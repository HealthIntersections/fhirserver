unit fhir3_resources_clinical;

{
  Copyright (c) 2011+, HL7 and Health Intersections Pty Ltd (http://www.healthintersections.com.au)
  All rights reserved.

  Redistribution and use in source and binary forms, with or without modification,
  are permitted provided that the following conditions are met:

   * Redistributions of source code must retain the above copyright notice, this
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice,
     this list of conditions and the following disclaimer in the documentation
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to
     endorse or promote products derived from this software without specific
     prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.

}

{$I fhir.inc}
{$I fhir3.inc}

interface

// FHIR v3.0.1 generated 2018-06-12T19:15:59+10:00

uses
  SysUtils, Classes,
  fsl_base, fsl_utilities, fsl_stream,
  fhir_objects, fhir_utilities, 
  fhir3_base, fhir3_types, fhir3_resources_base;

type
{$IFDEF FHIR_ACCOUNT}
  TFhirAccountCoverage = class;
  TFhirAccountCoverageList = class;
  TFhirAccountGuarantor = class;
  TFhirAccountGuarantorList = class;
  TFhirAccount = class;
  TFhirAccountList = class;
{$ENDIF FHIR_ACCOUNT}
{$IFDEF FHIR_ADVERSEEVENT}
  TFhirAdverseEventSuspectEntity = class;
  TFhirAdverseEventSuspectEntityList = class;
  TFhirAdverseEvent = class;
  TFhirAdverseEventList = class;
{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
  TFhirAllergyIntoleranceReaction = class;
  TFhirAllergyIntoleranceReactionList = class;
  TFhirAllergyIntolerance = class;
  TFhirAllergyIntoleranceList = class;
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
  TFhirAppointmentParticipant = class;
  TFhirAppointmentParticipantList = class;
  TFhirAppointment = class;
  TFhirAppointmentList = class;
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
  TFhirAppointmentResponse = class;
  TFhirAppointmentResponseList = class;
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_BASIC}
  TFhirBasic = class;
  TFhirBasicList = class;
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BODYSITE}
  TFhirBodySite = class;
  TFhirBodySiteList = class;
{$ENDIF FHIR_BODYSITE}
{$IFDEF FHIR_CAREPLAN}
  TFhirCarePlanActivity = class;
  TFhirCarePlanActivityList = class;
  TFhirCarePlanActivityDetail = class;
  TFhirCarePlanActivityDetailList = class;
  TFhirCarePlan = class;
  TFhirCarePlanList = class;
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
  TFhirCareTeamParticipant = class;
  TFhirCareTeamParticipantList = class;
  TFhirCareTeam = class;
  TFhirCareTeamList = class;
{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CLINICALIMPRESSION}
  TFhirClinicalImpressionInvestigation = class;
  TFhirClinicalImpressionInvestigationList = class;
  TFhirClinicalImpressionFinding = class;
  TFhirClinicalImpressionFindingList = class;
  TFhirClinicalImpression = class;
  TFhirClinicalImpressionList = class;
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_COMMUNICATION}
  TFhirCommunicationPayload = class;
  TFhirCommunicationPayloadList = class;
  TFhirCommunication = class;
  TFhirCommunicationList = class;
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
  TFhirCommunicationRequestPayload = class;
  TFhirCommunicationRequestPayloadList = class;
  TFhirCommunicationRequestRequester = class;
  TFhirCommunicationRequestRequesterList = class;
  TFhirCommunicationRequest = class;
  TFhirCommunicationRequestList = class;
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPOSITION}
  TFhirCompositionAttester = class;
  TFhirCompositionAttesterList = class;
  TFhirCompositionRelatesTo = class;
  TFhirCompositionRelatesToList = class;
  TFhirCompositionEvent = class;
  TFhirCompositionEventList = class;
  TFhirCompositionSection = class;
  TFhirCompositionSectionList = class;
  TFhirComposition = class;
  TFhirCompositionList = class;
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONDITION}
  TFhirConditionStage = class;
  TFhirConditionStageList = class;
  TFhirConditionEvidence = class;
  TFhirConditionEvidenceList = class;
  TFhirCondition = class;
  TFhirConditionList = class;
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_COVERAGE}
  TFhirCoverageGrouping = class;
  TFhirCoverageGroupingList = class;
  TFhirCoverage = class;
  TFhirCoverageList = class;
{$ENDIF FHIR_COVERAGE}
{$IFDEF FHIR_DETECTEDISSUE}
  TFhirDetectedIssueMitigation = class;
  TFhirDetectedIssueMitigationList = class;
  TFhirDetectedIssue = class;
  TFhirDetectedIssueList = class;
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICEREQUEST}
  TFhirDeviceRequestRequester = class;
  TFhirDeviceRequestRequesterList = class;
  TFhirDeviceRequest = class;
  TFhirDeviceRequestList = class;
{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
  TFhirDeviceUseStatement = class;
  TFhirDeviceUseStatementList = class;
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICREPORT}
  TFhirDiagnosticReportPerformer = class;
  TFhirDiagnosticReportPerformerList = class;
  TFhirDiagnosticReportImage = class;
  TFhirDiagnosticReportImageList = class;
  TFhirDiagnosticReport = class;
  TFhirDiagnosticReportList = class;
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
  TFhirDocumentManifestContent = class;
  TFhirDocumentManifestContentList = class;
  TFhirDocumentManifestRelated = class;
  TFhirDocumentManifestRelatedList = class;
  TFhirDocumentManifest = class;
  TFhirDocumentManifestList = class;
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
  TFhirDocumentReferenceRelatesTo = class;
  TFhirDocumentReferenceRelatesToList = class;
  TFhirDocumentReferenceContent = class;
  TFhirDocumentReferenceContentList = class;
  TFhirDocumentReferenceContext = class;
  TFhirDocumentReferenceContextList = class;
  TFhirDocumentReferenceContextRelated = class;
  TFhirDocumentReferenceContextRelatedList = class;
  TFhirDocumentReference = class;
  TFhirDocumentReferenceList = class;
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
  TFhirFamilyMemberHistoryCondition = class;
  TFhirFamilyMemberHistoryConditionList = class;
  TFhirFamilyMemberHistory = class;
  TFhirFamilyMemberHistoryList = class;
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
  TFhirFlag = class;
  TFhirFlagList = class;
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
  TFhirGoalTarget = class;
  TFhirGoalTargetList = class;
  TFhirGoal = class;
  TFhirGoalList = class;
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_IMAGINGMANIFEST}
  TFhirImagingManifestStudy = class;
  TFhirImagingManifestStudyList = class;
  TFhirImagingManifestStudySeries = class;
  TFhirImagingManifestStudySeriesList = class;
  TFhirImagingManifestStudySeriesInstance = class;
  TFhirImagingManifestStudySeriesInstanceList = class;
  TFhirImagingManifest = class;
  TFhirImagingManifestList = class;
{$ENDIF FHIR_IMAGINGMANIFEST}
{$IFDEF FHIR_IMAGINGSTUDY}
  TFhirImagingStudySeries = class;
  TFhirImagingStudySeriesList = class;
  TFhirImagingStudySeriesInstance = class;
  TFhirImagingStudySeriesInstanceList = class;
  TFhirImagingStudy = class;
  TFhirImagingStudyList = class;
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
  TFhirImmunizationPractitioner = class;
  TFhirImmunizationPractitionerList = class;
  TFhirImmunizationExplanation = class;
  TFhirImmunizationExplanationList = class;
  TFhirImmunizationReaction = class;
  TFhirImmunizationReactionList = class;
  TFhirImmunizationVaccinationProtocol = class;
  TFhirImmunizationVaccinationProtocolList = class;
  TFhirImmunization = class;
  TFhirImmunizationList = class;
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
  TFhirImmunizationRecommendationRecommendation = class;
  TFhirImmunizationRecommendationRecommendationList = class;
  TFhirImmunizationRecommendationRecommendationDateCriterion = class;
  TFhirImmunizationRecommendationRecommendationDateCriterionList = class;
  TFhirImmunizationRecommendationRecommendationProtocol = class;
  TFhirImmunizationRecommendationRecommendationProtocolList = class;
  TFhirImmunizationRecommendation = class;
  TFhirImmunizationRecommendationList = class;
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_MEDIA}
  TFhirMedia = class;
  TFhirMediaList = class;
{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
  TFhirMedicationAdministrationPerformer = class;
  TFhirMedicationAdministrationPerformerList = class;
  TFhirMedicationAdministrationDosage = class;
  TFhirMedicationAdministrationDosageList = class;
  TFhirMedicationAdministration = class;
  TFhirMedicationAdministrationList = class;
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
  TFhirMedicationDispensePerformer = class;
  TFhirMedicationDispensePerformerList = class;
  TFhirMedicationDispenseSubstitution = class;
  TFhirMedicationDispenseSubstitutionList = class;
  TFhirMedicationDispense = class;
  TFhirMedicationDispenseList = class;
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONREQUEST}
  TFhirMedicationRequestRequester = class;
  TFhirMedicationRequestRequesterList = class;
  TFhirMedicationRequestDispenseRequest = class;
  TFhirMedicationRequestDispenseRequestList = class;
  TFhirMedicationRequestSubstitution = class;
  TFhirMedicationRequestSubstitutionList = class;
  TFhirMedicationRequest = class;
  TFhirMedicationRequestList = class;
{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
  TFhirMedicationStatement = class;
  TFhirMedicationStatementList = class;
{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_NUTRITIONORDER}
  TFhirNutritionOrderOralDiet = class;
  TFhirNutritionOrderOralDietList = class;
  TFhirNutritionOrderOralDietNutrient = class;
  TFhirNutritionOrderOralDietNutrientList = class;
  TFhirNutritionOrderOralDietTexture = class;
  TFhirNutritionOrderOralDietTextureList = class;
  TFhirNutritionOrderSupplement = class;
  TFhirNutritionOrderSupplementList = class;
  TFhirNutritionOrderEnteralFormula = class;
  TFhirNutritionOrderEnteralFormulaList = class;
  TFhirNutritionOrderEnteralFormulaAdministration = class;
  TFhirNutritionOrderEnteralFormulaAdministrationList = class;
  TFhirNutritionOrder = class;
  TFhirNutritionOrderList = class;
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
  TFhirObservationReferenceRange = class;
  TFhirObservationReferenceRangeList = class;
  TFhirObservationRelated = class;
  TFhirObservationRelatedList = class;
  TFhirObservationComponent = class;
  TFhirObservationComponentList = class;
  TFhirObservation = class;
  TFhirObservationList = class;
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_PROCEDURE}
  TFhirProcedurePerformer = class;
  TFhirProcedurePerformerList = class;
  TFhirProcedureFocalDevice = class;
  TFhirProcedureFocalDeviceList = class;
  TFhirProcedure = class;
  TFhirProcedureList = class;
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_PROCEDUREREQUEST}
  TFhirProcedureRequestRequester = class;
  TFhirProcedureRequestRequesterList = class;
  TFhirProcedureRequest = class;
  TFhirProcedureRequestList = class;
{$ENDIF FHIR_PROCEDUREREQUEST}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
  TFhirQuestionnaireResponseItem = class;
  TFhirQuestionnaireResponseItemList = class;
  TFhirQuestionnaireResponseItemAnswer = class;
  TFhirQuestionnaireResponseItemAnswerList = class;
  TFhirQuestionnaireResponse = class;
  TFhirQuestionnaireResponseList = class;
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REFERRALREQUEST}
  TFhirReferralRequestRequester = class;
  TFhirReferralRequestRequesterList = class;
  TFhirReferralRequest = class;
  TFhirReferralRequestList = class;
{$ENDIF FHIR_REFERRALREQUEST}
{$IFDEF FHIR_RISKASSESSMENT}
  TFhirRiskAssessmentPrediction = class;
  TFhirRiskAssessmentPredictionList = class;
  TFhirRiskAssessment = class;
  TFhirRiskAssessmentList = class;
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SEQUENCE}
  TFhirSequenceReferenceSeq = class;
  TFhirSequenceReferenceSeqList = class;
  TFhirSequenceVariant = class;
  TFhirSequenceVariantList = class;
  TFhirSequenceQuality = class;
  TFhirSequenceQualityList = class;
  TFhirSequenceRepository = class;
  TFhirSequenceRepositoryList = class;
  TFhirSequence = class;
  TFhirSequenceList = class;
{$ENDIF FHIR_SEQUENCE}
{$IFDEF FHIR_SPECIMEN}
  TFhirSpecimenCollection = class;
  TFhirSpecimenCollectionList = class;
  TFhirSpecimenProcessing = class;
  TFhirSpecimenProcessingList = class;
  TFhirSpecimenContainer = class;
  TFhirSpecimenContainerList = class;
  TFhirSpecimen = class;
  TFhirSpecimenList = class;
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_SUPPLYDELIVERY}
  TFhirSupplyDeliverySuppliedItem = class;
  TFhirSupplyDeliverySuppliedItemList = class;
  TFhirSupplyDelivery = class;
  TFhirSupplyDeliveryList = class;
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
  TFhirSupplyRequestOrderedItem = class;
  TFhirSupplyRequestOrderedItemList = class;
  TFhirSupplyRequestRequester = class;
  TFhirSupplyRequestRequesterList = class;
  TFhirSupplyRequest = class;
  TFhirSupplyRequestList = class;
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_VISIONPRESCRIPTION}
  TFhirVisionPrescriptionDispense = class;
  TFhirVisionPrescriptionDispenseList = class;
  TFhirVisionPrescription = class;
  TFhirVisionPrescriptionList = class;
{$ENDIF FHIR_VISIONPRESCRIPTION}

{$IFDEF FHIR_ACCOUNT}

  // The party(s) that are responsible for covering the payment of this account, and what order should they be applied to the account.
  TFhirAccountCoverage = class (TFhirBackboneElement)
  protected
    FCoverage : TFhirReference{TFhirCoverage};
    FPriority : TFhirPositiveInt;
    Procedure SetCoverage(value : TFhirReference{TFhirCoverage});
    Procedure SetPriority(value : TFhirPositiveInt);
    Function GetPriorityST : String;
    Procedure SetPriorityST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAccountCoverage; overload;
    function Clone : TFhirAccountCoverage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The party(s) that are responsible for payment (or part of) of charges applied to this account (including self-pay).  A coverage may only be resposible for specific types of charges, and the sequence of the coverages in the account could be important when processing billing. (defined for API consistency)
    property coverage : TFhirReference{TFhirCoverage} read FCoverage write SetCoverage;
    // The party(s) that are responsible for payment (or part of) of charges applied to this account (including self-pay).  A coverage may only be resposible for specific types of charges, and the sequence of the coverages in the account could be important when processing billing.
    property coverageElement : TFhirReference{TFhirCoverage} read FCoverage write SetCoverage;

    // Typed access to The priority of the coverage in the context of this account.
    property priority : String read GetPriorityST write SetPriorityST;
    // The priority of the coverage in the context of this account.
    property priorityElement : TFhirPositiveInt read FPriority write SetPriority;

  end;

  TFhirAccountCoverageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAccountCoverageList;
    function GetCurrent : TFhirAccountCoverage;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAccountCoverageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAccountCoverage read GetCurrent;
  end;

  TFhirAccountCoverageList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirAccountCoverage;
    procedure SetItemN(index : Integer; value : TFhirAccountCoverage);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirAccountCoverageList; Overload;
    function Clone : TFhirAccountCoverageList; Overload;
    function GetEnumerator : TFhirAccountCoverageListEnumerator;

    //  Add a FhirAccountCoverage to the end of the list.
    function Append : TFhirAccountCoverage;

    // Add an already existing FhirAccountCoverage to the end of the list.
    procedure AddItem(value : TFhirAccountCoverage); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAccountCoverage) : Integer;

    // Insert FhirAccountCoverage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAccountCoverage;

    // Insert an existing FhirAccountCoverage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAccountCoverage);

    // Get the iIndexth FhirAccountCoverage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAccountCoverage);

    // The number of items in the collection
    function Item(index : Integer) : TFhirAccountCoverage;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirAccountCoverages[index : Integer] : TFhirAccountCoverage read GetItemN write SetItemN; default;
  End;

  // Parties financially responsible for the account.
  TFhirAccountGuarantor = class (TFhirBackboneElement)
  protected
    FParty : TFhirReference{Resource};
    FOnHold : TFhirBoolean;
    FPeriod : TFhirPeriod;
    Procedure SetParty(value : TFhirReference{Resource});
    Procedure SetOnHold(value : TFhirBoolean);
    Function GetOnHoldST : Boolean;
    Procedure SetOnHoldST(value : Boolean);
    Procedure SetPeriod(value : TFhirPeriod);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAccountGuarantor; overload;
    function Clone : TFhirAccountGuarantor; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The entity who is responsible. (defined for API consistency)
    property party : TFhirReference{Resource} read FParty write SetParty;
    // The entity who is responsible.
    property partyElement : TFhirReference{Resource} read FParty write SetParty;

    // Typed access to A guarantor may be placed on credit hold or otherwise have their role temporarily suspended.
    property onHold : Boolean read GetOnHoldST write SetOnHoldST;
    // A guarantor may be placed on credit hold or otherwise have their role temporarily suspended.
    property onHoldElement : TFhirBoolean read FOnHold write SetOnHold;

    // Typed access to The timeframe during which the guarantor accepts responsibility for the account. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The timeframe during which the guarantor accepts responsibility for the account.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirAccountGuarantorListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAccountGuarantorList;
    function GetCurrent : TFhirAccountGuarantor;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAccountGuarantorList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAccountGuarantor read GetCurrent;
  end;

  TFhirAccountGuarantorList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirAccountGuarantor;
    procedure SetItemN(index : Integer; value : TFhirAccountGuarantor);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirAccountGuarantorList; Overload;
    function Clone : TFhirAccountGuarantorList; Overload;
    function GetEnumerator : TFhirAccountGuarantorListEnumerator;

    //  Add a FhirAccountGuarantor to the end of the list.
    function Append : TFhirAccountGuarantor;

    // Add an already existing FhirAccountGuarantor to the end of the list.
    procedure AddItem(value : TFhirAccountGuarantor); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAccountGuarantor) : Integer;

    // Insert FhirAccountGuarantor before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAccountGuarantor;

    // Insert an existing FhirAccountGuarantor before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAccountGuarantor);

    // Get the iIndexth FhirAccountGuarantor. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAccountGuarantor);

    // The number of items in the collection
    function Item(index : Integer) : TFhirAccountGuarantor;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirAccountGuarantors[index : Integer] : TFhirAccountGuarantor read GetItemN write SetItemN; default;
  End;

  // A financial tool for tracking value accrued for a particular purpose.  In the healthcare field, used to track charges for a patient, cost centers, etc.
  TFhirAccount = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FType_ : TFhirCodeableConcept;
    FName : TFhirString;
    FSubject : TFhirReference{Resource};
    FPeriod : TFhirPeriod;
    FActive : TFhirPeriod;
    FBalance : TFhirMoney;
    FcoverageList : TFhirAccountCoverageList;
    FOwner : TFhirReference{TFhirOrganization};
    FDescription : TFhirString;
    FguarantorList : TFhirAccountGuarantorList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirAccountStatusEnum;
    Procedure SetStatusST(value : TFhirAccountStatusEnum);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetSubject(value : TFhirReference{Resource});
    Procedure SetPeriod(value : TFhirPeriod);
    Procedure SetActive(value : TFhirPeriod);
    Procedure SetBalance(value : TFhirMoney);
    function GetCoverageList : TFhirAccountCoverageList;
    function GetHasCoverageList : Boolean;
    Procedure SetOwner(value : TFhirReference{TFhirOrganization});
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    function GetGuarantorList : TFhirAccountGuarantorList;
    function GetHasGuarantorList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAccount; overload;
    function Clone : TFhirAccount; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Unique identifier used to reference the account.  May or may not be intended for human use (e.g. credit card number).
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Indicates whether the account is presently used/usable or not.
    property status : TFhirAccountStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Categorizes the account for reporting and searching purposes. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Categorizes the account for reporting and searching purposes.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Name used for the account when displaying it to humans in reports, etc.
    property name : String read GetNameST write SetNameST;
    // Name used for the account when displaying it to humans in reports, etc.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Identifies the patient, device, practitioner, location or other object the account is associated with. (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // Identifies the patient, device, practitioner, location or other object the account is associated with.
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // Typed access to Identifies the period of time the account applies to; e.g. accounts created per fiscal year, quarter, etc. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Identifies the period of time the account applies to; e.g. accounts created per fiscal year, quarter, etc.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to Indicates the period of time over which the account is allowed to have transactions posted to it. This period may be different to the coveragePeriod which is the duration of time that services may occur. (defined for API consistency)
    property active : TFhirPeriod read FActive write SetActive;
    // Indicates the period of time over which the account is allowed to have transactions posted to it. This period may be different to the coveragePeriod which is the duration of time that services may occur.
    property activeElement : TFhirPeriod read FActive write SetActive;

    // Typed access to Represents the sum of all credits less all debits associated with the account.  Might be positive, zero or negative. (defined for API consistency)
    property balance : TFhirMoney read FBalance write SetBalance;
    // Represents the sum of all credits less all debits associated with the account.  Might be positive, zero or negative.
    property balanceElement : TFhirMoney read FBalance write SetBalance;

    // The party(s) that are responsible for covering the payment of this account, and what order should they be applied to the account.
    property coverageList : TFhirAccountCoverageList read GetCoverageList;
    property hasCoverageList : boolean read GetHasCoverageList;

    // Typed access to Indicates the organization, department, etc. with responsibility for the account. (defined for API consistency)
    property owner : TFhirReference{TFhirOrganization} read FOwner write SetOwner;
    // Indicates the organization, department, etc. with responsibility for the account.
    property ownerElement : TFhirReference{TFhirOrganization} read FOwner write SetOwner;

    // Typed access to Provides additional information about what the account tracks and how it is used.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Provides additional information about what the account tracks and how it is used.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Parties financially responsible for the account.
    property guarantorList : TFhirAccountGuarantorList read GetGuarantorList;
    property hasGuarantorList : boolean read GetHasGuarantorList;

  end;

  TFhirAccountListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAccountList;
    function GetCurrent : TFhirAccount;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAccountList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAccount read GetCurrent;
  end;

  TFhirAccountList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirAccount;
    procedure SetItemN(index : Integer; value : TFhirAccount);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirAccountList; Overload;
    function Clone : TFhirAccountList; Overload;
    function GetEnumerator : TFhirAccountListEnumerator;

    //  Add a FhirAccount to the end of the list.
    function Append : TFhirAccount;

    // Add an already existing FhirAccount to the end of the list.
    procedure AddItem(value : TFhirAccount); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAccount) : Integer;

    // Insert FhirAccount before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAccount;

    // Insert an existing FhirAccount before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAccount);

    // Get the iIndexth FhirAccount. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAccount);

    // The number of items in the collection
    function Item(index : Integer) : TFhirAccount;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirAccounts[index : Integer] : TFhirAccount read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ACCOUNT}

{$IFDEF FHIR_ADVERSEEVENT}

  // Describes the entity that is suspected to have caused the adverse event.
  TFhirAdverseEventSuspectEntity = class (TFhirBackboneElement)
  protected
    FInstance : TFhirReference{Resource};
    FCausality : TFhirEnum;
    FCausalityAssessment : TFhirCodeableConcept;
    FCausalityProductRelatedness : TFhirString;
    FCausalityMethod : TFhirCodeableConcept;
    FCausalityAuthor : TFhirReference{Resource};
    FCausalityResult : TFhirCodeableConcept;
    Procedure SetInstance(value : TFhirReference{Resource});
    Procedure SetCausality(value : TFhirEnum);
    Function GetCausalityST : TFhirAdverseEventCausalityEnum;
    Procedure SetCausalityST(value : TFhirAdverseEventCausalityEnum);
    Procedure SetCausalityAssessment(value : TFhirCodeableConcept);
    Procedure SetCausalityProductRelatedness(value : TFhirString);
    Function GetCausalityProductRelatednessST : String;
    Procedure SetCausalityProductRelatednessST(value : String);
    Procedure SetCausalityMethod(value : TFhirCodeableConcept);
    Procedure SetCausalityAuthor(value : TFhirReference{Resource});
    Procedure SetCausalityResult(value : TFhirCodeableConcept);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAdverseEventSuspectEntity; overload;
    function Clone : TFhirAdverseEventSuspectEntity; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Identifies the actual instance of what caused the adverse event.  May be a substance, medication, medication administration, medication statement or a device. (defined for API consistency)
    property instance : TFhirReference{Resource} read FInstance write SetInstance;
    // Identifies the actual instance of what caused the adverse event.  May be a substance, medication, medication administration, medication statement or a device.
    property instanceElement : TFhirReference{Resource} read FInstance write SetInstance;

    // causality1 | causality2.
    property causality : TFhirAdverseEventCausalityEnum read GetCausalityST write SetCausalityST;
    property causalityElement : TFhirEnum read FCausality write SetCausality;

    // Typed access to assess1 | assess2. (defined for API consistency)
    property causalityAssessment : TFhirCodeableConcept read FCausalityAssessment write SetCausalityAssessment;
    // assess1 | assess2.
    property causalityAssessmentElement : TFhirCodeableConcept read FCausalityAssessment write SetCausalityAssessment;

    // Typed access to AdverseEvent.suspectEntity.causalityProductRelatedness.
    property causalityProductRelatedness : String read GetCausalityProductRelatednessST write SetCausalityProductRelatednessST;
    // AdverseEvent.suspectEntity.causalityProductRelatedness.
    property causalityProductRelatednessElement : TFhirString read FCausalityProductRelatedness write SetCausalityProductRelatedness;

    // Typed access to method1 | method2. (defined for API consistency)
    property causalityMethod : TFhirCodeableConcept read FCausalityMethod write SetCausalityMethod;
    // method1 | method2.
    property causalityMethodElement : TFhirCodeableConcept read FCausalityMethod write SetCausalityMethod;

    // Typed access to AdverseEvent.suspectEntity.causalityAuthor. (defined for API consistency)
    property causalityAuthor : TFhirReference{Resource} read FCausalityAuthor write SetCausalityAuthor;
    // AdverseEvent.suspectEntity.causalityAuthor.
    property causalityAuthorElement : TFhirReference{Resource} read FCausalityAuthor write SetCausalityAuthor;

    // Typed access to result1 | result2. (defined for API consistency)
    property causalityResult : TFhirCodeableConcept read FCausalityResult write SetCausalityResult;
    // result1 | result2.
    property causalityResultElement : TFhirCodeableConcept read FCausalityResult write SetCausalityResult;

  end;

  TFhirAdverseEventSuspectEntityListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAdverseEventSuspectEntityList;
    function GetCurrent : TFhirAdverseEventSuspectEntity;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAdverseEventSuspectEntityList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAdverseEventSuspectEntity read GetCurrent;
  end;

  TFhirAdverseEventSuspectEntityList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirAdverseEventSuspectEntity;
    procedure SetItemN(index : Integer; value : TFhirAdverseEventSuspectEntity);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirAdverseEventSuspectEntityList; Overload;
    function Clone : TFhirAdverseEventSuspectEntityList; Overload;
    function GetEnumerator : TFhirAdverseEventSuspectEntityListEnumerator;

    //  Add a FhirAdverseEventSuspectEntity to the end of the list.
    function Append : TFhirAdverseEventSuspectEntity;

    // Add an already existing FhirAdverseEventSuspectEntity to the end of the list.
    procedure AddItem(value : TFhirAdverseEventSuspectEntity); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAdverseEventSuspectEntity) : Integer;

    // Insert FhirAdverseEventSuspectEntity before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAdverseEventSuspectEntity;

    // Insert an existing FhirAdverseEventSuspectEntity before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAdverseEventSuspectEntity);

    // Get the iIndexth FhirAdverseEventSuspectEntity. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAdverseEventSuspectEntity);

    // The number of items in the collection
    function Item(index : Integer) : TFhirAdverseEventSuspectEntity;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirAdverseEventSuspectEntities[index : Integer] : TFhirAdverseEventSuspectEntity read GetItemN write SetItemN; default;
  End;

  // Actual or  potential/avoided event causing unintended physical injury resulting from or contributed to by medical care, a research study or other healthcare setting factors that requires additional monitoring, treatment, or hospitalization, or that results in death.
  TFhirAdverseEvent = class (TFhirDomainResource)
  protected
    FIdentifier : TFhirIdentifier;
    FCategory : TFhirEnum;
    FType_ : TFhirCodeableConcept;
    FSubject : TFhirReference{Resource};
    FDate : TFhirDateTime;
    FreactionList : TFhirReferenceList{TFhirCondition};
    FLocation : TFhirReference{TFhirLocation};
    FSeriousness : TFhirCodeableConcept;
    FOutcome : TFhirCodeableConcept;
    FRecorder : TFhirReference{Resource};
    FEventParticipant : TFhirReference{Resource};
    FDescription : TFhirString;
    FsuspectEntityList : TFhirAdverseEventSuspectEntityList;
    FsubjectMedicalHistoryList : TFhirReferenceList{Resource};
    FreferenceDocumentList : TFhirReferenceList{TFhirDocumentReference};
    FstudyList : TFhirReferenceList{TFhirResearchStudy};
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetCategory(value : TFhirEnum);
    Function GetCategoryST : TFhirAdverseEventCategoryEnum;
    Procedure SetCategoryST(value : TFhirAdverseEventCategoryEnum);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetSubject(value : TFhirReference{Resource});
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    function GetReactionList : TFhirReferenceList{TFhirCondition};
    function GetHasReactionList : Boolean;
    Procedure SetLocation(value : TFhirReference{TFhirLocation});
    Procedure SetSeriousness(value : TFhirCodeableConcept);
    Procedure SetOutcome(value : TFhirCodeableConcept);
    Procedure SetRecorder(value : TFhirReference{Resource});
    Procedure SetEventParticipant(value : TFhirReference{Resource});
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    function GetSuspectEntityList : TFhirAdverseEventSuspectEntityList;
    function GetHasSuspectEntityList : Boolean;
    function GetSubjectMedicalHistoryList : TFhirReferenceList{Resource};
    function GetHasSubjectMedicalHistoryList : Boolean;
    function GetReferenceDocumentList : TFhirReferenceList{TFhirDocumentReference};
    function GetHasReferenceDocumentList : Boolean;
    function GetStudyList : TFhirReferenceList{TFhirResearchStudy};
    function GetHasStudyList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAdverseEvent; overload;
    function Clone : TFhirAdverseEvent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The identifier(s) of this adverse event that are assigned by business processes and/or used to refer to it when a direct URL reference to the resource itsefl is not appropriate. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // The identifier(s) of this adverse event that are assigned by business processes and/or used to refer to it when a direct URL reference to the resource itsefl is not appropriate.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // The type of event which is important to characterize what occurred and caused harm to the subject, or had the potential to cause harm to the subject.
    property category : TFhirAdverseEventCategoryEnum read GetCategoryST write SetCategoryST;
    property categoryElement : TFhirEnum read FCategory write SetCategory;

    // Typed access to This element defines the specific type of event that occurred or that was prevented from occurring. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // This element defines the specific type of event that occurred or that was prevented from occurring.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to This subject or group impacted by the event.  With a prospective adverse event, there will be no subject as the adverse event was prevented. (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // This subject or group impacted by the event.  With a prospective adverse event, there will be no subject as the adverse event was prevented.
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // Typed access to The date (and perhaps time) when the adverse event occurred.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date (and perhaps time) when the adverse event occurred.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Includes information about the reaction that occurred as a result of exposure to a substance (for example, a drug or a chemical).
    property reactionList : TFhirReferenceList{TFhirCondition} read GetReactionList;
    property hasReactionList : boolean read GetHasReactionList;

    // Typed access to The information about where the adverse event occurred. (defined for API consistency)
    property location : TFhirReference{TFhirLocation} read FLocation write SetLocation;
    // The information about where the adverse event occurred.
    property locationElement : TFhirReference{TFhirLocation} read FLocation write SetLocation;

    // Typed access to Describes the seriousness or severity of the adverse event. (defined for API consistency)
    property seriousness : TFhirCodeableConcept read FSeriousness write SetSeriousness;
    // Describes the seriousness or severity of the adverse event.
    property seriousnessElement : TFhirCodeableConcept read FSeriousness write SetSeriousness;

    // Typed access to Describes the type of outcome from the adverse event. (defined for API consistency)
    property outcome : TFhirCodeableConcept read FOutcome write SetOutcome;
    // Describes the type of outcome from the adverse event.
    property outcomeElement : TFhirCodeableConcept read FOutcome write SetOutcome;

    // Typed access to Information on who recorded the adverse event.  May be the patient or a practitioner. (defined for API consistency)
    property recorder : TFhirReference{Resource} read FRecorder write SetRecorder;
    // Information on who recorded the adverse event.  May be the patient or a practitioner.
    property recorderElement : TFhirReference{Resource} read FRecorder write SetRecorder;

    // Typed access to Parties that may or should contribute or have contributed information to the Act. Such information includes information leading to the decision to perform the Act and how to perform the Act (e.g. consultant), information that the Act itself seeks to reveal (e.g. informant of clinical history), or information about what Act was performed (e.g. informant witness). (defined for API consistency)
    property eventParticipant : TFhirReference{Resource} read FEventParticipant write SetEventParticipant;
    // Parties that may or should contribute or have contributed information to the Act. Such information includes information leading to the decision to perform the Act and how to perform the Act (e.g. consultant), information that the Act itself seeks to reveal (e.g. informant of clinical history), or information about what Act was performed (e.g. informant witness).
    property eventParticipantElement : TFhirReference{Resource} read FEventParticipant write SetEventParticipant;

    // Typed access to Describes the adverse event in text.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Describes the adverse event in text.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Describes the entity that is suspected to have caused the adverse event.
    property suspectEntityList : TFhirAdverseEventSuspectEntityList read GetSuspectEntityList;
    property hasSuspectEntityList : boolean read GetHasSuspectEntityList;

    // AdverseEvent.subjectMedicalHistory.
    property subjectMedicalHistoryList : TFhirReferenceList{Resource} read GetSubjectMedicalHistoryList;
    property hasSubjectMedicalHistoryList : boolean read GetHasSubjectMedicalHistoryList;

    // AdverseEvent.referenceDocument.
    property referenceDocumentList : TFhirReferenceList{TFhirDocumentReference} read GetReferenceDocumentList;
    property hasReferenceDocumentList : boolean read GetHasReferenceDocumentList;

    // AdverseEvent.study.
    property studyList : TFhirReferenceList{TFhirResearchStudy} read GetStudyList;
    property hasStudyList : boolean read GetHasStudyList;

  end;

  TFhirAdverseEventListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAdverseEventList;
    function GetCurrent : TFhirAdverseEvent;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAdverseEventList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAdverseEvent read GetCurrent;
  end;

  TFhirAdverseEventList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirAdverseEvent;
    procedure SetItemN(index : Integer; value : TFhirAdverseEvent);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirAdverseEventList; Overload;
    function Clone : TFhirAdverseEventList; Overload;
    function GetEnumerator : TFhirAdverseEventListEnumerator;

    //  Add a FhirAdverseEvent to the end of the list.
    function Append : TFhirAdverseEvent;

    // Add an already existing FhirAdverseEvent to the end of the list.
    procedure AddItem(value : TFhirAdverseEvent); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAdverseEvent) : Integer;

    // Insert FhirAdverseEvent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAdverseEvent;

    // Insert an existing FhirAdverseEvent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAdverseEvent);

    // Get the iIndexth FhirAdverseEvent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAdverseEvent);

    // The number of items in the collection
    function Item(index : Integer) : TFhirAdverseEvent;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirAdverseEvents[index : Integer] : TFhirAdverseEvent read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ADVERSEEVENT}

{$IFDEF FHIR_ALLERGYINTOLERANCE}

  // Details about each adverse reaction event linked to exposure to the identified substance.
  TFhirAllergyIntoleranceReaction = class (TFhirBackboneElement)
  protected
    FSubstance : TFhirCodeableConcept;
    FmanifestationList : TFhirCodeableConceptList;
    FDescription : TFhirString;
    FOnset : TFhirDateTime;
    FSeverity : TFhirEnum;
    FExposureRoute : TFhirCodeableConcept;
    FnoteList : TFhirAnnotationList;
    Procedure SetSubstance(value : TFhirCodeableConcept);
    function GetManifestationList : TFhirCodeableConceptList;
    function GetHasManifestationList : Boolean;
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetOnset(value : TFhirDateTime);
    Function GetOnsetST : TFslDateTime;
    Procedure SetOnsetST(value : TFslDateTime);
    Procedure SetSeverity(value : TFhirEnum);
    Function GetSeverityST : TFhirReactionEventSeverityEnum;
    Procedure SetSeverityST(value : TFhirReactionEventSeverityEnum);
    Procedure SetExposureRoute(value : TFhirCodeableConcept);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAllergyIntoleranceReaction; overload;
    function Clone : TFhirAllergyIntoleranceReaction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Identification of the specific substance (or pharmaceutical product) considered to be responsible for the Adverse Reaction event. Note: the substance for a specific reaction may be different from the substance identified as the cause of the risk, but it must be consistent with it. For instance, it may be a more specific substance (e.g. a brand medication) or a composite product that includes the identified substance. It must be clinically safe to only process the 'code' and ignore the 'reaction.substance'. (defined for API consistency)
    property substance : TFhirCodeableConcept read FSubstance write SetSubstance;
    // Identification of the specific substance (or pharmaceutical product) considered to be responsible for the Adverse Reaction event. Note: the substance for a specific reaction may be different from the substance identified as the cause of the risk, but it must be consistent with it. For instance, it may be a more specific substance (e.g. a brand medication) or a composite product that includes the identified substance. It must be clinically safe to only process the 'code' and ignore the 'reaction.substance'.
    property substanceElement : TFhirCodeableConcept read FSubstance write SetSubstance;

    // Clinical symptoms and/or signs that are observed or associated with the adverse reaction event.
    property manifestationList : TFhirCodeableConceptList read GetManifestationList;
    property hasManifestationList : boolean read GetHasManifestationList;

    // Typed access to Text description about the reaction as a whole, including details of the manifestation if required.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Text description about the reaction as a whole, including details of the manifestation if required.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Record of the date and/or time of the onset of the Reaction.
    property onset : TFslDateTime read GetOnsetST write SetOnsetST;
    // Record of the date and/or time of the onset of the Reaction.
    property onsetElement : TFhirDateTime read FOnset write SetOnset;

    // Clinical assessment of the severity of the reaction event as a whole, potentially considering multiple different manifestations.
    property severity : TFhirReactionEventSeverityEnum read GetSeverityST write SetSeverityST;
    property severityElement : TFhirEnum read FSeverity write SetSeverity;

    // Typed access to Identification of the route by which the subject was exposed to the substance. (defined for API consistency)
    property exposureRoute : TFhirCodeableConcept read FExposureRoute write SetExposureRoute;
    // Identification of the route by which the subject was exposed to the substance.
    property exposureRouteElement : TFhirCodeableConcept read FExposureRoute write SetExposureRoute;

    // Additional text about the adverse reaction event not captured in other fields.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirAllergyIntoleranceReactionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAllergyIntoleranceReactionList;
    function GetCurrent : TFhirAllergyIntoleranceReaction;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAllergyIntoleranceReactionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAllergyIntoleranceReaction read GetCurrent;
  end;

  TFhirAllergyIntoleranceReactionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirAllergyIntoleranceReaction;
    procedure SetItemN(index : Integer; value : TFhirAllergyIntoleranceReaction);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirAllergyIntoleranceReactionList; Overload;
    function Clone : TFhirAllergyIntoleranceReactionList; Overload;
    function GetEnumerator : TFhirAllergyIntoleranceReactionListEnumerator;

    //  Add a FhirAllergyIntoleranceReaction to the end of the list.
    function Append : TFhirAllergyIntoleranceReaction;

    // Add an already existing FhirAllergyIntoleranceReaction to the end of the list.
    procedure AddItem(value : TFhirAllergyIntoleranceReaction); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAllergyIntoleranceReaction) : Integer;

    // Insert FhirAllergyIntoleranceReaction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAllergyIntoleranceReaction;

    // Insert an existing FhirAllergyIntoleranceReaction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAllergyIntoleranceReaction);

    // Get the iIndexth FhirAllergyIntoleranceReaction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAllergyIntoleranceReaction);

    // The number of items in the collection
    function Item(index : Integer) : TFhirAllergyIntoleranceReaction;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirAllergyIntoleranceReactions[index : Integer] : TFhirAllergyIntoleranceReaction read GetItemN write SetItemN; default;
  End;

  // Risk of harmful or undesirable, physiological response which is unique to an individual and associated with exposure to a substance.
  TFhirAllergyIntolerance = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FClinicalStatus : TFhirEnum;
    FVerificationStatus : TFhirEnum;
    FType_ : TFhirEnum;
    FCategory : TFhirEnumList;
    FCriticality : TFhirEnum;
    FCode : TFhirCodeableConcept;
    FPatient : TFhirReference{TFhirPatient};
    FOnset : TFhirType;
    FAssertedDate : TFhirDateTime;
    FRecorder : TFhirReference{Resource};
    FAsserter : TFhirReference{Resource};
    FLastOccurrence : TFhirDateTime;
    FnoteList : TFhirAnnotationList;
    FreactionList : TFhirAllergyIntoleranceReactionList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetClinicalStatus(value : TFhirEnum);
    Function GetClinicalStatusST : TFhirAllergyClinicalStatusEnum;
    Procedure SetClinicalStatusST(value : TFhirAllergyClinicalStatusEnum);
    Procedure SetVerificationStatus(value : TFhirEnum);
    Function GetVerificationStatusST : TFhirAllergyVerificationStatusEnum;
    Procedure SetVerificationStatusST(value : TFhirAllergyVerificationStatusEnum);
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirAllergyIntoleranceTypeEnum;
    Procedure SetType_ST(value : TFhirAllergyIntoleranceTypeEnum);
    function GetCategory : TFhirEnumList;
    function GetHasCategory : Boolean;
    Function GetCategoryST : TFhirAllergyIntoleranceCategoryEnumList;
    Procedure SetCategoryST(value : TFhirAllergyIntoleranceCategoryEnumList);
    Procedure SetCriticality(value : TFhirEnum);
    Function GetCriticalityST : TFhirAllergyIntoleranceCriticalityEnum;
    Procedure SetCriticalityST(value : TFhirAllergyIntoleranceCriticalityEnum);
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    Procedure SetOnset(value : TFhirType);
    Procedure SetAssertedDate(value : TFhirDateTime);
    Function GetAssertedDateST : TFslDateTime;
    Procedure SetAssertedDateST(value : TFslDateTime);
    Procedure SetRecorder(value : TFhirReference{Resource});
    Procedure SetAsserter(value : TFhirReference{Resource});
    Procedure SetLastOccurrence(value : TFhirDateTime);
    Function GetLastOccurrenceST : TFslDateTime;
    Procedure SetLastOccurrenceST(value : TFslDateTime);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetReactionList : TFhirAllergyIntoleranceReactionList;
    function GetHasReactionList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAllergyIntolerance; overload;
    function Clone : TFhirAllergyIntolerance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // This records identifiers associated with this allergy/intolerance concern that are defined by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate (e.g. in CDA documents, or in written / printed documentation).
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The clinical status of the allergy or intolerance.
    property clinicalStatus : TFhirAllergyClinicalStatusEnum read GetClinicalStatusST write SetClinicalStatusST;
    property clinicalStatusElement : TFhirEnum read FClinicalStatus write SetClinicalStatus;

    // Assertion about certainty associated with the propensity, or potential risk, of a reaction to the identified substance (including pharmaceutical product).
    property verificationStatus : TFhirAllergyVerificationStatusEnum read GetVerificationStatusST write SetVerificationStatusST;
    property verificationStatusElement : TFhirEnum read FVerificationStatus write SetVerificationStatus;

    // Identification of the underlying physiological mechanism for the reaction risk.
    property type_ : TFhirAllergyIntoleranceTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Category of the identified substance.
    property category : TFhirAllergyIntoleranceCategoryEnumList read GetCategoryST write SetCategoryST;
    property categoryList : TFhirEnumList read GetCategory;
    property hasCategory : boolean read GetHasCategory;
    // Estimate of the potential clinical harm, or seriousness, of the reaction to the identified substance.
    property criticality : TFhirAllergyIntoleranceCriticalityEnum read GetCriticalityST write SetCriticalityST;
    property criticalityElement : TFhirEnum read FCriticality write SetCriticality;

    // Typed access to Code for an allergy or intolerance statement (either a positive or a negated/excluded statement).  This may be a code for a substance or pharmaceutical product that is considered to be responsible for the adverse reaction risk (e.g., "Latex"), an allergy or intolerance condition (e.g., "Latex allergy"), or a negated/excluded code for a specific substance or class (e.g., "No latex allergy") or a general or categorical negated statement (e.g.,  "No known allergy", "No known drug allergies"). (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Code for an allergy or intolerance statement (either a positive or a negated/excluded statement).  This may be a code for a substance or pharmaceutical product that is considered to be responsible for the adverse reaction risk (e.g., "Latex"), an allergy or intolerance condition (e.g., "Latex allergy"), or a negated/excluded code for a specific substance or class (e.g., "No latex allergy") or a general or categorical negated statement (e.g.,  "No known allergy", "No known drug allergies").
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The patient who has the allergy or intolerance. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // The patient who has the allergy or intolerance.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Typed access to Estimated or actual date,  date-time, or age when allergy or intolerance was identified. (defined for API consistency)
    property onset : TFhirType read FOnset write SetOnset;
    // Estimated or actual date,  date-time, or age when allergy or intolerance was identified.
    property onsetElement : TFhirType read FOnset write SetOnset;

    // Typed access to The date on which the existance of the AllergyIntolerance was first asserted or acknowledged.
    property assertedDate : TFslDateTime read GetAssertedDateST write SetAssertedDateST;
    // The date on which the existance of the AllergyIntolerance was first asserted or acknowledged.
    property assertedDateElement : TFhirDateTime read FAssertedDate write SetAssertedDate;

    // Typed access to Individual who recorded the record and takes responsibility for its content. (defined for API consistency)
    property recorder : TFhirReference{Resource} read FRecorder write SetRecorder;
    // Individual who recorded the record and takes responsibility for its content.
    property recorderElement : TFhirReference{Resource} read FRecorder write SetRecorder;

    // Typed access to The source of the information about the allergy that is recorded. (defined for API consistency)
    property asserter : TFhirReference{Resource} read FAsserter write SetAsserter;
    // The source of the information about the allergy that is recorded.
    property asserterElement : TFhirReference{Resource} read FAsserter write SetAsserter;

    // Typed access to Represents the date and/or time of the last known occurrence of a reaction event.
    property lastOccurrence : TFslDateTime read GetLastOccurrenceST write SetLastOccurrenceST;
    // Represents the date and/or time of the last known occurrence of a reaction event.
    property lastOccurrenceElement : TFhirDateTime read FLastOccurrence write SetLastOccurrence;

    // Additional narrative about the propensity for the Adverse Reaction, not captured in other fields.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Details about each adverse reaction event linked to exposure to the identified substance.
    property reactionList : TFhirAllergyIntoleranceReactionList read GetReactionList;
    property hasReactionList : boolean read GetHasReactionList;

  end;

  TFhirAllergyIntoleranceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAllergyIntoleranceList;
    function GetCurrent : TFhirAllergyIntolerance;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAllergyIntoleranceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAllergyIntolerance read GetCurrent;
  end;

  TFhirAllergyIntoleranceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirAllergyIntolerance;
    procedure SetItemN(index : Integer; value : TFhirAllergyIntolerance);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirAllergyIntoleranceList; Overload;
    function Clone : TFhirAllergyIntoleranceList; Overload;
    function GetEnumerator : TFhirAllergyIntoleranceListEnumerator;

    //  Add a FhirAllergyIntolerance to the end of the list.
    function Append : TFhirAllergyIntolerance;

    // Add an already existing FhirAllergyIntolerance to the end of the list.
    procedure AddItem(value : TFhirAllergyIntolerance); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAllergyIntolerance) : Integer;

    // Insert FhirAllergyIntolerance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAllergyIntolerance;

    // Insert an existing FhirAllergyIntolerance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAllergyIntolerance);

    // Get the iIndexth FhirAllergyIntolerance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAllergyIntolerance);

    // The number of items in the collection
    function Item(index : Integer) : TFhirAllergyIntolerance;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirAllergyIntolerances[index : Integer] : TFhirAllergyIntolerance read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ALLERGYINTOLERANCE}

{$IFDEF FHIR_APPOINTMENT}

  // List of participants involved in the appointment.
  TFhirAppointmentParticipant = class (TFhirBackboneElement)
  protected
    Ftype_List : TFhirCodeableConceptList;
    FActor : TFhirReference{Resource};
    FRequired : TFhirEnum;
    FStatus : TFhirEnum;
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    Procedure SetActor(value : TFhirReference{Resource});
    Procedure SetRequired(value : TFhirEnum);
    Function GetRequiredST : TFhirParticipantrequiredEnum;
    Procedure SetRequiredST(value : TFhirParticipantrequiredEnum);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirParticipationstatusEnum;
    Procedure SetStatusST(value : TFhirParticipationstatusEnum);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAppointmentParticipant; overload;
    function Clone : TFhirAppointmentParticipant; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Role of participant in the appointment.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Typed access to A Person, Location/HealthcareService or Device that is participating in the appointment. (defined for API consistency)
    property actor : TFhirReference{Resource} read FActor write SetActor;
    // A Person, Location/HealthcareService or Device that is participating in the appointment.
    property actorElement : TFhirReference{Resource} read FActor write SetActor;

    // Is this participant required to be present at the meeting. This covers a use-case where 2 doctors need to meet to discuss the results for a specific patient, and the patient is not required to be present.
    property required : TFhirParticipantrequiredEnum read GetRequiredST write SetRequiredST;
    property requiredElement : TFhirEnum read FRequired write SetRequired;

    // Participation status of the actor.
    property status : TFhirParticipationstatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

  end;

  TFhirAppointmentParticipantListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAppointmentParticipantList;
    function GetCurrent : TFhirAppointmentParticipant;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAppointmentParticipantList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAppointmentParticipant read GetCurrent;
  end;

  TFhirAppointmentParticipantList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirAppointmentParticipant;
    procedure SetItemN(index : Integer; value : TFhirAppointmentParticipant);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirAppointmentParticipantList; Overload;
    function Clone : TFhirAppointmentParticipantList; Overload;
    function GetEnumerator : TFhirAppointmentParticipantListEnumerator;

    //  Add a FhirAppointmentParticipant to the end of the list.
    function Append : TFhirAppointmentParticipant;

    // Add an already existing FhirAppointmentParticipant to the end of the list.
    procedure AddItem(value : TFhirAppointmentParticipant); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAppointmentParticipant) : Integer;

    // Insert FhirAppointmentParticipant before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAppointmentParticipant;

    // Insert an existing FhirAppointmentParticipant before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAppointmentParticipant);

    // Get the iIndexth FhirAppointmentParticipant. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAppointmentParticipant);

    // The number of items in the collection
    function Item(index : Integer) : TFhirAppointmentParticipant;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirAppointmentParticipants[index : Integer] : TFhirAppointmentParticipant read GetItemN write SetItemN; default;
  End;

  // A booking of a healthcare event among patient(s), practitioner(s), related person(s) and/or device(s) for a specific date/time. This may result in one or more Encounter(s).
  TFhirAppointment = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FServiceCategory : TFhirCodeableConcept;
    FserviceTypeList : TFhirCodeableConceptList;
    FspecialtyList : TFhirCodeableConceptList;
    FAppointmentType : TFhirCodeableConcept;
    FreasonList : TFhirCodeableConceptList;
    FindicationList : TFhirReferenceList{Resource};
    FPriority : TFhirUnsignedInt;
    FDescription : TFhirString;
    FsupportingInformationList : TFhirReferenceList{TFhirReference};
    FStart : TFhirInstant;
    FEnd_ : TFhirInstant;
    FMinutesDuration : TFhirPositiveInt;
    FslotList : TFhirReferenceList{TFhirSlot};
    FCreated : TFhirDateTime;
    FComment : TFhirString;
    FincomingReferralList : TFhirReferenceList{TFhirReferralRequest};
    FparticipantList : TFhirAppointmentParticipantList;
    FrequestedPeriodList : TFhirPeriodList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirAppointmentstatusEnum;
    Procedure SetStatusST(value : TFhirAppointmentstatusEnum);
    Procedure SetServiceCategory(value : TFhirCodeableConcept);
    function GetServiceTypeList : TFhirCodeableConceptList;
    function GetHasServiceTypeList : Boolean;
    function GetSpecialtyList : TFhirCodeableConceptList;
    function GetHasSpecialtyList : Boolean;
    Procedure SetAppointmentType(value : TFhirCodeableConcept);
    function GetReasonList : TFhirCodeableConceptList;
    function GetHasReasonList : Boolean;
    function GetIndicationList : TFhirReferenceList{Resource};
    function GetHasIndicationList : Boolean;
    Procedure SetPriority(value : TFhirUnsignedInt);
    Function GetPriorityST : String;
    Procedure SetPriorityST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    function GetSupportingInformationList : TFhirReferenceList{TFhirReference};
    function GetHasSupportingInformationList : Boolean;
    Procedure SetStart(value : TFhirInstant);
    Function GetStartST : TFslDateTime;
    Procedure SetStartST(value : TFslDateTime);
    Procedure SetEnd_(value : TFhirInstant);
    Function GetEnd_ST : TFslDateTime;
    Procedure SetEnd_ST(value : TFslDateTime);
    Procedure SetMinutesDuration(value : TFhirPositiveInt);
    Function GetMinutesDurationST : String;
    Procedure SetMinutesDurationST(value : String);
    function GetSlotList : TFhirReferenceList{TFhirSlot};
    function GetHasSlotList : Boolean;
    Procedure SetCreated(value : TFhirDateTime);
    Function GetCreatedST : TFslDateTime;
    Procedure SetCreatedST(value : TFslDateTime);
    Procedure SetComment(value : TFhirString);
    Function GetCommentST : String;
    Procedure SetCommentST(value : String);
    function GetIncomingReferralList : TFhirReferenceList{TFhirReferralRequest};
    function GetHasIncomingReferralList : Boolean;
    function GetParticipantList : TFhirAppointmentParticipantList;
    function GetHasParticipantList : Boolean;
    function GetRequestedPeriodList : TFhirPeriodList;
    function GetHasRequestedPeriodList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAppointment; overload;
    function Clone : TFhirAppointment; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // This records identifiers associated with this appointment concern that are defined by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate (e.g. in CDA documents, or in written / printed documentation).
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The overall status of the Appointment. Each of the participants has their own participation status which indicates their involvement in the process, however this status indicates the shared status.
    property status : TFhirAppointmentstatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A broad categorisation of the service that is to be performed during this appointment. (defined for API consistency)
    property serviceCategory : TFhirCodeableConcept read FServiceCategory write SetServiceCategory;
    // A broad categorisation of the service that is to be performed during this appointment.
    property serviceCategoryElement : TFhirCodeableConcept read FServiceCategory write SetServiceCategory;

    // The specific service that is to be performed during this appointment.
    property serviceTypeList : TFhirCodeableConceptList read GetServiceTypeList;
    property hasServiceTypeList : boolean read GetHasServiceTypeList;

    // The specialty of a practitioner that would be required to perform the service requested in this appointment.
    property specialtyList : TFhirCodeableConceptList read GetSpecialtyList;
    property hasSpecialtyList : boolean read GetHasSpecialtyList;

    // Typed access to The style of appointment or patient that has been booked in the slot (not service type). (defined for API consistency)
    property appointmentType : TFhirCodeableConcept read FAppointmentType write SetAppointmentType;
    // The style of appointment or patient that has been booked in the slot (not service type).
    property appointmentTypeElement : TFhirCodeableConcept read FAppointmentType write SetAppointmentType;

    // The reason that this appointment is being scheduled. This is more clinical than administrative.
    property reasonList : TFhirCodeableConceptList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // Reason the appointment has been scheduled to take place, as specified using information from another resource. When the patient arrives and the encounter begins it may be used as the admission diagnosis. The indication will typically be a Condition (with other resources referenced in the evidence.detail), or a Procedure.
    property indicationList : TFhirReferenceList{Resource} read GetIndicationList;
    property hasIndicationList : boolean read GetHasIndicationList;

    // Typed access to The priority of the appointment. Can be used to make informed decisions if needing to re-prioritize appointments. (The iCal Standard specifies 0 as undefined, 1 as highest, 9 as lowest priority).
    property priority : String read GetPriorityST write SetPriorityST;
    // The priority of the appointment. Can be used to make informed decisions if needing to re-prioritize appointments. (The iCal Standard specifies 0 as undefined, 1 as highest, 9 as lowest priority).
    property priorityElement : TFhirUnsignedInt read FPriority write SetPriority;

    // Typed access to The brief description of the appointment as would be shown on a subject line in a meeting request, or appointment list. Detailed or expanded information should be put in the comment field.
    property description : String read GetDescriptionST write SetDescriptionST;
    // The brief description of the appointment as would be shown on a subject line in a meeting request, or appointment list. Detailed or expanded information should be put in the comment field.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Additional information to support the appointment provided when making the appointment.
    property supportingInformationList : TFhirReferenceList{TFhirReference} read GetSupportingInformationList;
    property hasSupportingInformationList : boolean read GetHasSupportingInformationList;

    // Typed access to Date/Time that the appointment is to take place.
    property start : TFslDateTime read GetStartST write SetStartST;
    // Date/Time that the appointment is to take place.
    property startElement : TFhirInstant read FStart write SetStart;

    // Typed access to Date/Time that the appointment is to conclude.
    property end_ : TFslDateTime read GetEnd_ST write SetEnd_ST;
    // Date/Time that the appointment is to conclude.
    property end_Element : TFhirInstant read FEnd_ write SetEnd_;

    // Typed access to Number of minutes that the appointment is to take. This can be less than the duration between the start and end times (where actual time of appointment is only an estimate or is a planned appointment request).
    property minutesDuration : String read GetMinutesDurationST write SetMinutesDurationST;
    // Number of minutes that the appointment is to take. This can be less than the duration between the start and end times (where actual time of appointment is only an estimate or is a planned appointment request).
    property minutesDurationElement : TFhirPositiveInt read FMinutesDuration write SetMinutesDuration;

    // The slots from the participants' schedules that will be filled by the appointment.
    property slotList : TFhirReferenceList{TFhirSlot} read GetSlotList;
    property hasSlotList : boolean read GetHasSlotList;

    // Typed access to The date that this appointment was initially created. This could be different to the meta.lastModified value on the initial entry, as this could have been before the resource was created on the FHIR server, and should remain unchanged over the lifespan of the appointment.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date that this appointment was initially created. This could be different to the meta.lastModified value on the initial entry, as this could have been before the resource was created on the FHIR server, and should remain unchanged over the lifespan of the appointment.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to Additional comments about the appointment.
    property comment : String read GetCommentST write SetCommentST;
    // Additional comments about the appointment.
    property commentElement : TFhirString read FComment write SetComment;

    // The referral request this appointment is allocated to assess (incoming referral).
    property incomingReferralList : TFhirReferenceList{TFhirReferralRequest} read GetIncomingReferralList;
    property hasIncomingReferralList : boolean read GetHasIncomingReferralList;

    // List of participants involved in the appointment.
    property participantList : TFhirAppointmentParticipantList read GetParticipantList;
    property hasParticipantList : boolean read GetHasParticipantList;

    // A set of date ranges (potentially including times) that the appointment is preferred to be scheduled within. When using these values, the minutes duration should be provided to indicate the length of the appointment to fill and populate the start/end times for the actual allocated time.
    property requestedPeriodList : TFhirPeriodList read GetRequestedPeriodList;
    property hasRequestedPeriodList : boolean read GetHasRequestedPeriodList;

  end;

  TFhirAppointmentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAppointmentList;
    function GetCurrent : TFhirAppointment;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAppointmentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAppointment read GetCurrent;
  end;

  TFhirAppointmentList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirAppointment;
    procedure SetItemN(index : Integer; value : TFhirAppointment);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirAppointmentList; Overload;
    function Clone : TFhirAppointmentList; Overload;
    function GetEnumerator : TFhirAppointmentListEnumerator;

    //  Add a FhirAppointment to the end of the list.
    function Append : TFhirAppointment;

    // Add an already existing FhirAppointment to the end of the list.
    procedure AddItem(value : TFhirAppointment); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAppointment) : Integer;

    // Insert FhirAppointment before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAppointment;

    // Insert an existing FhirAppointment before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAppointment);

    // Get the iIndexth FhirAppointment. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAppointment);

    // The number of items in the collection
    function Item(index : Integer) : TFhirAppointment;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirAppointments[index : Integer] : TFhirAppointment read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_APPOINTMENT}

{$IFDEF FHIR_APPOINTMENTRESPONSE}

  // A reply to an appointment request for a patient and/or practitioner(s), such as a confirmation or rejection.
  TFhirAppointmentResponse = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FAppointment : TFhirReference{TFhirAppointment};
    FStart : TFhirInstant;
    FEnd_ : TFhirInstant;
    FparticipantTypeList : TFhirCodeableConceptList;
    FActor : TFhirReference{Resource};
    FParticipantStatus : TFhirEnum;
    FComment : TFhirString;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetAppointment(value : TFhirReference{TFhirAppointment});
    Procedure SetStart(value : TFhirInstant);
    Function GetStartST : TFslDateTime;
    Procedure SetStartST(value : TFslDateTime);
    Procedure SetEnd_(value : TFhirInstant);
    Function GetEnd_ST : TFslDateTime;
    Procedure SetEnd_ST(value : TFslDateTime);
    function GetParticipantTypeList : TFhirCodeableConceptList;
    function GetHasParticipantTypeList : Boolean;
    Procedure SetActor(value : TFhirReference{Resource});
    Procedure SetParticipantStatus(value : TFhirEnum);
    Function GetParticipantStatusST : TFhirParticipationstatusEnum;
    Procedure SetParticipantStatusST(value : TFhirParticipationstatusEnum);
    Procedure SetComment(value : TFhirString);
    Function GetCommentST : String;
    Procedure SetCommentST(value : String);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAppointmentResponse; overload;
    function Clone : TFhirAppointmentResponse; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // This records identifiers associated with this appointment response concern that are defined by business processes and/ or used to refer to it when a direct URL reference to the resource itself is not appropriate.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Appointment that this response is replying to. (defined for API consistency)
    property appointment : TFhirReference{TFhirAppointment} read FAppointment write SetAppointment;
    // Appointment that this response is replying to.
    property appointmentElement : TFhirReference{TFhirAppointment} read FAppointment write SetAppointment;

    // Typed access to Date/Time that the appointment is to take place, or requested new start time.
    property start : TFslDateTime read GetStartST write SetStartST;
    // Date/Time that the appointment is to take place, or requested new start time.
    property startElement : TFhirInstant read FStart write SetStart;

    // Typed access to This may be either the same as the appointment request to confirm the details of the appointment, or alternately a new time to request a re-negotiation of the end time.
    property end_ : TFslDateTime read GetEnd_ST write SetEnd_ST;
    // This may be either the same as the appointment request to confirm the details of the appointment, or alternately a new time to request a re-negotiation of the end time.
    property end_Element : TFhirInstant read FEnd_ write SetEnd_;

    // Role of participant in the appointment.
    property participantTypeList : TFhirCodeableConceptList read GetParticipantTypeList;
    property hasParticipantTypeList : boolean read GetHasParticipantTypeList;

    // Typed access to A Person, Location/HealthcareService or Device that is participating in the appointment. (defined for API consistency)
    property actor : TFhirReference{Resource} read FActor write SetActor;
    // A Person, Location/HealthcareService or Device that is participating in the appointment.
    property actorElement : TFhirReference{Resource} read FActor write SetActor;

    // Participation status of the participant. When the status is declined or tentative if the start/end times are different to the appointment, then these times should be interpreted as a requested time change. When the status is accepted, the times can either be the time of the appointment (as a confirmation of the time) or can be empty.
    property participantStatus : TFhirParticipationstatusEnum read GetParticipantStatusST write SetParticipantStatusST;
    property participantStatusElement : TFhirEnum read FParticipantStatus write SetParticipantStatus;

    // Typed access to Additional comments about the appointment.
    property comment : String read GetCommentST write SetCommentST;
    // Additional comments about the appointment.
    property commentElement : TFhirString read FComment write SetComment;

  end;

  TFhirAppointmentResponseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAppointmentResponseList;
    function GetCurrent : TFhirAppointmentResponse;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirAppointmentResponseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAppointmentResponse read GetCurrent;
  end;

  TFhirAppointmentResponseList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirAppointmentResponse;
    procedure SetItemN(index : Integer; value : TFhirAppointmentResponse);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirAppointmentResponseList; Overload;
    function Clone : TFhirAppointmentResponseList; Overload;
    function GetEnumerator : TFhirAppointmentResponseListEnumerator;

    //  Add a FhirAppointmentResponse to the end of the list.
    function Append : TFhirAppointmentResponse;

    // Add an already existing FhirAppointmentResponse to the end of the list.
    procedure AddItem(value : TFhirAppointmentResponse); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAppointmentResponse) : Integer;

    // Insert FhirAppointmentResponse before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAppointmentResponse;

    // Insert an existing FhirAppointmentResponse before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAppointmentResponse);

    // Get the iIndexth FhirAppointmentResponse. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAppointmentResponse);

    // The number of items in the collection
    function Item(index : Integer) : TFhirAppointmentResponse;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirAppointmentResponses[index : Integer] : TFhirAppointmentResponse read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_APPOINTMENTRESPONSE}

{$IFDEF FHIR_BASIC}

  // Basic is used for handling concepts not yet defined in FHIR, narrative-only resources that don't map to an existing resource, and custom resources not appropriate for inclusion in the FHIR specification.
  TFhirBasic = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FCode : TFhirCodeableConcept;
    FSubject : TFhirReference{TFhirReference};
    FCreated : TFhirDate;
    FAuthor : TFhirReference{Resource};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetSubject(value : TFhirReference{TFhirReference});
    Procedure SetCreated(value : TFhirDate);
    Function GetCreatedST : TFslDateTime;
    Procedure SetCreatedST(value : TFslDateTime);
    Procedure SetAuthor(value : TFhirReference{Resource});

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBasic; overload;
    function Clone : TFhirBasic; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Identifier assigned to the resource for business purposes, outside the context of FHIR.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Identifies the 'type' of resource - equivalent to the resource name for other resources. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Identifies the 'type' of resource - equivalent to the resource name for other resources.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to Identifies the patient, practitioner, device or any other resource that is the "focus" of this resource. (defined for API consistency)
    property subject : TFhirReference{TFhirReference} read FSubject write SetSubject;
    // Identifies the patient, practitioner, device or any other resource that is the "focus" of this resource.
    property subjectElement : TFhirReference{TFhirReference} read FSubject write SetSubject;

    // Typed access to Identifies when the resource was first created.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // Identifies when the resource was first created.
    property createdElement : TFhirDate read FCreated write SetCreated;

    // Typed access to Indicates who was responsible for creating the resource instance. (defined for API consistency)
    property author : TFhirReference{Resource} read FAuthor write SetAuthor;
    // Indicates who was responsible for creating the resource instance.
    property authorElement : TFhirReference{Resource} read FAuthor write SetAuthor;

  end;

  TFhirBasicListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBasicList;
    function GetCurrent : TFhirBasic;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirBasicList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBasic read GetCurrent;
  end;

  TFhirBasicList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirBasic;
    procedure SetItemN(index : Integer; value : TFhirBasic);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirBasicList; Overload;
    function Clone : TFhirBasicList; Overload;
    function GetEnumerator : TFhirBasicListEnumerator;

    //  Add a FhirBasic to the end of the list.
    function Append : TFhirBasic;

    // Add an already existing FhirBasic to the end of the list.
    procedure AddItem(value : TFhirBasic); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBasic) : Integer;

    // Insert FhirBasic before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBasic;

    // Insert an existing FhirBasic before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBasic);

    // Get the iIndexth FhirBasic. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBasic);

    // The number of items in the collection
    function Item(index : Integer) : TFhirBasic;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirBasics[index : Integer] : TFhirBasic read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_BASIC}

{$IFDEF FHIR_BODYSITE}

  // Record details about the anatomical location of a specimen or body part.  This resource may be used when a coded concept does not provide the necessary detail needed for the use case.
  TFhirBodySite = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FActive : TFhirBoolean;
    FCode : TFhirCodeableConcept;
    FqualifierList : TFhirCodeableConceptList;
    FDescription : TFhirString;
    FimageList : TFhirAttachmentList;
    FPatient : TFhirReference{TFhirPatient};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetActive(value : TFhirBoolean);
    Function GetActiveST : Boolean;
    Procedure SetActiveST(value : Boolean);
    Procedure SetCode(value : TFhirCodeableConcept);
    function GetQualifierList : TFhirCodeableConceptList;
    function GetHasQualifierList : Boolean;
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    function GetImageList : TFhirAttachmentList;
    function GetHasImageList : Boolean;
    Procedure SetPatient(value : TFhirReference{TFhirPatient});

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBodySite; overload;
    function Clone : TFhirBodySite; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Identifier for this instance of the anatomical location.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Whether this body site is in active use.
    property active : Boolean read GetActiveST write SetActiveST;
    // Whether this body site is in active use.
    property activeElement : TFhirBoolean read FActive write SetActive;

    // Typed access to Named anatomical location - ideally coded where possible. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Named anatomical location - ideally coded where possible.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Qualifier to refine the anatomical location.  These include qualifiers for laterality, relative location, directionality, number, and plane.
    property qualifierList : TFhirCodeableConceptList read GetQualifierList;
    property hasQualifierList : boolean read GetHasQualifierList;

    // Typed access to A summary, charactarization or explanation of the anatomic location.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A summary, charactarization or explanation of the anatomic location.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Image or images used to identify a location.
    property imageList : TFhirAttachmentList read GetImageList;
    property hasImageList : boolean read GetHasImageList;

    // Typed access to The person to which the body site belongs. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // The person to which the body site belongs.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

  end;

  TFhirBodySiteListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBodySiteList;
    function GetCurrent : TFhirBodySite;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirBodySiteList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBodySite read GetCurrent;
  end;

  TFhirBodySiteList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirBodySite;
    procedure SetItemN(index : Integer; value : TFhirBodySite);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirBodySiteList; Overload;
    function Clone : TFhirBodySiteList; Overload;
    function GetEnumerator : TFhirBodySiteListEnumerator;

    //  Add a FhirBodySite to the end of the list.
    function Append : TFhirBodySite;

    // Add an already existing FhirBodySite to the end of the list.
    procedure AddItem(value : TFhirBodySite); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBodySite) : Integer;

    // Insert FhirBodySite before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBodySite;

    // Insert an existing FhirBodySite before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBodySite);

    // Get the iIndexth FhirBodySite. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBodySite);

    // The number of items in the collection
    function Item(index : Integer) : TFhirBodySite;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirBodySites[index : Integer] : TFhirBodySite read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_BODYSITE}

{$IFDEF FHIR_CAREPLAN}

  // Identifies a planned action to occur as part of the plan.  For example, a medication to be used, lab tests to perform, self-monitoring, education, etc.
  TFhirCarePlanActivity = class (TFhirBackboneElement)
  protected
    FoutcomeCodeableConceptList : TFhirCodeableConceptList;
    FoutcomeReferenceList : TFhirReferenceList{TFhirReference};
    FprogressList : TFhirAnnotationList;
    FReference : TFhirReference{Resource};
    FDetail : TFhirCarePlanActivityDetail;
    function GetOutcomeCodeableConceptList : TFhirCodeableConceptList;
    function GetHasOutcomeCodeableConceptList : Boolean;
    function GetOutcomeReferenceList : TFhirReferenceList{TFhirReference};
    function GetHasOutcomeReferenceList : Boolean;
    function GetProgressList : TFhirAnnotationList;
    function GetHasProgressList : Boolean;
    Procedure SetReference(value : TFhirReference{Resource});
    Procedure SetDetail(value : TFhirCarePlanActivityDetail);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCarePlanActivity; overload;
    function Clone : TFhirCarePlanActivity; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Identifies the outcome at the point when the status of the activity is assessed.  For example, the outcome of an education activity could be patient understands (or not).
    property outcomeCodeableConceptList : TFhirCodeableConceptList read GetOutcomeCodeableConceptList;
    property hasOutcomeCodeableConceptList : boolean read GetHasOutcomeCodeableConceptList;

    // Details of the outcome or action resulting from the activity.  The reference to an "event" resource, such as Procedure or Encounter or Observation, is the result/outcome of the activity itself.  The activity can be conveyed using CarePlan.activity.detail OR using the CarePlan.activity.reference (a reference to a ?request? resource).
    property outcomeReferenceList : TFhirReferenceList{TFhirReference} read GetOutcomeReferenceList;
    property hasOutcomeReferenceList : boolean read GetHasOutcomeReferenceList;

    // Notes about the adherence/status/progress of the activity.
    property progressList : TFhirAnnotationList read GetProgressList;
    property hasProgressList : boolean read GetHasProgressList;

    // Typed access to The details of the proposed activity represented in a specific resource. (defined for API consistency)
    property reference : TFhirReference{Resource} read FReference write SetReference;
    // The details of the proposed activity represented in a specific resource.
    property referenceElement : TFhirReference{Resource} read FReference write SetReference;

    // Typed access to A simple summary of a planned activity suitable for a general care plan system (e.g. form driven) that doesn't know about specific resources such as procedure etc. (defined for API consistency)
    property detail : TFhirCarePlanActivityDetail read FDetail write SetDetail;
    // A simple summary of a planned activity suitable for a general care plan system (e.g. form driven) that doesn't know about specific resources such as procedure etc.
    property detailElement : TFhirCarePlanActivityDetail read FDetail write SetDetail;

  end;

  TFhirCarePlanActivityListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCarePlanActivityList;
    function GetCurrent : TFhirCarePlanActivity;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCarePlanActivityList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCarePlanActivity read GetCurrent;
  end;

  TFhirCarePlanActivityList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCarePlanActivity;
    procedure SetItemN(index : Integer; value : TFhirCarePlanActivity);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCarePlanActivityList; Overload;
    function Clone : TFhirCarePlanActivityList; Overload;
    function GetEnumerator : TFhirCarePlanActivityListEnumerator;

    //  Add a FhirCarePlanActivity to the end of the list.
    function Append : TFhirCarePlanActivity;

    // Add an already existing FhirCarePlanActivity to the end of the list.
    procedure AddItem(value : TFhirCarePlanActivity); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCarePlanActivity) : Integer;

    // Insert FhirCarePlanActivity before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCarePlanActivity;

    // Insert an existing FhirCarePlanActivity before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCarePlanActivity);

    // Get the iIndexth FhirCarePlanActivity. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCarePlanActivity);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCarePlanActivity;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCarePlanActivities[index : Integer] : TFhirCarePlanActivity read GetItemN write SetItemN; default;
  End;

  // A simple summary of a planned activity suitable for a general care plan system (e.g. form driven) that doesn't know about specific resources such as procedure etc.
  TFhirCarePlanActivityDetail = class (TFhirBackboneElement)
  protected
    FCategory : TFhirCodeableConcept;
    FDefinition : TFhirReference{Resource};
    FCode : TFhirCodeableConcept;
    FreasonCodeList : TFhirCodeableConceptList;
    FreasonReferenceList : TFhirReferenceList{TFhirCondition};
    FgoalList : TFhirReferenceList{TFhirGoal};
    FStatus : TFhirEnum;
    FStatusReason : TFhirString;
    FProhibited : TFhirBoolean;
    FScheduled : TFhirType;
    FLocation : TFhirReference{TFhirLocation};
    FperformerList : TFhirReferenceList{Resource};
    FProduct : TFhirType;
    FDailyAmount : TFhirQuantity;
    FQuantity : TFhirQuantity;
    FDescription : TFhirString;
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetDefinition(value : TFhirReference{Resource});
    Procedure SetCode(value : TFhirCodeableConcept);
    function GetReasonCodeList : TFhirCodeableConceptList;
    function GetHasReasonCodeList : Boolean;
    function GetReasonReferenceList : TFhirReferenceList{TFhirCondition};
    function GetHasReasonReferenceList : Boolean;
    function GetGoalList : TFhirReferenceList{TFhirGoal};
    function GetHasGoalList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirCarePlanActivityStatusEnum;
    Procedure SetStatusST(value : TFhirCarePlanActivityStatusEnum);
    Procedure SetStatusReason(value : TFhirString);
    Function GetStatusReasonST : String;
    Procedure SetStatusReasonST(value : String);
    Procedure SetProhibited(value : TFhirBoolean);
    Function GetProhibitedST : Boolean;
    Procedure SetProhibitedST(value : Boolean);
    Procedure SetScheduled(value : TFhirType);
    Procedure SetLocation(value : TFhirReference{TFhirLocation});
    function GetPerformerList : TFhirReferenceList{Resource};
    function GetHasPerformerList : Boolean;
    Procedure SetProduct(value : TFhirType);
    Procedure SetDailyAmount(value : TFhirQuantity);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCarePlanActivityDetail; overload;
    function Clone : TFhirCarePlanActivityDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to High-level categorization of the type of activity in a care plan. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // High-level categorization of the type of activity in a care plan.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to Identifies the protocol, questionnaire, guideline or other specification the planned activity should be conducted in accordance with. (defined for API consistency)
    property definition : TFhirReference{Resource} read FDefinition write SetDefinition;
    // Identifies the protocol, questionnaire, guideline or other specification the planned activity should be conducted in accordance with.
    property definitionElement : TFhirReference{Resource} read FDefinition write SetDefinition;

    // Typed access to Detailed description of the type of planned activity; e.g. What lab test, what procedure, what kind of encounter. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Detailed description of the type of planned activity; e.g. What lab test, what procedure, what kind of encounter.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Provides the rationale that drove the inclusion of this particular activity as part of the plan or the reason why the activity was prohibited.
    property reasonCodeList : TFhirCodeableConceptList read GetReasonCodeList;
    property hasReasonCodeList : boolean read GetHasReasonCodeList;

    // Provides the health condition(s) that drove the inclusion of this particular activity as part of the plan.
    property reasonReferenceList : TFhirReferenceList{TFhirCondition} read GetReasonReferenceList;
    property hasReasonReferenceList : boolean read GetHasReasonReferenceList;

    // Internal reference that identifies the goals that this activity is intended to contribute towards meeting.
    property goalList : TFhirReferenceList{TFhirGoal} read GetGoalList;
    property hasGoalList : boolean read GetHasGoalList;

    // Identifies what progress is being made for the specific activity.
    property status : TFhirCarePlanActivityStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Provides reason why the activity isn't yet started, is on hold, was cancelled, etc.
    property statusReason : String read GetStatusReasonST write SetStatusReasonST;
    // Provides reason why the activity isn't yet started, is on hold, was cancelled, etc.
    property statusReasonElement : TFhirString read FStatusReason write SetStatusReason;

    // Typed access to If true, indicates that the described activity is one that must NOT be engaged in when following the plan.  If false, indicates that the described activity is one that should be engaged in when following the plan.
    property prohibited : Boolean read GetProhibitedST write SetProhibitedST;
    // If true, indicates that the described activity is one that must NOT be engaged in when following the plan.  If false, indicates that the described activity is one that should be engaged in when following the plan.
    property prohibitedElement : TFhirBoolean read FProhibited write SetProhibited;

    // Typed access to The period, timing or frequency upon which the described activity is to occur. (defined for API consistency)
    property scheduled : TFhirType read FScheduled write SetScheduled;
    // The period, timing or frequency upon which the described activity is to occur.
    property scheduledElement : TFhirType read FScheduled write SetScheduled;

    // Typed access to Identifies the facility where the activity will occur; e.g. home, hospital, specific clinic, etc. (defined for API consistency)
    property location : TFhirReference{TFhirLocation} read FLocation write SetLocation;
    // Identifies the facility where the activity will occur; e.g. home, hospital, specific clinic, etc.
    property locationElement : TFhirReference{TFhirLocation} read FLocation write SetLocation;

    // Identifies who's expected to be involved in the activity.
    property performerList : TFhirReferenceList{Resource} read GetPerformerList;
    property hasPerformerList : boolean read GetHasPerformerList;

    // Typed access to Identifies the food, drug or other product to be consumed or supplied in the activity. (defined for API consistency)
    property product : TFhirType read FProduct write SetProduct;
    // Identifies the food, drug or other product to be consumed or supplied in the activity.
    property productElement : TFhirType read FProduct write SetProduct;

    // Typed access to Identifies the quantity expected to be consumed in a given day. (defined for API consistency)
    property dailyAmount : TFhirQuantity read FDailyAmount write SetDailyAmount;
    // Identifies the quantity expected to be consumed in a given day.
    property dailyAmountElement : TFhirQuantity read FDailyAmount write SetDailyAmount;

    // Typed access to Identifies the quantity expected to be supplied, administered or consumed by the subject. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // Identifies the quantity expected to be supplied, administered or consumed by the subject.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to This provides a textual description of constraints on the intended activity occurrence, including relation to other activities.  It may also include objectives, pre-conditions and end-conditions.  Finally, it may convey specifics about the activity such as body site, method, route, etc.
    property description : String read GetDescriptionST write SetDescriptionST;
    // This provides a textual description of constraints on the intended activity occurrence, including relation to other activities.  It may also include objectives, pre-conditions and end-conditions.  Finally, it may convey specifics about the activity such as body site, method, route, etc.
    property descriptionElement : TFhirString read FDescription write SetDescription;

  end;

  TFhirCarePlanActivityDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCarePlanActivityDetailList;
    function GetCurrent : TFhirCarePlanActivityDetail;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCarePlanActivityDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCarePlanActivityDetail read GetCurrent;
  end;

  TFhirCarePlanActivityDetailList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCarePlanActivityDetail;
    procedure SetItemN(index : Integer; value : TFhirCarePlanActivityDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCarePlanActivityDetailList; Overload;
    function Clone : TFhirCarePlanActivityDetailList; Overload;
    function GetEnumerator : TFhirCarePlanActivityDetailListEnumerator;

    //  Add a FhirCarePlanActivityDetail to the end of the list.
    function Append : TFhirCarePlanActivityDetail;

    // Add an already existing FhirCarePlanActivityDetail to the end of the list.
    procedure AddItem(value : TFhirCarePlanActivityDetail); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCarePlanActivityDetail) : Integer;

    // Insert FhirCarePlanActivityDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCarePlanActivityDetail;

    // Insert an existing FhirCarePlanActivityDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCarePlanActivityDetail);

    // Get the iIndexth FhirCarePlanActivityDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCarePlanActivityDetail);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCarePlanActivityDetail;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCarePlanActivityDetails[index : Integer] : TFhirCarePlanActivityDetail read GetItemN write SetItemN; default;
  End;

  // Describes the intention of how one or more practitioners intend to deliver care for a particular patient, group or community for a period of time, possibly limited to care for a specific condition or set of conditions.
  TFhirCarePlan = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FdefinitionList : TFhirReferenceList{Resource};
    FbasedOnList : TFhirReferenceList{TFhirCarePlan};
    FreplacesList : TFhirReferenceList{TFhirCarePlan};
    FpartOfList : TFhirReferenceList{TFhirCarePlan};
    FStatus : TFhirEnum;
    FIntent : TFhirEnum;
    FcategoryList : TFhirCodeableConceptList;
    FTitle : TFhirString;
    FDescription : TFhirString;
    FSubject : TFhirReference{Resource};
    FContext : TFhirReference{Resource};
    FPeriod : TFhirPeriod;
    FauthorList : TFhirReferenceList{Resource};
    FcareTeamList : TFhirReferenceList{TFhirCareTeam};
    FaddressesList : TFhirReferenceList{TFhirCondition};
    FsupportingInfoList : TFhirReferenceList{TFhirReference};
    FgoalList : TFhirReferenceList{TFhirGoal};
    FactivityList : TFhirCarePlanActivityList;
    FnoteList : TFhirAnnotationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetDefinitionList : TFhirReferenceList{Resource};
    function GetHasDefinitionList : Boolean;
    function GetBasedOnList : TFhirReferenceList{TFhirCarePlan};
    function GetHasBasedOnList : Boolean;
    function GetReplacesList : TFhirReferenceList{TFhirCarePlan};
    function GetHasReplacesList : Boolean;
    function GetPartOfList : TFhirReferenceList{TFhirCarePlan};
    function GetHasPartOfList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirCarePlanStatusEnum;
    Procedure SetStatusST(value : TFhirCarePlanStatusEnum);
    Procedure SetIntent(value : TFhirEnum);
    Function GetIntentST : TFhirCarePlanIntentEnum;
    Procedure SetIntentST(value : TFhirCarePlanIntentEnum);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    Procedure SetTitle(value : TFhirString);
    Function GetTitleST : String;
    Procedure SetTitleST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetSubject(value : TFhirReference{Resource});
    Procedure SetContext(value : TFhirReference{Resource});
    Procedure SetPeriod(value : TFhirPeriod);
    function GetAuthorList : TFhirReferenceList{Resource};
    function GetHasAuthorList : Boolean;
    function GetCareTeamList : TFhirReferenceList{TFhirCareTeam};
    function GetHasCareTeamList : Boolean;
    function GetAddressesList : TFhirReferenceList{TFhirCondition};
    function GetHasAddressesList : Boolean;
    function GetSupportingInfoList : TFhirReferenceList{TFhirReference};
    function GetHasSupportingInfoList : Boolean;
    function GetGoalList : TFhirReferenceList{TFhirGoal};
    function GetHasGoalList : Boolean;
    function GetActivityList : TFhirCarePlanActivityList;
    function GetHasActivityList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCarePlan; overload;
    function Clone : TFhirCarePlan; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // This records identifiers associated with this care plan that are defined by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate (e.g. in CDA documents, or in written / printed documentation).
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Identifies the protocol, questionnaire, guideline or other specification the care plan should be conducted in accordance with.
    property definitionList : TFhirReferenceList{Resource} read GetDefinitionList;
    property hasDefinitionList : boolean read GetHasDefinitionList;

    // A care plan that is fulfilled in whole or in part by this care plan.
    property basedOnList : TFhirReferenceList{TFhirCarePlan} read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // Completed or terminated care plan whose function is taken by this new care plan.
    property replacesList : TFhirReferenceList{TFhirCarePlan} read GetReplacesList;
    property hasReplacesList : boolean read GetHasReplacesList;

    // A larger care plan of which this particular care plan is a component or step.
    property partOfList : TFhirReferenceList{TFhirCarePlan} read GetPartOfList;
    property hasPartOfList : boolean read GetHasPartOfList;

    // Indicates whether the plan is currently being acted upon, represents future intentions or is now a historical record.
    property status : TFhirCarePlanStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Indicates the level of authority/intentionality associated with the care plan and where the care plan fits into the workflow chain.
    property intent : TFhirCarePlanIntentEnum read GetIntentST write SetIntentST;
    property intentElement : TFhirEnum read FIntent write SetIntent;

    // Identifies what "kind" of plan this is to support differentiation between multiple co-existing plans; e.g. "Home health", "psychiatric", "asthma", "disease management", "wellness plan", etc.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to Human-friendly name for the CarePlan.
    property title : String read GetTitleST write SetTitleST;
    // Human-friendly name for the CarePlan.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to A description of the scope and nature of the plan.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A description of the scope and nature of the plan.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Identifies the patient or group whose intended care is described by the plan. (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // Identifies the patient or group whose intended care is described by the plan.
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // Typed access to Identifies the original context in which this particular CarePlan was created. (defined for API consistency)
    property context : TFhirReference{Resource} read FContext write SetContext;
    // Identifies the original context in which this particular CarePlan was created.
    property contextElement : TFhirReference{Resource} read FContext write SetContext;

    // Typed access to Indicates when the plan did (or is intended to) come into effect and end. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Indicates when the plan did (or is intended to) come into effect and end.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Identifies the individual(s) or ogranization who is responsible for the content of the care plan.
    property authorList : TFhirReferenceList{Resource} read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // Identifies all people and organizations who are expected to be involved in the care envisioned by this plan.
    property careTeamList : TFhirReferenceList{TFhirCareTeam} read GetCareTeamList;
    property hasCareTeamList : boolean read GetHasCareTeamList;

    // Identifies the conditions/problems/concerns/diagnoses/etc. whose management and/or mitigation are handled by this plan.
    property addressesList : TFhirReferenceList{TFhirCondition} read GetAddressesList;
    property hasAddressesList : boolean read GetHasAddressesList;

    // Identifies portions of the patient's record that specifically influenced the formation of the plan.  These might include co-morbidities, recent procedures, limitations, recent assessments, etc.
    property supportingInfoList : TFhirReferenceList{TFhirReference} read GetSupportingInfoList;
    property hasSupportingInfoList : boolean read GetHasSupportingInfoList;

    // Describes the intended objective(s) of carrying out the care plan.
    property goalList : TFhirReferenceList{TFhirGoal} read GetGoalList;
    property hasGoalList : boolean read GetHasGoalList;

    // Identifies a planned action to occur as part of the plan.  For example, a medication to be used, lab tests to perform, self-monitoring, education, etc.
    property activityList : TFhirCarePlanActivityList read GetActivityList;
    property hasActivityList : boolean read GetHasActivityList;

    // General notes about the care plan not covered elsewhere.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirCarePlanListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCarePlanList;
    function GetCurrent : TFhirCarePlan;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCarePlanList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCarePlan read GetCurrent;
  end;

  TFhirCarePlanList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCarePlan;
    procedure SetItemN(index : Integer; value : TFhirCarePlan);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCarePlanList; Overload;
    function Clone : TFhirCarePlanList; Overload;
    function GetEnumerator : TFhirCarePlanListEnumerator;

    //  Add a FhirCarePlan to the end of the list.
    function Append : TFhirCarePlan;

    // Add an already existing FhirCarePlan to the end of the list.
    procedure AddItem(value : TFhirCarePlan); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCarePlan) : Integer;

    // Insert FhirCarePlan before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCarePlan;

    // Insert an existing FhirCarePlan before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCarePlan);

    // Get the iIndexth FhirCarePlan. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCarePlan);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCarePlan;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCarePlans[index : Integer] : TFhirCarePlan read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CAREPLAN}

{$IFDEF FHIR_CARETEAM}

  // Identifies all people and organizations who are expected to be involved in the care team.
  TFhirCareTeamParticipant = class (TFhirBackboneElement)
  protected
    FRole : TFhirCodeableConcept;
    FMember : TFhirReference{Resource};
    FOnBehalfOf : TFhirReference{TFhirOrganization};
    FPeriod : TFhirPeriod;
    Procedure SetRole(value : TFhirCodeableConcept);
    Procedure SetMember(value : TFhirReference{Resource});
    Procedure SetOnBehalfOf(value : TFhirReference{TFhirOrganization});
    Procedure SetPeriod(value : TFhirPeriod);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCareTeamParticipant; overload;
    function Clone : TFhirCareTeamParticipant; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Indicates specific responsibility of an individual within the care team, such as "Primary care physician", "Trained social worker counselor", "Caregiver", etc. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // Indicates specific responsibility of an individual within the care team, such as "Primary care physician", "Trained social worker counselor", "Caregiver", etc.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

    // Typed access to The specific person or organization who is participating/expected to participate in the care team. (defined for API consistency)
    property member : TFhirReference{Resource} read FMember write SetMember;
    // The specific person or organization who is participating/expected to participate in the care team.
    property memberElement : TFhirReference{Resource} read FMember write SetMember;

    // Typed access to The organization of the practitioner. (defined for API consistency)
    property onBehalfOf : TFhirReference{TFhirOrganization} read FOnBehalfOf write SetOnBehalfOf;
    // The organization of the practitioner.
    property onBehalfOfElement : TFhirReference{TFhirOrganization} read FOnBehalfOf write SetOnBehalfOf;

    // Typed access to Indicates when the specific member or organization did (or is intended to) come into effect and end. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Indicates when the specific member or organization did (or is intended to) come into effect and end.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirCareTeamParticipantListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCareTeamParticipantList;
    function GetCurrent : TFhirCareTeamParticipant;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCareTeamParticipantList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCareTeamParticipant read GetCurrent;
  end;

  TFhirCareTeamParticipantList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCareTeamParticipant;
    procedure SetItemN(index : Integer; value : TFhirCareTeamParticipant);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCareTeamParticipantList; Overload;
    function Clone : TFhirCareTeamParticipantList; Overload;
    function GetEnumerator : TFhirCareTeamParticipantListEnumerator;

    //  Add a FhirCareTeamParticipant to the end of the list.
    function Append : TFhirCareTeamParticipant;

    // Add an already existing FhirCareTeamParticipant to the end of the list.
    procedure AddItem(value : TFhirCareTeamParticipant); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCareTeamParticipant) : Integer;

    // Insert FhirCareTeamParticipant before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCareTeamParticipant;

    // Insert an existing FhirCareTeamParticipant before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCareTeamParticipant);

    // Get the iIndexth FhirCareTeamParticipant. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCareTeamParticipant);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCareTeamParticipant;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCareTeamParticipants[index : Integer] : TFhirCareTeamParticipant read GetItemN write SetItemN; default;
  End;

  // The Care Team includes all the people and organizations who plan to participate in the coordination and delivery of care for a patient.
  TFhirCareTeam = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FcategoryList : TFhirCodeableConceptList;
    FName : TFhirString;
    FSubject : TFhirReference{Resource};
    FContext : TFhirReference{Resource};
    FPeriod : TFhirPeriod;
    FparticipantList : TFhirCareTeamParticipantList;
    FreasonCodeList : TFhirCodeableConceptList;
    FreasonReferenceList : TFhirReferenceList{TFhirCondition};
    FmanagingOrganizationList : TFhirReferenceList{TFhirOrganization};
    FnoteList : TFhirAnnotationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirCareTeamStatusEnum;
    Procedure SetStatusST(value : TFhirCareTeamStatusEnum);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetSubject(value : TFhirReference{Resource});
    Procedure SetContext(value : TFhirReference{Resource});
    Procedure SetPeriod(value : TFhirPeriod);
    function GetParticipantList : TFhirCareTeamParticipantList;
    function GetHasParticipantList : Boolean;
    function GetReasonCodeList : TFhirCodeableConceptList;
    function GetHasReasonCodeList : Boolean;
    function GetReasonReferenceList : TFhirReferenceList{TFhirCondition};
    function GetHasReasonReferenceList : Boolean;
    function GetManagingOrganizationList : TFhirReferenceList{TFhirOrganization};
    function GetHasManagingOrganizationList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCareTeam; overload;
    function Clone : TFhirCareTeam; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // This records identifiers associated with this care team that are defined by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Indicates the current state of the care team.
    property status : TFhirCareTeamStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Identifies what kind of team.  This is to support differentiation between multiple co-existing teams, such as care plan team, episode of care team, longitudinal care team.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to A label for human use intended to distinguish like teams.  E.g. the "red" vs. "green" trauma teams.
    property name : String read GetNameST write SetNameST;
    // A label for human use intended to distinguish like teams.  E.g. the "red" vs. "green" trauma teams.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Identifies the patient or group whose intended care is handled by the team. (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // Identifies the patient or group whose intended care is handled by the team.
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // Typed access to The encounter or episode of care that establishes the context for this care team. (defined for API consistency)
    property context : TFhirReference{Resource} read FContext write SetContext;
    // The encounter or episode of care that establishes the context for this care team.
    property contextElement : TFhirReference{Resource} read FContext write SetContext;

    // Typed access to Indicates when the team did (or is intended to) come into effect and end. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Indicates when the team did (or is intended to) come into effect and end.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Identifies all people and organizations who are expected to be involved in the care team.
    property participantList : TFhirCareTeamParticipantList read GetParticipantList;
    property hasParticipantList : boolean read GetHasParticipantList;

    // Describes why the care team exists.
    property reasonCodeList : TFhirCodeableConceptList read GetReasonCodeList;
    property hasReasonCodeList : boolean read GetHasReasonCodeList;

    // Condition(s) that this care team addresses.
    property reasonReferenceList : TFhirReferenceList{TFhirCondition} read GetReasonReferenceList;
    property hasReasonReferenceList : boolean read GetHasReasonReferenceList;

    // The organization responsible for the care team.
    property managingOrganizationList : TFhirReferenceList{TFhirOrganization} read GetManagingOrganizationList;
    property hasManagingOrganizationList : boolean read GetHasManagingOrganizationList;

    // Comments made about the CareTeam.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirCareTeamListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCareTeamList;
    function GetCurrent : TFhirCareTeam;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCareTeamList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCareTeam read GetCurrent;
  end;

  TFhirCareTeamList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCareTeam;
    procedure SetItemN(index : Integer; value : TFhirCareTeam);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCareTeamList; Overload;
    function Clone : TFhirCareTeamList; Overload;
    function GetEnumerator : TFhirCareTeamListEnumerator;

    //  Add a FhirCareTeam to the end of the list.
    function Append : TFhirCareTeam;

    // Add an already existing FhirCareTeam to the end of the list.
    procedure AddItem(value : TFhirCareTeam); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCareTeam) : Integer;

    // Insert FhirCareTeam before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCareTeam;

    // Insert an existing FhirCareTeam before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCareTeam);

    // Get the iIndexth FhirCareTeam. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCareTeam);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCareTeam;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCareTeams[index : Integer] : TFhirCareTeam read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CARETEAM}

{$IFDEF FHIR_CLINICALIMPRESSION}

  // One or more sets of investigations (signs, symptions, etc.). The actual grouping of investigations vary greatly depending on the type and context of the assessment. These investigations may include data generated during the assessment process, or data previously generated and recorded that is pertinent to the outcomes.
  TFhirClinicalImpressionInvestigation = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FitemList : TFhirReferenceList{Resource};
    Procedure SetCode(value : TFhirCodeableConcept);
    function GetItemList : TFhirReferenceList{Resource};
    function GetHasItemList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClinicalImpressionInvestigation; overload;
    function Clone : TFhirClinicalImpressionInvestigation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A name/code for the group ("set") of investigations. Typically, this will be something like "signs", "symptoms", "clinical", "diagnostic", but the list is not constrained, and others such groups such as (exposure|family|travel|nutitirional) history may be used. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A name/code for the group ("set") of investigations. Typically, this will be something like "signs", "symptoms", "clinical", "diagnostic", but the list is not constrained, and others such groups such as (exposure|family|travel|nutitirional) history may be used.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // A record of a specific investigation that was undertaken.
    property itemList : TFhirReferenceList{Resource} read GetItemList;
    property hasItemList : boolean read GetHasItemList;

  end;

  TFhirClinicalImpressionInvestigationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClinicalImpressionInvestigationList;
    function GetCurrent : TFhirClinicalImpressionInvestigation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClinicalImpressionInvestigationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClinicalImpressionInvestigation read GetCurrent;
  end;

  TFhirClinicalImpressionInvestigationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClinicalImpressionInvestigation;
    procedure SetItemN(index : Integer; value : TFhirClinicalImpressionInvestigation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClinicalImpressionInvestigationList; Overload;
    function Clone : TFhirClinicalImpressionInvestigationList; Overload;
    function GetEnumerator : TFhirClinicalImpressionInvestigationListEnumerator;

    //  Add a FhirClinicalImpressionInvestigation to the end of the list.
    function Append : TFhirClinicalImpressionInvestigation;

    // Add an already existing FhirClinicalImpressionInvestigation to the end of the list.
    procedure AddItem(value : TFhirClinicalImpressionInvestigation); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClinicalImpressionInvestigation) : Integer;

    // Insert FhirClinicalImpressionInvestigation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClinicalImpressionInvestigation;

    // Insert an existing FhirClinicalImpressionInvestigation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClinicalImpressionInvestigation);

    // Get the iIndexth FhirClinicalImpressionInvestigation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClinicalImpressionInvestigation);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClinicalImpressionInvestigation;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClinicalImpressionInvestigations[index : Integer] : TFhirClinicalImpressionInvestigation read GetItemN write SetItemN; default;
  End;

  // Specific findings or diagnoses that was considered likely or relevant to ongoing treatment.
  TFhirClinicalImpressionFinding = class (TFhirBackboneElement)
  protected
    FItem : TFhirType;
    FBasis : TFhirString;
    Procedure SetItem(value : TFhirType);
    Procedure SetBasis(value : TFhirString);
    Function GetBasisST : String;
    Procedure SetBasisST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClinicalImpressionFinding; overload;
    function Clone : TFhirClinicalImpressionFinding; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Specific text, code or reference for finding or diagnosis, which may include ruled-out or resolved conditions. (defined for API consistency)
    property item : TFhirType read FItem write SetItem;
    // Specific text, code or reference for finding or diagnosis, which may include ruled-out or resolved conditions.
    property itemElement : TFhirType read FItem write SetItem;

    // Typed access to Which investigations support finding or diagnosis.
    property basis : String read GetBasisST write SetBasisST;
    // Which investigations support finding or diagnosis.
    property basisElement : TFhirString read FBasis write SetBasis;

  end;

  TFhirClinicalImpressionFindingListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClinicalImpressionFindingList;
    function GetCurrent : TFhirClinicalImpressionFinding;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClinicalImpressionFindingList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClinicalImpressionFinding read GetCurrent;
  end;

  TFhirClinicalImpressionFindingList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClinicalImpressionFinding;
    procedure SetItemN(index : Integer; value : TFhirClinicalImpressionFinding);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClinicalImpressionFindingList; Overload;
    function Clone : TFhirClinicalImpressionFindingList; Overload;
    function GetEnumerator : TFhirClinicalImpressionFindingListEnumerator;

    //  Add a FhirClinicalImpressionFinding to the end of the list.
    function Append : TFhirClinicalImpressionFinding;

    // Add an already existing FhirClinicalImpressionFinding to the end of the list.
    procedure AddItem(value : TFhirClinicalImpressionFinding); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClinicalImpressionFinding) : Integer;

    // Insert FhirClinicalImpressionFinding before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClinicalImpressionFinding;

    // Insert an existing FhirClinicalImpressionFinding before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClinicalImpressionFinding);

    // Get the iIndexth FhirClinicalImpressionFinding. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClinicalImpressionFinding);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClinicalImpressionFinding;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClinicalImpressionFindings[index : Integer] : TFhirClinicalImpressionFinding read GetItemN write SetItemN; default;
  End;

  // A record of a clinical assessment performed to determine what problem(s) may affect the patient and before planning the treatments or management strategies that are best to manage a patient's condition. Assessments are often 1:1 with a clinical consultation / encounter,  but this varies greatly depending on the clinical workflow. This resource is called "ClinicalImpression" rather than "ClinicalAssessment" to avoid confusion with the recording of assessment tools such as Apgar score.
  TFhirClinicalImpression = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FCode : TFhirCodeableConcept;
    FDescription : TFhirString;
    FSubject : TFhirReference{Resource};
    FContext : TFhirReference{Resource};
    FEffective : TFhirType;
    FDate : TFhirDateTime;
    FAssessor : TFhirReference{TFhirPractitioner};
    FPrevious : TFhirReference{TFhirClinicalImpression};
    FproblemList : TFhirReferenceList{Resource};
    FinvestigationList : TFhirClinicalImpressionInvestigationList;
    FprotocolList : TFhirUriList;
    FSummary : TFhirString;
    FfindingList : TFhirClinicalImpressionFindingList;
    FprognosisCodeableConceptList : TFhirCodeableConceptList;
    FprognosisReferenceList : TFhirReferenceList{TFhirRiskAssessment};
    FactionList : TFhirReferenceList{Resource};
    FnoteList : TFhirAnnotationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirClinicalImpressionStatusEnum;
    Procedure SetStatusST(value : TFhirClinicalImpressionStatusEnum);
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetSubject(value : TFhirReference{Resource});
    Procedure SetContext(value : TFhirReference{Resource});
    Procedure SetEffective(value : TFhirType);
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetAssessor(value : TFhirReference{TFhirPractitioner});
    Procedure SetPrevious(value : TFhirReference{TFhirClinicalImpression});
    function GetProblemList : TFhirReferenceList{Resource};
    function GetHasProblemList : Boolean;
    function GetInvestigationList : TFhirClinicalImpressionInvestigationList;
    function GetHasInvestigationList : Boolean;
    function GetProtocolList : TFhirUriList;
    function GetHasProtocolList : Boolean;
    Procedure SetSummary(value : TFhirString);
    Function GetSummaryST : String;
    Procedure SetSummaryST(value : String);
    function GetFindingList : TFhirClinicalImpressionFindingList;
    function GetHasFindingList : Boolean;
    function GetPrognosisCodeableConceptList : TFhirCodeableConceptList;
    function GetHasPrognosisCodeableConceptList : Boolean;
    function GetPrognosisReferenceList : TFhirReferenceList{TFhirRiskAssessment};
    function GetHasPrognosisReferenceList : Boolean;
    function GetActionList : TFhirReferenceList{Resource};
    function GetHasActionList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClinicalImpression; overload;
    function Clone : TFhirClinicalImpression; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // A unique identifier assigned to the clinical impression that remains consistent regardless of what server the impression is stored on.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Identifies the workflow status of the assessment.
    property status : TFhirClinicalImpressionStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Categorizes the type of clinical assessment performed. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Categorizes the type of clinical assessment performed.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to A summary of the context and/or cause of the assessment - why / where was it performed, and what patient events/status prompted it.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A summary of the context and/or cause of the assessment - why / where was it performed, and what patient events/status prompted it.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to The patient or group of individuals assessed as part of this record. (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // The patient or group of individuals assessed as part of this record.
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // Typed access to The encounter or episode of care this impression was created as part of. (defined for API consistency)
    property context : TFhirReference{Resource} read FContext write SetContext;
    // The encounter or episode of care this impression was created as part of.
    property contextElement : TFhirReference{Resource} read FContext write SetContext;

    // Typed access to The point in time or period over which the subject was assessed. (defined for API consistency)
    property effective : TFhirType read FEffective write SetEffective;
    // The point in time or period over which the subject was assessed.
    property effectiveElement : TFhirType read FEffective write SetEffective;

    // Typed access to Indicates when the documentation of the assessment was complete.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Indicates when the documentation of the assessment was complete.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The clinician performing the assessment. (defined for API consistency)
    property assessor : TFhirReference{TFhirPractitioner} read FAssessor write SetAssessor;
    // The clinician performing the assessment.
    property assessorElement : TFhirReference{TFhirPractitioner} read FAssessor write SetAssessor;

    // Typed access to A reference to the last assesment that was conducted bon this patient. Assessments are often/usually ongoing in nature; a care provider (practitioner or team) will make new assessments on an ongoing basis as new data arises or the patient's conditions changes. (defined for API consistency)
    property previous : TFhirReference{TFhirClinicalImpression} read FPrevious write SetPrevious;
    // A reference to the last assesment that was conducted bon this patient. Assessments are often/usually ongoing in nature; a care provider (practitioner or team) will make new assessments on an ongoing basis as new data arises or the patient's conditions changes.
    property previousElement : TFhirReference{TFhirClinicalImpression} read FPrevious write SetPrevious;

    // This a list of the relevant problems/conditions for a patient.
    property problemList : TFhirReferenceList{Resource} read GetProblemList;
    property hasProblemList : boolean read GetHasProblemList;

    // One or more sets of investigations (signs, symptions, etc.). The actual grouping of investigations vary greatly depending on the type and context of the assessment. These investigations may include data generated during the assessment process, or data previously generated and recorded that is pertinent to the outcomes.
    property investigationList : TFhirClinicalImpressionInvestigationList read GetInvestigationList;
    property hasInvestigationList : boolean read GetHasInvestigationList;

    // Reference to a specific {$IFNDEF FPC}Published{$ENDIF} clinical protocol that was followed during this assessment, and/or that provides evidence in support of the diagnosis.
    property protocolList : TFhirUriList read GetProtocolList;
    property hasProtocolList : boolean read GetHasProtocolList;

    // Typed access to A text summary of the investigations and the diagnosis.
    property summary : String read GetSummaryST write SetSummaryST;
    // A text summary of the investigations and the diagnosis.
    property summaryElement : TFhirString read FSummary write SetSummary;

    // Specific findings or diagnoses that was considered likely or relevant to ongoing treatment.
    property findingList : TFhirClinicalImpressionFindingList read GetFindingList;
    property hasFindingList : boolean read GetHasFindingList;

    // Estimate of likely outcome.
    property prognosisCodeableConceptList : TFhirCodeableConceptList read GetPrognosisCodeableConceptList;
    property hasPrognosisCodeableConceptList : boolean read GetHasPrognosisCodeableConceptList;

    // RiskAssessment expressing likely outcome.
    property prognosisReferenceList : TFhirReferenceList{TFhirRiskAssessment} read GetPrognosisReferenceList;
    property hasPrognosisReferenceList : boolean read GetHasPrognosisReferenceList;

    // Action taken as part of assessment procedure.
    property actionList : TFhirReferenceList{Resource} read GetActionList;
    property hasActionList : boolean read GetHasActionList;

    // Commentary about the impression, typically recorded after the impression itself was made, though supplemental notes by the original author could also appear.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirClinicalImpressionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClinicalImpressionList;
    function GetCurrent : TFhirClinicalImpression;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirClinicalImpressionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClinicalImpression read GetCurrent;
  end;

  TFhirClinicalImpressionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirClinicalImpression;
    procedure SetItemN(index : Integer; value : TFhirClinicalImpression);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirClinicalImpressionList; Overload;
    function Clone : TFhirClinicalImpressionList; Overload;
    function GetEnumerator : TFhirClinicalImpressionListEnumerator;

    //  Add a FhirClinicalImpression to the end of the list.
    function Append : TFhirClinicalImpression;

    // Add an already existing FhirClinicalImpression to the end of the list.
    procedure AddItem(value : TFhirClinicalImpression); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClinicalImpression) : Integer;

    // Insert FhirClinicalImpression before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClinicalImpression;

    // Insert an existing FhirClinicalImpression before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClinicalImpression);

    // Get the iIndexth FhirClinicalImpression. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClinicalImpression);

    // The number of items in the collection
    function Item(index : Integer) : TFhirClinicalImpression;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirClinicalImpressions[index : Integer] : TFhirClinicalImpression read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CLINICALIMPRESSION}

{$IFDEF FHIR_COMMUNICATION}

  // Text, attachment(s), or resource(s) that was communicated to the recipient.
  TFhirCommunicationPayload = class (TFhirBackboneElement)
  protected
    FContent : TFhirType;
    Procedure SetContent(value : TFhirType);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCommunicationPayload; overload;
    function Clone : TFhirCommunicationPayload; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A communicated content (or for multi-part communications, one portion of the communication). (defined for API consistency)
    property content : TFhirType read FContent write SetContent;
    // A communicated content (or for multi-part communications, one portion of the communication).
    property contentElement : TFhirType read FContent write SetContent;

  end;

  TFhirCommunicationPayloadListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCommunicationPayloadList;
    function GetCurrent : TFhirCommunicationPayload;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCommunicationPayloadList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCommunicationPayload read GetCurrent;
  end;

  TFhirCommunicationPayloadList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCommunicationPayload;
    procedure SetItemN(index : Integer; value : TFhirCommunicationPayload);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCommunicationPayloadList; Overload;
    function Clone : TFhirCommunicationPayloadList; Overload;
    function GetEnumerator : TFhirCommunicationPayloadListEnumerator;

    //  Add a FhirCommunicationPayload to the end of the list.
    function Append : TFhirCommunicationPayload;

    // Add an already existing FhirCommunicationPayload to the end of the list.
    procedure AddItem(value : TFhirCommunicationPayload); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCommunicationPayload) : Integer;

    // Insert FhirCommunicationPayload before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCommunicationPayload;

    // Insert an existing FhirCommunicationPayload before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCommunicationPayload);

    // Get the iIndexth FhirCommunicationPayload. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCommunicationPayload);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCommunicationPayload;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCommunicationPayloads[index : Integer] : TFhirCommunicationPayload read GetItemN write SetItemN; default;
  End;

  // An occurrence of information being transmitted; e.g. an alert that was sent to a responsible provider, a public health agency was notified about a reportable condition.
  TFhirCommunication = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FdefinitionList : TFhirReferenceList{Resource};
    FbasedOnList : TFhirReferenceList{TFhirReference};
    FpartOfList : TFhirReferenceList{TFhirReference};
    FStatus : TFhirEnum;
    FNotDone : TFhirBoolean;
    FNotDoneReason : TFhirCodeableConcept;
    FcategoryList : TFhirCodeableConceptList;
    FmediumList : TFhirCodeableConceptList;
    FSubject : TFhirReference{Resource};
    FrecipientList : TFhirReferenceList{Resource};
    FtopicList : TFhirReferenceList{TFhirReference};
    FContext : TFhirReference{Resource};
    FSent : TFhirDateTime;
    FReceived : TFhirDateTime;
    FSender : TFhirReference{Resource};
    FreasonCodeList : TFhirCodeableConceptList;
    FreasonReferenceList : TFhirReferenceList{Resource};
    FpayloadList : TFhirCommunicationPayloadList;
    FnoteList : TFhirAnnotationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetDefinitionList : TFhirReferenceList{Resource};
    function GetHasDefinitionList : Boolean;
    function GetBasedOnList : TFhirReferenceList{TFhirReference};
    function GetHasBasedOnList : Boolean;
    function GetPartOfList : TFhirReferenceList{TFhirReference};
    function GetHasPartOfList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirEventStatusEnum;
    Procedure SetStatusST(value : TFhirEventStatusEnum);
    Procedure SetNotDone(value : TFhirBoolean);
    Function GetNotDoneST : Boolean;
    Procedure SetNotDoneST(value : Boolean);
    Procedure SetNotDoneReason(value : TFhirCodeableConcept);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    function GetMediumList : TFhirCodeableConceptList;
    function GetHasMediumList : Boolean;
    Procedure SetSubject(value : TFhirReference{Resource});
    function GetRecipientList : TFhirReferenceList{Resource};
    function GetHasRecipientList : Boolean;
    function GetTopicList : TFhirReferenceList{TFhirReference};
    function GetHasTopicList : Boolean;
    Procedure SetContext(value : TFhirReference{Resource});
    Procedure SetSent(value : TFhirDateTime);
    Function GetSentST : TFslDateTime;
    Procedure SetSentST(value : TFslDateTime);
    Procedure SetReceived(value : TFhirDateTime);
    Function GetReceivedST : TFslDateTime;
    Procedure SetReceivedST(value : TFslDateTime);
    Procedure SetSender(value : TFhirReference{Resource});
    function GetReasonCodeList : TFhirCodeableConceptList;
    function GetHasReasonCodeList : Boolean;
    function GetReasonReferenceList : TFhirReferenceList{Resource};
    function GetHasReasonReferenceList : Boolean;
    function GetPayloadList : TFhirCommunicationPayloadList;
    function GetHasPayloadList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCommunication; overload;
    function Clone : TFhirCommunication; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Identifiers associated with this Communication that are defined by business processes and/ or used to refer to it when a direct URL reference to the resource itself is not appropriate (e.g. in CDA documents, or in written / printed documentation).
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A protocol, guideline, or other definition that was adhered to in whole or in part by this communication event.
    property definitionList : TFhirReferenceList{Resource} read GetDefinitionList;
    property hasDefinitionList : boolean read GetHasDefinitionList;

    // An order, proposal or plan fulfilled in whole or in part by this Communication.
    property basedOnList : TFhirReferenceList{TFhirReference} read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // Part of this action.
    property partOfList : TFhirReferenceList{TFhirReference} read GetPartOfList;
    property hasPartOfList : boolean read GetHasPartOfList;

    // The status of the transmission.
    property status : TFhirEventStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to If true, indicates that the described communication event did not actually occur.
    property notDone : Boolean read GetNotDoneST write SetNotDoneST;
    // If true, indicates that the described communication event did not actually occur.
    property notDoneElement : TFhirBoolean read FNotDone write SetNotDone;

    // Typed access to Describes why the communication event did not occur in coded and/or textual form. (defined for API consistency)
    property notDoneReason : TFhirCodeableConcept read FNotDoneReason write SetNotDoneReason;
    // Describes why the communication event did not occur in coded and/or textual form.
    property notDoneReasonElement : TFhirCodeableConcept read FNotDoneReason write SetNotDoneReason;

    // The type of message conveyed such as alert, notification, reminder, instruction, etc.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // A channel that was used for this communication (e.g. email, fax).
    property mediumList : TFhirCodeableConceptList read GetMediumList;
    property hasMediumList : boolean read GetHasMediumList;

    // Typed access to The patient or group that was the focus of this communication. (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // The patient or group that was the focus of this communication.
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // The entity (e.g. person, organization, clinical information system, or device) which was the target of the communication. If receipts need to be tracked by individual, a separate resource instance will need to be created for each recipient. ?Multiple recipient communications are intended where either a receipt(s) is not tracked (e.g. a mass mail-out) or is captured in aggregate (all emails confirmed received by a particular time).
    property recipientList : TFhirReferenceList{Resource} read GetRecipientList;
    property hasRecipientList : boolean read GetHasRecipientList;

    // The resources which were responsible for or related to producing this communication.
    property topicList : TFhirReferenceList{TFhirReference} read GetTopicList;
    property hasTopicList : boolean read GetHasTopicList;

    // Typed access to The encounter within which the communication was sent. (defined for API consistency)
    property context : TFhirReference{Resource} read FContext write SetContext;
    // The encounter within which the communication was sent.
    property contextElement : TFhirReference{Resource} read FContext write SetContext;

    // Typed access to The time when this communication was sent.
    property sent : TFslDateTime read GetSentST write SetSentST;
    // The time when this communication was sent.
    property sentElement : TFhirDateTime read FSent write SetSent;

    // Typed access to The time when this communication arrived at the destination.
    property received : TFslDateTime read GetReceivedST write SetReceivedST;
    // The time when this communication arrived at the destination.
    property receivedElement : TFhirDateTime read FReceived write SetReceived;

    // Typed access to The entity (e.g. person, organization, clinical information system, or device) which was the source of the communication. (defined for API consistency)
    property sender : TFhirReference{Resource} read FSender write SetSender;
    // The entity (e.g. person, organization, clinical information system, or device) which was the source of the communication.
    property senderElement : TFhirReference{Resource} read FSender write SetSender;

    // The reason or justification for the communication.
    property reasonCodeList : TFhirCodeableConceptList read GetReasonCodeList;
    property hasReasonCodeList : boolean read GetHasReasonCodeList;

    // Indicates another resource whose existence justifies this communication.
    property reasonReferenceList : TFhirReferenceList{Resource} read GetReasonReferenceList;
    property hasReasonReferenceList : boolean read GetHasReasonReferenceList;

    // Text, attachment(s), or resource(s) that was communicated to the recipient.
    property payloadList : TFhirCommunicationPayloadList read GetPayloadList;
    property hasPayloadList : boolean read GetHasPayloadList;

    // Additional notes or commentary about the communication by the sender, receiver or other interested parties.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirCommunicationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCommunicationList;
    function GetCurrent : TFhirCommunication;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCommunicationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCommunication read GetCurrent;
  end;

  TFhirCommunicationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCommunication;
    procedure SetItemN(index : Integer; value : TFhirCommunication);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCommunicationList; Overload;
    function Clone : TFhirCommunicationList; Overload;
    function GetEnumerator : TFhirCommunicationListEnumerator;

    //  Add a FhirCommunication to the end of the list.
    function Append : TFhirCommunication;

    // Add an already existing FhirCommunication to the end of the list.
    procedure AddItem(value : TFhirCommunication); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCommunication) : Integer;

    // Insert FhirCommunication before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCommunication;

    // Insert an existing FhirCommunication before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCommunication);

    // Get the iIndexth FhirCommunication. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCommunication);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCommunication;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCommunications[index : Integer] : TFhirCommunication read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_COMMUNICATION}

{$IFDEF FHIR_COMMUNICATIONREQUEST}

  // Text, attachment(s), or resource(s) to be communicated to the recipient.
  TFhirCommunicationRequestPayload = class (TFhirBackboneElement)
  protected
    FContent : TFhirType;
    Procedure SetContent(value : TFhirType);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCommunicationRequestPayload; overload;
    function Clone : TFhirCommunicationRequestPayload; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The communicated content (or for multi-part communications, one portion of the communication). (defined for API consistency)
    property content : TFhirType read FContent write SetContent;
    // The communicated content (or for multi-part communications, one portion of the communication).
    property contentElement : TFhirType read FContent write SetContent;

  end;

  TFhirCommunicationRequestPayloadListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCommunicationRequestPayloadList;
    function GetCurrent : TFhirCommunicationRequestPayload;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCommunicationRequestPayloadList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCommunicationRequestPayload read GetCurrent;
  end;

  TFhirCommunicationRequestPayloadList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCommunicationRequestPayload;
    procedure SetItemN(index : Integer; value : TFhirCommunicationRequestPayload);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCommunicationRequestPayloadList; Overload;
    function Clone : TFhirCommunicationRequestPayloadList; Overload;
    function GetEnumerator : TFhirCommunicationRequestPayloadListEnumerator;

    //  Add a FhirCommunicationRequestPayload to the end of the list.
    function Append : TFhirCommunicationRequestPayload;

    // Add an already existing FhirCommunicationRequestPayload to the end of the list.
    procedure AddItem(value : TFhirCommunicationRequestPayload); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCommunicationRequestPayload) : Integer;

    // Insert FhirCommunicationRequestPayload before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCommunicationRequestPayload;

    // Insert an existing FhirCommunicationRequestPayload before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCommunicationRequestPayload);

    // Get the iIndexth FhirCommunicationRequestPayload. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCommunicationRequestPayload);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCommunicationRequestPayload;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCommunicationRequestPayloads[index : Integer] : TFhirCommunicationRequestPayload read GetItemN write SetItemN; default;
  End;

  // The individual who initiated the request and has responsibility for its activation.
  TFhirCommunicationRequestRequester = class (TFhirBackboneElement)
  protected
    FAgent : TFhirReference{Resource};
    FOnBehalfOf : TFhirReference{TFhirOrganization};
    Procedure SetAgent(value : TFhirReference{Resource});
    Procedure SetOnBehalfOf(value : TFhirReference{TFhirOrganization});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCommunicationRequestRequester; overload;
    function Clone : TFhirCommunicationRequestRequester; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The device, practitioner, etc. who initiated the request. (defined for API consistency)
    property agent : TFhirReference{Resource} read FAgent write SetAgent;
    // The device, practitioner, etc. who initiated the request.
    property agentElement : TFhirReference{Resource} read FAgent write SetAgent;

    // Typed access to The organization the device or practitioner was acting on behalf of. (defined for API consistency)
    property onBehalfOf : TFhirReference{TFhirOrganization} read FOnBehalfOf write SetOnBehalfOf;
    // The organization the device or practitioner was acting on behalf of.
    property onBehalfOfElement : TFhirReference{TFhirOrganization} read FOnBehalfOf write SetOnBehalfOf;

  end;

  TFhirCommunicationRequestRequesterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCommunicationRequestRequesterList;
    function GetCurrent : TFhirCommunicationRequestRequester;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCommunicationRequestRequesterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCommunicationRequestRequester read GetCurrent;
  end;

  TFhirCommunicationRequestRequesterList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCommunicationRequestRequester;
    procedure SetItemN(index : Integer; value : TFhirCommunicationRequestRequester);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCommunicationRequestRequesterList; Overload;
    function Clone : TFhirCommunicationRequestRequesterList; Overload;
    function GetEnumerator : TFhirCommunicationRequestRequesterListEnumerator;

    //  Add a FhirCommunicationRequestRequester to the end of the list.
    function Append : TFhirCommunicationRequestRequester;

    // Add an already existing FhirCommunicationRequestRequester to the end of the list.
    procedure AddItem(value : TFhirCommunicationRequestRequester); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCommunicationRequestRequester) : Integer;

    // Insert FhirCommunicationRequestRequester before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCommunicationRequestRequester;

    // Insert an existing FhirCommunicationRequestRequester before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCommunicationRequestRequester);

    // Get the iIndexth FhirCommunicationRequestRequester. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCommunicationRequestRequester);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCommunicationRequestRequester;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCommunicationRequestRequesters[index : Integer] : TFhirCommunicationRequestRequester read GetItemN write SetItemN; default;
  End;

  // A request to convey information; e.g. the CDS system proposes that an alert be sent to a responsible provider, the CDS system proposes that the public health agency be notified about a reportable condition.
  TFhirCommunicationRequest = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FbasedOnList : TFhirReferenceList{TFhirReference};
    FreplacesList : TFhirReferenceList{TFhirCommunicationRequest};
    FGroupIdentifier : TFhirIdentifier;
    FStatus : TFhirEnum;
    FcategoryList : TFhirCodeableConceptList;
    FPriority : TFhirEnum;
    FmediumList : TFhirCodeableConceptList;
    FSubject : TFhirReference{Resource};
    FrecipientList : TFhirReferenceList{Resource};
    FtopicList : TFhirReferenceList{TFhirReference};
    FContext : TFhirReference{Resource};
    FpayloadList : TFhirCommunicationRequestPayloadList;
    FOccurrence : TFhirType;
    FAuthoredOn : TFhirDateTime;
    FSender : TFhirReference{Resource};
    FRequester : TFhirCommunicationRequestRequester;
    FreasonCodeList : TFhirCodeableConceptList;
    FreasonReferenceList : TFhirReferenceList{Resource};
    FnoteList : TFhirAnnotationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetBasedOnList : TFhirReferenceList{TFhirReference};
    function GetHasBasedOnList : Boolean;
    function GetReplacesList : TFhirReferenceList{TFhirCommunicationRequest};
    function GetHasReplacesList : Boolean;
    Procedure SetGroupIdentifier(value : TFhirIdentifier);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirRequestStatusEnum;
    Procedure SetStatusST(value : TFhirRequestStatusEnum);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    Procedure SetPriority(value : TFhirEnum);
    Function GetPriorityST : TFhirRequestPriorityEnum;
    Procedure SetPriorityST(value : TFhirRequestPriorityEnum);
    function GetMediumList : TFhirCodeableConceptList;
    function GetHasMediumList : Boolean;
    Procedure SetSubject(value : TFhirReference{Resource});
    function GetRecipientList : TFhirReferenceList{Resource};
    function GetHasRecipientList : Boolean;
    function GetTopicList : TFhirReferenceList{TFhirReference};
    function GetHasTopicList : Boolean;
    Procedure SetContext(value : TFhirReference{Resource});
    function GetPayloadList : TFhirCommunicationRequestPayloadList;
    function GetHasPayloadList : Boolean;
    Procedure SetOccurrence(value : TFhirType);
    Procedure SetAuthoredOn(value : TFhirDateTime);
    Function GetAuthoredOnST : TFslDateTime;
    Procedure SetAuthoredOnST(value : TFslDateTime);
    Procedure SetSender(value : TFhirReference{Resource});
    Procedure SetRequester(value : TFhirCommunicationRequestRequester);
    function GetReasonCodeList : TFhirCodeableConceptList;
    function GetHasReasonCodeList : Boolean;
    function GetReasonReferenceList : TFhirReferenceList{Resource};
    function GetHasReasonReferenceList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCommunicationRequest; overload;
    function Clone : TFhirCommunicationRequest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // A unique ID of this request for reference purposes. It must be provided if user wants it returned as part of any output, otherwise it will be autogenerated, if needed, by CDS system. Does not need to be the actual ID of the source system.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A plan or proposal that is fulfilled in whole or in part by this request.
    property basedOnList : TFhirReferenceList{TFhirReference} read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // Completed or terminated request(s) whose function is taken by this new request.
    property replacesList : TFhirReferenceList{TFhirCommunicationRequest} read GetReplacesList;
    property hasReplacesList : boolean read GetHasReplacesList;

    // Typed access to A shared identifier common to all requests that were authorized more or less simultaneously by a single author, representing the identifier of the requisition, prescription or similar form. (defined for API consistency)
    property groupIdentifier : TFhirIdentifier read FGroupIdentifier write SetGroupIdentifier;
    // A shared identifier common to all requests that were authorized more or less simultaneously by a single author, representing the identifier of the requisition, prescription or similar form.
    property groupIdentifierElement : TFhirIdentifier read FGroupIdentifier write SetGroupIdentifier;

    // The status of the proposal or order.
    property status : TFhirRequestStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // The type of message to be sent such as alert, notification, reminder, instruction, etc.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Characterizes how quickly the proposed act must be initiated. Includes concepts such as stat, urgent, routine.
    property priority : TFhirRequestPriorityEnum read GetPriorityST write SetPriorityST;
    property priorityElement : TFhirEnum read FPriority write SetPriority;

    // A channel that was used for this communication (e.g. email, fax).
    property mediumList : TFhirCodeableConceptList read GetMediumList;
    property hasMediumList : boolean read GetHasMediumList;

    // Typed access to The patient or group that is the focus of this communication request. (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // The patient or group that is the focus of this communication request.
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // The entity (e.g. person, organization, clinical information system, device, group, or care team) which is the intended target of the communication.
    property recipientList : TFhirReferenceList{Resource} read GetRecipientList;
    property hasRecipientList : boolean read GetHasRecipientList;

    // The resources which were related to producing this communication request.
    property topicList : TFhirReferenceList{TFhirReference} read GetTopicList;
    property hasTopicList : boolean read GetHasTopicList;

    // Typed access to The encounter or episode of care within which the communication request was created. (defined for API consistency)
    property context : TFhirReference{Resource} read FContext write SetContext;
    // The encounter or episode of care within which the communication request was created.
    property contextElement : TFhirReference{Resource} read FContext write SetContext;

    // Text, attachment(s), or resource(s) to be communicated to the recipient.
    property payloadList : TFhirCommunicationRequestPayloadList read GetPayloadList;
    property hasPayloadList : boolean read GetHasPayloadList;

    // Typed access to The time when this communication is to occur. (defined for API consistency)
    property occurrence : TFhirType read FOccurrence write SetOccurrence;
    // The time when this communication is to occur.
    property occurrenceElement : TFhirType read FOccurrence write SetOccurrence;

    // Typed access to For draft requests, indicates the date of initial creation.  For requests with other statuses, indicates the date of activation.
    property authoredOn : TFslDateTime read GetAuthoredOnST write SetAuthoredOnST;
    // For draft requests, indicates the date of initial creation.  For requests with other statuses, indicates the date of activation.
    property authoredOnElement : TFhirDateTime read FAuthoredOn write SetAuthoredOn;

    // Typed access to The entity (e.g. person, organization, clinical information system, or device) which is to be the source of the communication. (defined for API consistency)
    property sender : TFhirReference{Resource} read FSender write SetSender;
    // The entity (e.g. person, organization, clinical information system, or device) which is to be the source of the communication.
    property senderElement : TFhirReference{Resource} read FSender write SetSender;

    // Typed access to The individual who initiated the request and has responsibility for its activation. (defined for API consistency)
    property requester : TFhirCommunicationRequestRequester read FRequester write SetRequester;
    // The individual who initiated the request and has responsibility for its activation.
    property requesterElement : TFhirCommunicationRequestRequester read FRequester write SetRequester;

    // Describes why the request is being made in coded or textual form.
    property reasonCodeList : TFhirCodeableConceptList read GetReasonCodeList;
    property hasReasonCodeList : boolean read GetHasReasonCodeList;

    // Indicates another resource whose existence justifies this request.
    property reasonReferenceList : TFhirReferenceList{Resource} read GetReasonReferenceList;
    property hasReasonReferenceList : boolean read GetHasReasonReferenceList;

    // Comments made about the request by the requester, sender, recipient, subject or other participants.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirCommunicationRequestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCommunicationRequestList;
    function GetCurrent : TFhirCommunicationRequest;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCommunicationRequestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCommunicationRequest read GetCurrent;
  end;

  TFhirCommunicationRequestList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCommunicationRequest;
    procedure SetItemN(index : Integer; value : TFhirCommunicationRequest);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCommunicationRequestList; Overload;
    function Clone : TFhirCommunicationRequestList; Overload;
    function GetEnumerator : TFhirCommunicationRequestListEnumerator;

    //  Add a FhirCommunicationRequest to the end of the list.
    function Append : TFhirCommunicationRequest;

    // Add an already existing FhirCommunicationRequest to the end of the list.
    procedure AddItem(value : TFhirCommunicationRequest); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCommunicationRequest) : Integer;

    // Insert FhirCommunicationRequest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCommunicationRequest;

    // Insert an existing FhirCommunicationRequest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCommunicationRequest);

    // Get the iIndexth FhirCommunicationRequest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCommunicationRequest);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCommunicationRequest;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCommunicationRequests[index : Integer] : TFhirCommunicationRequest read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_COMMUNICATIONREQUEST}

{$IFDEF FHIR_COMPOSITION}

  // A participant who has attested to the accuracy of the composition/document.
  TFhirCompositionAttester = class (TFhirBackboneElement)
  protected
    FMode : TFhirEnumList;
    FTime : TFhirDateTime;
    FParty : TFhirReference{Resource};
    function GetMode : TFhirEnumList;
    function GetHasMode : Boolean;
    Function GetModeST : TFhirCompositionAttestationModeEnumList;
    Procedure SetModeST(value : TFhirCompositionAttestationModeEnumList);
    Procedure SetTime(value : TFhirDateTime);
    Function GetTimeST : TFslDateTime;
    Procedure SetTimeST(value : TFslDateTime);
    Procedure SetParty(value : TFhirReference{Resource});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCompositionAttester; overload;
    function Clone : TFhirCompositionAttester; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The type of attestation the authenticator offers.
    property mode : TFhirCompositionAttestationModeEnumList read GetModeST write SetModeST;
    property modeList : TFhirEnumList read GetMode;
    property hasMode : boolean read GetHasMode;
    // Typed access to When the composition was attested by the party.
    property time : TFslDateTime read GetTimeST write SetTimeST;
    // When the composition was attested by the party.
    property timeElement : TFhirDateTime read FTime write SetTime;

    // Typed access to Who attested the composition in the specified way. (defined for API consistency)
    property party : TFhirReference{Resource} read FParty write SetParty;
    // Who attested the composition in the specified way.
    property partyElement : TFhirReference{Resource} read FParty write SetParty;

  end;

  TFhirCompositionAttesterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCompositionAttesterList;
    function GetCurrent : TFhirCompositionAttester;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCompositionAttesterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCompositionAttester read GetCurrent;
  end;

  TFhirCompositionAttesterList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCompositionAttester;
    procedure SetItemN(index : Integer; value : TFhirCompositionAttester);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCompositionAttesterList; Overload;
    function Clone : TFhirCompositionAttesterList; Overload;
    function GetEnumerator : TFhirCompositionAttesterListEnumerator;

    //  Add a FhirCompositionAttester to the end of the list.
    function Append : TFhirCompositionAttester;

    // Add an already existing FhirCompositionAttester to the end of the list.
    procedure AddItem(value : TFhirCompositionAttester); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCompositionAttester) : Integer;

    // Insert FhirCompositionAttester before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCompositionAttester;

    // Insert an existing FhirCompositionAttester before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCompositionAttester);

    // Get the iIndexth FhirCompositionAttester. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCompositionAttester);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCompositionAttester;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCompositionAttesters[index : Integer] : TFhirCompositionAttester read GetItemN write SetItemN; default;
  End;

  // Relationships that this composition has with other compositions or documents that already exist.
  TFhirCompositionRelatesTo = class (TFhirBackboneElement)
  protected
    FCode : TFhirEnum;
    FTarget : TFhirType;
    Procedure SetCode(value : TFhirEnum);
    Function GetCodeST : TFhirDocumentRelationshipTypeEnum;
    Procedure SetCodeST(value : TFhirDocumentRelationshipTypeEnum);
    Procedure SetTarget(value : TFhirType);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCompositionRelatesTo; overload;
    function Clone : TFhirCompositionRelatesTo; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The type of relationship that this composition has with anther composition or document.
    property code : TFhirDocumentRelationshipTypeEnum read GetCodeST write SetCodeST;
    property codeElement : TFhirEnum read FCode write SetCode;

    // Typed access to The target composition/document of this relationship. (defined for API consistency)
    property target : TFhirType read FTarget write SetTarget;
    // The target composition/document of this relationship.
    property targetElement : TFhirType read FTarget write SetTarget;

  end;

  TFhirCompositionRelatesToListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCompositionRelatesToList;
    function GetCurrent : TFhirCompositionRelatesTo;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCompositionRelatesToList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCompositionRelatesTo read GetCurrent;
  end;

  TFhirCompositionRelatesToList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCompositionRelatesTo;
    procedure SetItemN(index : Integer; value : TFhirCompositionRelatesTo);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCompositionRelatesToList; Overload;
    function Clone : TFhirCompositionRelatesToList; Overload;
    function GetEnumerator : TFhirCompositionRelatesToListEnumerator;

    //  Add a FhirCompositionRelatesTo to the end of the list.
    function Append : TFhirCompositionRelatesTo;

    // Add an already existing FhirCompositionRelatesTo to the end of the list.
    procedure AddItem(value : TFhirCompositionRelatesTo); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCompositionRelatesTo) : Integer;

    // Insert FhirCompositionRelatesTo before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCompositionRelatesTo;

    // Insert an existing FhirCompositionRelatesTo before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCompositionRelatesTo);

    // Get the iIndexth FhirCompositionRelatesTo. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCompositionRelatesTo);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCompositionRelatesTo;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCompositionRelatesTos[index : Integer] : TFhirCompositionRelatesTo read GetItemN write SetItemN; default;
  End;

  // The clinical service, such as a colonoscopy or an appendectomy, being documented.
  TFhirCompositionEvent = class (TFhirBackboneElement)
  protected
    FcodeList : TFhirCodeableConceptList;
    FPeriod : TFhirPeriod;
    FdetailList : TFhirReferenceList{TFhirReference};
    function GetCodeList : TFhirCodeableConceptList;
    function GetHasCodeList : Boolean;
    Procedure SetPeriod(value : TFhirPeriod);
    function GetDetailList : TFhirReferenceList{TFhirReference};
    function GetHasDetailList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCompositionEvent; overload;
    function Clone : TFhirCompositionEvent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // This list of codes represents the main clinical acts, such as a colonoscopy or an appendectomy, being documented. In some cases, the event is inherent in the typeCode, such as a "History and Physical Report" in which the procedure being documented is necessarily a "History and Physical" act.
    property codeList : TFhirCodeableConceptList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // Typed access to The period of time covered by the documentation. There is no assertion that the documentation is a complete representation for this period, only that it documents events during this time. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period of time covered by the documentation. There is no assertion that the documentation is a complete representation for this period, only that it documents events during this time.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // The description and/or reference of the event(s) being documented. For example, this could be used to document such a colonoscopy or an appendectomy.
    property detailList : TFhirReferenceList{TFhirReference} read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

  end;

  TFhirCompositionEventListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCompositionEventList;
    function GetCurrent : TFhirCompositionEvent;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCompositionEventList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCompositionEvent read GetCurrent;
  end;

  TFhirCompositionEventList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCompositionEvent;
    procedure SetItemN(index : Integer; value : TFhirCompositionEvent);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCompositionEventList; Overload;
    function Clone : TFhirCompositionEventList; Overload;
    function GetEnumerator : TFhirCompositionEventListEnumerator;

    //  Add a FhirCompositionEvent to the end of the list.
    function Append : TFhirCompositionEvent;

    // Add an already existing FhirCompositionEvent to the end of the list.
    procedure AddItem(value : TFhirCompositionEvent); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCompositionEvent) : Integer;

    // Insert FhirCompositionEvent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCompositionEvent;

    // Insert an existing FhirCompositionEvent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCompositionEvent);

    // Get the iIndexth FhirCompositionEvent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCompositionEvent);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCompositionEvent;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCompositionEvents[index : Integer] : TFhirCompositionEvent read GetItemN write SetItemN; default;
  End;

  // The root of the sections that make up the composition.
  TFhirCompositionSection = class (TFhirBackboneElement)
  protected
    FTitle : TFhirString;
    FCode : TFhirCodeableConcept;
    FText : TFhirNarrative;
    FMode : TFhirEnum;
    FOrderedBy : TFhirCodeableConcept;
    FentryList : TFhirReferenceList{TFhirReference};
    FEmptyReason : TFhirCodeableConcept;
    FsectionList : TFhirCompositionSectionList;
    Procedure SetTitle(value : TFhirString);
    Function GetTitleST : String;
    Procedure SetTitleST(value : String);
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetText(value : TFhirNarrative);
    Procedure SetMode(value : TFhirEnum);
    Function GetModeST : TFhirListModeEnum;
    Procedure SetModeST(value : TFhirListModeEnum);
    Procedure SetOrderedBy(value : TFhirCodeableConcept);
    function GetEntryList : TFhirReferenceList{TFhirReference};
    function GetHasEntryList : Boolean;
    Procedure SetEmptyReason(value : TFhirCodeableConcept);
    function GetSectionList : TFhirCompositionSectionList;
    function GetHasSectionList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCompositionSection; overload;
    function Clone : TFhirCompositionSection; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The label for this particular section.  This will be part of the rendered content for the document, and is often used to build a table of contents.
    property title : String read GetTitleST write SetTitleST;
    // The label for this particular section.  This will be part of the rendered content for the document, and is often used to build a table of contents.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to A code identifying the kind of content contained within the section. This must be consistent with the section title. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code identifying the kind of content contained within the section. This must be consistent with the section title.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to A human-readable narrative that contains the attested content of the section, used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. (defined for API consistency)
    property text : TFhirNarrative read FText write SetText;
    // A human-readable narrative that contains the attested content of the section, used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative.
    property textElement : TFhirNarrative read FText write SetText;

    // How the entry list was prepared - whether it is a working list that is suitable for being maintained on an ongoing basis, or if it represents a snapshot of a list of items from another source, or whether it is a prepared list where items may be marked as added, modified or deleted.
    property mode : TFhirListModeEnum read GetModeST write SetModeST;
    property modeElement : TFhirEnum read FMode write SetMode;

    // Typed access to Specifies the order applied to the items in the section entries. (defined for API consistency)
    property orderedBy : TFhirCodeableConcept read FOrderedBy write SetOrderedBy;
    // Specifies the order applied to the items in the section entries.
    property orderedByElement : TFhirCodeableConcept read FOrderedBy write SetOrderedBy;

    // A reference to the actual resource from which the narrative in the section is derived.
    property entryList : TFhirReferenceList{TFhirReference} read GetEntryList;
    property hasEntryList : boolean read GetHasEntryList;

    // Typed access to If the section is empty, why the list is empty. An empty section typically has some text explaining the empty reason. (defined for API consistency)
    property emptyReason : TFhirCodeableConcept read FEmptyReason write SetEmptyReason;
    // If the section is empty, why the list is empty. An empty section typically has some text explaining the empty reason.
    property emptyReasonElement : TFhirCodeableConcept read FEmptyReason write SetEmptyReason;

    // A nested sub-section within this section.
    property sectionList : TFhirCompositionSectionList read GetSectionList;
    property hasSectionList : boolean read GetHasSectionList;

  end;

  TFhirCompositionSectionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCompositionSectionList;
    function GetCurrent : TFhirCompositionSection;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCompositionSectionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCompositionSection read GetCurrent;
  end;

  TFhirCompositionSectionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCompositionSection;
    procedure SetItemN(index : Integer; value : TFhirCompositionSection);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCompositionSectionList; Overload;
    function Clone : TFhirCompositionSectionList; Overload;
    function GetEnumerator : TFhirCompositionSectionListEnumerator;

    //  Add a FhirCompositionSection to the end of the list.
    function Append : TFhirCompositionSection;

    // Add an already existing FhirCompositionSection to the end of the list.
    procedure AddItem(value : TFhirCompositionSection); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCompositionSection) : Integer;

    // Insert FhirCompositionSection before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCompositionSection;

    // Insert an existing FhirCompositionSection before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCompositionSection);

    // Get the iIndexth FhirCompositionSection. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCompositionSection);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCompositionSection;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCompositionSections[index : Integer] : TFhirCompositionSection read GetItemN write SetItemN; default;
  End;

  // A set of healthcare-related information that is assembled together into a single logical document that provides a single coherent statement of meaning, establishes its own context and that has clinical attestation with regard to who is making the statement. While a Composition defines the structure, it does not actually contain the content: rather the full content of a document is contained in a Bundle, of which the Composition is the first resource contained.
  TFhirComposition = class (TFhirDomainResource)
  protected
    FIdentifier : TFhirIdentifier;
    FStatus : TFhirEnum;
    FType_ : TFhirCodeableConcept;
    FClass_ : TFhirCodeableConcept;
    FSubject : TFhirReference{TFhirReference};
    FEncounter : TFhirReference{TFhirEncounter};
    FDate : TFhirDateTime;
    FauthorList : TFhirReferenceList{Resource};
    FTitle : TFhirString;
    FConfidentiality : TFhirEnum;
    FattesterList : TFhirCompositionAttesterList;
    FCustodian : TFhirReference{TFhirOrganization};
    FrelatesToList : TFhirCompositionRelatesToList;
    FeventList : TFhirCompositionEventList;
    FsectionList : TFhirCompositionSectionList;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirCompositionStatusEnum;
    Procedure SetStatusST(value : TFhirCompositionStatusEnum);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetClass_(value : TFhirCodeableConcept);
    Procedure SetSubject(value : TFhirReference{TFhirReference});
    Procedure SetEncounter(value : TFhirReference{TFhirEncounter});
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    function GetAuthorList : TFhirReferenceList{Resource};
    function GetHasAuthorList : Boolean;
    Procedure SetTitle(value : TFhirString);
    Function GetTitleST : String;
    Procedure SetTitleST(value : String);
    Procedure SetConfidentiality(value : TFhirEnum);
    Function GetConfidentialityST : TFhirV3ConfidentialityClassificationEnum;
    Procedure SetConfidentialityST(value : TFhirV3ConfidentialityClassificationEnum);
    function GetAttesterList : TFhirCompositionAttesterList;
    function GetHasAttesterList : Boolean;
    Procedure SetCustodian(value : TFhirReference{TFhirOrganization});
    function GetRelatesToList : TFhirCompositionRelatesToList;
    function GetHasRelatesToList : Boolean;
    function GetEventList : TFhirCompositionEventList;
    function GetHasEventList : Boolean;
    function GetSectionList : TFhirCompositionSectionList;
    function GetHasSectionList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirComposition; overload;
    function Clone : TFhirComposition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Logical identifier for the composition, assigned when created. This identifier stays constant as the composition is changed over time. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Logical identifier for the composition, assigned when created. This identifier stays constant as the composition is changed over time.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // The workflow/clinical status of this composition. The status is a marker for the clinical standing of the document.
    property status : TFhirCompositionStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Specifies the particular kind of composition (e.g. History and Physical, Discharge Summary, Progress Note). This usually equates to the purpose of making the composition. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Specifies the particular kind of composition (e.g. History and Physical, Discharge Summary, Progress Note). This usually equates to the purpose of making the composition.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A categorization for the type of the composition - helps for indexing and searching. This may be implied by or derived from the code specified in the Composition Type. (defined for API consistency)
    property class_ : TFhirCodeableConcept read FClass_ write SetClass_;
    // A categorization for the type of the composition - helps for indexing and searching. This may be implied by or derived from the code specified in the Composition Type.
    property class_Element : TFhirCodeableConcept read FClass_ write SetClass_;

    // Typed access to Who or what the composition is about. The composition can be about a person, (patient or healthcare practitioner), a device (e.g. a machine) or even a group of subjects (such as a document about a herd of livestock, or a set of patients that share a common exposure). (defined for API consistency)
    property subject : TFhirReference{TFhirReference} read FSubject write SetSubject;
    // Who or what the composition is about. The composition can be about a person, (patient or healthcare practitioner), a device (e.g. a machine) or even a group of subjects (such as a document about a herd of livestock, or a set of patients that share a common exposure).
    property subjectElement : TFhirReference{TFhirReference} read FSubject write SetSubject;

    // Typed access to Describes the clinical encounter or type of care this documentation is associated with. (defined for API consistency)
    property encounter : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;
    // Describes the clinical encounter or type of care this documentation is associated with.
    property encounterElement : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;

    // Typed access to The composition editing time, when the composition was last logically changed by the author.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The composition editing time, when the composition was last logically changed by the author.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Identifies who is responsible for the information in the composition, not necessarily who typed it in.
    property authorList : TFhirReferenceList{Resource} read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // Typed access to Official human-readable label for the composition.
    property title : String read GetTitleST write SetTitleST;
    // Official human-readable label for the composition.
    property titleElement : TFhirString read FTitle write SetTitle;

    // The code specifying the level of confidentiality of the Composition.
    property confidentiality : TFhirV3ConfidentialityClassificationEnum read GetConfidentialityST write SetConfidentialityST;
    property confidentialityElement : TFhirEnum read FConfidentiality write SetConfidentiality;

    // A participant who has attested to the accuracy of the composition/document.
    property attesterList : TFhirCompositionAttesterList read GetAttesterList;
    property hasAttesterList : boolean read GetHasAttesterList;

    // Typed access to Identifies the organization or group who is responsible for ongoing maintenance of and access to the composition/document information. (defined for API consistency)
    property custodian : TFhirReference{TFhirOrganization} read FCustodian write SetCustodian;
    // Identifies the organization or group who is responsible for ongoing maintenance of and access to the composition/document information.
    property custodianElement : TFhirReference{TFhirOrganization} read FCustodian write SetCustodian;

    // Relationships that this composition has with other compositions or documents that already exist.
    property relatesToList : TFhirCompositionRelatesToList read GetRelatesToList;
    property hasRelatesToList : boolean read GetHasRelatesToList;

    // The clinical service, such as a colonoscopy or an appendectomy, being documented.
    property eventList : TFhirCompositionEventList read GetEventList;
    property hasEventList : boolean read GetHasEventList;

    // The root of the sections that make up the composition.
    property sectionList : TFhirCompositionSectionList read GetSectionList;
    property hasSectionList : boolean read GetHasSectionList;

  end;

  TFhirCompositionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCompositionList;
    function GetCurrent : TFhirComposition;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCompositionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirComposition read GetCurrent;
  end;

  TFhirCompositionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirComposition;
    procedure SetItemN(index : Integer; value : TFhirComposition);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCompositionList; Overload;
    function Clone : TFhirCompositionList; Overload;
    function GetEnumerator : TFhirCompositionListEnumerator;

    //  Add a FhirComposition to the end of the list.
    function Append : TFhirComposition;

    // Add an already existing FhirComposition to the end of the list.
    procedure AddItem(value : TFhirComposition); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirComposition) : Integer;

    // Insert FhirComposition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirComposition;

    // Insert an existing FhirComposition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirComposition);

    // Get the iIndexth FhirComposition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirComposition);

    // The number of items in the collection
    function Item(index : Integer) : TFhirComposition;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCompositions[index : Integer] : TFhirComposition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_COMPOSITION}

{$IFDEF FHIR_CONDITION}

  // Clinical stage or grade of a condition. May include formal severity assessments.
  TFhirConditionStage = class (TFhirBackboneElement)
  protected
    FSummary : TFhirCodeableConcept;
    FassessmentList : TFhirReferenceList{Resource};
    Procedure SetSummary(value : TFhirCodeableConcept);
    function GetAssessmentList : TFhirReferenceList{Resource};
    function GetHasAssessmentList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConditionStage; overload;
    function Clone : TFhirConditionStage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A simple summary of the stage such as "Stage 3". The determination of the stage is disease-specific. (defined for API consistency)
    property summary : TFhirCodeableConcept read FSummary write SetSummary;
    // A simple summary of the stage such as "Stage 3". The determination of the stage is disease-specific.
    property summaryElement : TFhirCodeableConcept read FSummary write SetSummary;

    // Reference to a formal record of the evidence on which the staging assessment is based.
    property assessmentList : TFhirReferenceList{Resource} read GetAssessmentList;
    property hasAssessmentList : boolean read GetHasAssessmentList;

  end;

  TFhirConditionStageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConditionStageList;
    function GetCurrent : TFhirConditionStage;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConditionStageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConditionStage read GetCurrent;
  end;

  TFhirConditionStageList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConditionStage;
    procedure SetItemN(index : Integer; value : TFhirConditionStage);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConditionStageList; Overload;
    function Clone : TFhirConditionStageList; Overload;
    function GetEnumerator : TFhirConditionStageListEnumerator;

    //  Add a FhirConditionStage to the end of the list.
    function Append : TFhirConditionStage;

    // Add an already existing FhirConditionStage to the end of the list.
    procedure AddItem(value : TFhirConditionStage); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConditionStage) : Integer;

    // Insert FhirConditionStage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConditionStage;

    // Insert an existing FhirConditionStage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConditionStage);

    // Get the iIndexth FhirConditionStage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConditionStage);

    // The number of items in the collection
    function Item(index : Integer) : TFhirConditionStage;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirConditionStages[index : Integer] : TFhirConditionStage read GetItemN write SetItemN; default;
  End;

  // Supporting Evidence / manifestations that are the basis on which this condition is suspected or confirmed.
  TFhirConditionEvidence = class (TFhirBackboneElement)
  protected
    FcodeList : TFhirCodeableConceptList;
    FdetailList : TFhirReferenceList{TFhirReference};
    function GetCodeList : TFhirCodeableConceptList;
    function GetHasCodeList : Boolean;
    function GetDetailList : TFhirReferenceList{TFhirReference};
    function GetHasDetailList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConditionEvidence; overload;
    function Clone : TFhirConditionEvidence; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // A manifestation or symptom that led to the recording of this condition.
    property codeList : TFhirCodeableConceptList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // Links to other relevant information, including pathology reports.
    property detailList : TFhirReferenceList{TFhirReference} read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

  end;

  TFhirConditionEvidenceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConditionEvidenceList;
    function GetCurrent : TFhirConditionEvidence;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConditionEvidenceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConditionEvidence read GetCurrent;
  end;

  TFhirConditionEvidenceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConditionEvidence;
    procedure SetItemN(index : Integer; value : TFhirConditionEvidence);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConditionEvidenceList; Overload;
    function Clone : TFhirConditionEvidenceList; Overload;
    function GetEnumerator : TFhirConditionEvidenceListEnumerator;

    //  Add a FhirConditionEvidence to the end of the list.
    function Append : TFhirConditionEvidence;

    // Add an already existing FhirConditionEvidence to the end of the list.
    procedure AddItem(value : TFhirConditionEvidence); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConditionEvidence) : Integer;

    // Insert FhirConditionEvidence before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConditionEvidence;

    // Insert an existing FhirConditionEvidence before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConditionEvidence);

    // Get the iIndexth FhirConditionEvidence. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConditionEvidence);

    // The number of items in the collection
    function Item(index : Integer) : TFhirConditionEvidence;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirConditionEvidences[index : Integer] : TFhirConditionEvidence read GetItemN write SetItemN; default;
  End;

  // A clinical condition, problem, diagnosis, or other event, situation, issue, or clinical concept that has risen to a level of concern.
  TFhirCondition = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FClinicalStatus : TFhirEnum;
    FVerificationStatus : TFhirEnum;
    FcategoryList : TFhirCodeableConceptList;
    FSeverity : TFhirCodeableConcept;
    FCode : TFhirCodeableConcept;
    FbodySiteList : TFhirCodeableConceptList;
    FSubject : TFhirReference{Resource};
    FContext : TFhirReference{Resource};
    FOnset : TFhirType;
    FAbatement : TFhirType;
    FAssertedDate : TFhirDateTime;
    FAsserter : TFhirReference{Resource};
    FStage : TFhirConditionStage;
    FevidenceList : TFhirConditionEvidenceList;
    FnoteList : TFhirAnnotationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetClinicalStatus(value : TFhirEnum);
    Function GetClinicalStatusST : TFhirConditionClinicalEnum;
    Procedure SetClinicalStatusST(value : TFhirConditionClinicalEnum);
    Procedure SetVerificationStatus(value : TFhirEnum);
    Function GetVerificationStatusST : TFhirConditionVerStatusEnum;
    Procedure SetVerificationStatusST(value : TFhirConditionVerStatusEnum);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    Procedure SetSeverity(value : TFhirCodeableConcept);
    Procedure SetCode(value : TFhirCodeableConcept);
    function GetBodySiteList : TFhirCodeableConceptList;
    function GetHasBodySiteList : Boolean;
    Procedure SetSubject(value : TFhirReference{Resource});
    Procedure SetContext(value : TFhirReference{Resource});
    Procedure SetOnset(value : TFhirType);
    Procedure SetAbatement(value : TFhirType);
    Procedure SetAssertedDate(value : TFhirDateTime);
    Function GetAssertedDateST : TFslDateTime;
    Procedure SetAssertedDateST(value : TFslDateTime);
    Procedure SetAsserter(value : TFhirReference{Resource});
    Procedure SetStage(value : TFhirConditionStage);
    function GetEvidenceList : TFhirConditionEvidenceList;
    function GetHasEvidenceList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCondition; overload;
    function Clone : TFhirCondition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // This records identifiers associated with this condition that are defined by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate (e.g. in CDA documents, or in written / printed documentation).
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The clinical status of the condition.
    property clinicalStatus : TFhirConditionClinicalEnum read GetClinicalStatusST write SetClinicalStatusST;
    property clinicalStatusElement : TFhirEnum read FClinicalStatus write SetClinicalStatus;

    // The verification status to support the clinical status of the condition.
    property verificationStatus : TFhirConditionVerStatusEnum read GetVerificationStatusST write SetVerificationStatusST;
    property verificationStatusElement : TFhirEnum read FVerificationStatus write SetVerificationStatus;

    // A category assigned to the condition.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to A subjective assessment of the severity of the condition as evaluated by the clinician. (defined for API consistency)
    property severity : TFhirCodeableConcept read FSeverity write SetSeverity;
    // A subjective assessment of the severity of the condition as evaluated by the clinician.
    property severityElement : TFhirCodeableConcept read FSeverity write SetSeverity;

    // Typed access to Identification of the condition, problem or diagnosis. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Identification of the condition, problem or diagnosis.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // The anatomical location where this condition manifests itself.
    property bodySiteList : TFhirCodeableConceptList read GetBodySiteList;
    property hasBodySiteList : boolean read GetHasBodySiteList;

    // Typed access to Indicates the patient or group who the condition record is associated with. (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // Indicates the patient or group who the condition record is associated with.
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // Typed access to Encounter during which the condition was first asserted. (defined for API consistency)
    property context : TFhirReference{Resource} read FContext write SetContext;
    // Encounter during which the condition was first asserted.
    property contextElement : TFhirReference{Resource} read FContext write SetContext;

    // Typed access to Estimated or actual date or date-time  the condition began, in the opinion of the clinician. (defined for API consistency)
    property onset : TFhirType read FOnset write SetOnset;
    // Estimated or actual date or date-time  the condition began, in the opinion of the clinician.
    property onsetElement : TFhirType read FOnset write SetOnset;

    // Typed access to The date or estimated date that the condition resolved or went into remission. This is called "abatement" because of the many overloaded connotations associated with "remission" or "resolution" - Conditions are never really resolved, but they can abate. (defined for API consistency)
    property abatement : TFhirType read FAbatement write SetAbatement;
    // The date or estimated date that the condition resolved or went into remission. This is called "abatement" because of the many overloaded connotations associated with "remission" or "resolution" - Conditions are never really resolved, but they can abate.
    property abatementElement : TFhirType read FAbatement write SetAbatement;

    // Typed access to The date on which the existance of the Condition was first asserted or acknowledged.
    property assertedDate : TFslDateTime read GetAssertedDateST write SetAssertedDateST;
    // The date on which the existance of the Condition was first asserted or acknowledged.
    property assertedDateElement : TFhirDateTime read FAssertedDate write SetAssertedDate;

    // Typed access to Individual who is making the condition statement. (defined for API consistency)
    property asserter : TFhirReference{Resource} read FAsserter write SetAsserter;
    // Individual who is making the condition statement.
    property asserterElement : TFhirReference{Resource} read FAsserter write SetAsserter;

    // Typed access to Clinical stage or grade of a condition. May include formal severity assessments. (defined for API consistency)
    property stage : TFhirConditionStage read FStage write SetStage;
    // Clinical stage or grade of a condition. May include formal severity assessments.
    property stageElement : TFhirConditionStage read FStage write SetStage;

    // Supporting Evidence / manifestations that are the basis on which this condition is suspected or confirmed.
    property evidenceList : TFhirConditionEvidenceList read GetEvidenceList;
    property hasEvidenceList : boolean read GetHasEvidenceList;

    // Additional information about the Condition. This is a general notes/comments entry  for description of the Condition, its diagnosis and prognosis.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirConditionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConditionList;
    function GetCurrent : TFhirCondition;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConditionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCondition read GetCurrent;
  end;

  TFhirConditionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCondition;
    procedure SetItemN(index : Integer; value : TFhirCondition);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConditionList; Overload;
    function Clone : TFhirConditionList; Overload;
    function GetEnumerator : TFhirConditionListEnumerator;

    //  Add a FhirCondition to the end of the list.
    function Append : TFhirCondition;

    // Add an already existing FhirCondition to the end of the list.
    procedure AddItem(value : TFhirCondition); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCondition) : Integer;

    // Insert FhirCondition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCondition;

    // Insert an existing FhirCondition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCondition);

    // Get the iIndexth FhirCondition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCondition);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCondition;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirConditions[index : Integer] : TFhirCondition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CONDITION}

{$IFDEF FHIR_COVERAGE}

  // A suite of underwrite specific classifiers, for example may be used to identify a class of coverage or employer group, Policy, Plan.
  TFhirCoverageGrouping = class (TFhirBackboneElement)
  protected
    FGroup : TFhirString;
    FGroupDisplay : TFhirString;
    FSubGroup : TFhirString;
    FSubGroupDisplay : TFhirString;
    FPlan : TFhirString;
    FPlanDisplay : TFhirString;
    FSubPlan : TFhirString;
    FSubPlanDisplay : TFhirString;
    FClass_ : TFhirString;
    FClassDisplay : TFhirString;
    FSubClass : TFhirString;
    FSubClassDisplay : TFhirString;
    Procedure SetGroup(value : TFhirString);
    Function GetGroupST : String;
    Procedure SetGroupST(value : String);
    Procedure SetGroupDisplay(value : TFhirString);
    Function GetGroupDisplayST : String;
    Procedure SetGroupDisplayST(value : String);
    Procedure SetSubGroup(value : TFhirString);
    Function GetSubGroupST : String;
    Procedure SetSubGroupST(value : String);
    Procedure SetSubGroupDisplay(value : TFhirString);
    Function GetSubGroupDisplayST : String;
    Procedure SetSubGroupDisplayST(value : String);
    Procedure SetPlan(value : TFhirString);
    Function GetPlanST : String;
    Procedure SetPlanST(value : String);
    Procedure SetPlanDisplay(value : TFhirString);
    Function GetPlanDisplayST : String;
    Procedure SetPlanDisplayST(value : String);
    Procedure SetSubPlan(value : TFhirString);
    Function GetSubPlanST : String;
    Procedure SetSubPlanST(value : String);
    Procedure SetSubPlanDisplay(value : TFhirString);
    Function GetSubPlanDisplayST : String;
    Procedure SetSubPlanDisplayST(value : String);
    Procedure SetClass_(value : TFhirString);
    Function GetClass_ST : String;
    Procedure SetClass_ST(value : String);
    Procedure SetClassDisplay(value : TFhirString);
    Function GetClassDisplayST : String;
    Procedure SetClassDisplayST(value : String);
    Procedure SetSubClass(value : TFhirString);
    Function GetSubClassST : String;
    Procedure SetSubClassST(value : String);
    Procedure SetSubClassDisplay(value : TFhirString);
    Function GetSubClassDisplayST : String;
    Procedure SetSubClassDisplayST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverageGrouping; overload;
    function Clone : TFhirCoverageGrouping; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Identifies a style or collective of coverage issued by the underwriter, for example may be used to identify an employer group. May also be referred to as a Policy or Group ID.
    property group : String read GetGroupST write SetGroupST;
    // Identifies a style or collective of coverage issued by the underwriter, for example may be used to identify an employer group. May also be referred to as a Policy or Group ID.
    property groupElement : TFhirString read FGroup write SetGroup;

    // Typed access to A short description for the group.
    property groupDisplay : String read GetGroupDisplayST write SetGroupDisplayST;
    // A short description for the group.
    property groupDisplayElement : TFhirString read FGroupDisplay write SetGroupDisplay;

    // Typed access to Identifies a style or collective of coverage issued by the underwriter, for example may be used to identify a subset of an employer group.
    property subGroup : String read GetSubGroupST write SetSubGroupST;
    // Identifies a style or collective of coverage issued by the underwriter, for example may be used to identify a subset of an employer group.
    property subGroupElement : TFhirString read FSubGroup write SetSubGroup;

    // Typed access to A short description for the subgroup.
    property subGroupDisplay : String read GetSubGroupDisplayST write SetSubGroupDisplayST;
    // A short description for the subgroup.
    property subGroupDisplayElement : TFhirString read FSubGroupDisplay write SetSubGroupDisplay;

    // Typed access to Identifies a style or collective of coverage issued by the underwriter, for example may be used to identify a collection of benefits provided to employees. May be referred to as a Section or Division ID.
    property plan : String read GetPlanST write SetPlanST;
    // Identifies a style or collective of coverage issued by the underwriter, for example may be used to identify a collection of benefits provided to employees. May be referred to as a Section or Division ID.
    property planElement : TFhirString read FPlan write SetPlan;

    // Typed access to A short description for the plan.
    property planDisplay : String read GetPlanDisplayST write SetPlanDisplayST;
    // A short description for the plan.
    property planDisplayElement : TFhirString read FPlanDisplay write SetPlanDisplay;

    // Typed access to Identifies a sub-style or sub-collective of coverage issued by the underwriter, for example may be used to identify a subset of a collection of benefits provided to employees.
    property subPlan : String read GetSubPlanST write SetSubPlanST;
    // Identifies a sub-style or sub-collective of coverage issued by the underwriter, for example may be used to identify a subset of a collection of benefits provided to employees.
    property subPlanElement : TFhirString read FSubPlan write SetSubPlan;

    // Typed access to A short description for the subplan.
    property subPlanDisplay : String read GetSubPlanDisplayST write SetSubPlanDisplayST;
    // A short description for the subplan.
    property subPlanDisplayElement : TFhirString read FSubPlanDisplay write SetSubPlanDisplay;

    // Typed access to Identifies a style or collective of coverage issues by the underwriter, for example may be used to identify a class of coverage such as a level of deductables or co-payment.
    property class_ : String read GetClass_ST write SetClass_ST;
    // Identifies a style or collective of coverage issues by the underwriter, for example may be used to identify a class of coverage such as a level of deductables or co-payment.
    property class_Element : TFhirString read FClass_ write SetClass_;

    // Typed access to A short description for the class.
    property classDisplay : String read GetClassDisplayST write SetClassDisplayST;
    // A short description for the class.
    property classDisplayElement : TFhirString read FClassDisplay write SetClassDisplay;

    // Typed access to Identifies a sub-style or sub-collective of coverage issues by the underwriter, for example may be used to identify a subclass of coverage such as a sub-level of deductables or co-payment.
    property subClass : String read GetSubClassST write SetSubClassST;
    // Identifies a sub-style or sub-collective of coverage issues by the underwriter, for example may be used to identify a subclass of coverage such as a sub-level of deductables or co-payment.
    property subClassElement : TFhirString read FSubClass write SetSubClass;

    // Typed access to A short description for the subclass.
    property subClassDisplay : String read GetSubClassDisplayST write SetSubClassDisplayST;
    // A short description for the subclass.
    property subClassDisplayElement : TFhirString read FSubClassDisplay write SetSubClassDisplay;

  end;

  TFhirCoverageGroupingListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageGroupingList;
    function GetCurrent : TFhirCoverageGrouping;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCoverageGroupingList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverageGrouping read GetCurrent;
  end;

  TFhirCoverageGroupingList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCoverageGrouping;
    procedure SetItemN(index : Integer; value : TFhirCoverageGrouping);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCoverageGroupingList; Overload;
    function Clone : TFhirCoverageGroupingList; Overload;
    function GetEnumerator : TFhirCoverageGroupingListEnumerator;

    //  Add a FhirCoverageGrouping to the end of the list.
    function Append : TFhirCoverageGrouping;

    // Add an already existing FhirCoverageGrouping to the end of the list.
    procedure AddItem(value : TFhirCoverageGrouping); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverageGrouping) : Integer;

    // Insert FhirCoverageGrouping before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverageGrouping;

    // Insert an existing FhirCoverageGrouping before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverageGrouping);

    // Get the iIndexth FhirCoverageGrouping. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverageGrouping);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverageGrouping;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCoverageGroupings[index : Integer] : TFhirCoverageGrouping read GetItemN write SetItemN; default;
  End;

  // Financial instrument which may be used to reimburse or pay for health care products and services.
  TFhirCoverage = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FType_ : TFhirCodeableConcept;
    FPolicyHolder : TFhirReference{Resource};
    FSubscriber : TFhirReference{Resource};
    FSubscriberId : TFhirString;
    FBeneficiary : TFhirReference{TFhirPatient};
    FRelationship : TFhirCodeableConcept;
    FPeriod : TFhirPeriod;
    FpayorList : TFhirReferenceList{Resource};
    FGrouping : TFhirCoverageGrouping;
    FDependent : TFhirString;
    FSequence : TFhirString;
    FOrder : TFhirPositiveInt;
    FNetwork : TFhirString;
    FcontractList : TFhirReferenceList{TFhirContract};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirFmStatusEnum;
    Procedure SetStatusST(value : TFhirFmStatusEnum);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetPolicyHolder(value : TFhirReference{Resource});
    Procedure SetSubscriber(value : TFhirReference{Resource});
    Procedure SetSubscriberId(value : TFhirString);
    Function GetSubscriberIdST : String;
    Procedure SetSubscriberIdST(value : String);
    Procedure SetBeneficiary(value : TFhirReference{TFhirPatient});
    Procedure SetRelationship(value : TFhirCodeableConcept);
    Procedure SetPeriod(value : TFhirPeriod);
    function GetPayorList : TFhirReferenceList{Resource};
    function GetHasPayorList : Boolean;
    Procedure SetGrouping(value : TFhirCoverageGrouping);
    Procedure SetDependent(value : TFhirString);
    Function GetDependentST : String;
    Procedure SetDependentST(value : String);
    Procedure SetSequence(value : TFhirString);
    Function GetSequenceST : String;
    Procedure SetSequenceST(value : String);
    Procedure SetOrder(value : TFhirPositiveInt);
    Function GetOrderST : String;
    Procedure SetOrderST(value : String);
    Procedure SetNetwork(value : TFhirString);
    Function GetNetworkST : String;
    Procedure SetNetworkST(value : String);
    function GetContractList : TFhirReferenceList{TFhirContract};
    function GetHasContractList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCoverage; overload;
    function Clone : TFhirCoverage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The main (and possibly only) identifier for the coverage - often referred to as a Member Id, Certificate number, Personal Health Number or Case ID. May be constructed as the concatination of the Coverage.SubscriberID and the Coverage.dependant.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirFmStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The type of coverage: social program, medical plan, accident coverage (workers compensation, auto), group health or payment by an individual or organization. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of coverage: social program, medical plan, accident coverage (workers compensation, auto), group health or payment by an individual or organization.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The party who 'owns' the insurance policy,  may be an individual, corporation or the subscriber's employer. (defined for API consistency)
    property policyHolder : TFhirReference{Resource} read FPolicyHolder write SetPolicyHolder;
    // The party who 'owns' the insurance policy,  may be an individual, corporation or the subscriber's employer.
    property policyHolderElement : TFhirReference{Resource} read FPolicyHolder write SetPolicyHolder;

    // Typed access to The party who has signed-up for or 'owns' the contractual relationship to the policy or to whom the benefit of the policy for services rendered to them or their family is due. (defined for API consistency)
    property subscriber : TFhirReference{Resource} read FSubscriber write SetSubscriber;
    // The party who has signed-up for or 'owns' the contractual relationship to the policy or to whom the benefit of the policy for services rendered to them or their family is due.
    property subscriberElement : TFhirReference{Resource} read FSubscriber write SetSubscriber;

    // Typed access to The insurer assigned ID for the Subscriber.
    property subscriberId : String read GetSubscriberIdST write SetSubscriberIdST;
    // The insurer assigned ID for the Subscriber.
    property subscriberIdElement : TFhirString read FSubscriberId write SetSubscriberId;

    // Typed access to The party who benefits from the insurance coverage., the patient when services are provided. (defined for API consistency)
    property beneficiary : TFhirReference{TFhirPatient} read FBeneficiary write SetBeneficiary;
    // The party who benefits from the insurance coverage., the patient when services are provided.
    property beneficiaryElement : TFhirReference{TFhirPatient} read FBeneficiary write SetBeneficiary;

    // Typed access to The relationship of beneficiary (patient) to the subscriber. (defined for API consistency)
    property relationship : TFhirCodeableConcept read FRelationship write SetRelationship;
    // The relationship of beneficiary (patient) to the subscriber.
    property relationshipElement : TFhirCodeableConcept read FRelationship write SetRelationship;

    // Typed access to Time period during which the coverage is in force. A missing start date indicates the start date isn't known, a missing end date means the coverage is continuing to be in force. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Time period during which the coverage is in force. A missing start date indicates the start date isn't known, a missing end date means the coverage is continuing to be in force.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // The program or plan underwriter or payor including both insurance and non-insurance agreements, such as patient-pay agreements. May provide multiple identifiers such as insurance company identifier or business identifier (BIN number).
    property payorList : TFhirReferenceList{Resource} read GetPayorList;
    property hasPayorList : boolean read GetHasPayorList;

    // Typed access to A suite of underwrite specific classifiers, for example may be used to identify a class of coverage or employer group, Policy, Plan. (defined for API consistency)
    property grouping : TFhirCoverageGrouping read FGrouping write SetGrouping;
    // A suite of underwrite specific classifiers, for example may be used to identify a class of coverage or employer group, Policy, Plan.
    property groupingElement : TFhirCoverageGrouping read FGrouping write SetGrouping;

    // Typed access to A unique identifier for a dependent under the coverage.
    property dependent : String read GetDependentST write SetDependentST;
    // A unique identifier for a dependent under the coverage.
    property dependentElement : TFhirString read FDependent write SetDependent;

    // Typed access to An optional counter for a particular instance of the identified coverage which increments upon each renewal.
    property sequence : String read GetSequenceST write SetSequenceST;
    // An optional counter for a particular instance of the identified coverage which increments upon each renewal.
    property sequenceElement : TFhirString read FSequence write SetSequence;

    // Typed access to The order of applicability of this coverage relative to other coverages which are currently inforce. Note, there may be gaps in the numbering and this does not imply primary, secondard etc. as the specific positioning of coverages depends upon the episode of care.
    property order : String read GetOrderST write SetOrderST;
    // The order of applicability of this coverage relative to other coverages which are currently inforce. Note, there may be gaps in the numbering and this does not imply primary, secondard etc. as the specific positioning of coverages depends upon the episode of care.
    property orderElement : TFhirPositiveInt read FOrder write SetOrder;

    // Typed access to The insurer-specific identifier for the insurer-defined network of providers to which the beneficiary may seek treatment which will be covered at the 'in-network' rate, otherwise 'out of network' terms and conditions apply.
    property network : String read GetNetworkST write SetNetworkST;
    // The insurer-specific identifier for the insurer-defined network of providers to which the beneficiary may seek treatment which will be covered at the 'in-network' rate, otherwise 'out of network' terms and conditions apply.
    property networkElement : TFhirString read FNetwork write SetNetwork;

    // The policy(s) which constitute this insurance coverage.
    property contractList : TFhirReferenceList{TFhirContract} read GetContractList;
    property hasContractList : boolean read GetHasContractList;

  end;

  TFhirCoverageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCoverageList;
    function GetCurrent : TFhirCoverage;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCoverageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCoverage read GetCurrent;
  end;

  TFhirCoverageList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCoverage;
    procedure SetItemN(index : Integer; value : TFhirCoverage);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCoverageList; Overload;
    function Clone : TFhirCoverageList; Overload;
    function GetEnumerator : TFhirCoverageListEnumerator;

    //  Add a FhirCoverage to the end of the list.
    function Append : TFhirCoverage;

    // Add an already existing FhirCoverage to the end of the list.
    procedure AddItem(value : TFhirCoverage); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCoverage) : Integer;

    // Insert FhirCoverage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCoverage;

    // Insert an existing FhirCoverage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCoverage);

    // Get the iIndexth FhirCoverage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCoverage);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCoverage;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCoverages[index : Integer] : TFhirCoverage read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_COVERAGE}

{$IFDEF FHIR_DETECTEDISSUE}

  // Indicates an action that has been taken or is committed to to reduce or eliminate the likelihood of the risk identified by the detected issue from manifesting.  Can also reflect an observation of known mitigating factors that may reduce/eliminate the need for any action.
  TFhirDetectedIssueMitigation = class (TFhirBackboneElement)
  protected
    FAction : TFhirCodeableConcept;
    FDate : TFhirDateTime;
    FAuthor : TFhirReference{TFhirPractitioner};
    Procedure SetAction(value : TFhirCodeableConcept);
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetAuthor(value : TFhirReference{TFhirPractitioner});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDetectedIssueMitigation; overload;
    function Clone : TFhirDetectedIssueMitigation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Describes the action that was taken or the observation that was made that reduces/eliminates the risk associated with the identified issue. (defined for API consistency)
    property action : TFhirCodeableConcept read FAction write SetAction;
    // Describes the action that was taken or the observation that was made that reduces/eliminates the risk associated with the identified issue.
    property actionElement : TFhirCodeableConcept read FAction write SetAction;

    // Typed access to Indicates when the mitigating action was documented.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Indicates when the mitigating action was documented.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to Identifies the practitioner who determined the mitigation and takes responsibility for the mitigation step occurring. (defined for API consistency)
    property author : TFhirReference{TFhirPractitioner} read FAuthor write SetAuthor;
    // Identifies the practitioner who determined the mitigation and takes responsibility for the mitigation step occurring.
    property authorElement : TFhirReference{TFhirPractitioner} read FAuthor write SetAuthor;

  end;

  TFhirDetectedIssueMitigationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDetectedIssueMitigationList;
    function GetCurrent : TFhirDetectedIssueMitigation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDetectedIssueMitigationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDetectedIssueMitigation read GetCurrent;
  end;

  TFhirDetectedIssueMitigationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDetectedIssueMitigation;
    procedure SetItemN(index : Integer; value : TFhirDetectedIssueMitigation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDetectedIssueMitigationList; Overload;
    function Clone : TFhirDetectedIssueMitigationList; Overload;
    function GetEnumerator : TFhirDetectedIssueMitigationListEnumerator;

    //  Add a FhirDetectedIssueMitigation to the end of the list.
    function Append : TFhirDetectedIssueMitigation;

    // Add an already existing FhirDetectedIssueMitigation to the end of the list.
    procedure AddItem(value : TFhirDetectedIssueMitigation); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDetectedIssueMitigation) : Integer;

    // Insert FhirDetectedIssueMitigation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDetectedIssueMitigation;

    // Insert an existing FhirDetectedIssueMitigation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDetectedIssueMitigation);

    // Get the iIndexth FhirDetectedIssueMitigation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDetectedIssueMitigation);

    // The number of items in the collection
    function Item(index : Integer) : TFhirDetectedIssueMitigation;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirDetectedIssueMitigations[index : Integer] : TFhirDetectedIssueMitigation read GetItemN write SetItemN; default;
  End;

  // Indicates an actual or potential clinical issue with or between one or more active or proposed clinical actions for a patient; e.g. Drug-drug interaction, Ineffective treatment frequency, Procedure-condition conflict, etc.
  TFhirDetectedIssue = class (TFhirDomainResource)
  protected
    FIdentifier : TFhirIdentifier;
    FStatus : TFhirEnum;
    FCategory : TFhirCodeableConcept;
    FSeverity : TFhirEnum;
    FPatient : TFhirReference{TFhirPatient};
    FDate : TFhirDateTime;
    FAuthor : TFhirReference{Resource};
    FimplicatedList : TFhirReferenceList{TFhirReference};
    FDetail : TFhirString;
    FReference : TFhirUri;
    FmitigationList : TFhirDetectedIssueMitigationList;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirObservationStatusEnum;
    Procedure SetStatusST(value : TFhirObservationStatusEnum);
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetSeverity(value : TFhirEnum);
    Function GetSeverityST : TFhirDetectedissueSeverityEnum;
    Procedure SetSeverityST(value : TFhirDetectedissueSeverityEnum);
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetAuthor(value : TFhirReference{Resource});
    function GetImplicatedList : TFhirReferenceList{TFhirReference};
    function GetHasImplicatedList : Boolean;
    Procedure SetDetail(value : TFhirString);
    Function GetDetailST : String;
    Procedure SetDetailST(value : String);
    Procedure SetReference(value : TFhirUri);
    Function GetReferenceST : String;
    Procedure SetReferenceST(value : String);
    function GetMitigationList : TFhirDetectedIssueMitigationList;
    function GetHasMitigationList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDetectedIssue; overload;
    function Clone : TFhirDetectedIssue; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Business identifier associated with the detected issue record. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Business identifier associated with the detected issue record.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Indicates the status of the detected issue.
    property status : TFhirObservationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Identifies the general type of issue identified. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Identifies the general type of issue identified.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Indicates the degree of importance associated with the identified issue based on the potential impact on the patient.
    property severity : TFhirDetectedissueSeverityEnum read GetSeverityST write SetSeverityST;
    property severityElement : TFhirEnum read FSeverity write SetSeverity;

    // Typed access to Indicates the patient whose record the detected issue is associated with. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // Indicates the patient whose record the detected issue is associated with.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Typed access to The date or date-time when the detected issue was initially identified.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date or date-time when the detected issue was initially identified.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to Individual or device responsible for the issue being raised.  For example, a decision support application or a pharmacist conducting a medication review. (defined for API consistency)
    property author : TFhirReference{Resource} read FAuthor write SetAuthor;
    // Individual or device responsible for the issue being raised.  For example, a decision support application or a pharmacist conducting a medication review.
    property authorElement : TFhirReference{Resource} read FAuthor write SetAuthor;

    // Indicates the resource representing the current activity or proposed activity that is potentially problematic.
    property implicatedList : TFhirReferenceList{TFhirReference} read GetImplicatedList;
    property hasImplicatedList : boolean read GetHasImplicatedList;

    // Typed access to A textual explanation of the detected issue.
    property detail : String read GetDetailST write SetDetailST;
    // A textual explanation of the detected issue.
    property detailElement : TFhirString read FDetail write SetDetail;

    // Typed access to The literature, knowledge-base or similar reference that describes the propensity for the detected issue identified.
    property reference : String read GetReferenceST write SetReferenceST;
    // The literature, knowledge-base or similar reference that describes the propensity for the detected issue identified.
    property referenceElement : TFhirUri read FReference write SetReference;

    // Indicates an action that has been taken or is committed to to reduce or eliminate the likelihood of the risk identified by the detected issue from manifesting.  Can also reflect an observation of known mitigating factors that may reduce/eliminate the need for any action.
    property mitigationList : TFhirDetectedIssueMitigationList read GetMitigationList;
    property hasMitigationList : boolean read GetHasMitigationList;

  end;

  TFhirDetectedIssueListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDetectedIssueList;
    function GetCurrent : TFhirDetectedIssue;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDetectedIssueList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDetectedIssue read GetCurrent;
  end;

  TFhirDetectedIssueList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDetectedIssue;
    procedure SetItemN(index : Integer; value : TFhirDetectedIssue);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDetectedIssueList; Overload;
    function Clone : TFhirDetectedIssueList; Overload;
    function GetEnumerator : TFhirDetectedIssueListEnumerator;

    //  Add a FhirDetectedIssue to the end of the list.
    function Append : TFhirDetectedIssue;

    // Add an already existing FhirDetectedIssue to the end of the list.
    procedure AddItem(value : TFhirDetectedIssue); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDetectedIssue) : Integer;

    // Insert FhirDetectedIssue before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDetectedIssue;

    // Insert an existing FhirDetectedIssue before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDetectedIssue);

    // Get the iIndexth FhirDetectedIssue. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDetectedIssue);

    // The number of items in the collection
    function Item(index : Integer) : TFhirDetectedIssue;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirDetectedIssues[index : Integer] : TFhirDetectedIssue read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_DETECTEDISSUE}

{$IFDEF FHIR_DEVICEREQUEST}

  // The individual who initiated the request and has responsibility for its activation.
  TFhirDeviceRequestRequester = class (TFhirBackboneElement)
  protected
    FAgent : TFhirReference{Resource};
    FOnBehalfOf : TFhirReference{TFhirOrganization};
    Procedure SetAgent(value : TFhirReference{Resource});
    Procedure SetOnBehalfOf(value : TFhirReference{TFhirOrganization});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceRequestRequester; overload;
    function Clone : TFhirDeviceRequestRequester; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The device, practitioner, etc. who initiated the request. (defined for API consistency)
    property agent : TFhirReference{Resource} read FAgent write SetAgent;
    // The device, practitioner, etc. who initiated the request.
    property agentElement : TFhirReference{Resource} read FAgent write SetAgent;

    // Typed access to The organization the device or practitioner was acting on behalf of. (defined for API consistency)
    property onBehalfOf : TFhirReference{TFhirOrganization} read FOnBehalfOf write SetOnBehalfOf;
    // The organization the device or practitioner was acting on behalf of.
    property onBehalfOfElement : TFhirReference{TFhirOrganization} read FOnBehalfOf write SetOnBehalfOf;

  end;

  TFhirDeviceRequestRequesterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceRequestRequesterList;
    function GetCurrent : TFhirDeviceRequestRequester;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDeviceRequestRequesterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceRequestRequester read GetCurrent;
  end;

  TFhirDeviceRequestRequesterList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDeviceRequestRequester;
    procedure SetItemN(index : Integer; value : TFhirDeviceRequestRequester);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDeviceRequestRequesterList; Overload;
    function Clone : TFhirDeviceRequestRequesterList; Overload;
    function GetEnumerator : TFhirDeviceRequestRequesterListEnumerator;

    //  Add a FhirDeviceRequestRequester to the end of the list.
    function Append : TFhirDeviceRequestRequester;

    // Add an already existing FhirDeviceRequestRequester to the end of the list.
    procedure AddItem(value : TFhirDeviceRequestRequester); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceRequestRequester) : Integer;

    // Insert FhirDeviceRequestRequester before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceRequestRequester;

    // Insert an existing FhirDeviceRequestRequester before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceRequestRequester);

    // Get the iIndexth FhirDeviceRequestRequester. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceRequestRequester);

    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceRequestRequester;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirDeviceRequestRequesters[index : Integer] : TFhirDeviceRequestRequester read GetItemN write SetItemN; default;
  End;

  // Represents a request for a patient to employ a medical device. The device may be an implantable device, or an external assistive device, such as a walker.
  TFhirDeviceRequest = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FdefinitionList : TFhirReferenceList{Resource};
    FbasedOnList : TFhirReferenceList{TFhirReference};
    FpriorRequestList : TFhirReferenceList{TFhirReference};
    FGroupIdentifier : TFhirIdentifier;
    FStatus : TFhirEnum;
    FIntent : TFhirCodeableConcept;
    FPriority : TFhirEnum;
    FCode : TFhirType;
    FSubject : TFhirReference{Resource};
    FContext : TFhirReference{Resource};
    FOccurrence : TFhirType;
    FAuthoredOn : TFhirDateTime;
    FRequester : TFhirDeviceRequestRequester;
    FPerformerType : TFhirCodeableConcept;
    FPerformer : TFhirReference{Resource};
    FreasonCodeList : TFhirCodeableConceptList;
    FreasonReferenceList : TFhirReferenceList{TFhirReference};
    FsupportingInfoList : TFhirReferenceList{TFhirReference};
    FnoteList : TFhirAnnotationList;
    FrelevantHistoryList : TFhirReferenceList{TFhirProvenance};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetDefinitionList : TFhirReferenceList{Resource};
    function GetHasDefinitionList : Boolean;
    function GetBasedOnList : TFhirReferenceList{TFhirReference};
    function GetHasBasedOnList : Boolean;
    function GetPriorRequestList : TFhirReferenceList{TFhirReference};
    function GetHasPriorRequestList : Boolean;
    Procedure SetGroupIdentifier(value : TFhirIdentifier);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirRequestStatusEnum;
    Procedure SetStatusST(value : TFhirRequestStatusEnum);
    Procedure SetIntent(value : TFhirCodeableConcept);
    Procedure SetPriority(value : TFhirEnum);
    Function GetPriorityST : TFhirRequestPriorityEnum;
    Procedure SetPriorityST(value : TFhirRequestPriorityEnum);
    Procedure SetCode(value : TFhirType);
    Procedure SetSubject(value : TFhirReference{Resource});
    Procedure SetContext(value : TFhirReference{Resource});
    Procedure SetOccurrence(value : TFhirType);
    Procedure SetAuthoredOn(value : TFhirDateTime);
    Function GetAuthoredOnST : TFslDateTime;
    Procedure SetAuthoredOnST(value : TFslDateTime);
    Procedure SetRequester(value : TFhirDeviceRequestRequester);
    Procedure SetPerformerType(value : TFhirCodeableConcept);
    Procedure SetPerformer(value : TFhirReference{Resource});
    function GetReasonCodeList : TFhirCodeableConceptList;
    function GetHasReasonCodeList : Boolean;
    function GetReasonReferenceList : TFhirReferenceList{TFhirReference};
    function GetHasReasonReferenceList : Boolean;
    function GetSupportingInfoList : TFhirReferenceList{TFhirReference};
    function GetHasSupportingInfoList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetRelevantHistoryList : TFhirReferenceList{TFhirProvenance};
    function GetHasRelevantHistoryList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceRequest; overload;
    function Clone : TFhirDeviceRequest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Identifiers assigned to this order by the orderer or by the receiver.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Protocol or definition followed by this request. For example: The proposed act must be performed if the indicated conditions occur, e.g.., shortness of breath, SpO2 less than x%.
    property definitionList : TFhirReferenceList{Resource} read GetDefinitionList;
    property hasDefinitionList : boolean read GetHasDefinitionList;

    // Plan/proposal/order fulfilled by this request.
    property basedOnList : TFhirReferenceList{TFhirReference} read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // The request takes the place of the referenced completed or terminated request(s).
    property priorRequestList : TFhirReferenceList{TFhirReference} read GetPriorRequestList;
    property hasPriorRequestList : boolean read GetHasPriorRequestList;

    // Typed access to Composite request this is part of. (defined for API consistency)
    property groupIdentifier : TFhirIdentifier read FGroupIdentifier write SetGroupIdentifier;
    // Composite request this is part of.
    property groupIdentifierElement : TFhirIdentifier read FGroupIdentifier write SetGroupIdentifier;

    // The status of the request.
    property status : TFhirRequestStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Whether the request is a proposal, plan, an original order or a reflex order. (defined for API consistency)
    property intent : TFhirCodeableConcept read FIntent write SetIntent;
    // Whether the request is a proposal, plan, an original order or a reflex order.
    property intentElement : TFhirCodeableConcept read FIntent write SetIntent;

    // Indicates how quickly the {{title)))) should be addressed with respect to other requests.
    property priority : TFhirRequestPriorityEnum read GetPriorityST write SetPriorityST;
    property priorityElement : TFhirEnum read FPriority write SetPriority;

    // Typed access to The details of the device to be used. (defined for API consistency)
    property code : TFhirType read FCode write SetCode;
    // The details of the device to be used.
    property codeElement : TFhirType read FCode write SetCode;

    // Typed access to The patient who will use the device. (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // The patient who will use the device.
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // Typed access to An encounter that provides additional context in which this request is made. (defined for API consistency)
    property context : TFhirReference{Resource} read FContext write SetContext;
    // An encounter that provides additional context in which this request is made.
    property contextElement : TFhirReference{Resource} read FContext write SetContext;

    // Typed access to The timing schedule for the use of the device. The Schedule data type allows many different expressions, for example. "Every 8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:"; "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013". (defined for API consistency)
    property occurrence : TFhirType read FOccurrence write SetOccurrence;
    // The timing schedule for the use of the device. The Schedule data type allows many different expressions, for example. "Every 8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:"; "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013".
    property occurrenceElement : TFhirType read FOccurrence write SetOccurrence;

    // Typed access to When the request transitioned to being actionable.
    property authoredOn : TFslDateTime read GetAuthoredOnST write SetAuthoredOnST;
    // When the request transitioned to being actionable.
    property authoredOnElement : TFhirDateTime read FAuthoredOn write SetAuthoredOn;

    // Typed access to The individual who initiated the request and has responsibility for its activation. (defined for API consistency)
    property requester : TFhirDeviceRequestRequester read FRequester write SetRequester;
    // The individual who initiated the request and has responsibility for its activation.
    property requesterElement : TFhirDeviceRequestRequester read FRequester write SetRequester;

    // Typed access to Desired type of performer for doing the diagnostic testing. (defined for API consistency)
    property performerType : TFhirCodeableConcept read FPerformerType write SetPerformerType;
    // Desired type of performer for doing the diagnostic testing.
    property performerTypeElement : TFhirCodeableConcept read FPerformerType write SetPerformerType;

    // Typed access to The desired perfomer for doing the diagnostic testing. (defined for API consistency)
    property performer : TFhirReference{Resource} read FPerformer write SetPerformer;
    // The desired perfomer for doing the diagnostic testing.
    property performerElement : TFhirReference{Resource} read FPerformer write SetPerformer;

    // Reason or justification for the use of this device.
    property reasonCodeList : TFhirCodeableConceptList read GetReasonCodeList;
    property hasReasonCodeList : boolean read GetHasReasonCodeList;

    // Reason or justification for the use of this device.
    property reasonReferenceList : TFhirReferenceList{TFhirReference} read GetReasonReferenceList;
    property hasReasonReferenceList : boolean read GetHasReasonReferenceList;

    // Additional clinical information about the patient that may influence the request fulfilment.  For example, this may includes body where on the subject's the device will be used ( i.e. the target site).
    property supportingInfoList : TFhirReferenceList{TFhirReference} read GetSupportingInfoList;
    property hasSupportingInfoList : boolean read GetHasSupportingInfoList;

    // Details about this request that were not represented at all or sufficiently in one of the attributes provided in a class. These may include for example a comment, an instruction, or a note associated with the statement.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Key events in the history of the request.
    property relevantHistoryList : TFhirReferenceList{TFhirProvenance} read GetRelevantHistoryList;
    property hasRelevantHistoryList : boolean read GetHasRelevantHistoryList;

  end;

  TFhirDeviceRequestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceRequestList;
    function GetCurrent : TFhirDeviceRequest;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDeviceRequestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceRequest read GetCurrent;
  end;

  TFhirDeviceRequestList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDeviceRequest;
    procedure SetItemN(index : Integer; value : TFhirDeviceRequest);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDeviceRequestList; Overload;
    function Clone : TFhirDeviceRequestList; Overload;
    function GetEnumerator : TFhirDeviceRequestListEnumerator;

    //  Add a FhirDeviceRequest to the end of the list.
    function Append : TFhirDeviceRequest;

    // Add an already existing FhirDeviceRequest to the end of the list.
    procedure AddItem(value : TFhirDeviceRequest); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceRequest) : Integer;

    // Insert FhirDeviceRequest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceRequest;

    // Insert an existing FhirDeviceRequest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceRequest);

    // Get the iIndexth FhirDeviceRequest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceRequest);

    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceRequest;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirDeviceRequests[index : Integer] : TFhirDeviceRequest read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_DEVICEREQUEST}

{$IFDEF FHIR_DEVICEUSESTATEMENT}

  // A record of a device being used by a patient where the record is the result of a report from the patient or another clinician.
  TFhirDeviceUseStatement = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FSubject : TFhirReference{Resource};
    FWhenUsed : TFhirPeriod;
    FTiming : TFhirType;
    FRecordedOn : TFhirDateTime;
    FSource : TFhirReference{Resource};
    FDevice : TFhirReference{TFhirDevice};
    FindicationList : TFhirCodeableConceptList;
    FBodySite : TFhirCodeableConcept;
    FnoteList : TFhirAnnotationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirDeviceStatementStatusEnum;
    Procedure SetStatusST(value : TFhirDeviceStatementStatusEnum);
    Procedure SetSubject(value : TFhirReference{Resource});
    Procedure SetWhenUsed(value : TFhirPeriod);
    Procedure SetTiming(value : TFhirType);
    Procedure SetRecordedOn(value : TFhirDateTime);
    Function GetRecordedOnST : TFslDateTime;
    Procedure SetRecordedOnST(value : TFslDateTime);
    Procedure SetSource(value : TFhirReference{Resource});
    Procedure SetDevice(value : TFhirReference{TFhirDevice});
    function GetIndicationList : TFhirCodeableConceptList;
    function GetHasIndicationList : Boolean;
    Procedure SetBodySite(value : TFhirCodeableConcept);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceUseStatement; overload;
    function Clone : TFhirDeviceUseStatement; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // An external identifier for this statement such as an IRI.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A code representing the patient or other source's judgment about the state of the device used that this statement is about.  Generally this will be active or completed.
    property status : TFhirDeviceStatementStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The patient who used the device. (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // The patient who used the device.
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // Typed access to The time period over which the device was used. (defined for API consistency)
    property whenUsed : TFhirPeriod read FWhenUsed write SetWhenUsed;
    // The time period over which the device was used.
    property whenUsedElement : TFhirPeriod read FWhenUsed write SetWhenUsed;

    // Typed access to How often the device was used. (defined for API consistency)
    property timing : TFhirType read FTiming write SetTiming;
    // How often the device was used.
    property timingElement : TFhirType read FTiming write SetTiming;

    // Typed access to The time at which the statement was made/recorded.
    property recordedOn : TFslDateTime read GetRecordedOnST write SetRecordedOnST;
    // The time at which the statement was made/recorded.
    property recordedOnElement : TFhirDateTime read FRecordedOn write SetRecordedOn;

    // Typed access to Who reported the device was being used by the patient. (defined for API consistency)
    property source : TFhirReference{Resource} read FSource write SetSource;
    // Who reported the device was being used by the patient.
    property sourceElement : TFhirReference{Resource} read FSource write SetSource;

    // Typed access to The details of the device used. (defined for API consistency)
    property device : TFhirReference{TFhirDevice} read FDevice write SetDevice;
    // The details of the device used.
    property deviceElement : TFhirReference{TFhirDevice} read FDevice write SetDevice;

    // Reason or justification for the use of the device.
    property indicationList : TFhirCodeableConceptList read GetIndicationList;
    property hasIndicationList : boolean read GetHasIndicationList;

    // Typed access to Indicates the site on the subject's body where the device was used ( i.e. the target site). (defined for API consistency)
    property bodySite : TFhirCodeableConcept read FBodySite write SetBodySite;
    // Indicates the site on the subject's body where the device was used ( i.e. the target site).
    property bodySiteElement : TFhirCodeableConcept read FBodySite write SetBodySite;

    // Details about the device statement that were not represented at all or sufficiently in one of the attributes provided in a class. These may include for example a comment, an instruction, or a note associated with the statement.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirDeviceUseStatementListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceUseStatementList;
    function GetCurrent : TFhirDeviceUseStatement;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDeviceUseStatementList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceUseStatement read GetCurrent;
  end;

  TFhirDeviceUseStatementList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDeviceUseStatement;
    procedure SetItemN(index : Integer; value : TFhirDeviceUseStatement);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDeviceUseStatementList; Overload;
    function Clone : TFhirDeviceUseStatementList; Overload;
    function GetEnumerator : TFhirDeviceUseStatementListEnumerator;

    //  Add a FhirDeviceUseStatement to the end of the list.
    function Append : TFhirDeviceUseStatement;

    // Add an already existing FhirDeviceUseStatement to the end of the list.
    procedure AddItem(value : TFhirDeviceUseStatement); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceUseStatement) : Integer;

    // Insert FhirDeviceUseStatement before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceUseStatement;

    // Insert an existing FhirDeviceUseStatement before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceUseStatement);

    // Get the iIndexth FhirDeviceUseStatement. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceUseStatement);

    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceUseStatement;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirDeviceUseStatements[index : Integer] : TFhirDeviceUseStatement read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_DEVICEUSESTATEMENT}

{$IFDEF FHIR_DIAGNOSTICREPORT}

  // Indicates who or what participated in producing the report.
  TFhirDiagnosticReportPerformer = class (TFhirBackboneElement)
  protected
    FRole : TFhirCodeableConcept;
    FActor : TFhirReference{Resource};
    Procedure SetRole(value : TFhirCodeableConcept);
    Procedure SetActor(value : TFhirReference{Resource});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDiagnosticReportPerformer; overload;
    function Clone : TFhirDiagnosticReportPerformer; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Describes the type of participation (e.g.  a responsible party, author, or verifier). (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // Describes the type of participation (e.g.  a responsible party, author, or verifier).
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

    // Typed access to The reference to the  practitioner or organization involved in producing the report. For example, the diagnostic service that is responsible for issuing the report. (defined for API consistency)
    property actor : TFhirReference{Resource} read FActor write SetActor;
    // The reference to the  practitioner or organization involved in producing the report. For example, the diagnostic service that is responsible for issuing the report.
    property actorElement : TFhirReference{Resource} read FActor write SetActor;

  end;

  TFhirDiagnosticReportPerformerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDiagnosticReportPerformerList;
    function GetCurrent : TFhirDiagnosticReportPerformer;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDiagnosticReportPerformerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDiagnosticReportPerformer read GetCurrent;
  end;

  TFhirDiagnosticReportPerformerList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDiagnosticReportPerformer;
    procedure SetItemN(index : Integer; value : TFhirDiagnosticReportPerformer);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDiagnosticReportPerformerList; Overload;
    function Clone : TFhirDiagnosticReportPerformerList; Overload;
    function GetEnumerator : TFhirDiagnosticReportPerformerListEnumerator;

    //  Add a FhirDiagnosticReportPerformer to the end of the list.
    function Append : TFhirDiagnosticReportPerformer;

    // Add an already existing FhirDiagnosticReportPerformer to the end of the list.
    procedure AddItem(value : TFhirDiagnosticReportPerformer); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDiagnosticReportPerformer) : Integer;

    // Insert FhirDiagnosticReportPerformer before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDiagnosticReportPerformer;

    // Insert an existing FhirDiagnosticReportPerformer before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDiagnosticReportPerformer);

    // Get the iIndexth FhirDiagnosticReportPerformer. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDiagnosticReportPerformer);

    // The number of items in the collection
    function Item(index : Integer) : TFhirDiagnosticReportPerformer;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirDiagnosticReportPerformers[index : Integer] : TFhirDiagnosticReportPerformer read GetItemN write SetItemN; default;
  End;

  // A list of key images associated with this report. The images are generally created during the diagnostic process, and may be directly of the patient, or of treated specimens (i.e. slides of interest).
  TFhirDiagnosticReportImage = class (TFhirBackboneElement)
  protected
    FComment : TFhirString;
    FLink_ : TFhirReference{TFhirMedia};
    Procedure SetComment(value : TFhirString);
    Function GetCommentST : String;
    Procedure SetCommentST(value : String);
    Procedure SetLink_(value : TFhirReference{TFhirMedia});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDiagnosticReportImage; overload;
    function Clone : TFhirDiagnosticReportImage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A comment about the image. Typically, this is used to provide an explanation for why the image is included, or to draw the viewer's attention to important features.
    property comment : String read GetCommentST write SetCommentST;
    // A comment about the image. Typically, this is used to provide an explanation for why the image is included, or to draw the viewer's attention to important features.
    property commentElement : TFhirString read FComment write SetComment;

    // Typed access to Reference to the image source. (defined for API consistency)
    property link_ : TFhirReference{TFhirMedia} read FLink_ write SetLink_;
    // Reference to the image source.
    property link_Element : TFhirReference{TFhirMedia} read FLink_ write SetLink_;

  end;

  TFhirDiagnosticReportImageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDiagnosticReportImageList;
    function GetCurrent : TFhirDiagnosticReportImage;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDiagnosticReportImageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDiagnosticReportImage read GetCurrent;
  end;

  TFhirDiagnosticReportImageList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDiagnosticReportImage;
    procedure SetItemN(index : Integer; value : TFhirDiagnosticReportImage);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDiagnosticReportImageList; Overload;
    function Clone : TFhirDiagnosticReportImageList; Overload;
    function GetEnumerator : TFhirDiagnosticReportImageListEnumerator;

    //  Add a FhirDiagnosticReportImage to the end of the list.
    function Append : TFhirDiagnosticReportImage;

    // Add an already existing FhirDiagnosticReportImage to the end of the list.
    procedure AddItem(value : TFhirDiagnosticReportImage); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDiagnosticReportImage) : Integer;

    // Insert FhirDiagnosticReportImage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDiagnosticReportImage;

    // Insert an existing FhirDiagnosticReportImage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDiagnosticReportImage);

    // Get the iIndexth FhirDiagnosticReportImage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDiagnosticReportImage);

    // The number of items in the collection
    function Item(index : Integer) : TFhirDiagnosticReportImage;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirDiagnosticReportImages[index : Integer] : TFhirDiagnosticReportImage read GetItemN write SetItemN; default;
  End;

  // The findings and interpretation of diagnostic  tests performed on patients, groups of patients, devices, and locations, and/or specimens derived from these. The report includes clinical context such as requesting and provider information, and some mix of atomic results, images, textual and coded interpretations, and formatted representation of diagnostic reports.
  TFhirDiagnosticReport = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FbasedOnList : TFhirReferenceList{Resource};
    FStatus : TFhirEnum;
    FCategory : TFhirCodeableConcept;
    FCode : TFhirCodeableConcept;
    FSubject : TFhirReference{Resource};
    FContext : TFhirReference{Resource};
    FEffective : TFhirType;
    FIssued : TFhirInstant;
    FperformerList : TFhirDiagnosticReportPerformerList;
    FspecimenList : TFhirReferenceList{TFhirSpecimen};
    FresultList : TFhirReferenceList{TFhirObservation};
    FimagingStudyList : TFhirReferenceList{Resource};
    FimageList : TFhirDiagnosticReportImageList;
    FConclusion : TFhirString;
    FcodedDiagnosisList : TFhirCodeableConceptList;
    FpresentedFormList : TFhirAttachmentList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetBasedOnList : TFhirReferenceList{Resource};
    function GetHasBasedOnList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirDiagnosticReportStatusEnum;
    Procedure SetStatusST(value : TFhirDiagnosticReportStatusEnum);
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetSubject(value : TFhirReference{Resource});
    Procedure SetContext(value : TFhirReference{Resource});
    Procedure SetEffective(value : TFhirType);
    Procedure SetIssued(value : TFhirInstant);
    Function GetIssuedST : TFslDateTime;
    Procedure SetIssuedST(value : TFslDateTime);
    function GetPerformerList : TFhirDiagnosticReportPerformerList;
    function GetHasPerformerList : Boolean;
    function GetSpecimenList : TFhirReferenceList{TFhirSpecimen};
    function GetHasSpecimenList : Boolean;
    function GetResultList : TFhirReferenceList{TFhirObservation};
    function GetHasResultList : Boolean;
    function GetImagingStudyList : TFhirReferenceList{Resource};
    function GetHasImagingStudyList : Boolean;
    function GetImageList : TFhirDiagnosticReportImageList;
    function GetHasImageList : Boolean;
    Procedure SetConclusion(value : TFhirString);
    Function GetConclusionST : String;
    Procedure SetConclusionST(value : String);
    function GetCodedDiagnosisList : TFhirCodeableConceptList;
    function GetHasCodedDiagnosisList : Boolean;
    function GetPresentedFormList : TFhirAttachmentList;
    function GetHasPresentedFormList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDiagnosticReport; overload;
    function Clone : TFhirDiagnosticReport; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Identifiers assigned to this report by the performer or other systems.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Details concerning a test or procedure requested.
    property basedOnList : TFhirReferenceList{Resource} read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // The status of the diagnostic report as a whole.
    property status : TFhirDiagnosticReportStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A code that classifies the clinical discipline, department or diagnostic service that created the report (e.g. cardiology, biochemistry, hematology, MRI). This is used for searching, sorting and display purposes. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // A code that classifies the clinical discipline, department or diagnostic service that created the report (e.g. cardiology, biochemistry, hematology, MRI). This is used for searching, sorting and display purposes.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to A code or name that describes this diagnostic report. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code or name that describes this diagnostic report.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The subject of the report. Usually, but not always, this is a patient. However diagnostic services also perform analyses on specimens collected from a variety of other sources. (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // The subject of the report. Usually, but not always, this is a patient. However diagnostic services also perform analyses on specimens collected from a variety of other sources.
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // Typed access to The healthcare event  (e.g. a patient and healthcare provider interaction) which this DiagnosticReport per is about. (defined for API consistency)
    property context : TFhirReference{Resource} read FContext write SetContext;
    // The healthcare event  (e.g. a patient and healthcare provider interaction) which this DiagnosticReport per is about.
    property contextElement : TFhirReference{Resource} read FContext write SetContext;

    // Typed access to The time or time-period the observed values are related to. When the subject of the report is a patient, this is usually either the time of the procedure or of specimen collection(s), but very often the source of the date/time is not known, only the date/time itself. (defined for API consistency)
    property effective : TFhirType read FEffective write SetEffective;
    // The time or time-period the observed values are related to. When the subject of the report is a patient, this is usually either the time of the procedure or of specimen collection(s), but very often the source of the date/time is not known, only the date/time itself.
    property effectiveElement : TFhirType read FEffective write SetEffective;

    // Typed access to The date and time that this version of the report was released from the source diagnostic service.
    property issued : TFslDateTime read GetIssuedST write SetIssuedST;
    // The date and time that this version of the report was released from the source diagnostic service.
    property issuedElement : TFhirInstant read FIssued write SetIssued;

    // Indicates who or what participated in producing the report.
    property performerList : TFhirDiagnosticReportPerformerList read GetPerformerList;
    property hasPerformerList : boolean read GetHasPerformerList;

    // Details about the specimens on which this diagnostic report is based.
    property specimenList : TFhirReferenceList{TFhirSpecimen} read GetSpecimenList;
    property hasSpecimenList : boolean read GetHasSpecimenList;

    // Observations that are part of this diagnostic report. Observations can be simple name/value pairs (e.g. "atomic" results), or they can be grouping observations that include references to other members of the group (e.g. "panels").
    property resultList : TFhirReferenceList{TFhirObservation} read GetResultList;
    property hasResultList : boolean read GetHasResultList;

    // One or more links to full details of any imaging performed during the diagnostic investigation. Typically, this is imaging performed by DICOM enabled modalities, but this is not required. A fully enabled PACS viewer can use this information to provide views of the source images.
    property imagingStudyList : TFhirReferenceList{Resource} read GetImagingStudyList;
    property hasImagingStudyList : boolean read GetHasImagingStudyList;

    // A list of key images associated with this report. The images are generally created during the diagnostic process, and may be directly of the patient, or of treated specimens (i.e. slides of interest).
    property imageList : TFhirDiagnosticReportImageList read GetImageList;
    property hasImageList : boolean read GetHasImageList;

    // Typed access to Concise and clinically contextualized impression / summary of the diagnostic report.
    property conclusion : String read GetConclusionST write SetConclusionST;
    // Concise and clinically contextualized impression / summary of the diagnostic report.
    property conclusionElement : TFhirString read FConclusion write SetConclusion;

    // Codes for the conclusion.
    property codedDiagnosisList : TFhirCodeableConceptList read GetCodedDiagnosisList;
    property hasCodedDiagnosisList : boolean read GetHasCodedDiagnosisList;

    // Rich text representation of the entire result as issued by the diagnostic service. Multiple formats are allowed but they SHALL be semantically equivalent.
    property presentedFormList : TFhirAttachmentList read GetPresentedFormList;
    property hasPresentedFormList : boolean read GetHasPresentedFormList;

  end;

  TFhirDiagnosticReportListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDiagnosticReportList;
    function GetCurrent : TFhirDiagnosticReport;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDiagnosticReportList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDiagnosticReport read GetCurrent;
  end;

  TFhirDiagnosticReportList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDiagnosticReport;
    procedure SetItemN(index : Integer; value : TFhirDiagnosticReport);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDiagnosticReportList; Overload;
    function Clone : TFhirDiagnosticReportList; Overload;
    function GetEnumerator : TFhirDiagnosticReportListEnumerator;

    //  Add a FhirDiagnosticReport to the end of the list.
    function Append : TFhirDiagnosticReport;

    // Add an already existing FhirDiagnosticReport to the end of the list.
    procedure AddItem(value : TFhirDiagnosticReport); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDiagnosticReport) : Integer;

    // Insert FhirDiagnosticReport before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDiagnosticReport;

    // Insert an existing FhirDiagnosticReport before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDiagnosticReport);

    // Get the iIndexth FhirDiagnosticReport. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDiagnosticReport);

    // The number of items in the collection
    function Item(index : Integer) : TFhirDiagnosticReport;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirDiagnosticReports[index : Integer] : TFhirDiagnosticReport read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_DIAGNOSTICREPORT}

{$IFDEF FHIR_DOCUMENTMANIFEST}

  // The list of Documents included in the manifest.
  TFhirDocumentManifestContent = class (TFhirBackboneElement)
  protected
    FP : TFhirType;
    Procedure SetP(value : TFhirType);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDocumentManifestContent; overload;
    function Clone : TFhirDocumentManifestContent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The list of references to document content, or Attachment that consist of the parts of this document manifest. Usually, these would be document references, but direct references to Media or Attachments are also allowed. (defined for API consistency)
    property p : TFhirType read FP write SetP;
    // The list of references to document content, or Attachment that consist of the parts of this document manifest. Usually, these would be document references, but direct references to Media or Attachments are also allowed.
    property pElement : TFhirType read FP write SetP;

  end;

  TFhirDocumentManifestContentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDocumentManifestContentList;
    function GetCurrent : TFhirDocumentManifestContent;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDocumentManifestContentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDocumentManifestContent read GetCurrent;
  end;

  TFhirDocumentManifestContentList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDocumentManifestContent;
    procedure SetItemN(index : Integer; value : TFhirDocumentManifestContent);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDocumentManifestContentList; Overload;
    function Clone : TFhirDocumentManifestContentList; Overload;
    function GetEnumerator : TFhirDocumentManifestContentListEnumerator;

    //  Add a FhirDocumentManifestContent to the end of the list.
    function Append : TFhirDocumentManifestContent;

    // Add an already existing FhirDocumentManifestContent to the end of the list.
    procedure AddItem(value : TFhirDocumentManifestContent); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDocumentManifestContent) : Integer;

    // Insert FhirDocumentManifestContent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDocumentManifestContent;

    // Insert an existing FhirDocumentManifestContent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDocumentManifestContent);

    // Get the iIndexth FhirDocumentManifestContent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDocumentManifestContent);

    // The number of items in the collection
    function Item(index : Integer) : TFhirDocumentManifestContent;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirDocumentManifestContents[index : Integer] : TFhirDocumentManifestContent read GetItemN write SetItemN; default;
  End;

  // Related identifiers or resources associated with the DocumentManifest.
  TFhirDocumentManifestRelated = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirIdentifier;
    FRef : TFhirReference{TFhirReference};
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetRef(value : TFhirReference{TFhirReference});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDocumentManifestRelated; overload;
    function Clone : TFhirDocumentManifestRelated; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Related identifier to this DocumentManifest.  For example, Order numbers, accession numbers, XDW workflow numbers. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Related identifier to this DocumentManifest.  For example, Order numbers, accession numbers, XDW workflow numbers.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to Related Resource to this DocumentManifest. For example, Order, ProcedureRequest,  Procedure, EligibilityRequest, etc. (defined for API consistency)
    property ref : TFhirReference{TFhirReference} read FRef write SetRef;
    // Related Resource to this DocumentManifest. For example, Order, ProcedureRequest,  Procedure, EligibilityRequest, etc.
    property refElement : TFhirReference{TFhirReference} read FRef write SetRef;

  end;

  TFhirDocumentManifestRelatedListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDocumentManifestRelatedList;
    function GetCurrent : TFhirDocumentManifestRelated;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDocumentManifestRelatedList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDocumentManifestRelated read GetCurrent;
  end;

  TFhirDocumentManifestRelatedList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDocumentManifestRelated;
    procedure SetItemN(index : Integer; value : TFhirDocumentManifestRelated);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDocumentManifestRelatedList; Overload;
    function Clone : TFhirDocumentManifestRelatedList; Overload;
    function GetEnumerator : TFhirDocumentManifestRelatedListEnumerator;

    //  Add a FhirDocumentManifestRelated to the end of the list.
    function Append : TFhirDocumentManifestRelated;

    // Add an already existing FhirDocumentManifestRelated to the end of the list.
    procedure AddItem(value : TFhirDocumentManifestRelated); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDocumentManifestRelated) : Integer;

    // Insert FhirDocumentManifestRelated before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDocumentManifestRelated;

    // Insert an existing FhirDocumentManifestRelated before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDocumentManifestRelated);

    // Get the iIndexth FhirDocumentManifestRelated. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDocumentManifestRelated);

    // The number of items in the collection
    function Item(index : Integer) : TFhirDocumentManifestRelated;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirDocumentManifestRelateds[index : Integer] : TFhirDocumentManifestRelated read GetItemN write SetItemN; default;
  End;

  // A collection of documents compiled for a purpose together with metadata that applies to the collection.
  TFhirDocumentManifest = class (TFhirDomainResource)
  protected
    FMasterIdentifier : TFhirIdentifier;
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FType_ : TFhirCodeableConcept;
    FSubject : TFhirReference{Resource};
    FCreated : TFhirDateTime;
    FauthorList : TFhirReferenceList{Resource};
    FrecipientList : TFhirReferenceList{Resource};
    FSource : TFhirUri;
    FDescription : TFhirString;
    FcontentList : TFhirDocumentManifestContentList;
    FrelatedList : TFhirDocumentManifestRelatedList;
    Procedure SetMasterIdentifier(value : TFhirIdentifier);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirDocumentReferenceStatusEnum;
    Procedure SetStatusST(value : TFhirDocumentReferenceStatusEnum);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetSubject(value : TFhirReference{Resource});
    Procedure SetCreated(value : TFhirDateTime);
    Function GetCreatedST : TFslDateTime;
    Procedure SetCreatedST(value : TFslDateTime);
    function GetAuthorList : TFhirReferenceList{Resource};
    function GetHasAuthorList : Boolean;
    function GetRecipientList : TFhirReferenceList{Resource};
    function GetHasRecipientList : Boolean;
    Procedure SetSource(value : TFhirUri);
    Function GetSourceST : String;
    Procedure SetSourceST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    function GetContentList : TFhirDocumentManifestContentList;
    function GetHasContentList : Boolean;
    function GetRelatedList : TFhirDocumentManifestRelatedList;
    function GetHasRelatedList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDocumentManifest; overload;
    function Clone : TFhirDocumentManifest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A single identifier that uniquely identifies this manifest. Principally used to refer to the manifest in non-FHIR contexts. (defined for API consistency)
    property masterIdentifier : TFhirIdentifier read FMasterIdentifier write SetMasterIdentifier;
    // A single identifier that uniquely identifies this manifest. Principally used to refer to the manifest in non-FHIR contexts.
    property masterIdentifierElement : TFhirIdentifier read FMasterIdentifier write SetMasterIdentifier;

    // Other identifiers associated with the document manifest, including version independent  identifiers.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of this document manifest.
    property status : TFhirDocumentReferenceStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Specifies the kind of this set of documents (e.g. Patient Summary, Discharge Summary, Prescription, etc.). The type of a set of documents may be the same as one of the documents in it - especially if there is only one - but it may be wider. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Specifies the kind of this set of documents (e.g. Patient Summary, Discharge Summary, Prescription, etc.). The type of a set of documents may be the same as one of the documents in it - especially if there is only one - but it may be wider.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Who or what the set of documents is about. The documents can be about a person, (patient or healthcare practitioner), a device (i.e. machine) or even a group of subjects (such as a document about a herd of farm animals, or a set of patients that share a common exposure). If the documents cross more than one subject, then more than one subject is allowed here (unusual use case). (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // Who or what the set of documents is about. The documents can be about a person, (patient or healthcare practitioner), a device (i.e. machine) or even a group of subjects (such as a document about a herd of farm animals, or a set of patients that share a common exposure). If the documents cross more than one subject, then more than one subject is allowed here (unusual use case).
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // Typed access to When the document manifest was created for submission to the server (not necessarily the same thing as the actual resource last modified time, since it may be modified, replicated, etc.).
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // When the document manifest was created for submission to the server (not necessarily the same thing as the actual resource last modified time, since it may be modified, replicated, etc.).
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Identifies who is responsible for creating the manifest, and adding  documents to it.
    property authorList : TFhirReferenceList{Resource} read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // A patient, practitioner, or organization for which this set of documents is intended.
    property recipientList : TFhirReferenceList{Resource} read GetRecipientList;
    property hasRecipientList : boolean read GetHasRecipientList;

    // Typed access to Identifies the source system, application, or software that produced the document manifest.
    property source : String read GetSourceST write SetSourceST;
    // Identifies the source system, application, or software that produced the document manifest.
    property sourceElement : TFhirUri read FSource write SetSource;

    // Typed access to Human-readable description of the source document. This is sometimes known as the "title".
    property description : String read GetDescriptionST write SetDescriptionST;
    // Human-readable description of the source document. This is sometimes known as the "title".
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // The list of Documents included in the manifest.
    property contentList : TFhirDocumentManifestContentList read GetContentList;
    property hasContentList : boolean read GetHasContentList;

    // Related identifiers or resources associated with the DocumentManifest.
    property relatedList : TFhirDocumentManifestRelatedList read GetRelatedList;
    property hasRelatedList : boolean read GetHasRelatedList;

  end;

  TFhirDocumentManifestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDocumentManifestList;
    function GetCurrent : TFhirDocumentManifest;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDocumentManifestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDocumentManifest read GetCurrent;
  end;

  TFhirDocumentManifestList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDocumentManifest;
    procedure SetItemN(index : Integer; value : TFhirDocumentManifest);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDocumentManifestList; Overload;
    function Clone : TFhirDocumentManifestList; Overload;
    function GetEnumerator : TFhirDocumentManifestListEnumerator;

    //  Add a FhirDocumentManifest to the end of the list.
    function Append : TFhirDocumentManifest;

    // Add an already existing FhirDocumentManifest to the end of the list.
    procedure AddItem(value : TFhirDocumentManifest); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDocumentManifest) : Integer;

    // Insert FhirDocumentManifest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDocumentManifest;

    // Insert an existing FhirDocumentManifest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDocumentManifest);

    // Get the iIndexth FhirDocumentManifest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDocumentManifest);

    // The number of items in the collection
    function Item(index : Integer) : TFhirDocumentManifest;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirDocumentManifests[index : Integer] : TFhirDocumentManifest read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_DOCUMENTMANIFEST}

{$IFDEF FHIR_DOCUMENTREFERENCE}

  // Relationships that this document has with other document references that already exist.
  TFhirDocumentReferenceRelatesTo = class (TFhirBackboneElement)
  protected
    FCode : TFhirEnum;
    FTarget : TFhirReference{TFhirDocumentReference};
    Procedure SetCode(value : TFhirEnum);
    Function GetCodeST : TFhirDocumentRelationshipTypeEnum;
    Procedure SetCodeST(value : TFhirDocumentRelationshipTypeEnum);
    Procedure SetTarget(value : TFhirReference{TFhirDocumentReference});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDocumentReferenceRelatesTo; overload;
    function Clone : TFhirDocumentReferenceRelatesTo; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The type of relationship that this document has with anther document.
    property code : TFhirDocumentRelationshipTypeEnum read GetCodeST write SetCodeST;
    property codeElement : TFhirEnum read FCode write SetCode;

    // Typed access to The target document of this relationship. (defined for API consistency)
    property target : TFhirReference{TFhirDocumentReference} read FTarget write SetTarget;
    // The target document of this relationship.
    property targetElement : TFhirReference{TFhirDocumentReference} read FTarget write SetTarget;

  end;

  TFhirDocumentReferenceRelatesToListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDocumentReferenceRelatesToList;
    function GetCurrent : TFhirDocumentReferenceRelatesTo;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDocumentReferenceRelatesToList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDocumentReferenceRelatesTo read GetCurrent;
  end;

  TFhirDocumentReferenceRelatesToList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDocumentReferenceRelatesTo;
    procedure SetItemN(index : Integer; value : TFhirDocumentReferenceRelatesTo);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDocumentReferenceRelatesToList; Overload;
    function Clone : TFhirDocumentReferenceRelatesToList; Overload;
    function GetEnumerator : TFhirDocumentReferenceRelatesToListEnumerator;

    //  Add a FhirDocumentReferenceRelatesTo to the end of the list.
    function Append : TFhirDocumentReferenceRelatesTo;

    // Add an already existing FhirDocumentReferenceRelatesTo to the end of the list.
    procedure AddItem(value : TFhirDocumentReferenceRelatesTo); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDocumentReferenceRelatesTo) : Integer;

    // Insert FhirDocumentReferenceRelatesTo before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDocumentReferenceRelatesTo;

    // Insert an existing FhirDocumentReferenceRelatesTo before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDocumentReferenceRelatesTo);

    // Get the iIndexth FhirDocumentReferenceRelatesTo. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDocumentReferenceRelatesTo);

    // The number of items in the collection
    function Item(index : Integer) : TFhirDocumentReferenceRelatesTo;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirDocumentReferenceRelatesTos[index : Integer] : TFhirDocumentReferenceRelatesTo read GetItemN write SetItemN; default;
  End;

  // The document and format referenced. There may be multiple content element repetitions, each with a different format.
  TFhirDocumentReferenceContent = class (TFhirBackboneElement)
  protected
    FAttachment : TFhirAttachment;
    FFormat : TFhirCoding;
    Procedure SetAttachment(value : TFhirAttachment);
    Procedure SetFormat(value : TFhirCoding);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDocumentReferenceContent; overload;
    function Clone : TFhirDocumentReferenceContent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The document or URL of the document along with critical metadata to prove content has integrity. (defined for API consistency)
    property attachment : TFhirAttachment read FAttachment write SetAttachment;
    // The document or URL of the document along with critical metadata to prove content has integrity.
    property attachmentElement : TFhirAttachment read FAttachment write SetAttachment;

    // Typed access to An identifier of the document encoding, structure, and template that the document conforms to beyond the base format indicated in the mimeType. (defined for API consistency)
    property format : TFhirCoding read FFormat write SetFormat;
    // An identifier of the document encoding, structure, and template that the document conforms to beyond the base format indicated in the mimeType.
    property formatElement : TFhirCoding read FFormat write SetFormat;

  end;

  TFhirDocumentReferenceContentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDocumentReferenceContentList;
    function GetCurrent : TFhirDocumentReferenceContent;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDocumentReferenceContentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDocumentReferenceContent read GetCurrent;
  end;

  TFhirDocumentReferenceContentList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDocumentReferenceContent;
    procedure SetItemN(index : Integer; value : TFhirDocumentReferenceContent);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDocumentReferenceContentList; Overload;
    function Clone : TFhirDocumentReferenceContentList; Overload;
    function GetEnumerator : TFhirDocumentReferenceContentListEnumerator;

    //  Add a FhirDocumentReferenceContent to the end of the list.
    function Append : TFhirDocumentReferenceContent;

    // Add an already existing FhirDocumentReferenceContent to the end of the list.
    procedure AddItem(value : TFhirDocumentReferenceContent); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDocumentReferenceContent) : Integer;

    // Insert FhirDocumentReferenceContent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDocumentReferenceContent;

    // Insert an existing FhirDocumentReferenceContent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDocumentReferenceContent);

    // Get the iIndexth FhirDocumentReferenceContent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDocumentReferenceContent);

    // The number of items in the collection
    function Item(index : Integer) : TFhirDocumentReferenceContent;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirDocumentReferenceContents[index : Integer] : TFhirDocumentReferenceContent read GetItemN write SetItemN; default;
  End;

  // The clinical context in which the document was prepared.
  TFhirDocumentReferenceContext = class (TFhirBackboneElement)
  protected
    FEncounter : TFhirReference{TFhirEncounter};
    FeventList : TFhirCodeableConceptList;
    FPeriod : TFhirPeriod;
    FFacilityType : TFhirCodeableConcept;
    FPracticeSetting : TFhirCodeableConcept;
    FSourcePatientInfo : TFhirReference{TFhirPatient};
    FrelatedList : TFhirDocumentReferenceContextRelatedList;
    Procedure SetEncounter(value : TFhirReference{TFhirEncounter});
    function GetEventList : TFhirCodeableConceptList;
    function GetHasEventList : Boolean;
    Procedure SetPeriod(value : TFhirPeriod);
    Procedure SetFacilityType(value : TFhirCodeableConcept);
    Procedure SetPracticeSetting(value : TFhirCodeableConcept);
    Procedure SetSourcePatientInfo(value : TFhirReference{TFhirPatient});
    function GetRelatedList : TFhirDocumentReferenceContextRelatedList;
    function GetHasRelatedList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDocumentReferenceContext; overload;
    function Clone : TFhirDocumentReferenceContext; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Describes the clinical encounter or type of care that the document content is associated with. (defined for API consistency)
    property encounter : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;
    // Describes the clinical encounter or type of care that the document content is associated with.
    property encounterElement : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;

    // This list of codes represents the main clinical acts, such as a colonoscopy or an appendectomy, being documented. In some cases, the event is inherent in the typeCode, such as a "History and Physical Report" in which the procedure being documented is necessarily a "History and Physical" act.
    property eventList : TFhirCodeableConceptList read GetEventList;
    property hasEventList : boolean read GetHasEventList;

    // Typed access to The time period over which the service that is described by the document was provided. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The time period over which the service that is described by the document was provided.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to The kind of facility where the patient was seen. (defined for API consistency)
    property facilityType : TFhirCodeableConcept read FFacilityType write SetFacilityType;
    // The kind of facility where the patient was seen.
    property facilityTypeElement : TFhirCodeableConcept read FFacilityType write SetFacilityType;

    // Typed access to This property may convey specifics about the practice setting where the content was created, often reflecting the clinical specialty. (defined for API consistency)
    property practiceSetting : TFhirCodeableConcept read FPracticeSetting write SetPracticeSetting;
    // This property may convey specifics about the practice setting where the content was created, often reflecting the clinical specialty.
    property practiceSettingElement : TFhirCodeableConcept read FPracticeSetting write SetPracticeSetting;

    // Typed access to The Patient Information as known when the document was {$IFNDEF FPC}Published{$ENDIF}. May be a reference to a version specific, or contained. (defined for API consistency)
    property sourcePatientInfo : TFhirReference{TFhirPatient} read FSourcePatientInfo write SetSourcePatientInfo;
    // The Patient Information as known when the document was {$IFNDEF FPC}Published{$ENDIF}. May be a reference to a version specific, or contained.
    property sourcePatientInfoElement : TFhirReference{TFhirPatient} read FSourcePatientInfo write SetSourcePatientInfo;

    // Related identifiers or resources associated with the DocumentReference.
    property relatedList : TFhirDocumentReferenceContextRelatedList read GetRelatedList;
    property hasRelatedList : boolean read GetHasRelatedList;

  end;

  TFhirDocumentReferenceContextListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDocumentReferenceContextList;
    function GetCurrent : TFhirDocumentReferenceContext;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDocumentReferenceContextList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDocumentReferenceContext read GetCurrent;
  end;

  TFhirDocumentReferenceContextList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDocumentReferenceContext;
    procedure SetItemN(index : Integer; value : TFhirDocumentReferenceContext);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDocumentReferenceContextList; Overload;
    function Clone : TFhirDocumentReferenceContextList; Overload;
    function GetEnumerator : TFhirDocumentReferenceContextListEnumerator;

    //  Add a FhirDocumentReferenceContext to the end of the list.
    function Append : TFhirDocumentReferenceContext;

    // Add an already existing FhirDocumentReferenceContext to the end of the list.
    procedure AddItem(value : TFhirDocumentReferenceContext); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDocumentReferenceContext) : Integer;

    // Insert FhirDocumentReferenceContext before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDocumentReferenceContext;

    // Insert an existing FhirDocumentReferenceContext before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDocumentReferenceContext);

    // Get the iIndexth FhirDocumentReferenceContext. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDocumentReferenceContext);

    // The number of items in the collection
    function Item(index : Integer) : TFhirDocumentReferenceContext;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirDocumentReferenceContexts[index : Integer] : TFhirDocumentReferenceContext read GetItemN write SetItemN; default;
  End;

  // Related identifiers or resources associated with the DocumentReference.
  TFhirDocumentReferenceContextRelated = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirIdentifier;
    FRef : TFhirReference{TFhirReference};
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetRef(value : TFhirReference{TFhirReference});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDocumentReferenceContextRelated; overload;
    function Clone : TFhirDocumentReferenceContextRelated; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Related identifier to this DocumentReference. If both id and ref are present they shall refer to the same thing. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Related identifier to this DocumentReference. If both id and ref are present they shall refer to the same thing.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to Related Resource to this DocumentReference. If both id and ref are present they shall refer to the same thing. (defined for API consistency)
    property ref : TFhirReference{TFhirReference} read FRef write SetRef;
    // Related Resource to this DocumentReference. If both id and ref are present they shall refer to the same thing.
    property refElement : TFhirReference{TFhirReference} read FRef write SetRef;

  end;

  TFhirDocumentReferenceContextRelatedListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDocumentReferenceContextRelatedList;
    function GetCurrent : TFhirDocumentReferenceContextRelated;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDocumentReferenceContextRelatedList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDocumentReferenceContextRelated read GetCurrent;
  end;

  TFhirDocumentReferenceContextRelatedList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDocumentReferenceContextRelated;
    procedure SetItemN(index : Integer; value : TFhirDocumentReferenceContextRelated);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDocumentReferenceContextRelatedList; Overload;
    function Clone : TFhirDocumentReferenceContextRelatedList; Overload;
    function GetEnumerator : TFhirDocumentReferenceContextRelatedListEnumerator;

    //  Add a FhirDocumentReferenceContextRelated to the end of the list.
    function Append : TFhirDocumentReferenceContextRelated;

    // Add an already existing FhirDocumentReferenceContextRelated to the end of the list.
    procedure AddItem(value : TFhirDocumentReferenceContextRelated); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDocumentReferenceContextRelated) : Integer;

    // Insert FhirDocumentReferenceContextRelated before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDocumentReferenceContextRelated;

    // Insert an existing FhirDocumentReferenceContextRelated before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDocumentReferenceContextRelated);

    // Get the iIndexth FhirDocumentReferenceContextRelated. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDocumentReferenceContextRelated);

    // The number of items in the collection
    function Item(index : Integer) : TFhirDocumentReferenceContextRelated;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirDocumentReferenceContextRelateds[index : Integer] : TFhirDocumentReferenceContextRelated read GetItemN write SetItemN; default;
  End;

  // A reference to a document.
  TFhirDocumentReference = class (TFhirDomainResource)
  protected
    FMasterIdentifier : TFhirIdentifier;
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FDocStatus : TFhirEnum;
    FType_ : TFhirCodeableConcept;
    FClass_ : TFhirCodeableConcept;
    FSubject : TFhirReference{Resource};
    FCreated : TFhirDateTime;
    FIndexed : TFhirInstant;
    FauthorList : TFhirReferenceList{Resource};
    FAuthenticator : TFhirReference{Resource};
    FCustodian : TFhirReference{TFhirOrganization};
    FrelatesToList : TFhirDocumentReferenceRelatesToList;
    FDescription : TFhirString;
    FsecurityLabelList : TFhirCodeableConceptList;
    FcontentList : TFhirDocumentReferenceContentList;
    FContext : TFhirDocumentReferenceContext;
    Procedure SetMasterIdentifier(value : TFhirIdentifier);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirDocumentReferenceStatusEnum;
    Procedure SetStatusST(value : TFhirDocumentReferenceStatusEnum);
    Procedure SetDocStatus(value : TFhirEnum);
    Function GetDocStatusST : TFhirCompositionStatusEnum;
    Procedure SetDocStatusST(value : TFhirCompositionStatusEnum);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetClass_(value : TFhirCodeableConcept);
    Procedure SetSubject(value : TFhirReference{Resource});
    Procedure SetCreated(value : TFhirDateTime);
    Function GetCreatedST : TFslDateTime;
    Procedure SetCreatedST(value : TFslDateTime);
    Procedure SetIndexed(value : TFhirInstant);
    Function GetIndexedST : TFslDateTime;
    Procedure SetIndexedST(value : TFslDateTime);
    function GetAuthorList : TFhirReferenceList{Resource};
    function GetHasAuthorList : Boolean;
    Procedure SetAuthenticator(value : TFhirReference{Resource});
    Procedure SetCustodian(value : TFhirReference{TFhirOrganization});
    function GetRelatesToList : TFhirDocumentReferenceRelatesToList;
    function GetHasRelatesToList : Boolean;
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    function GetSecurityLabelList : TFhirCodeableConceptList;
    function GetHasSecurityLabelList : Boolean;
    function GetContentList : TFhirDocumentReferenceContentList;
    function GetHasContentList : Boolean;
    Procedure SetContext(value : TFhirDocumentReferenceContext);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDocumentReference; overload;
    function Clone : TFhirDocumentReference; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Document identifier as assigned by the source of the document. This identifier is specific to this version of the document. This unique identifier may be used elsewhere to identify this version of the document. (defined for API consistency)
    property masterIdentifier : TFhirIdentifier read FMasterIdentifier write SetMasterIdentifier;
    // Document identifier as assigned by the source of the document. This identifier is specific to this version of the document. This unique identifier may be used elsewhere to identify this version of the document.
    property masterIdentifierElement : TFhirIdentifier read FMasterIdentifier write SetMasterIdentifier;

    // Other identifiers associated with the document, including version independent identifiers.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of this document reference.
    property status : TFhirDocumentReferenceStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // The status of the underlying document.
    property docStatus : TFhirCompositionStatusEnum read GetDocStatusST write SetDocStatusST;
    property docStatusElement : TFhirEnum read FDocStatus write SetDocStatus;

    // Typed access to Specifies the particular kind of document referenced  (e.g. History and Physical, Discharge Summary, Progress Note). This usually equates to the purpose of making the document referenced. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Specifies the particular kind of document referenced  (e.g. History and Physical, Discharge Summary, Progress Note). This usually equates to the purpose of making the document referenced.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A categorization for the type of document referenced - helps for indexing and searching. This may be implied by or derived from the code specified in the DocumentReference.type. (defined for API consistency)
    property class_ : TFhirCodeableConcept read FClass_ write SetClass_;
    // A categorization for the type of document referenced - helps for indexing and searching. This may be implied by or derived from the code specified in the DocumentReference.type.
    property class_Element : TFhirCodeableConcept read FClass_ write SetClass_;

    // Typed access to Who or what the document is about. The document can be about a person, (patient or healthcare practitioner), a device (e.g. a machine) or even a group of subjects (such as a document about a herd of farm animals, or a set of patients that share a common exposure). (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // Who or what the document is about. The document can be about a person, (patient or healthcare practitioner), a device (e.g. a machine) or even a group of subjects (such as a document about a herd of farm animals, or a set of patients that share a common exposure).
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // Typed access to When the document was created.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // When the document was created.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to When the document reference was created.
    property indexed : TFslDateTime read GetIndexedST write SetIndexedST;
    // When the document reference was created.
    property indexedElement : TFhirInstant read FIndexed write SetIndexed;

    // Identifies who is responsible for adding the information to the document.
    property authorList : TFhirReferenceList{Resource} read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // Typed access to Which person or organization authenticates that this document is valid. (defined for API consistency)
    property authenticator : TFhirReference{Resource} read FAuthenticator write SetAuthenticator;
    // Which person or organization authenticates that this document is valid.
    property authenticatorElement : TFhirReference{Resource} read FAuthenticator write SetAuthenticator;

    // Typed access to Identifies the organization or group who is responsible for ongoing maintenance of and access to the document. (defined for API consistency)
    property custodian : TFhirReference{TFhirOrganization} read FCustodian write SetCustodian;
    // Identifies the organization or group who is responsible for ongoing maintenance of and access to the document.
    property custodianElement : TFhirReference{TFhirOrganization} read FCustodian write SetCustodian;

    // Relationships that this document has with other document references that already exist.
    property relatesToList : TFhirDocumentReferenceRelatesToList read GetRelatesToList;
    property hasRelatesToList : boolean read GetHasRelatesToList;

    // Typed access to Human-readable description of the source document. This is sometimes known as the "title".
    property description : String read GetDescriptionST write SetDescriptionST;
    // Human-readable description of the source document. This is sometimes known as the "title".
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // A set of Security-Tag codes specifying the level of privacy/security of the Document. Note that DocumentReference.meta.security contains the security labels of the "reference" to the document, while DocumentReference.securityLabel contains a snapshot of the security labels on the document the reference refers to.
    property securityLabelList : TFhirCodeableConceptList read GetSecurityLabelList;
    property hasSecurityLabelList : boolean read GetHasSecurityLabelList;

    // The document and format referenced. There may be multiple content element repetitions, each with a different format.
    property contentList : TFhirDocumentReferenceContentList read GetContentList;
    property hasContentList : boolean read GetHasContentList;

    // Typed access to The clinical context in which the document was prepared. (defined for API consistency)
    property context : TFhirDocumentReferenceContext read FContext write SetContext;
    // The clinical context in which the document was prepared.
    property contextElement : TFhirDocumentReferenceContext read FContext write SetContext;

  end;

  TFhirDocumentReferenceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDocumentReferenceList;
    function GetCurrent : TFhirDocumentReference;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDocumentReferenceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDocumentReference read GetCurrent;
  end;

  TFhirDocumentReferenceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDocumentReference;
    procedure SetItemN(index : Integer; value : TFhirDocumentReference);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDocumentReferenceList; Overload;
    function Clone : TFhirDocumentReferenceList; Overload;
    function GetEnumerator : TFhirDocumentReferenceListEnumerator;

    //  Add a FhirDocumentReference to the end of the list.
    function Append : TFhirDocumentReference;

    // Add an already existing FhirDocumentReference to the end of the list.
    procedure AddItem(value : TFhirDocumentReference); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDocumentReference) : Integer;

    // Insert FhirDocumentReference before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDocumentReference;

    // Insert an existing FhirDocumentReference before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDocumentReference);

    // Get the iIndexth FhirDocumentReference. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDocumentReference);

    // The number of items in the collection
    function Item(index : Integer) : TFhirDocumentReference;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirDocumentReferences[index : Integer] : TFhirDocumentReference read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_DOCUMENTREFERENCE}

{$IFDEF FHIR_FAMILYMEMBERHISTORY}

  // The significant Conditions (or condition) that the family member had. This is a repeating section to allow a system to represent more than one condition per resource, though there is nothing stopping multiple resources - one per condition.
  TFhirFamilyMemberHistoryCondition = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FOutcome : TFhirCodeableConcept;
    FOnset : TFhirType;
    FnoteList : TFhirAnnotationList;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetOutcome(value : TFhirCodeableConcept);
    Procedure SetOnset(value : TFhirType);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirFamilyMemberHistoryCondition; overload;
    function Clone : TFhirFamilyMemberHistoryCondition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The actual condition specified. Could be a coded condition (like MI or Diabetes) or a less specific string like 'cancer' depending on how much is known about the condition and the capabilities of the creating system. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The actual condition specified. Could be a coded condition (like MI or Diabetes) or a less specific string like 'cancer' depending on how much is known about the condition and the capabilities of the creating system.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to Indicates what happened as a result of this condition.  If the condition resulted in death, deceased date is captured on the relation. (defined for API consistency)
    property outcome : TFhirCodeableConcept read FOutcome write SetOutcome;
    // Indicates what happened as a result of this condition.  If the condition resulted in death, deceased date is captured on the relation.
    property outcomeElement : TFhirCodeableConcept read FOutcome write SetOutcome;

    // Typed access to Either the age of onset, range of approximate age or descriptive string can be recorded.  For conditions with multiple occurrences, this describes the first known occurrence. (defined for API consistency)
    property onset : TFhirType read FOnset write SetOnset;
    // Either the age of onset, range of approximate age or descriptive string can be recorded.  For conditions with multiple occurrences, this describes the first known occurrence.
    property onsetElement : TFhirType read FOnset write SetOnset;

    // An area where general notes can be placed about this specific condition.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirFamilyMemberHistoryConditionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirFamilyMemberHistoryConditionList;
    function GetCurrent : TFhirFamilyMemberHistoryCondition;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirFamilyMemberHistoryConditionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirFamilyMemberHistoryCondition read GetCurrent;
  end;

  TFhirFamilyMemberHistoryConditionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirFamilyMemberHistoryCondition;
    procedure SetItemN(index : Integer; value : TFhirFamilyMemberHistoryCondition);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirFamilyMemberHistoryConditionList; Overload;
    function Clone : TFhirFamilyMemberHistoryConditionList; Overload;
    function GetEnumerator : TFhirFamilyMemberHistoryConditionListEnumerator;

    //  Add a FhirFamilyMemberHistoryCondition to the end of the list.
    function Append : TFhirFamilyMemberHistoryCondition;

    // Add an already existing FhirFamilyMemberHistoryCondition to the end of the list.
    procedure AddItem(value : TFhirFamilyMemberHistoryCondition); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirFamilyMemberHistoryCondition) : Integer;

    // Insert FhirFamilyMemberHistoryCondition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirFamilyMemberHistoryCondition;

    // Insert an existing FhirFamilyMemberHistoryCondition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirFamilyMemberHistoryCondition);

    // Get the iIndexth FhirFamilyMemberHistoryCondition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirFamilyMemberHistoryCondition);

    // The number of items in the collection
    function Item(index : Integer) : TFhirFamilyMemberHistoryCondition;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirFamilyMemberHistoryConditions[index : Integer] : TFhirFamilyMemberHistoryCondition read GetItemN write SetItemN; default;
  End;

  // Significant health events and conditions for a person related to the patient relevant in the context of care for the patient.
  TFhirFamilyMemberHistory = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FdefinitionList : TFhirReferenceList{Resource};
    FStatus : TFhirEnum;
    FNotDone : TFhirBoolean;
    FNotDoneReason : TFhirCodeableConcept;
    FPatient : TFhirReference{TFhirPatient};
    FDate : TFhirDateTime;
    FName : TFhirString;
    FRelationship : TFhirCodeableConcept;
    FGender : TFhirEnum;
    FBorn : TFhirType;
    FAge : TFhirType;
    FEstimatedAge : TFhirBoolean;
    FDeceased : TFhirType;
    FreasonCodeList : TFhirCodeableConceptList;
    FreasonReferenceList : TFhirReferenceList{Resource};
    FnoteList : TFhirAnnotationList;
    FconditionList : TFhirFamilyMemberHistoryConditionList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetDefinitionList : TFhirReferenceList{Resource};
    function GetHasDefinitionList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirHistoryStatusEnum;
    Procedure SetStatusST(value : TFhirHistoryStatusEnum);
    Procedure SetNotDone(value : TFhirBoolean);
    Function GetNotDoneST : Boolean;
    Procedure SetNotDoneST(value : Boolean);
    Procedure SetNotDoneReason(value : TFhirCodeableConcept);
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetRelationship(value : TFhirCodeableConcept);
    Procedure SetGender(value : TFhirEnum);
    Function GetGenderST : TFhirAdministrativeGenderEnum;
    Procedure SetGenderST(value : TFhirAdministrativeGenderEnum);
    Procedure SetBorn(value : TFhirType);
    Procedure SetAge(value : TFhirType);
    Procedure SetEstimatedAge(value : TFhirBoolean);
    Function GetEstimatedAgeST : Boolean;
    Procedure SetEstimatedAgeST(value : Boolean);
    Procedure SetDeceased(value : TFhirType);
    function GetReasonCodeList : TFhirCodeableConceptList;
    function GetHasReasonCodeList : Boolean;
    function GetReasonReferenceList : TFhirReferenceList{Resource};
    function GetHasReasonReferenceList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetConditionList : TFhirFamilyMemberHistoryConditionList;
    function GetHasConditionList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirFamilyMemberHistory; overload;
    function Clone : TFhirFamilyMemberHistory; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // This records identifiers associated with this family member history record that are defined by business processes and/ or used to refer to it when a direct URL reference to the resource itself is not appropriate (e.g. in CDA documents, or in written / printed documentation).
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A protocol or questionnaire that was adhered to in whole or in part by this event.
    property definitionList : TFhirReferenceList{Resource} read GetDefinitionList;
    property hasDefinitionList : boolean read GetHasDefinitionList;

    // A code specifying the status of the record of the family history of a specific family member.
    property status : TFhirHistoryStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to If true, indicates the taking of an individual family member's history did not occur. The notDone element should not be used to document negated conditions, such as a family member that did not have a condition.
    property notDone : Boolean read GetNotDoneST write SetNotDoneST;
    // If true, indicates the taking of an individual family member's history did not occur. The notDone element should not be used to document negated conditions, such as a family member that did not have a condition.
    property notDoneElement : TFhirBoolean read FNotDone write SetNotDone;

    // Typed access to Describes why the family member's history is absent. (defined for API consistency)
    property notDoneReason : TFhirCodeableConcept read FNotDoneReason write SetNotDoneReason;
    // Describes why the family member's history is absent.
    property notDoneReasonElement : TFhirCodeableConcept read FNotDoneReason write SetNotDoneReason;

    // Typed access to The person who this history concerns. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // The person who this history concerns.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Typed access to The date (and possibly time) when the family member history was taken.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date (and possibly time) when the family member history was taken.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to This will either be a name or a description; e.g. "Aunt Susan", "my cousin with the red hair".
    property name : String read GetNameST write SetNameST;
    // This will either be a name or a description; e.g. "Aunt Susan", "my cousin with the red hair".
    property nameElement : TFhirString read FName write SetName;

    // Typed access to The type of relationship this person has to the patient (father, mother, brother etc.). (defined for API consistency)
    property relationship : TFhirCodeableConcept read FRelationship write SetRelationship;
    // The type of relationship this person has to the patient (father, mother, brother etc.).
    property relationshipElement : TFhirCodeableConcept read FRelationship write SetRelationship;

    // Administrative Gender - the gender that the relative is considered to have for administration and record keeping purposes.
    property gender : TFhirAdministrativeGenderEnum read GetGenderST write SetGenderST;
    property genderElement : TFhirEnum read FGender write SetGender;

    // Typed access to The actual or approximate date of birth of the relative. (defined for API consistency)
    property born : TFhirType read FBorn write SetBorn;
    // The actual or approximate date of birth of the relative.
    property bornElement : TFhirType read FBorn write SetBorn;

    // Typed access to The age of the relative at the time the family member history is recorded. (defined for API consistency)
    property age : TFhirType read FAge write SetAge;
    // The age of the relative at the time the family member history is recorded.
    property ageElement : TFhirType read FAge write SetAge;

    // Typed access to If true, indicates that the age value specified is an estimated value.
    property estimatedAge : Boolean read GetEstimatedAgeST write SetEstimatedAgeST;
    // If true, indicates that the age value specified is an estimated value.
    property estimatedAgeElement : TFhirBoolean read FEstimatedAge write SetEstimatedAge;

    // Typed access to Deceased flag or the actual or approximate age of the relative at the time of death for the family member history record. (defined for API consistency)
    property deceased : TFhirType read FDeceased write SetDeceased;
    // Deceased flag or the actual or approximate age of the relative at the time of death for the family member history record.
    property deceasedElement : TFhirType read FDeceased write SetDeceased;

    // Describes why the family member history occurred in coded or textual form.
    property reasonCodeList : TFhirCodeableConceptList read GetReasonCodeList;
    property hasReasonCodeList : boolean read GetHasReasonCodeList;

    // Indicates a Condition, Observation, AllergyIntolerance, or QuestionnaireResponse that justifies this family member history event.
    property reasonReferenceList : TFhirReferenceList{Resource} read GetReasonReferenceList;
    property hasReasonReferenceList : boolean read GetHasReasonReferenceList;

    // This property allows a non condition-specific note to the made about the related person. Ideally, the note would be in the condition property, but this is not always possible.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // The significant Conditions (or condition) that the family member had. This is a repeating section to allow a system to represent more than one condition per resource, though there is nothing stopping multiple resources - one per condition.
    property conditionList : TFhirFamilyMemberHistoryConditionList read GetConditionList;
    property hasConditionList : boolean read GetHasConditionList;

  end;

  TFhirFamilyMemberHistoryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirFamilyMemberHistoryList;
    function GetCurrent : TFhirFamilyMemberHistory;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirFamilyMemberHistoryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirFamilyMemberHistory read GetCurrent;
  end;

  TFhirFamilyMemberHistoryList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirFamilyMemberHistory;
    procedure SetItemN(index : Integer; value : TFhirFamilyMemberHistory);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirFamilyMemberHistoryList; Overload;
    function Clone : TFhirFamilyMemberHistoryList; Overload;
    function GetEnumerator : TFhirFamilyMemberHistoryListEnumerator;

    //  Add a FhirFamilyMemberHistory to the end of the list.
    function Append : TFhirFamilyMemberHistory;

    // Add an already existing FhirFamilyMemberHistory to the end of the list.
    procedure AddItem(value : TFhirFamilyMemberHistory); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirFamilyMemberHistory) : Integer;

    // Insert FhirFamilyMemberHistory before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirFamilyMemberHistory;

    // Insert an existing FhirFamilyMemberHistory before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirFamilyMemberHistory);

    // Get the iIndexth FhirFamilyMemberHistory. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirFamilyMemberHistory);

    // The number of items in the collection
    function Item(index : Integer) : TFhirFamilyMemberHistory;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirFamilyMemberHistories[index : Integer] : TFhirFamilyMemberHistory read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_FAMILYMEMBERHISTORY}

{$IFDEF FHIR_FLAG}

  // Prospective warnings of potential issues when providing care to the patient.
  TFhirFlag = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FCategory : TFhirCodeableConcept;
    FCode : TFhirCodeableConcept;
    FSubject : TFhirReference{Resource};
    FPeriod : TFhirPeriod;
    FEncounter : TFhirReference{TFhirEncounter};
    FAuthor : TFhirReference{Resource};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirFlagStatusEnum;
    Procedure SetStatusST(value : TFhirFlagStatusEnum);
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetSubject(value : TFhirReference{Resource});
    Procedure SetPeriod(value : TFhirPeriod);
    Procedure SetEncounter(value : TFhirReference{TFhirEncounter});
    Procedure SetAuthor(value : TFhirReference{Resource});

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirFlag; overload;
    function Clone : TFhirFlag; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Identifier assigned to the flag for external use (outside the FHIR environment).
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Supports basic workflow.
    property status : TFhirFlagStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Allows an flag to be divided into different categories like clinical, administrative etc. Intended to be used as a means of filtering which flags are displayed to particular user or in a given context. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Allows an flag to be divided into different categories like clinical, administrative etc. Intended to be used as a means of filtering which flags are displayed to particular user or in a given context.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to The coded value or textual component of the flag to display to the user. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The coded value or textual component of the flag to display to the user.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The patient, location, group , organization , or practitioner, etc. this is about record this flag is associated with. (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // The patient, location, group , organization , or practitioner, etc. this is about record this flag is associated with.
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // Typed access to The period of time from the activation of the flag to inactivation of the flag. If the flag is active, the end of the period should be unspecified. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period of time from the activation of the flag to inactivation of the flag. If the flag is active, the end of the period should be unspecified.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to This alert is only relevant during the encounter. (defined for API consistency)
    property encounter : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;
    // This alert is only relevant during the encounter.
    property encounterElement : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;

    // Typed access to The person, organization or device that created the flag. (defined for API consistency)
    property author : TFhirReference{Resource} read FAuthor write SetAuthor;
    // The person, organization or device that created the flag.
    property authorElement : TFhirReference{Resource} read FAuthor write SetAuthor;

  end;

  TFhirFlagListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirFlagList;
    function GetCurrent : TFhirFlag;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirFlagList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirFlag read GetCurrent;
  end;

  TFhirFlagList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirFlag;
    procedure SetItemN(index : Integer; value : TFhirFlag);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirFlagList; Overload;
    function Clone : TFhirFlagList; Overload;
    function GetEnumerator : TFhirFlagListEnumerator;

    //  Add a FhirFlag to the end of the list.
    function Append : TFhirFlag;

    // Add an already existing FhirFlag to the end of the list.
    procedure AddItem(value : TFhirFlag); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirFlag) : Integer;

    // Insert FhirFlag before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirFlag;

    // Insert an existing FhirFlag before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirFlag);

    // Get the iIndexth FhirFlag. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirFlag);

    // The number of items in the collection
    function Item(index : Integer) : TFhirFlag;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirFlags[index : Integer] : TFhirFlag read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_FLAG}

{$IFDEF FHIR_GOAL}

  // Indicates what should be done by when.
  TFhirGoalTarget = class (TFhirBackboneElement)
  protected
    FMeasure : TFhirCodeableConcept;
    FDetail : TFhirType;
    FDue : TFhirType;
    Procedure SetMeasure(value : TFhirCodeableConcept);
    Procedure SetDetail(value : TFhirType);
    Procedure SetDue(value : TFhirType);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirGoalTarget; overload;
    function Clone : TFhirGoalTarget; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The parameter whose value is being tracked, e.g. body weight, blood pressure, or hemoglobin A1c level. (defined for API consistency)
    property measure : TFhirCodeableConcept read FMeasure write SetMeasure;
    // The parameter whose value is being tracked, e.g. body weight, blood pressure, or hemoglobin A1c level.
    property measureElement : TFhirCodeableConcept read FMeasure write SetMeasure;

    // Typed access to The target value of the focus to be achieved to signify the fulfillment of the goal, e.g. 150 pounds, 7.0%. Either the high or low or both values of the range can be specified. When a low value is missing, it indicates that the goal is achieved at any focus value at or below the high value. Similarly, if the high value is missing, it indicates that the goal is achieved at any focus value at or above the low value. (defined for API consistency)
    property detail : TFhirType read FDetail write SetDetail;
    // The target value of the focus to be achieved to signify the fulfillment of the goal, e.g. 150 pounds, 7.0%. Either the high or low or both values of the range can be specified. When a low value is missing, it indicates that the goal is achieved at any focus value at or below the high value. Similarly, if the high value is missing, it indicates that the goal is achieved at any focus value at or above the low value.
    property detailElement : TFhirType read FDetail write SetDetail;

    // Typed access to Indicates either the date or the duration after start by which the goal should be met. (defined for API consistency)
    property due : TFhirType read FDue write SetDue;
    // Indicates either the date or the duration after start by which the goal should be met.
    property dueElement : TFhirType read FDue write SetDue;

  end;

  TFhirGoalTargetListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirGoalTargetList;
    function GetCurrent : TFhirGoalTarget;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirGoalTargetList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirGoalTarget read GetCurrent;
  end;

  TFhirGoalTargetList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirGoalTarget;
    procedure SetItemN(index : Integer; value : TFhirGoalTarget);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirGoalTargetList; Overload;
    function Clone : TFhirGoalTargetList; Overload;
    function GetEnumerator : TFhirGoalTargetListEnumerator;

    //  Add a FhirGoalTarget to the end of the list.
    function Append : TFhirGoalTarget;

    // Add an already existing FhirGoalTarget to the end of the list.
    procedure AddItem(value : TFhirGoalTarget); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirGoalTarget) : Integer;

    // Insert FhirGoalTarget before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirGoalTarget;

    // Insert an existing FhirGoalTarget before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirGoalTarget);

    // Get the iIndexth FhirGoalTarget. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirGoalTarget);

    // The number of items in the collection
    function Item(index : Integer) : TFhirGoalTarget;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirGoalTargets[index : Integer] : TFhirGoalTarget read GetItemN write SetItemN; default;
  End;

  // Describes the intended objective(s) for a patient, group or organization care, for example, weight loss, restoring an activity of daily living, obtaining herd immunity via immunization, meeting a process improvement objective, etc.
  TFhirGoal = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FcategoryList : TFhirCodeableConceptList;
    FPriority : TFhirCodeableConcept;
    FDescription : TFhirCodeableConcept;
    FSubject : TFhirReference{Resource};
    FStart : TFhirType;
    FTarget : TFhirGoalTarget;
    FStatusDate : TFhirDate;
    FStatusReason : TFhirString;
    FExpressedBy : TFhirReference{Resource};
    FaddressesList : TFhirReferenceList{Resource};
    FnoteList : TFhirAnnotationList;
    FoutcomeCodeList : TFhirCodeableConceptList;
    FoutcomeReferenceList : TFhirReferenceList{TFhirObservation};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirGoalStatusEnum;
    Procedure SetStatusST(value : TFhirGoalStatusEnum);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    Procedure SetPriority(value : TFhirCodeableConcept);
    Procedure SetDescription(value : TFhirCodeableConcept);
    Procedure SetSubject(value : TFhirReference{Resource});
    Procedure SetStart(value : TFhirType);
    Procedure SetTarget(value : TFhirGoalTarget);
    Procedure SetStatusDate(value : TFhirDate);
    Function GetStatusDateST : TFslDateTime;
    Procedure SetStatusDateST(value : TFslDateTime);
    Procedure SetStatusReason(value : TFhirString);
    Function GetStatusReasonST : String;
    Procedure SetStatusReasonST(value : String);
    Procedure SetExpressedBy(value : TFhirReference{Resource});
    function GetAddressesList : TFhirReferenceList{Resource};
    function GetHasAddressesList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetOutcomeCodeList : TFhirCodeableConceptList;
    function GetHasOutcomeCodeList : Boolean;
    function GetOutcomeReferenceList : TFhirReferenceList{TFhirObservation};
    function GetHasOutcomeReferenceList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirGoal; overload;
    function Clone : TFhirGoal; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // This records identifiers associated with this care plan that are defined by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate (e.g. in CDA documents, or in written / printed documentation).
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Indicates whether the goal has been reached and is still considered relevant.
    property status : TFhirGoalStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Indicates a category the goal falls within.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to Identifies the mutually agreed level of importance associated with reaching/sustaining the goal. (defined for API consistency)
    property priority : TFhirCodeableConcept read FPriority write SetPriority;
    // Identifies the mutually agreed level of importance associated with reaching/sustaining the goal.
    property priorityElement : TFhirCodeableConcept read FPriority write SetPriority;

    // Typed access to Human-readable and/or coded description of a specific desired objective of care, such as "control blood pressure" or "negotiate an obstacle course" or "dance with child at wedding". (defined for API consistency)
    property description : TFhirCodeableConcept read FDescription write SetDescription;
    // Human-readable and/or coded description of a specific desired objective of care, such as "control blood pressure" or "negotiate an obstacle course" or "dance with child at wedding".
    property descriptionElement : TFhirCodeableConcept read FDescription write SetDescription;

    // Typed access to Identifies the patient, group or organization for whom the goal is being established. (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // Identifies the patient, group or organization for whom the goal is being established.
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // Typed access to The date or event after which the goal should begin being pursued. (defined for API consistency)
    property start : TFhirType read FStart write SetStart;
    // The date or event after which the goal should begin being pursued.
    property startElement : TFhirType read FStart write SetStart;

    // Typed access to Indicates what should be done by when. (defined for API consistency)
    property target : TFhirGoalTarget read FTarget write SetTarget;
    // Indicates what should be done by when.
    property targetElement : TFhirGoalTarget read FTarget write SetTarget;

    // Typed access to Identifies when the current status.  I.e. When initially created, when achieved, when cancelled, etc.
    property statusDate : TFslDateTime read GetStatusDateST write SetStatusDateST;
    // Identifies when the current status.  I.e. When initially created, when achieved, when cancelled, etc.
    property statusDateElement : TFhirDate read FStatusDate write SetStatusDate;

    // Typed access to Captures the reason for the current status.
    property statusReason : String read GetStatusReasonST write SetStatusReasonST;
    // Captures the reason for the current status.
    property statusReasonElement : TFhirString read FStatusReason write SetStatusReason;

    // Typed access to Indicates whose goal this is - patient goal, practitioner goal, etc. (defined for API consistency)
    property expressedBy : TFhirReference{Resource} read FExpressedBy write SetExpressedBy;
    // Indicates whose goal this is - patient goal, practitioner goal, etc.
    property expressedByElement : TFhirReference{Resource} read FExpressedBy write SetExpressedBy;

    // The identified conditions and other health record elements that are intended to be addressed by the goal.
    property addressesList : TFhirReferenceList{Resource} read GetAddressesList;
    property hasAddressesList : boolean read GetHasAddressesList;

    // Any comments related to the goal.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Identifies the change (or lack of change) at the point when the status of the goal is assessed.
    property outcomeCodeList : TFhirCodeableConceptList read GetOutcomeCodeList;
    property hasOutcomeCodeList : boolean read GetHasOutcomeCodeList;

    // Details of what's changed (or not changed).
    property outcomeReferenceList : TFhirReferenceList{TFhirObservation} read GetOutcomeReferenceList;
    property hasOutcomeReferenceList : boolean read GetHasOutcomeReferenceList;

  end;

  TFhirGoalListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirGoalList;
    function GetCurrent : TFhirGoal;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirGoalList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirGoal read GetCurrent;
  end;

  TFhirGoalList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirGoal;
    procedure SetItemN(index : Integer; value : TFhirGoal);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirGoalList; Overload;
    function Clone : TFhirGoalList; Overload;
    function GetEnumerator : TFhirGoalListEnumerator;

    //  Add a FhirGoal to the end of the list.
    function Append : TFhirGoal;

    // Add an already existing FhirGoal to the end of the list.
    procedure AddItem(value : TFhirGoal); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirGoal) : Integer;

    // Insert FhirGoal before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirGoal;

    // Insert an existing FhirGoal before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirGoal);

    // Get the iIndexth FhirGoal. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirGoal);

    // The number of items in the collection
    function Item(index : Integer) : TFhirGoal;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirGoals[index : Integer] : TFhirGoal read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_GOAL}

{$IFDEF FHIR_IMAGINGMANIFEST}

  // Study identity and locating information of the DICOM SOP instances in the selection.
  TFhirImagingManifestStudy = class (TFhirBackboneElement)
  protected
    FUid : TFhirOid;
    FImagingStudy : TFhirReference{TFhirImagingStudy};
    FendpointList : TFhirReferenceList{TFhirEndpoint};
    FseriesList : TFhirImagingManifestStudySeriesList;
    Procedure SetUid(value : TFhirOid);
    Function GetUidST : String;
    Procedure SetUidST(value : String);
    Procedure SetImagingStudy(value : TFhirReference{TFhirImagingStudy});
    function GetEndpointList : TFhirReferenceList{TFhirEndpoint};
    function GetHasEndpointList : Boolean;
    function GetSeriesList : TFhirImagingManifestStudySeriesList;
    function GetHasSeriesList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImagingManifestStudy; overload;
    function Clone : TFhirImagingManifestStudy; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Study instance UID of the SOP instances in the selection.
    property uid : String read GetUidST write SetUidST;
    // Study instance UID of the SOP instances in the selection.
    property uidElement : TFhirOid read FUid write SetUid;

    // Typed access to Reference to the Imaging Study in FHIR form. (defined for API consistency)
    property imagingStudy : TFhirReference{TFhirImagingStudy} read FImagingStudy write SetImagingStudy;
    // Reference to the Imaging Study in FHIR form.
    property imagingStudyElement : TFhirReference{TFhirImagingStudy} read FImagingStudy write SetImagingStudy;

    // The network service providing access (e.g., query, view, or retrieval) for the study. See implementation notes for information about using DICOM endpoints. A study-level endpoint applies to each series in the study, unless overridden by a series-level endpoint with the same Endpoint.type.
    property endpointList : TFhirReferenceList{TFhirEndpoint} read GetEndpointList;
    property hasEndpointList : boolean read GetHasEndpointList;

    // Series identity and locating information of the DICOM SOP instances in the selection.
    property seriesList : TFhirImagingManifestStudySeriesList read GetSeriesList;
    property hasSeriesList : boolean read GetHasSeriesList;

  end;

  TFhirImagingManifestStudyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImagingManifestStudyList;
    function GetCurrent : TFhirImagingManifestStudy;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImagingManifestStudyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImagingManifestStudy read GetCurrent;
  end;

  TFhirImagingManifestStudyList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImagingManifestStudy;
    procedure SetItemN(index : Integer; value : TFhirImagingManifestStudy);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImagingManifestStudyList; Overload;
    function Clone : TFhirImagingManifestStudyList; Overload;
    function GetEnumerator : TFhirImagingManifestStudyListEnumerator;

    //  Add a FhirImagingManifestStudy to the end of the list.
    function Append : TFhirImagingManifestStudy;

    // Add an already existing FhirImagingManifestStudy to the end of the list.
    procedure AddItem(value : TFhirImagingManifestStudy); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImagingManifestStudy) : Integer;

    // Insert FhirImagingManifestStudy before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImagingManifestStudy;

    // Insert an existing FhirImagingManifestStudy before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImagingManifestStudy);

    // Get the iIndexth FhirImagingManifestStudy. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImagingManifestStudy);

    // The number of items in the collection
    function Item(index : Integer) : TFhirImagingManifestStudy;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirImagingManifestStudies[index : Integer] : TFhirImagingManifestStudy read GetItemN write SetItemN; default;
  End;

  // Series identity and locating information of the DICOM SOP instances in the selection.
  TFhirImagingManifestStudySeries = class (TFhirBackboneElement)
  protected
    FUid : TFhirOid;
    FendpointList : TFhirReferenceList{TFhirEndpoint};
    FinstanceList : TFhirImagingManifestStudySeriesInstanceList;
    Procedure SetUid(value : TFhirOid);
    Function GetUidST : String;
    Procedure SetUidST(value : String);
    function GetEndpointList : TFhirReferenceList{TFhirEndpoint};
    function GetHasEndpointList : Boolean;
    function GetInstanceList : TFhirImagingManifestStudySeriesInstanceList;
    function GetHasInstanceList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImagingManifestStudySeries; overload;
    function Clone : TFhirImagingManifestStudySeries; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Series instance UID of the SOP instances in the selection.
    property uid : String read GetUidST write SetUidST;
    // Series instance UID of the SOP instances in the selection.
    property uidElement : TFhirOid read FUid write SetUid;

    // The network service providing access (e.g., query, view, or retrieval) for this series. See implementation notes for information about using DICOM endpoints. A series-level endpoint, if present, has precedence over a study-level endpoint with the same Endpoint.type.
    property endpointList : TFhirReferenceList{TFhirEndpoint} read GetEndpointList;
    property hasEndpointList : boolean read GetHasEndpointList;

    // Identity and locating information of the selected DICOM SOP instances.
    property instanceList : TFhirImagingManifestStudySeriesInstanceList read GetInstanceList;
    property hasInstanceList : boolean read GetHasInstanceList;

  end;

  TFhirImagingManifestStudySeriesListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImagingManifestStudySeriesList;
    function GetCurrent : TFhirImagingManifestStudySeries;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImagingManifestStudySeriesList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImagingManifestStudySeries read GetCurrent;
  end;

  TFhirImagingManifestStudySeriesList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImagingManifestStudySeries;
    procedure SetItemN(index : Integer; value : TFhirImagingManifestStudySeries);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImagingManifestStudySeriesList; Overload;
    function Clone : TFhirImagingManifestStudySeriesList; Overload;
    function GetEnumerator : TFhirImagingManifestStudySeriesListEnumerator;

    //  Add a FhirImagingManifestStudySeries to the end of the list.
    function Append : TFhirImagingManifestStudySeries;

    // Add an already existing FhirImagingManifestStudySeries to the end of the list.
    procedure AddItem(value : TFhirImagingManifestStudySeries); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImagingManifestStudySeries) : Integer;

    // Insert FhirImagingManifestStudySeries before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImagingManifestStudySeries;

    // Insert an existing FhirImagingManifestStudySeries before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImagingManifestStudySeries);

    // Get the iIndexth FhirImagingManifestStudySeries. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImagingManifestStudySeries);

    // The number of items in the collection
    function Item(index : Integer) : TFhirImagingManifestStudySeries;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirImagingManifestStudySeries[index : Integer] : TFhirImagingManifestStudySeries read GetItemN write SetItemN; default;
  End;

  // Identity and locating information of the selected DICOM SOP instances.
  TFhirImagingManifestStudySeriesInstance = class (TFhirBackboneElement)
  protected
    FSopClass : TFhirOid;
    FUid : TFhirOid;
    Procedure SetSopClass(value : TFhirOid);
    Function GetSopClassST : String;
    Procedure SetSopClassST(value : String);
    Procedure SetUid(value : TFhirOid);
    Function GetUidST : String;
    Procedure SetUidST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImagingManifestStudySeriesInstance; overload;
    function Clone : TFhirImagingManifestStudySeriesInstance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to SOP class UID of the selected instance.
    property sopClass : String read GetSopClassST write SetSopClassST;
    // SOP class UID of the selected instance.
    property sopClassElement : TFhirOid read FSopClass write SetSopClass;

    // Typed access to SOP Instance UID of the selected instance.
    property uid : String read GetUidST write SetUidST;
    // SOP Instance UID of the selected instance.
    property uidElement : TFhirOid read FUid write SetUid;

  end;

  TFhirImagingManifestStudySeriesInstanceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImagingManifestStudySeriesInstanceList;
    function GetCurrent : TFhirImagingManifestStudySeriesInstance;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImagingManifestStudySeriesInstanceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImagingManifestStudySeriesInstance read GetCurrent;
  end;

  TFhirImagingManifestStudySeriesInstanceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImagingManifestStudySeriesInstance;
    procedure SetItemN(index : Integer; value : TFhirImagingManifestStudySeriesInstance);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImagingManifestStudySeriesInstanceList; Overload;
    function Clone : TFhirImagingManifestStudySeriesInstanceList; Overload;
    function GetEnumerator : TFhirImagingManifestStudySeriesInstanceListEnumerator;

    //  Add a FhirImagingManifestStudySeriesInstance to the end of the list.
    function Append : TFhirImagingManifestStudySeriesInstance;

    // Add an already existing FhirImagingManifestStudySeriesInstance to the end of the list.
    procedure AddItem(value : TFhirImagingManifestStudySeriesInstance); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImagingManifestStudySeriesInstance) : Integer;

    // Insert FhirImagingManifestStudySeriesInstance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImagingManifestStudySeriesInstance;

    // Insert an existing FhirImagingManifestStudySeriesInstance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImagingManifestStudySeriesInstance);

    // Get the iIndexth FhirImagingManifestStudySeriesInstance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImagingManifestStudySeriesInstance);

    // The number of items in the collection
    function Item(index : Integer) : TFhirImagingManifestStudySeriesInstance;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirImagingManifestStudySeriesInstances[index : Integer] : TFhirImagingManifestStudySeriesInstance read GetItemN write SetItemN; default;
  End;

  // A text description of the DICOM SOP instances selected in the ImagingManifest; or the reason for, or significance of, the selection.
  TFhirImagingManifest = class (TFhirDomainResource)
  protected
    FIdentifier : TFhirIdentifier;
    FPatient : TFhirReference{TFhirPatient};
    FAuthoringTime : TFhirDateTime;
    FAuthor : TFhirReference{Resource};
    FDescription : TFhirString;
    FstudyList : TFhirImagingManifestStudyList;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    Procedure SetAuthoringTime(value : TFhirDateTime);
    Function GetAuthoringTimeST : TFslDateTime;
    Procedure SetAuthoringTimeST(value : TFslDateTime);
    Procedure SetAuthor(value : TFhirReference{Resource});
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    function GetStudyList : TFhirImagingManifestStudyList;
    function GetHasStudyList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImagingManifest; overload;
    function Clone : TFhirImagingManifest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Unique identifier of the DICOM Key Object Selection (KOS) that this resource represents. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Unique identifier of the DICOM Key Object Selection (KOS) that this resource represents.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to A patient resource reference which is the patient subject of all DICOM SOP Instances in this ImagingManifest. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // A patient resource reference which is the patient subject of all DICOM SOP Instances in this ImagingManifest.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Typed access to Date and time when the selection of the referenced instances were made. It is (typically) different from the creation date of the selection resource, and from dates associated with the referenced instances (e.g. capture time of the referenced image).
    property authoringTime : TFslDateTime read GetAuthoringTimeST write SetAuthoringTimeST;
    // Date and time when the selection of the referenced instances were made. It is (typically) different from the creation date of the selection resource, and from dates associated with the referenced instances (e.g. capture time of the referenced image).
    property authoringTimeElement : TFhirDateTime read FAuthoringTime write SetAuthoringTime;

    // Typed access to Author of ImagingManifest. It can be a human author or a device which made the decision of the SOP instances selected. For example, a radiologist selected a set of imaging SOP instances to attach in a diagnostic report, and a CAD application may author a selection to describe SOP instances it used to generate a detection conclusion. (defined for API consistency)
    property author : TFhirReference{Resource} read FAuthor write SetAuthor;
    // Author of ImagingManifest. It can be a human author or a device which made the decision of the SOP instances selected. For example, a radiologist selected a set of imaging SOP instances to attach in a diagnostic report, and a CAD application may author a selection to describe SOP instances it used to generate a detection conclusion.
    property authorElement : TFhirReference{Resource} read FAuthor write SetAuthor;

    // Typed access to Free text narrative description of the ImagingManifest.   The value may be derived from the DICOM Standard Part 16, CID-7010 descriptions (e.g. Best in Set, Complete Study Content). Note that those values cover the wide range of uses of the DICOM Key Object Selection object, several of which are not supported by ImagingManifest. Specifically, there is no expected behavior associated with descriptions that suggest referenced images be removed or not used.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Free text narrative description of the ImagingManifest.   The value may be derived from the DICOM Standard Part 16, CID-7010 descriptions (e.g. Best in Set, Complete Study Content). Note that those values cover the wide range of uses of the DICOM Key Object Selection object, several of which are not supported by ImagingManifest. Specifically, there is no expected behavior associated with descriptions that suggest referenced images be removed or not used.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Study identity and locating information of the DICOM SOP instances in the selection.
    property studyList : TFhirImagingManifestStudyList read GetStudyList;
    property hasStudyList : boolean read GetHasStudyList;

  end;

  TFhirImagingManifestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImagingManifestList;
    function GetCurrent : TFhirImagingManifest;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImagingManifestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImagingManifest read GetCurrent;
  end;

  TFhirImagingManifestList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImagingManifest;
    procedure SetItemN(index : Integer; value : TFhirImagingManifest);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImagingManifestList; Overload;
    function Clone : TFhirImagingManifestList; Overload;
    function GetEnumerator : TFhirImagingManifestListEnumerator;

    //  Add a FhirImagingManifest to the end of the list.
    function Append : TFhirImagingManifest;

    // Add an already existing FhirImagingManifest to the end of the list.
    procedure AddItem(value : TFhirImagingManifest); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImagingManifest) : Integer;

    // Insert FhirImagingManifest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImagingManifest;

    // Insert an existing FhirImagingManifest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImagingManifest);

    // Get the iIndexth FhirImagingManifest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImagingManifest);

    // The number of items in the collection
    function Item(index : Integer) : TFhirImagingManifest;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirImagingManifests[index : Integer] : TFhirImagingManifest read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_IMAGINGMANIFEST}

{$IFDEF FHIR_IMAGINGSTUDY}

  // Each study has one or more series of images or other content.
  TFhirImagingStudySeries = class (TFhirBackboneElement)
  protected
    FUid : TFhirOid;
    FNumber : TFhirUnsignedInt;
    FModality : TFhirCoding;
    FDescription : TFhirString;
    FNumberOfInstances : TFhirUnsignedInt;
    FAvailability : TFhirEnum;
    FendpointList : TFhirReferenceList{TFhirEndpoint};
    FBodySite : TFhirCoding;
    FLaterality : TFhirCoding;
    FStarted : TFhirDateTime;
    FperformerList : TFhirReferenceList{TFhirPractitioner};
    FinstanceList : TFhirImagingStudySeriesInstanceList;
    Procedure SetUid(value : TFhirOid);
    Function GetUidST : String;
    Procedure SetUidST(value : String);
    Procedure SetNumber(value : TFhirUnsignedInt);
    Function GetNumberST : String;
    Procedure SetNumberST(value : String);
    Procedure SetModality(value : TFhirCoding);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetNumberOfInstances(value : TFhirUnsignedInt);
    Function GetNumberOfInstancesST : String;
    Procedure SetNumberOfInstancesST(value : String);
    Procedure SetAvailability(value : TFhirEnum);
    Function GetAvailabilityST : TFhirInstanceAvailabilityEnum;
    Procedure SetAvailabilityST(value : TFhirInstanceAvailabilityEnum);
    function GetEndpointList : TFhirReferenceList{TFhirEndpoint};
    function GetHasEndpointList : Boolean;
    Procedure SetBodySite(value : TFhirCoding);
    Procedure SetLaterality(value : TFhirCoding);
    Procedure SetStarted(value : TFhirDateTime);
    Function GetStartedST : TFslDateTime;
    Procedure SetStartedST(value : TFslDateTime);
    function GetPerformerList : TFhirReferenceList{TFhirPractitioner};
    function GetHasPerformerList : Boolean;
    function GetInstanceList : TFhirImagingStudySeriesInstanceList;
    function GetHasInstanceList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImagingStudySeries; overload;
    function Clone : TFhirImagingStudySeries; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Formal identifier for this series.
    property uid : String read GetUidST write SetUidST;
    // Formal identifier for this series.
    property uidElement : TFhirOid read FUid write SetUid;

    // Typed access to The numeric identifier of this series in the study.
    property number : String read GetNumberST write SetNumberST;
    // The numeric identifier of this series in the study.
    property numberElement : TFhirUnsignedInt read FNumber write SetNumber;

    // Typed access to The modality of this series sequence. (defined for API consistency)
    property modality : TFhirCoding read FModality write SetModality;
    // The modality of this series sequence.
    property modalityElement : TFhirCoding read FModality write SetModality;

    // Typed access to A description of the series.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A description of the series.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Number of SOP Instances in the Study. The value given may be larger than the number of instance elements this resource contains due to resource availability, security, or other factors. This element should be present if any instance elements are present.
    property numberOfInstances : String read GetNumberOfInstancesST write SetNumberOfInstancesST;
    // Number of SOP Instances in the Study. The value given may be larger than the number of instance elements this resource contains due to resource availability, security, or other factors. This element should be present if any instance elements are present.
    property numberOfInstancesElement : TFhirUnsignedInt read FNumberOfInstances write SetNumberOfInstances;

    // Availability of series (online, offline or nearline).
    property availability : TFhirInstanceAvailabilityEnum read GetAvailabilityST write SetAvailabilityST;
    property availabilityElement : TFhirEnum read FAvailability write SetAvailability;

    // The network service providing access (e.g., query, view, or retrieval) for this series. See implementation notes for information about using DICOM endpoints. A series-level endpoint, if present, has precedence over a study-level endpoint with the same Endpoint.type.
    property endpointList : TFhirReferenceList{TFhirEndpoint} read GetEndpointList;
    property hasEndpointList : boolean read GetHasEndpointList;

    // Typed access to The anatomic structures examined. See DICOM Part 16 Annex L (http://dicom.nema.org/medical/dicom/current/output/chtml/part16/chapter_L.html) for DICOM to SNOMED-CT mappings. The bodySite may indicate the laterality of body part imaged; if so, it shall be consistent with any content of ImagingStudy.series.laterality. (defined for API consistency)
    property bodySite : TFhirCoding read FBodySite write SetBodySite;
    // The anatomic structures examined. See DICOM Part 16 Annex L (http://dicom.nema.org/medical/dicom/current/output/chtml/part16/chapter_L.html) for DICOM to SNOMED-CT mappings. The bodySite may indicate the laterality of body part imaged; if so, it shall be consistent with any content of ImagingStudy.series.laterality.
    property bodySiteElement : TFhirCoding read FBodySite write SetBodySite;

    // Typed access to The laterality of the (possibly paired) anatomic structures examined. E.g., the left knee, both lungs, or unpaired abdomen. If present, shall be consistent with any laterality information indicated in ImagingStudy.series.bodySite. (defined for API consistency)
    property laterality : TFhirCoding read FLaterality write SetLaterality;
    // The laterality of the (possibly paired) anatomic structures examined. E.g., the left knee, both lungs, or unpaired abdomen. If present, shall be consistent with any laterality information indicated in ImagingStudy.series.bodySite.
    property lateralityElement : TFhirCoding read FLaterality write SetLaterality;

    // Typed access to The date and time the series was started.
    property started : TFslDateTime read GetStartedST write SetStartedST;
    // The date and time the series was started.
    property startedElement : TFhirDateTime read FStarted write SetStarted;

    // The physician or operator (often the radiology technician)  who performed the series. The performer is recorded at the series level, since each series in a study may be performed by a different practitioner, at different times, and using different devices. A series may be performed by multiple practitioners.
    property performerList : TFhirReferenceList{TFhirPractitioner} read GetPerformerList;
    property hasPerformerList : boolean read GetHasPerformerList;

    // A single SOP instance within the series, e.g. an image, or presentation state.
    property instanceList : TFhirImagingStudySeriesInstanceList read GetInstanceList;
    property hasInstanceList : boolean read GetHasInstanceList;

  end;

  TFhirImagingStudySeriesListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImagingStudySeriesList;
    function GetCurrent : TFhirImagingStudySeries;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImagingStudySeriesList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImagingStudySeries read GetCurrent;
  end;

  TFhirImagingStudySeriesList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImagingStudySeries;
    procedure SetItemN(index : Integer; value : TFhirImagingStudySeries);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImagingStudySeriesList; Overload;
    function Clone : TFhirImagingStudySeriesList; Overload;
    function GetEnumerator : TFhirImagingStudySeriesListEnumerator;

    //  Add a FhirImagingStudySeries to the end of the list.
    function Append : TFhirImagingStudySeries;

    // Add an already existing FhirImagingStudySeries to the end of the list.
    procedure AddItem(value : TFhirImagingStudySeries); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImagingStudySeries) : Integer;

    // Insert FhirImagingStudySeries before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImagingStudySeries;

    // Insert an existing FhirImagingStudySeries before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImagingStudySeries);

    // Get the iIndexth FhirImagingStudySeries. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImagingStudySeries);

    // The number of items in the collection
    function Item(index : Integer) : TFhirImagingStudySeries;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirImagingStudySeries[index : Integer] : TFhirImagingStudySeries read GetItemN write SetItemN; default;
  End;

  // A single SOP instance within the series, e.g. an image, or presentation state.
  TFhirImagingStudySeriesInstance = class (TFhirBackboneElement)
  protected
    FUid : TFhirOid;
    FNumber : TFhirUnsignedInt;
    FSopClass : TFhirOid;
    FTitle : TFhirString;
    Procedure SetUid(value : TFhirOid);
    Function GetUidST : String;
    Procedure SetUidST(value : String);
    Procedure SetNumber(value : TFhirUnsignedInt);
    Function GetNumberST : String;
    Procedure SetNumberST(value : String);
    Procedure SetSopClass(value : TFhirOid);
    Function GetSopClassST : String;
    Procedure SetSopClassST(value : String);
    Procedure SetTitle(value : TFhirString);
    Function GetTitleST : String;
    Procedure SetTitleST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImagingStudySeriesInstance; overload;
    function Clone : TFhirImagingStudySeriesInstance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Formal identifier for this image or other content.
    property uid : String read GetUidST write SetUidST;
    // Formal identifier for this image or other content.
    property uidElement : TFhirOid read FUid write SetUid;

    // Typed access to The number of instance in the series.
    property number : String read GetNumberST write SetNumberST;
    // The number of instance in the series.
    property numberElement : TFhirUnsignedInt read FNumber write SetNumber;

    // Typed access to DICOM instance  type.
    property sopClass : String read GetSopClassST write SetSopClassST;
    // DICOM instance  type.
    property sopClassElement : TFhirOid read FSopClass write SetSopClass;

    // Typed access to The description of the instance.
    property title : String read GetTitleST write SetTitleST;
    // The description of the instance.
    property titleElement : TFhirString read FTitle write SetTitle;

  end;

  TFhirImagingStudySeriesInstanceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImagingStudySeriesInstanceList;
    function GetCurrent : TFhirImagingStudySeriesInstance;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImagingStudySeriesInstanceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImagingStudySeriesInstance read GetCurrent;
  end;

  TFhirImagingStudySeriesInstanceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImagingStudySeriesInstance;
    procedure SetItemN(index : Integer; value : TFhirImagingStudySeriesInstance);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImagingStudySeriesInstanceList; Overload;
    function Clone : TFhirImagingStudySeriesInstanceList; Overload;
    function GetEnumerator : TFhirImagingStudySeriesInstanceListEnumerator;

    //  Add a FhirImagingStudySeriesInstance to the end of the list.
    function Append : TFhirImagingStudySeriesInstance;

    // Add an already existing FhirImagingStudySeriesInstance to the end of the list.
    procedure AddItem(value : TFhirImagingStudySeriesInstance); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImagingStudySeriesInstance) : Integer;

    // Insert FhirImagingStudySeriesInstance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImagingStudySeriesInstance;

    // Insert an existing FhirImagingStudySeriesInstance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImagingStudySeriesInstance);

    // Get the iIndexth FhirImagingStudySeriesInstance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImagingStudySeriesInstance);

    // The number of items in the collection
    function Item(index : Integer) : TFhirImagingStudySeriesInstance;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirImagingStudySeriesInstances[index : Integer] : TFhirImagingStudySeriesInstance read GetItemN write SetItemN; default;
  End;

  // Representation of the content produced in a DICOM imaging study. A study comprises a set of series, each of which includes a set of Service-Object Pair Instances (SOP Instances - images or other data) acquired or produced in a common context.  A series is of only one modality (e.g. X-ray, CT, MR, ultrasound), but a study may have multiple series of different modalities.
  TFhirImagingStudy = class (TFhirDomainResource)
  protected
    FUid : TFhirOid;
    FAccession : TFhirIdentifier;
    FidentifierList : TFhirIdentifierList;
    FAvailability : TFhirEnum;
    FmodalityListList : TFhirCodingList;
    FPatient : TFhirReference{TFhirPatient};
    FContext : TFhirReference{Resource};
    FStarted : TFhirDateTime;
    FbasedOnList : TFhirReferenceList{Resource};
    FReferrer : TFhirReference{TFhirPractitioner};
    FinterpreterList : TFhirReferenceList{TFhirPractitioner};
    FendpointList : TFhirReferenceList{TFhirEndpoint};
    FNumberOfSeries : TFhirUnsignedInt;
    FNumberOfInstances : TFhirUnsignedInt;
    FprocedureReferenceList : TFhirReferenceList{TFhirProcedure};
    FprocedureCodeList : TFhirCodeableConceptList;
    FReason : TFhirCodeableConcept;
    FDescription : TFhirString;
    FseriesList : TFhirImagingStudySeriesList;
    Procedure SetUid(value : TFhirOid);
    Function GetUidST : String;
    Procedure SetUidST(value : String);
    Procedure SetAccession(value : TFhirIdentifier);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetAvailability(value : TFhirEnum);
    Function GetAvailabilityST : TFhirInstanceAvailabilityEnum;
    Procedure SetAvailabilityST(value : TFhirInstanceAvailabilityEnum);
    function GetModalityListList : TFhirCodingList;
    function GetHasModalityListList : Boolean;
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    Procedure SetContext(value : TFhirReference{Resource});
    Procedure SetStarted(value : TFhirDateTime);
    Function GetStartedST : TFslDateTime;
    Procedure SetStartedST(value : TFslDateTime);
    function GetBasedOnList : TFhirReferenceList{Resource};
    function GetHasBasedOnList : Boolean;
    Procedure SetReferrer(value : TFhirReference{TFhirPractitioner});
    function GetInterpreterList : TFhirReferenceList{TFhirPractitioner};
    function GetHasInterpreterList : Boolean;
    function GetEndpointList : TFhirReferenceList{TFhirEndpoint};
    function GetHasEndpointList : Boolean;
    Procedure SetNumberOfSeries(value : TFhirUnsignedInt);
    Function GetNumberOfSeriesST : String;
    Procedure SetNumberOfSeriesST(value : String);
    Procedure SetNumberOfInstances(value : TFhirUnsignedInt);
    Function GetNumberOfInstancesST : String;
    Procedure SetNumberOfInstancesST(value : String);
    function GetProcedureReferenceList : TFhirReferenceList{TFhirProcedure};
    function GetHasProcedureReferenceList : Boolean;
    function GetProcedureCodeList : TFhirCodeableConceptList;
    function GetHasProcedureCodeList : Boolean;
    Procedure SetReason(value : TFhirCodeableConcept);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    function GetSeriesList : TFhirImagingStudySeriesList;
    function GetHasSeriesList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImagingStudy; overload;
    function Clone : TFhirImagingStudy; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Formal identifier for the study.
    property uid : String read GetUidST write SetUidST;
    // Formal identifier for the study.
    property uidElement : TFhirOid read FUid write SetUid;

    // Typed access to Accession Number is an identifier related to some aspect of imaging workflow and data management. Usage may vary across different institutions.  See for instance [IHE Radiology Technical Framework Volume 1 Appendix A](http://www.ihe.net/uploadedFiles/Documents/Radiology/IHE_RAD_TF_Rev13.0_Vol1_FT_2014-07-30.pdf). (defined for API consistency)
    property accession : TFhirIdentifier read FAccession write SetAccession;
    // Accession Number is an identifier related to some aspect of imaging workflow and data management. Usage may vary across different institutions.  See for instance [IHE Radiology Technical Framework Volume 1 Appendix A](http://www.ihe.net/uploadedFiles/Documents/Radiology/IHE_RAD_TF_Rev13.0_Vol1_FT_2014-07-30.pdf).
    property accessionElement : TFhirIdentifier read FAccession write SetAccession;

    // Other identifiers for the study.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Availability of study (online, offline, or nearline).
    property availability : TFhirInstanceAvailabilityEnum read GetAvailabilityST write SetAvailabilityST;
    property availabilityElement : TFhirEnum read FAvailability write SetAvailability;

    // A list of all the Series.ImageModality values that are actual acquisition modalities, i.e. those in the DICOM Context Group 29 (value set OID 1.2.840.10008.6.1.19).
    property modalityListList : TFhirCodingList read GetModalityListList;
    property hasModalityListList : boolean read GetHasModalityListList;

    // Typed access to The patient imaged in the study. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // The patient imaged in the study.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Typed access to The encounter or episode at which the request is initiated. (defined for API consistency)
    property context : TFhirReference{Resource} read FContext write SetContext;
    // The encounter or episode at which the request is initiated.
    property contextElement : TFhirReference{Resource} read FContext write SetContext;

    // Typed access to Date and time the study started.
    property started : TFslDateTime read GetStartedST write SetStartedST;
    // Date and time the study started.
    property startedElement : TFhirDateTime read FStarted write SetStarted;

    // A list of the diagnostic requests that resulted in this imaging study being performed.
    property basedOnList : TFhirReferenceList{Resource} read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // Typed access to The requesting/referring physician. (defined for API consistency)
    property referrer : TFhirReference{TFhirPractitioner} read FReferrer write SetReferrer;
    // The requesting/referring physician.
    property referrerElement : TFhirReference{TFhirPractitioner} read FReferrer write SetReferrer;

    // Who read the study and interpreted the images or other content.
    property interpreterList : TFhirReferenceList{TFhirPractitioner} read GetInterpreterList;
    property hasInterpreterList : boolean read GetHasInterpreterList;

    // The network service providing access (e.g., query, view, or retrieval) for the study. See implementation notes for information about using DICOM endpoints. A study-level endpoint applies to each series in the study, unless overridden by a series-level endpoint with the same Endpoint.type.
    property endpointList : TFhirReferenceList{TFhirEndpoint} read GetEndpointList;
    property hasEndpointList : boolean read GetHasEndpointList;

    // Typed access to Number of Series in the Study. This value given may be larger than the number of series elements this Resource contains due to resource availability, security, or other factors. This element should be present if any series elements are present.
    property numberOfSeries : String read GetNumberOfSeriesST write SetNumberOfSeriesST;
    // Number of Series in the Study. This value given may be larger than the number of series elements this Resource contains due to resource availability, security, or other factors. This element should be present if any series elements are present.
    property numberOfSeriesElement : TFhirUnsignedInt read FNumberOfSeries write SetNumberOfSeries;

    // Typed access to Number of SOP Instances in Study. This value given may be larger than the number of instance elements this resource contains due to resource availability, security, or other factors. This element should be present if any instance elements are present.
    property numberOfInstances : String read GetNumberOfInstancesST write SetNumberOfInstancesST;
    // Number of SOP Instances in Study. This value given may be larger than the number of instance elements this resource contains due to resource availability, security, or other factors. This element should be present if any instance elements are present.
    property numberOfInstancesElement : TFhirUnsignedInt read FNumberOfInstances write SetNumberOfInstances;

    // A reference to the performed Procedure.
    property procedureReferenceList : TFhirReferenceList{TFhirProcedure} read GetProcedureReferenceList;
    property hasProcedureReferenceList : boolean read GetHasProcedureReferenceList;

    // The code for the performed procedure type.
    property procedureCodeList : TFhirCodeableConceptList read GetProcedureCodeList;
    property hasProcedureCodeList : boolean read GetHasProcedureCodeList;

    // Typed access to Description of clinical condition indicating why the ImagingStudy was requested. (defined for API consistency)
    property reason : TFhirCodeableConcept read FReason write SetReason;
    // Description of clinical condition indicating why the ImagingStudy was requested.
    property reasonElement : TFhirCodeableConcept read FReason write SetReason;

    // Typed access to Institution-generated description or classification of the Study performed.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Institution-generated description or classification of the Study performed.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Each study has one or more series of images or other content.
    property seriesList : TFhirImagingStudySeriesList read GetSeriesList;
    property hasSeriesList : boolean read GetHasSeriesList;

  end;

  TFhirImagingStudyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImagingStudyList;
    function GetCurrent : TFhirImagingStudy;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImagingStudyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImagingStudy read GetCurrent;
  end;

  TFhirImagingStudyList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImagingStudy;
    procedure SetItemN(index : Integer; value : TFhirImagingStudy);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImagingStudyList; Overload;
    function Clone : TFhirImagingStudyList; Overload;
    function GetEnumerator : TFhirImagingStudyListEnumerator;

    //  Add a FhirImagingStudy to the end of the list.
    function Append : TFhirImagingStudy;

    // Add an already existing FhirImagingStudy to the end of the list.
    procedure AddItem(value : TFhirImagingStudy); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImagingStudy) : Integer;

    // Insert FhirImagingStudy before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImagingStudy;

    // Insert an existing FhirImagingStudy before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImagingStudy);

    // Get the iIndexth FhirImagingStudy. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImagingStudy);

    // The number of items in the collection
    function Item(index : Integer) : TFhirImagingStudy;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirImagingStudies[index : Integer] : TFhirImagingStudy read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_IMAGINGSTUDY}

{$IFDEF FHIR_IMMUNIZATION}

  // Indicates who or what performed the event.
  TFhirImmunizationPractitioner = class (TFhirBackboneElement)
  protected
    FRole : TFhirCodeableConcept;
    FActor : TFhirReference{TFhirPractitioner};
    Procedure SetRole(value : TFhirCodeableConcept);
    Procedure SetActor(value : TFhirReference{TFhirPractitioner});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImmunizationPractitioner; overload;
    function Clone : TFhirImmunizationPractitioner; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Describes the type of performance (e.g. ordering provider, administering provider, etc.). (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // Describes the type of performance (e.g. ordering provider, administering provider, etc.).
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

    // Typed access to The device, practitioner, etc. who performed the action. (defined for API consistency)
    property actor : TFhirReference{TFhirPractitioner} read FActor write SetActor;
    // The device, practitioner, etc. who performed the action.
    property actorElement : TFhirReference{TFhirPractitioner} read FActor write SetActor;

  end;

  TFhirImmunizationPractitionerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImmunizationPractitionerList;
    function GetCurrent : TFhirImmunizationPractitioner;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImmunizationPractitionerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImmunizationPractitioner read GetCurrent;
  end;

  TFhirImmunizationPractitionerList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImmunizationPractitioner;
    procedure SetItemN(index : Integer; value : TFhirImmunizationPractitioner);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImmunizationPractitionerList; Overload;
    function Clone : TFhirImmunizationPractitionerList; Overload;
    function GetEnumerator : TFhirImmunizationPractitionerListEnumerator;

    //  Add a FhirImmunizationPractitioner to the end of the list.
    function Append : TFhirImmunizationPractitioner;

    // Add an already existing FhirImmunizationPractitioner to the end of the list.
    procedure AddItem(value : TFhirImmunizationPractitioner); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImmunizationPractitioner) : Integer;

    // Insert FhirImmunizationPractitioner before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImmunizationPractitioner;

    // Insert an existing FhirImmunizationPractitioner before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImmunizationPractitioner);

    // Get the iIndexth FhirImmunizationPractitioner. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationPractitioner);

    // The number of items in the collection
    function Item(index : Integer) : TFhirImmunizationPractitioner;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirImmunizationPractitioners[index : Integer] : TFhirImmunizationPractitioner read GetItemN write SetItemN; default;
  End;

  // Reasons why a vaccine was or was not administered.
  TFhirImmunizationExplanation = class (TFhirBackboneElement)
  protected
    FreasonList : TFhirCodeableConceptList;
    FreasonNotGivenList : TFhirCodeableConceptList;
    function GetReasonList : TFhirCodeableConceptList;
    function GetHasReasonList : Boolean;
    function GetReasonNotGivenList : TFhirCodeableConceptList;
    function GetHasReasonNotGivenList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImmunizationExplanation; overload;
    function Clone : TFhirImmunizationExplanation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Reasons why a vaccine was administered.
    property reasonList : TFhirCodeableConceptList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // Reason why a vaccine was not administered.
    property reasonNotGivenList : TFhirCodeableConceptList read GetReasonNotGivenList;
    property hasReasonNotGivenList : boolean read GetHasReasonNotGivenList;

  end;

  TFhirImmunizationExplanationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImmunizationExplanationList;
    function GetCurrent : TFhirImmunizationExplanation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImmunizationExplanationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImmunizationExplanation read GetCurrent;
  end;

  TFhirImmunizationExplanationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImmunizationExplanation;
    procedure SetItemN(index : Integer; value : TFhirImmunizationExplanation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImmunizationExplanationList; Overload;
    function Clone : TFhirImmunizationExplanationList; Overload;
    function GetEnumerator : TFhirImmunizationExplanationListEnumerator;

    //  Add a FhirImmunizationExplanation to the end of the list.
    function Append : TFhirImmunizationExplanation;

    // Add an already existing FhirImmunizationExplanation to the end of the list.
    procedure AddItem(value : TFhirImmunizationExplanation); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImmunizationExplanation) : Integer;

    // Insert FhirImmunizationExplanation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImmunizationExplanation;

    // Insert an existing FhirImmunizationExplanation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImmunizationExplanation);

    // Get the iIndexth FhirImmunizationExplanation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationExplanation);

    // The number of items in the collection
    function Item(index : Integer) : TFhirImmunizationExplanation;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirImmunizationExplanations[index : Integer] : TFhirImmunizationExplanation read GetItemN write SetItemN; default;
  End;

  // Categorical data indicating that an adverse event is associated in time to an immunization.
  TFhirImmunizationReaction = class (TFhirBackboneElement)
  protected
    FDate : TFhirDateTime;
    FDetail : TFhirReference{TFhirObservation};
    FReported : TFhirBoolean;
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetDetail(value : TFhirReference{TFhirObservation});
    Procedure SetReported(value : TFhirBoolean);
    Function GetReportedST : Boolean;
    Procedure SetReportedST(value : Boolean);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImmunizationReaction; overload;
    function Clone : TFhirImmunizationReaction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Date of reaction to the immunization.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Date of reaction to the immunization.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to Details of the reaction. (defined for API consistency)
    property detail : TFhirReference{TFhirObservation} read FDetail write SetDetail;
    // Details of the reaction.
    property detailElement : TFhirReference{TFhirObservation} read FDetail write SetDetail;

    // Typed access to Self-reported indicator.
    property reported : Boolean read GetReportedST write SetReportedST;
    // Self-reported indicator.
    property reportedElement : TFhirBoolean read FReported write SetReported;

  end;

  TFhirImmunizationReactionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImmunizationReactionList;
    function GetCurrent : TFhirImmunizationReaction;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImmunizationReactionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImmunizationReaction read GetCurrent;
  end;

  TFhirImmunizationReactionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImmunizationReaction;
    procedure SetItemN(index : Integer; value : TFhirImmunizationReaction);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImmunizationReactionList; Overload;
    function Clone : TFhirImmunizationReactionList; Overload;
    function GetEnumerator : TFhirImmunizationReactionListEnumerator;

    //  Add a FhirImmunizationReaction to the end of the list.
    function Append : TFhirImmunizationReaction;

    // Add an already existing FhirImmunizationReaction to the end of the list.
    procedure AddItem(value : TFhirImmunizationReaction); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImmunizationReaction) : Integer;

    // Insert FhirImmunizationReaction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImmunizationReaction;

    // Insert an existing FhirImmunizationReaction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImmunizationReaction);

    // Get the iIndexth FhirImmunizationReaction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationReaction);

    // The number of items in the collection
    function Item(index : Integer) : TFhirImmunizationReaction;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirImmunizationReactions[index : Integer] : TFhirImmunizationReaction read GetItemN write SetItemN; default;
  End;

  // Contains information about the protocol(s) under which the vaccine was administered.
  TFhirImmunizationVaccinationProtocol = class (TFhirBackboneElement)
  protected
    FDoseSequence : TFhirPositiveInt;
    FDescription : TFhirString;
    FAuthority : TFhirReference{TFhirOrganization};
    FSeries : TFhirString;
    FSeriesDoses : TFhirPositiveInt;
    FtargetDiseaseList : TFhirCodeableConceptList;
    FDoseStatus : TFhirCodeableConcept;
    FDoseStatusReason : TFhirCodeableConcept;
    Procedure SetDoseSequence(value : TFhirPositiveInt);
    Function GetDoseSequenceST : String;
    Procedure SetDoseSequenceST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetAuthority(value : TFhirReference{TFhirOrganization});
    Procedure SetSeries(value : TFhirString);
    Function GetSeriesST : String;
    Procedure SetSeriesST(value : String);
    Procedure SetSeriesDoses(value : TFhirPositiveInt);
    Function GetSeriesDosesST : String;
    Procedure SetSeriesDosesST(value : String);
    function GetTargetDiseaseList : TFhirCodeableConceptList;
    function GetHasTargetDiseaseList : Boolean;
    Procedure SetDoseStatus(value : TFhirCodeableConcept);
    Procedure SetDoseStatusReason(value : TFhirCodeableConcept);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImmunizationVaccinationProtocol; overload;
    function Clone : TFhirImmunizationVaccinationProtocol; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Nominal position in a series.
    property doseSequence : String read GetDoseSequenceST write SetDoseSequenceST;
    // Nominal position in a series.
    property doseSequenceElement : TFhirPositiveInt read FDoseSequence write SetDoseSequence;

    // Typed access to Contains the description about the protocol under which the vaccine was administered.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Contains the description about the protocol under which the vaccine was administered.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Indicates the authority who {$IFNDEF FPC}Published{$ENDIF} the protocol.  E.g. ACIP. (defined for API consistency)
    property authority : TFhirReference{TFhirOrganization} read FAuthority write SetAuthority;
    // Indicates the authority who {$IFNDEF FPC}Published{$ENDIF} the protocol.  E.g. ACIP.
    property authorityElement : TFhirReference{TFhirOrganization} read FAuthority write SetAuthority;

    // Typed access to One possible path to achieve presumed immunity against a disease - within the context of an authority.
    property series : String read GetSeriesST write SetSeriesST;
    // One possible path to achieve presumed immunity against a disease - within the context of an authority.
    property seriesElement : TFhirString read FSeries write SetSeries;

    // Typed access to The recommended number of doses to achieve immunity.
    property seriesDoses : String read GetSeriesDosesST write SetSeriesDosesST;
    // The recommended number of doses to achieve immunity.
    property seriesDosesElement : TFhirPositiveInt read FSeriesDoses write SetSeriesDoses;

    // The targeted disease.
    property targetDiseaseList : TFhirCodeableConceptList read GetTargetDiseaseList;
    property hasTargetDiseaseList : boolean read GetHasTargetDiseaseList;

    // Typed access to Indicates if the immunization event should "count" against  the protocol. (defined for API consistency)
    property doseStatus : TFhirCodeableConcept read FDoseStatus write SetDoseStatus;
    // Indicates if the immunization event should "count" against  the protocol.
    property doseStatusElement : TFhirCodeableConcept read FDoseStatus write SetDoseStatus;

    // Typed access to Provides an explanation as to why an immunization event should or should not count against the protocol. (defined for API consistency)
    property doseStatusReason : TFhirCodeableConcept read FDoseStatusReason write SetDoseStatusReason;
    // Provides an explanation as to why an immunization event should or should not count against the protocol.
    property doseStatusReasonElement : TFhirCodeableConcept read FDoseStatusReason write SetDoseStatusReason;

  end;

  TFhirImmunizationVaccinationProtocolListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImmunizationVaccinationProtocolList;
    function GetCurrent : TFhirImmunizationVaccinationProtocol;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImmunizationVaccinationProtocolList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImmunizationVaccinationProtocol read GetCurrent;
  end;

  TFhirImmunizationVaccinationProtocolList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImmunizationVaccinationProtocol;
    procedure SetItemN(index : Integer; value : TFhirImmunizationVaccinationProtocol);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImmunizationVaccinationProtocolList; Overload;
    function Clone : TFhirImmunizationVaccinationProtocolList; Overload;
    function GetEnumerator : TFhirImmunizationVaccinationProtocolListEnumerator;

    //  Add a FhirImmunizationVaccinationProtocol to the end of the list.
    function Append : TFhirImmunizationVaccinationProtocol;

    // Add an already existing FhirImmunizationVaccinationProtocol to the end of the list.
    procedure AddItem(value : TFhirImmunizationVaccinationProtocol); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImmunizationVaccinationProtocol) : Integer;

    // Insert FhirImmunizationVaccinationProtocol before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImmunizationVaccinationProtocol;

    // Insert an existing FhirImmunizationVaccinationProtocol before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImmunizationVaccinationProtocol);

    // Get the iIndexth FhirImmunizationVaccinationProtocol. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationVaccinationProtocol);

    // The number of items in the collection
    function Item(index : Integer) : TFhirImmunizationVaccinationProtocol;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirImmunizationVaccinationProtocols[index : Integer] : TFhirImmunizationVaccinationProtocol read GetItemN write SetItemN; default;
  End;

  // Describes the event of a patient being administered a vaccination or a record of a vaccination as reported by a patient, a clinician or another party and may include vaccine reaction information and what vaccination protocol was followed.
  TFhirImmunization = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FNotGiven : TFhirBoolean;
    FVaccineCode : TFhirCodeableConcept;
    FPatient : TFhirReference{TFhirPatient};
    FEncounter : TFhirReference{TFhirEncounter};
    FDate : TFhirDateTime;
    FPrimarySource : TFhirBoolean;
    FReportOrigin : TFhirCodeableConcept;
    FLocation : TFhirReference{TFhirLocation};
    FManufacturer : TFhirReference{TFhirOrganization};
    FLotNumber : TFhirString;
    FExpirationDate : TFhirDate;
    FSite : TFhirCodeableConcept;
    FRoute : TFhirCodeableConcept;
    FDoseQuantity : TFhirQuantity;
    FpractitionerList : TFhirImmunizationPractitionerList;
    FnoteList : TFhirAnnotationList;
    FExplanation : TFhirImmunizationExplanation;
    FreactionList : TFhirImmunizationReactionList;
    FvaccinationProtocolList : TFhirImmunizationVaccinationProtocolList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirImmunizationStatusEnum;
    Procedure SetStatusST(value : TFhirImmunizationStatusEnum);
    Procedure SetNotGiven(value : TFhirBoolean);
    Function GetNotGivenST : Boolean;
    Procedure SetNotGivenST(value : Boolean);
    Procedure SetVaccineCode(value : TFhirCodeableConcept);
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    Procedure SetEncounter(value : TFhirReference{TFhirEncounter});
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetPrimarySource(value : TFhirBoolean);
    Function GetPrimarySourceST : Boolean;
    Procedure SetPrimarySourceST(value : Boolean);
    Procedure SetReportOrigin(value : TFhirCodeableConcept);
    Procedure SetLocation(value : TFhirReference{TFhirLocation});
    Procedure SetManufacturer(value : TFhirReference{TFhirOrganization});
    Procedure SetLotNumber(value : TFhirString);
    Function GetLotNumberST : String;
    Procedure SetLotNumberST(value : String);
    Procedure SetExpirationDate(value : TFhirDate);
    Function GetExpirationDateST : TFslDateTime;
    Procedure SetExpirationDateST(value : TFslDateTime);
    Procedure SetSite(value : TFhirCodeableConcept);
    Procedure SetRoute(value : TFhirCodeableConcept);
    Procedure SetDoseQuantity(value : TFhirQuantity);
    function GetPractitionerList : TFhirImmunizationPractitionerList;
    function GetHasPractitionerList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    Procedure SetExplanation(value : TFhirImmunizationExplanation);
    function GetReactionList : TFhirImmunizationReactionList;
    function GetHasReactionList : Boolean;
    function GetVaccinationProtocolList : TFhirImmunizationVaccinationProtocolList;
    function GetHasVaccinationProtocolList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImmunization; overload;
    function Clone : TFhirImmunization; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // A unique identifier assigned to this immunization record.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Indicates the current status of the vaccination event.
    property status : TFhirImmunizationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Indicates if the vaccination was or was not given.
    property notGiven : Boolean read GetNotGivenST write SetNotGivenST;
    // Indicates if the vaccination was or was not given.
    property notGivenElement : TFhirBoolean read FNotGiven write SetNotGiven;

    // Typed access to Vaccine that was administered or was to be administered. (defined for API consistency)
    property vaccineCode : TFhirCodeableConcept read FVaccineCode write SetVaccineCode;
    // Vaccine that was administered or was to be administered.
    property vaccineCodeElement : TFhirCodeableConcept read FVaccineCode write SetVaccineCode;

    // Typed access to The patient who either received or did not receive the immunization. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // The patient who either received or did not receive the immunization.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Typed access to The visit or admission or other contact between patient and health care provider the immunization was performed as part of. (defined for API consistency)
    property encounter : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;
    // The visit or admission or other contact between patient and health care provider the immunization was performed as part of.
    property encounterElement : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;

    // Typed access to Date vaccine administered or was to be administered.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Date vaccine administered or was to be administered.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to An indication that the content of the record is based on information from the person who administered the vaccine. This reflects the context under which the data was originally recorded.
    property primarySource : Boolean read GetPrimarySourceST write SetPrimarySourceST;
    // An indication that the content of the record is based on information from the person who administered the vaccine. This reflects the context under which the data was originally recorded.
    property primarySourceElement : TFhirBoolean read FPrimarySource write SetPrimarySource;

    // Typed access to The source of the data when the report of the immunization event is not based on information from the person who administered the vaccine. (defined for API consistency)
    property reportOrigin : TFhirCodeableConcept read FReportOrigin write SetReportOrigin;
    // The source of the data when the report of the immunization event is not based on information from the person who administered the vaccine.
    property reportOriginElement : TFhirCodeableConcept read FReportOrigin write SetReportOrigin;

    // Typed access to The service delivery location where the vaccine administration occurred. (defined for API consistency)
    property location : TFhirReference{TFhirLocation} read FLocation write SetLocation;
    // The service delivery location where the vaccine administration occurred.
    property locationElement : TFhirReference{TFhirLocation} read FLocation write SetLocation;

    // Typed access to Name of vaccine manufacturer. (defined for API consistency)
    property manufacturer : TFhirReference{TFhirOrganization} read FManufacturer write SetManufacturer;
    // Name of vaccine manufacturer.
    property manufacturerElement : TFhirReference{TFhirOrganization} read FManufacturer write SetManufacturer;

    // Typed access to Lot number of the  vaccine product.
    property lotNumber : String read GetLotNumberST write SetLotNumberST;
    // Lot number of the  vaccine product.
    property lotNumberElement : TFhirString read FLotNumber write SetLotNumber;

    // Typed access to Date vaccine batch expires.
    property expirationDate : TFslDateTime read GetExpirationDateST write SetExpirationDateST;
    // Date vaccine batch expires.
    property expirationDateElement : TFhirDate read FExpirationDate write SetExpirationDate;

    // Typed access to Body site where vaccine was administered. (defined for API consistency)
    property site : TFhirCodeableConcept read FSite write SetSite;
    // Body site where vaccine was administered.
    property siteElement : TFhirCodeableConcept read FSite write SetSite;

    // Typed access to The path by which the vaccine product is taken into the body. (defined for API consistency)
    property route : TFhirCodeableConcept read FRoute write SetRoute;
    // The path by which the vaccine product is taken into the body.
    property routeElement : TFhirCodeableConcept read FRoute write SetRoute;

    // Typed access to The quantity of vaccine product that was administered. (defined for API consistency)
    property doseQuantity : TFhirQuantity read FDoseQuantity write SetDoseQuantity;
    // The quantity of vaccine product that was administered.
    property doseQuantityElement : TFhirQuantity read FDoseQuantity write SetDoseQuantity;

    // Indicates who or what performed the event.
    property practitionerList : TFhirImmunizationPractitionerList read GetPractitionerList;
    property hasPractitionerList : boolean read GetHasPractitionerList;

    // Extra information about the immunization that is not conveyed by the other attributes.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Typed access to Reasons why a vaccine was or was not administered. (defined for API consistency)
    property explanation : TFhirImmunizationExplanation read FExplanation write SetExplanation;
    // Reasons why a vaccine was or was not administered.
    property explanationElement : TFhirImmunizationExplanation read FExplanation write SetExplanation;

    // Categorical data indicating that an adverse event is associated in time to an immunization.
    property reactionList : TFhirImmunizationReactionList read GetReactionList;
    property hasReactionList : boolean read GetHasReactionList;

    // Contains information about the protocol(s) under which the vaccine was administered.
    property vaccinationProtocolList : TFhirImmunizationVaccinationProtocolList read GetVaccinationProtocolList;
    property hasVaccinationProtocolList : boolean read GetHasVaccinationProtocolList;

  end;

  TFhirImmunizationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImmunizationList;
    function GetCurrent : TFhirImmunization;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImmunizationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImmunization read GetCurrent;
  end;

  TFhirImmunizationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImmunization;
    procedure SetItemN(index : Integer; value : TFhirImmunization);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImmunizationList; Overload;
    function Clone : TFhirImmunizationList; Overload;
    function GetEnumerator : TFhirImmunizationListEnumerator;

    //  Add a FhirImmunization to the end of the list.
    function Append : TFhirImmunization;

    // Add an already existing FhirImmunization to the end of the list.
    procedure AddItem(value : TFhirImmunization); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImmunization) : Integer;

    // Insert FhirImmunization before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImmunization;

    // Insert an existing FhirImmunization before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImmunization);

    // Get the iIndexth FhirImmunization. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImmunization);

    // The number of items in the collection
    function Item(index : Integer) : TFhirImmunization;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirImmunizations[index : Integer] : TFhirImmunization read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_IMMUNIZATION}

{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}

  // Vaccine administration recommendations.
  TFhirImmunizationRecommendationRecommendation = class (TFhirBackboneElement)
  protected
    FDate : TFhirDateTime;
    FVaccineCode : TFhirCodeableConcept;
    FTargetDisease : TFhirCodeableConcept;
    FDoseNumber : TFhirPositiveInt;
    FForecastStatus : TFhirCodeableConcept;
    FdateCriterionList : TFhirImmunizationRecommendationRecommendationDateCriterionList;
    FProtocol : TFhirImmunizationRecommendationRecommendationProtocol;
    FsupportingImmunizationList : TFhirReferenceList{TFhirImmunization};
    FsupportingPatientInformationList : TFhirReferenceList{Resource};
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetVaccineCode(value : TFhirCodeableConcept);
    Procedure SetTargetDisease(value : TFhirCodeableConcept);
    Procedure SetDoseNumber(value : TFhirPositiveInt);
    Function GetDoseNumberST : String;
    Procedure SetDoseNumberST(value : String);
    Procedure SetForecastStatus(value : TFhirCodeableConcept);
    function GetDateCriterionList : TFhirImmunizationRecommendationRecommendationDateCriterionList;
    function GetHasDateCriterionList : Boolean;
    Procedure SetProtocol(value : TFhirImmunizationRecommendationRecommendationProtocol);
    function GetSupportingImmunizationList : TFhirReferenceList{TFhirImmunization};
    function GetHasSupportingImmunizationList : Boolean;
    function GetSupportingPatientInformationList : TFhirReferenceList{Resource};
    function GetHasSupportingPatientInformationList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImmunizationRecommendationRecommendation; overload;
    function Clone : TFhirImmunizationRecommendationRecommendation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The date the immunization recommendation was created.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date the immunization recommendation was created.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to Vaccine that pertains to the recommendation. (defined for API consistency)
    property vaccineCode : TFhirCodeableConcept read FVaccineCode write SetVaccineCode;
    // Vaccine that pertains to the recommendation.
    property vaccineCodeElement : TFhirCodeableConcept read FVaccineCode write SetVaccineCode;

    // Typed access to The targeted disease for the recommendation. (defined for API consistency)
    property targetDisease : TFhirCodeableConcept read FTargetDisease write SetTargetDisease;
    // The targeted disease for the recommendation.
    property targetDiseaseElement : TFhirCodeableConcept read FTargetDisease write SetTargetDisease;

    // Typed access to The next recommended dose number (e.g. dose 2 is the next recommended dose).
    property doseNumber : String read GetDoseNumberST write SetDoseNumberST;
    // The next recommended dose number (e.g. dose 2 is the next recommended dose).
    property doseNumberElement : TFhirPositiveInt read FDoseNumber write SetDoseNumber;

    // Typed access to Vaccine administration status. (defined for API consistency)
    property forecastStatus : TFhirCodeableConcept read FForecastStatus write SetForecastStatus;
    // Vaccine administration status.
    property forecastStatusElement : TFhirCodeableConcept read FForecastStatus write SetForecastStatus;

    // Vaccine date recommendations.  For example, earliest date to administer, latest date to administer, etc.
    property dateCriterionList : TFhirImmunizationRecommendationRecommendationDateCriterionList read GetDateCriterionList;
    property hasDateCriterionList : boolean read GetHasDateCriterionList;

    // Typed access to Contains information about the protocol under which the vaccine was administered. (defined for API consistency)
    property protocol : TFhirImmunizationRecommendationRecommendationProtocol read FProtocol write SetProtocol;
    // Contains information about the protocol under which the vaccine was administered.
    property protocolElement : TFhirImmunizationRecommendationRecommendationProtocol read FProtocol write SetProtocol;

    // Immunization event history that supports the status and recommendation.
    property supportingImmunizationList : TFhirReferenceList{TFhirImmunization} read GetSupportingImmunizationList;
    property hasSupportingImmunizationList : boolean read GetHasSupportingImmunizationList;

    // Patient Information that supports the status and recommendation.  This includes patient observations, adverse reactions and allergy/intolerance information.
    property supportingPatientInformationList : TFhirReferenceList{Resource} read GetSupportingPatientInformationList;
    property hasSupportingPatientInformationList : boolean read GetHasSupportingPatientInformationList;

  end;

  TFhirImmunizationRecommendationRecommendationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImmunizationRecommendationRecommendationList;
    function GetCurrent : TFhirImmunizationRecommendationRecommendation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImmunizationRecommendationRecommendationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImmunizationRecommendationRecommendation read GetCurrent;
  end;

  TFhirImmunizationRecommendationRecommendationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImmunizationRecommendationRecommendation;
    procedure SetItemN(index : Integer; value : TFhirImmunizationRecommendationRecommendation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImmunizationRecommendationRecommendationList; Overload;
    function Clone : TFhirImmunizationRecommendationRecommendationList; Overload;
    function GetEnumerator : TFhirImmunizationRecommendationRecommendationListEnumerator;

    //  Add a FhirImmunizationRecommendationRecommendation to the end of the list.
    function Append : TFhirImmunizationRecommendationRecommendation;

    // Add an already existing FhirImmunizationRecommendationRecommendation to the end of the list.
    procedure AddItem(value : TFhirImmunizationRecommendationRecommendation); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImmunizationRecommendationRecommendation) : Integer;

    // Insert FhirImmunizationRecommendationRecommendation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImmunizationRecommendationRecommendation;

    // Insert an existing FhirImmunizationRecommendationRecommendation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImmunizationRecommendationRecommendation);

    // Get the iIndexth FhirImmunizationRecommendationRecommendation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationRecommendationRecommendation);

    // The number of items in the collection
    function Item(index : Integer) : TFhirImmunizationRecommendationRecommendation;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirImmunizationRecommendationRecommendations[index : Integer] : TFhirImmunizationRecommendationRecommendation read GetItemN write SetItemN; default;
  End;

  // Vaccine date recommendations.  For example, earliest date to administer, latest date to administer, etc.
  TFhirImmunizationRecommendationRecommendationDateCriterion = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FValue : TFhirDateTime;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetValue(value : TFhirDateTime);
    Function GetValueST : TFslDateTime;
    Procedure SetValueST(value : TFslDateTime);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImmunizationRecommendationRecommendationDateCriterion; overload;
    function Clone : TFhirImmunizationRecommendationRecommendationDateCriterion; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Date classification of recommendation.  For example, earliest date to give, latest date to give, etc. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Date classification of recommendation.  For example, earliest date to give, latest date to give, etc.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The date whose meaning is specified by dateCriterion.code.
    property value : TFslDateTime read GetValueST write SetValueST;
    // The date whose meaning is specified by dateCriterion.code.
    property valueElement : TFhirDateTime read FValue write SetValue;

  end;

  TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImmunizationRecommendationRecommendationDateCriterionList;
    function GetCurrent : TFhirImmunizationRecommendationRecommendationDateCriterion;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImmunizationRecommendationRecommendationDateCriterionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImmunizationRecommendationRecommendationDateCriterion read GetCurrent;
  end;

  TFhirImmunizationRecommendationRecommendationDateCriterionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImmunizationRecommendationRecommendationDateCriterion;
    procedure SetItemN(index : Integer; value : TFhirImmunizationRecommendationRecommendationDateCriterion);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImmunizationRecommendationRecommendationDateCriterionList; Overload;
    function Clone : TFhirImmunizationRecommendationRecommendationDateCriterionList; Overload;
    function GetEnumerator : TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator;

    //  Add a FhirImmunizationRecommendationRecommendationDateCriterion to the end of the list.
    function Append : TFhirImmunizationRecommendationRecommendationDateCriterion;

    // Add an already existing FhirImmunizationRecommendationRecommendationDateCriterion to the end of the list.
    procedure AddItem(value : TFhirImmunizationRecommendationRecommendationDateCriterion); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImmunizationRecommendationRecommendationDateCriterion) : Integer;

    // Insert FhirImmunizationRecommendationRecommendationDateCriterion before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImmunizationRecommendationRecommendationDateCriterion;

    // Insert an existing FhirImmunizationRecommendationRecommendationDateCriterion before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImmunizationRecommendationRecommendationDateCriterion);

    // Get the iIndexth FhirImmunizationRecommendationRecommendationDateCriterion. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationRecommendationRecommendationDateCriterion);

    // The number of items in the collection
    function Item(index : Integer) : TFhirImmunizationRecommendationRecommendationDateCriterion;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirImmunizationRecommendationRecommendationDateCriterions[index : Integer] : TFhirImmunizationRecommendationRecommendationDateCriterion read GetItemN write SetItemN; default;
  End;

  // Contains information about the protocol under which the vaccine was administered.
  TFhirImmunizationRecommendationRecommendationProtocol = class (TFhirBackboneElement)
  protected
    FDoseSequence : TFhirPositiveInt;
    FDescription : TFhirString;
    FAuthority : TFhirReference{TFhirOrganization};
    FSeries : TFhirString;
    Procedure SetDoseSequence(value : TFhirPositiveInt);
    Function GetDoseSequenceST : String;
    Procedure SetDoseSequenceST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetAuthority(value : TFhirReference{TFhirOrganization});
    Procedure SetSeries(value : TFhirString);
    Function GetSeriesST : String;
    Procedure SetSeriesST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImmunizationRecommendationRecommendationProtocol; overload;
    function Clone : TFhirImmunizationRecommendationRecommendationProtocol; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Indicates the nominal position in a series of the next dose.  This is the recommended dose number as per a specified protocol.
    property doseSequence : String read GetDoseSequenceST write SetDoseSequenceST;
    // Indicates the nominal position in a series of the next dose.  This is the recommended dose number as per a specified protocol.
    property doseSequenceElement : TFhirPositiveInt read FDoseSequence write SetDoseSequence;

    // Typed access to Contains the description about the protocol under which the vaccine was administered.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Contains the description about the protocol under which the vaccine was administered.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Indicates the authority who {$IFNDEF FPC}Published{$ENDIF} the protocol.  For example, ACIP. (defined for API consistency)
    property authority : TFhirReference{TFhirOrganization} read FAuthority write SetAuthority;
    // Indicates the authority who {$IFNDEF FPC}Published{$ENDIF} the protocol.  For example, ACIP.
    property authorityElement : TFhirReference{TFhirOrganization} read FAuthority write SetAuthority;

    // Typed access to One possible path to achieve presumed immunity against a disease - within the context of an authority.
    property series : String read GetSeriesST write SetSeriesST;
    // One possible path to achieve presumed immunity against a disease - within the context of an authority.
    property seriesElement : TFhirString read FSeries write SetSeries;

  end;

  TFhirImmunizationRecommendationRecommendationProtocolListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImmunizationRecommendationRecommendationProtocolList;
    function GetCurrent : TFhirImmunizationRecommendationRecommendationProtocol;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImmunizationRecommendationRecommendationProtocolList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImmunizationRecommendationRecommendationProtocol read GetCurrent;
  end;

  TFhirImmunizationRecommendationRecommendationProtocolList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImmunizationRecommendationRecommendationProtocol;
    procedure SetItemN(index : Integer; value : TFhirImmunizationRecommendationRecommendationProtocol);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImmunizationRecommendationRecommendationProtocolList; Overload;
    function Clone : TFhirImmunizationRecommendationRecommendationProtocolList; Overload;
    function GetEnumerator : TFhirImmunizationRecommendationRecommendationProtocolListEnumerator;

    //  Add a FhirImmunizationRecommendationRecommendationProtocol to the end of the list.
    function Append : TFhirImmunizationRecommendationRecommendationProtocol;

    // Add an already existing FhirImmunizationRecommendationRecommendationProtocol to the end of the list.
    procedure AddItem(value : TFhirImmunizationRecommendationRecommendationProtocol); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImmunizationRecommendationRecommendationProtocol) : Integer;

    // Insert FhirImmunizationRecommendationRecommendationProtocol before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImmunizationRecommendationRecommendationProtocol;

    // Insert an existing FhirImmunizationRecommendationRecommendationProtocol before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImmunizationRecommendationRecommendationProtocol);

    // Get the iIndexth FhirImmunizationRecommendationRecommendationProtocol. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationRecommendationRecommendationProtocol);

    // The number of items in the collection
    function Item(index : Integer) : TFhirImmunizationRecommendationRecommendationProtocol;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirImmunizationRecommendationRecommendationProtocols[index : Integer] : TFhirImmunizationRecommendationRecommendationProtocol read GetItemN write SetItemN; default;
  End;

  // A patient's point-in-time immunization and recommendation (i.e. forecasting a patient's immunization eligibility according to a {$IFNDEF FPC}Published{$ENDIF} schedule) with optional supporting justification.
  TFhirImmunizationRecommendation = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FPatient : TFhirReference{TFhirPatient};
    FrecommendationList : TFhirImmunizationRecommendationRecommendationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    function GetRecommendationList : TFhirImmunizationRecommendationRecommendationList;
    function GetHasRecommendationList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImmunizationRecommendation; overload;
    function Clone : TFhirImmunizationRecommendation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // A unique identifier assigned to this particular recommendation record.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The patient the recommendations are for. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // The patient the recommendations are for.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Vaccine administration recommendations.
    property recommendationList : TFhirImmunizationRecommendationRecommendationList read GetRecommendationList;
    property hasRecommendationList : boolean read GetHasRecommendationList;

  end;

  TFhirImmunizationRecommendationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImmunizationRecommendationList;
    function GetCurrent : TFhirImmunizationRecommendation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImmunizationRecommendationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImmunizationRecommendation read GetCurrent;
  end;

  TFhirImmunizationRecommendationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImmunizationRecommendation;
    procedure SetItemN(index : Integer; value : TFhirImmunizationRecommendation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImmunizationRecommendationList; Overload;
    function Clone : TFhirImmunizationRecommendationList; Overload;
    function GetEnumerator : TFhirImmunizationRecommendationListEnumerator;

    //  Add a FhirImmunizationRecommendation to the end of the list.
    function Append : TFhirImmunizationRecommendation;

    // Add an already existing FhirImmunizationRecommendation to the end of the list.
    procedure AddItem(value : TFhirImmunizationRecommendation); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImmunizationRecommendation) : Integer;

    // Insert FhirImmunizationRecommendation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImmunizationRecommendation;

    // Insert an existing FhirImmunizationRecommendation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImmunizationRecommendation);

    // Get the iIndexth FhirImmunizationRecommendation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationRecommendation);

    // The number of items in the collection
    function Item(index : Integer) : TFhirImmunizationRecommendation;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirImmunizationRecommendations[index : Integer] : TFhirImmunizationRecommendation read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}

{$IFDEF FHIR_MEDIA}

  // A photo, video, or audio recording acquired or used in healthcare. The actual content may be inline or provided by direct reference.
  TFhirMedia = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FbasedOnList : TFhirReferenceList{TFhirProcedureRequest};
    FType_ : TFhirEnum;
    FSubtype : TFhirCodeableConcept;
    FView : TFhirCodeableConcept;
    FSubject : TFhirReference{Resource};
    FContext : TFhirReference{Resource};
    FOccurrence : TFhirType;
    FOperator : TFhirReference{TFhirPractitioner};
    FreasonCodeList : TFhirCodeableConceptList;
    FBodySite : TFhirCodeableConcept;
    FDevice : TFhirReference{Resource};
    FHeight : TFhirPositiveInt;
    FWidth : TFhirPositiveInt;
    FFrames : TFhirPositiveInt;
    FDuration : TFhirUnsignedInt;
    FContent : TFhirAttachment;
    FnoteList : TFhirAnnotationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetBasedOnList : TFhirReferenceList{TFhirProcedureRequest};
    function GetHasBasedOnList : Boolean;
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirDigitalMediaTypeEnum;
    Procedure SetType_ST(value : TFhirDigitalMediaTypeEnum);
    Procedure SetSubtype(value : TFhirCodeableConcept);
    Procedure SetView(value : TFhirCodeableConcept);
    Procedure SetSubject(value : TFhirReference{Resource});
    Procedure SetContext(value : TFhirReference{Resource});
    Procedure SetOccurrence(value : TFhirType);
    Procedure SetOperator(value : TFhirReference{TFhirPractitioner});
    function GetReasonCodeList : TFhirCodeableConceptList;
    function GetHasReasonCodeList : Boolean;
    Procedure SetBodySite(value : TFhirCodeableConcept);
    Procedure SetDevice(value : TFhirReference{Resource});
    Procedure SetHeight(value : TFhirPositiveInt);
    Function GetHeightST : String;
    Procedure SetHeightST(value : String);
    Procedure SetWidth(value : TFhirPositiveInt);
    Function GetWidthST : String;
    Procedure SetWidthST(value : String);
    Procedure SetFrames(value : TFhirPositiveInt);
    Function GetFramesST : String;
    Procedure SetFramesST(value : String);
    Procedure SetDuration(value : TFhirUnsignedInt);
    Function GetDurationST : String;
    Procedure SetDurationST(value : String);
    Procedure SetContent(value : TFhirAttachment);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedia; overload;
    function Clone : TFhirMedia; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Identifiers associated with the image - these may include identifiers for the image itself, identifiers for the context of its collection (e.g. series ids) and context ids such as accession numbers or other workflow identifiers.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A procedure that is fulfilled in whole or in part by the creation of this media.
    property basedOnList : TFhirReferenceList{TFhirProcedureRequest} read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // Whether the media is a photo (still image), an audio recording, or a video recording.
    property type_ : TFhirDigitalMediaTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to Details of the type of the media - usually, how it was acquired (what type of device). If images sourced from a DICOM system, are wrapped in a Media resource, then this is the modality. (defined for API consistency)
    property subtype : TFhirCodeableConcept read FSubtype write SetSubtype;
    // Details of the type of the media - usually, how it was acquired (what type of device). If images sourced from a DICOM system, are wrapped in a Media resource, then this is the modality.
    property subtypeElement : TFhirCodeableConcept read FSubtype write SetSubtype;

    // Typed access to The name of the imaging view e.g. Lateral or Antero-posterior (AP). (defined for API consistency)
    property view : TFhirCodeableConcept read FView write SetView;
    // The name of the imaging view e.g. Lateral or Antero-posterior (AP).
    property viewElement : TFhirCodeableConcept read FView write SetView;

    // Typed access to Who/What this Media is a record of. (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // Who/What this Media is a record of.
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // Typed access to The encounter or episode of care that establishes the context for this media. (defined for API consistency)
    property context : TFhirReference{Resource} read FContext write SetContext;
    // The encounter or episode of care that establishes the context for this media.
    property contextElement : TFhirReference{Resource} read FContext write SetContext;

    // Typed access to The date and time(s) at which the media was collected. (defined for API consistency)
    property occurrence : TFhirType read FOccurrence write SetOccurrence;
    // The date and time(s) at which the media was collected.
    property occurrenceElement : TFhirType read FOccurrence write SetOccurrence;

    // Typed access to The person who administered the collection of the image. (defined for API consistency)
    property operator : TFhirReference{TFhirPractitioner} read FOperator write SetOperator;
    // The person who administered the collection of the image.
    property operatorElement : TFhirReference{TFhirPractitioner} read FOperator write SetOperator;

    // Describes why the event occurred in coded or textual form.
    property reasonCodeList : TFhirCodeableConceptList read GetReasonCodeList;
    property hasReasonCodeList : boolean read GetHasReasonCodeList;

    // Typed access to Indicates the site on the subject's body where the media was collected (i.e. the target site). (defined for API consistency)
    property bodySite : TFhirCodeableConcept read FBodySite write SetBodySite;
    // Indicates the site on the subject's body where the media was collected (i.e. the target site).
    property bodySiteElement : TFhirCodeableConcept read FBodySite write SetBodySite;

    // Typed access to The device used to collect the media. (defined for API consistency)
    property device : TFhirReference{Resource} read FDevice write SetDevice;
    // The device used to collect the media.
    property deviceElement : TFhirReference{Resource} read FDevice write SetDevice;

    // Typed access to Height of the image in pixels (photo/video).
    property height : String read GetHeightST write SetHeightST;
    // Height of the image in pixels (photo/video).
    property heightElement : TFhirPositiveInt read FHeight write SetHeight;

    // Typed access to Width of the image in pixels (photo/video).
    property width : String read GetWidthST write SetWidthST;
    // Width of the image in pixels (photo/video).
    property widthElement : TFhirPositiveInt read FWidth write SetWidth;

    // Typed access to The number of frames in a photo. This is used with a multi-page fax, or an imaging acquisition context that takes multiple slices in a single image, or an animated gif. If there is more than one frame, this SHALL have a value in order to alert interface software that a multi-frame capable rendering widget is required.
    property frames : String read GetFramesST write SetFramesST;
    // The number of frames in a photo. This is used with a multi-page fax, or an imaging acquisition context that takes multiple slices in a single image, or an animated gif. If there is more than one frame, this SHALL have a value in order to alert interface software that a multi-frame capable rendering widget is required.
    property framesElement : TFhirPositiveInt read FFrames write SetFrames;

    // Typed access to The duration of the recording in seconds - for audio and video.
    property duration : String read GetDurationST write SetDurationST;
    // The duration of the recording in seconds - for audio and video.
    property durationElement : TFhirUnsignedInt read FDuration write SetDuration;

    // Typed access to The actual content of the media - inline or by direct reference to the media source file. (defined for API consistency)
    property content : TFhirAttachment read FContent write SetContent;
    // The actual content of the media - inline or by direct reference to the media source file.
    property contentElement : TFhirAttachment read FContent write SetContent;

    // Comments made about the media by the performer, subject or other participants.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirMediaListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMediaList;
    function GetCurrent : TFhirMedia;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMediaList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedia read GetCurrent;
  end;

  TFhirMediaList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedia;
    procedure SetItemN(index : Integer; value : TFhirMedia);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMediaList; Overload;
    function Clone : TFhirMediaList; Overload;
    function GetEnumerator : TFhirMediaListEnumerator;

    //  Add a FhirMedia to the end of the list.
    function Append : TFhirMedia;

    // Add an already existing FhirMedia to the end of the list.
    procedure AddItem(value : TFhirMedia); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedia) : Integer;

    // Insert FhirMedia before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedia;

    // Insert an existing FhirMedia before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedia);

    // Get the iIndexth FhirMedia. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedia);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMedia;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMedia[index : Integer] : TFhirMedia read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEDIA}

{$IFDEF FHIR_MEDICATIONADMINISTRATION}

  // The individual who was responsible for giving the medication to the patient.
  TFhirMedicationAdministrationPerformer = class (TFhirBackboneElement)
  protected
    FActor : TFhirReference{Resource};
    FOnBehalfOf : TFhirReference{TFhirOrganization};
    Procedure SetActor(value : TFhirReference{Resource});
    Procedure SetOnBehalfOf(value : TFhirReference{TFhirOrganization});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationAdministrationPerformer; overload;
    function Clone : TFhirMedicationAdministrationPerformer; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The device, practitioner, etc. who performed the action. (defined for API consistency)
    property actor : TFhirReference{Resource} read FActor write SetActor;
    // The device, practitioner, etc. who performed the action.
    property actorElement : TFhirReference{Resource} read FActor write SetActor;

    // Typed access to The organization the device or practitioner was acting on behalf of. (defined for API consistency)
    property onBehalfOf : TFhirReference{TFhirOrganization} read FOnBehalfOf write SetOnBehalfOf;
    // The organization the device or practitioner was acting on behalf of.
    property onBehalfOfElement : TFhirReference{TFhirOrganization} read FOnBehalfOf write SetOnBehalfOf;

  end;

  TFhirMedicationAdministrationPerformerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationAdministrationPerformerList;
    function GetCurrent : TFhirMedicationAdministrationPerformer;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationAdministrationPerformerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationAdministrationPerformer read GetCurrent;
  end;

  TFhirMedicationAdministrationPerformerList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationAdministrationPerformer;
    procedure SetItemN(index : Integer; value : TFhirMedicationAdministrationPerformer);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationAdministrationPerformerList; Overload;
    function Clone : TFhirMedicationAdministrationPerformerList; Overload;
    function GetEnumerator : TFhirMedicationAdministrationPerformerListEnumerator;

    //  Add a FhirMedicationAdministrationPerformer to the end of the list.
    function Append : TFhirMedicationAdministrationPerformer;

    // Add an already existing FhirMedicationAdministrationPerformer to the end of the list.
    procedure AddItem(value : TFhirMedicationAdministrationPerformer); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationAdministrationPerformer) : Integer;

    // Insert FhirMedicationAdministrationPerformer before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationAdministrationPerformer;

    // Insert an existing FhirMedicationAdministrationPerformer before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationAdministrationPerformer);

    // Get the iIndexth FhirMedicationAdministrationPerformer. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationAdministrationPerformer);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationAdministrationPerformer;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMedicationAdministrationPerformers[index : Integer] : TFhirMedicationAdministrationPerformer read GetItemN write SetItemN; default;
  End;

  // Describes the medication dosage information details e.g. dose, rate, site, route, etc.
  TFhirMedicationAdministrationDosage = class (TFhirBackboneElement)
  protected
    FText : TFhirString;
    FSite : TFhirCodeableConcept;
    FRoute : TFhirCodeableConcept;
    FMethod : TFhirCodeableConcept;
    FDose : TFhirQuantity;
    FRate : TFhirType;
    Procedure SetText(value : TFhirString);
    Function GetTextST : String;
    Procedure SetTextST(value : String);
    Procedure SetSite(value : TFhirCodeableConcept);
    Procedure SetRoute(value : TFhirCodeableConcept);
    Procedure SetMethod(value : TFhirCodeableConcept);
    Procedure SetDose(value : TFhirQuantity);
    Procedure SetRate(value : TFhirType);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationAdministrationDosage; overload;
    function Clone : TFhirMedicationAdministrationDosage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Free text dosage can be used for cases where the dosage administered is too complex to code. When coded dosage is present, the free text dosage may still be present for display to humans.  The dosage instructions should reflect the dosage of the medication that was administered.
    property text : String read GetTextST write SetTextST;
    // Free text dosage can be used for cases where the dosage administered is too complex to code. When coded dosage is present, the free text dosage may still be present for display to humans.  The dosage instructions should reflect the dosage of the medication that was administered.
    property textElement : TFhirString read FText write SetText;

    // Typed access to A coded specification of the anatomic site where the medication first entered the body.  For example, "left arm". (defined for API consistency)
    property site : TFhirCodeableConcept read FSite write SetSite;
    // A coded specification of the anatomic site where the medication first entered the body.  For example, "left arm".
    property siteElement : TFhirCodeableConcept read FSite write SetSite;

    // Typed access to A code specifying the route or physiological path of administration of a therapeutic agent into or onto the patient.  For example, topical, intravenous, etc. (defined for API consistency)
    property route : TFhirCodeableConcept read FRoute write SetRoute;
    // A code specifying the route or physiological path of administration of a therapeutic agent into or onto the patient.  For example, topical, intravenous, etc.
    property routeElement : TFhirCodeableConcept read FRoute write SetRoute;

    // Typed access to A coded value indicating the method by which the medication is intended to be or was introduced into or on the body.  This attribute will most often NOT be populated.  It is most commonly used for injections.  For example, Slow Push, Deep IV. (defined for API consistency)
    property method : TFhirCodeableConcept read FMethod write SetMethod;
    // A coded value indicating the method by which the medication is intended to be or was introduced into or on the body.  This attribute will most often NOT be populated.  It is most commonly used for injections.  For example, Slow Push, Deep IV.
    property methodElement : TFhirCodeableConcept read FMethod write SetMethod;

    // Typed access to The amount of the medication given at one administration event.   Use this value when the administration is essentially an instantaneous event such as a swallowing a tablet or giving an injection. (defined for API consistency)
    property dose : TFhirQuantity read FDose write SetDose;
    // The amount of the medication given at one administration event.   Use this value when the administration is essentially an instantaneous event such as a swallowing a tablet or giving an injection.
    property doseElement : TFhirQuantity read FDose write SetDose;

    // Typed access to Identifies the speed with which the medication was or will be introduced into the patient.  Typically the rate for an infusion e.g. 100 ml per 1 hour or 100 ml/hr.  May also be expressed as a rate per unit of time e.g. 500 ml per 2 hours.  Other examples:  200 mcg/min or 200 mcg/1 minute; 1 liter/8 hours. (defined for API consistency)
    property rate : TFhirType read FRate write SetRate;
    // Identifies the speed with which the medication was or will be introduced into the patient.  Typically the rate for an infusion e.g. 100 ml per 1 hour or 100 ml/hr.  May also be expressed as a rate per unit of time e.g. 500 ml per 2 hours.  Other examples:  200 mcg/min or 200 mcg/1 minute; 1 liter/8 hours.
    property rateElement : TFhirType read FRate write SetRate;

  end;

  TFhirMedicationAdministrationDosageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationAdministrationDosageList;
    function GetCurrent : TFhirMedicationAdministrationDosage;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationAdministrationDosageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationAdministrationDosage read GetCurrent;
  end;

  TFhirMedicationAdministrationDosageList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationAdministrationDosage;
    procedure SetItemN(index : Integer; value : TFhirMedicationAdministrationDosage);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationAdministrationDosageList; Overload;
    function Clone : TFhirMedicationAdministrationDosageList; Overload;
    function GetEnumerator : TFhirMedicationAdministrationDosageListEnumerator;

    //  Add a FhirMedicationAdministrationDosage to the end of the list.
    function Append : TFhirMedicationAdministrationDosage;

    // Add an already existing FhirMedicationAdministrationDosage to the end of the list.
    procedure AddItem(value : TFhirMedicationAdministrationDosage); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationAdministrationDosage) : Integer;

    // Insert FhirMedicationAdministrationDosage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationAdministrationDosage;

    // Insert an existing FhirMedicationAdministrationDosage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationAdministrationDosage);

    // Get the iIndexth FhirMedicationAdministrationDosage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationAdministrationDosage);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationAdministrationDosage;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMedicationAdministrationDosages[index : Integer] : TFhirMedicationAdministrationDosage read GetItemN write SetItemN; default;
  End;

  // Describes the event of a patient consuming or otherwise being administered a medication.  This may be as simple as swallowing a tablet or it may be a long running infusion.  Related resources tie this event to the authorizing prescription, and the specific encounter between patient and health care practitioner.
  TFhirMedicationAdministration = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FdefinitionList : TFhirReferenceList{Resource};
    FpartOfList : TFhirReferenceList{Resource};
    FStatus : TFhirEnum;
    FCategory : TFhirCodeableConcept;
    FMedication : TFhirType;
    FSubject : TFhirReference{Resource};
    FContext : TFhirReference{Resource};
    FsupportingInformationList : TFhirReferenceList{TFhirReference};
    FEffective : TFhirType;
    FperformerList : TFhirMedicationAdministrationPerformerList;
    FNotGiven : TFhirBoolean;
    FreasonNotGivenList : TFhirCodeableConceptList;
    FreasonCodeList : TFhirCodeableConceptList;
    FreasonReferenceList : TFhirReferenceList{Resource};
    FPrescription : TFhirReference{TFhirMedicationRequest};
    FdeviceList : TFhirReferenceList{TFhirDevice};
    FnoteList : TFhirAnnotationList;
    FDosage : TFhirMedicationAdministrationDosage;
    FeventHistoryList : TFhirReferenceList{TFhirProvenance};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetDefinitionList : TFhirReferenceList{Resource};
    function GetHasDefinitionList : Boolean;
    function GetPartOfList : TFhirReferenceList{Resource};
    function GetHasPartOfList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirMedicationAdminStatusEnum;
    Procedure SetStatusST(value : TFhirMedicationAdminStatusEnum);
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetMedication(value : TFhirType);
    Procedure SetSubject(value : TFhirReference{Resource});
    Procedure SetContext(value : TFhirReference{Resource});
    function GetSupportingInformationList : TFhirReferenceList{TFhirReference};
    function GetHasSupportingInformationList : Boolean;
    Procedure SetEffective(value : TFhirType);
    function GetPerformerList : TFhirMedicationAdministrationPerformerList;
    function GetHasPerformerList : Boolean;
    Procedure SetNotGiven(value : TFhirBoolean);
    Function GetNotGivenST : Boolean;
    Procedure SetNotGivenST(value : Boolean);
    function GetReasonNotGivenList : TFhirCodeableConceptList;
    function GetHasReasonNotGivenList : Boolean;
    function GetReasonCodeList : TFhirCodeableConceptList;
    function GetHasReasonCodeList : Boolean;
    function GetReasonReferenceList : TFhirReferenceList{Resource};
    function GetHasReasonReferenceList : Boolean;
    Procedure SetPrescription(value : TFhirReference{TFhirMedicationRequest});
    function GetDeviceList : TFhirReferenceList{TFhirDevice};
    function GetHasDeviceList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    Procedure SetDosage(value : TFhirMedicationAdministrationDosage);
    function GetEventHistoryList : TFhirReferenceList{TFhirProvenance};
    function GetHasEventHistoryList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationAdministration; overload;
    function Clone : TFhirMedicationAdministration; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // External identifier - FHIR will generate its own internal identifiers (probably URLs) which do not need to be explicitly managed by the resource.  The identifier here is one that would be used by another non-FHIR system - for example an automated medication pump would provide a record each time it operated; an administration while the patient was off the ward might be made with a different system and entered after the event.  Particularly important if these records have to be updated.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A protocol, guideline, orderset or other definition that was adhered to in whole or in part by this event.
    property definitionList : TFhirReferenceList{Resource} read GetDefinitionList;
    property hasDefinitionList : boolean read GetHasDefinitionList;

    // A larger event of which this particular event is a component or step.
    property partOfList : TFhirReferenceList{Resource} read GetPartOfList;
    property hasPartOfList : boolean read GetHasPartOfList;

    // Will generally be set to show that the administration has been completed.  For some long running administrations such as infusions it is possible for an administration to be started but not completed or it may be paused while some other process is under way.
    property status : TFhirMedicationAdminStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Indicates the type of medication administration and where the medication is expected to be consumed or administered. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Indicates the type of medication administration and where the medication is expected to be consumed or administered.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to Identifies the medication that was administered. This is either a link to a resource representing the details of the medication or a simple attribute carrying a code that identifies the medication from a known list of medications. (defined for API consistency)
    property medication : TFhirType read FMedication write SetMedication;
    // Identifies the medication that was administered. This is either a link to a resource representing the details of the medication or a simple attribute carrying a code that identifies the medication from a known list of medications.
    property medicationElement : TFhirType read FMedication write SetMedication;

    // Typed access to The person or animal or group receiving the medication. (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // The person or animal or group receiving the medication.
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // Typed access to The visit, admission or other contact between patient and health care provider the medication administration was performed as part of. (defined for API consistency)
    property context : TFhirReference{Resource} read FContext write SetContext;
    // The visit, admission or other contact between patient and health care provider the medication administration was performed as part of.
    property contextElement : TFhirReference{Resource} read FContext write SetContext;

    // Additional information (for example, patient height and weight) that supports the administration of the medication.
    property supportingInformationList : TFhirReferenceList{TFhirReference} read GetSupportingInformationList;
    property hasSupportingInformationList : boolean read GetHasSupportingInformationList;

    // Typed access to A specific date/time or interval of time during which the administration took place (or did not take place, when the 'notGiven' attribute is true). For many administrations, such as swallowing a tablet the use of dateTime is more appropriate. (defined for API consistency)
    property effective : TFhirType read FEffective write SetEffective;
    // A specific date/time or interval of time during which the administration took place (or did not take place, when the 'notGiven' attribute is true). For many administrations, such as swallowing a tablet the use of dateTime is more appropriate.
    property effectiveElement : TFhirType read FEffective write SetEffective;

    // The individual who was responsible for giving the medication to the patient.
    property performerList : TFhirMedicationAdministrationPerformerList read GetPerformerList;
    property hasPerformerList : boolean read GetHasPerformerList;

    // Typed access to Set this to true if the record is saying that the medication was NOT administered.
    property notGiven : Boolean read GetNotGivenST write SetNotGivenST;
    // Set this to true if the record is saying that the medication was NOT administered.
    property notGivenElement : TFhirBoolean read FNotGiven write SetNotGiven;

    // A code indicating why the administration was not performed.
    property reasonNotGivenList : TFhirCodeableConceptList read GetReasonNotGivenList;
    property hasReasonNotGivenList : boolean read GetHasReasonNotGivenList;

    // A code indicating why the medication was given.
    property reasonCodeList : TFhirCodeableConceptList read GetReasonCodeList;
    property hasReasonCodeList : boolean read GetHasReasonCodeList;

    // Condition or observation that supports why the medication was administered.
    property reasonReferenceList : TFhirReferenceList{Resource} read GetReasonReferenceList;
    property hasReasonReferenceList : boolean read GetHasReasonReferenceList;

    // Typed access to The original request, instruction or authority to perform the administration. (defined for API consistency)
    property prescription : TFhirReference{TFhirMedicationRequest} read FPrescription write SetPrescription;
    // The original request, instruction or authority to perform the administration.
    property prescriptionElement : TFhirReference{TFhirMedicationRequest} read FPrescription write SetPrescription;

    // The device used in administering the medication to the patient.  For example, a particular infusion pump.
    property deviceList : TFhirReferenceList{TFhirDevice} read GetDeviceList;
    property hasDeviceList : boolean read GetHasDeviceList;

    // Extra information about the medication administration that is not conveyed by the other attributes.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Typed access to Describes the medication dosage information details e.g. dose, rate, site, route, etc. (defined for API consistency)
    property dosage : TFhirMedicationAdministrationDosage read FDosage write SetDosage;
    // Describes the medication dosage information details e.g. dose, rate, site, route, etc.
    property dosageElement : TFhirMedicationAdministrationDosage read FDosage write SetDosage;

    // A summary of the events of interest that have occurred, such as when the administration was verified.
    property eventHistoryList : TFhirReferenceList{TFhirProvenance} read GetEventHistoryList;
    property hasEventHistoryList : boolean read GetHasEventHistoryList;

  end;

  TFhirMedicationAdministrationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationAdministrationList;
    function GetCurrent : TFhirMedicationAdministration;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationAdministrationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationAdministration read GetCurrent;
  end;

  TFhirMedicationAdministrationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationAdministration;
    procedure SetItemN(index : Integer; value : TFhirMedicationAdministration);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationAdministrationList; Overload;
    function Clone : TFhirMedicationAdministrationList; Overload;
    function GetEnumerator : TFhirMedicationAdministrationListEnumerator;

    //  Add a FhirMedicationAdministration to the end of the list.
    function Append : TFhirMedicationAdministration;

    // Add an already existing FhirMedicationAdministration to the end of the list.
    procedure AddItem(value : TFhirMedicationAdministration); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationAdministration) : Integer;

    // Insert FhirMedicationAdministration before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationAdministration;

    // Insert an existing FhirMedicationAdministration before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationAdministration);

    // Get the iIndexth FhirMedicationAdministration. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationAdministration);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationAdministration;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMedicationAdministrations[index : Integer] : TFhirMedicationAdministration read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEDICATIONADMINISTRATION}

{$IFDEF FHIR_MEDICATIONDISPENSE}

  // Indicates who or what performed the event.  It should be assumed that the performer is the dispenser of the medication.
  TFhirMedicationDispensePerformer = class (TFhirBackboneElement)
  protected
    FActor : TFhirReference{Resource};
    FOnBehalfOf : TFhirReference{TFhirOrganization};
    Procedure SetActor(value : TFhirReference{Resource});
    Procedure SetOnBehalfOf(value : TFhirReference{TFhirOrganization});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationDispensePerformer; overload;
    function Clone : TFhirMedicationDispensePerformer; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The device, practitioner, etc. who performed the action.  It should be assumed that the actor is the dispenser of the medication. (defined for API consistency)
    property actor : TFhirReference{Resource} read FActor write SetActor;
    // The device, practitioner, etc. who performed the action.  It should be assumed that the actor is the dispenser of the medication.
    property actorElement : TFhirReference{Resource} read FActor write SetActor;

    // Typed access to The organization the device or practitioner was acting on behalf of. (defined for API consistency)
    property onBehalfOf : TFhirReference{TFhirOrganization} read FOnBehalfOf write SetOnBehalfOf;
    // The organization the device or practitioner was acting on behalf of.
    property onBehalfOfElement : TFhirReference{TFhirOrganization} read FOnBehalfOf write SetOnBehalfOf;

  end;

  TFhirMedicationDispensePerformerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationDispensePerformerList;
    function GetCurrent : TFhirMedicationDispensePerformer;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationDispensePerformerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationDispensePerformer read GetCurrent;
  end;

  TFhirMedicationDispensePerformerList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationDispensePerformer;
    procedure SetItemN(index : Integer; value : TFhirMedicationDispensePerformer);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationDispensePerformerList; Overload;
    function Clone : TFhirMedicationDispensePerformerList; Overload;
    function GetEnumerator : TFhirMedicationDispensePerformerListEnumerator;

    //  Add a FhirMedicationDispensePerformer to the end of the list.
    function Append : TFhirMedicationDispensePerformer;

    // Add an already existing FhirMedicationDispensePerformer to the end of the list.
    procedure AddItem(value : TFhirMedicationDispensePerformer); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationDispensePerformer) : Integer;

    // Insert FhirMedicationDispensePerformer before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationDispensePerformer;

    // Insert an existing FhirMedicationDispensePerformer before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationDispensePerformer);

    // Get the iIndexth FhirMedicationDispensePerformer. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationDispensePerformer);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationDispensePerformer;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMedicationDispensePerformers[index : Integer] : TFhirMedicationDispensePerformer read GetItemN write SetItemN; default;
  End;

  // Indicates whether or not substitution was made as part of the dispense.  In some cases substitution will be expected but does not happen, in other cases substitution is not expected but does happen.  This block explains what substitution did or did not happen and why.  If nothing is specified, substitution was not done.
  TFhirMedicationDispenseSubstitution = class (TFhirBackboneElement)
  protected
    FWasSubstituted : TFhirBoolean;
    FType_ : TFhirCodeableConcept;
    FreasonList : TFhirCodeableConceptList;
    FresponsiblePartyList : TFhirReferenceList{TFhirPractitioner};
    Procedure SetWasSubstituted(value : TFhirBoolean);
    Function GetWasSubstitutedST : Boolean;
    Procedure SetWasSubstitutedST(value : Boolean);
    Procedure SetType_(value : TFhirCodeableConcept);
    function GetReasonList : TFhirCodeableConceptList;
    function GetHasReasonList : Boolean;
    function GetResponsiblePartyList : TFhirReferenceList{TFhirPractitioner};
    function GetHasResponsiblePartyList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationDispenseSubstitution; overload;
    function Clone : TFhirMedicationDispenseSubstitution; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to True if the dispenser dispensed a different drug or product from what was prescribed.
    property wasSubstituted : Boolean read GetWasSubstitutedST write SetWasSubstitutedST;
    // True if the dispenser dispensed a different drug or product from what was prescribed.
    property wasSubstitutedElement : TFhirBoolean read FWasSubstituted write SetWasSubstituted;

    // Typed access to A code signifying whether a different drug was dispensed from what was prescribed. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A code signifying whether a different drug was dispensed from what was prescribed.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Indicates the reason for the substitution of (or lack of substitution) from what was prescribed.
    property reasonList : TFhirCodeableConceptList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // The person or organization that has primary responsibility for the substitution.
    property responsiblePartyList : TFhirReferenceList{TFhirPractitioner} read GetResponsiblePartyList;
    property hasResponsiblePartyList : boolean read GetHasResponsiblePartyList;

  end;

  TFhirMedicationDispenseSubstitutionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationDispenseSubstitutionList;
    function GetCurrent : TFhirMedicationDispenseSubstitution;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationDispenseSubstitutionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationDispenseSubstitution read GetCurrent;
  end;

  TFhirMedicationDispenseSubstitutionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationDispenseSubstitution;
    procedure SetItemN(index : Integer; value : TFhirMedicationDispenseSubstitution);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationDispenseSubstitutionList; Overload;
    function Clone : TFhirMedicationDispenseSubstitutionList; Overload;
    function GetEnumerator : TFhirMedicationDispenseSubstitutionListEnumerator;

    //  Add a FhirMedicationDispenseSubstitution to the end of the list.
    function Append : TFhirMedicationDispenseSubstitution;

    // Add an already existing FhirMedicationDispenseSubstitution to the end of the list.
    procedure AddItem(value : TFhirMedicationDispenseSubstitution); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationDispenseSubstitution) : Integer;

    // Insert FhirMedicationDispenseSubstitution before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationDispenseSubstitution;

    // Insert an existing FhirMedicationDispenseSubstitution before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationDispenseSubstitution);

    // Get the iIndexth FhirMedicationDispenseSubstitution. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationDispenseSubstitution);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationDispenseSubstitution;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMedicationDispenseSubstitutions[index : Integer] : TFhirMedicationDispenseSubstitution read GetItemN write SetItemN; default;
  End;

  // Indicates that a medication product is to be or has been dispensed for a named person/patient.  This includes a description of the medication product (supply) provided and the instructions for administering the medication.  The medication dispense is the result of a pharmacy system responding to a medication order.
  TFhirMedicationDispense = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FpartOfList : TFhirReferenceList{TFhirProcedure};
    FStatus : TFhirEnum;
    FCategory : TFhirCodeableConcept;
    FMedication : TFhirType;
    FSubject : TFhirReference{Resource};
    FContext : TFhirReference{Resource};
    FsupportingInformationList : TFhirReferenceList{TFhirReference};
    FperformerList : TFhirMedicationDispensePerformerList;
    FauthorizingPrescriptionList : TFhirReferenceList{TFhirMedicationRequest};
    FType_ : TFhirCodeableConcept;
    FQuantity : TFhirQuantity;
    FDaysSupply : TFhirQuantity;
    FWhenPrepared : TFhirDateTime;
    FWhenHandedOver : TFhirDateTime;
    FDestination : TFhirReference{TFhirLocation};
    FreceiverList : TFhirReferenceList{Resource};
    FnoteList : TFhirAnnotationList;
    FdosageInstructionList : TFhirDosageList;
    FSubstitution : TFhirMedicationDispenseSubstitution;
    FdetectedIssueList : TFhirReferenceList{TFhirDetectedIssue};
    FNotDone : TFhirBoolean;
    FNotDoneReason : TFhirType;
    FeventHistoryList : TFhirReferenceList{TFhirProvenance};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetPartOfList : TFhirReferenceList{TFhirProcedure};
    function GetHasPartOfList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirMedicationDispenseStatusEnum;
    Procedure SetStatusST(value : TFhirMedicationDispenseStatusEnum);
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetMedication(value : TFhirType);
    Procedure SetSubject(value : TFhirReference{Resource});
    Procedure SetContext(value : TFhirReference{Resource});
    function GetSupportingInformationList : TFhirReferenceList{TFhirReference};
    function GetHasSupportingInformationList : Boolean;
    function GetPerformerList : TFhirMedicationDispensePerformerList;
    function GetHasPerformerList : Boolean;
    function GetAuthorizingPrescriptionList : TFhirReferenceList{TFhirMedicationRequest};
    function GetHasAuthorizingPrescriptionList : Boolean;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetDaysSupply(value : TFhirQuantity);
    Procedure SetWhenPrepared(value : TFhirDateTime);
    Function GetWhenPreparedST : TFslDateTime;
    Procedure SetWhenPreparedST(value : TFslDateTime);
    Procedure SetWhenHandedOver(value : TFhirDateTime);
    Function GetWhenHandedOverST : TFslDateTime;
    Procedure SetWhenHandedOverST(value : TFslDateTime);
    Procedure SetDestination(value : TFhirReference{TFhirLocation});
    function GetReceiverList : TFhirReferenceList{Resource};
    function GetHasReceiverList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetDosageInstructionList : TFhirDosageList;
    function GetHasDosageInstructionList : Boolean;
    Procedure SetSubstitution(value : TFhirMedicationDispenseSubstitution);
    function GetDetectedIssueList : TFhirReferenceList{TFhirDetectedIssue};
    function GetHasDetectedIssueList : Boolean;
    Procedure SetNotDone(value : TFhirBoolean);
    Function GetNotDoneST : Boolean;
    Procedure SetNotDoneST(value : Boolean);
    Procedure SetNotDoneReason(value : TFhirType);
    function GetEventHistoryList : TFhirReferenceList{TFhirProvenance};
    function GetHasEventHistoryList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationDispense; overload;
    function Clone : TFhirMedicationDispense; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Identifier assigned by the dispensing facility - this is an identifier assigned outside FHIR.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The procedure that the dispense is done because of.
    property partOfList : TFhirReferenceList{TFhirProcedure} read GetPartOfList;
    property hasPartOfList : boolean read GetHasPartOfList;

    // A code specifying the state of the set of dispense events.
    property status : TFhirMedicationDispenseStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Indicates type of medication dispense and where the medication is expected to be consumed or administered. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Indicates type of medication dispense and where the medication is expected to be consumed or administered.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to Identifies the medication being administered. This is either a link to a resource representing the details of the medication or a simple attribute carrying a code that identifies the medication from a known list of medications. (defined for API consistency)
    property medication : TFhirType read FMedication write SetMedication;
    // Identifies the medication being administered. This is either a link to a resource representing the details of the medication or a simple attribute carrying a code that identifies the medication from a known list of medications.
    property medicationElement : TFhirType read FMedication write SetMedication;

    // Typed access to A link to a resource representing the person or the group to whom the medication will be given. (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // A link to a resource representing the person or the group to whom the medication will be given.
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // Typed access to The encounter or episode of care that establishes the context for this event. (defined for API consistency)
    property context : TFhirReference{Resource} read FContext write SetContext;
    // The encounter or episode of care that establishes the context for this event.
    property contextElement : TFhirReference{Resource} read FContext write SetContext;

    // Additional information that supports the medication being dispensed.
    property supportingInformationList : TFhirReferenceList{TFhirReference} read GetSupportingInformationList;
    property hasSupportingInformationList : boolean read GetHasSupportingInformationList;

    // Indicates who or what performed the event.  It should be assumed that the performer is the dispenser of the medication.
    property performerList : TFhirMedicationDispensePerformerList read GetPerformerList;
    property hasPerformerList : boolean read GetHasPerformerList;

    // Indicates the medication order that is being dispensed against.
    property authorizingPrescriptionList : TFhirReferenceList{TFhirMedicationRequest} read GetAuthorizingPrescriptionList;
    property hasAuthorizingPrescriptionList : boolean read GetHasAuthorizingPrescriptionList;

    // Typed access to Indicates the type of dispensing event that is performed. For example, Trial Fill, Completion of Trial, Partial Fill, Emergency Fill, Samples, etc. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Indicates the type of dispensing event that is performed. For example, Trial Fill, Completion of Trial, Partial Fill, Emergency Fill, Samples, etc.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The amount of medication that has been dispensed. Includes unit of measure. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The amount of medication that has been dispensed. Includes unit of measure.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to The amount of medication expressed as a timing amount. (defined for API consistency)
    property daysSupply : TFhirQuantity read FDaysSupply write SetDaysSupply;
    // The amount of medication expressed as a timing amount.
    property daysSupplyElement : TFhirQuantity read FDaysSupply write SetDaysSupply;

    // Typed access to The time when the dispensed product was packaged and reviewed.
    property whenPrepared : TFslDateTime read GetWhenPreparedST write SetWhenPreparedST;
    // The time when the dispensed product was packaged and reviewed.
    property whenPreparedElement : TFhirDateTime read FWhenPrepared write SetWhenPrepared;

    // Typed access to The time the dispensed product was provided to the patient or their representative.
    property whenHandedOver : TFslDateTime read GetWhenHandedOverST write SetWhenHandedOverST;
    // The time the dispensed product was provided to the patient or their representative.
    property whenHandedOverElement : TFhirDateTime read FWhenHandedOver write SetWhenHandedOver;

    // Typed access to Identification of the facility/location where the medication was shipped to, as part of the dispense event. (defined for API consistency)
    property destination : TFhirReference{TFhirLocation} read FDestination write SetDestination;
    // Identification of the facility/location where the medication was shipped to, as part of the dispense event.
    property destinationElement : TFhirReference{TFhirLocation} read FDestination write SetDestination;

    // Identifies the person who picked up the medication.  This will usually be a patient or their caregiver, but some cases exist where it can be a healthcare professional.
    property receiverList : TFhirReferenceList{Resource} read GetReceiverList;
    property hasReceiverList : boolean read GetHasReceiverList;

    // Extra information about the dispense that could not be conveyed in the other attributes.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Indicates how the medication is to be used by the patient.
    property dosageInstructionList : TFhirDosageList read GetDosageInstructionList;
    property hasDosageInstructionList : boolean read GetHasDosageInstructionList;

    // Typed access to Indicates whether or not substitution was made as part of the dispense.  In some cases substitution will be expected but does not happen, in other cases substitution is not expected but does happen.  This block explains what substitution did or did not happen and why.  If nothing is specified, substitution was not done. (defined for API consistency)
    property substitution : TFhirMedicationDispenseSubstitution read FSubstitution write SetSubstitution;
    // Indicates whether or not substitution was made as part of the dispense.  In some cases substitution will be expected but does not happen, in other cases substitution is not expected but does happen.  This block explains what substitution did or did not happen and why.  If nothing is specified, substitution was not done.
    property substitutionElement : TFhirMedicationDispenseSubstitution read FSubstitution write SetSubstitution;

    // Indicates an actual or potential clinical issue with or between one or more active or proposed clinical actions for a patient; e.g. Drug-drug interaction, duplicate therapy, dosage alert etc.
    property detectedIssueList : TFhirReferenceList{TFhirDetectedIssue} read GetDetectedIssueList;
    property hasDetectedIssueList : boolean read GetHasDetectedIssueList;

    // Typed access to True if the dispense was not performed for some reason.
    property notDone : Boolean read GetNotDoneST write SetNotDoneST;
    // True if the dispense was not performed for some reason.
    property notDoneElement : TFhirBoolean read FNotDone write SetNotDone;

    // Typed access to Indicates the reason why a dispense was not performed. (defined for API consistency)
    property notDoneReason : TFhirType read FNotDoneReason write SetNotDoneReason;
    // Indicates the reason why a dispense was not performed.
    property notDoneReasonElement : TFhirType read FNotDoneReason write SetNotDoneReason;

    // A summary of the events of interest that have occurred, such as when the dispense was verified.
    property eventHistoryList : TFhirReferenceList{TFhirProvenance} read GetEventHistoryList;
    property hasEventHistoryList : boolean read GetHasEventHistoryList;

  end;

  TFhirMedicationDispenseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationDispenseList;
    function GetCurrent : TFhirMedicationDispense;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationDispenseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationDispense read GetCurrent;
  end;

  TFhirMedicationDispenseList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationDispense;
    procedure SetItemN(index : Integer; value : TFhirMedicationDispense);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationDispenseList; Overload;
    function Clone : TFhirMedicationDispenseList; Overload;
    function GetEnumerator : TFhirMedicationDispenseListEnumerator;

    //  Add a FhirMedicationDispense to the end of the list.
    function Append : TFhirMedicationDispense;

    // Add an already existing FhirMedicationDispense to the end of the list.
    procedure AddItem(value : TFhirMedicationDispense); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationDispense) : Integer;

    // Insert FhirMedicationDispense before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationDispense;

    // Insert an existing FhirMedicationDispense before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationDispense);

    // Get the iIndexth FhirMedicationDispense. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationDispense);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationDispense;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMedicationDispenses[index : Integer] : TFhirMedicationDispense read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEDICATIONDISPENSE}

{$IFDEF FHIR_MEDICATIONREQUEST}

  // The individual, organization or device that initiated the request and has responsibility for its activation.
  TFhirMedicationRequestRequester = class (TFhirBackboneElement)
  protected
    FAgent : TFhirReference{Resource};
    FOnBehalfOf : TFhirReference{TFhirOrganization};
    Procedure SetAgent(value : TFhirReference{Resource});
    Procedure SetOnBehalfOf(value : TFhirReference{TFhirOrganization});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationRequestRequester; overload;
    function Clone : TFhirMedicationRequestRequester; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The healthcare professional responsible for authorizing the initial prescription. (defined for API consistency)
    property agent : TFhirReference{Resource} read FAgent write SetAgent;
    // The healthcare professional responsible for authorizing the initial prescription.
    property agentElement : TFhirReference{Resource} read FAgent write SetAgent;

    // Typed access to The organization the device or practitioner was acting on behalf of. (defined for API consistency)
    property onBehalfOf : TFhirReference{TFhirOrganization} read FOnBehalfOf write SetOnBehalfOf;
    // The organization the device or practitioner was acting on behalf of.
    property onBehalfOfElement : TFhirReference{TFhirOrganization} read FOnBehalfOf write SetOnBehalfOf;

  end;

  TFhirMedicationRequestRequesterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationRequestRequesterList;
    function GetCurrent : TFhirMedicationRequestRequester;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationRequestRequesterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationRequestRequester read GetCurrent;
  end;

  TFhirMedicationRequestRequesterList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationRequestRequester;
    procedure SetItemN(index : Integer; value : TFhirMedicationRequestRequester);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationRequestRequesterList; Overload;
    function Clone : TFhirMedicationRequestRequesterList; Overload;
    function GetEnumerator : TFhirMedicationRequestRequesterListEnumerator;

    //  Add a FhirMedicationRequestRequester to the end of the list.
    function Append : TFhirMedicationRequestRequester;

    // Add an already existing FhirMedicationRequestRequester to the end of the list.
    procedure AddItem(value : TFhirMedicationRequestRequester); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationRequestRequester) : Integer;

    // Insert FhirMedicationRequestRequester before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationRequestRequester;

    // Insert an existing FhirMedicationRequestRequester before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationRequestRequester);

    // Get the iIndexth FhirMedicationRequestRequester. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationRequestRequester);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationRequestRequester;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMedicationRequestRequesters[index : Integer] : TFhirMedicationRequestRequester read GetItemN write SetItemN; default;
  End;

  // Indicates the specific details for the dispense or medication supply part of a medication request (also known as a Medication Prescription or Medication Order).  Note that this information is not always sent with the order.  There may be in some settings (e.g. hospitals) institutional or system support for completing the dispense details in the pharmacy department.
  TFhirMedicationRequestDispenseRequest = class (TFhirBackboneElement)
  protected
    FValidityPeriod : TFhirPeriod;
    FNumberOfRepeatsAllowed : TFhirPositiveInt;
    FQuantity : TFhirQuantity;
    FExpectedSupplyDuration : TFhirDuration;
    FPerformer : TFhirReference{TFhirOrganization};
    Procedure SetValidityPeriod(value : TFhirPeriod);
    Procedure SetNumberOfRepeatsAllowed(value : TFhirPositiveInt);
    Function GetNumberOfRepeatsAllowedST : String;
    Procedure SetNumberOfRepeatsAllowedST(value : String);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetExpectedSupplyDuration(value : TFhirDuration);
    Procedure SetPerformer(value : TFhirReference{TFhirOrganization});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationRequestDispenseRequest; overload;
    function Clone : TFhirMedicationRequestDispenseRequest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to This indicates the validity period of a prescription (stale dating the Prescription). (defined for API consistency)
    property validityPeriod : TFhirPeriod read FValidityPeriod write SetValidityPeriod;
    // This indicates the validity period of a prescription (stale dating the Prescription).
    property validityPeriodElement : TFhirPeriod read FValidityPeriod write SetValidityPeriod;

    // Typed access to An integer indicating the number of times, in addition to the original dispense, (aka refills or repeats) that the patient can receive the prescribed medication. Usage Notes: This integer does not include the original order dispense. This means that if an order indicates dispense 30 tablets plus "3 repeats", then the order can be dispensed a total of 4 times and the patient can receive a total of 120 tablets.
    property numberOfRepeatsAllowed : String read GetNumberOfRepeatsAllowedST write SetNumberOfRepeatsAllowedST;
    // An integer indicating the number of times, in addition to the original dispense, (aka refills or repeats) that the patient can receive the prescribed medication. Usage Notes: This integer does not include the original order dispense. This means that if an order indicates dispense 30 tablets plus "3 repeats", then the order can be dispensed a total of 4 times and the patient can receive a total of 120 tablets.
    property numberOfRepeatsAllowedElement : TFhirPositiveInt read FNumberOfRepeatsAllowed write SetNumberOfRepeatsAllowed;

    // Typed access to The amount that is to be dispensed for one fill. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The amount that is to be dispensed for one fill.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to Identifies the period time over which the supplied product is expected to be used, or the length of time the dispense is expected to last. (defined for API consistency)
    property expectedSupplyDuration : TFhirDuration read FExpectedSupplyDuration write SetExpectedSupplyDuration;
    // Identifies the period time over which the supplied product is expected to be used, or the length of time the dispense is expected to last.
    property expectedSupplyDurationElement : TFhirDuration read FExpectedSupplyDuration write SetExpectedSupplyDuration;

    // Typed access to Indicates the intended dispensing Organization specified by the prescriber. (defined for API consistency)
    property performer : TFhirReference{TFhirOrganization} read FPerformer write SetPerformer;
    // Indicates the intended dispensing Organization specified by the prescriber.
    property performerElement : TFhirReference{TFhirOrganization} read FPerformer write SetPerformer;

  end;

  TFhirMedicationRequestDispenseRequestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationRequestDispenseRequestList;
    function GetCurrent : TFhirMedicationRequestDispenseRequest;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationRequestDispenseRequestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationRequestDispenseRequest read GetCurrent;
  end;

  TFhirMedicationRequestDispenseRequestList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationRequestDispenseRequest;
    procedure SetItemN(index : Integer; value : TFhirMedicationRequestDispenseRequest);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationRequestDispenseRequestList; Overload;
    function Clone : TFhirMedicationRequestDispenseRequestList; Overload;
    function GetEnumerator : TFhirMedicationRequestDispenseRequestListEnumerator;

    //  Add a FhirMedicationRequestDispenseRequest to the end of the list.
    function Append : TFhirMedicationRequestDispenseRequest;

    // Add an already existing FhirMedicationRequestDispenseRequest to the end of the list.
    procedure AddItem(value : TFhirMedicationRequestDispenseRequest); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationRequestDispenseRequest) : Integer;

    // Insert FhirMedicationRequestDispenseRequest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationRequestDispenseRequest;

    // Insert an existing FhirMedicationRequestDispenseRequest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationRequestDispenseRequest);

    // Get the iIndexth FhirMedicationRequestDispenseRequest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationRequestDispenseRequest);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationRequestDispenseRequest;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMedicationRequestDispenseRequests[index : Integer] : TFhirMedicationRequestDispenseRequest read GetItemN write SetItemN; default;
  End;

  // Indicates whether or not substitution can or should be part of the dispense. In some cases substitution must happen, in other cases substitution must not happen. This block explains the prescriber's intent. If nothing is specified substitution may be done.
  TFhirMedicationRequestSubstitution = class (TFhirBackboneElement)
  protected
    FAllowed : TFhirBoolean;
    FReason : TFhirCodeableConcept;
    Procedure SetAllowed(value : TFhirBoolean);
    Function GetAllowedST : Boolean;
    Procedure SetAllowedST(value : Boolean);
    Procedure SetReason(value : TFhirCodeableConcept);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationRequestSubstitution; overload;
    function Clone : TFhirMedicationRequestSubstitution; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to True if the prescriber allows a different drug to be dispensed from what was prescribed.
    property allowed : Boolean read GetAllowedST write SetAllowedST;
    // True if the prescriber allows a different drug to be dispensed from what was prescribed.
    property allowedElement : TFhirBoolean read FAllowed write SetAllowed;

    // Typed access to Indicates the reason for the substitution, or why substitution must or must not be performed. (defined for API consistency)
    property reason : TFhirCodeableConcept read FReason write SetReason;
    // Indicates the reason for the substitution, or why substitution must or must not be performed.
    property reasonElement : TFhirCodeableConcept read FReason write SetReason;

  end;

  TFhirMedicationRequestSubstitutionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationRequestSubstitutionList;
    function GetCurrent : TFhirMedicationRequestSubstitution;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationRequestSubstitutionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationRequestSubstitution read GetCurrent;
  end;

  TFhirMedicationRequestSubstitutionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationRequestSubstitution;
    procedure SetItemN(index : Integer; value : TFhirMedicationRequestSubstitution);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationRequestSubstitutionList; Overload;
    function Clone : TFhirMedicationRequestSubstitutionList; Overload;
    function GetEnumerator : TFhirMedicationRequestSubstitutionListEnumerator;

    //  Add a FhirMedicationRequestSubstitution to the end of the list.
    function Append : TFhirMedicationRequestSubstitution;

    // Add an already existing FhirMedicationRequestSubstitution to the end of the list.
    procedure AddItem(value : TFhirMedicationRequestSubstitution); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationRequestSubstitution) : Integer;

    // Insert FhirMedicationRequestSubstitution before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationRequestSubstitution;

    // Insert an existing FhirMedicationRequestSubstitution before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationRequestSubstitution);

    // Get the iIndexth FhirMedicationRequestSubstitution. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationRequestSubstitution);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationRequestSubstitution;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMedicationRequestSubstitutions[index : Integer] : TFhirMedicationRequestSubstitution read GetItemN write SetItemN; default;
  End;

  // An order or request for both supply of the medication and the instructions for administration of the medication to a patient. The resource is called "MedicationRequest" rather than "MedicationPrescription" or "MedicationOrder" to generalize the use across inpatient and outpatient settings, including care plans, etc., and to harmonize with workflow patterns.
  TFhirMedicationRequest = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FdefinitionList : TFhirReferenceList{Resource};
    FbasedOnList : TFhirReferenceList{Resource};
    FGroupIdentifier : TFhirIdentifier;
    FStatus : TFhirEnum;
    FIntent : TFhirEnum;
    FCategory : TFhirCodeableConcept;
    FPriority : TFhirEnum;
    FMedication : TFhirType;
    FSubject : TFhirReference{Resource};
    FContext : TFhirReference{Resource};
    FsupportingInformationList : TFhirReferenceList{TFhirReference};
    FAuthoredOn : TFhirDateTime;
    FRequester : TFhirMedicationRequestRequester;
    FRecorder : TFhirReference{TFhirPractitioner};
    FreasonCodeList : TFhirCodeableConceptList;
    FreasonReferenceList : TFhirReferenceList{Resource};
    FnoteList : TFhirAnnotationList;
    FdosageInstructionList : TFhirDosageList;
    FDispenseRequest : TFhirMedicationRequestDispenseRequest;
    FSubstitution : TFhirMedicationRequestSubstitution;
    FPriorPrescription : TFhirReference{TFhirMedicationRequest};
    FdetectedIssueList : TFhirReferenceList{TFhirDetectedIssue};
    FeventHistoryList : TFhirReferenceList{TFhirProvenance};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetDefinitionList : TFhirReferenceList{Resource};
    function GetHasDefinitionList : Boolean;
    function GetBasedOnList : TFhirReferenceList{Resource};
    function GetHasBasedOnList : Boolean;
    Procedure SetGroupIdentifier(value : TFhirIdentifier);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirMedicationRequestStatusEnum;
    Procedure SetStatusST(value : TFhirMedicationRequestStatusEnum);
    Procedure SetIntent(value : TFhirEnum);
    Function GetIntentST : TFhirMedicationRequestIntentEnum;
    Procedure SetIntentST(value : TFhirMedicationRequestIntentEnum);
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetPriority(value : TFhirEnum);
    Function GetPriorityST : TFhirMedicationRequestPriorityEnum;
    Procedure SetPriorityST(value : TFhirMedicationRequestPriorityEnum);
    Procedure SetMedication(value : TFhirType);
    Procedure SetSubject(value : TFhirReference{Resource});
    Procedure SetContext(value : TFhirReference{Resource});
    function GetSupportingInformationList : TFhirReferenceList{TFhirReference};
    function GetHasSupportingInformationList : Boolean;
    Procedure SetAuthoredOn(value : TFhirDateTime);
    Function GetAuthoredOnST : TFslDateTime;
    Procedure SetAuthoredOnST(value : TFslDateTime);
    Procedure SetRequester(value : TFhirMedicationRequestRequester);
    Procedure SetRecorder(value : TFhirReference{TFhirPractitioner});
    function GetReasonCodeList : TFhirCodeableConceptList;
    function GetHasReasonCodeList : Boolean;
    function GetReasonReferenceList : TFhirReferenceList{Resource};
    function GetHasReasonReferenceList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetDosageInstructionList : TFhirDosageList;
    function GetHasDosageInstructionList : Boolean;
    Procedure SetDispenseRequest(value : TFhirMedicationRequestDispenseRequest);
    Procedure SetSubstitution(value : TFhirMedicationRequestSubstitution);
    Procedure SetPriorPrescription(value : TFhirReference{TFhirMedicationRequest});
    function GetDetectedIssueList : TFhirReferenceList{TFhirDetectedIssue};
    function GetHasDetectedIssueList : Boolean;
    function GetEventHistoryList : TFhirReferenceList{TFhirProvenance};
    function GetHasEventHistoryList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationRequest; overload;
    function Clone : TFhirMedicationRequest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // This records identifiers associated with this medication request that are defined by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate. For example a re-imbursement system might issue its own id for each prescription that is created.  This is particularly important where FHIR only provides part of an entire workflow process where records must be tracked through an entire system.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Protocol or definition followed by this request.
    property definitionList : TFhirReferenceList{Resource} read GetDefinitionList;
    property hasDefinitionList : boolean read GetHasDefinitionList;

    // A plan or request that is fulfilled in whole or in part by this medication request.
    property basedOnList : TFhirReferenceList{Resource} read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // Typed access to A shared identifier common to all requests that were authorized more or less simultaneously by a single author, representing the identifier of the requisition or prescription. (defined for API consistency)
    property groupIdentifier : TFhirIdentifier read FGroupIdentifier write SetGroupIdentifier;
    // A shared identifier common to all requests that were authorized more or less simultaneously by a single author, representing the identifier of the requisition or prescription.
    property groupIdentifierElement : TFhirIdentifier read FGroupIdentifier write SetGroupIdentifier;

    // A code specifying the current state of the order.  Generally this will be active or completed state.
    property status : TFhirMedicationRequestStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Whether the request is a proposal, plan, or an original order.
    property intent : TFhirMedicationRequestIntentEnum read GetIntentST write SetIntentST;
    property intentElement : TFhirEnum read FIntent write SetIntent;

    // Typed access to Indicates the type of medication order and where the medication is expected to be consumed or administered. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Indicates the type of medication order and where the medication is expected to be consumed or administered.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Indicates how quickly the Medication Request should be addressed with respect to other requests.
    property priority : TFhirMedicationRequestPriorityEnum read GetPriorityST write SetPriorityST;
    property priorityElement : TFhirEnum read FPriority write SetPriority;

    // Typed access to Identifies the medication being requested. This is a link to a resource that represents the medication which may be the details of the medication or simply an attribute carrying a code that identifies the medication from a known list of medications. (defined for API consistency)
    property medication : TFhirType read FMedication write SetMedication;
    // Identifies the medication being requested. This is a link to a resource that represents the medication which may be the details of the medication or simply an attribute carrying a code that identifies the medication from a known list of medications.
    property medicationElement : TFhirType read FMedication write SetMedication;

    // Typed access to A link to a resource representing the person or set of individuals to whom the medication will be given. (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // A link to a resource representing the person or set of individuals to whom the medication will be given.
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // Typed access to A link to an encounter, or episode of care, that identifies the particular occurrence or set occurrences of contact between patient and health care provider. (defined for API consistency)
    property context : TFhirReference{Resource} read FContext write SetContext;
    // A link to an encounter, or episode of care, that identifies the particular occurrence or set occurrences of contact between patient and health care provider.
    property contextElement : TFhirReference{Resource} read FContext write SetContext;

    // Include additional information (for example, patient height and weight) that supports the ordering of the medication.
    property supportingInformationList : TFhirReferenceList{TFhirReference} read GetSupportingInformationList;
    property hasSupportingInformationList : boolean read GetHasSupportingInformationList;

    // Typed access to The date (and perhaps time) when the prescription was initially written or authored on.
    property authoredOn : TFslDateTime read GetAuthoredOnST write SetAuthoredOnST;
    // The date (and perhaps time) when the prescription was initially written or authored on.
    property authoredOnElement : TFhirDateTime read FAuthoredOn write SetAuthoredOn;

    // Typed access to The individual, organization or device that initiated the request and has responsibility for its activation. (defined for API consistency)
    property requester : TFhirMedicationRequestRequester read FRequester write SetRequester;
    // The individual, organization or device that initiated the request and has responsibility for its activation.
    property requesterElement : TFhirMedicationRequestRequester read FRequester write SetRequester;

    // Typed access to The person who entered the order on behalf of another individual for example in the case of a verbal or a telephone order. (defined for API consistency)
    property recorder : TFhirReference{TFhirPractitioner} read FRecorder write SetRecorder;
    // The person who entered the order on behalf of another individual for example in the case of a verbal or a telephone order.
    property recorderElement : TFhirReference{TFhirPractitioner} read FRecorder write SetRecorder;

    // The reason or the indication for ordering the medication.
    property reasonCodeList : TFhirCodeableConceptList read GetReasonCodeList;
    property hasReasonCodeList : boolean read GetHasReasonCodeList;

    // Condition or observation that supports why the medication was ordered.
    property reasonReferenceList : TFhirReferenceList{Resource} read GetReasonReferenceList;
    property hasReasonReferenceList : boolean read GetHasReasonReferenceList;

    // Extra information about the prescription that could not be conveyed by the other attributes.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Indicates how the medication is to be used by the patient.
    property dosageInstructionList : TFhirDosageList read GetDosageInstructionList;
    property hasDosageInstructionList : boolean read GetHasDosageInstructionList;

    // Typed access to Indicates the specific details for the dispense or medication supply part of a medication request (also known as a Medication Prescription or Medication Order).  Note that this information is not always sent with the order.  There may be in some settings (e.g. hospitals) institutional or system support for completing the dispense details in the pharmacy department. (defined for API consistency)
    property dispenseRequest : TFhirMedicationRequestDispenseRequest read FDispenseRequest write SetDispenseRequest;
    // Indicates the specific details for the dispense or medication supply part of a medication request (also known as a Medication Prescription or Medication Order).  Note that this information is not always sent with the order.  There may be in some settings (e.g. hospitals) institutional or system support for completing the dispense details in the pharmacy department.
    property dispenseRequestElement : TFhirMedicationRequestDispenseRequest read FDispenseRequest write SetDispenseRequest;

    // Typed access to Indicates whether or not substitution can or should be part of the dispense. In some cases substitution must happen, in other cases substitution must not happen. This block explains the prescriber's intent. If nothing is specified substitution may be done. (defined for API consistency)
    property substitution : TFhirMedicationRequestSubstitution read FSubstitution write SetSubstitution;
    // Indicates whether or not substitution can or should be part of the dispense. In some cases substitution must happen, in other cases substitution must not happen. This block explains the prescriber's intent. If nothing is specified substitution may be done.
    property substitutionElement : TFhirMedicationRequestSubstitution read FSubstitution write SetSubstitution;

    // Typed access to A link to a resource representing an earlier order related order or prescription. (defined for API consistency)
    property priorPrescription : TFhirReference{TFhirMedicationRequest} read FPriorPrescription write SetPriorPrescription;
    // A link to a resource representing an earlier order related order or prescription.
    property priorPrescriptionElement : TFhirReference{TFhirMedicationRequest} read FPriorPrescription write SetPriorPrescription;

    // Indicates an actual or potential clinical issue with or between one or more active or proposed clinical actions for a patient; e.g. Drug-drug interaction, duplicate therapy, dosage alert etc.
    property detectedIssueList : TFhirReferenceList{TFhirDetectedIssue} read GetDetectedIssueList;
    property hasDetectedIssueList : boolean read GetHasDetectedIssueList;

    // Links to Provenance records for past versions of this resource or fulfilling request or event resources that identify key state transitions or updates that are likely to be relevant to a user looking at the current version of the resource.
    property eventHistoryList : TFhirReferenceList{TFhirProvenance} read GetEventHistoryList;
    property hasEventHistoryList : boolean read GetHasEventHistoryList;

  end;

  TFhirMedicationRequestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationRequestList;
    function GetCurrent : TFhirMedicationRequest;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationRequestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationRequest read GetCurrent;
  end;

  TFhirMedicationRequestList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationRequest;
    procedure SetItemN(index : Integer; value : TFhirMedicationRequest);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationRequestList; Overload;
    function Clone : TFhirMedicationRequestList; Overload;
    function GetEnumerator : TFhirMedicationRequestListEnumerator;

    //  Add a FhirMedicationRequest to the end of the list.
    function Append : TFhirMedicationRequest;

    // Add an already existing FhirMedicationRequest to the end of the list.
    procedure AddItem(value : TFhirMedicationRequest); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationRequest) : Integer;

    // Insert FhirMedicationRequest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationRequest;

    // Insert an existing FhirMedicationRequest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationRequest);

    // Get the iIndexth FhirMedicationRequest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationRequest);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationRequest;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMedicationRequests[index : Integer] : TFhirMedicationRequest read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEDICATIONREQUEST}

{$IFDEF FHIR_MEDICATIONSTATEMENT}

  // A record of a medication that is being consumed by a patient.   A MedicationStatement may indicate that the patient may be taking the medication now, or has taken the medication in the past or will be taking the medication in the future.  The source of this information can be the patient, significant other (such as a family member or spouse), or a clinician.  A common scenario where this information is captured is during the history taking process during a patient visit or stay.   The medication information may come from sources such as the patient's memory, from a prescription bottle,  or from a list of medications the patient, clinician or other party maintains   The primary difference between a medication statement and a medication administration is that the medication administration has complete administration information and is based on actual administration information from the person who administered the medication.  A medication statement is often, if not
    //  always, less specific.  There is no required date/time when the medication was administered, in fact we only know that a source has reported the patient is taking this medication, where details such as time, quantity, or rate or even medication product may be incomplete or missing or less precise.  As stated earlier, the medication statement information may come from the patient's memory, from a prescription bottle or from a list of medications the patient, clinician or other party maintains.  Medication administration is more formal and is not missing detailed information.
  TFhirMedicationStatement = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FbasedOnList : TFhirReferenceList{Resource};
    FpartOfList : TFhirReferenceList{Resource};
    FContext : TFhirReference{Resource};
    FStatus : TFhirEnum;
    FCategory : TFhirCodeableConcept;
    FMedication : TFhirType;
    FEffective : TFhirType;
    FDateAsserted : TFhirDateTime;
    FInformationSource : TFhirReference{Resource};
    FSubject : TFhirReference{Resource};
    FderivedFromList : TFhirReferenceList{TFhirReference};
    FTaken : TFhirEnum;
    FreasonNotTakenList : TFhirCodeableConceptList;
    FreasonCodeList : TFhirCodeableConceptList;
    FreasonReferenceList : TFhirReferenceList{Resource};
    FnoteList : TFhirAnnotationList;
    FdosageList : TFhirDosageList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetBasedOnList : TFhirReferenceList{Resource};
    function GetHasBasedOnList : Boolean;
    function GetPartOfList : TFhirReferenceList{Resource};
    function GetHasPartOfList : Boolean;
    Procedure SetContext(value : TFhirReference{Resource});
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirMedicationStatementStatusEnum;
    Procedure SetStatusST(value : TFhirMedicationStatementStatusEnum);
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetMedication(value : TFhirType);
    Procedure SetEffective(value : TFhirType);
    Procedure SetDateAsserted(value : TFhirDateTime);
    Function GetDateAssertedST : TFslDateTime;
    Procedure SetDateAssertedST(value : TFslDateTime);
    Procedure SetInformationSource(value : TFhirReference{Resource});
    Procedure SetSubject(value : TFhirReference{Resource});
    function GetDerivedFromList : TFhirReferenceList{TFhirReference};
    function GetHasDerivedFromList : Boolean;
    Procedure SetTaken(value : TFhirEnum);
    Function GetTakenST : TFhirMedicationStatementTakenEnum;
    Procedure SetTakenST(value : TFhirMedicationStatementTakenEnum);
    function GetReasonNotTakenList : TFhirCodeableConceptList;
    function GetHasReasonNotTakenList : Boolean;
    function GetReasonCodeList : TFhirCodeableConceptList;
    function GetHasReasonCodeList : Boolean;
    function GetReasonReferenceList : TFhirReferenceList{Resource};
    function GetHasReasonReferenceList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetDosageList : TFhirDosageList;
    function GetHasDosageList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationStatement; overload;
    function Clone : TFhirMedicationStatement; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // External identifier - FHIR will generate its own internal identifiers (probably URLs) which do not need to be explicitly managed by the resource.  The identifier here is one that would be used by another non-FHIR system - for example an automated medication pump would provide a record each time it operated; an administration while the patient was off the ward might be made with a different system and entered after the event.  Particularly important if these records have to be updated.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A plan, proposal or order that is fulfilled in whole or in part by this event.
    property basedOnList : TFhirReferenceList{Resource} read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // A larger event of which this particular event is a component or step.
    property partOfList : TFhirReferenceList{Resource} read GetPartOfList;
    property hasPartOfList : boolean read GetHasPartOfList;

    // Typed access to The encounter or episode of care that establishes the context for this MedicationStatement. (defined for API consistency)
    property context : TFhirReference{Resource} read FContext write SetContext;
    // The encounter or episode of care that establishes the context for this MedicationStatement.
    property contextElement : TFhirReference{Resource} read FContext write SetContext;

    // A code representing the patient or other source's judgment about the state of the medication used that this statement is about.  Generally this will be active or completed.
    property status : TFhirMedicationStatementStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Indicates where type of medication statement and where the medication is expected to be consumed or administered. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Indicates where type of medication statement and where the medication is expected to be consumed or administered.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to Identifies the medication being administered. This is either a link to a resource representing the details of the medication or a simple attribute carrying a code that identifies the medication from a known list of medications. (defined for API consistency)
    property medication : TFhirType read FMedication write SetMedication;
    // Identifies the medication being administered. This is either a link to a resource representing the details of the medication or a simple attribute carrying a code that identifies the medication from a known list of medications.
    property medicationElement : TFhirType read FMedication write SetMedication;

    // Typed access to The interval of time during which it is being asserted that the patient was taking the medication (or was not taking, when the wasNotGiven element is true). (defined for API consistency)
    property effective : TFhirType read FEffective write SetEffective;
    // The interval of time during which it is being asserted that the patient was taking the medication (or was not taking, when the wasNotGiven element is true).
    property effectiveElement : TFhirType read FEffective write SetEffective;

    // Typed access to The date when the medication statement was asserted by the information source.
    property dateAsserted : TFslDateTime read GetDateAssertedST write SetDateAssertedST;
    // The date when the medication statement was asserted by the information source.
    property dateAssertedElement : TFhirDateTime read FDateAsserted write SetDateAsserted;

    // Typed access to The person or organization that provided the information about the taking of this medication. Note: Use derivedFrom when a MedicationStatement is derived from other resources, e.g Claim or MedicationRequest. (defined for API consistency)
    property informationSource : TFhirReference{Resource} read FInformationSource write SetInformationSource;
    // The person or organization that provided the information about the taking of this medication. Note: Use derivedFrom when a MedicationStatement is derived from other resources, e.g Claim or MedicationRequest.
    property informationSourceElement : TFhirReference{Resource} read FInformationSource write SetInformationSource;

    // Typed access to The person, animal or group who is/was taking the medication. (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // The person, animal or group who is/was taking the medication.
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // Allows linking the MedicationStatement to the underlying MedicationRequest, or to other information that supports or is used to derive the MedicationStatement.
    property derivedFromList : TFhirReferenceList{TFhirReference} read GetDerivedFromList;
    property hasDerivedFromList : boolean read GetHasDerivedFromList;

    // Indicator of the certainty of whether the medication was taken by the patient.
    property taken : TFhirMedicationStatementTakenEnum read GetTakenST write SetTakenST;
    property takenElement : TFhirEnum read FTaken write SetTaken;

    // A code indicating why the medication was not taken.
    property reasonNotTakenList : TFhirCodeableConceptList read GetReasonNotTakenList;
    property hasReasonNotTakenList : boolean read GetHasReasonNotTakenList;

    // A reason for why the medication is being/was taken.
    property reasonCodeList : TFhirCodeableConceptList read GetReasonCodeList;
    property hasReasonCodeList : boolean read GetHasReasonCodeList;

    // Condition or observation that supports why the medication is being/was taken.
    property reasonReferenceList : TFhirReferenceList{Resource} read GetReasonReferenceList;
    property hasReasonReferenceList : boolean read GetHasReasonReferenceList;

    // Provides extra information about the medication statement that is not conveyed by the other attributes.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Indicates how the medication is/was or should be taken by the patient.
    property dosageList : TFhirDosageList read GetDosageList;
    property hasDosageList : boolean read GetHasDosageList;

  end;

  TFhirMedicationStatementListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationStatementList;
    function GetCurrent : TFhirMedicationStatement;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMedicationStatementList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationStatement read GetCurrent;
  end;

  TFhirMedicationStatementList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMedicationStatement;
    procedure SetItemN(index : Integer; value : TFhirMedicationStatement);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMedicationStatementList; Overload;
    function Clone : TFhirMedicationStatementList; Overload;
    function GetEnumerator : TFhirMedicationStatementListEnumerator;

    //  Add a FhirMedicationStatement to the end of the list.
    function Append : TFhirMedicationStatement;

    // Add an already existing FhirMedicationStatement to the end of the list.
    procedure AddItem(value : TFhirMedicationStatement); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationStatement) : Integer;

    // Insert FhirMedicationStatement before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationStatement;

    // Insert an existing FhirMedicationStatement before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationStatement);

    // Get the iIndexth FhirMedicationStatement. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationStatement);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationStatement;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMedicationStatements[index : Integer] : TFhirMedicationStatement read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEDICATIONSTATEMENT}

{$IFDEF FHIR_NUTRITIONORDER}

  // Diet given orally in contrast to enteral (tube) feeding.
  TFhirNutritionOrderOralDiet = class (TFhirBackboneElement)
  protected
    Ftype_List : TFhirCodeableConceptList;
    FscheduleList : TFhirTimingList;
    FnutrientList : TFhirNutritionOrderOralDietNutrientList;
    FtextureList : TFhirNutritionOrderOralDietTextureList;
    FfluidConsistencyTypeList : TFhirCodeableConceptList;
    FInstruction : TFhirString;
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    function GetScheduleList : TFhirTimingList;
    function GetHasScheduleList : Boolean;
    function GetNutrientList : TFhirNutritionOrderOralDietNutrientList;
    function GetHasNutrientList : Boolean;
    function GetTextureList : TFhirNutritionOrderOralDietTextureList;
    function GetHasTextureList : Boolean;
    function GetFluidConsistencyTypeList : TFhirCodeableConceptList;
    function GetHasFluidConsistencyTypeList : Boolean;
    Procedure SetInstruction(value : TFhirString);
    Function GetInstructionST : String;
    Procedure SetInstructionST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionOrderOralDiet; overload;
    function Clone : TFhirNutritionOrderOralDiet; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The kind of diet or dietary restriction such as fiber restricted diet or diabetic diet.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // The time period and frequency at which the diet should be given.  The diet should be given for the combination of all schedules if more than one schedule is present.
    property scheduleList : TFhirTimingList read GetScheduleList;
    property hasScheduleList : boolean read GetHasScheduleList;

    // Class that defines the quantity and type of nutrient modifications (for example carbohydrate, fiber or sodium) required for the oral diet.
    property nutrientList : TFhirNutritionOrderOralDietNutrientList read GetNutrientList;
    property hasNutrientList : boolean read GetHasNutrientList;

    // Class that describes any texture modifications required for the patient to safely consume various types of solid foods.
    property textureList : TFhirNutritionOrderOralDietTextureList read GetTextureList;
    property hasTextureList : boolean read GetHasTextureList;

    // The required consistency (e.g. honey-thick, nectar-thick, thin, thickened.) of liquids or fluids served to the patient.
    property fluidConsistencyTypeList : TFhirCodeableConceptList read GetFluidConsistencyTypeList;
    property hasFluidConsistencyTypeList : boolean read GetHasFluidConsistencyTypeList;

    // Typed access to Free text or additional instructions or information pertaining to the oral diet.
    property instruction : String read GetInstructionST write SetInstructionST;
    // Free text or additional instructions or information pertaining to the oral diet.
    property instructionElement : TFhirString read FInstruction write SetInstruction;

  end;

  TFhirNutritionOrderOralDietListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionOrderOralDietList;
    function GetCurrent : TFhirNutritionOrderOralDiet;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirNutritionOrderOralDietList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionOrderOralDiet read GetCurrent;
  end;

  TFhirNutritionOrderOralDietList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirNutritionOrderOralDiet;
    procedure SetItemN(index : Integer; value : TFhirNutritionOrderOralDiet);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirNutritionOrderOralDietList; Overload;
    function Clone : TFhirNutritionOrderOralDietList; Overload;
    function GetEnumerator : TFhirNutritionOrderOralDietListEnumerator;

    //  Add a FhirNutritionOrderOralDiet to the end of the list.
    function Append : TFhirNutritionOrderOralDiet;

    // Add an already existing FhirNutritionOrderOralDiet to the end of the list.
    procedure AddItem(value : TFhirNutritionOrderOralDiet); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionOrderOralDiet) : Integer;

    // Insert FhirNutritionOrderOralDiet before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionOrderOralDiet;

    // Insert an existing FhirNutritionOrderOralDiet before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionOrderOralDiet);

    // Get the iIndexth FhirNutritionOrderOralDiet. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionOrderOralDiet);

    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionOrderOralDiet;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirNutritionOrderOralDiets[index : Integer] : TFhirNutritionOrderOralDiet read GetItemN write SetItemN; default;
  End;

  // Class that defines the quantity and type of nutrient modifications (for example carbohydrate, fiber or sodium) required for the oral diet.
  TFhirNutritionOrderOralDietNutrient = class (TFhirBackboneElement)
  protected
    FModifier : TFhirCodeableConcept;
    FAmount : TFhirQuantity;
    Procedure SetModifier(value : TFhirCodeableConcept);
    Procedure SetAmount(value : TFhirQuantity);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionOrderOralDietNutrient; overload;
    function Clone : TFhirNutritionOrderOralDietNutrient; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The nutrient that is being modified such as carbohydrate or sodium. (defined for API consistency)
    property modifier : TFhirCodeableConcept read FModifier write SetModifier;
    // The nutrient that is being modified such as carbohydrate or sodium.
    property modifierElement : TFhirCodeableConcept read FModifier write SetModifier;

    // Typed access to The quantity of the specified nutrient to include in diet. (defined for API consistency)
    property amount : TFhirQuantity read FAmount write SetAmount;
    // The quantity of the specified nutrient to include in diet.
    property amountElement : TFhirQuantity read FAmount write SetAmount;

  end;

  TFhirNutritionOrderOralDietNutrientListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionOrderOralDietNutrientList;
    function GetCurrent : TFhirNutritionOrderOralDietNutrient;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirNutritionOrderOralDietNutrientList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionOrderOralDietNutrient read GetCurrent;
  end;

  TFhirNutritionOrderOralDietNutrientList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirNutritionOrderOralDietNutrient;
    procedure SetItemN(index : Integer; value : TFhirNutritionOrderOralDietNutrient);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirNutritionOrderOralDietNutrientList; Overload;
    function Clone : TFhirNutritionOrderOralDietNutrientList; Overload;
    function GetEnumerator : TFhirNutritionOrderOralDietNutrientListEnumerator;

    //  Add a FhirNutritionOrderOralDietNutrient to the end of the list.
    function Append : TFhirNutritionOrderOralDietNutrient;

    // Add an already existing FhirNutritionOrderOralDietNutrient to the end of the list.
    procedure AddItem(value : TFhirNutritionOrderOralDietNutrient); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionOrderOralDietNutrient) : Integer;

    // Insert FhirNutritionOrderOralDietNutrient before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionOrderOralDietNutrient;

    // Insert an existing FhirNutritionOrderOralDietNutrient before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionOrderOralDietNutrient);

    // Get the iIndexth FhirNutritionOrderOralDietNutrient. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionOrderOralDietNutrient);

    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionOrderOralDietNutrient;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirNutritionOrderOralDietNutrients[index : Integer] : TFhirNutritionOrderOralDietNutrient read GetItemN write SetItemN; default;
  End;

  // Class that describes any texture modifications required for the patient to safely consume various types of solid foods.
  TFhirNutritionOrderOralDietTexture = class (TFhirBackboneElement)
  protected
    FModifier : TFhirCodeableConcept;
    FFoodType : TFhirCodeableConcept;
    Procedure SetModifier(value : TFhirCodeableConcept);
    Procedure SetFoodType(value : TFhirCodeableConcept);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionOrderOralDietTexture; overload;
    function Clone : TFhirNutritionOrderOralDietTexture; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Any texture modifications (for solid foods) that should be made, e.g. easy to chew, chopped, ground, and pureed. (defined for API consistency)
    property modifier : TFhirCodeableConcept read FModifier write SetModifier;
    // Any texture modifications (for solid foods) that should be made, e.g. easy to chew, chopped, ground, and pureed.
    property modifierElement : TFhirCodeableConcept read FModifier write SetModifier;

    // Typed access to The food type(s) (e.g. meats, all foods)  that the texture modification applies to.  This could be all foods types. (defined for API consistency)
    property foodType : TFhirCodeableConcept read FFoodType write SetFoodType;
    // The food type(s) (e.g. meats, all foods)  that the texture modification applies to.  This could be all foods types.
    property foodTypeElement : TFhirCodeableConcept read FFoodType write SetFoodType;

  end;

  TFhirNutritionOrderOralDietTextureListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionOrderOralDietTextureList;
    function GetCurrent : TFhirNutritionOrderOralDietTexture;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirNutritionOrderOralDietTextureList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionOrderOralDietTexture read GetCurrent;
  end;

  TFhirNutritionOrderOralDietTextureList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirNutritionOrderOralDietTexture;
    procedure SetItemN(index : Integer; value : TFhirNutritionOrderOralDietTexture);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirNutritionOrderOralDietTextureList; Overload;
    function Clone : TFhirNutritionOrderOralDietTextureList; Overload;
    function GetEnumerator : TFhirNutritionOrderOralDietTextureListEnumerator;

    //  Add a FhirNutritionOrderOralDietTexture to the end of the list.
    function Append : TFhirNutritionOrderOralDietTexture;

    // Add an already existing FhirNutritionOrderOralDietTexture to the end of the list.
    procedure AddItem(value : TFhirNutritionOrderOralDietTexture); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionOrderOralDietTexture) : Integer;

    // Insert FhirNutritionOrderOralDietTexture before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionOrderOralDietTexture;

    // Insert an existing FhirNutritionOrderOralDietTexture before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionOrderOralDietTexture);

    // Get the iIndexth FhirNutritionOrderOralDietTexture. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionOrderOralDietTexture);

    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionOrderOralDietTexture;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirNutritionOrderOralDietTextures[index : Integer] : TFhirNutritionOrderOralDietTexture read GetItemN write SetItemN; default;
  End;

  // Oral nutritional products given in order to add further nutritional value to the patient's diet.
  TFhirNutritionOrderSupplement = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FProductName : TFhirString;
    FscheduleList : TFhirTimingList;
    FQuantity : TFhirQuantity;
    FInstruction : TFhirString;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetProductName(value : TFhirString);
    Function GetProductNameST : String;
    Procedure SetProductNameST(value : String);
    function GetScheduleList : TFhirTimingList;
    function GetHasScheduleList : Boolean;
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetInstruction(value : TFhirString);
    Function GetInstructionST : String;
    Procedure SetInstructionST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionOrderSupplement; overload;
    function Clone : TFhirNutritionOrderSupplement; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The kind of nutritional supplement product required such as a high protein or pediatric clear liquid supplement. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The kind of nutritional supplement product required such as a high protein or pediatric clear liquid supplement.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The product or brand name of the nutritional supplement such as "Acme Protein Shake".
    property productName : String read GetProductNameST write SetProductNameST;
    // The product or brand name of the nutritional supplement such as "Acme Protein Shake".
    property productNameElement : TFhirString read FProductName write SetProductName;

    // The time period and frequency at which the supplement(s) should be given.  The supplement should be given for the combination of all schedules if more than one schedule is present.
    property scheduleList : TFhirTimingList read GetScheduleList;
    property hasScheduleList : boolean read GetHasScheduleList;

    // Typed access to The amount of the nutritional supplement to be given. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The amount of the nutritional supplement to be given.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to Free text or additional instructions or information pertaining to the oral supplement.
    property instruction : String read GetInstructionST write SetInstructionST;
    // Free text or additional instructions or information pertaining to the oral supplement.
    property instructionElement : TFhirString read FInstruction write SetInstruction;

  end;

  TFhirNutritionOrderSupplementListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionOrderSupplementList;
    function GetCurrent : TFhirNutritionOrderSupplement;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirNutritionOrderSupplementList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionOrderSupplement read GetCurrent;
  end;

  TFhirNutritionOrderSupplementList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirNutritionOrderSupplement;
    procedure SetItemN(index : Integer; value : TFhirNutritionOrderSupplement);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirNutritionOrderSupplementList; Overload;
    function Clone : TFhirNutritionOrderSupplementList; Overload;
    function GetEnumerator : TFhirNutritionOrderSupplementListEnumerator;

    //  Add a FhirNutritionOrderSupplement to the end of the list.
    function Append : TFhirNutritionOrderSupplement;

    // Add an already existing FhirNutritionOrderSupplement to the end of the list.
    procedure AddItem(value : TFhirNutritionOrderSupplement); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionOrderSupplement) : Integer;

    // Insert FhirNutritionOrderSupplement before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionOrderSupplement;

    // Insert an existing FhirNutritionOrderSupplement before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionOrderSupplement);

    // Get the iIndexth FhirNutritionOrderSupplement. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionOrderSupplement);

    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionOrderSupplement;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirNutritionOrderSupplements[index : Integer] : TFhirNutritionOrderSupplement read GetItemN write SetItemN; default;
  End;

  // Feeding provided through the gastrointestinal tract via a tube, catheter, or stoma that delivers nutrition distal to the oral cavity.
  TFhirNutritionOrderEnteralFormula = class (TFhirBackboneElement)
  protected
    FBaseFormulaType : TFhirCodeableConcept;
    FBaseFormulaProductName : TFhirString;
    FAdditiveType : TFhirCodeableConcept;
    FAdditiveProductName : TFhirString;
    FCaloricDensity : TFhirQuantity;
    FRouteofAdministration : TFhirCodeableConcept;
    FadministrationList : TFhirNutritionOrderEnteralFormulaAdministrationList;
    FMaxVolumeToDeliver : TFhirQuantity;
    FAdministrationInstruction : TFhirString;
    Procedure SetBaseFormulaType(value : TFhirCodeableConcept);
    Procedure SetBaseFormulaProductName(value : TFhirString);
    Function GetBaseFormulaProductNameST : String;
    Procedure SetBaseFormulaProductNameST(value : String);
    Procedure SetAdditiveType(value : TFhirCodeableConcept);
    Procedure SetAdditiveProductName(value : TFhirString);
    Function GetAdditiveProductNameST : String;
    Procedure SetAdditiveProductNameST(value : String);
    Procedure SetCaloricDensity(value : TFhirQuantity);
    Procedure SetRouteofAdministration(value : TFhirCodeableConcept);
    function GetAdministrationList : TFhirNutritionOrderEnteralFormulaAdministrationList;
    function GetHasAdministrationList : Boolean;
    Procedure SetMaxVolumeToDeliver(value : TFhirQuantity);
    Procedure SetAdministrationInstruction(value : TFhirString);
    Function GetAdministrationInstructionST : String;
    Procedure SetAdministrationInstructionST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionOrderEnteralFormula; overload;
    function Clone : TFhirNutritionOrderEnteralFormula; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The type of enteral or infant formula such as an adult standard formula with fiber or a soy-based infant formula. (defined for API consistency)
    property baseFormulaType : TFhirCodeableConcept read FBaseFormulaType write SetBaseFormulaType;
    // The type of enteral or infant formula such as an adult standard formula with fiber or a soy-based infant formula.
    property baseFormulaTypeElement : TFhirCodeableConcept read FBaseFormulaType write SetBaseFormulaType;

    // Typed access to The product or brand name of the enteral or infant formula product such as "ACME Adult Standard Formula".
    property baseFormulaProductName : String read GetBaseFormulaProductNameST write SetBaseFormulaProductNameST;
    // The product or brand name of the enteral or infant formula product such as "ACME Adult Standard Formula".
    property baseFormulaProductNameElement : TFhirString read FBaseFormulaProductName write SetBaseFormulaProductName;

    // Typed access to Indicates the type of modular component such as protein, carbohydrate, fat or fiber to be provided in addition to or mixed with the base formula. (defined for API consistency)
    property additiveType : TFhirCodeableConcept read FAdditiveType write SetAdditiveType;
    // Indicates the type of modular component such as protein, carbohydrate, fat or fiber to be provided in addition to or mixed with the base formula.
    property additiveTypeElement : TFhirCodeableConcept read FAdditiveType write SetAdditiveType;

    // Typed access to The product or brand name of the type of modular component to be added to the formula.
    property additiveProductName : String read GetAdditiveProductNameST write SetAdditiveProductNameST;
    // The product or brand name of the type of modular component to be added to the formula.
    property additiveProductNameElement : TFhirString read FAdditiveProductName write SetAdditiveProductName;

    // Typed access to The amount of energy (calories) that the formula should provide per specified volume, typically per mL or fluid oz.  For example, an infant may require a formula that provides 24 calories per fluid ounce or an adult may require an enteral formula that provides 1.5 calorie/mL. (defined for API consistency)
    property caloricDensity : TFhirQuantity read FCaloricDensity write SetCaloricDensity;
    // The amount of energy (calories) that the formula should provide per specified volume, typically per mL or fluid oz.  For example, an infant may require a formula that provides 24 calories per fluid ounce or an adult may require an enteral formula that provides 1.5 calorie/mL.
    property caloricDensityElement : TFhirQuantity read FCaloricDensity write SetCaloricDensity;

    // Typed access to The route or physiological path of administration into the patient's gastrointestinal  tract for purposes of providing the formula feeding, e.g. nasogastric tube. (defined for API consistency)
    property routeofAdministration : TFhirCodeableConcept read FRouteofAdministration write SetRouteofAdministration;
    // The route or physiological path of administration into the patient's gastrointestinal  tract for purposes of providing the formula feeding, e.g. nasogastric tube.
    property routeofAdministrationElement : TFhirCodeableConcept read FRouteofAdministration write SetRouteofAdministration;

    // Formula administration instructions as structured data.  This repeating structure allows for changing the administration rate or volume over time for both bolus and continuous feeding.  An example of this would be an instruction to increase the rate of continuous feeding every 2 hours.
    property administrationList : TFhirNutritionOrderEnteralFormulaAdministrationList read GetAdministrationList;
    property hasAdministrationList : boolean read GetHasAdministrationList;

    // Typed access to The maximum total quantity of formula that may be administered to a subject over the period of time, e.g. 1440 mL over 24 hours. (defined for API consistency)
    property maxVolumeToDeliver : TFhirQuantity read FMaxVolumeToDeliver write SetMaxVolumeToDeliver;
    // The maximum total quantity of formula that may be administered to a subject over the period of time, e.g. 1440 mL over 24 hours.
    property maxVolumeToDeliverElement : TFhirQuantity read FMaxVolumeToDeliver write SetMaxVolumeToDeliver;

    // Typed access to Free text formula administration, feeding instructions or additional instructions or information.
    property administrationInstruction : String read GetAdministrationInstructionST write SetAdministrationInstructionST;
    // Free text formula administration, feeding instructions or additional instructions or information.
    property administrationInstructionElement : TFhirString read FAdministrationInstruction write SetAdministrationInstruction;

  end;

  TFhirNutritionOrderEnteralFormulaListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionOrderEnteralFormulaList;
    function GetCurrent : TFhirNutritionOrderEnteralFormula;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirNutritionOrderEnteralFormulaList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionOrderEnteralFormula read GetCurrent;
  end;

  TFhirNutritionOrderEnteralFormulaList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirNutritionOrderEnteralFormula;
    procedure SetItemN(index : Integer; value : TFhirNutritionOrderEnteralFormula);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirNutritionOrderEnteralFormulaList; Overload;
    function Clone : TFhirNutritionOrderEnteralFormulaList; Overload;
    function GetEnumerator : TFhirNutritionOrderEnteralFormulaListEnumerator;

    //  Add a FhirNutritionOrderEnteralFormula to the end of the list.
    function Append : TFhirNutritionOrderEnteralFormula;

    // Add an already existing FhirNutritionOrderEnteralFormula to the end of the list.
    procedure AddItem(value : TFhirNutritionOrderEnteralFormula); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionOrderEnteralFormula) : Integer;

    // Insert FhirNutritionOrderEnteralFormula before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionOrderEnteralFormula;

    // Insert an existing FhirNutritionOrderEnteralFormula before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionOrderEnteralFormula);

    // Get the iIndexth FhirNutritionOrderEnteralFormula. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionOrderEnteralFormula);

    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionOrderEnteralFormula;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirNutritionOrderEnteralFormulas[index : Integer] : TFhirNutritionOrderEnteralFormula read GetItemN write SetItemN; default;
  End;

  // Formula administration instructions as structured data.  This repeating structure allows for changing the administration rate or volume over time for both bolus and continuous feeding.  An example of this would be an instruction to increase the rate of continuous feeding every 2 hours.
  TFhirNutritionOrderEnteralFormulaAdministration = class (TFhirBackboneElement)
  protected
    FSchedule : TFhirTiming;
    FQuantity : TFhirQuantity;
    FRate : TFhirType;
    Procedure SetSchedule(value : TFhirTiming);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetRate(value : TFhirType);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionOrderEnteralFormulaAdministration; overload;
    function Clone : TFhirNutritionOrderEnteralFormulaAdministration; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The time period and frequency at which the enteral formula should be delivered to the patient. (defined for API consistency)
    property schedule : TFhirTiming read FSchedule write SetSchedule;
    // The time period and frequency at which the enteral formula should be delivered to the patient.
    property scheduleElement : TFhirTiming read FSchedule write SetSchedule;

    // Typed access to The volume of formula to provide to the patient per the specified administration schedule. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The volume of formula to provide to the patient per the specified administration schedule.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to The rate of administration of formula via a feeding pump, e.g. 60 mL per hour, according to the specified schedule. (defined for API consistency)
    property rate : TFhirType read FRate write SetRate;
    // The rate of administration of formula via a feeding pump, e.g. 60 mL per hour, according to the specified schedule.
    property rateElement : TFhirType read FRate write SetRate;

  end;

  TFhirNutritionOrderEnteralFormulaAdministrationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionOrderEnteralFormulaAdministrationList;
    function GetCurrent : TFhirNutritionOrderEnteralFormulaAdministration;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirNutritionOrderEnteralFormulaAdministrationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionOrderEnteralFormulaAdministration read GetCurrent;
  end;

  TFhirNutritionOrderEnteralFormulaAdministrationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirNutritionOrderEnteralFormulaAdministration;
    procedure SetItemN(index : Integer; value : TFhirNutritionOrderEnteralFormulaAdministration);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirNutritionOrderEnteralFormulaAdministrationList; Overload;
    function Clone : TFhirNutritionOrderEnteralFormulaAdministrationList; Overload;
    function GetEnumerator : TFhirNutritionOrderEnteralFormulaAdministrationListEnumerator;

    //  Add a FhirNutritionOrderEnteralFormulaAdministration to the end of the list.
    function Append : TFhirNutritionOrderEnteralFormulaAdministration;

    // Add an already existing FhirNutritionOrderEnteralFormulaAdministration to the end of the list.
    procedure AddItem(value : TFhirNutritionOrderEnteralFormulaAdministration); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionOrderEnteralFormulaAdministration) : Integer;

    // Insert FhirNutritionOrderEnteralFormulaAdministration before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionOrderEnteralFormulaAdministration;

    // Insert an existing FhirNutritionOrderEnteralFormulaAdministration before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionOrderEnteralFormulaAdministration);

    // Get the iIndexth FhirNutritionOrderEnteralFormulaAdministration. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionOrderEnteralFormulaAdministration);

    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionOrderEnteralFormulaAdministration;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirNutritionOrderEnteralFormulaAdministrations[index : Integer] : TFhirNutritionOrderEnteralFormulaAdministration read GetItemN write SetItemN; default;
  End;

  // A request to supply a diet, formula feeding (enteral) or oral nutritional supplement to a patient/resident.
  TFhirNutritionOrder = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FPatient : TFhirReference{TFhirPatient};
    FEncounter : TFhirReference{TFhirEncounter};
    FDateTime : TFhirDateTime;
    FOrderer : TFhirReference{TFhirPractitioner};
    FallergyIntoleranceList : TFhirReferenceList{TFhirAllergyIntolerance};
    FfoodPreferenceModifierList : TFhirCodeableConceptList;
    FexcludeFoodModifierList : TFhirCodeableConceptList;
    FOralDiet : TFhirNutritionOrderOralDiet;
    FsupplementList : TFhirNutritionOrderSupplementList;
    FEnteralFormula : TFhirNutritionOrderEnteralFormula;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirNutritionRequestStatusEnum;
    Procedure SetStatusST(value : TFhirNutritionRequestStatusEnum);
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    Procedure SetEncounter(value : TFhirReference{TFhirEncounter});
    Procedure SetDateTime(value : TFhirDateTime);
    Function GetDateTimeST : TFslDateTime;
    Procedure SetDateTimeST(value : TFslDateTime);
    Procedure SetOrderer(value : TFhirReference{TFhirPractitioner});
    function GetAllergyIntoleranceList : TFhirReferenceList{TFhirAllergyIntolerance};
    function GetHasAllergyIntoleranceList : Boolean;
    function GetFoodPreferenceModifierList : TFhirCodeableConceptList;
    function GetHasFoodPreferenceModifierList : Boolean;
    function GetExcludeFoodModifierList : TFhirCodeableConceptList;
    function GetHasExcludeFoodModifierList : Boolean;
    Procedure SetOralDiet(value : TFhirNutritionOrderOralDiet);
    function GetSupplementList : TFhirNutritionOrderSupplementList;
    function GetHasSupplementList : Boolean;
    Procedure SetEnteralFormula(value : TFhirNutritionOrderEnteralFormula);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionOrder; overload;
    function Clone : TFhirNutritionOrder; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Identifiers assigned to this order by the order sender or by the order receiver.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The workflow status of the nutrition order/request.
    property status : TFhirNutritionRequestStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The person (patient) who needs the nutrition order for an oral diet, nutritional supplement and/or enteral or formula feeding. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // The person (patient) who needs the nutrition order for an oral diet, nutritional supplement and/or enteral or formula feeding.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Typed access to An encounter that provides additional information about the healthcare context in which this request is made. (defined for API consistency)
    property encounter : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;
    // An encounter that provides additional information about the healthcare context in which this request is made.
    property encounterElement : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;

    // Typed access to The date and time that this nutrition order was requested.
    property dateTime : TFslDateTime read GetDateTimeST write SetDateTimeST;
    // The date and time that this nutrition order was requested.
    property dateTimeElement : TFhirDateTime read FDateTime write SetDateTime;

    // Typed access to The practitioner that holds legal responsibility for ordering the diet, nutritional supplement, or formula feedings. (defined for API consistency)
    property orderer : TFhirReference{TFhirPractitioner} read FOrderer write SetOrderer;
    // The practitioner that holds legal responsibility for ordering the diet, nutritional supplement, or formula feedings.
    property ordererElement : TFhirReference{TFhirPractitioner} read FOrderer write SetOrderer;

    // A link to a record of allergies or intolerances  which should be included in the nutrition order.
    property allergyIntoleranceList : TFhirReferenceList{TFhirAllergyIntolerance} read GetAllergyIntoleranceList;
    property hasAllergyIntoleranceList : boolean read GetHasAllergyIntoleranceList;

    // This modifier is used to convey order-specific modifiers about the type of food that should be given. These can be derived from patient allergies, intolerances, or preferences such as Halal, Vegan or Kosher. This modifier applies to the entire nutrition order inclusive of the oral diet, nutritional supplements and enteral formula feedings.
    property foodPreferenceModifierList : TFhirCodeableConceptList read GetFoodPreferenceModifierList;
    property hasFoodPreferenceModifierList : boolean read GetHasFoodPreferenceModifierList;

    // This modifier is used to convey order-specific modifiers about the type of food that should NOT be given. These can be derived from patient allergies, intolerances, or preferences such as No Red Meat, No Soy or No Wheat or  Gluten-Free.  While it should not be necessary to repeat allergy or intolerance information captured in the referenced AllergyIntolerance resource in the excludeFoodModifier, this element may be used to convey additional specificity related to foods that should be eliminated from the patient?s diet for any reason.  This modifier applies to the entire nutrition order inclusive of the oral diet, nutritional supplements and enteral formula feedings.
    property excludeFoodModifierList : TFhirCodeableConceptList read GetExcludeFoodModifierList;
    property hasExcludeFoodModifierList : boolean read GetHasExcludeFoodModifierList;

    // Typed access to Diet given orally in contrast to enteral (tube) feeding. (defined for API consistency)
    property oralDiet : TFhirNutritionOrderOralDiet read FOralDiet write SetOralDiet;
    // Diet given orally in contrast to enteral (tube) feeding.
    property oralDietElement : TFhirNutritionOrderOralDiet read FOralDiet write SetOralDiet;

    // Oral nutritional products given in order to add further nutritional value to the patient's diet.
    property supplementList : TFhirNutritionOrderSupplementList read GetSupplementList;
    property hasSupplementList : boolean read GetHasSupplementList;

    // Typed access to Feeding provided through the gastrointestinal tract via a tube, catheter, or stoma that delivers nutrition distal to the oral cavity. (defined for API consistency)
    property enteralFormula : TFhirNutritionOrderEnteralFormula read FEnteralFormula write SetEnteralFormula;
    // Feeding provided through the gastrointestinal tract via a tube, catheter, or stoma that delivers nutrition distal to the oral cavity.
    property enteralFormulaElement : TFhirNutritionOrderEnteralFormula read FEnteralFormula write SetEnteralFormula;

  end;

  TFhirNutritionOrderListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionOrderList;
    function GetCurrent : TFhirNutritionOrder;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirNutritionOrderList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionOrder read GetCurrent;
  end;

  TFhirNutritionOrderList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirNutritionOrder;
    procedure SetItemN(index : Integer; value : TFhirNutritionOrder);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirNutritionOrderList; Overload;
    function Clone : TFhirNutritionOrderList; Overload;
    function GetEnumerator : TFhirNutritionOrderListEnumerator;

    //  Add a FhirNutritionOrder to the end of the list.
    function Append : TFhirNutritionOrder;

    // Add an already existing FhirNutritionOrder to the end of the list.
    procedure AddItem(value : TFhirNutritionOrder); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionOrder) : Integer;

    // Insert FhirNutritionOrder before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionOrder;

    // Insert an existing FhirNutritionOrder before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionOrder);

    // Get the iIndexth FhirNutritionOrder. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionOrder);

    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionOrder;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirNutritionOrders[index : Integer] : TFhirNutritionOrder read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_NUTRITIONORDER}

{$IFDEF FHIR_OBSERVATION}

  // Guidance on how to interpret the value by comparison to a normal or recommended range.
  TFhirObservationReferenceRange = class (TFhirBackboneElement)
  protected
    FLow : TFhirQuantity;
    FHigh : TFhirQuantity;
    FType_ : TFhirCodeableConcept;
    FappliesToList : TFhirCodeableConceptList;
    FAge : TFhirRange;
    FText : TFhirString;
    Procedure SetLow(value : TFhirQuantity);
    Procedure SetHigh(value : TFhirQuantity);
    Procedure SetType_(value : TFhirCodeableConcept);
    function GetAppliesToList : TFhirCodeableConceptList;
    function GetHasAppliesToList : Boolean;
    Procedure SetAge(value : TFhirRange);
    Procedure SetText(value : TFhirString);
    Function GetTextST : String;
    Procedure SetTextST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirObservationReferenceRange; overload;
    function Clone : TFhirObservationReferenceRange; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The value of the low bound of the reference range.  The low bound of the reference range endpoint is inclusive of the value (e.g.  reference range is >=5 - <=9).   If the low bound is omitted,  it is assumed to be meaningless (e.g. reference range is <=2.3). (defined for API consistency)
    property low : TFhirQuantity read FLow write SetLow;
    // The value of the low bound of the reference range.  The low bound of the reference range endpoint is inclusive of the value (e.g.  reference range is >=5 - <=9).   If the low bound is omitted,  it is assumed to be meaningless (e.g. reference range is <=2.3).
    property lowElement : TFhirQuantity read FLow write SetLow;

    // Typed access to The value of the high bound of the reference range.  The high bound of the reference range endpoint is inclusive of the value (e.g.  reference range is >=5 - <=9).   If the high bound is omitted,  it is assumed to be meaningless (e.g. reference range is >= 2.3). (defined for API consistency)
    property high : TFhirQuantity read FHigh write SetHigh;
    // The value of the high bound of the reference range.  The high bound of the reference range endpoint is inclusive of the value (e.g.  reference range is >=5 - <=9).   If the high bound is omitted,  it is assumed to be meaningless (e.g. reference range is >= 2.3).
    property highElement : TFhirQuantity read FHigh write SetHigh;

    // Typed access to Codes to indicate the what part of the targeted reference population it applies to. For example, the normal or therapeutic range. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Codes to indicate the what part of the targeted reference population it applies to. For example, the normal or therapeutic range.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Codes to indicate the target population this reference range applies to.  For example, a reference range may be based on the normal population or a particular sex or race.
    property appliesToList : TFhirCodeableConceptList read GetAppliesToList;
    property hasAppliesToList : boolean read GetHasAppliesToList;

    // Typed access to The age at which this reference range is applicable. This is a neonatal age (e.g. number of weeks at term) if the meaning says so. (defined for API consistency)
    property age : TFhirRange read FAge write SetAge;
    // The age at which this reference range is applicable. This is a neonatal age (e.g. number of weeks at term) if the meaning says so.
    property ageElement : TFhirRange read FAge write SetAge;

    // Typed access to Text based reference range in an observation which may be used when a quantitative range is not appropriate for an observation.  An example would be a reference value of "Negative" or a list or table of 'normals'.
    property text : String read GetTextST write SetTextST;
    // Text based reference range in an observation which may be used when a quantitative range is not appropriate for an observation.  An example would be a reference value of "Negative" or a list or table of 'normals'.
    property textElement : TFhirString read FText write SetText;

  end;

  TFhirObservationReferenceRangeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirObservationReferenceRangeList;
    function GetCurrent : TFhirObservationReferenceRange;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirObservationReferenceRangeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirObservationReferenceRange read GetCurrent;
  end;

  TFhirObservationReferenceRangeList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirObservationReferenceRange;
    procedure SetItemN(index : Integer; value : TFhirObservationReferenceRange);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirObservationReferenceRangeList; Overload;
    function Clone : TFhirObservationReferenceRangeList; Overload;
    function GetEnumerator : TFhirObservationReferenceRangeListEnumerator;

    //  Add a FhirObservationReferenceRange to the end of the list.
    function Append : TFhirObservationReferenceRange;

    // Add an already existing FhirObservationReferenceRange to the end of the list.
    procedure AddItem(value : TFhirObservationReferenceRange); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirObservationReferenceRange) : Integer;

    // Insert FhirObservationReferenceRange before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirObservationReferenceRange;

    // Insert an existing FhirObservationReferenceRange before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirObservationReferenceRange);

    // Get the iIndexth FhirObservationReferenceRange. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirObservationReferenceRange);

    // The number of items in the collection
    function Item(index : Integer) : TFhirObservationReferenceRange;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirObservationReferenceRanges[index : Integer] : TFhirObservationReferenceRange read GetItemN write SetItemN; default;
  End;

  // A  reference to another resource (usually another Observation) whose relationship is defined by the relationship type code.
  TFhirObservationRelated = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FTarget : TFhirReference{Resource};
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirObservationRelationshiptypesEnum;
    Procedure SetType_ST(value : TFhirObservationRelationshiptypesEnum);
    Procedure SetTarget(value : TFhirReference{Resource});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirObservationRelated; overload;
    function Clone : TFhirObservationRelated; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // A code specifying the kind of relationship that exists with the target resource.
    property type_ : TFhirObservationRelationshiptypesEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to A reference to the observation or [QuestionnaireResponse](questionnaireresponse.html#) resource that is related to this observation. (defined for API consistency)
    property target : TFhirReference{Resource} read FTarget write SetTarget;
    // A reference to the observation or [QuestionnaireResponse](questionnaireresponse.html#) resource that is related to this observation.
    property targetElement : TFhirReference{Resource} read FTarget write SetTarget;

  end;

  TFhirObservationRelatedListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirObservationRelatedList;
    function GetCurrent : TFhirObservationRelated;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirObservationRelatedList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirObservationRelated read GetCurrent;
  end;

  TFhirObservationRelatedList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirObservationRelated;
    procedure SetItemN(index : Integer; value : TFhirObservationRelated);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirObservationRelatedList; Overload;
    function Clone : TFhirObservationRelatedList; Overload;
    function GetEnumerator : TFhirObservationRelatedListEnumerator;

    //  Add a FhirObservationRelated to the end of the list.
    function Append : TFhirObservationRelated;

    // Add an already existing FhirObservationRelated to the end of the list.
    procedure AddItem(value : TFhirObservationRelated); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirObservationRelated) : Integer;

    // Insert FhirObservationRelated before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirObservationRelated;

    // Insert an existing FhirObservationRelated before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirObservationRelated);

    // Get the iIndexth FhirObservationRelated. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirObservationRelated);

    // The number of items in the collection
    function Item(index : Integer) : TFhirObservationRelated;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirObservationRelateds[index : Integer] : TFhirObservationRelated read GetItemN write SetItemN; default;
  End;

  // Some observations have multiple component observations.  These component observations are expressed as separate code value pairs that share the same attributes.  Examples include systolic and diastolic component observations for blood pressure measurement and multiple component observations for genetics observations.
  TFhirObservationComponent = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FValue : TFhirType;
    FDataAbsentReason : TFhirCodeableConcept;
    FInterpretation : TFhirCodeableConcept;
    FreferenceRangeList : TFhirObservationReferenceRangeList;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetValue(value : TFhirType);
    Procedure SetDataAbsentReason(value : TFhirCodeableConcept);
    Procedure SetInterpretation(value : TFhirCodeableConcept);
    function GetReferenceRangeList : TFhirObservationReferenceRangeList;
    function GetHasReferenceRangeList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirObservationComponent; overload;
    function Clone : TFhirObservationComponent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Describes what was observed. Sometimes this is called the observation "code". (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Describes what was observed. Sometimes this is called the observation "code".
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The information determined as a result of making the observation, if the information has a simple value. (defined for API consistency)
    property value : TFhirType read FValue write SetValue;
    // The information determined as a result of making the observation, if the information has a simple value.
    property valueElement : TFhirType read FValue write SetValue;

    // Typed access to Provides a reason why the expected value in the element Observation.value[x] is missing. (defined for API consistency)
    property dataAbsentReason : TFhirCodeableConcept read FDataAbsentReason write SetDataAbsentReason;
    // Provides a reason why the expected value in the element Observation.value[x] is missing.
    property dataAbsentReasonElement : TFhirCodeableConcept read FDataAbsentReason write SetDataAbsentReason;

    // Typed access to The assessment made based on the result of the observation.  Intended as a simple compact code often placed adjacent to the result value in reports and flow sheets to signal the meaning/normalcy status of the result. Otherwise known as abnormal flag. (defined for API consistency)
    property interpretation : TFhirCodeableConcept read FInterpretation write SetInterpretation;
    // The assessment made based on the result of the observation.  Intended as a simple compact code often placed adjacent to the result value in reports and flow sheets to signal the meaning/normalcy status of the result. Otherwise known as abnormal flag.
    property interpretationElement : TFhirCodeableConcept read FInterpretation write SetInterpretation;

    // Guidance on how to interpret the value by comparison to a normal or recommended range.
    property referenceRangeList : TFhirObservationReferenceRangeList read GetReferenceRangeList;
    property hasReferenceRangeList : boolean read GetHasReferenceRangeList;

  end;

  TFhirObservationComponentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirObservationComponentList;
    function GetCurrent : TFhirObservationComponent;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirObservationComponentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirObservationComponent read GetCurrent;
  end;

  TFhirObservationComponentList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirObservationComponent;
    procedure SetItemN(index : Integer; value : TFhirObservationComponent);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirObservationComponentList; Overload;
    function Clone : TFhirObservationComponentList; Overload;
    function GetEnumerator : TFhirObservationComponentListEnumerator;

    //  Add a FhirObservationComponent to the end of the list.
    function Append : TFhirObservationComponent;

    // Add an already existing FhirObservationComponent to the end of the list.
    procedure AddItem(value : TFhirObservationComponent); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirObservationComponent) : Integer;

    // Insert FhirObservationComponent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirObservationComponent;

    // Insert an existing FhirObservationComponent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirObservationComponent);

    // Get the iIndexth FhirObservationComponent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirObservationComponent);

    // The number of items in the collection
    function Item(index : Integer) : TFhirObservationComponent;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirObservationComponents[index : Integer] : TFhirObservationComponent read GetItemN write SetItemN; default;
  End;

  // Measurements and simple assertions made about a patient, device or other subject.
  TFhirObservation = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FbasedOnList : TFhirReferenceList{Resource};
    FStatus : TFhirEnum;
    FcategoryList : TFhirCodeableConceptList;
    FCode : TFhirCodeableConcept;
    FSubject : TFhirReference{Resource};
    FContext : TFhirReference{Resource};
    FEffective : TFhirType;
    FIssued : TFhirInstant;
    FperformerList : TFhirReferenceList{Resource};
    FValue : TFhirType;
    FDataAbsentReason : TFhirCodeableConcept;
    FInterpretation : TFhirCodeableConcept;
    FComment : TFhirString;
    FBodySite : TFhirCodeableConcept;
    FMethod : TFhirCodeableConcept;
    FSpecimen : TFhirReference{TFhirSpecimen};
    FDevice : TFhirReference{Resource};
    FreferenceRangeList : TFhirObservationReferenceRangeList;
    FrelatedList : TFhirObservationRelatedList;
    FcomponentList : TFhirObservationComponentList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetBasedOnList : TFhirReferenceList{Resource};
    function GetHasBasedOnList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirObservationStatusEnum;
    Procedure SetStatusST(value : TFhirObservationStatusEnum);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetSubject(value : TFhirReference{Resource});
    Procedure SetContext(value : TFhirReference{Resource});
    Procedure SetEffective(value : TFhirType);
    Procedure SetIssued(value : TFhirInstant);
    Function GetIssuedST : TFslDateTime;
    Procedure SetIssuedST(value : TFslDateTime);
    function GetPerformerList : TFhirReferenceList{Resource};
    function GetHasPerformerList : Boolean;
    Procedure SetValue(value : TFhirType);
    Procedure SetDataAbsentReason(value : TFhirCodeableConcept);
    Procedure SetInterpretation(value : TFhirCodeableConcept);
    Procedure SetComment(value : TFhirString);
    Function GetCommentST : String;
    Procedure SetCommentST(value : String);
    Procedure SetBodySite(value : TFhirCodeableConcept);
    Procedure SetMethod(value : TFhirCodeableConcept);
    Procedure SetSpecimen(value : TFhirReference{TFhirSpecimen});
    Procedure SetDevice(value : TFhirReference{Resource});
    function GetReferenceRangeList : TFhirObservationReferenceRangeList;
    function GetHasReferenceRangeList : Boolean;
    function GetRelatedList : TFhirObservationRelatedList;
    function GetHasRelatedList : Boolean;
    function GetComponentList : TFhirObservationComponentList;
    function GetHasComponentList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirObservation; overload;
    function Clone : TFhirObservation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // A unique identifier assigned to this observation.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A plan, proposal or order that is fulfilled in whole or in part by this event.
    property basedOnList : TFhirReferenceList{Resource} read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // The status of the result value.
    property status : TFhirObservationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // A code that classifies the general type of observation being made.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to Describes what was observed. Sometimes this is called the observation "name". (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Describes what was observed. Sometimes this is called the observation "name".
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The patient, or group of patients, location, or device whose characteristics (direct or indirect) are described by the observation and into whose record the observation is placed.  Comments: Indirect characteristics may be those of a specimen, fetus, donor,  other observer (for example a relative or EMT), or any observation made about the subject. (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // The patient, or group of patients, location, or device whose characteristics (direct or indirect) are described by the observation and into whose record the observation is placed.  Comments: Indirect characteristics may be those of a specimen, fetus, donor,  other observer (for example a relative or EMT), or any observation made about the subject.
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // Typed access to The healthcare event  (e.g. a patient and healthcare provider interaction) during which this observation is made. (defined for API consistency)
    property context : TFhirReference{Resource} read FContext write SetContext;
    // The healthcare event  (e.g. a patient and healthcare provider interaction) during which this observation is made.
    property contextElement : TFhirReference{Resource} read FContext write SetContext;

    // Typed access to The time or time-period the observed value is asserted as being true. For biological subjects - e.g. human patients - this is usually called the "physiologically relevant time". This is usually either the time of the procedure or of specimen collection, but very often the source of the date/time is not known, only the date/time itself. (defined for API consistency)
    property effective : TFhirType read FEffective write SetEffective;
    // The time or time-period the observed value is asserted as being true. For biological subjects - e.g. human patients - this is usually called the "physiologically relevant time". This is usually either the time of the procedure or of specimen collection, but very often the source of the date/time is not known, only the date/time itself.
    property effectiveElement : TFhirType read FEffective write SetEffective;

    // Typed access to The date and time this observation was made available to providers, typically after the results have been reviewed and verified.
    property issued : TFslDateTime read GetIssuedST write SetIssuedST;
    // The date and time this observation was made available to providers, typically after the results have been reviewed and verified.
    property issuedElement : TFhirInstant read FIssued write SetIssued;

    // Who was responsible for asserting the observed value as "true".
    property performerList : TFhirReferenceList{Resource} read GetPerformerList;
    property hasPerformerList : boolean read GetHasPerformerList;

    // Typed access to The information determined as a result of making the observation, if the information has a simple value. (defined for API consistency)
    property value : TFhirType read FValue write SetValue;
    // The information determined as a result of making the observation, if the information has a simple value.
    property valueElement : TFhirType read FValue write SetValue;

    // Typed access to Provides a reason why the expected value in the element Observation.value[x] is missing. (defined for API consistency)
    property dataAbsentReason : TFhirCodeableConcept read FDataAbsentReason write SetDataAbsentReason;
    // Provides a reason why the expected value in the element Observation.value[x] is missing.
    property dataAbsentReasonElement : TFhirCodeableConcept read FDataAbsentReason write SetDataAbsentReason;

    // Typed access to The assessment made based on the result of the observation.  Intended as a simple compact code often placed adjacent to the result value in reports and flow sheets to signal the meaning/normalcy status of the result. Otherwise known as abnormal flag. (defined for API consistency)
    property interpretation : TFhirCodeableConcept read FInterpretation write SetInterpretation;
    // The assessment made based on the result of the observation.  Intended as a simple compact code often placed adjacent to the result value in reports and flow sheets to signal the meaning/normalcy status of the result. Otherwise known as abnormal flag.
    property interpretationElement : TFhirCodeableConcept read FInterpretation write SetInterpretation;

    // Typed access to May include statements about significant, unexpected or unreliable values, or information about the source of the value where this may be relevant to the interpretation of the result.
    property comment : String read GetCommentST write SetCommentST;
    // May include statements about significant, unexpected or unreliable values, or information about the source of the value where this may be relevant to the interpretation of the result.
    property commentElement : TFhirString read FComment write SetComment;

    // Typed access to Indicates the site on the subject's body where the observation was made (i.e. the target site). (defined for API consistency)
    property bodySite : TFhirCodeableConcept read FBodySite write SetBodySite;
    // Indicates the site on the subject's body where the observation was made (i.e. the target site).
    property bodySiteElement : TFhirCodeableConcept read FBodySite write SetBodySite;

    // Typed access to Indicates the mechanism used to perform the observation. (defined for API consistency)
    property method : TFhirCodeableConcept read FMethod write SetMethod;
    // Indicates the mechanism used to perform the observation.
    property methodElement : TFhirCodeableConcept read FMethod write SetMethod;

    // Typed access to The specimen that was used when this observation was made. (defined for API consistency)
    property specimen : TFhirReference{TFhirSpecimen} read FSpecimen write SetSpecimen;
    // The specimen that was used when this observation was made.
    property specimenElement : TFhirReference{TFhirSpecimen} read FSpecimen write SetSpecimen;

    // Typed access to The device used to generate the observation data. (defined for API consistency)
    property device : TFhirReference{Resource} read FDevice write SetDevice;
    // The device used to generate the observation data.
    property deviceElement : TFhirReference{Resource} read FDevice write SetDevice;

    // Guidance on how to interpret the value by comparison to a normal or recommended range.
    property referenceRangeList : TFhirObservationReferenceRangeList read GetReferenceRangeList;
    property hasReferenceRangeList : boolean read GetHasReferenceRangeList;

    // A  reference to another resource (usually another Observation) whose relationship is defined by the relationship type code.
    property relatedList : TFhirObservationRelatedList read GetRelatedList;
    property hasRelatedList : boolean read GetHasRelatedList;

    // Some observations have multiple component observations.  These component observations are expressed as separate code value pairs that share the same attributes.  Examples include systolic and diastolic component observations for blood pressure measurement and multiple component observations for genetics observations.
    property componentList : TFhirObservationComponentList read GetComponentList;
    property hasComponentList : boolean read GetHasComponentList;

  end;

  TFhirObservationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirObservationList;
    function GetCurrent : TFhirObservation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirObservationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirObservation read GetCurrent;
  end;

  TFhirObservationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirObservation;
    procedure SetItemN(index : Integer; value : TFhirObservation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirObservationList; Overload;
    function Clone : TFhirObservationList; Overload;
    function GetEnumerator : TFhirObservationListEnumerator;

    //  Add a FhirObservation to the end of the list.
    function Append : TFhirObservation;

    // Add an already existing FhirObservation to the end of the list.
    procedure AddItem(value : TFhirObservation); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirObservation) : Integer;

    // Insert FhirObservation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirObservation;

    // Insert an existing FhirObservation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirObservation);

    // Get the iIndexth FhirObservation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirObservation);

    // The number of items in the collection
    function Item(index : Integer) : TFhirObservation;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirObservations[index : Integer] : TFhirObservation read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_OBSERVATION}

{$IFDEF FHIR_PROCEDURE}

  // Limited to 'real' people rather than equipment.
  TFhirProcedurePerformer = class (TFhirBackboneElement)
  protected
    FRole : TFhirCodeableConcept;
    FActor : TFhirReference{Resource};
    FOnBehalfOf : TFhirReference{TFhirOrganization};
    Procedure SetRole(value : TFhirCodeableConcept);
    Procedure SetActor(value : TFhirReference{Resource});
    Procedure SetOnBehalfOf(value : TFhirReference{TFhirOrganization});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirProcedurePerformer; overload;
    function Clone : TFhirProcedurePerformer; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to For example: surgeon, anaethetist, endoscopist. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // For example: surgeon, anaethetist, endoscopist.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

    // Typed access to The practitioner who was involved in the procedure. (defined for API consistency)
    property actor : TFhirReference{Resource} read FActor write SetActor;
    // The practitioner who was involved in the procedure.
    property actorElement : TFhirReference{Resource} read FActor write SetActor;

    // Typed access to The organization the device or practitioner was acting on behalf of. (defined for API consistency)
    property onBehalfOf : TFhirReference{TFhirOrganization} read FOnBehalfOf write SetOnBehalfOf;
    // The organization the device or practitioner was acting on behalf of.
    property onBehalfOfElement : TFhirReference{TFhirOrganization} read FOnBehalfOf write SetOnBehalfOf;

  end;

  TFhirProcedurePerformerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirProcedurePerformerList;
    function GetCurrent : TFhirProcedurePerformer;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirProcedurePerformerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProcedurePerformer read GetCurrent;
  end;

  TFhirProcedurePerformerList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirProcedurePerformer;
    procedure SetItemN(index : Integer; value : TFhirProcedurePerformer);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirProcedurePerformerList; Overload;
    function Clone : TFhirProcedurePerformerList; Overload;
    function GetEnumerator : TFhirProcedurePerformerListEnumerator;

    //  Add a FhirProcedurePerformer to the end of the list.
    function Append : TFhirProcedurePerformer;

    // Add an already existing FhirProcedurePerformer to the end of the list.
    procedure AddItem(value : TFhirProcedurePerformer); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirProcedurePerformer) : Integer;

    // Insert FhirProcedurePerformer before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirProcedurePerformer;

    // Insert an existing FhirProcedurePerformer before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirProcedurePerformer);

    // Get the iIndexth FhirProcedurePerformer. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirProcedurePerformer);

    // The number of items in the collection
    function Item(index : Integer) : TFhirProcedurePerformer;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirProcedurePerformers[index : Integer] : TFhirProcedurePerformer read GetItemN write SetItemN; default;
  End;

  // A device that is implanted, removed or otherwise manipulated (calibration, battery replacement, fitting a prosthesis, attaching a wound-vac, etc.) as a focal portion of the Procedure.
  TFhirProcedureFocalDevice = class (TFhirBackboneElement)
  protected
    FAction : TFhirCodeableConcept;
    FManipulated : TFhirReference{TFhirDevice};
    Procedure SetAction(value : TFhirCodeableConcept);
    Procedure SetManipulated(value : TFhirReference{TFhirDevice});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirProcedureFocalDevice; overload;
    function Clone : TFhirProcedureFocalDevice; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The kind of change that happened to the device during the procedure. (defined for API consistency)
    property action : TFhirCodeableConcept read FAction write SetAction;
    // The kind of change that happened to the device during the procedure.
    property actionElement : TFhirCodeableConcept read FAction write SetAction;

    // Typed access to The device that was manipulated (changed) during the procedure. (defined for API consistency)
    property manipulated : TFhirReference{TFhirDevice} read FManipulated write SetManipulated;
    // The device that was manipulated (changed) during the procedure.
    property manipulatedElement : TFhirReference{TFhirDevice} read FManipulated write SetManipulated;

  end;

  TFhirProcedureFocalDeviceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirProcedureFocalDeviceList;
    function GetCurrent : TFhirProcedureFocalDevice;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirProcedureFocalDeviceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProcedureFocalDevice read GetCurrent;
  end;

  TFhirProcedureFocalDeviceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirProcedureFocalDevice;
    procedure SetItemN(index : Integer; value : TFhirProcedureFocalDevice);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirProcedureFocalDeviceList; Overload;
    function Clone : TFhirProcedureFocalDeviceList; Overload;
    function GetEnumerator : TFhirProcedureFocalDeviceListEnumerator;

    //  Add a FhirProcedureFocalDevice to the end of the list.
    function Append : TFhirProcedureFocalDevice;

    // Add an already existing FhirProcedureFocalDevice to the end of the list.
    procedure AddItem(value : TFhirProcedureFocalDevice); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirProcedureFocalDevice) : Integer;

    // Insert FhirProcedureFocalDevice before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirProcedureFocalDevice;

    // Insert an existing FhirProcedureFocalDevice before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirProcedureFocalDevice);

    // Get the iIndexth FhirProcedureFocalDevice. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirProcedureFocalDevice);

    // The number of items in the collection
    function Item(index : Integer) : TFhirProcedureFocalDevice;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirProcedureFocalDevices[index : Integer] : TFhirProcedureFocalDevice read GetItemN write SetItemN; default;
  End;

  // An action that is or was performed on a patient. This can be a physical intervention like an operation, or less invasive like counseling or hypnotherapy.
  TFhirProcedure = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FdefinitionList : TFhirReferenceList{Resource};
    FbasedOnList : TFhirReferenceList{Resource};
    FpartOfList : TFhirReferenceList{Resource};
    FStatus : TFhirEnum;
    FNotDone : TFhirBoolean;
    FNotDoneReason : TFhirCodeableConcept;
    FCategory : TFhirCodeableConcept;
    FCode : TFhirCodeableConcept;
    FSubject : TFhirReference{Resource};
    FContext : TFhirReference{Resource};
    FPerformed : TFhirType;
    FperformerList : TFhirProcedurePerformerList;
    FLocation : TFhirReference{TFhirLocation};
    FreasonCodeList : TFhirCodeableConceptList;
    FreasonReferenceList : TFhirReferenceList{Resource};
    FbodySiteList : TFhirCodeableConceptList;
    FOutcome : TFhirCodeableConcept;
    FreportList : TFhirReferenceList{TFhirDiagnosticReport};
    FcomplicationList : TFhirCodeableConceptList;
    FcomplicationDetailList : TFhirReferenceList{TFhirCondition};
    FfollowUpList : TFhirCodeableConceptList;
    FnoteList : TFhirAnnotationList;
    FfocalDeviceList : TFhirProcedureFocalDeviceList;
    FusedReferenceList : TFhirReferenceList{Resource};
    FusedCodeList : TFhirCodeableConceptList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetDefinitionList : TFhirReferenceList{Resource};
    function GetHasDefinitionList : Boolean;
    function GetBasedOnList : TFhirReferenceList{Resource};
    function GetHasBasedOnList : Boolean;
    function GetPartOfList : TFhirReferenceList{Resource};
    function GetHasPartOfList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirEventStatusEnum;
    Procedure SetStatusST(value : TFhirEventStatusEnum);
    Procedure SetNotDone(value : TFhirBoolean);
    Function GetNotDoneST : Boolean;
    Procedure SetNotDoneST(value : Boolean);
    Procedure SetNotDoneReason(value : TFhirCodeableConcept);
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetSubject(value : TFhirReference{Resource});
    Procedure SetContext(value : TFhirReference{Resource});
    Procedure SetPerformed(value : TFhirType);
    function GetPerformerList : TFhirProcedurePerformerList;
    function GetHasPerformerList : Boolean;
    Procedure SetLocation(value : TFhirReference{TFhirLocation});
    function GetReasonCodeList : TFhirCodeableConceptList;
    function GetHasReasonCodeList : Boolean;
    function GetReasonReferenceList : TFhirReferenceList{Resource};
    function GetHasReasonReferenceList : Boolean;
    function GetBodySiteList : TFhirCodeableConceptList;
    function GetHasBodySiteList : Boolean;
    Procedure SetOutcome(value : TFhirCodeableConcept);
    function GetReportList : TFhirReferenceList{TFhirDiagnosticReport};
    function GetHasReportList : Boolean;
    function GetComplicationList : TFhirCodeableConceptList;
    function GetHasComplicationList : Boolean;
    function GetComplicationDetailList : TFhirReferenceList{TFhirCondition};
    function GetHasComplicationDetailList : Boolean;
    function GetFollowUpList : TFhirCodeableConceptList;
    function GetHasFollowUpList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetFocalDeviceList : TFhirProcedureFocalDeviceList;
    function GetHasFocalDeviceList : Boolean;
    function GetUsedReferenceList : TFhirReferenceList{Resource};
    function GetHasUsedReferenceList : Boolean;
    function GetUsedCodeList : TFhirCodeableConceptList;
    function GetHasUsedCodeList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirProcedure; overload;
    function Clone : TFhirProcedure; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // This records identifiers associated with this procedure that are defined by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate (e.g. in CDA documents, or in written / printed documentation).
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A protocol, guideline, orderset or other definition that was adhered to in whole or in part by this procedure.
    property definitionList : TFhirReferenceList{Resource} read GetDefinitionList;
    property hasDefinitionList : boolean read GetHasDefinitionList;

    // A reference to a resource that contains details of the request for this procedure.
    property basedOnList : TFhirReferenceList{Resource} read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // A larger event of which this particular procedure is a component or step.
    property partOfList : TFhirReferenceList{Resource} read GetPartOfList;
    property hasPartOfList : boolean read GetHasPartOfList;

    // A code specifying the state of the procedure. Generally this will be in-progress or completed state.
    property status : TFhirEventStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Set this to true if the record is saying that the procedure was NOT performed.
    property notDone : Boolean read GetNotDoneST write SetNotDoneST;
    // Set this to true if the record is saying that the procedure was NOT performed.
    property notDoneElement : TFhirBoolean read FNotDone write SetNotDone;

    // Typed access to A code indicating why the procedure was not performed. (defined for API consistency)
    property notDoneReason : TFhirCodeableConcept read FNotDoneReason write SetNotDoneReason;
    // A code indicating why the procedure was not performed.
    property notDoneReasonElement : TFhirCodeableConcept read FNotDoneReason write SetNotDoneReason;

    // Typed access to A code that classifies the procedure for searching, sorting and display purposes (e.g. "Surgical Procedure"). (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // A code that classifies the procedure for searching, sorting and display purposes (e.g. "Surgical Procedure").
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to The specific procedure that is performed. Use text if the exact nature of the procedure cannot be coded (e.g. "Laparoscopic Appendectomy"). (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The specific procedure that is performed. Use text if the exact nature of the procedure cannot be coded (e.g. "Laparoscopic Appendectomy").
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The person, animal or group on which the procedure was performed. (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // The person, animal or group on which the procedure was performed.
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // Typed access to The encounter during which the procedure was performed. (defined for API consistency)
    property context : TFhirReference{Resource} read FContext write SetContext;
    // The encounter during which the procedure was performed.
    property contextElement : TFhirReference{Resource} read FContext write SetContext;

    // Typed access to The date(time)/period over which the procedure was performed. Allows a period to support complex procedures that span more than one date, and also allows for the length of the procedure to be captured. (defined for API consistency)
    property performed : TFhirType read FPerformed write SetPerformed;
    // The date(time)/period over which the procedure was performed. Allows a period to support complex procedures that span more than one date, and also allows for the length of the procedure to be captured.
    property performedElement : TFhirType read FPerformed write SetPerformed;

    // Limited to 'real' people rather than equipment.
    property performerList : TFhirProcedurePerformerList read GetPerformerList;
    property hasPerformerList : boolean read GetHasPerformerList;

    // Typed access to The location where the procedure actually happened.  E.g. a newborn at home, a tracheostomy at a restaurant. (defined for API consistency)
    property location : TFhirReference{TFhirLocation} read FLocation write SetLocation;
    // The location where the procedure actually happened.  E.g. a newborn at home, a tracheostomy at a restaurant.
    property locationElement : TFhirReference{TFhirLocation} read FLocation write SetLocation;

    // The coded reason why the procedure was performed. This may be coded entity of some type, or may simply be present as text.
    property reasonCodeList : TFhirCodeableConceptList read GetReasonCodeList;
    property hasReasonCodeList : boolean read GetHasReasonCodeList;

    // The condition that is the reason why the procedure was performed.
    property reasonReferenceList : TFhirReferenceList{Resource} read GetReasonReferenceList;
    property hasReasonReferenceList : boolean read GetHasReasonReferenceList;

    // Detailed and structured anatomical location information. Multiple locations are allowed - e.g. multiple punch biopsies of a lesion.
    property bodySiteList : TFhirCodeableConceptList read GetBodySiteList;
    property hasBodySiteList : boolean read GetHasBodySiteList;

    // Typed access to The outcome of the procedure - did it resolve reasons for the procedure being performed? (defined for API consistency)
    property outcome : TFhirCodeableConcept read FOutcome write SetOutcome;
    // The outcome of the procedure - did it resolve reasons for the procedure being performed?
    property outcomeElement : TFhirCodeableConcept read FOutcome write SetOutcome;

    // This could be a histology result, pathology report, surgical report, etc..
    property reportList : TFhirReferenceList{TFhirDiagnosticReport} read GetReportList;
    property hasReportList : boolean read GetHasReportList;

    // Any complications that occurred during the procedure, or in the immediate post-performance period. These are generally tracked separately from the notes, which will typically describe the procedure itself rather than any 'post procedure' issues.
    property complicationList : TFhirCodeableConceptList read GetComplicationList;
    property hasComplicationList : boolean read GetHasComplicationList;

    // Any complications that occurred during the procedure, or in the immediate post-performance period.
    property complicationDetailList : TFhirReferenceList{TFhirCondition} read GetComplicationDetailList;
    property hasComplicationDetailList : boolean read GetHasComplicationDetailList;

    // If the procedure required specific follow up - e.g. removal of sutures. The followup may be represented as a simple note, or could potentially be more complex in which case the CarePlan resource can be used.
    property followUpList : TFhirCodeableConceptList read GetFollowUpList;
    property hasFollowUpList : boolean read GetHasFollowUpList;

    // Any other notes about the procedure.  E.g. the operative notes.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // A device that is implanted, removed or otherwise manipulated (calibration, battery replacement, fitting a prosthesis, attaching a wound-vac, etc.) as a focal portion of the Procedure.
    property focalDeviceList : TFhirProcedureFocalDeviceList read GetFocalDeviceList;
    property hasFocalDeviceList : boolean read GetHasFocalDeviceList;

    // Identifies medications, devices and any other substance used as part of the procedure.
    property usedReferenceList : TFhirReferenceList{Resource} read GetUsedReferenceList;
    property hasUsedReferenceList : boolean read GetHasUsedReferenceList;

    // Identifies coded items that were used as part of the procedure.
    property usedCodeList : TFhirCodeableConceptList read GetUsedCodeList;
    property hasUsedCodeList : boolean read GetHasUsedCodeList;

  end;

  TFhirProcedureListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirProcedureList;
    function GetCurrent : TFhirProcedure;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirProcedureList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProcedure read GetCurrent;
  end;

  TFhirProcedureList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirProcedure;
    procedure SetItemN(index : Integer; value : TFhirProcedure);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirProcedureList; Overload;
    function Clone : TFhirProcedureList; Overload;
    function GetEnumerator : TFhirProcedureListEnumerator;

    //  Add a FhirProcedure to the end of the list.
    function Append : TFhirProcedure;

    // Add an already existing FhirProcedure to the end of the list.
    procedure AddItem(value : TFhirProcedure); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirProcedure) : Integer;

    // Insert FhirProcedure before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirProcedure;

    // Insert an existing FhirProcedure before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirProcedure);

    // Get the iIndexth FhirProcedure. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirProcedure);

    // The number of items in the collection
    function Item(index : Integer) : TFhirProcedure;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirProcedures[index : Integer] : TFhirProcedure read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PROCEDURE}

{$IFDEF FHIR_PROCEDUREREQUEST}

  // The individual who initiated the request and has responsibility for its activation.
  TFhirProcedureRequestRequester = class (TFhirBackboneElement)
  protected
    FAgent : TFhirReference{Resource};
    FOnBehalfOf : TFhirReference{TFhirOrganization};
    Procedure SetAgent(value : TFhirReference{Resource});
    Procedure SetOnBehalfOf(value : TFhirReference{TFhirOrganization});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirProcedureRequestRequester; overload;
    function Clone : TFhirProcedureRequestRequester; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The device, practitioner or organization who initiated the request. (defined for API consistency)
    property agent : TFhirReference{Resource} read FAgent write SetAgent;
    // The device, practitioner or organization who initiated the request.
    property agentElement : TFhirReference{Resource} read FAgent write SetAgent;

    // Typed access to The organization the device or practitioner was acting on behalf of. (defined for API consistency)
    property onBehalfOf : TFhirReference{TFhirOrganization} read FOnBehalfOf write SetOnBehalfOf;
    // The organization the device or practitioner was acting on behalf of.
    property onBehalfOfElement : TFhirReference{TFhirOrganization} read FOnBehalfOf write SetOnBehalfOf;

  end;

  TFhirProcedureRequestRequesterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirProcedureRequestRequesterList;
    function GetCurrent : TFhirProcedureRequestRequester;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirProcedureRequestRequesterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProcedureRequestRequester read GetCurrent;
  end;

  TFhirProcedureRequestRequesterList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirProcedureRequestRequester;
    procedure SetItemN(index : Integer; value : TFhirProcedureRequestRequester);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirProcedureRequestRequesterList; Overload;
    function Clone : TFhirProcedureRequestRequesterList; Overload;
    function GetEnumerator : TFhirProcedureRequestRequesterListEnumerator;

    //  Add a FhirProcedureRequestRequester to the end of the list.
    function Append : TFhirProcedureRequestRequester;

    // Add an already existing FhirProcedureRequestRequester to the end of the list.
    procedure AddItem(value : TFhirProcedureRequestRequester); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirProcedureRequestRequester) : Integer;

    // Insert FhirProcedureRequestRequester before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirProcedureRequestRequester;

    // Insert an existing FhirProcedureRequestRequester before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirProcedureRequestRequester);

    // Get the iIndexth FhirProcedureRequestRequester. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirProcedureRequestRequester);

    // The number of items in the collection
    function Item(index : Integer) : TFhirProcedureRequestRequester;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirProcedureRequestRequesters[index : Integer] : TFhirProcedureRequestRequester read GetItemN write SetItemN; default;
  End;

  // A record of a request for diagnostic investigations, treatments, or operations to be performed.
  TFhirProcedureRequest = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FdefinitionList : TFhirReferenceList{Resource};
    FbasedOnList : TFhirReferenceList{TFhirReference};
    FreplacesList : TFhirReferenceList{TFhirReference};
    FRequisition : TFhirIdentifier;
    FStatus : TFhirEnum;
    FIntent : TFhirEnum;
    FPriority : TFhirEnum;
    FDoNotPerform : TFhirBoolean;
    FcategoryList : TFhirCodeableConceptList;
    FCode : TFhirCodeableConcept;
    FSubject : TFhirReference{Resource};
    FContext : TFhirReference{Resource};
    FOccurrence : TFhirType;
    FAsNeeded : TFhirType;
    FAuthoredOn : TFhirDateTime;
    FRequester : TFhirProcedureRequestRequester;
    FPerformerType : TFhirCodeableConcept;
    FPerformer : TFhirReference{Resource};
    FreasonCodeList : TFhirCodeableConceptList;
    FreasonReferenceList : TFhirReferenceList{Resource};
    FsupportingInfoList : TFhirReferenceList{TFhirReference};
    FspecimenList : TFhirReferenceList{TFhirSpecimen};
    FbodySiteList : TFhirCodeableConceptList;
    FnoteList : TFhirAnnotationList;
    FrelevantHistoryList : TFhirReferenceList{TFhirProvenance};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetDefinitionList : TFhirReferenceList{Resource};
    function GetHasDefinitionList : Boolean;
    function GetBasedOnList : TFhirReferenceList{TFhirReference};
    function GetHasBasedOnList : Boolean;
    function GetReplacesList : TFhirReferenceList{TFhirReference};
    function GetHasReplacesList : Boolean;
    Procedure SetRequisition(value : TFhirIdentifier);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirRequestStatusEnum;
    Procedure SetStatusST(value : TFhirRequestStatusEnum);
    Procedure SetIntent(value : TFhirEnum);
    Function GetIntentST : TFhirRequestIntentEnum;
    Procedure SetIntentST(value : TFhirRequestIntentEnum);
    Procedure SetPriority(value : TFhirEnum);
    Function GetPriorityST : TFhirRequestPriorityEnum;
    Procedure SetPriorityST(value : TFhirRequestPriorityEnum);
    Procedure SetDoNotPerform(value : TFhirBoolean);
    Function GetDoNotPerformST : Boolean;
    Procedure SetDoNotPerformST(value : Boolean);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetSubject(value : TFhirReference{Resource});
    Procedure SetContext(value : TFhirReference{Resource});
    Procedure SetOccurrence(value : TFhirType);
    Procedure SetAsNeeded(value : TFhirType);
    Procedure SetAuthoredOn(value : TFhirDateTime);
    Function GetAuthoredOnST : TFslDateTime;
    Procedure SetAuthoredOnST(value : TFslDateTime);
    Procedure SetRequester(value : TFhirProcedureRequestRequester);
    Procedure SetPerformerType(value : TFhirCodeableConcept);
    Procedure SetPerformer(value : TFhirReference{Resource});
    function GetReasonCodeList : TFhirCodeableConceptList;
    function GetHasReasonCodeList : Boolean;
    function GetReasonReferenceList : TFhirReferenceList{Resource};
    function GetHasReasonReferenceList : Boolean;
    function GetSupportingInfoList : TFhirReferenceList{TFhirReference};
    function GetHasSupportingInfoList : Boolean;
    function GetSpecimenList : TFhirReferenceList{TFhirSpecimen};
    function GetHasSpecimenList : Boolean;
    function GetBodySiteList : TFhirCodeableConceptList;
    function GetHasBodySiteList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetRelevantHistoryList : TFhirReferenceList{TFhirProvenance};
    function GetHasRelevantHistoryList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirProcedureRequest; overload;
    function Clone : TFhirProcedureRequest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Identifiers assigned to this order instance by the orderer and/or the receiver and/or order fulfiller.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Protocol or definition followed by this request.
    property definitionList : TFhirReferenceList{Resource} read GetDefinitionList;
    property hasDefinitionList : boolean read GetHasDefinitionList;

    // Plan/proposal/order fulfilled by this request.
    property basedOnList : TFhirReferenceList{TFhirReference} read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // The request takes the place of the referenced completed or terminated request(s).
    property replacesList : TFhirReferenceList{TFhirReference} read GetReplacesList;
    property hasReplacesList : boolean read GetHasReplacesList;

    // Typed access to A shared identifier common to all procedure or diagnostic requests that were authorized more or less simultaneously by a single author, representing the composite or group identifier. (defined for API consistency)
    property requisition : TFhirIdentifier read FRequisition write SetRequisition;
    // A shared identifier common to all procedure or diagnostic requests that were authorized more or less simultaneously by a single author, representing the composite or group identifier.
    property requisitionElement : TFhirIdentifier read FRequisition write SetRequisition;

    // The status of the order.
    property status : TFhirRequestStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Whether the request is a proposal, plan, an original order or a reflex order.
    property intent : TFhirRequestIntentEnum read GetIntentST write SetIntentST;
    property intentElement : TFhirEnum read FIntent write SetIntent;

    // Indicates how quickly the ProcedureRequest should be addressed with respect to other requests.
    property priority : TFhirRequestPriorityEnum read GetPriorityST write SetPriorityST;
    property priorityElement : TFhirEnum read FPriority write SetPriority;

    // Typed access to Set this to true if the record is saying that the procedure should NOT be performed.
    property doNotPerform : Boolean read GetDoNotPerformST write SetDoNotPerformST;
    // Set this to true if the record is saying that the procedure should NOT be performed.
    property doNotPerformElement : TFhirBoolean read FDoNotPerform write SetDoNotPerform;

    // A code that classifies the procedure for searching, sorting and display purposes (e.g. "Surgical Procedure").
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to A code that identifies a particular procedure, diagnostic investigation, or panel of investigations, that have been requested. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code that identifies a particular procedure, diagnostic investigation, or panel of investigations, that have been requested.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to On whom or what the procedure or diagnostic is to be performed. This is usually a human patient, but can also be requested on animals, groups of humans or animals, devices such as dialysis machines, or even locations (typically for environmental scans). (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // On whom or what the procedure or diagnostic is to be performed. This is usually a human patient, but can also be requested on animals, groups of humans or animals, devices such as dialysis machines, or even locations (typically for environmental scans).
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // Typed access to An encounter or episode of care that provides additional information about the healthcare context in which this request is made. (defined for API consistency)
    property context : TFhirReference{Resource} read FContext write SetContext;
    // An encounter or episode of care that provides additional information about the healthcare context in which this request is made.
    property contextElement : TFhirReference{Resource} read FContext write SetContext;

    // Typed access to The date/time at which the diagnostic testing should occur. (defined for API consistency)
    property occurrence : TFhirType read FOccurrence write SetOccurrence;
    // The date/time at which the diagnostic testing should occur.
    property occurrenceElement : TFhirType read FOccurrence write SetOccurrence;

    // Typed access to If a CodeableConcept is present, it indicates the pre-condition for performing the procedure.  For example "pain", "on flare-up", etc. (defined for API consistency)
    property asNeeded : TFhirType read FAsNeeded write SetAsNeeded;
    // If a CodeableConcept is present, it indicates the pre-condition for performing the procedure.  For example "pain", "on flare-up", etc.
    property asNeededElement : TFhirType read FAsNeeded write SetAsNeeded;

    // Typed access to When the request transitioned to being actionable.
    property authoredOn : TFslDateTime read GetAuthoredOnST write SetAuthoredOnST;
    // When the request transitioned to being actionable.
    property authoredOnElement : TFhirDateTime read FAuthoredOn write SetAuthoredOn;

    // Typed access to The individual who initiated the request and has responsibility for its activation. (defined for API consistency)
    property requester : TFhirProcedureRequestRequester read FRequester write SetRequester;
    // The individual who initiated the request and has responsibility for its activation.
    property requesterElement : TFhirProcedureRequestRequester read FRequester write SetRequester;

    // Typed access to Desired type of performer for doing the diagnostic testing. (defined for API consistency)
    property performerType : TFhirCodeableConcept read FPerformerType write SetPerformerType;
    // Desired type of performer for doing the diagnostic testing.
    property performerTypeElement : TFhirCodeableConcept read FPerformerType write SetPerformerType;

    // Typed access to The desired perfomer for doing the diagnostic testing.  For example, the surgeon, dermatopathologist, endoscopist, etc. (defined for API consistency)
    property performer : TFhirReference{Resource} read FPerformer write SetPerformer;
    // The desired perfomer for doing the diagnostic testing.  For example, the surgeon, dermatopathologist, endoscopist, etc.
    property performerElement : TFhirReference{Resource} read FPerformer write SetPerformer;

    // An explanation or justification for why this diagnostic investigation is being requested in coded or textual form.   This is often for billing purposes.  May relate to the resources referred to in supportingInformation.
    property reasonCodeList : TFhirCodeableConceptList read GetReasonCodeList;
    property hasReasonCodeList : boolean read GetHasReasonCodeList;

    // Indicates another resource that provides a justification for why this diagnostic investigation is being requested.   May relate to the resources referred to in supportingInformation.
    property reasonReferenceList : TFhirReferenceList{Resource} read GetReasonReferenceList;
    property hasReasonReferenceList : boolean read GetHasReasonReferenceList;

    // Additional clinical information about the patient or specimen that may influence the procedure or diagnostics or their interpretations.     This information includes diagnosis, clinical findings and other observations.  In laboratory ordering these are typically referred to as "ask at order entry questions (AOEs)".  This includes observations explicitly requested by the producer (filler) to provide context or supporting information needed to complete the order. For example,  reporting the amount of inspired oxygen for blood gas measurements.
    property supportingInfoList : TFhirReferenceList{TFhirReference} read GetSupportingInfoList;
    property hasSupportingInfoList : boolean read GetHasSupportingInfoList;

    // One or more specimens that the laboratory procedure will use.
    property specimenList : TFhirReferenceList{TFhirSpecimen} read GetSpecimenList;
    property hasSpecimenList : boolean read GetHasSpecimenList;

    // Anatomic location where the procedure should be performed. This is the target site.
    property bodySiteList : TFhirCodeableConceptList read GetBodySiteList;
    property hasBodySiteList : boolean read GetHasBodySiteList;

    // Any other notes and comments made about the service request. For example, letting provider know that "patient hates needles" or other provider instructions.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Key events in the history of the request.
    property relevantHistoryList : TFhirReferenceList{TFhirProvenance} read GetRelevantHistoryList;
    property hasRelevantHistoryList : boolean read GetHasRelevantHistoryList;

  end;

  TFhirProcedureRequestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirProcedureRequestList;
    function GetCurrent : TFhirProcedureRequest;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirProcedureRequestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProcedureRequest read GetCurrent;
  end;

  TFhirProcedureRequestList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirProcedureRequest;
    procedure SetItemN(index : Integer; value : TFhirProcedureRequest);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirProcedureRequestList; Overload;
    function Clone : TFhirProcedureRequestList; Overload;
    function GetEnumerator : TFhirProcedureRequestListEnumerator;

    //  Add a FhirProcedureRequest to the end of the list.
    function Append : TFhirProcedureRequest;

    // Add an already existing FhirProcedureRequest to the end of the list.
    procedure AddItem(value : TFhirProcedureRequest); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirProcedureRequest) : Integer;

    // Insert FhirProcedureRequest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirProcedureRequest;

    // Insert an existing FhirProcedureRequest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirProcedureRequest);

    // Get the iIndexth FhirProcedureRequest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirProcedureRequest);

    // The number of items in the collection
    function Item(index : Integer) : TFhirProcedureRequest;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirProcedureRequests[index : Integer] : TFhirProcedureRequest read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PROCEDUREREQUEST}

{$IFDEF FHIR_QUESTIONNAIRERESPONSE}

  // A group or question item from the original questionnaire for which answers are provided.
  TFhirQuestionnaireResponseItem = class (TFhirBackboneElement)
  protected
    FLinkId : TFhirString;
    FDefinition : TFhirUri;
    FText : TFhirString;
    FSubject : TFhirReference{TFhirReference};
    FanswerList : TFhirQuestionnaireResponseItemAnswerList;
    FitemList : TFhirQuestionnaireResponseItemList;
    Procedure SetLinkId(value : TFhirString);
    Function GetLinkIdST : String;
    Procedure SetLinkIdST(value : String);
    Procedure SetDefinition(value : TFhirUri);
    Function GetDefinitionST : String;
    Procedure SetDefinitionST(value : String);
    Procedure SetText(value : TFhirString);
    Function GetTextST : String;
    Procedure SetTextST(value : String);
    Procedure SetSubject(value : TFhirReference{TFhirReference});
    function GetAnswerList : TFhirQuestionnaireResponseItemAnswerList;
    function GetHasAnswerList : Boolean;
    function GetItemList : TFhirQuestionnaireResponseItemList;
    function GetHasItemList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirQuestionnaireResponseItem; overload;
    function Clone : TFhirQuestionnaireResponseItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The item from the Questionnaire that corresponds to this item in the QuestionnaireResponse resource.
    property linkId : String read GetLinkIdST write SetLinkIdST;
    // The item from the Questionnaire that corresponds to this item in the QuestionnaireResponse resource.
    property linkIdElement : TFhirString read FLinkId write SetLinkId;

    // Typed access to A reference to an [ElementDefinition](elementdefinition.html) that provides the details for the item.
    property definition : String read GetDefinitionST write SetDefinitionST;
    // A reference to an [ElementDefinition](elementdefinition.html) that provides the details for the item.
    property definitionElement : TFhirUri read FDefinition write SetDefinition;

    // Typed access to Text that is displayed above the contents of the group or as the text of the question being answered.
    property text : String read GetTextST write SetTextST;
    // Text that is displayed above the contents of the group or as the text of the question being answered.
    property textElement : TFhirString read FText write SetText;

    // Typed access to More specific subject this section's answers are about, details the subject given in QuestionnaireResponse. (defined for API consistency)
    property subject : TFhirReference{TFhirReference} read FSubject write SetSubject;
    // More specific subject this section's answers are about, details the subject given in QuestionnaireResponse.
    property subjectElement : TFhirReference{TFhirReference} read FSubject write SetSubject;

    // The respondent's answer(s) to the question.
    property answerList : TFhirQuestionnaireResponseItemAnswerList read GetAnswerList;
    property hasAnswerList : boolean read GetHasAnswerList;

    // Questions or sub-groups nested beneath a question or group.
    property itemList : TFhirQuestionnaireResponseItemList read GetItemList;
    property hasItemList : boolean read GetHasItemList;

  end;

  TFhirQuestionnaireResponseItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirQuestionnaireResponseItemList;
    function GetCurrent : TFhirQuestionnaireResponseItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirQuestionnaireResponseItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirQuestionnaireResponseItem read GetCurrent;
  end;

  TFhirQuestionnaireResponseItemList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirQuestionnaireResponseItem;
    procedure SetItemN(index : Integer; value : TFhirQuestionnaireResponseItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirQuestionnaireResponseItemList; Overload;
    function Clone : TFhirQuestionnaireResponseItemList; Overload;
    function GetEnumerator : TFhirQuestionnaireResponseItemListEnumerator;

    //  Add a FhirQuestionnaireResponseItem to the end of the list.
    function Append : TFhirQuestionnaireResponseItem;

    // Add an already existing FhirQuestionnaireResponseItem to the end of the list.
    procedure AddItem(value : TFhirQuestionnaireResponseItem); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirQuestionnaireResponseItem) : Integer;

    // Insert FhirQuestionnaireResponseItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirQuestionnaireResponseItem;

    // Insert an existing FhirQuestionnaireResponseItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirQuestionnaireResponseItem);

    // Get the iIndexth FhirQuestionnaireResponseItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirQuestionnaireResponseItem);

    // The number of items in the collection
    function Item(index : Integer) : TFhirQuestionnaireResponseItem;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirQuestionnaireResponseItems[index : Integer] : TFhirQuestionnaireResponseItem read GetItemN write SetItemN; default;
  End;

  // The respondent's answer(s) to the question.
  TFhirQuestionnaireResponseItemAnswer = class (TFhirBackboneElement)
  protected
    FValue : TFhirType;
    FitemList : TFhirQuestionnaireResponseItemList;
    Procedure SetValue(value : TFhirType);
    function GetItemList : TFhirQuestionnaireResponseItemList;
    function GetHasItemList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirQuestionnaireResponseItemAnswer; overload;
    function Clone : TFhirQuestionnaireResponseItemAnswer; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The answer (or one of the answers) provided by the respondent to the question. (defined for API consistency)
    property value : TFhirType read FValue write SetValue;
    // The answer (or one of the answers) provided by the respondent to the question.
    property valueElement : TFhirType read FValue write SetValue;

    // Nested groups and/or questions found within this particular answer.
    property itemList : TFhirQuestionnaireResponseItemList read GetItemList;
    property hasItemList : boolean read GetHasItemList;

  end;

  TFhirQuestionnaireResponseItemAnswerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirQuestionnaireResponseItemAnswerList;
    function GetCurrent : TFhirQuestionnaireResponseItemAnswer;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirQuestionnaireResponseItemAnswerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirQuestionnaireResponseItemAnswer read GetCurrent;
  end;

  TFhirQuestionnaireResponseItemAnswerList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirQuestionnaireResponseItemAnswer;
    procedure SetItemN(index : Integer; value : TFhirQuestionnaireResponseItemAnswer);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirQuestionnaireResponseItemAnswerList; Overload;
    function Clone : TFhirQuestionnaireResponseItemAnswerList; Overload;
    function GetEnumerator : TFhirQuestionnaireResponseItemAnswerListEnumerator;

    //  Add a FhirQuestionnaireResponseItemAnswer to the end of the list.
    function Append : TFhirQuestionnaireResponseItemAnswer;

    // Add an already existing FhirQuestionnaireResponseItemAnswer to the end of the list.
    procedure AddItem(value : TFhirQuestionnaireResponseItemAnswer); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirQuestionnaireResponseItemAnswer) : Integer;

    // Insert FhirQuestionnaireResponseItemAnswer before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirQuestionnaireResponseItemAnswer;

    // Insert an existing FhirQuestionnaireResponseItemAnswer before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirQuestionnaireResponseItemAnswer);

    // Get the iIndexth FhirQuestionnaireResponseItemAnswer. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirQuestionnaireResponseItemAnswer);

    // The number of items in the collection
    function Item(index : Integer) : TFhirQuestionnaireResponseItemAnswer;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirQuestionnaireResponseItemAnswers[index : Integer] : TFhirQuestionnaireResponseItemAnswer read GetItemN write SetItemN; default;
  End;

  // A structured set of questions and their answers. The questions are ordered and grouped into coherent subsets, corresponding to the structure of the grouping of the questionnaire being responded to.
  TFhirQuestionnaireResponse = class (TFhirDomainResource)
  protected
    FIdentifier : TFhirIdentifier;
    FbasedOnList : TFhirReferenceList{Resource};
    FparentList : TFhirReferenceList{Resource};
    FQuestionnaire : TFhirReference{TFhirQuestionnaire};
    FStatus : TFhirEnum;
    FSubject : TFhirReference{TFhirReference};
    FContext : TFhirReference{Resource};
    FAuthored : TFhirDateTime;
    FAuthor : TFhirReference{Resource};
    FSource : TFhirReference{Resource};
    FitemList : TFhirQuestionnaireResponseItemList;
    Procedure SetIdentifier(value : TFhirIdentifier);
    function GetBasedOnList : TFhirReferenceList{Resource};
    function GetHasBasedOnList : Boolean;
    function GetParentList : TFhirReferenceList{Resource};
    function GetHasParentList : Boolean;
    Procedure SetQuestionnaire(value : TFhirReference{TFhirQuestionnaire});
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirQuestionnaireAnswersStatusEnum;
    Procedure SetStatusST(value : TFhirQuestionnaireAnswersStatusEnum);
    Procedure SetSubject(value : TFhirReference{TFhirReference});
    Procedure SetContext(value : TFhirReference{Resource});
    Procedure SetAuthored(value : TFhirDateTime);
    Function GetAuthoredST : TFslDateTime;
    Procedure SetAuthoredST(value : TFslDateTime);
    Procedure SetAuthor(value : TFhirReference{Resource});
    Procedure SetSource(value : TFhirReference{Resource});
    function GetItemList : TFhirQuestionnaireResponseItemList;
    function GetHasItemList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirQuestionnaireResponse; overload;
    function Clone : TFhirQuestionnaireResponse; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A business identifier assigned to a particular completed (or partially completed) questionnaire. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // A business identifier assigned to a particular completed (or partially completed) questionnaire.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // The order, proposal or plan that is fulfilled in whole or in part by this QuestionnaireResponse.  For example, a ProcedureRequest seeking an intake assessment or a decision support recommendation to assess for post-partum depression.
    property basedOnList : TFhirReferenceList{Resource} read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // A procedure or observation that this questionnaire was performed as part of the execution of.  For example, the surgery a checklist was executed as part of.
    property parentList : TFhirReferenceList{Resource} read GetParentList;
    property hasParentList : boolean read GetHasParentList;

    // Typed access to The Questionnaire that defines and organizes the questions for which answers are being provided. (defined for API consistency)
    property questionnaire : TFhirReference{TFhirQuestionnaire} read FQuestionnaire write SetQuestionnaire;
    // The Questionnaire that defines and organizes the questions for which answers are being provided.
    property questionnaireElement : TFhirReference{TFhirQuestionnaire} read FQuestionnaire write SetQuestionnaire;

    // The position of the questionnaire response within its overall lifecycle.
    property status : TFhirQuestionnaireAnswersStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The subject of the questionnaire response.  This could be a patient, organization, practitioner, device, etc.  This is who/what the answers apply to, but is not necessarily the source of information. (defined for API consistency)
    property subject : TFhirReference{TFhirReference} read FSubject write SetSubject;
    // The subject of the questionnaire response.  This could be a patient, organization, practitioner, device, etc.  This is who/what the answers apply to, but is not necessarily the source of information.
    property subjectElement : TFhirReference{TFhirReference} read FSubject write SetSubject;

    // Typed access to The encounter or episode of care with primary association to the questionnaire response. (defined for API consistency)
    property context : TFhirReference{Resource} read FContext write SetContext;
    // The encounter or episode of care with primary association to the questionnaire response.
    property contextElement : TFhirReference{Resource} read FContext write SetContext;

    // Typed access to The date and/or time that this set of answers were last changed.
    property authored : TFslDateTime read GetAuthoredST write SetAuthoredST;
    // The date and/or time that this set of answers were last changed.
    property authoredElement : TFhirDateTime read FAuthored write SetAuthored;

    // Typed access to Person who received the answers to the questions in the QuestionnaireResponse and recorded them in the system. (defined for API consistency)
    property author : TFhirReference{Resource} read FAuthor write SetAuthor;
    // Person who received the answers to the questions in the QuestionnaireResponse and recorded them in the system.
    property authorElement : TFhirReference{Resource} read FAuthor write SetAuthor;

    // Typed access to The person who answered the questions about the subject. (defined for API consistency)
    property source : TFhirReference{Resource} read FSource write SetSource;
    // The person who answered the questions about the subject.
    property sourceElement : TFhirReference{Resource} read FSource write SetSource;

    // A group or question item from the original questionnaire for which answers are provided.
    property itemList : TFhirQuestionnaireResponseItemList read GetItemList;
    property hasItemList : boolean read GetHasItemList;

  end;

  TFhirQuestionnaireResponseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirQuestionnaireResponseList;
    function GetCurrent : TFhirQuestionnaireResponse;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirQuestionnaireResponseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirQuestionnaireResponse read GetCurrent;
  end;

  TFhirQuestionnaireResponseList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirQuestionnaireResponse;
    procedure SetItemN(index : Integer; value : TFhirQuestionnaireResponse);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirQuestionnaireResponseList; Overload;
    function Clone : TFhirQuestionnaireResponseList; Overload;
    function GetEnumerator : TFhirQuestionnaireResponseListEnumerator;

    //  Add a FhirQuestionnaireResponse to the end of the list.
    function Append : TFhirQuestionnaireResponse;

    // Add an already existing FhirQuestionnaireResponse to the end of the list.
    procedure AddItem(value : TFhirQuestionnaireResponse); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirQuestionnaireResponse) : Integer;

    // Insert FhirQuestionnaireResponse before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirQuestionnaireResponse;

    // Insert an existing FhirQuestionnaireResponse before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirQuestionnaireResponse);

    // Get the iIndexth FhirQuestionnaireResponse. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirQuestionnaireResponse);

    // The number of items in the collection
    function Item(index : Integer) : TFhirQuestionnaireResponse;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirQuestionnaireResponses[index : Integer] : TFhirQuestionnaireResponse read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_QUESTIONNAIRERESPONSE}

{$IFDEF FHIR_REFERRALREQUEST}

  // The individual who initiated the request and has responsibility for its activation.
  TFhirReferralRequestRequester = class (TFhirBackboneElement)
  protected
    FAgent : TFhirReference{Resource};
    FOnBehalfOf : TFhirReference{TFhirOrganization};
    Procedure SetAgent(value : TFhirReference{Resource});
    Procedure SetOnBehalfOf(value : TFhirReference{TFhirOrganization});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirReferralRequestRequester; overload;
    function Clone : TFhirReferralRequestRequester; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The device, practitioner, etc. who initiated the request. (defined for API consistency)
    property agent : TFhirReference{Resource} read FAgent write SetAgent;
    // The device, practitioner, etc. who initiated the request.
    property agentElement : TFhirReference{Resource} read FAgent write SetAgent;

    // Typed access to The organization the device or practitioner was acting on behalf of. (defined for API consistency)
    property onBehalfOf : TFhirReference{TFhirOrganization} read FOnBehalfOf write SetOnBehalfOf;
    // The organization the device or practitioner was acting on behalf of.
    property onBehalfOfElement : TFhirReference{TFhirOrganization} read FOnBehalfOf write SetOnBehalfOf;

  end;

  TFhirReferralRequestRequesterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirReferralRequestRequesterList;
    function GetCurrent : TFhirReferralRequestRequester;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirReferralRequestRequesterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirReferralRequestRequester read GetCurrent;
  end;

  TFhirReferralRequestRequesterList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirReferralRequestRequester;
    procedure SetItemN(index : Integer; value : TFhirReferralRequestRequester);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirReferralRequestRequesterList; Overload;
    function Clone : TFhirReferralRequestRequesterList; Overload;
    function GetEnumerator : TFhirReferralRequestRequesterListEnumerator;

    //  Add a FhirReferralRequestRequester to the end of the list.
    function Append : TFhirReferralRequestRequester;

    // Add an already existing FhirReferralRequestRequester to the end of the list.
    procedure AddItem(value : TFhirReferralRequestRequester); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirReferralRequestRequester) : Integer;

    // Insert FhirReferralRequestRequester before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirReferralRequestRequester;

    // Insert an existing FhirReferralRequestRequester before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirReferralRequestRequester);

    // Get the iIndexth FhirReferralRequestRequester. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirReferralRequestRequester);

    // The number of items in the collection
    function Item(index : Integer) : TFhirReferralRequestRequester;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirReferralRequestRequesters[index : Integer] : TFhirReferralRequestRequester read GetItemN write SetItemN; default;
  End;

  // Used to record and send details about a request for referral service or transfer of a patient to the care of another provider or provider organization.
  TFhirReferralRequest = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FdefinitionList : TFhirReferenceList{Resource};
    FbasedOnList : TFhirReferenceList{Resource};
    FreplacesList : TFhirReferenceList{TFhirReferralRequest};
    FGroupIdentifier : TFhirIdentifier;
    FStatus : TFhirEnum;
    FIntent : TFhirEnum;
    FType_ : TFhirCodeableConcept;
    FPriority : TFhirEnum;
    FserviceRequestedList : TFhirCodeableConceptList;
    FSubject : TFhirReference{Resource};
    FContext : TFhirReference{Resource};
    FOccurrence : TFhirType;
    FAuthoredOn : TFhirDateTime;
    FRequester : TFhirReferralRequestRequester;
    FSpecialty : TFhirCodeableConcept;
    FrecipientList : TFhirReferenceList{Resource};
    FreasonCodeList : TFhirCodeableConceptList;
    FreasonReferenceList : TFhirReferenceList{Resource};
    FDescription : TFhirString;
    FsupportingInfoList : TFhirReferenceList{TFhirReference};
    FnoteList : TFhirAnnotationList;
    FrelevantHistoryList : TFhirReferenceList{TFhirProvenance};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetDefinitionList : TFhirReferenceList{Resource};
    function GetHasDefinitionList : Boolean;
    function GetBasedOnList : TFhirReferenceList{Resource};
    function GetHasBasedOnList : Boolean;
    function GetReplacesList : TFhirReferenceList{TFhirReferralRequest};
    function GetHasReplacesList : Boolean;
    Procedure SetGroupIdentifier(value : TFhirIdentifier);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirRequestStatusEnum;
    Procedure SetStatusST(value : TFhirRequestStatusEnum);
    Procedure SetIntent(value : TFhirEnum);
    Function GetIntentST : TFhirRequestIntentEnum;
    Procedure SetIntentST(value : TFhirRequestIntentEnum);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetPriority(value : TFhirEnum);
    Function GetPriorityST : TFhirRequestPriorityEnum;
    Procedure SetPriorityST(value : TFhirRequestPriorityEnum);
    function GetServiceRequestedList : TFhirCodeableConceptList;
    function GetHasServiceRequestedList : Boolean;
    Procedure SetSubject(value : TFhirReference{Resource});
    Procedure SetContext(value : TFhirReference{Resource});
    Procedure SetOccurrence(value : TFhirType);
    Procedure SetAuthoredOn(value : TFhirDateTime);
    Function GetAuthoredOnST : TFslDateTime;
    Procedure SetAuthoredOnST(value : TFslDateTime);
    Procedure SetRequester(value : TFhirReferralRequestRequester);
    Procedure SetSpecialty(value : TFhirCodeableConcept);
    function GetRecipientList : TFhirReferenceList{Resource};
    function GetHasRecipientList : Boolean;
    function GetReasonCodeList : TFhirCodeableConceptList;
    function GetHasReasonCodeList : Boolean;
    function GetReasonReferenceList : TFhirReferenceList{Resource};
    function GetHasReasonReferenceList : Boolean;
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    function GetSupportingInfoList : TFhirReferenceList{TFhirReference};
    function GetHasSupportingInfoList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetRelevantHistoryList : TFhirReferenceList{TFhirProvenance};
    function GetHasRelevantHistoryList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirReferralRequest; overload;
    function Clone : TFhirReferralRequest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Business identifier that uniquely identifies the referral/care transfer request instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A protocol, guideline, orderset or other definition that is adhered to in whole or in part by this request.
    property definitionList : TFhirReferenceList{Resource} read GetDefinitionList;
    property hasDefinitionList : boolean read GetHasDefinitionList;

    // Indicates any plans, proposals or orders that this request is intended to satisfy - in whole or in part.
    property basedOnList : TFhirReferenceList{Resource} read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // Completed or terminated request(s) whose function is taken by this new request.
    property replacesList : TFhirReferenceList{TFhirReferralRequest} read GetReplacesList;
    property hasReplacesList : boolean read GetHasReplacesList;

    // Typed access to The business identifier of the logical "grouping" request/order that this referral is a part of. (defined for API consistency)
    property groupIdentifier : TFhirIdentifier read FGroupIdentifier write SetGroupIdentifier;
    // The business identifier of the logical "grouping" request/order that this referral is a part of.
    property groupIdentifierElement : TFhirIdentifier read FGroupIdentifier write SetGroupIdentifier;

    // The status of the authorization/intention reflected by the referral request record.
    property status : TFhirRequestStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Distinguishes the "level" of authorization/demand implicit in this request.
    property intent : TFhirRequestIntentEnum read GetIntentST write SetIntentST;
    property intentElement : TFhirEnum read FIntent write SetIntent;

    // Typed access to An indication of the type of referral (or where applicable the type of transfer of care) request. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // An indication of the type of referral (or where applicable the type of transfer of care) request.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // An indication of the urgency of referral (or where applicable the type of transfer of care) request.
    property priority : TFhirRequestPriorityEnum read GetPriorityST write SetPriorityST;
    property priorityElement : TFhirEnum read FPriority write SetPriority;

    // The service(s) that is/are requested to be provided to the patient.  For example: cardiac pacemaker insertion.
    property serviceRequestedList : TFhirCodeableConceptList read GetServiceRequestedList;
    property hasServiceRequestedList : boolean read GetHasServiceRequestedList;

    // Typed access to The patient who is the subject of a referral or transfer of care request. (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // The patient who is the subject of a referral or transfer of care request.
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // Typed access to The encounter at which the request for referral or transfer of care is initiated. (defined for API consistency)
    property context : TFhirReference{Resource} read FContext write SetContext;
    // The encounter at which the request for referral or transfer of care is initiated.
    property contextElement : TFhirReference{Resource} read FContext write SetContext;

    // Typed access to The period of time within which the services identified in the referral/transfer of care is specified or required to occur. (defined for API consistency)
    property occurrence : TFhirType read FOccurrence write SetOccurrence;
    // The period of time within which the services identified in the referral/transfer of care is specified or required to occur.
    property occurrenceElement : TFhirType read FOccurrence write SetOccurrence;

    // Typed access to Date/DateTime of creation for draft requests and date of activation for active requests.
    property authoredOn : TFslDateTime read GetAuthoredOnST write SetAuthoredOnST;
    // Date/DateTime of creation for draft requests and date of activation for active requests.
    property authoredOnElement : TFhirDateTime read FAuthoredOn write SetAuthoredOn;

    // Typed access to The individual who initiated the request and has responsibility for its activation. (defined for API consistency)
    property requester : TFhirReferralRequestRequester read FRequester write SetRequester;
    // The individual who initiated the request and has responsibility for its activation.
    property requesterElement : TFhirReferralRequestRequester read FRequester write SetRequester;

    // Typed access to Indication of the clinical domain or discipline to which the referral or transfer of care request is sent.  For example: Cardiology Gastroenterology Diabetology. (defined for API consistency)
    property specialty : TFhirCodeableConcept read FSpecialty write SetSpecialty;
    // Indication of the clinical domain or discipline to which the referral or transfer of care request is sent.  For example: Cardiology Gastroenterology Diabetology.
    property specialtyElement : TFhirCodeableConcept read FSpecialty write SetSpecialty;

    // The healthcare provider(s) or provider organization(s) who/which is to receive the referral/transfer of care request.
    property recipientList : TFhirReferenceList{Resource} read GetRecipientList;
    property hasRecipientList : boolean read GetHasRecipientList;

    // Description of clinical condition indicating why referral/transfer of care is requested.  For example:  Pathological Anomalies, Disabled (physical or mental),  Behavioral Management.
    property reasonCodeList : TFhirCodeableConceptList read GetReasonCodeList;
    property hasReasonCodeList : boolean read GetHasReasonCodeList;

    // Indicates another resource whose existence justifies this request.
    property reasonReferenceList : TFhirReferenceList{Resource} read GetReasonReferenceList;
    property hasReasonReferenceList : boolean read GetHasReasonReferenceList;

    // Typed access to The reason element gives a short description of why the referral is being made, the description expands on this to support a more complete clinical summary.
    property description : String read GetDescriptionST write SetDescriptionST;
    // The reason element gives a short description of why the referral is being made, the description expands on this to support a more complete clinical summary.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Any additional (administrative, financial or clinical) information required to support request for referral or transfer of care.  For example: Presenting problems/chief complaints Medical History Family History Alerts Allergy/Intolerance and Adverse Reactions Medications Observations/Assessments (may include cognitive and fundtional assessments) Diagnostic Reports Care Plan.
    property supportingInfoList : TFhirReferenceList{TFhirReference} read GetSupportingInfoList;
    property hasSupportingInfoList : boolean read GetHasSupportingInfoList;

    // Comments made about the referral request by any of the participants.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Links to Provenance records for past versions of this resource or fulfilling request or event resources that identify key state transitions or updates that are likely to be relevant to a user looking at the current version of the resource.
    property relevantHistoryList : TFhirReferenceList{TFhirProvenance} read GetRelevantHistoryList;
    property hasRelevantHistoryList : boolean read GetHasRelevantHistoryList;

  end;

  TFhirReferralRequestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirReferralRequestList;
    function GetCurrent : TFhirReferralRequest;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirReferralRequestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirReferralRequest read GetCurrent;
  end;

  TFhirReferralRequestList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirReferralRequest;
    procedure SetItemN(index : Integer; value : TFhirReferralRequest);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirReferralRequestList; Overload;
    function Clone : TFhirReferralRequestList; Overload;
    function GetEnumerator : TFhirReferralRequestListEnumerator;

    //  Add a FhirReferralRequest to the end of the list.
    function Append : TFhirReferralRequest;

    // Add an already existing FhirReferralRequest to the end of the list.
    procedure AddItem(value : TFhirReferralRequest); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirReferralRequest) : Integer;

    // Insert FhirReferralRequest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirReferralRequest;

    // Insert an existing FhirReferralRequest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirReferralRequest);

    // Get the iIndexth FhirReferralRequest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirReferralRequest);

    // The number of items in the collection
    function Item(index : Integer) : TFhirReferralRequest;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirReferralRequests[index : Integer] : TFhirReferralRequest read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_REFERRALREQUEST}

{$IFDEF FHIR_RISKASSESSMENT}

  // Describes the expected outcome for the subject.
  TFhirRiskAssessmentPrediction = class (TFhirBackboneElement)
  protected
    FOutcome : TFhirCodeableConcept;
    FProbability : TFhirType;
    FQualitativeRisk : TFhirCodeableConcept;
    FRelativeRisk : TFhirDecimal;
    FWhen : TFhirType;
    FRationale : TFhirString;
    Procedure SetOutcome(value : TFhirCodeableConcept);
    Procedure SetProbability(value : TFhirType);
    Procedure SetQualitativeRisk(value : TFhirCodeableConcept);
    Procedure SetRelativeRisk(value : TFhirDecimal);
    Function GetRelativeRiskST : String;
    Procedure SetRelativeRiskST(value : String);
    Procedure SetWhen(value : TFhirType);
    Procedure SetRationale(value : TFhirString);
    Function GetRationaleST : String;
    Procedure SetRationaleST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRiskAssessmentPrediction; overload;
    function Clone : TFhirRiskAssessmentPrediction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to One of the potential outcomes for the patient (e.g. remission, death,  a particular condition). (defined for API consistency)
    property outcome : TFhirCodeableConcept read FOutcome write SetOutcome;
    // One of the potential outcomes for the patient (e.g. remission, death,  a particular condition).
    property outcomeElement : TFhirCodeableConcept read FOutcome write SetOutcome;

    // Typed access to How likely is the outcome (in the specified timeframe). (defined for API consistency)
    property probability : TFhirType read FProbability write SetProbability;
    // How likely is the outcome (in the specified timeframe).
    property probabilityElement : TFhirType read FProbability write SetProbability;

    // Typed access to How likely is the outcome (in the specified timeframe), expressed as a qualitative value (e.g. low, medium, high). (defined for API consistency)
    property qualitativeRisk : TFhirCodeableConcept read FQualitativeRisk write SetQualitativeRisk;
    // How likely is the outcome (in the specified timeframe), expressed as a qualitative value (e.g. low, medium, high).
    property qualitativeRiskElement : TFhirCodeableConcept read FQualitativeRisk write SetQualitativeRisk;

    // Typed access to Indicates the risk for this particular subject (with their specific characteristics) divided by the risk of the population in general.  (Numbers greater than 1 = higher risk than the population, numbers less than 1 = lower risk.).
    property relativeRisk : String read GetRelativeRiskST write SetRelativeRiskST;
    // Indicates the risk for this particular subject (with their specific characteristics) divided by the risk of the population in general.  (Numbers greater than 1 = higher risk than the population, numbers less than 1 = lower risk.).
    property relativeRiskElement : TFhirDecimal read FRelativeRisk write SetRelativeRisk;

    // Typed access to Indicates the period of time or age range of the subject to which the specified probability applies. (defined for API consistency)
    property when : TFhirType read FWhen write SetWhen;
    // Indicates the period of time or age range of the subject to which the specified probability applies.
    property whenElement : TFhirType read FWhen write SetWhen;

    // Typed access to Additional information explaining the basis for the prediction.
    property rationale : String read GetRationaleST write SetRationaleST;
    // Additional information explaining the basis for the prediction.
    property rationaleElement : TFhirString read FRationale write SetRationale;

  end;

  TFhirRiskAssessmentPredictionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRiskAssessmentPredictionList;
    function GetCurrent : TFhirRiskAssessmentPrediction;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirRiskAssessmentPredictionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRiskAssessmentPrediction read GetCurrent;
  end;

  TFhirRiskAssessmentPredictionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirRiskAssessmentPrediction;
    procedure SetItemN(index : Integer; value : TFhirRiskAssessmentPrediction);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirRiskAssessmentPredictionList; Overload;
    function Clone : TFhirRiskAssessmentPredictionList; Overload;
    function GetEnumerator : TFhirRiskAssessmentPredictionListEnumerator;

    //  Add a FhirRiskAssessmentPrediction to the end of the list.
    function Append : TFhirRiskAssessmentPrediction;

    // Add an already existing FhirRiskAssessmentPrediction to the end of the list.
    procedure AddItem(value : TFhirRiskAssessmentPrediction); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRiskAssessmentPrediction) : Integer;

    // Insert FhirRiskAssessmentPrediction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRiskAssessmentPrediction;

    // Insert an existing FhirRiskAssessmentPrediction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRiskAssessmentPrediction);

    // Get the iIndexth FhirRiskAssessmentPrediction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRiskAssessmentPrediction);

    // The number of items in the collection
    function Item(index : Integer) : TFhirRiskAssessmentPrediction;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirRiskAssessmentPredictions[index : Integer] : TFhirRiskAssessmentPrediction read GetItemN write SetItemN; default;
  End;

  // An assessment of the likely outcome(s) for a patient or other subject as well as the likelihood of each outcome.
  TFhirRiskAssessment = class (TFhirDomainResource)
  protected
    FIdentifier : TFhirIdentifier;
    FBasedOn : TFhirReference{TFhirReference};
    FParent : TFhirReference{TFhirReference};
    FStatus : TFhirEnum;
    FMethod : TFhirCodeableConcept;
    FCode : TFhirCodeableConcept;
    FSubject : TFhirReference{Resource};
    FContext : TFhirReference{Resource};
    FOccurrence : TFhirType;
    FCondition : TFhirReference{TFhirCondition};
    FPerformer : TFhirReference{Resource};
    FReason : TFhirType;
    FbasisList : TFhirReferenceList{TFhirReference};
    FpredictionList : TFhirRiskAssessmentPredictionList;
    FMitigation : TFhirString;
    FComment : TFhirString;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetBasedOn(value : TFhirReference{TFhirReference});
    Procedure SetParent(value : TFhirReference{TFhirReference});
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirObservationStatusEnum;
    Procedure SetStatusST(value : TFhirObservationStatusEnum);
    Procedure SetMethod(value : TFhirCodeableConcept);
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetSubject(value : TFhirReference{Resource});
    Procedure SetContext(value : TFhirReference{Resource});
    Procedure SetOccurrence(value : TFhirType);
    Procedure SetCondition(value : TFhirReference{TFhirCondition});
    Procedure SetPerformer(value : TFhirReference{Resource});
    Procedure SetReason(value : TFhirType);
    function GetBasisList : TFhirReferenceList{TFhirReference};
    function GetHasBasisList : Boolean;
    function GetPredictionList : TFhirRiskAssessmentPredictionList;
    function GetHasPredictionList : Boolean;
    Procedure SetMitigation(value : TFhirString);
    Function GetMitigationST : String;
    Procedure SetMitigationST(value : String);
    Procedure SetComment(value : TFhirString);
    Function GetCommentST : String;
    Procedure SetCommentST(value : String);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRiskAssessment; overload;
    function Clone : TFhirRiskAssessment; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Business identifier assigned to the risk assessment. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Business identifier assigned to the risk assessment.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to A reference to the request that is fulfilled by this risk assessment. (defined for API consistency)
    property basedOn : TFhirReference{TFhirReference} read FBasedOn write SetBasedOn;
    // A reference to the request that is fulfilled by this risk assessment.
    property basedOnElement : TFhirReference{TFhirReference} read FBasedOn write SetBasedOn;

    // Typed access to A reference to a resource that this risk assessment is part of, such as a Procedure. (defined for API consistency)
    property parent : TFhirReference{TFhirReference} read FParent write SetParent;
    // A reference to a resource that this risk assessment is part of, such as a Procedure.
    property parentElement : TFhirReference{TFhirReference} read FParent write SetParent;

    // The status of the RiskAssessment, using the same statuses as an Observation.
    property status : TFhirObservationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The algorithm, process or mechanism used to evaluate the risk. (defined for API consistency)
    property method : TFhirCodeableConcept read FMethod write SetMethod;
    // The algorithm, process or mechanism used to evaluate the risk.
    property methodElement : TFhirCodeableConcept read FMethod write SetMethod;

    // Typed access to The type of the risk assessment performed. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The type of the risk assessment performed.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The patient or group the risk assessment applies to. (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // The patient or group the risk assessment applies to.
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // Typed access to The encounter where the assessment was performed. (defined for API consistency)
    property context : TFhirReference{Resource} read FContext write SetContext;
    // The encounter where the assessment was performed.
    property contextElement : TFhirReference{Resource} read FContext write SetContext;

    // Typed access to The date (and possibly time) the risk assessment was performed. (defined for API consistency)
    property occurrence : TFhirType read FOccurrence write SetOccurrence;
    // The date (and possibly time) the risk assessment was performed.
    property occurrenceElement : TFhirType read FOccurrence write SetOccurrence;

    // Typed access to For assessments or prognosis specific to a particular condition, indicates the condition being assessed. (defined for API consistency)
    property condition : TFhirReference{TFhirCondition} read FCondition write SetCondition;
    // For assessments or prognosis specific to a particular condition, indicates the condition being assessed.
    property conditionElement : TFhirReference{TFhirCondition} read FCondition write SetCondition;

    // Typed access to The provider or software application that performed the assessment. (defined for API consistency)
    property performer : TFhirReference{Resource} read FPerformer write SetPerformer;
    // The provider or software application that performed the assessment.
    property performerElement : TFhirReference{Resource} read FPerformer write SetPerformer;

    // Typed access to The reason the risk assessment was performed. (defined for API consistency)
    property reason : TFhirType read FReason write SetReason;
    // The reason the risk assessment was performed.
    property reasonElement : TFhirType read FReason write SetReason;

    // Indicates the source data considered as part of the assessment (FamilyHistory, Observations, Procedures, Conditions, etc.).
    property basisList : TFhirReferenceList{TFhirReference} read GetBasisList;
    property hasBasisList : boolean read GetHasBasisList;

    // Describes the expected outcome for the subject.
    property predictionList : TFhirRiskAssessmentPredictionList read GetPredictionList;
    property hasPredictionList : boolean read GetHasPredictionList;

    // Typed access to A description of the steps that might be taken to reduce the identified risk(s).
    property mitigation : String read GetMitigationST write SetMitigationST;
    // A description of the steps that might be taken to reduce the identified risk(s).
    property mitigationElement : TFhirString read FMitigation write SetMitigation;

    // Typed access to Additional comments about the risk assessment.
    property comment : String read GetCommentST write SetCommentST;
    // Additional comments about the risk assessment.
    property commentElement : TFhirString read FComment write SetComment;

  end;

  TFhirRiskAssessmentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRiskAssessmentList;
    function GetCurrent : TFhirRiskAssessment;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirRiskAssessmentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRiskAssessment read GetCurrent;
  end;

  TFhirRiskAssessmentList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirRiskAssessment;
    procedure SetItemN(index : Integer; value : TFhirRiskAssessment);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirRiskAssessmentList; Overload;
    function Clone : TFhirRiskAssessmentList; Overload;
    function GetEnumerator : TFhirRiskAssessmentListEnumerator;

    //  Add a FhirRiskAssessment to the end of the list.
    function Append : TFhirRiskAssessment;

    // Add an already existing FhirRiskAssessment to the end of the list.
    procedure AddItem(value : TFhirRiskAssessment); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRiskAssessment) : Integer;

    // Insert FhirRiskAssessment before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRiskAssessment;

    // Insert an existing FhirRiskAssessment before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRiskAssessment);

    // Get the iIndexth FhirRiskAssessment. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRiskAssessment);

    // The number of items in the collection
    function Item(index : Integer) : TFhirRiskAssessment;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirRiskAssessments[index : Integer] : TFhirRiskAssessment read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_RISKASSESSMENT}

{$IFDEF FHIR_SEQUENCE}

  // A sequence that is used as a reference to describe variants that are present in a sequence analyzed.
  TFhirSequenceReferenceSeq = class (TFhirBackboneElement)
  protected
    FChromosome : TFhirCodeableConcept;
    FGenomeBuild : TFhirString;
    FReferenceSeqId : TFhirCodeableConcept;
    FReferenceSeqPointer : TFhirReference{TFhirSequence};
    FReferenceSeqString : TFhirString;
    FStrand : TFhirInteger;
    FWindowStart : TFhirInteger;
    FWindowEnd : TFhirInteger;
    Procedure SetChromosome(value : TFhirCodeableConcept);
    Procedure SetGenomeBuild(value : TFhirString);
    Function GetGenomeBuildST : String;
    Procedure SetGenomeBuildST(value : String);
    Procedure SetReferenceSeqId(value : TFhirCodeableConcept);
    Procedure SetReferenceSeqPointer(value : TFhirReference{TFhirSequence});
    Procedure SetReferenceSeqString(value : TFhirString);
    Function GetReferenceSeqStringST : String;
    Procedure SetReferenceSeqStringST(value : String);
    Procedure SetStrand(value : TFhirInteger);
    Function GetStrandST : String;
    Procedure SetStrandST(value : String);
    Procedure SetWindowStart(value : TFhirInteger);
    Function GetWindowStartST : String;
    Procedure SetWindowStartST(value : String);
    Procedure SetWindowEnd(value : TFhirInteger);
    Function GetWindowEndST : String;
    Procedure SetWindowEndST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSequenceReferenceSeq; overload;
    function Clone : TFhirSequenceReferenceSeq; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Structural unit composed of a nucleic acid molecule which controls its own replication through the interaction of specific proteins at one or more origins of replication ([SO:0000340](http://www.sequenceontology.org/browser/current_svn/term/SO:0000340)). (defined for API consistency)
    property chromosome : TFhirCodeableConcept read FChromosome write SetChromosome;
    // Structural unit composed of a nucleic acid molecule which controls its own replication through the interaction of specific proteins at one or more origins of replication ([SO:0000340](http://www.sequenceontology.org/browser/current_svn/term/SO:0000340)).
    property chromosomeElement : TFhirCodeableConcept read FChromosome write SetChromosome;

    // Typed access to The Genome Build used for reference, following GRCh build versions e.g. 'GRCh 37'.  Version number must be included if a versioned release of a primary build was used.
    property genomeBuild : String read GetGenomeBuildST write SetGenomeBuildST;
    // The Genome Build used for reference, following GRCh build versions e.g. 'GRCh 37'.  Version number must be included if a versioned release of a primary build was used.
    property genomeBuildElement : TFhirString read FGenomeBuild write SetGenomeBuild;

    // Typed access to Reference identifier of reference sequence submitted to NCBI. It must match the type in the Sequence.type field. For example, the prefix, ?NG_? identifies reference sequence for genes, ?NM_? for messenger RNA transcripts, and ?NP_? for amino acid sequences. (defined for API consistency)
    property referenceSeqId : TFhirCodeableConcept read FReferenceSeqId write SetReferenceSeqId;
    // Reference identifier of reference sequence submitted to NCBI. It must match the type in the Sequence.type field. For example, the prefix, ?NG_? identifies reference sequence for genes, ?NM_? for messenger RNA transcripts, and ?NP_? for amino acid sequences.
    property referenceSeqIdElement : TFhirCodeableConcept read FReferenceSeqId write SetReferenceSeqId;

    // Typed access to A Pointer to another Sequence entity as reference sequence. (defined for API consistency)
    property referenceSeqPointer : TFhirReference{TFhirSequence} read FReferenceSeqPointer write SetReferenceSeqPointer;
    // A Pointer to another Sequence entity as reference sequence.
    property referenceSeqPointerElement : TFhirReference{TFhirSequence} read FReferenceSeqPointer write SetReferenceSeqPointer;

    // Typed access to A string like "ACGT".
    property referenceSeqString : String read GetReferenceSeqStringST write SetReferenceSeqStringST;
    // A string like "ACGT".
    property referenceSeqStringElement : TFhirString read FReferenceSeqString write SetReferenceSeqString;

    // Typed access to Directionality of DNA sequence. Available values are "1" for the plus strand (5' to 3')/Watson/Sense/positive  and "-1" for the minus strand(3' to 5')/Crick/Antisense/negative.
    property strand : String read GetStrandST write SetStrandST;
    // Directionality of DNA sequence. Available values are "1" for the plus strand (5' to 3')/Watson/Sense/positive  and "-1" for the minus strand(3' to 5')/Crick/Antisense/negative.
    property strandElement : TFhirInteger read FStrand write SetStrand;

    // Typed access to Start position of the window on the reference sequence. If the coordinate system is either 0-based or 1-based, then start position is inclusive.
    property windowStart : String read GetWindowStartST write SetWindowStartST;
    // Start position of the window on the reference sequence. If the coordinate system is either 0-based or 1-based, then start position is inclusive.
    property windowStartElement : TFhirInteger read FWindowStart write SetWindowStart;

    // Typed access to End position of the window on the reference sequence. If the coordinate system is 0-based then end is is exclusive and does not include the last position. If the coordinate system is 1-base, then end is inclusive and includes the last position.
    property windowEnd : String read GetWindowEndST write SetWindowEndST;
    // End position of the window on the reference sequence. If the coordinate system is 0-based then end is is exclusive and does not include the last position. If the coordinate system is 1-base, then end is inclusive and includes the last position.
    property windowEndElement : TFhirInteger read FWindowEnd write SetWindowEnd;

  end;

  TFhirSequenceReferenceSeqListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSequenceReferenceSeqList;
    function GetCurrent : TFhirSequenceReferenceSeq;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSequenceReferenceSeqList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSequenceReferenceSeq read GetCurrent;
  end;

  TFhirSequenceReferenceSeqList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSequenceReferenceSeq;
    procedure SetItemN(index : Integer; value : TFhirSequenceReferenceSeq);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSequenceReferenceSeqList; Overload;
    function Clone : TFhirSequenceReferenceSeqList; Overload;
    function GetEnumerator : TFhirSequenceReferenceSeqListEnumerator;

    //  Add a FhirSequenceReferenceSeq to the end of the list.
    function Append : TFhirSequenceReferenceSeq;

    // Add an already existing FhirSequenceReferenceSeq to the end of the list.
    procedure AddItem(value : TFhirSequenceReferenceSeq); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSequenceReferenceSeq) : Integer;

    // Insert FhirSequenceReferenceSeq before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSequenceReferenceSeq;

    // Insert an existing FhirSequenceReferenceSeq before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSequenceReferenceSeq);

    // Get the iIndexth FhirSequenceReferenceSeq. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSequenceReferenceSeq);

    // The number of items in the collection
    function Item(index : Integer) : TFhirSequenceReferenceSeq;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirSequenceReferenceSeqs[index : Integer] : TFhirSequenceReferenceSeq read GetItemN write SetItemN; default;
  End;

  // The definition of variant here originates from Sequence ontology ([variant_of](http://www.sequenceontology.org/browser/current_svn/term/variant_of)). This element can represent amino acid or nucleic sequence change(including insertion,deletion,SNP,etc.)  It can represent some complex mutation or segment variation with the assist of CIGAR string.
  TFhirSequenceVariant = class (TFhirBackboneElement)
  protected
    FStart : TFhirInteger;
    FEnd_ : TFhirInteger;
    FObservedAllele : TFhirString;
    FReferenceAllele : TFhirString;
    FCigar : TFhirString;
    FVariantPointer : TFhirReference{TFhirObservation};
    Procedure SetStart(value : TFhirInteger);
    Function GetStartST : String;
    Procedure SetStartST(value : String);
    Procedure SetEnd_(value : TFhirInteger);
    Function GetEnd_ST : String;
    Procedure SetEnd_ST(value : String);
    Procedure SetObservedAllele(value : TFhirString);
    Function GetObservedAlleleST : String;
    Procedure SetObservedAlleleST(value : String);
    Procedure SetReferenceAllele(value : TFhirString);
    Function GetReferenceAlleleST : String;
    Procedure SetReferenceAlleleST(value : String);
    Procedure SetCigar(value : TFhirString);
    Function GetCigarST : String;
    Procedure SetCigarST(value : String);
    Procedure SetVariantPointer(value : TFhirReference{TFhirObservation});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSequenceVariant; overload;
    function Clone : TFhirSequenceVariant; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Start position of the variant on the  reference sequence.If the coordinate system is either 0-based or 1-based, then start position is inclusive.
    property start : String read GetStartST write SetStartST;
    // Start position of the variant on the  reference sequence.If the coordinate system is either 0-based or 1-based, then start position is inclusive.
    property startElement : TFhirInteger read FStart write SetStart;

    // Typed access to End position of the variant on the reference sequence.If the coordinate system is 0-based then end is is exclusive and does not include the last position. If the coordinate system is 1-base, then end is inclusive and includes the last position.
    property end_ : String read GetEnd_ST write SetEnd_ST;
    // End position of the variant on the reference sequence.If the coordinate system is 0-based then end is is exclusive and does not include the last position. If the coordinate system is 1-base, then end is inclusive and includes the last position.
    property end_Element : TFhirInteger read FEnd_ write SetEnd_;

    // Typed access to An allele is one of a set of coexisting sequence variants of a gene ([SO:0001023](http://www.sequenceontology.org/browser/current_svn/term/SO:0001023)).  Nucleotide(s)/amino acids from start position of sequence to stop position of sequence on the positive (+) strand of the observed  sequence. When the sequence  type is DNA, it should be the sequence on the positive (+) strand. This will lay in the range between variant.start and variant.end.
    property observedAllele : String read GetObservedAlleleST write SetObservedAlleleST;
    // An allele is one of a set of coexisting sequence variants of a gene ([SO:0001023](http://www.sequenceontology.org/browser/current_svn/term/SO:0001023)).  Nucleotide(s)/amino acids from start position of sequence to stop position of sequence on the positive (+) strand of the observed  sequence. When the sequence  type is DNA, it should be the sequence on the positive (+) strand. This will lay in the range between variant.start and variant.end.
    property observedAlleleElement : TFhirString read FObservedAllele write SetObservedAllele;

    // Typed access to An allele is one of a set of coexisting sequence variants of a gene ([SO:0001023](http://www.sequenceontology.org/browser/current_svn/term/SO:0001023)). Nucleotide(s)/amino acids from start position of sequence to stop position of sequence on the positive (+) strand of the reference sequence. When the sequence  type is DNA, it should be the sequence on the positive (+) strand. This will lay in the range between variant.start and variant.end.
    property referenceAllele : String read GetReferenceAlleleST write SetReferenceAlleleST;
    // An allele is one of a set of coexisting sequence variants of a gene ([SO:0001023](http://www.sequenceontology.org/browser/current_svn/term/SO:0001023)). Nucleotide(s)/amino acids from start position of sequence to stop position of sequence on the positive (+) strand of the reference sequence. When the sequence  type is DNA, it should be the sequence on the positive (+) strand. This will lay in the range between variant.start and variant.end.
    property referenceAlleleElement : TFhirString read FReferenceAllele write SetReferenceAllele;

    // Typed access to Extended CIGAR string for aligning the sequence with reference bases. See detailed documentation [here](http://support.illumina.com/help/SequencingAnalysisWorkflow/Content/Vault/Informatics/Sequencing_Analysis/CASAVA/swSEQ_mCA_ExtendedCIGARFormat.htm).
    property cigar : String read GetCigarST write SetCigarST;
    // Extended CIGAR string for aligning the sequence with reference bases. See detailed documentation [here](http://support.illumina.com/help/SequencingAnalysisWorkflow/Content/Vault/Informatics/Sequencing_Analysis/CASAVA/swSEQ_mCA_ExtendedCIGARFormat.htm).
    property cigarElement : TFhirString read FCigar write SetCigar;

    // Typed access to A pointer to an Observation containing variant information. (defined for API consistency)
    property variantPointer : TFhirReference{TFhirObservation} read FVariantPointer write SetVariantPointer;
    // A pointer to an Observation containing variant information.
    property variantPointerElement : TFhirReference{TFhirObservation} read FVariantPointer write SetVariantPointer;

  end;

  TFhirSequenceVariantListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSequenceVariantList;
    function GetCurrent : TFhirSequenceVariant;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSequenceVariantList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSequenceVariant read GetCurrent;
  end;

  TFhirSequenceVariantList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSequenceVariant;
    procedure SetItemN(index : Integer; value : TFhirSequenceVariant);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSequenceVariantList; Overload;
    function Clone : TFhirSequenceVariantList; Overload;
    function GetEnumerator : TFhirSequenceVariantListEnumerator;

    //  Add a FhirSequenceVariant to the end of the list.
    function Append : TFhirSequenceVariant;

    // Add an already existing FhirSequenceVariant to the end of the list.
    procedure AddItem(value : TFhirSequenceVariant); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSequenceVariant) : Integer;

    // Insert FhirSequenceVariant before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSequenceVariant;

    // Insert an existing FhirSequenceVariant before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSequenceVariant);

    // Get the iIndexth FhirSequenceVariant. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSequenceVariant);

    // The number of items in the collection
    function Item(index : Integer) : TFhirSequenceVariant;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirSequenceVariants[index : Integer] : TFhirSequenceVariant read GetItemN write SetItemN; default;
  End;

  // An experimental feature attribute that defines the quality of the feature in a quantitative way, such as a phred quality score ([SO:0001686](http://www.sequenceontology.org/browser/current_svn/term/SO:0001686)).
  TFhirSequenceQuality = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FStandardSequence : TFhirCodeableConcept;
    FStart : TFhirInteger;
    FEnd_ : TFhirInteger;
    FScore : TFhirQuantity;
    FMethod : TFhirCodeableConcept;
    FTruthTP : TFhirDecimal;
    FQueryTP : TFhirDecimal;
    FTruthFN : TFhirDecimal;
    FQueryFP : TFhirDecimal;
    FGtFP : TFhirDecimal;
    FPrecision : TFhirDecimal;
    FRecall : TFhirDecimal;
    FFScore_ : TFhirDecimal;
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirQualityTypeEnum;
    Procedure SetType_ST(value : TFhirQualityTypeEnum);
    Procedure SetStandardSequence(value : TFhirCodeableConcept);
    Procedure SetStart(value : TFhirInteger);
    Function GetStartST : String;
    Procedure SetStartST(value : String);
    Procedure SetEnd_(value : TFhirInteger);
    Function GetEnd_ST : String;
    Procedure SetEnd_ST(value : String);
    Procedure SetScore(value : TFhirQuantity);
    Procedure SetMethod(value : TFhirCodeableConcept);
    Procedure SetTruthTP(value : TFhirDecimal);
    Function GetTruthTPST : String;
    Procedure SetTruthTPST(value : String);
    Procedure SetQueryTP(value : TFhirDecimal);
    Function GetQueryTPST : String;
    Procedure SetQueryTPST(value : String);
    Procedure SetTruthFN(value : TFhirDecimal);
    Function GetTruthFNST : String;
    Procedure SetTruthFNST(value : String);
    Procedure SetQueryFP(value : TFhirDecimal);
    Function GetQueryFPST : String;
    Procedure SetQueryFPST(value : String);
    Procedure SetGtFP(value : TFhirDecimal);
    Function GetGtFPST : String;
    Procedure SetGtFPST(value : String);
    Procedure SetPrecision(value : TFhirDecimal);
    Function GetPrecisionST : String;
    Procedure SetPrecisionST(value : String);
    Procedure SetRecall(value : TFhirDecimal);
    Function GetRecallST : String;
    Procedure SetRecallST(value : String);
    Procedure SetFScore_(value : TFhirDecimal);
    Function GetFScore_ST : String;
    Procedure SetFScore_ST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSequenceQuality; overload;
    function Clone : TFhirSequenceQuality; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // INDEL / SNP / Undefined variant.
    property type_ : TFhirQualityTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to Gold standard sequence used for comparing against. (defined for API consistency)
    property standardSequence : TFhirCodeableConcept read FStandardSequence write SetStandardSequence;
    // Gold standard sequence used for comparing against.
    property standardSequenceElement : TFhirCodeableConcept read FStandardSequence write SetStandardSequence;

    // Typed access to Start position of the sequence. If the coordinate system is either 0-based or 1-based, then start position is inclusive.
    property start : String read GetStartST write SetStartST;
    // Start position of the sequence. If the coordinate system is either 0-based or 1-based, then start position is inclusive.
    property startElement : TFhirInteger read FStart write SetStart;

    // Typed access to End position of the sequence.If the coordinate system is 0-based then end is is exclusive and does not include the last position. If the coordinate system is 1-base, then end is inclusive and includes the last position.
    property end_ : String read GetEnd_ST write SetEnd_ST;
    // End position of the sequence.If the coordinate system is 0-based then end is is exclusive and does not include the last position. If the coordinate system is 1-base, then end is inclusive and includes the last position.
    property end_Element : TFhirInteger read FEnd_ write SetEnd_;

    // Typed access to The score of an experimentally derived feature such as a p-value ([SO:0001685](http://www.sequenceontology.org/browser/current_svn/term/SO:0001685)). (defined for API consistency)
    property score : TFhirQuantity read FScore write SetScore;
    // The score of an experimentally derived feature such as a p-value ([SO:0001685](http://www.sequenceontology.org/browser/current_svn/term/SO:0001685)).
    property scoreElement : TFhirQuantity read FScore write SetScore;

    // Typed access to Which method is used to get sequence quality. (defined for API consistency)
    property method : TFhirCodeableConcept read FMethod write SetMethod;
    // Which method is used to get sequence quality.
    property methodElement : TFhirCodeableConcept read FMethod write SetMethod;

    // Typed access to True positives, from the perspective of the truth data, i.e. the number of sites in the Truth Call Set for which there are paths through the Query Call Set that are consistent with all of the alleles at this site, and for which there is an accurate genotype call for the event.
    property truthTP : String read GetTruthTPST write SetTruthTPST;
    // True positives, from the perspective of the truth data, i.e. the number of sites in the Truth Call Set for which there are paths through the Query Call Set that are consistent with all of the alleles at this site, and for which there is an accurate genotype call for the event.
    property truthTPElement : TFhirDecimal read FTruthTP write SetTruthTP;

    // Typed access to True positives, from the perspective of the query data, i.e. the number of sites in the Query Call Set for which there are paths through the Truth Call Set that are consistent with all of the alleles at this site, and for which there is an accurate genotype call for the event.
    property queryTP : String read GetQueryTPST write SetQueryTPST;
    // True positives, from the perspective of the query data, i.e. the number of sites in the Query Call Set for which there are paths through the Truth Call Set that are consistent with all of the alleles at this site, and for which there is an accurate genotype call for the event.
    property queryTPElement : TFhirDecimal read FQueryTP write SetQueryTP;

    // Typed access to False negatives, i.e. the number of sites in the Truth Call Set for which there is no path through the Query Call Set that is consistent with all of the alleles at this site, or sites for which there is an inaccurate genotype call for the event. Sites with correct variant but incorrect genotype are counted here.
    property truthFN : String read GetTruthFNST write SetTruthFNST;
    // False negatives, i.e. the number of sites in the Truth Call Set for which there is no path through the Query Call Set that is consistent with all of the alleles at this site, or sites for which there is an inaccurate genotype call for the event. Sites with correct variant but incorrect genotype are counted here.
    property truthFNElement : TFhirDecimal read FTruthFN write SetTruthFN;

    // Typed access to False positives, i.e. the number of sites in the Query Call Set for which there is no path through the Truth Call Set that is consistent with this site. Sites with correct variant but incorrect genotype are counted here.
    property queryFP : String read GetQueryFPST write SetQueryFPST;
    // False positives, i.e. the number of sites in the Query Call Set for which there is no path through the Truth Call Set that is consistent with this site. Sites with correct variant but incorrect genotype are counted here.
    property queryFPElement : TFhirDecimal read FQueryFP write SetQueryFP;

    // Typed access to The number of false positives where the non-REF alleles in the Truth and Query Call Sets match (i.e. cases where the truth is 1/1 and the query is 0/1 or similar).
    property gtFP : String read GetGtFPST write SetGtFPST;
    // The number of false positives where the non-REF alleles in the Truth and Query Call Sets match (i.e. cases where the truth is 1/1 and the query is 0/1 or similar).
    property gtFPElement : TFhirDecimal read FGtFP write SetGtFP;

    // Typed access to QUERY.TP / (QUERY.TP + QUERY.FP).
    property precision : String read GetPrecisionST write SetPrecisionST;
    // QUERY.TP / (QUERY.TP + QUERY.FP).
    property precisionElement : TFhirDecimal read FPrecision write SetPrecision;

    // Typed access to TRUTH.TP / (TRUTH.TP + TRUTH.FN).
    property recall : String read GetRecallST write SetRecallST;
    // TRUTH.TP / (TRUTH.TP + TRUTH.FN).
    property recallElement : TFhirDecimal read FRecall write SetRecall;

    // Typed access to Harmonic mean of Recall and Precision, computed as: 2 * precision * recall / (precision + recall).
    property fScore_ : String read GetFScore_ST write SetFScore_ST;
    // Harmonic mean of Recall and Precision, computed as: 2 * precision * recall / (precision + recall).
    property fScore_Element : TFhirDecimal read FFScore_ write SetFScore_;

  end;

  TFhirSequenceQualityListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSequenceQualityList;
    function GetCurrent : TFhirSequenceQuality;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSequenceQualityList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSequenceQuality read GetCurrent;
  end;

  TFhirSequenceQualityList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSequenceQuality;
    procedure SetItemN(index : Integer; value : TFhirSequenceQuality);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSequenceQualityList; Overload;
    function Clone : TFhirSequenceQualityList; Overload;
    function GetEnumerator : TFhirSequenceQualityListEnumerator;

    //  Add a FhirSequenceQuality to the end of the list.
    function Append : TFhirSequenceQuality;

    // Add an already existing FhirSequenceQuality to the end of the list.
    procedure AddItem(value : TFhirSequenceQuality); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSequenceQuality) : Integer;

    // Insert FhirSequenceQuality before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSequenceQuality;

    // Insert an existing FhirSequenceQuality before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSequenceQuality);

    // Get the iIndexth FhirSequenceQuality. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSequenceQuality);

    // The number of items in the collection
    function Item(index : Integer) : TFhirSequenceQuality;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirSequenceQualities[index : Integer] : TFhirSequenceQuality read GetItemN write SetItemN; default;
  End;

  // Configurations of the external repository. The repository shall store target's observedSeq or records related with target's observedSeq.
  TFhirSequenceRepository = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FUrl : TFhirUri;
    FName : TFhirString;
    FDatasetId : TFhirString;
    FVariantsetId : TFhirString;
    FReadsetId : TFhirString;
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirRepositoryTypeEnum;
    Procedure SetType_ST(value : TFhirRepositoryTypeEnum);
    Procedure SetUrl(value : TFhirUri);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetDatasetId(value : TFhirString);
    Function GetDatasetIdST : String;
    Procedure SetDatasetIdST(value : String);
    Procedure SetVariantsetId(value : TFhirString);
    Function GetVariantsetIdST : String;
    Procedure SetVariantsetIdST(value : String);
    Procedure SetReadsetId(value : TFhirString);
    Function GetReadsetIdST : String;
    Procedure SetReadsetIdST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSequenceRepository; overload;
    function Clone : TFhirSequenceRepository; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Click and see / RESTful API / Need login to see / RESTful API with authentication / Other ways to see resource.
    property type_ : TFhirRepositoryTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to URI of an external repository which contains further details about the genetics data.
    property url : String read GetUrlST write SetUrlST;
    // URI of an external repository which contains further details about the genetics data.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to URI of an external repository which contains further details about the genetics data.
    property name : String read GetNameST write SetNameST;
    // URI of an external repository which contains further details about the genetics data.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Id of the variant in this external repository. The server will understand how to use this id to call for more info about datasets in external repository.
    property datasetId : String read GetDatasetIdST write SetDatasetIdST;
    // Id of the variant in this external repository. The server will understand how to use this id to call for more info about datasets in external repository.
    property datasetIdElement : TFhirString read FDatasetId write SetDatasetId;

    // Typed access to Id of the variantset in this external repository. The server will understand how to use this id to call for more info about variantsets in external repository.
    property variantsetId : String read GetVariantsetIdST write SetVariantsetIdST;
    // Id of the variantset in this external repository. The server will understand how to use this id to call for more info about variantsets in external repository.
    property variantsetIdElement : TFhirString read FVariantsetId write SetVariantsetId;

    // Typed access to Id of the read in this external repository.
    property readsetId : String read GetReadsetIdST write SetReadsetIdST;
    // Id of the read in this external repository.
    property readsetIdElement : TFhirString read FReadsetId write SetReadsetId;

  end;

  TFhirSequenceRepositoryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSequenceRepositoryList;
    function GetCurrent : TFhirSequenceRepository;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSequenceRepositoryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSequenceRepository read GetCurrent;
  end;

  TFhirSequenceRepositoryList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSequenceRepository;
    procedure SetItemN(index : Integer; value : TFhirSequenceRepository);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSequenceRepositoryList; Overload;
    function Clone : TFhirSequenceRepositoryList; Overload;
    function GetEnumerator : TFhirSequenceRepositoryListEnumerator;

    //  Add a FhirSequenceRepository to the end of the list.
    function Append : TFhirSequenceRepository;

    // Add an already existing FhirSequenceRepository to the end of the list.
    procedure AddItem(value : TFhirSequenceRepository); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSequenceRepository) : Integer;

    // Insert FhirSequenceRepository before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSequenceRepository;

    // Insert an existing FhirSequenceRepository before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSequenceRepository);

    // Get the iIndexth FhirSequenceRepository. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSequenceRepository);

    // The number of items in the collection
    function Item(index : Integer) : TFhirSequenceRepository;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirSequenceRepositories[index : Integer] : TFhirSequenceRepository read GetItemN write SetItemN; default;
  End;

  // Raw data describing a biological sequence.
  TFhirSequence = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FType_ : TFhirCode;
    FCoordinateSystem : TFhirInteger;
    FPatient : TFhirReference{TFhirPatient};
    FSpecimen : TFhirReference{TFhirSpecimen};
    FDevice : TFhirReference{TFhirDevice};
    FPerformer : TFhirReference{TFhirOrganization};
    FQuantity : TFhirQuantity;
    FReferenceSeq : TFhirSequenceReferenceSeq;
    FvariantList : TFhirSequenceVariantList;
    FObservedSeq : TFhirString;
    FqualityList : TFhirSequenceQualityList;
    FReadCoverage : TFhirInteger;
    FrepositoryList : TFhirSequenceRepositoryList;
    FpointerList : TFhirReferenceList{TFhirSequence};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetType_(value : TFhirCode);
    Function GetType_ST : String;
    Procedure SetType_ST(value : String);
    Procedure SetCoordinateSystem(value : TFhirInteger);
    Function GetCoordinateSystemST : String;
    Procedure SetCoordinateSystemST(value : String);
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    Procedure SetSpecimen(value : TFhirReference{TFhirSpecimen});
    Procedure SetDevice(value : TFhirReference{TFhirDevice});
    Procedure SetPerformer(value : TFhirReference{TFhirOrganization});
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetReferenceSeq(value : TFhirSequenceReferenceSeq);
    function GetVariantList : TFhirSequenceVariantList;
    function GetHasVariantList : Boolean;
    Procedure SetObservedSeq(value : TFhirString);
    Function GetObservedSeqST : String;
    Procedure SetObservedSeqST(value : String);
    function GetQualityList : TFhirSequenceQualityList;
    function GetHasQualityList : Boolean;
    Procedure SetReadCoverage(value : TFhirInteger);
    Function GetReadCoverageST : String;
    Procedure SetReadCoverageST(value : String);
    function GetRepositoryList : TFhirSequenceRepositoryList;
    function GetHasRepositoryList : Boolean;
    function GetPointerList : TFhirReferenceList{TFhirSequence};
    function GetHasPointerList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSequence; overload;
    function Clone : TFhirSequence; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // A unique identifier for this particular sequence instance. This is a FHIR-defined id.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Amino Acid Sequence/ DNA Sequence / RNA Sequence.
    property type_ : String read GetType_ST write SetType_ST;
    // Amino Acid Sequence/ DNA Sequence / RNA Sequence.
    property type_Element : TFhirCode read FType_ write SetType_;

    // Typed access to Whether the sequence is numbered starting at 0 (0-based numbering or coordinates, inclusive start, exclusive end) or starting at 1 (1-based numbering, inclusive start and inclusive end).
    property coordinateSystem : String read GetCoordinateSystemST write SetCoordinateSystemST;
    // Whether the sequence is numbered starting at 0 (0-based numbering or coordinates, inclusive start, exclusive end) or starting at 1 (1-based numbering, inclusive start and inclusive end).
    property coordinateSystemElement : TFhirInteger read FCoordinateSystem write SetCoordinateSystem;

    // Typed access to The patient whose sequencing results are described by this resource. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // The patient whose sequencing results are described by this resource.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Typed access to Specimen used for sequencing. (defined for API consistency)
    property specimen : TFhirReference{TFhirSpecimen} read FSpecimen write SetSpecimen;
    // Specimen used for sequencing.
    property specimenElement : TFhirReference{TFhirSpecimen} read FSpecimen write SetSpecimen;

    // Typed access to The method for sequencing, for example, chip information. (defined for API consistency)
    property device : TFhirReference{TFhirDevice} read FDevice write SetDevice;
    // The method for sequencing, for example, chip information.
    property deviceElement : TFhirReference{TFhirDevice} read FDevice write SetDevice;

    // Typed access to The organization or lab that should be responsible for this result. (defined for API consistency)
    property performer : TFhirReference{TFhirOrganization} read FPerformer write SetPerformer;
    // The organization or lab that should be responsible for this result.
    property performerElement : TFhirReference{TFhirOrganization} read FPerformer write SetPerformer;

    // Typed access to The number of copies of the seqeunce of interest. (RNASeq). (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of copies of the seqeunce of interest. (RNASeq).
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to A sequence that is used as a reference to describe variants that are present in a sequence analyzed. (defined for API consistency)
    property referenceSeq : TFhirSequenceReferenceSeq read FReferenceSeq write SetReferenceSeq;
    // A sequence that is used as a reference to describe variants that are present in a sequence analyzed.
    property referenceSeqElement : TFhirSequenceReferenceSeq read FReferenceSeq write SetReferenceSeq;

    // The definition of variant here originates from Sequence ontology ([variant_of](http://www.sequenceontology.org/browser/current_svn/term/variant_of)). This element can represent amino acid or nucleic sequence change(including insertion,deletion,SNP,etc.)  It can represent some complex mutation or segment variation with the assist of CIGAR string.
    property variantList : TFhirSequenceVariantList read GetVariantList;
    property hasVariantList : boolean read GetHasVariantList;

    // Typed access to Sequence that was observed. It is the result marked by referenceSeq along with variant records on referenceSeq. This shall starts from referenceSeq.windowStart and end by referenceSeq.windowEnd.
    property observedSeq : String read GetObservedSeqST write SetObservedSeqST;
    // Sequence that was observed. It is the result marked by referenceSeq along with variant records on referenceSeq. This shall starts from referenceSeq.windowStart and end by referenceSeq.windowEnd.
    property observedSeqElement : TFhirString read FObservedSeq write SetObservedSeq;

    // An experimental feature attribute that defines the quality of the feature in a quantitative way, such as a phred quality score ([SO:0001686](http://www.sequenceontology.org/browser/current_svn/term/SO:0001686)).
    property qualityList : TFhirSequenceQualityList read GetQualityList;
    property hasQualityList : boolean read GetHasQualityList;

    // Typed access to Coverage (read depth or depth) is the average number of reads representing a given nucleotide in the reconstructed sequence.
    property readCoverage : String read GetReadCoverageST write SetReadCoverageST;
    // Coverage (read depth or depth) is the average number of reads representing a given nucleotide in the reconstructed sequence.
    property readCoverageElement : TFhirInteger read FReadCoverage write SetReadCoverage;

    // Configurations of the external repository. The repository shall store target's observedSeq or records related with target's observedSeq.
    property repositoryList : TFhirSequenceRepositoryList read GetRepositoryList;
    property hasRepositoryList : boolean read GetHasRepositoryList;

    // Pointer to next atomic sequence which at most contains one variant.
    property pointerList : TFhirReferenceList{TFhirSequence} read GetPointerList;
    property hasPointerList : boolean read GetHasPointerList;

  end;

  TFhirSequenceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSequenceList;
    function GetCurrent : TFhirSequence;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSequenceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSequence read GetCurrent;
  end;

  TFhirSequenceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSequence;
    procedure SetItemN(index : Integer; value : TFhirSequence);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSequenceList; Overload;
    function Clone : TFhirSequenceList; Overload;
    function GetEnumerator : TFhirSequenceListEnumerator;

    //  Add a FhirSequence to the end of the list.
    function Append : TFhirSequence;

    // Add an already existing FhirSequence to the end of the list.
    procedure AddItem(value : TFhirSequence); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSequence) : Integer;

    // Insert FhirSequence before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSequence;

    // Insert an existing FhirSequence before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSequence);

    // Get the iIndexth FhirSequence. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSequence);

    // The number of items in the collection
    function Item(index : Integer) : TFhirSequence;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirSequences[index : Integer] : TFhirSequence read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SEQUENCE}

{$IFDEF FHIR_SPECIMEN}

  // Details concerning the specimen collection.
  TFhirSpecimenCollection = class (TFhirBackboneElement)
  protected
    FCollector : TFhirReference{TFhirPractitioner};
    FCollected : TFhirType;
    FQuantity : TFhirQuantity;
    FMethod : TFhirCodeableConcept;
    FBodySite : TFhirCodeableConcept;
    Procedure SetCollector(value : TFhirReference{TFhirPractitioner});
    Procedure SetCollected(value : TFhirType);
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetMethod(value : TFhirCodeableConcept);
    Procedure SetBodySite(value : TFhirCodeableConcept);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSpecimenCollection; overload;
    function Clone : TFhirSpecimenCollection; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Person who collected the specimen. (defined for API consistency)
    property collector : TFhirReference{TFhirPractitioner} read FCollector write SetCollector;
    // Person who collected the specimen.
    property collectorElement : TFhirReference{TFhirPractitioner} read FCollector write SetCollector;

    // Typed access to Time when specimen was collected from subject - the physiologically relevant time. (defined for API consistency)
    property collected : TFhirType read FCollected write SetCollected;
    // Time when specimen was collected from subject - the physiologically relevant time.
    property collectedElement : TFhirType read FCollected write SetCollected;

    // Typed access to The quantity of specimen collected; for instance the volume of a blood sample, or the physical measurement of an anatomic pathology sample. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The quantity of specimen collected; for instance the volume of a blood sample, or the physical measurement of an anatomic pathology sample.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to A coded value specifying the technique that is used to perform the procedure. (defined for API consistency)
    property method : TFhirCodeableConcept read FMethod write SetMethod;
    // A coded value specifying the technique that is used to perform the procedure.
    property methodElement : TFhirCodeableConcept read FMethod write SetMethod;

    // Typed access to Anatomical location from which the specimen was collected (if subject is a patient). This is the target site.  This element is not used for environmental specimens. (defined for API consistency)
    property bodySite : TFhirCodeableConcept read FBodySite write SetBodySite;
    // Anatomical location from which the specimen was collected (if subject is a patient). This is the target site.  This element is not used for environmental specimens.
    property bodySiteElement : TFhirCodeableConcept read FBodySite write SetBodySite;

  end;

  TFhirSpecimenCollectionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSpecimenCollectionList;
    function GetCurrent : TFhirSpecimenCollection;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSpecimenCollectionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSpecimenCollection read GetCurrent;
  end;

  TFhirSpecimenCollectionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSpecimenCollection;
    procedure SetItemN(index : Integer; value : TFhirSpecimenCollection);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSpecimenCollectionList; Overload;
    function Clone : TFhirSpecimenCollectionList; Overload;
    function GetEnumerator : TFhirSpecimenCollectionListEnumerator;

    //  Add a FhirSpecimenCollection to the end of the list.
    function Append : TFhirSpecimenCollection;

    // Add an already existing FhirSpecimenCollection to the end of the list.
    procedure AddItem(value : TFhirSpecimenCollection); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSpecimenCollection) : Integer;

    // Insert FhirSpecimenCollection before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSpecimenCollection;

    // Insert an existing FhirSpecimenCollection before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSpecimenCollection);

    // Get the iIndexth FhirSpecimenCollection. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSpecimenCollection);

    // The number of items in the collection
    function Item(index : Integer) : TFhirSpecimenCollection;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirSpecimenCollections[index : Integer] : TFhirSpecimenCollection read GetItemN write SetItemN; default;
  End;

  // Details concerning processing and processing steps for the specimen.
  TFhirSpecimenProcessing = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FProcedure_ : TFhirCodeableConcept;
    FadditiveList : TFhirReferenceList{TFhirSubstance};
    FTime : TFhirType;
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetProcedure_(value : TFhirCodeableConcept);
    function GetAdditiveList : TFhirReferenceList{TFhirSubstance};
    function GetHasAdditiveList : Boolean;
    Procedure SetTime(value : TFhirType);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSpecimenProcessing; overload;
    function Clone : TFhirSpecimenProcessing; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Textual description of procedure.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Textual description of procedure.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to A coded value specifying the procedure used to process the specimen. (defined for API consistency)
    property procedure_ : TFhirCodeableConcept read FProcedure_ write SetProcedure_;
    // A coded value specifying the procedure used to process the specimen.
    property procedure_Element : TFhirCodeableConcept read FProcedure_ write SetProcedure_;

    // Material used in the processing step.
    property additiveList : TFhirReferenceList{TFhirSubstance} read GetAdditiveList;
    property hasAdditiveList : boolean read GetHasAdditiveList;

    // Typed access to A record of the time or period when the specimen processing occurred.  For example the time of sample fixation or the period of time the sample was in formalin. (defined for API consistency)
    property time : TFhirType read FTime write SetTime;
    // A record of the time or period when the specimen processing occurred.  For example the time of sample fixation or the period of time the sample was in formalin.
    property timeElement : TFhirType read FTime write SetTime;

  end;

  TFhirSpecimenProcessingListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSpecimenProcessingList;
    function GetCurrent : TFhirSpecimenProcessing;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSpecimenProcessingList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSpecimenProcessing read GetCurrent;
  end;

  TFhirSpecimenProcessingList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSpecimenProcessing;
    procedure SetItemN(index : Integer; value : TFhirSpecimenProcessing);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSpecimenProcessingList; Overload;
    function Clone : TFhirSpecimenProcessingList; Overload;
    function GetEnumerator : TFhirSpecimenProcessingListEnumerator;

    //  Add a FhirSpecimenProcessing to the end of the list.
    function Append : TFhirSpecimenProcessing;

    // Add an already existing FhirSpecimenProcessing to the end of the list.
    procedure AddItem(value : TFhirSpecimenProcessing); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSpecimenProcessing) : Integer;

    // Insert FhirSpecimenProcessing before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSpecimenProcessing;

    // Insert an existing FhirSpecimenProcessing before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSpecimenProcessing);

    // Get the iIndexth FhirSpecimenProcessing. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSpecimenProcessing);

    // The number of items in the collection
    function Item(index : Integer) : TFhirSpecimenProcessing;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirSpecimenProcessings[index : Integer] : TFhirSpecimenProcessing read GetItemN write SetItemN; default;
  End;

  // The container holding the specimen.  The recursive nature of containers; i.e. blood in tube in tray in rack is not addressed here.
  TFhirSpecimenContainer = class (TFhirBackboneElement)
  protected
    FidentifierList : TFhirIdentifierList;
    FDescription : TFhirString;
    FType_ : TFhirCodeableConcept;
    FCapacity : TFhirQuantity;
    FSpecimenQuantity : TFhirQuantity;
    FAdditive : TFhirType;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetCapacity(value : TFhirQuantity);
    Procedure SetSpecimenQuantity(value : TFhirQuantity);
    Procedure SetAdditive(value : TFhirType);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSpecimenContainer; overload;
    function Clone : TFhirSpecimenContainer; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Id for container. There may be multiple; a manufacturer's bar code, lab assigned identifier, etc. The container ID may differ from the specimen id in some circumstances.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Textual description of the container.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Textual description of the container.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to The type of container associated with the specimen (e.g. slide, aliquot, etc.). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of container associated with the specimen (e.g. slide, aliquot, etc.).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The capacity (volume or other measure) the container may contain. (defined for API consistency)
    property capacity : TFhirQuantity read FCapacity write SetCapacity;
    // The capacity (volume or other measure) the container may contain.
    property capacityElement : TFhirQuantity read FCapacity write SetCapacity;

    // Typed access to The quantity of specimen in the container; may be volume, dimensions, or other appropriate measurements, depending on the specimen type. (defined for API consistency)
    property specimenQuantity : TFhirQuantity read FSpecimenQuantity write SetSpecimenQuantity;
    // The quantity of specimen in the container; may be volume, dimensions, or other appropriate measurements, depending on the specimen type.
    property specimenQuantityElement : TFhirQuantity read FSpecimenQuantity write SetSpecimenQuantity;

    // Typed access to Introduced substance to preserve, maintain or enhance the specimen. Examples: Formalin, Citrate, EDTA. (defined for API consistency)
    property additive : TFhirType read FAdditive write SetAdditive;
    // Introduced substance to preserve, maintain or enhance the specimen. Examples: Formalin, Citrate, EDTA.
    property additiveElement : TFhirType read FAdditive write SetAdditive;

  end;

  TFhirSpecimenContainerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSpecimenContainerList;
    function GetCurrent : TFhirSpecimenContainer;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSpecimenContainerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSpecimenContainer read GetCurrent;
  end;

  TFhirSpecimenContainerList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSpecimenContainer;
    procedure SetItemN(index : Integer; value : TFhirSpecimenContainer);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSpecimenContainerList; Overload;
    function Clone : TFhirSpecimenContainerList; Overload;
    function GetEnumerator : TFhirSpecimenContainerListEnumerator;

    //  Add a FhirSpecimenContainer to the end of the list.
    function Append : TFhirSpecimenContainer;

    // Add an already existing FhirSpecimenContainer to the end of the list.
    procedure AddItem(value : TFhirSpecimenContainer); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSpecimenContainer) : Integer;

    // Insert FhirSpecimenContainer before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSpecimenContainer;

    // Insert an existing FhirSpecimenContainer before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSpecimenContainer);

    // Get the iIndexth FhirSpecimenContainer. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSpecimenContainer);

    // The number of items in the collection
    function Item(index : Integer) : TFhirSpecimenContainer;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirSpecimenContainers[index : Integer] : TFhirSpecimenContainer read GetItemN write SetItemN; default;
  End;

  // A sample to be used for analysis.
  TFhirSpecimen = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FAccessionIdentifier : TFhirIdentifier;
    FStatus : TFhirEnum;
    FType_ : TFhirCodeableConcept;
    FSubject : TFhirReference{Resource};
    FReceivedTime : TFhirDateTime;
    FparentList : TFhirReferenceList{TFhirSpecimen};
    FrequestList : TFhirReferenceList{TFhirProcedureRequest};
    FCollection : TFhirSpecimenCollection;
    FprocessingList : TFhirSpecimenProcessingList;
    FcontainerList : TFhirSpecimenContainerList;
    FnoteList : TFhirAnnotationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetAccessionIdentifier(value : TFhirIdentifier);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirSpecimenStatusEnum;
    Procedure SetStatusST(value : TFhirSpecimenStatusEnum);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetSubject(value : TFhirReference{Resource});
    Procedure SetReceivedTime(value : TFhirDateTime);
    Function GetReceivedTimeST : TFslDateTime;
    Procedure SetReceivedTimeST(value : TFslDateTime);
    function GetParentList : TFhirReferenceList{TFhirSpecimen};
    function GetHasParentList : Boolean;
    function GetRequestList : TFhirReferenceList{TFhirProcedureRequest};
    function GetHasRequestList : Boolean;
    Procedure SetCollection(value : TFhirSpecimenCollection);
    function GetProcessingList : TFhirSpecimenProcessingList;
    function GetHasProcessingList : Boolean;
    function GetContainerList : TFhirSpecimenContainerList;
    function GetHasContainerList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSpecimen; overload;
    function Clone : TFhirSpecimen; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Id for specimen.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier assigned by the lab when accessioning specimen(s). This is not necessarily the same as the specimen identifier, depending on local lab procedures. (defined for API consistency)
    property accessionIdentifier : TFhirIdentifier read FAccessionIdentifier write SetAccessionIdentifier;
    // The identifier assigned by the lab when accessioning specimen(s). This is not necessarily the same as the specimen identifier, depending on local lab procedures.
    property accessionIdentifierElement : TFhirIdentifier read FAccessionIdentifier write SetAccessionIdentifier;

    // The availability of the specimen.
    property status : TFhirSpecimenStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The kind of material that forms the specimen. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The kind of material that forms the specimen.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Where the specimen came from. This may be from the patient(s) or from the environment or a device. (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // Where the specimen came from. This may be from the patient(s) or from the environment or a device.
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // Typed access to Time when specimen was received for processing or testing.
    property receivedTime : TFslDateTime read GetReceivedTimeST write SetReceivedTimeST;
    // Time when specimen was received for processing or testing.
    property receivedTimeElement : TFhirDateTime read FReceivedTime write SetReceivedTime;

    // Reference to the parent (source) specimen which is used when the specimen was either derived from or a component of another specimen.
    property parentList : TFhirReferenceList{TFhirSpecimen} read GetParentList;
    property hasParentList : boolean read GetHasParentList;

    // Details concerning a test or procedure request that required a specimen to be collected.
    property requestList : TFhirReferenceList{TFhirProcedureRequest} read GetRequestList;
    property hasRequestList : boolean read GetHasRequestList;

    // Typed access to Details concerning the specimen collection. (defined for API consistency)
    property collection : TFhirSpecimenCollection read FCollection write SetCollection;
    // Details concerning the specimen collection.
    property collectionElement : TFhirSpecimenCollection read FCollection write SetCollection;

    // Details concerning processing and processing steps for the specimen.
    property processingList : TFhirSpecimenProcessingList read GetProcessingList;
    property hasProcessingList : boolean read GetHasProcessingList;

    // The container holding the specimen.  The recursive nature of containers; i.e. blood in tube in tray in rack is not addressed here.
    property containerList : TFhirSpecimenContainerList read GetContainerList;
    property hasContainerList : boolean read GetHasContainerList;

    // To communicate any details or issues about the specimen or during the specimen collection. (for example: broken vial, sent with patient, frozen).
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirSpecimenListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSpecimenList;
    function GetCurrent : TFhirSpecimen;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSpecimenList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSpecimen read GetCurrent;
  end;

  TFhirSpecimenList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSpecimen;
    procedure SetItemN(index : Integer; value : TFhirSpecimen);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSpecimenList; Overload;
    function Clone : TFhirSpecimenList; Overload;
    function GetEnumerator : TFhirSpecimenListEnumerator;

    //  Add a FhirSpecimen to the end of the list.
    function Append : TFhirSpecimen;

    // Add an already existing FhirSpecimen to the end of the list.
    procedure AddItem(value : TFhirSpecimen); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSpecimen) : Integer;

    // Insert FhirSpecimen before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSpecimen;

    // Insert an existing FhirSpecimen before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSpecimen);

    // Get the iIndexth FhirSpecimen. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSpecimen);

    // The number of items in the collection
    function Item(index : Integer) : TFhirSpecimen;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirSpecimen[index : Integer] : TFhirSpecimen read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SPECIMEN}

{$IFDEF FHIR_SUPPLYDELIVERY}

  // The item that is being delivered or has been supplied.
  TFhirSupplyDeliverySuppliedItem = class (TFhirBackboneElement)
  protected
    FQuantity : TFhirQuantity;
    FItem : TFhirType;
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetItem(value : TFhirType);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSupplyDeliverySuppliedItem; overload;
    function Clone : TFhirSupplyDeliverySuppliedItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The amount of supply that has been dispensed. Includes unit of measure. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The amount of supply that has been dispensed. Includes unit of measure.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to Identifies the medication, substance or device being dispensed. This is either a link to a resource representing the details of the item or a code that identifies the item from a known list. (defined for API consistency)
    property item : TFhirType read FItem write SetItem;
    // Identifies the medication, substance or device being dispensed. This is either a link to a resource representing the details of the item or a code that identifies the item from a known list.
    property itemElement : TFhirType read FItem write SetItem;

  end;

  TFhirSupplyDeliverySuppliedItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSupplyDeliverySuppliedItemList;
    function GetCurrent : TFhirSupplyDeliverySuppliedItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSupplyDeliverySuppliedItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSupplyDeliverySuppliedItem read GetCurrent;
  end;

  TFhirSupplyDeliverySuppliedItemList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSupplyDeliverySuppliedItem;
    procedure SetItemN(index : Integer; value : TFhirSupplyDeliverySuppliedItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSupplyDeliverySuppliedItemList; Overload;
    function Clone : TFhirSupplyDeliverySuppliedItemList; Overload;
    function GetEnumerator : TFhirSupplyDeliverySuppliedItemListEnumerator;

    //  Add a FhirSupplyDeliverySuppliedItem to the end of the list.
    function Append : TFhirSupplyDeliverySuppliedItem;

    // Add an already existing FhirSupplyDeliverySuppliedItem to the end of the list.
    procedure AddItem(value : TFhirSupplyDeliverySuppliedItem); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSupplyDeliverySuppliedItem) : Integer;

    // Insert FhirSupplyDeliverySuppliedItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSupplyDeliverySuppliedItem;

    // Insert an existing FhirSupplyDeliverySuppliedItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSupplyDeliverySuppliedItem);

    // Get the iIndexth FhirSupplyDeliverySuppliedItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSupplyDeliverySuppliedItem);

    // The number of items in the collection
    function Item(index : Integer) : TFhirSupplyDeliverySuppliedItem;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirSupplyDeliverySuppliedItems[index : Integer] : TFhirSupplyDeliverySuppliedItem read GetItemN write SetItemN; default;
  End;

  // Record of delivery of what is supplied.
  TFhirSupplyDelivery = class (TFhirDomainResource)
  protected
    FIdentifier : TFhirIdentifier;
    FbasedOnList : TFhirReferenceList{TFhirSupplyRequest};
    FpartOfList : TFhirReferenceList{Resource};
    FStatus : TFhirEnum;
    FPatient : TFhirReference{TFhirPatient};
    FType_ : TFhirCodeableConcept;
    FSuppliedItem : TFhirSupplyDeliverySuppliedItem;
    FOccurrence : TFhirType;
    FSupplier : TFhirReference{Resource};
    FDestination : TFhirReference{TFhirLocation};
    FreceiverList : TFhirReferenceList{TFhirPractitioner};
    Procedure SetIdentifier(value : TFhirIdentifier);
    function GetBasedOnList : TFhirReferenceList{TFhirSupplyRequest};
    function GetHasBasedOnList : Boolean;
    function GetPartOfList : TFhirReferenceList{Resource};
    function GetHasPartOfList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirSupplydeliveryStatusEnum;
    Procedure SetStatusST(value : TFhirSupplydeliveryStatusEnum);
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetSuppliedItem(value : TFhirSupplyDeliverySuppliedItem);
    Procedure SetOccurrence(value : TFhirType);
    Procedure SetSupplier(value : TFhirReference{Resource});
    Procedure SetDestination(value : TFhirReference{TFhirLocation});
    function GetReceiverList : TFhirReferenceList{TFhirPractitioner};
    function GetHasReceiverList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSupplyDelivery; overload;
    function Clone : TFhirSupplyDelivery; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Identifier assigned by the dispensing facility when the item(s) is dispensed. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Identifier assigned by the dispensing facility when the item(s) is dispensed.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // A plan, proposal or order that is fulfilled in whole or in part by this event.
    property basedOnList : TFhirReferenceList{TFhirSupplyRequest} read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // A larger event of which this particular event is a component or step.
    property partOfList : TFhirReferenceList{Resource} read GetPartOfList;
    property hasPartOfList : boolean read GetHasPartOfList;

    // A code specifying the state of the dispense event.
    property status : TFhirSupplydeliveryStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A link to a resource representing the person whom the delivered item is for. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // A link to a resource representing the person whom the delivered item is for.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Typed access to Indicates the type of dispensing event that is performed. Examples include: Trial Fill, Completion of Trial, Partial Fill, Emergency Fill, Samples, etc. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Indicates the type of dispensing event that is performed. Examples include: Trial Fill, Completion of Trial, Partial Fill, Emergency Fill, Samples, etc.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The item that is being delivered or has been supplied. (defined for API consistency)
    property suppliedItem : TFhirSupplyDeliverySuppliedItem read FSuppliedItem write SetSuppliedItem;
    // The item that is being delivered or has been supplied.
    property suppliedItemElement : TFhirSupplyDeliverySuppliedItem read FSuppliedItem write SetSuppliedItem;

    // Typed access to The date or time(s) the activity occurred. (defined for API consistency)
    property occurrence : TFhirType read FOccurrence write SetOccurrence;
    // The date or time(s) the activity occurred.
    property occurrenceElement : TFhirType read FOccurrence write SetOccurrence;

    // Typed access to The individual responsible for dispensing the medication, supplier or device. (defined for API consistency)
    property supplier : TFhirReference{Resource} read FSupplier write SetSupplier;
    // The individual responsible for dispensing the medication, supplier or device.
    property supplierElement : TFhirReference{Resource} read FSupplier write SetSupplier;

    // Typed access to Identification of the facility/location where the Supply was shipped to, as part of the dispense event. (defined for API consistency)
    property destination : TFhirReference{TFhirLocation} read FDestination write SetDestination;
    // Identification of the facility/location where the Supply was shipped to, as part of the dispense event.
    property destinationElement : TFhirReference{TFhirLocation} read FDestination write SetDestination;

    // Identifies the person who picked up the Supply.
    property receiverList : TFhirReferenceList{TFhirPractitioner} read GetReceiverList;
    property hasReceiverList : boolean read GetHasReceiverList;

  end;

  TFhirSupplyDeliveryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSupplyDeliveryList;
    function GetCurrent : TFhirSupplyDelivery;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSupplyDeliveryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSupplyDelivery read GetCurrent;
  end;

  TFhirSupplyDeliveryList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSupplyDelivery;
    procedure SetItemN(index : Integer; value : TFhirSupplyDelivery);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSupplyDeliveryList; Overload;
    function Clone : TFhirSupplyDeliveryList; Overload;
    function GetEnumerator : TFhirSupplyDeliveryListEnumerator;

    //  Add a FhirSupplyDelivery to the end of the list.
    function Append : TFhirSupplyDelivery;

    // Add an already existing FhirSupplyDelivery to the end of the list.
    procedure AddItem(value : TFhirSupplyDelivery); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSupplyDelivery) : Integer;

    // Insert FhirSupplyDelivery before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSupplyDelivery;

    // Insert an existing FhirSupplyDelivery before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSupplyDelivery);

    // Get the iIndexth FhirSupplyDelivery. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSupplyDelivery);

    // The number of items in the collection
    function Item(index : Integer) : TFhirSupplyDelivery;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirSupplyDeliveries[index : Integer] : TFhirSupplyDelivery read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SUPPLYDELIVERY}

{$IFDEF FHIR_SUPPLYREQUEST}

  // The item being requested.
  TFhirSupplyRequestOrderedItem = class (TFhirBackboneElement)
  protected
    FQuantity : TFhirQuantity;
    FItem : TFhirType;
    Procedure SetQuantity(value : TFhirQuantity);
    Procedure SetItem(value : TFhirType);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSupplyRequestOrderedItem; overload;
    function Clone : TFhirSupplyRequestOrderedItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The amount that is being ordered of the indicated item. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The amount that is being ordered of the indicated item.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to The item that is requested to be supplied. This is either a link to a resource representing the details of the item or a code that identifies the item from a known list. (defined for API consistency)
    property item : TFhirType read FItem write SetItem;
    // The item that is requested to be supplied. This is either a link to a resource representing the details of the item or a code that identifies the item from a known list.
    property itemElement : TFhirType read FItem write SetItem;

  end;

  TFhirSupplyRequestOrderedItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSupplyRequestOrderedItemList;
    function GetCurrent : TFhirSupplyRequestOrderedItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSupplyRequestOrderedItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSupplyRequestOrderedItem read GetCurrent;
  end;

  TFhirSupplyRequestOrderedItemList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSupplyRequestOrderedItem;
    procedure SetItemN(index : Integer; value : TFhirSupplyRequestOrderedItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSupplyRequestOrderedItemList; Overload;
    function Clone : TFhirSupplyRequestOrderedItemList; Overload;
    function GetEnumerator : TFhirSupplyRequestOrderedItemListEnumerator;

    //  Add a FhirSupplyRequestOrderedItem to the end of the list.
    function Append : TFhirSupplyRequestOrderedItem;

    // Add an already existing FhirSupplyRequestOrderedItem to the end of the list.
    procedure AddItem(value : TFhirSupplyRequestOrderedItem); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSupplyRequestOrderedItem) : Integer;

    // Insert FhirSupplyRequestOrderedItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSupplyRequestOrderedItem;

    // Insert an existing FhirSupplyRequestOrderedItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSupplyRequestOrderedItem);

    // Get the iIndexth FhirSupplyRequestOrderedItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSupplyRequestOrderedItem);

    // The number of items in the collection
    function Item(index : Integer) : TFhirSupplyRequestOrderedItem;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirSupplyRequestOrderedItems[index : Integer] : TFhirSupplyRequestOrderedItem read GetItemN write SetItemN; default;
  End;

  // The individual who initiated the request and has responsibility for its activation.
  TFhirSupplyRequestRequester = class (TFhirBackboneElement)
  protected
    FAgent : TFhirReference{Resource};
    FOnBehalfOf : TFhirReference{TFhirOrganization};
    Procedure SetAgent(value : TFhirReference{Resource});
    Procedure SetOnBehalfOf(value : TFhirReference{TFhirOrganization});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSupplyRequestRequester; overload;
    function Clone : TFhirSupplyRequestRequester; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The device, practitioner, etc. who initiated the request. (defined for API consistency)
    property agent : TFhirReference{Resource} read FAgent write SetAgent;
    // The device, practitioner, etc. who initiated the request.
    property agentElement : TFhirReference{Resource} read FAgent write SetAgent;

    // Typed access to The organization the device or practitioner was acting on behalf of. (defined for API consistency)
    property onBehalfOf : TFhirReference{TFhirOrganization} read FOnBehalfOf write SetOnBehalfOf;
    // The organization the device or practitioner was acting on behalf of.
    property onBehalfOfElement : TFhirReference{TFhirOrganization} read FOnBehalfOf write SetOnBehalfOf;

  end;

  TFhirSupplyRequestRequesterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSupplyRequestRequesterList;
    function GetCurrent : TFhirSupplyRequestRequester;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSupplyRequestRequesterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSupplyRequestRequester read GetCurrent;
  end;

  TFhirSupplyRequestRequesterList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSupplyRequestRequester;
    procedure SetItemN(index : Integer; value : TFhirSupplyRequestRequester);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSupplyRequestRequesterList; Overload;
    function Clone : TFhirSupplyRequestRequesterList; Overload;
    function GetEnumerator : TFhirSupplyRequestRequesterListEnumerator;

    //  Add a FhirSupplyRequestRequester to the end of the list.
    function Append : TFhirSupplyRequestRequester;

    // Add an already existing FhirSupplyRequestRequester to the end of the list.
    procedure AddItem(value : TFhirSupplyRequestRequester); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSupplyRequestRequester) : Integer;

    // Insert FhirSupplyRequestRequester before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSupplyRequestRequester;

    // Insert an existing FhirSupplyRequestRequester before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSupplyRequestRequester);

    // Get the iIndexth FhirSupplyRequestRequester. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSupplyRequestRequester);

    // The number of items in the collection
    function Item(index : Integer) : TFhirSupplyRequestRequester;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirSupplyRequestRequesters[index : Integer] : TFhirSupplyRequestRequester read GetItemN write SetItemN; default;
  End;

  // A record of a request for a medication, substance or device used in the healthcare setting.
  TFhirSupplyRequest = class (TFhirDomainResource)
  protected
    FIdentifier : TFhirIdentifier;
    FStatus : TFhirEnum;
    FCategory : TFhirCodeableConcept;
    FPriority : TFhirEnum;
    FOrderedItem : TFhirSupplyRequestOrderedItem;
    FOccurrence : TFhirType;
    FAuthoredOn : TFhirDateTime;
    FRequester : TFhirSupplyRequestRequester;
    FsupplierList : TFhirReferenceList{TFhirOrganization};
    FReason : TFhirType;
    FDeliverFrom : TFhirReference{Resource};
    FDeliverTo : TFhirReference{Resource};
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirSupplyrequestStatusEnum;
    Procedure SetStatusST(value : TFhirSupplyrequestStatusEnum);
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetPriority(value : TFhirEnum);
    Function GetPriorityST : TFhirRequestPriorityEnum;
    Procedure SetPriorityST(value : TFhirRequestPriorityEnum);
    Procedure SetOrderedItem(value : TFhirSupplyRequestOrderedItem);
    Procedure SetOccurrence(value : TFhirType);
    Procedure SetAuthoredOn(value : TFhirDateTime);
    Function GetAuthoredOnST : TFslDateTime;
    Procedure SetAuthoredOnST(value : TFslDateTime);
    Procedure SetRequester(value : TFhirSupplyRequestRequester);
    function GetSupplierList : TFhirReferenceList{TFhirOrganization};
    function GetHasSupplierList : Boolean;
    Procedure SetReason(value : TFhirType);
    Procedure SetDeliverFrom(value : TFhirReference{Resource});
    Procedure SetDeliverTo(value : TFhirReference{Resource});

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSupplyRequest; overload;
    function Clone : TFhirSupplyRequest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Unique identifier for this supply request. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Unique identifier for this supply request.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Status of the supply request.
    property status : TFhirSupplyrequestStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Category of supply, e.g.  central, non-stock, etc. This is used to support work flows associated with the supply process. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Category of supply, e.g.  central, non-stock, etc. This is used to support work flows associated with the supply process.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Indicates how quickly this SupplyRequest should be addressed with respect to other requests.
    property priority : TFhirRequestPriorityEnum read GetPriorityST write SetPriorityST;
    property priorityElement : TFhirEnum read FPriority write SetPriority;

    // Typed access to The item being requested. (defined for API consistency)
    property orderedItem : TFhirSupplyRequestOrderedItem read FOrderedItem write SetOrderedItem;
    // The item being requested.
    property orderedItemElement : TFhirSupplyRequestOrderedItem read FOrderedItem write SetOrderedItem;

    // Typed access to When the request should be fulfilled. (defined for API consistency)
    property occurrence : TFhirType read FOccurrence write SetOccurrence;
    // When the request should be fulfilled.
    property occurrenceElement : TFhirType read FOccurrence write SetOccurrence;

    // Typed access to When the request was made.
    property authoredOn : TFslDateTime read GetAuthoredOnST write SetAuthoredOnST;
    // When the request was made.
    property authoredOnElement : TFhirDateTime read FAuthoredOn write SetAuthoredOn;

    // Typed access to The individual who initiated the request and has responsibility for its activation. (defined for API consistency)
    property requester : TFhirSupplyRequestRequester read FRequester write SetRequester;
    // The individual who initiated the request and has responsibility for its activation.
    property requesterElement : TFhirSupplyRequestRequester read FRequester write SetRequester;

    // Who is intended to fulfill the request.
    property supplierList : TFhirReferenceList{TFhirOrganization} read GetSupplierList;
    property hasSupplierList : boolean read GetHasSupplierList;

    // Typed access to Why the supply item was requested. (defined for API consistency)
    property reason : TFhirType read FReason write SetReason;
    // Why the supply item was requested.
    property reasonElement : TFhirType read FReason write SetReason;

    // Typed access to Where the supply is expected to come from. (defined for API consistency)
    property deliverFrom : TFhirReference{Resource} read FDeliverFrom write SetDeliverFrom;
    // Where the supply is expected to come from.
    property deliverFromElement : TFhirReference{Resource} read FDeliverFrom write SetDeliverFrom;

    // Typed access to Where the supply is destined to go. (defined for API consistency)
    property deliverTo : TFhirReference{Resource} read FDeliverTo write SetDeliverTo;
    // Where the supply is destined to go.
    property deliverToElement : TFhirReference{Resource} read FDeliverTo write SetDeliverTo;

  end;

  TFhirSupplyRequestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSupplyRequestList;
    function GetCurrent : TFhirSupplyRequest;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSupplyRequestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSupplyRequest read GetCurrent;
  end;

  TFhirSupplyRequestList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSupplyRequest;
    procedure SetItemN(index : Integer; value : TFhirSupplyRequest);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSupplyRequestList; Overload;
    function Clone : TFhirSupplyRequestList; Overload;
    function GetEnumerator : TFhirSupplyRequestListEnumerator;

    //  Add a FhirSupplyRequest to the end of the list.
    function Append : TFhirSupplyRequest;

    // Add an already existing FhirSupplyRequest to the end of the list.
    procedure AddItem(value : TFhirSupplyRequest); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSupplyRequest) : Integer;

    // Insert FhirSupplyRequest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSupplyRequest;

    // Insert an existing FhirSupplyRequest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSupplyRequest);

    // Get the iIndexth FhirSupplyRequest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSupplyRequest);

    // The number of items in the collection
    function Item(index : Integer) : TFhirSupplyRequest;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirSupplyRequests[index : Integer] : TFhirSupplyRequest read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SUPPLYREQUEST}

{$IFDEF FHIR_VISIONPRESCRIPTION}

  // Deals with details of the dispense part of the supply specification.
  TFhirVisionPrescriptionDispense = class (TFhirBackboneElement)
  protected
    FProduct : TFhirCodeableConcept;
    FEye : TFhirEnum;
    FSphere : TFhirDecimal;
    FCylinder : TFhirDecimal;
    FAxis : TFhirInteger;
    FPrism : TFhirDecimal;
    FBase : TFhirEnum;
    FAdd : TFhirDecimal;
    FPower : TFhirDecimal;
    FBackCurve : TFhirDecimal;
    FDiameter : TFhirDecimal;
    FDuration : TFhirQuantity;
    FColor : TFhirString;
    FBrand : TFhirString;
    FnoteList : TFhirAnnotationList;
    Procedure SetProduct(value : TFhirCodeableConcept);
    Procedure SetEye(value : TFhirEnum);
    Function GetEyeST : TFhirVisionEyeCodesEnum;
    Procedure SetEyeST(value : TFhirVisionEyeCodesEnum);
    Procedure SetSphere(value : TFhirDecimal);
    Function GetSphereST : String;
    Procedure SetSphereST(value : String);
    Procedure SetCylinder(value : TFhirDecimal);
    Function GetCylinderST : String;
    Procedure SetCylinderST(value : String);
    Procedure SetAxis(value : TFhirInteger);
    Function GetAxisST : String;
    Procedure SetAxisST(value : String);
    Procedure SetPrism(value : TFhirDecimal);
    Function GetPrismST : String;
    Procedure SetPrismST(value : String);
    Procedure SetBase(value : TFhirEnum);
    Function GetBaseST : TFhirVisionBaseCodesEnum;
    Procedure SetBaseST(value : TFhirVisionBaseCodesEnum);
    Procedure SetAdd(value : TFhirDecimal);
    Function GetAddST : String;
    Procedure SetAddST(value : String);
    Procedure SetPower(value : TFhirDecimal);
    Function GetPowerST : String;
    Procedure SetPowerST(value : String);
    Procedure SetBackCurve(value : TFhirDecimal);
    Function GetBackCurveST : String;
    Procedure SetBackCurveST(value : String);
    Procedure SetDiameter(value : TFhirDecimal);
    Function GetDiameterST : String;
    Procedure SetDiameterST(value : String);
    Procedure SetDuration(value : TFhirQuantity);
    Procedure SetColor(value : TFhirString);
    Function GetColorST : String;
    Procedure SetColorST(value : String);
    Procedure SetBrand(value : TFhirString);
    Function GetBrandST : String;
    Procedure SetBrandST(value : String);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirVisionPrescriptionDispense; overload;
    function Clone : TFhirVisionPrescriptionDispense; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Identifies the type of vision correction product which is required for the patient. (defined for API consistency)
    property product : TFhirCodeableConcept read FProduct write SetProduct;
    // Identifies the type of vision correction product which is required for the patient.
    property productElement : TFhirCodeableConcept read FProduct write SetProduct;

    // The eye for which the lens applies.
    property eye : TFhirVisionEyeCodesEnum read GetEyeST write SetEyeST;
    property eyeElement : TFhirEnum read FEye write SetEye;

    // Typed access to Lens power measured in diopters (0.25 units).
    property sphere : String read GetSphereST write SetSphereST;
    // Lens power measured in diopters (0.25 units).
    property sphereElement : TFhirDecimal read FSphere write SetSphere;

    // Typed access to Power adjustment for astigmatism measured in diopters (0.25 units).
    property cylinder : String read GetCylinderST write SetCylinderST;
    // Power adjustment for astigmatism measured in diopters (0.25 units).
    property cylinderElement : TFhirDecimal read FCylinder write SetCylinder;

    // Typed access to Adjustment for astigmatism measured in integer degrees.
    property axis : String read GetAxisST write SetAxisST;
    // Adjustment for astigmatism measured in integer degrees.
    property axisElement : TFhirInteger read FAxis write SetAxis;

    // Typed access to Amount of prism to compensate for eye alignment in fractional units.
    property prism : String read GetPrismST write SetPrismST;
    // Amount of prism to compensate for eye alignment in fractional units.
    property prismElement : TFhirDecimal read FPrism write SetPrism;

    // The relative base, or reference lens edge, for the prism.
    property base : TFhirVisionBaseCodesEnum read GetBaseST write SetBaseST;
    property baseElement : TFhirEnum read FBase write SetBase;

    // Typed access to Power adjustment for multifocal lenses measured in diopters (0.25 units).
    property add : String read GetAddST write SetAddST;
    // Power adjustment for multifocal lenses measured in diopters (0.25 units).
    property addElement : TFhirDecimal read FAdd write SetAdd;

    // Typed access to Contact lens power measured in diopters (0.25 units).
    property power : String read GetPowerST write SetPowerST;
    // Contact lens power measured in diopters (0.25 units).
    property powerElement : TFhirDecimal read FPower write SetPower;

    // Typed access to Back curvature measured in millimeters.
    property backCurve : String read GetBackCurveST write SetBackCurveST;
    // Back curvature measured in millimeters.
    property backCurveElement : TFhirDecimal read FBackCurve write SetBackCurve;

    // Typed access to Contact lens diameter measured in millimeters.
    property diameter : String read GetDiameterST write SetDiameterST;
    // Contact lens diameter measured in millimeters.
    property diameterElement : TFhirDecimal read FDiameter write SetDiameter;

    // Typed access to The recommended maximum wear period for the lens. (defined for API consistency)
    property duration : TFhirQuantity read FDuration write SetDuration;
    // The recommended maximum wear period for the lens.
    property durationElement : TFhirQuantity read FDuration write SetDuration;

    // Typed access to Special color or pattern.
    property color : String read GetColorST write SetColorST;
    // Special color or pattern.
    property colorElement : TFhirString read FColor write SetColor;

    // Typed access to Brand recommendations or restrictions.
    property brand : String read GetBrandST write SetBrandST;
    // Brand recommendations or restrictions.
    property brandElement : TFhirString read FBrand write SetBrand;

    // Notes for special requirements such as coatings and lens materials.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirVisionPrescriptionDispenseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirVisionPrescriptionDispenseList;
    function GetCurrent : TFhirVisionPrescriptionDispense;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirVisionPrescriptionDispenseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirVisionPrescriptionDispense read GetCurrent;
  end;

  TFhirVisionPrescriptionDispenseList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirVisionPrescriptionDispense;
    procedure SetItemN(index : Integer; value : TFhirVisionPrescriptionDispense);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirVisionPrescriptionDispenseList; Overload;
    function Clone : TFhirVisionPrescriptionDispenseList; Overload;
    function GetEnumerator : TFhirVisionPrescriptionDispenseListEnumerator;

    //  Add a FhirVisionPrescriptionDispense to the end of the list.
    function Append : TFhirVisionPrescriptionDispense;

    // Add an already existing FhirVisionPrescriptionDispense to the end of the list.
    procedure AddItem(value : TFhirVisionPrescriptionDispense); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirVisionPrescriptionDispense) : Integer;

    // Insert FhirVisionPrescriptionDispense before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirVisionPrescriptionDispense;

    // Insert an existing FhirVisionPrescriptionDispense before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirVisionPrescriptionDispense);

    // Get the iIndexth FhirVisionPrescriptionDispense. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirVisionPrescriptionDispense);

    // The number of items in the collection
    function Item(index : Integer) : TFhirVisionPrescriptionDispense;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirVisionPrescriptionDispenses[index : Integer] : TFhirVisionPrescriptionDispense read GetItemN write SetItemN; default;
  End;

  // An authorization for the supply of glasses and/or contact lenses to a patient.
  TFhirVisionPrescription = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FPatient : TFhirReference{TFhirPatient};
    FEncounter : TFhirReference{TFhirEncounter};
    FDateWritten : TFhirDateTime;
    FPrescriber : TFhirReference{TFhirPractitioner};
    FReason : TFhirType;
    FdispenseList : TFhirVisionPrescriptionDispenseList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirFmStatusEnum;
    Procedure SetStatusST(value : TFhirFmStatusEnum);
    Procedure SetPatient(value : TFhirReference{TFhirPatient});
    Procedure SetEncounter(value : TFhirReference{TFhirEncounter});
    Procedure SetDateWritten(value : TFhirDateTime);
    Function GetDateWrittenST : TFslDateTime;
    Procedure SetDateWrittenST(value : TFslDateTime);
    Procedure SetPrescriber(value : TFhirReference{TFhirPractitioner});
    Procedure SetReason(value : TFhirType);
    function GetDispenseList : TFhirVisionPrescriptionDispenseList;
    function GetHasDispenseList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirVisionPrescription; overload;
    function Clone : TFhirVisionPrescription; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Business identifier which may be used by other parties to reference or identify the prescription.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirFmStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A link to a resource representing the person to whom the vision products will be supplied. (defined for API consistency)
    property patient : TFhirReference{TFhirPatient} read FPatient write SetPatient;
    // A link to a resource representing the person to whom the vision products will be supplied.
    property patientElement : TFhirReference{TFhirPatient} read FPatient write SetPatient;

    // Typed access to A link to a resource that identifies the particular occurrence of contact between patient and health care provider. (defined for API consistency)
    property encounter : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;
    // A link to a resource that identifies the particular occurrence of contact between patient and health care provider.
    property encounterElement : TFhirReference{TFhirEncounter} read FEncounter write SetEncounter;

    // Typed access to The date (and perhaps time) when the prescription was written.
    property dateWritten : TFslDateTime read GetDateWrittenST write SetDateWrittenST;
    // The date (and perhaps time) when the prescription was written.
    property dateWrittenElement : TFhirDateTime read FDateWritten write SetDateWritten;

    // Typed access to The healthcare professional responsible for authorizing the prescription. (defined for API consistency)
    property prescriber : TFhirReference{TFhirPractitioner} read FPrescriber write SetPrescriber;
    // The healthcare professional responsible for authorizing the prescription.
    property prescriberElement : TFhirReference{TFhirPractitioner} read FPrescriber write SetPrescriber;

    // Typed access to Can be the reason or the indication for writing the prescription. (defined for API consistency)
    property reason : TFhirType read FReason write SetReason;
    // Can be the reason or the indication for writing the prescription.
    property reasonElement : TFhirType read FReason write SetReason;

    // Deals with details of the dispense part of the supply specification.
    property dispenseList : TFhirVisionPrescriptionDispenseList read GetDispenseList;
    property hasDispenseList : boolean read GetHasDispenseList;

  end;

  TFhirVisionPrescriptionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirVisionPrescriptionList;
    function GetCurrent : TFhirVisionPrescription;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirVisionPrescriptionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirVisionPrescription read GetCurrent;
  end;

  TFhirVisionPrescriptionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirVisionPrescription;
    procedure SetItemN(index : Integer; value : TFhirVisionPrescription);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirVisionPrescriptionList; Overload;
    function Clone : TFhirVisionPrescriptionList; Overload;
    function GetEnumerator : TFhirVisionPrescriptionListEnumerator;

    //  Add a FhirVisionPrescription to the end of the list.
    function Append : TFhirVisionPrescription;

    // Add an already existing FhirVisionPrescription to the end of the list.
    procedure AddItem(value : TFhirVisionPrescription); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirVisionPrescription) : Integer;

    // Insert FhirVisionPrescription before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirVisionPrescription;

    // Insert an existing FhirVisionPrescription before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirVisionPrescription);

    // Get the iIndexth FhirVisionPrescription. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirVisionPrescription);

    // The number of items in the collection
    function Item(index : Integer) : TFhirVisionPrescription;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirVisionPrescriptions[index : Integer] : TFhirVisionPrescription read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_VISIONPRESCRIPTION}

implementation

uses
  fhir3_utilities;

{$IFDEF FHIR_ACCOUNT}

{ TFhirAccountCoverage }

constructor TFhirAccountCoverage.Create;
begin
  inherited;
end;

destructor TFhirAccountCoverage.Destroy;
begin
  FCoverage.free;
  FPriority.free;
  inherited;
end;

procedure TFhirAccountCoverage.Assign(oSource : TFslObject);
begin
  inherited;
  coverage := TFhirAccountCoverage(oSource).coverage.Clone;
  priorityElement := TFhirAccountCoverage(oSource).priorityElement.Clone;
end;

procedure TFhirAccountCoverage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'coverage') Then
     list.add(self.link, 'coverage', FCoverage.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
end;

procedure TFhirAccountCoverage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'coverage', 'Reference(Coverage)', false, TFhirReference{TFhirCoverage}, FCoverage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'priority', 'positiveInt', false, TFhirPositiveInt, FPriority.Link));{2}
end;

function TFhirAccountCoverage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'coverage') then
  begin
    Coverage := propValue as TFhirReference{TFhirCoverage}{4b};
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAccountCoverage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirAccountCoverage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'coverage') then result := TFhirReference{TFhirCoverage}.create(){4b}
  else if (propName = 'priority') then result := TFhirPositiveInt.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAccountCoverage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'coverage') then result := 'Reference'
  else if (propName = 'priority') then result := 'positiveInt'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAccountCoverage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'coverage') then CoverageElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAccountCoverage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'coverage') then CoverageElement := new as TFhirReference{TFhirCoverage}{4}
  else if (propName = 'priority') then PriorityElement := asPositiveInt(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAccountCoverage.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirAccountCoverage.fhirType : string;
begin
  result := 'coverage';
end;

function TFhirAccountCoverage.Link : TFhirAccountCoverage;
begin
  result := TFhirAccountCoverage(inherited Link);
end;

function TFhirAccountCoverage.Clone : TFhirAccountCoverage;
begin
  result := TFhirAccountCoverage(inherited Clone);
end;

function TFhirAccountCoverage.equals(other : TObject) : boolean;
var
  o : TFhirAccountCoverage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAccountCoverage)) then
    result := false
  else
  begin
    o := TFhirAccountCoverage(other);
    result := compareDeep(coverageElement, o.coverageElement, true) and compareDeep(priorityElement, o.priorityElement, true);
  end;
end;

function TFhirAccountCoverage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCoverage) and isEmptyProp(FPriority);
end;

procedure TFhirAccountCoverage.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('coverage');
  fields.add('priority');
end;

{ TFhirAccountCoverage }

Procedure TFhirAccountCoverage.SetCoverage(value : TFhirReference{TFhirCoverage});
begin
  FCoverage.free;
  FCoverage := value;
end;

Procedure TFhirAccountCoverage.SetPriority(value : TFhirPositiveInt);
begin
  FPriority.free;
  FPriority := value;
end;

Function TFhirAccountCoverage.GetPriorityST : String;
begin
  if FPriority = nil then
    result := ''
  else
    result := FPriority.value;
end;

Procedure TFhirAccountCoverage.SetPriorityST(value : String);
begin
  if value <> '' then
  begin
    if FPriority = nil then
      FPriority := TFhirPositiveInt.create;
    FPriority.value := value
  end
  else if FPriority <> nil then
    FPriority.value := '';
end;

function TFhirAccountCoverage.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCoverage.sizeInBytes);
  inc(result, FPriority.sizeInBytes);
end;

{ TFhirAccountCoverageListEnumerator }

Constructor TFhirAccountCoverageListEnumerator.Create(list : TFhirAccountCoverageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAccountCoverageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAccountCoverageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAccountCoverageListEnumerator.GetCurrent : TFhirAccountCoverage;
begin
  Result := FList[FIndex];
end;

function TFhirAccountCoverageListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAccountCoverageList }
procedure TFhirAccountCoverageList.AddItem(value: TFhirAccountCoverage);
begin
  assert(value.ClassName = 'TFhirAccountCoverage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAccountCoverage');
  add(value);
end;

function TFhirAccountCoverageList.Append: TFhirAccountCoverage;
begin
  result := TFhirAccountCoverage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAccountCoverageList.ClearItems;
begin
  Clear;
end;

function TFhirAccountCoverageList.GetEnumerator : TFhirAccountCoverageListEnumerator;
begin
  result := TFhirAccountCoverageListEnumerator.Create(self.link);
end;

function TFhirAccountCoverageList.Clone: TFhirAccountCoverageList;
begin
  result := TFhirAccountCoverageList(inherited Clone);
end;

function TFhirAccountCoverageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAccountCoverageList.GetItemN(index: Integer): TFhirAccountCoverage;
begin
  result := TFhirAccountCoverage(ObjectByIndex[index]);
end;

function TFhirAccountCoverageList.ItemClass: TFslObjectClass;
begin
  result := TFhirAccountCoverage;
end;
function TFhirAccountCoverageList.IndexOf(value: TFhirAccountCoverage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAccountCoverageList.Insert(index: Integer): TFhirAccountCoverage;
begin
  result := TFhirAccountCoverage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAccountCoverageList.InsertItem(index: Integer; value: TFhirAccountCoverage);
begin
  assert(value is TFhirAccountCoverage);
  Inherited Insert(index, value);
end;

function TFhirAccountCoverageList.Item(index: Integer): TFhirAccountCoverage;
begin
  result := TFhirAccountCoverage(ObjectByIndex[index]);
end;

function TFhirAccountCoverageList.Link: TFhirAccountCoverageList;
begin
  result := TFhirAccountCoverageList(inherited Link);
end;

procedure TFhirAccountCoverageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAccountCoverageList.SetItemByIndex(index: Integer; value: TFhirAccountCoverage);
begin
  assert(value is TFhirAccountCoverage);
  FhirAccountCoverages[index] := value;
end;

procedure TFhirAccountCoverageList.SetItemN(index: Integer; value: TFhirAccountCoverage);
begin
  assert(value is TFhirAccountCoverage);
  ObjectByIndex[index] := value;
end;

{ TFhirAccountGuarantor }

constructor TFhirAccountGuarantor.Create;
begin
  inherited;
end;

destructor TFhirAccountGuarantor.Destroy;
begin
  FParty.free;
  FOnHold.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirAccountGuarantor.Assign(oSource : TFslObject);
begin
  inherited;
  party := TFhirAccountGuarantor(oSource).party.Clone;
  onHoldElement := TFhirAccountGuarantor(oSource).onHoldElement.Clone;
  period := TFhirAccountGuarantor(oSource).period.Clone;
end;

procedure TFhirAccountGuarantor.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'party') Then
     list.add(self.link, 'party', FParty.Link);
  if (child_name = 'onHold') Then
     list.add(self.link, 'onHold', FOnHold.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirAccountGuarantor.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'party', 'Reference(Patient|RelatedPerson|Organization)', false, TFhirReference{Resource}, FParty.Link));{2}
  oList.add(TFHIRProperty.create(self, 'onHold', 'boolean', false, TFhirBoolean, FOnHold.Link));{2}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
end;

function TFhirAccountGuarantor.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'party') then
  begin
    Party := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'onHold') then
  begin
    OnHoldElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAccountGuarantor.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirAccountGuarantor.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'party') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'onHold') then result := TFhirBoolean.create() {5b}
  else if (propName = 'period') then result := TFhirPeriod.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAccountGuarantor.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'party') then result := 'Reference'
  else if (propName = 'onHold') then result := 'boolean'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAccountGuarantor.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'party') then PartyElement := nil
  else if (propName = 'onHold') then OnHoldElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAccountGuarantor.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'party') then PartyElement := new as TFhirReference{Resource}{4}
  else if (propName = 'onHold') then OnHoldElement := asBoolean(new){5b}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAccountGuarantor.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirAccountGuarantor.fhirType : string;
begin
  result := 'guarantor';
end;

function TFhirAccountGuarantor.Link : TFhirAccountGuarantor;
begin
  result := TFhirAccountGuarantor(inherited Link);
end;

function TFhirAccountGuarantor.Clone : TFhirAccountGuarantor;
begin
  result := TFhirAccountGuarantor(inherited Clone);
end;

function TFhirAccountGuarantor.equals(other : TObject) : boolean;
var
  o : TFhirAccountGuarantor;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAccountGuarantor)) then
    result := false
  else
  begin
    o := TFhirAccountGuarantor(other);
    result := compareDeep(partyElement, o.partyElement, true) and compareDeep(onHoldElement, o.onHoldElement, true) and
      compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirAccountGuarantor.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FParty) and isEmptyProp(FOnHold) and isEmptyProp(FPeriod);
end;

procedure TFhirAccountGuarantor.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('party');
  fields.add('onHold');
  fields.add('period');
end;

{ TFhirAccountGuarantor }

Procedure TFhirAccountGuarantor.SetParty(value : TFhirReference{Resource});
begin
  FParty.free;
  FParty := value;
end;

Procedure TFhirAccountGuarantor.SetOnHold(value : TFhirBoolean);
begin
  FOnHold.free;
  FOnHold := value;
end;

Function TFhirAccountGuarantor.GetOnHoldST : Boolean;
begin
  if FOnHold = nil then
    result := false
  else
    result := FOnHold.value;
end;

Procedure TFhirAccountGuarantor.SetOnHoldST(value : Boolean);
begin
  if FOnHold = nil then
    FOnHold := TFhirBoolean.create;
  FOnHold.value := value
end;

Procedure TFhirAccountGuarantor.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

function TFhirAccountGuarantor.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FParty.sizeInBytes);
  inc(result, FOnHold.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
end;

{ TFhirAccountGuarantorListEnumerator }

Constructor TFhirAccountGuarantorListEnumerator.Create(list : TFhirAccountGuarantorList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAccountGuarantorListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAccountGuarantorListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAccountGuarantorListEnumerator.GetCurrent : TFhirAccountGuarantor;
begin
  Result := FList[FIndex];
end;

function TFhirAccountGuarantorListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAccountGuarantorList }
procedure TFhirAccountGuarantorList.AddItem(value: TFhirAccountGuarantor);
begin
  assert(value.ClassName = 'TFhirAccountGuarantor', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAccountGuarantor');
  add(value);
end;

function TFhirAccountGuarantorList.Append: TFhirAccountGuarantor;
begin
  result := TFhirAccountGuarantor.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAccountGuarantorList.ClearItems;
begin
  Clear;
end;

function TFhirAccountGuarantorList.GetEnumerator : TFhirAccountGuarantorListEnumerator;
begin
  result := TFhirAccountGuarantorListEnumerator.Create(self.link);
end;

function TFhirAccountGuarantorList.Clone: TFhirAccountGuarantorList;
begin
  result := TFhirAccountGuarantorList(inherited Clone);
end;

function TFhirAccountGuarantorList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAccountGuarantorList.GetItemN(index: Integer): TFhirAccountGuarantor;
begin
  result := TFhirAccountGuarantor(ObjectByIndex[index]);
end;

function TFhirAccountGuarantorList.ItemClass: TFslObjectClass;
begin
  result := TFhirAccountGuarantor;
end;
function TFhirAccountGuarantorList.IndexOf(value: TFhirAccountGuarantor): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAccountGuarantorList.Insert(index: Integer): TFhirAccountGuarantor;
begin
  result := TFhirAccountGuarantor.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAccountGuarantorList.InsertItem(index: Integer; value: TFhirAccountGuarantor);
begin
  assert(value is TFhirAccountGuarantor);
  Inherited Insert(index, value);
end;

function TFhirAccountGuarantorList.Item(index: Integer): TFhirAccountGuarantor;
begin
  result := TFhirAccountGuarantor(ObjectByIndex[index]);
end;

function TFhirAccountGuarantorList.Link: TFhirAccountGuarantorList;
begin
  result := TFhirAccountGuarantorList(inherited Link);
end;

procedure TFhirAccountGuarantorList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAccountGuarantorList.SetItemByIndex(index: Integer; value: TFhirAccountGuarantor);
begin
  assert(value is TFhirAccountGuarantor);
  FhirAccountGuarantors[index] := value;
end;

procedure TFhirAccountGuarantorList.SetItemN(index: Integer; value: TFhirAccountGuarantor);
begin
  assert(value is TFhirAccountGuarantor);
  ObjectByIndex[index] := value;
end;

{ TFhirAccount }

constructor TFhirAccount.Create;
begin
  inherited;
end;

destructor TFhirAccount.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FType_.free;
  FName.free;
  FSubject.free;
  FPeriod.free;
  FActive.free;
  FBalance.free;
  FCoverageList.Free;
  FOwner.free;
  FDescription.free;
  FGuarantorList.Free;
  inherited;
end;

function TFhirAccount.GetResourceType : TFhirResourceType;
begin
  result := frtAccount;
end;

procedure TFhirAccount.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirAccount(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirAccount(oSource).FIdentifierList);
  end;
  FStatus := TFhirAccount(oSource).FStatus.Link;
  type_ := TFhirAccount(oSource).type_.Clone;
  nameElement := TFhirAccount(oSource).nameElement.Clone;
  subject := TFhirAccount(oSource).subject.Clone;
  period := TFhirAccount(oSource).period.Clone;
  active := TFhirAccount(oSource).active.Clone;
  balance := TFhirAccount(oSource).balance.Clone;
  if (TFhirAccount(oSource).FCoverageList = nil) then
  begin
    FCoverageList.free;
    FCoverageList := nil;
  end
  else
  begin
    if FCoverageList = nil then
      FCoverageList := TFhirAccountCoverageList.Create;
    FCoverageList.Assign(TFhirAccount(oSource).FCoverageList);
  end;
  owner := TFhirAccount(oSource).owner.Clone;
  descriptionElement := TFhirAccount(oSource).descriptionElement.Clone;
  if (TFhirAccount(oSource).FGuarantorList = nil) then
  begin
    FGuarantorList.free;
    FGuarantorList := nil;
  end
  else
  begin
    if FGuarantorList = nil then
      FGuarantorList := TFhirAccountGuarantorList.Create;
    FGuarantorList.Assign(TFhirAccount(oSource).FGuarantorList);
  end;
end;

procedure TFhirAccount.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'balance') Then
     list.add(self.link, 'balance', FBalance.Link);
  if (child_name = 'coverage') Then
    list.addAll(self, 'coverage', FCoverageList);
  if (child_name = 'owner') Then
     list.add(self.link, 'owner', FOwner.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'guarantor') Then
    list.addAll(self, 'guarantor', FGuarantorList);
end;

procedure TFhirAccount.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Device|Practitioner|Location|HealthcareService|Organization)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'active', 'Period', false, TFhirPeriod, FActive.Link));{2}
  oList.add(TFHIRProperty.create(self, 'balance', 'Money', false, TFhirMoney, FBalance.Link));{2}
  oList.add(TFHIRProperty.create(self, 'coverage', '', true, TFhirAccountCoverage, FCoverageList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'owner', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FOwner.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'guarantor', '', true, TFhirAccountGuarantor, FGuarantorList.Link)){3};
end;

function TFhirAccount.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirAccountStatusEnum, CODES_TFhirAccountStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    Active := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'balance') then
  begin
    Balance := propValue as TFhirMoney{4b};
    result := propValue;
  end
  else if (propName = 'coverage') then
  begin
    CoverageList.add(propValue as TFhirAccountCoverage){2a};
    result := propValue;
  end
  else if (propName = 'owner') then
  begin
    Owner := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'guarantor') then
  begin
    GuarantorList.add(propValue as TFhirAccountGuarantor){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirAccount.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'coverage') then CoverageList.insertItem(index, propValue as TFhirAccountCoverage){2a}
  else if (propName = 'guarantor') then GuarantorList.insertItem(index, propValue as TFhirAccountGuarantor){2a}
  else inherited;
end;

function TFhirAccount.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'period') then result := TFhirPeriod.create(){4b}
  else if (propName = 'active') then result := TFhirPeriod.create(){4b}
  else if (propName = 'balance') then result := TFhirMoney.create(){4b}
  else if (propName = 'coverage') then result := CoverageList.new(){2}
  else if (propName = 'owner') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'guarantor') then result := GuarantorList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAccount.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'active') then result := 'Period'
  else if (propName = 'balance') then result := 'Money'
  else if (propName = 'coverage') then result := ''
  else if (propName = 'owner') then result := 'Reference'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'guarantor') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAccount.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'balance') then BalanceElement := nil
  else if (propName = 'coverage') then deletePropertyValue('coverage', CoverageList, value) {2}
  else if (propName = 'owner') then OwnerElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'guarantor') then deletePropertyValue('guarantor', GuarantorList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAccount.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirAccountStatusEnum, CODES_TFhirAccountStatusEnum, new){4}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else if (propName = 'active') then ActiveElement := new as TFhirPeriod{4}
  else if (propName = 'balance') then BalanceElement := new as TFhirMoney{4}
  else if (propName = 'coverage') then replacePropertyValue('coverage', CoverageList, existing, new) {2}
  else if (propName = 'owner') then OwnerElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'guarantor') then replacePropertyValue('guarantor', GuarantorList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAccount.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'coverage') then CoverageList.move(source, destination){2a}
  else if (propName = 'guarantor') then GuarantorList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAccount.fhirType : string;
begin
  result := 'Account';
end;

function TFhirAccount.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FType_) and isEmptyProp(FName) and isEmptyProp(FSubject) and isEmptyProp(FPeriod) and isEmptyProp(FActive) and isEmptyProp(FBalance) and isEmptyProp(FcoverageList) and isEmptyProp(FOwner) and isEmptyProp(FDescription) and isEmptyProp(FguarantorList);
end;

function TFhirAccount.equals(other : TObject) : boolean;
var
  o : TFhirAccount;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAccount)) then
    result := false
  else
  begin
    o := TFhirAccount(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(type_Element, o.type_Element, true) and compareDeep(nameElement, o.nameElement, true) and
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(periodElement, o.periodElement, true) and
      compareDeep(activeElement, o.activeElement, true) and compareDeep(balanceElement, o.balanceElement, true) and
      compareDeep(coverageList, o.coverageList, true) and compareDeep(ownerElement, o.ownerElement, true) and
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(guarantorList, o.guarantorList, true);
  end;
end;

function TFhirAccount.Link : TFhirAccount;
begin
  result := TFhirAccount(inherited Link);
end;

function TFhirAccount.Clone : TFhirAccount;
begin
  result := TFhirAccount(inherited Clone);
end;

procedure TFhirAccount.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('type');
  fields.add('name');
  fields.add('subject');
  fields.add('period');
  fields.add('active');
  fields.add('balance');
  fields.add('coverage');
  fields.add('owner');
  fields.add('description');
  fields.add('guarantor');
end;

{ TFhirAccount }

Function TFhirAccount.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirAccount.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirAccount.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirAccount.GetStatusST : TFhirAccountStatusEnum;
begin
  if FStatus = nil then
    result := TFhirAccountStatusEnum(0)
  else
    result := TFhirAccountStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirAccountStatusEnum, FStatus.value));
end;

Procedure TFhirAccount.SetStatusST(value : TFhirAccountStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirAccountStatusEnum[value], CODES_TFhirAccountStatusEnum[value]);
end;

Procedure TFhirAccount.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirAccount.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirAccount.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirAccount.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirAccount.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirAccount.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Procedure TFhirAccount.SetActive(value : TFhirPeriod);
begin
  FActive.free;
  FActive := value;
end;

Procedure TFhirAccount.SetBalance(value : TFhirMoney);
begin
  FBalance.free;
  FBalance := value;
end;

Function TFhirAccount.GetCoverageList : TFhirAccountCoverageList;
begin
  if FCoverageList = nil then
    FCoverageList := TFhirAccountCoverageList.Create;
  result := FCoverageList;
end;

Function TFhirAccount.GetHasCoverageList : boolean;
begin
  result := (FCoverageList <> nil) and (FCoverageList.count > 0);
end;

Procedure TFhirAccount.SetOwner(value : TFhirReference{TFhirOrganization});
begin
  FOwner.free;
  FOwner := value;
end;

Procedure TFhirAccount.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirAccount.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirAccount.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Function TFhirAccount.GetGuarantorList : TFhirAccountGuarantorList;
begin
  if FGuarantorList = nil then
    FGuarantorList := TFhirAccountGuarantorList.Create;
  result := FGuarantorList;
end;

Function TFhirAccount.GetHasGuarantorList : boolean;
begin
  result := (FGuarantorList <> nil) and (FGuarantorList.count > 0);
end;

function TFhirAccount.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FActive.sizeInBytes);
  inc(result, FBalance.sizeInBytes);
  inc(result, FcoverageList.sizeInBytes);
  inc(result, FOwner.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FguarantorList.sizeInBytes);
end;

{ TFhirAccountListEnumerator }

Constructor TFhirAccountListEnumerator.Create(list : TFhirAccountList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAccountListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAccountListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAccountListEnumerator.GetCurrent : TFhirAccount;
begin
  Result := FList[FIndex];
end;

function TFhirAccountListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAccountList }
procedure TFhirAccountList.AddItem(value: TFhirAccount);
begin
  assert(value.ClassName = 'TFhirAccount', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAccount');
  add(value);
end;

function TFhirAccountList.Append: TFhirAccount;
begin
  result := TFhirAccount.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAccountList.ClearItems;
begin
  Clear;
end;

function TFhirAccountList.GetEnumerator : TFhirAccountListEnumerator;
begin
  result := TFhirAccountListEnumerator.Create(self.link);
end;

function TFhirAccountList.Clone: TFhirAccountList;
begin
  result := TFhirAccountList(inherited Clone);
end;

function TFhirAccountList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAccountList.GetItemN(index: Integer): TFhirAccount;
begin
  result := TFhirAccount(ObjectByIndex[index]);
end;

function TFhirAccountList.ItemClass: TFslObjectClass;
begin
  result := TFhirAccount;
end;
function TFhirAccountList.IndexOf(value: TFhirAccount): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAccountList.Insert(index: Integer): TFhirAccount;
begin
  result := TFhirAccount.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAccountList.InsertItem(index: Integer; value: TFhirAccount);
begin
  assert(value is TFhirAccount);
  Inherited Insert(index, value);
end;

function TFhirAccountList.Item(index: Integer): TFhirAccount;
begin
  result := TFhirAccount(ObjectByIndex[index]);
end;

function TFhirAccountList.Link: TFhirAccountList;
begin
  result := TFhirAccountList(inherited Link);
end;

procedure TFhirAccountList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAccountList.SetItemByIndex(index: Integer; value: TFhirAccount);
begin
  assert(value is TFhirAccount);
  FhirAccounts[index] := value;
end;

procedure TFhirAccountList.SetItemN(index: Integer; value: TFhirAccount);
begin
  assert(value is TFhirAccount);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ACCOUNT}

{$IFDEF FHIR_ADVERSEEVENT}

{ TFhirAdverseEventSuspectEntity }

constructor TFhirAdverseEventSuspectEntity.Create;
begin
  inherited;
end;

destructor TFhirAdverseEventSuspectEntity.Destroy;
begin
  FInstance.free;
  FCausality.free;
  FCausalityAssessment.free;
  FCausalityProductRelatedness.free;
  FCausalityMethod.free;
  FCausalityAuthor.free;
  FCausalityResult.free;
  inherited;
end;

procedure TFhirAdverseEventSuspectEntity.Assign(oSource : TFslObject);
begin
  inherited;
  instance := TFhirAdverseEventSuspectEntity(oSource).instance.Clone;
  FCausality := TFhirAdverseEventSuspectEntity(oSource).FCausality.Link;
  causalityAssessment := TFhirAdverseEventSuspectEntity(oSource).causalityAssessment.Clone;
  causalityProductRelatednessElement := TFhirAdverseEventSuspectEntity(oSource).causalityProductRelatednessElement.Clone;
  causalityMethod := TFhirAdverseEventSuspectEntity(oSource).causalityMethod.Clone;
  causalityAuthor := TFhirAdverseEventSuspectEntity(oSource).causalityAuthor.Clone;
  causalityResult := TFhirAdverseEventSuspectEntity(oSource).causalityResult.Clone;
end;

procedure TFhirAdverseEventSuspectEntity.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'instance') Then
     list.add(self.link, 'instance', FInstance.Link);
  if (child_name = 'causality') Then
     list.add(self.link, 'causality', FCausality.Link);
  if (child_name = 'causalityAssessment') Then
     list.add(self.link, 'causalityAssessment', FCausalityAssessment.Link);
  if (child_name = 'causalityProductRelatedness') Then
     list.add(self.link, 'causalityProductRelatedness', FCausalityProductRelatedness.Link);
  if (child_name = 'causalityMethod') Then
     list.add(self.link, 'causalityMethod', FCausalityMethod.Link);
  if (child_name = 'causalityAuthor') Then
     list.add(self.link, 'causalityAuthor', FCausalityAuthor.Link);
  if (child_name = 'causalityResult') Then
     list.add(self.link, 'causalityResult', FCausalityResult.Link);
end;

procedure TFhirAdverseEventSuspectEntity.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'instance', 'Reference(Substance|Medication|MedicationAdministration|MedicationStatement|Device)', false, TFhirReference{Resource}, FInstance.Link));{2}
  oList.add(TFHIRProperty.create(self, 'causality', 'code', false, TFHIREnum, FCausality.Link));{1}
  oList.add(TFHIRProperty.create(self, 'causalityAssessment', 'CodeableConcept', false, TFhirCodeableConcept, FCausalityAssessment.Link));{2}
  oList.add(TFHIRProperty.create(self, 'causalityProductRelatedness', 'string', false, TFhirString, FCausalityProductRelatedness.Link));{2}
  oList.add(TFHIRProperty.create(self, 'causalityMethod', 'CodeableConcept', false, TFhirCodeableConcept, FCausalityMethod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'causalityAuthor', 'Reference(Practitioner|PractitionerRole)', false, TFhirReference{Resource}, FCausalityAuthor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'causalityResult', 'CodeableConcept', false, TFhirCodeableConcept, FCausalityResult.Link));{2}
end;

function TFhirAdverseEventSuspectEntity.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'instance') then
  begin
    Instance := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'causality') then
  begin
    CausalityElement := asEnum(SYSTEMS_TFhirAdverseEventCausalityEnum, CODES_TFhirAdverseEventCausalityEnum, propValue);
    result := propValue
  end
  else if (propName = 'causalityAssessment') then
  begin
    CausalityAssessment := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'causalityProductRelatedness') then
  begin
    CausalityProductRelatednessElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'causalityMethod') then
  begin
    CausalityMethod := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'causalityAuthor') then
  begin
    CausalityAuthor := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'causalityResult') then
  begin
    CausalityResult := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAdverseEventSuspectEntity.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirAdverseEventSuspectEntity.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'instance') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'causalityAssessment') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'causalityProductRelatedness') then result := TFhirString.create() {5b}
  else if (propName = 'causalityMethod') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'causalityAuthor') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'causalityResult') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAdverseEventSuspectEntity.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'instance') then result := 'Reference'
  else if (propName = 'causality') then result := 'code'
  else if (propName = 'causalityAssessment') then result := 'CodeableConcept'
  else if (propName = 'causalityProductRelatedness') then result := 'string'
  else if (propName = 'causalityMethod') then result := 'CodeableConcept'
  else if (propName = 'causalityAuthor') then result := 'Reference'
  else if (propName = 'causalityResult') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAdverseEventSuspectEntity.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'instance') then InstanceElement := nil
  else if (propName = 'causality') then CausalityElement := nil
  else if (propName = 'causalityAssessment') then CausalityAssessmentElement := nil
  else if (propName = 'causalityProductRelatedness') then CausalityProductRelatednessElement := nil
  else if (propName = 'causalityMethod') then CausalityMethodElement := nil
  else if (propName = 'causalityAuthor') then CausalityAuthorElement := nil
  else if (propName = 'causalityResult') then CausalityResultElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAdverseEventSuspectEntity.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'instance') then InstanceElement := new as TFhirReference{Resource}{4}
  else if (propName = 'causality') then CausalityElement := asEnum(SYSTEMS_TFhirAdverseEventCausalityEnum, CODES_TFhirAdverseEventCausalityEnum, new){4}
  else if (propName = 'causalityAssessment') then CausalityAssessmentElement := new as TFhirCodeableConcept{4}
  else if (propName = 'causalityProductRelatedness') then CausalityProductRelatednessElement := asString(new){5b}
  else if (propName = 'causalityMethod') then CausalityMethodElement := new as TFhirCodeableConcept{4}
  else if (propName = 'causalityAuthor') then CausalityAuthorElement := new as TFhirReference{Resource}{4}
  else if (propName = 'causalityResult') then CausalityResultElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAdverseEventSuspectEntity.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirAdverseEventSuspectEntity.fhirType : string;
begin
  result := 'suspectEntity';
end;

function TFhirAdverseEventSuspectEntity.Link : TFhirAdverseEventSuspectEntity;
begin
  result := TFhirAdverseEventSuspectEntity(inherited Link);
end;

function TFhirAdverseEventSuspectEntity.Clone : TFhirAdverseEventSuspectEntity;
begin
  result := TFhirAdverseEventSuspectEntity(inherited Clone);
end;

function TFhirAdverseEventSuspectEntity.equals(other : TObject) : boolean;
var
  o : TFhirAdverseEventSuspectEntity;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAdverseEventSuspectEntity)) then
    result := false
  else
  begin
    o := TFhirAdverseEventSuspectEntity(other);
    result := compareDeep(instanceElement, o.instanceElement, true) and compareDeep(causalityElement, o.causalityElement, true) and
      compareDeep(causalityAssessmentElement, o.causalityAssessmentElement, true) and
      compareDeep(causalityProductRelatednessElement, o.causalityProductRelatednessElement, true) and
      compareDeep(causalityMethodElement, o.causalityMethodElement, true) and compareDeep(causalityAuthorElement, o.causalityAuthorElement, true) and
      compareDeep(causalityResultElement, o.causalityResultElement, true);
  end;
end;

function TFhirAdverseEventSuspectEntity.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FInstance) and isEmptyProp(FCausality) and isEmptyProp(FCausalityAssessment) and isEmptyProp(FCausalityProductRelatedness) and isEmptyProp(FCausalityMethod) and isEmptyProp(FCausalityAuthor) and isEmptyProp(FCausalityResult);
end;

procedure TFhirAdverseEventSuspectEntity.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('instance');
  fields.add('causality');
  fields.add('causalityAssessment');
  fields.add('causalityProductRelatedness');
  fields.add('causalityMethod');
  fields.add('causalityAuthor');
  fields.add('causalityResult');
end;

{ TFhirAdverseEventSuspectEntity }

Procedure TFhirAdverseEventSuspectEntity.SetInstance(value : TFhirReference{Resource});
begin
  FInstance.free;
  FInstance := value;
end;

Procedure TFhirAdverseEventSuspectEntity.SetCausality(value : TFhirEnum);
begin
  FCausality.free;
  FCausality := value;
end;

Function TFhirAdverseEventSuspectEntity.GetCausalityST : TFhirAdverseEventCausalityEnum;
begin
  if FCausality = nil then
    result := TFhirAdverseEventCausalityEnum(0)
  else
    result := TFhirAdverseEventCausalityEnum(StringArrayIndexOfSensitive(CODES_TFhirAdverseEventCausalityEnum, FCausality.value));
end;

Procedure TFhirAdverseEventSuspectEntity.SetCausalityST(value : TFhirAdverseEventCausalityEnum);
begin
  if ord(value) = 0 then
    CausalityElement := nil
  else
    CausalityElement := TFhirEnum.create(SYSTEMS_TFhirAdverseEventCausalityEnum[value], CODES_TFhirAdverseEventCausalityEnum[value]);
end;

Procedure TFhirAdverseEventSuspectEntity.SetCausalityAssessment(value : TFhirCodeableConcept);
begin
  FCausalityAssessment.free;
  FCausalityAssessment := value;
end;

Procedure TFhirAdverseEventSuspectEntity.SetCausalityProductRelatedness(value : TFhirString);
begin
  FCausalityProductRelatedness.free;
  FCausalityProductRelatedness := value;
end;

Function TFhirAdverseEventSuspectEntity.GetCausalityProductRelatednessST : String;
begin
  if FCausalityProductRelatedness = nil then
    result := ''
  else
    result := FCausalityProductRelatedness.value;
end;

Procedure TFhirAdverseEventSuspectEntity.SetCausalityProductRelatednessST(value : String);
begin
  if value <> '' then
  begin
    if FCausalityProductRelatedness = nil then
      FCausalityProductRelatedness := TFhirString.create;
    FCausalityProductRelatedness.value := value
  end
  else if FCausalityProductRelatedness <> nil then
    FCausalityProductRelatedness.value := '';
end;

Procedure TFhirAdverseEventSuspectEntity.SetCausalityMethod(value : TFhirCodeableConcept);
begin
  FCausalityMethod.free;
  FCausalityMethod := value;
end;

Procedure TFhirAdverseEventSuspectEntity.SetCausalityAuthor(value : TFhirReference{Resource});
begin
  FCausalityAuthor.free;
  FCausalityAuthor := value;
end;

Procedure TFhirAdverseEventSuspectEntity.SetCausalityResult(value : TFhirCodeableConcept);
begin
  FCausalityResult.free;
  FCausalityResult := value;
end;

function TFhirAdverseEventSuspectEntity.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FInstance.sizeInBytes);
  inc(result, FCausality.sizeInBytes);
  inc(result, FCausalityAssessment.sizeInBytes);
  inc(result, FCausalityProductRelatedness.sizeInBytes);
  inc(result, FCausalityMethod.sizeInBytes);
  inc(result, FCausalityAuthor.sizeInBytes);
  inc(result, FCausalityResult.sizeInBytes);
end;

{ TFhirAdverseEventSuspectEntityListEnumerator }

Constructor TFhirAdverseEventSuspectEntityListEnumerator.Create(list : TFhirAdverseEventSuspectEntityList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAdverseEventSuspectEntityListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAdverseEventSuspectEntityListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAdverseEventSuspectEntityListEnumerator.GetCurrent : TFhirAdverseEventSuspectEntity;
begin
  Result := FList[FIndex];
end;

function TFhirAdverseEventSuspectEntityListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAdverseEventSuspectEntityList }
procedure TFhirAdverseEventSuspectEntityList.AddItem(value: TFhirAdverseEventSuspectEntity);
begin
  assert(value.ClassName = 'TFhirAdverseEventSuspectEntity', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAdverseEventSuspectEntity');
  add(value);
end;

function TFhirAdverseEventSuspectEntityList.Append: TFhirAdverseEventSuspectEntity;
begin
  result := TFhirAdverseEventSuspectEntity.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdverseEventSuspectEntityList.ClearItems;
begin
  Clear;
end;

function TFhirAdverseEventSuspectEntityList.GetEnumerator : TFhirAdverseEventSuspectEntityListEnumerator;
begin
  result := TFhirAdverseEventSuspectEntityListEnumerator.Create(self.link);
end;

function TFhirAdverseEventSuspectEntityList.Clone: TFhirAdverseEventSuspectEntityList;
begin
  result := TFhirAdverseEventSuspectEntityList(inherited Clone);
end;

function TFhirAdverseEventSuspectEntityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAdverseEventSuspectEntityList.GetItemN(index: Integer): TFhirAdverseEventSuspectEntity;
begin
  result := TFhirAdverseEventSuspectEntity(ObjectByIndex[index]);
end;

function TFhirAdverseEventSuspectEntityList.ItemClass: TFslObjectClass;
begin
  result := TFhirAdverseEventSuspectEntity;
end;
function TFhirAdverseEventSuspectEntityList.IndexOf(value: TFhirAdverseEventSuspectEntity): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAdverseEventSuspectEntityList.Insert(index: Integer): TFhirAdverseEventSuspectEntity;
begin
  result := TFhirAdverseEventSuspectEntity.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdverseEventSuspectEntityList.InsertItem(index: Integer; value: TFhirAdverseEventSuspectEntity);
begin
  assert(value is TFhirAdverseEventSuspectEntity);
  Inherited Insert(index, value);
end;

function TFhirAdverseEventSuspectEntityList.Item(index: Integer): TFhirAdverseEventSuspectEntity;
begin
  result := TFhirAdverseEventSuspectEntity(ObjectByIndex[index]);
end;

function TFhirAdverseEventSuspectEntityList.Link: TFhirAdverseEventSuspectEntityList;
begin
  result := TFhirAdverseEventSuspectEntityList(inherited Link);
end;

procedure TFhirAdverseEventSuspectEntityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAdverseEventSuspectEntityList.SetItemByIndex(index: Integer; value: TFhirAdverseEventSuspectEntity);
begin
  assert(value is TFhirAdverseEventSuspectEntity);
  FhirAdverseEventSuspectEntities[index] := value;
end;

procedure TFhirAdverseEventSuspectEntityList.SetItemN(index: Integer; value: TFhirAdverseEventSuspectEntity);
begin
  assert(value is TFhirAdverseEventSuspectEntity);
  ObjectByIndex[index] := value;
end;

{ TFhirAdverseEvent }

constructor TFhirAdverseEvent.Create;
begin
  inherited;
end;

destructor TFhirAdverseEvent.Destroy;
begin
  FIdentifier.free;
  FCategory.free;
  FType_.free;
  FSubject.free;
  FDate.free;
  FReactionList.Free;
  FLocation.free;
  FSeriousness.free;
  FOutcome.free;
  FRecorder.free;
  FEventParticipant.free;
  FDescription.free;
  FSuspectEntityList.Free;
  FSubjectMedicalHistoryList.Free;
  FReferenceDocumentList.Free;
  FStudyList.Free;
  inherited;
end;

function TFhirAdverseEvent.GetResourceType : TFhirResourceType;
begin
  result := frtAdverseEvent;
end;

procedure TFhirAdverseEvent.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirAdverseEvent(oSource).identifier.Clone;
  FCategory := TFhirAdverseEvent(oSource).FCategory.Link;
  type_ := TFhirAdverseEvent(oSource).type_.Clone;
  subject := TFhirAdverseEvent(oSource).subject.Clone;
  dateElement := TFhirAdverseEvent(oSource).dateElement.Clone;
  if (TFhirAdverseEvent(oSource).FReactionList = nil) then
  begin
    FReactionList.free;
    FReactionList := nil;
  end
  else
  begin
    if FReactionList = nil then
      FReactionList := TFhirReferenceList{TFhirCondition}.Create;
    FReactionList.Assign(TFhirAdverseEvent(oSource).FReactionList);
  end;
  location := TFhirAdverseEvent(oSource).location.Clone;
  seriousness := TFhirAdverseEvent(oSource).seriousness.Clone;
  outcome := TFhirAdverseEvent(oSource).outcome.Clone;
  recorder := TFhirAdverseEvent(oSource).recorder.Clone;
  eventParticipant := TFhirAdverseEvent(oSource).eventParticipant.Clone;
  descriptionElement := TFhirAdverseEvent(oSource).descriptionElement.Clone;
  if (TFhirAdverseEvent(oSource).FSuspectEntityList = nil) then
  begin
    FSuspectEntityList.free;
    FSuspectEntityList := nil;
  end
  else
  begin
    if FSuspectEntityList = nil then
      FSuspectEntityList := TFhirAdverseEventSuspectEntityList.Create;
    FSuspectEntityList.Assign(TFhirAdverseEvent(oSource).FSuspectEntityList);
  end;
  if (TFhirAdverseEvent(oSource).FSubjectMedicalHistoryList = nil) then
  begin
    FSubjectMedicalHistoryList.free;
    FSubjectMedicalHistoryList := nil;
  end
  else
  begin
    if FSubjectMedicalHistoryList = nil then
      FSubjectMedicalHistoryList := TFhirReferenceList{Resource}.Create;
    FSubjectMedicalHistoryList.Assign(TFhirAdverseEvent(oSource).FSubjectMedicalHistoryList);
  end;
  if (TFhirAdverseEvent(oSource).FReferenceDocumentList = nil) then
  begin
    FReferenceDocumentList.free;
    FReferenceDocumentList := nil;
  end
  else
  begin
    if FReferenceDocumentList = nil then
      FReferenceDocumentList := TFhirReferenceList{TFhirDocumentReference}.Create;
    FReferenceDocumentList.Assign(TFhirAdverseEvent(oSource).FReferenceDocumentList);
  end;
  if (TFhirAdverseEvent(oSource).FStudyList = nil) then
  begin
    FStudyList.free;
    FStudyList := nil;
  end
  else
  begin
    if FStudyList = nil then
      FStudyList := TFhirReferenceList{TFhirResearchStudy}.Create;
    FStudyList.Assign(TFhirAdverseEvent(oSource).FStudyList);
  end;
end;

procedure TFhirAdverseEvent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'reaction') Then
    list.addAll(self, 'reaction', FReactionList);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'seriousness') Then
     list.add(self.link, 'seriousness', FSeriousness.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'recorder') Then
     list.add(self.link, 'recorder', FRecorder.Link);
  if (child_name = 'eventParticipant') Then
     list.add(self.link, 'eventParticipant', FEventParticipant.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'suspectEntity') Then
    list.addAll(self, 'suspectEntity', FSuspectEntityList);
  if (child_name = 'subjectMedicalHistory') Then
    list.addAll(self, 'subjectMedicalHistory', FSubjectMedicalHistoryList);
  if (child_name = 'referenceDocument') Then
    list.addAll(self, 'referenceDocument', FReferenceDocumentList);
  if (child_name = 'study') Then
    list.addAll(self, 'study', FStudyList);
end;

procedure TFhirAdverseEvent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'category', 'code', false, TFHIREnum, FCategory.Link));{1}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|ResearchSubject|Medication|Device)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reaction', 'Reference(Condition)', true, TFhirReference{TFhirCondition}, FReactionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'location', 'Reference(Location)', false, TFhirReference{TFhirLocation}, FLocation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'seriousness', 'CodeableConcept', false, TFhirCodeableConcept, FSeriousness.Link));{2}
  oList.add(TFHIRProperty.create(self, 'outcome', 'CodeableConcept', false, TFhirCodeableConcept, FOutcome.Link));{2}
  oList.add(TFHIRProperty.create(self, 'recorder', 'Reference(Patient|Practitioner|RelatedPerson)', false, TFhirReference{Resource}, FRecorder.Link));{2}
  oList.add(TFHIRProperty.create(self, 'eventParticipant', 'Reference(Practitioner|Device)', false, TFhirReference{Resource}, FEventParticipant.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'suspectEntity', '', true, TFhirAdverseEventSuspectEntity, FSuspectEntityList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'subjectMedicalHistory', 'Reference(Condition|Observation|AllergyIntolerance|FamilyMemberHistory|Immunization|Procedure)', true, TFhirReference{Resource}, FSubjectMedicalHistoryList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'referenceDocument', 'Reference(DocumentReference)', true, TFhirReference{TFhirDocumentReference}, FReferenceDocumentList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'study', 'Reference(ResearchStudy)', true, TFhirReference{TFhirResearchStudy}, FStudyList.Link)){3};
end;

function TFhirAdverseEvent.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryElement := asEnum(SYSTEMS_TFhirAdverseEventCategoryEnum, CODES_TFhirAdverseEventCategoryEnum, propValue);
    result := propValue
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'reaction') then
  begin
    ReactionList.add(propValue as TFhirReference{TFhirCondition}){2a};
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirReference{TFhirLocation}{4b};
    result := propValue;
  end
  else if (propName = 'seriousness') then
  begin
    Seriousness := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    Outcome := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'recorder') then
  begin
    Recorder := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'eventParticipant') then
  begin
    EventParticipant := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'suspectEntity') then
  begin
    SuspectEntityList.add(propValue as TFhirAdverseEventSuspectEntity){2a};
    result := propValue;
  end
  else if (propName = 'subjectMedicalHistory') then
  begin
    SubjectMedicalHistoryList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'referenceDocument') then
  begin
    ReferenceDocumentList.add(propValue as TFhirReference{TFhirDocumentReference}){2a};
    result := propValue;
  end
  else if (propName = 'study') then
  begin
    StudyList.add(propValue as TFhirReference{TFhirResearchStudy}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirAdverseEvent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'reaction') then ReactionList.insertItem(index, propValue as TFhirReference{TFhirCondition}){2a}
  else if (propName = 'suspectEntity') then SuspectEntityList.insertItem(index, propValue as TFhirAdverseEventSuspectEntity){2a}
  else if (propName = 'subjectMedicalHistory') then SubjectMedicalHistoryList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'referenceDocument') then ReferenceDocumentList.insertItem(index, propValue as TFhirReference{TFhirDocumentReference}){2a}
  else if (propName = 'study') then StudyList.insertItem(index, propValue as TFhirReference{TFhirResearchStudy}){2a}
  else inherited;
end;

function TFhirAdverseEvent.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'reaction') then result := ReactionList.new(){2}
  else if (propName = 'location') then result := TFhirReference{TFhirLocation}.create(){4b}
  else if (propName = 'seriousness') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'outcome') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'recorder') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'eventParticipant') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'suspectEntity') then result := SuspectEntityList.new(){2}
  else if (propName = 'subjectMedicalHistory') then result := SubjectMedicalHistoryList.new(){2}
  else if (propName = 'referenceDocument') then result := ReferenceDocumentList.new(){2}
  else if (propName = 'study') then result := StudyList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAdverseEvent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'category') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'reaction') then result := 'Reference'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'seriousness') then result := 'CodeableConcept'
  else if (propName = 'outcome') then result := 'CodeableConcept'
  else if (propName = 'recorder') then result := 'Reference'
  else if (propName = 'eventParticipant') then result := 'Reference'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'suspectEntity') then result := ''
  else if (propName = 'subjectMedicalHistory') then result := 'Reference'
  else if (propName = 'referenceDocument') then result := 'Reference'
  else if (propName = 'study') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAdverseEvent.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'reaction') then deletePropertyValue('reaction', ReactionList, value) {2}
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'seriousness') then SeriousnessElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'recorder') then RecorderElement := nil
  else if (propName = 'eventParticipant') then EventParticipantElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'suspectEntity') then deletePropertyValue('suspectEntity', SuspectEntityList, value) {2}
  else if (propName = 'subjectMedicalHistory') then deletePropertyValue('subjectMedicalHistory', SubjectMedicalHistoryList, value) {2}
  else if (propName = 'referenceDocument') then deletePropertyValue('referenceDocument', ReferenceDocumentList, value) {2}
  else if (propName = 'study') then deletePropertyValue('study', StudyList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAdverseEvent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'category') then CategoryElement := asEnum(SYSTEMS_TFhirAdverseEventCategoryEnum, CODES_TFhirAdverseEventCategoryEnum, new){4}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'reaction') then replacePropertyValue('reaction', ReactionList, existing, new) {2}
  else if (propName = 'location') then LocationElement := new as TFhirReference{TFhirLocation}{4}
  else if (propName = 'seriousness') then SeriousnessElement := new as TFhirCodeableConcept{4}
  else if (propName = 'outcome') then OutcomeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'recorder') then RecorderElement := new as TFhirReference{Resource}{4}
  else if (propName = 'eventParticipant') then EventParticipantElement := new as TFhirReference{Resource}{4}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'suspectEntity') then replacePropertyValue('suspectEntity', SuspectEntityList, existing, new) {2}
  else if (propName = 'subjectMedicalHistory') then replacePropertyValue('subjectMedicalHistory', SubjectMedicalHistoryList, existing, new) {2}
  else if (propName = 'referenceDocument') then replacePropertyValue('referenceDocument', ReferenceDocumentList, existing, new) {2}
  else if (propName = 'study') then replacePropertyValue('study', StudyList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAdverseEvent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'reaction') then ReactionList.move(source, destination){2a}
  else if (propName = 'suspectEntity') then SuspectEntityList.move(source, destination){2a}
  else if (propName = 'subjectMedicalHistory') then SubjectMedicalHistoryList.move(source, destination){2a}
  else if (propName = 'referenceDocument') then ReferenceDocumentList.move(source, destination){2a}
  else if (propName = 'study') then StudyList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAdverseEvent.fhirType : string;
begin
  result := 'AdverseEvent';
end;

function TFhirAdverseEvent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FCategory) and isEmptyProp(FType_) and isEmptyProp(FSubject) and isEmptyProp(FDate) and isEmptyProp(FreactionList) and isEmptyProp(FLocation) and isEmptyProp(FSeriousness) and isEmptyProp(FOutcome) and isEmptyProp(FRecorder) and isEmptyProp(FEventParticipant) and isEmptyProp(FDescription) and isEmptyProp(FsuspectEntityList) and isEmptyProp(FsubjectMedicalHistoryList) and isEmptyProp(FreferenceDocumentList) and isEmptyProp(FstudyList);
end;

function TFhirAdverseEvent.equals(other : TObject) : boolean;
var
  o : TFhirAdverseEvent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAdverseEvent)) then
    result := false
  else
  begin
    o := TFhirAdverseEvent(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(categoryElement, o.categoryElement, true) and
      compareDeep(type_Element, o.type_Element, true) and compareDeep(subjectElement, o.subjectElement, true) and
      compareDeep(dateElement, o.dateElement, true) and compareDeep(reactionList, o.reactionList, true) and
      compareDeep(locationElement, o.locationElement, true) and compareDeep(seriousnessElement, o.seriousnessElement, true) and
      compareDeep(outcomeElement, o.outcomeElement, true) and compareDeep(recorderElement, o.recorderElement, true) and
      compareDeep(eventParticipantElement, o.eventParticipantElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and
      compareDeep(suspectEntityList, o.suspectEntityList, true) and compareDeep(subjectMedicalHistoryList, o.subjectMedicalHistoryList, true) and
      compareDeep(referenceDocumentList, o.referenceDocumentList, true) and compareDeep(studyList, o.studyList, true);
  end;
end;

function TFhirAdverseEvent.Link : TFhirAdverseEvent;
begin
  result := TFhirAdverseEvent(inherited Link);
end;

function TFhirAdverseEvent.Clone : TFhirAdverseEvent;
begin
  result := TFhirAdverseEvent(inherited Clone);
end;

procedure TFhirAdverseEvent.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('category');
  fields.add('type');
  fields.add('subject');
  fields.add('date');
  fields.add('reaction');
  fields.add('location');
  fields.add('seriousness');
  fields.add('outcome');
  fields.add('recorder');
  fields.add('eventParticipant');
  fields.add('description');
  fields.add('suspectEntity');
  fields.add('subjectMedicalHistory');
  fields.add('referenceDocument');
  fields.add('study');
end;

{ TFhirAdverseEvent }

Procedure TFhirAdverseEvent.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirAdverseEvent.SetCategory(value : TFhirEnum);
begin
  FCategory.free;
  FCategory := value;
end;

Function TFhirAdverseEvent.GetCategoryST : TFhirAdverseEventCategoryEnum;
begin
  if FCategory = nil then
    result := TFhirAdverseEventCategoryEnum(0)
  else
    result := TFhirAdverseEventCategoryEnum(StringArrayIndexOfSensitive(CODES_TFhirAdverseEventCategoryEnum, FCategory.value));
end;

Procedure TFhirAdverseEvent.SetCategoryST(value : TFhirAdverseEventCategoryEnum);
begin
  if ord(value) = 0 then
    CategoryElement := nil
  else
    CategoryElement := TFhirEnum.create(SYSTEMS_TFhirAdverseEventCategoryEnum[value], CODES_TFhirAdverseEventCategoryEnum[value]);
end;

Procedure TFhirAdverseEvent.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirAdverseEvent.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirAdverseEvent.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirAdverseEvent.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirAdverseEvent.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Function TFhirAdverseEvent.GetReactionList : TFhirReferenceList{TFhirCondition};
begin
  if FReactionList = nil then
    FReactionList := TFhirReferenceList{TFhirCondition}.Create;
  result := FReactionList;
end;

Function TFhirAdverseEvent.GetHasReactionList : boolean;
begin
  result := (FReactionList <> nil) and (FReactionList.count > 0);
end;

Procedure TFhirAdverseEvent.SetLocation(value : TFhirReference{TFhirLocation});
begin
  FLocation.free;
  FLocation := value;
end;

Procedure TFhirAdverseEvent.SetSeriousness(value : TFhirCodeableConcept);
begin
  FSeriousness.free;
  FSeriousness := value;
end;

Procedure TFhirAdverseEvent.SetOutcome(value : TFhirCodeableConcept);
begin
  FOutcome.free;
  FOutcome := value;
end;

Procedure TFhirAdverseEvent.SetRecorder(value : TFhirReference{Resource});
begin
  FRecorder.free;
  FRecorder := value;
end;

Procedure TFhirAdverseEvent.SetEventParticipant(value : TFhirReference{Resource});
begin
  FEventParticipant.free;
  FEventParticipant := value;
end;

Procedure TFhirAdverseEvent.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirAdverseEvent.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirAdverseEvent.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Function TFhirAdverseEvent.GetSuspectEntityList : TFhirAdverseEventSuspectEntityList;
begin
  if FSuspectEntityList = nil then
    FSuspectEntityList := TFhirAdverseEventSuspectEntityList.Create;
  result := FSuspectEntityList;
end;

Function TFhirAdverseEvent.GetHasSuspectEntityList : boolean;
begin
  result := (FSuspectEntityList <> nil) and (FSuspectEntityList.count > 0);
end;

Function TFhirAdverseEvent.GetSubjectMedicalHistoryList : TFhirReferenceList{Resource};
begin
  if FSubjectMedicalHistoryList = nil then
    FSubjectMedicalHistoryList := TFhirReferenceList{Resource}.Create;
  result := FSubjectMedicalHistoryList;
end;

Function TFhirAdverseEvent.GetHasSubjectMedicalHistoryList : boolean;
begin
  result := (FSubjectMedicalHistoryList <> nil) and (FSubjectMedicalHistoryList.count > 0);
end;

Function TFhirAdverseEvent.GetReferenceDocumentList : TFhirReferenceList{TFhirDocumentReference};
begin
  if FReferenceDocumentList = nil then
    FReferenceDocumentList := TFhirReferenceList{TFhirDocumentReference}.Create;
  result := FReferenceDocumentList;
end;

Function TFhirAdverseEvent.GetHasReferenceDocumentList : boolean;
begin
  result := (FReferenceDocumentList <> nil) and (FReferenceDocumentList.count > 0);
end;

Function TFhirAdverseEvent.GetStudyList : TFhirReferenceList{TFhirResearchStudy};
begin
  if FStudyList = nil then
    FStudyList := TFhirReferenceList{TFhirResearchStudy}.Create;
  result := FStudyList;
end;

Function TFhirAdverseEvent.GetHasStudyList : boolean;
begin
  result := (FStudyList <> nil) and (FStudyList.count > 0);
end;

function TFhirAdverseEvent.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FreactionList.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
  inc(result, FSeriousness.sizeInBytes);
  inc(result, FOutcome.sizeInBytes);
  inc(result, FRecorder.sizeInBytes);
  inc(result, FEventParticipant.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FsuspectEntityList.sizeInBytes);
  inc(result, FsubjectMedicalHistoryList.sizeInBytes);
  inc(result, FreferenceDocumentList.sizeInBytes);
  inc(result, FstudyList.sizeInBytes);
end;

{ TFhirAdverseEventListEnumerator }

Constructor TFhirAdverseEventListEnumerator.Create(list : TFhirAdverseEventList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAdverseEventListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAdverseEventListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAdverseEventListEnumerator.GetCurrent : TFhirAdverseEvent;
begin
  Result := FList[FIndex];
end;

function TFhirAdverseEventListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAdverseEventList }
procedure TFhirAdverseEventList.AddItem(value: TFhirAdverseEvent);
begin
  assert(value.ClassName = 'TFhirAdverseEvent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAdverseEvent');
  add(value);
end;

function TFhirAdverseEventList.Append: TFhirAdverseEvent;
begin
  result := TFhirAdverseEvent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdverseEventList.ClearItems;
begin
  Clear;
end;

function TFhirAdverseEventList.GetEnumerator : TFhirAdverseEventListEnumerator;
begin
  result := TFhirAdverseEventListEnumerator.Create(self.link);
end;

function TFhirAdverseEventList.Clone: TFhirAdverseEventList;
begin
  result := TFhirAdverseEventList(inherited Clone);
end;

function TFhirAdverseEventList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAdverseEventList.GetItemN(index: Integer): TFhirAdverseEvent;
begin
  result := TFhirAdverseEvent(ObjectByIndex[index]);
end;

function TFhirAdverseEventList.ItemClass: TFslObjectClass;
begin
  result := TFhirAdverseEvent;
end;
function TFhirAdverseEventList.IndexOf(value: TFhirAdverseEvent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAdverseEventList.Insert(index: Integer): TFhirAdverseEvent;
begin
  result := TFhirAdverseEvent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdverseEventList.InsertItem(index: Integer; value: TFhirAdverseEvent);
begin
  assert(value is TFhirAdverseEvent);
  Inherited Insert(index, value);
end;

function TFhirAdverseEventList.Item(index: Integer): TFhirAdverseEvent;
begin
  result := TFhirAdverseEvent(ObjectByIndex[index]);
end;

function TFhirAdverseEventList.Link: TFhirAdverseEventList;
begin
  result := TFhirAdverseEventList(inherited Link);
end;

procedure TFhirAdverseEventList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAdverseEventList.SetItemByIndex(index: Integer; value: TFhirAdverseEvent);
begin
  assert(value is TFhirAdverseEvent);
  FhirAdverseEvents[index] := value;
end;

procedure TFhirAdverseEventList.SetItemN(index: Integer; value: TFhirAdverseEvent);
begin
  assert(value is TFhirAdverseEvent);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ADVERSEEVENT}

{$IFDEF FHIR_ALLERGYINTOLERANCE}

{ TFhirAllergyIntoleranceReaction }

constructor TFhirAllergyIntoleranceReaction.Create;
begin
  inherited;
end;

destructor TFhirAllergyIntoleranceReaction.Destroy;
begin
  FSubstance.free;
  FManifestationList.Free;
  FDescription.free;
  FOnset.free;
  FSeverity.free;
  FExposureRoute.free;
  FNoteList.Free;
  inherited;
end;

procedure TFhirAllergyIntoleranceReaction.Assign(oSource : TFslObject);
begin
  inherited;
  substance := TFhirAllergyIntoleranceReaction(oSource).substance.Clone;
  if (TFhirAllergyIntoleranceReaction(oSource).FManifestationList = nil) then
  begin
    FManifestationList.free;
    FManifestationList := nil;
  end
  else
  begin
    if FManifestationList = nil then
      FManifestationList := TFhirCodeableConceptList.Create;
    FManifestationList.Assign(TFhirAllergyIntoleranceReaction(oSource).FManifestationList);
  end;
  descriptionElement := TFhirAllergyIntoleranceReaction(oSource).descriptionElement.Clone;
  onsetElement := TFhirAllergyIntoleranceReaction(oSource).onsetElement.Clone;
  FSeverity := TFhirAllergyIntoleranceReaction(oSource).FSeverity.Link;
  exposureRoute := TFhirAllergyIntoleranceReaction(oSource).exposureRoute.Clone;
  if (TFhirAllergyIntoleranceReaction(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirAllergyIntoleranceReaction(oSource).FNoteList);
  end;
end;

procedure TFhirAllergyIntoleranceReaction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'substance') Then
     list.add(self.link, 'substance', FSubstance.Link);
  if (child_name = 'manifestation') Then
    list.addAll(self, 'manifestation', FManifestationList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'onset') Then
     list.add(self.link, 'onset', FOnset.Link);
  if (child_name = 'severity') Then
     list.add(self.link, 'severity', FSeverity.Link);
  if (child_name = 'exposureRoute') Then
     list.add(self.link, 'exposureRoute', FExposureRoute.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirAllergyIntoleranceReaction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'substance', 'CodeableConcept', false, TFhirCodeableConcept, FSubstance.Link));{2}
  oList.add(TFHIRProperty.create(self, 'manifestation', 'CodeableConcept', true, TFhirCodeableConcept, FManifestationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'onset', 'dateTime', false, TFhirDateTime, FOnset.Link));{2}
  oList.add(TFHIRProperty.create(self, 'severity', 'code', false, TFHIREnum, FSeverity.Link));{1}
  oList.add(TFHIRProperty.create(self, 'exposureRoute', 'CodeableConcept', false, TFhirCodeableConcept, FExposureRoute.Link));{2}
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
end;

function TFhirAllergyIntoleranceReaction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'substance') then
  begin
    Substance := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'manifestation') then
  begin
    ManifestationList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'onset') then
  begin
    OnsetElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'severity') then
  begin
    SeverityElement := asEnum(SYSTEMS_TFhirReactionEventSeverityEnum, CODES_TFhirReactionEventSeverityEnum, propValue);
    result := propValue
  end
  else if (propName = 'exposureRoute') then
  begin
    ExposureRoute := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAllergyIntoleranceReaction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'manifestation') then ManifestationList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else inherited;
end;

function TFhirAllergyIntoleranceReaction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'substance') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'manifestation') then result := ManifestationList.new(){2}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'onset') then result := TFhirDateTime.create() {5b}
  else if (propName = 'exposureRoute') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'note') then result := NoteList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAllergyIntoleranceReaction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'substance') then result := 'CodeableConcept'
  else if (propName = 'manifestation') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'onset') then result := 'dateTime'
  else if (propName = 'severity') then result := 'code'
  else if (propName = 'exposureRoute') then result := 'CodeableConcept'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAllergyIntoleranceReaction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'substance') then SubstanceElement := nil
  else if (propName = 'manifestation') then deletePropertyValue('manifestation', ManifestationList, value) {2}
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'onset') then OnsetElement := nil
  else if (propName = 'severity') then SeverityElement := nil
  else if (propName = 'exposureRoute') then ExposureRouteElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAllergyIntoleranceReaction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'substance') then SubstanceElement := new as TFhirCodeableConcept{4}
  else if (propName = 'manifestation') then replacePropertyValue('manifestation', ManifestationList, existing, new) {2}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'onset') then OnsetElement := asDateTime(new){5b}
  else if (propName = 'severity') then SeverityElement := asEnum(SYSTEMS_TFhirReactionEventSeverityEnum, CODES_TFhirReactionEventSeverityEnum, new){4}
  else if (propName = 'exposureRoute') then ExposureRouteElement := new as TFhirCodeableConcept{4}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAllergyIntoleranceReaction.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'manifestation') then ManifestationList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAllergyIntoleranceReaction.fhirType : string;
begin
  result := 'reaction';
end;

function TFhirAllergyIntoleranceReaction.Link : TFhirAllergyIntoleranceReaction;
begin
  result := TFhirAllergyIntoleranceReaction(inherited Link);
end;

function TFhirAllergyIntoleranceReaction.Clone : TFhirAllergyIntoleranceReaction;
begin
  result := TFhirAllergyIntoleranceReaction(inherited Clone);
end;

function TFhirAllergyIntoleranceReaction.equals(other : TObject) : boolean;
var
  o : TFhirAllergyIntoleranceReaction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAllergyIntoleranceReaction)) then
    result := false
  else
  begin
    o := TFhirAllergyIntoleranceReaction(other);
    result := compareDeep(substanceElement, o.substanceElement, true) and compareDeep(manifestationList, o.manifestationList, true) and
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(onsetElement, o.onsetElement, true) and
      compareDeep(severityElement, o.severityElement, true) and compareDeep(exposureRouteElement, o.exposureRouteElement, true) and
      compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirAllergyIntoleranceReaction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSubstance) and isEmptyProp(FmanifestationList) and isEmptyProp(FDescription) and isEmptyProp(FOnset) and isEmptyProp(FSeverity) and isEmptyProp(FExposureRoute) and isEmptyProp(FnoteList);
end;

procedure TFhirAllergyIntoleranceReaction.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('substance');
  fields.add('manifestation');
  fields.add('description');
  fields.add('onset');
  fields.add('severity');
  fields.add('exposureRoute');
  fields.add('note');
end;

{ TFhirAllergyIntoleranceReaction }

Procedure TFhirAllergyIntoleranceReaction.SetSubstance(value : TFhirCodeableConcept);
begin
  FSubstance.free;
  FSubstance := value;
end;

Function TFhirAllergyIntoleranceReaction.GetManifestationList : TFhirCodeableConceptList;
begin
  if FManifestationList = nil then
    FManifestationList := TFhirCodeableConceptList.Create;
  result := FManifestationList;
end;

Function TFhirAllergyIntoleranceReaction.GetHasManifestationList : boolean;
begin
  result := (FManifestationList <> nil) and (FManifestationList.count > 0);
end;

Procedure TFhirAllergyIntoleranceReaction.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirAllergyIntoleranceReaction.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirAllergyIntoleranceReaction.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirAllergyIntoleranceReaction.SetOnset(value : TFhirDateTime);
begin
  FOnset.free;
  FOnset := value;
end;

Function TFhirAllergyIntoleranceReaction.GetOnsetST : TFslDateTime;
begin
  if FOnset = nil then
    result := TFslDateTime.makeNull
  else
    result := FOnset.value;
end;

Procedure TFhirAllergyIntoleranceReaction.SetOnsetST(value : TFslDateTime);
begin
  if FOnset = nil then
    FOnset := TFhirDateTime.create;
  FOnset.value := value
end;

Procedure TFhirAllergyIntoleranceReaction.SetSeverity(value : TFhirEnum);
begin
  FSeverity.free;
  FSeverity := value;
end;

Function TFhirAllergyIntoleranceReaction.GetSeverityST : TFhirReactionEventSeverityEnum;
begin
  if FSeverity = nil then
    result := TFhirReactionEventSeverityEnum(0)
  else
    result := TFhirReactionEventSeverityEnum(StringArrayIndexOfSensitive(CODES_TFhirReactionEventSeverityEnum, FSeverity.value));
end;

Procedure TFhirAllergyIntoleranceReaction.SetSeverityST(value : TFhirReactionEventSeverityEnum);
begin
  if ord(value) = 0 then
    SeverityElement := nil
  else
    SeverityElement := TFhirEnum.create(SYSTEMS_TFhirReactionEventSeverityEnum[value], CODES_TFhirReactionEventSeverityEnum[value]);
end;

Procedure TFhirAllergyIntoleranceReaction.SetExposureRoute(value : TFhirCodeableConcept);
begin
  FExposureRoute.free;
  FExposureRoute := value;
end;

Function TFhirAllergyIntoleranceReaction.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirAllergyIntoleranceReaction.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirAllergyIntoleranceReaction.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSubstance.sizeInBytes);
  inc(result, FmanifestationList.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FOnset.sizeInBytes);
  inc(result, FSeverity.sizeInBytes);
  inc(result, FExposureRoute.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
end;

{ TFhirAllergyIntoleranceReactionListEnumerator }

Constructor TFhirAllergyIntoleranceReactionListEnumerator.Create(list : TFhirAllergyIntoleranceReactionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAllergyIntoleranceReactionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAllergyIntoleranceReactionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAllergyIntoleranceReactionListEnumerator.GetCurrent : TFhirAllergyIntoleranceReaction;
begin
  Result := FList[FIndex];
end;

function TFhirAllergyIntoleranceReactionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAllergyIntoleranceReactionList }
procedure TFhirAllergyIntoleranceReactionList.AddItem(value: TFhirAllergyIntoleranceReaction);
begin
  assert(value.ClassName = 'TFhirAllergyIntoleranceReaction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAllergyIntoleranceReaction');
  add(value);
end;

function TFhirAllergyIntoleranceReactionList.Append: TFhirAllergyIntoleranceReaction;
begin
  result := TFhirAllergyIntoleranceReaction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAllergyIntoleranceReactionList.ClearItems;
begin
  Clear;
end;

function TFhirAllergyIntoleranceReactionList.GetEnumerator : TFhirAllergyIntoleranceReactionListEnumerator;
begin
  result := TFhirAllergyIntoleranceReactionListEnumerator.Create(self.link);
end;

function TFhirAllergyIntoleranceReactionList.Clone: TFhirAllergyIntoleranceReactionList;
begin
  result := TFhirAllergyIntoleranceReactionList(inherited Clone);
end;

function TFhirAllergyIntoleranceReactionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAllergyIntoleranceReactionList.GetItemN(index: Integer): TFhirAllergyIntoleranceReaction;
begin
  result := TFhirAllergyIntoleranceReaction(ObjectByIndex[index]);
end;

function TFhirAllergyIntoleranceReactionList.ItemClass: TFslObjectClass;
begin
  result := TFhirAllergyIntoleranceReaction;
end;
function TFhirAllergyIntoleranceReactionList.IndexOf(value: TFhirAllergyIntoleranceReaction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAllergyIntoleranceReactionList.Insert(index: Integer): TFhirAllergyIntoleranceReaction;
begin
  result := TFhirAllergyIntoleranceReaction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAllergyIntoleranceReactionList.InsertItem(index: Integer; value: TFhirAllergyIntoleranceReaction);
begin
  assert(value is TFhirAllergyIntoleranceReaction);
  Inherited Insert(index, value);
end;

function TFhirAllergyIntoleranceReactionList.Item(index: Integer): TFhirAllergyIntoleranceReaction;
begin
  result := TFhirAllergyIntoleranceReaction(ObjectByIndex[index]);
end;

function TFhirAllergyIntoleranceReactionList.Link: TFhirAllergyIntoleranceReactionList;
begin
  result := TFhirAllergyIntoleranceReactionList(inherited Link);
end;

procedure TFhirAllergyIntoleranceReactionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAllergyIntoleranceReactionList.SetItemByIndex(index: Integer; value: TFhirAllergyIntoleranceReaction);
begin
  assert(value is TFhirAllergyIntoleranceReaction);
  FhirAllergyIntoleranceReactions[index] := value;
end;

procedure TFhirAllergyIntoleranceReactionList.SetItemN(index: Integer; value: TFhirAllergyIntoleranceReaction);
begin
  assert(value is TFhirAllergyIntoleranceReaction);
  ObjectByIndex[index] := value;
end;

{ TFhirAllergyIntolerance }

constructor TFhirAllergyIntolerance.Create;
begin
  inherited;
end;

destructor TFhirAllergyIntolerance.Destroy;
begin
  FIdentifierList.Free;
  FClinicalStatus.free;
  FVerificationStatus.free;
  FType_.free;
  FCategory.Free;
  FCriticality.free;
  FCode.free;
  FPatient.free;
  FOnset.free;
  FAssertedDate.free;
  FRecorder.free;
  FAsserter.free;
  FLastOccurrence.free;
  FNoteList.Free;
  FReactionList.Free;
  inherited;
end;

function TFhirAllergyIntolerance.GetResourceType : TFhirResourceType;
begin
  result := frtAllergyIntolerance;
end;

procedure TFhirAllergyIntolerance.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirAllergyIntolerance(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirAllergyIntolerance(oSource).FIdentifierList);
  end;
  FClinicalStatus := TFhirAllergyIntolerance(oSource).FClinicalStatus.Link;
  FVerificationStatus := TFhirAllergyIntolerance(oSource).FVerificationStatus.Link;
  FType_ := TFhirAllergyIntolerance(oSource).FType_.Link;
  if (TFhirAllergyIntolerance(oSource).FCategory = nil) then
  begin
    FCategory.free;
    FCategory := nil;
  end
  else
  begin
    FCategory := TFHIREnumList.Create(SYSTEMS_TFhirAllergyIntoleranceCategoryEnum, CODES_TFhirAllergyIntoleranceCategoryEnum);
    FCategory.Assign(TFhirAllergyIntolerance(oSource).FCategory);
  end;
  FCriticality := TFhirAllergyIntolerance(oSource).FCriticality.Link;
  code := TFhirAllergyIntolerance(oSource).code.Clone;
  patient := TFhirAllergyIntolerance(oSource).patient.Clone;
  onset := TFhirAllergyIntolerance(oSource).onset.Clone;
  assertedDateElement := TFhirAllergyIntolerance(oSource).assertedDateElement.Clone;
  recorder := TFhirAllergyIntolerance(oSource).recorder.Clone;
  asserter := TFhirAllergyIntolerance(oSource).asserter.Clone;
  lastOccurrenceElement := TFhirAllergyIntolerance(oSource).lastOccurrenceElement.Clone;
  if (TFhirAllergyIntolerance(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirAllergyIntolerance(oSource).FNoteList);
  end;
  if (TFhirAllergyIntolerance(oSource).FReactionList = nil) then
  begin
    FReactionList.free;
    FReactionList := nil;
  end
  else
  begin
    if FReactionList = nil then
      FReactionList := TFhirAllergyIntoleranceReactionList.Create;
    FReactionList.Assign(TFhirAllergyIntolerance(oSource).FReactionList);
  end;
end;

procedure TFhirAllergyIntolerance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'clinicalStatus') Then
     list.add(self.link, 'clinicalStatus', FClinicalStatus.Link);
  if (child_name = 'verificationStatus') Then
     list.add(self.link, 'verificationStatus', FVerificationStatus.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'category') Then
     list.addAll(self, 'category', FCategory);
  if (child_name = 'criticality') Then
     list.add(self.link, 'criticality', FCriticality.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'onset[x]') or (child_name = 'onset') Then
     list.add(self.link, 'onset[x]', FOnset.Link);
  if (child_name = 'assertedDate') Then
     list.add(self.link, 'assertedDate', FAssertedDate.Link);
  if (child_name = 'recorder') Then
     list.add(self.link, 'recorder', FRecorder.Link);
  if (child_name = 'asserter') Then
     list.add(self.link, 'asserter', FAsserter.Link);
  if (child_name = 'lastOccurrence') Then
     list.add(self.link, 'lastOccurrence', FLastOccurrence.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'reaction') Then
    list.addAll(self, 'reaction', FReactionList);
end;

procedure TFhirAllergyIntolerance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'clinicalStatus', 'code', false, TFHIREnum, FClinicalStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'verificationStatus', 'code', false, TFHIREnum, FVerificationStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'category', 'code', true, TFHIREnum, FCategory.Link)){3};
  oList.add(TFHIRProperty.create(self, 'criticality', 'code', false, TFHIREnum, FCriticality.Link));{1}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'onset[x]', 'dateTime|Age|Period|Range|string', false, TFhirType, FOnset.Link));{2}
  oList.add(TFHIRProperty.create(self, 'assertedDate', 'dateTime', false, TFhirDateTime, FAssertedDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'recorder', 'Reference(Practitioner|Patient)', false, TFhirReference{Resource}, FRecorder.Link));{2}
  oList.add(TFHIRProperty.create(self, 'asserter', 'Reference(Patient|RelatedPerson|Practitioner)', false, TFhirReference{Resource}, FAsserter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'lastOccurrence', 'dateTime', false, TFhirDateTime, FLastOccurrence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reaction', '', true, TFhirAllergyIntoleranceReaction, FReactionList.Link)){3};
end;

function TFhirAllergyIntolerance.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'clinicalStatus') then
  begin
    ClinicalStatusElement := asEnum(SYSTEMS_TFhirAllergyClinicalStatusEnum, CODES_TFhirAllergyClinicalStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'verificationStatus') then
  begin
    VerificationStatusElement := asEnum(SYSTEMS_TFhirAllergyVerificationStatusEnum, CODES_TFhirAllergyVerificationStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirAllergyIntoleranceTypeEnum, CODES_TFhirAllergyIntoleranceTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(asEnum(SYSTEMS_TFhirAllergyIntoleranceCategoryEnum, CODES_TFhirAllergyIntoleranceCategoryEnum, propValue)); {1}
    result := propValue;
  end
  else if (propName = 'criticality') then
  begin
    CriticalityElement := asEnum(SYSTEMS_TFhirAllergyIntoleranceCriticalityEnum, CODES_TFhirAllergyIntoleranceCriticalityEnum, propValue);
    result := propValue
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'onset', ['DateTime', 'Age', 'Period', 'Range', 'String'])) then
  begin
    Onset := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'assertedDate') then
  begin
    AssertedDateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'recorder') then
  begin
    Recorder := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'asserter') then
  begin
    Asserter := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'lastOccurrence') then
  begin
    LastOccurrenceElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else if (propName = 'reaction') then
  begin
    ReactionList.add(propValue as TFhirAllergyIntoleranceReaction){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirAllergyIntolerance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'category') then FCategory.insertItem(index, asEnum(SYSTEMS_TFhirAllergyIntoleranceCategoryEnum, CODES_TFhirAllergyIntoleranceCategoryEnum, propValue)) {1}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else if (propName = 'reaction') then ReactionList.insertItem(index, propValue as TFhirAllergyIntoleranceReaction){2a}
  else inherited;
end;

function TFhirAllergyIntolerance.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (isMatchingName(propName, 'onset', ['DateTime', 'Age', 'Period', 'Range', 'String'])) then raise EFHIRException.create('Cannot make property Onset'){4x}
  else if (propName = 'assertedDate') then result := TFhirDateTime.create() {5b}
  else if (propName = 'recorder') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'asserter') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'lastOccurrence') then result := TFhirDateTime.create() {5b}
  else if (propName = 'note') then result := NoteList.new(){2}
  else if (propName = 'reaction') then result := ReactionList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAllergyIntolerance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'clinicalStatus') then result := 'code'
  else if (propName = 'verificationStatus') then result := 'code'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'category') then result := 'code'
  else if (propName = 'criticality') then result := 'code'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'onset[x]') then result := 'dateTime|Age|Period|Range|string'
  else if (propName = 'assertedDate') then result := 'dateTime'
  else if (propName = 'recorder') then result := 'Reference'
  else if (propName = 'asserter') then result := 'Reference'
  else if (propName = 'lastOccurrence') then result := 'dateTime'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'reaction') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAllergyIntolerance.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'clinicalStatus') then ClinicalStatusElement := nil
  else if (propName = 'verificationStatus') then VerificationStatusElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'criticality') then CriticalityElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (isMatchingName(propName, 'onset', ['DateTime', 'Age', 'Period', 'Range', 'String'])) then OnsetElement := nil{4x}
  else if (propName = 'assertedDate') then AssertedDateElement := nil
  else if (propName = 'recorder') then RecorderElement := nil
  else if (propName = 'asserter') then AsserterElement := nil
  else if (propName = 'lastOccurrence') then LastOccurrenceElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else if (propName = 'reaction') then deletePropertyValue('reaction', ReactionList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAllergyIntolerance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'clinicalStatus') then ClinicalStatusElement := asEnum(SYSTEMS_TFhirAllergyClinicalStatusEnum, CODES_TFhirAllergyClinicalStatusEnum, new){4}
  else if (propName = 'verificationStatus') then VerificationStatusElement := asEnum(SYSTEMS_TFhirAllergyVerificationStatusEnum, CODES_TFhirAllergyVerificationStatusEnum, new){4}
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirAllergyIntoleranceTypeEnum, CODES_TFhirAllergyIntoleranceTypeEnum, new){4}
  else if (propName = 'criticality') then CriticalityElement := asEnum(SYSTEMS_TFhirAllergyIntoleranceCriticalityEnum, CODES_TFhirAllergyIntoleranceCriticalityEnum, new){4}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (isMatchingName(propName, 'onset', ['DateTime', 'Age', 'Period', 'Range', 'String'])) then OnsetElement := new as TFhirType{4x}
  else if (propName = 'assertedDate') then AssertedDateElement := asDateTime(new){5b}
  else if (propName = 'recorder') then RecorderElement := new as TFhirReference{Resource}{4}
  else if (propName = 'asserter') then AsserterElement := new as TFhirReference{Resource}{4}
  else if (propName = 'lastOccurrence') then LastOccurrenceElement := asDateTime(new){5b}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else if (propName = 'reaction') then replacePropertyValue('reaction', ReactionList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAllergyIntolerance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'category') then FCategory.move(source, destination) {1}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else if (propName = 'reaction') then ReactionList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAllergyIntolerance.fhirType : string;
begin
  result := 'AllergyIntolerance';
end;

function TFhirAllergyIntolerance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FClinicalStatus) and isEmptyProp(FVerificationStatus) and isEmptyProp(FType_) and isEmptyProp(FCategory) and isEmptyProp(FCriticality) and isEmptyProp(FCode) and isEmptyProp(FPatient) and isEmptyProp(FOnset) and isEmptyProp(FAssertedDate) and isEmptyProp(FRecorder) and isEmptyProp(FAsserter) and isEmptyProp(FLastOccurrence) and isEmptyProp(FnoteList) and isEmptyProp(FreactionList);
end;

function TFhirAllergyIntolerance.equals(other : TObject) : boolean;
var
  o : TFhirAllergyIntolerance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAllergyIntolerance)) then
    result := false
  else
  begin
    o := TFhirAllergyIntolerance(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(clinicalStatusElement, o.clinicalStatusElement, true) and
      compareDeep(verificationStatusElement, o.verificationStatusElement, true) and
      compareDeep(type_Element, o.type_Element, true) and compareDeep(categoryList, o.categoryList, true) and
      compareDeep(criticalityElement, o.criticalityElement, true) and compareDeep(codeElement, o.codeElement, true) and
      compareDeep(patientElement, o.patientElement, true) and compareDeep(onsetElement, o.onsetElement, true) and
      compareDeep(assertedDateElement, o.assertedDateElement, true) and compareDeep(recorderElement, o.recorderElement, true) and
      compareDeep(asserterElement, o.asserterElement, true) and compareDeep(lastOccurrenceElement, o.lastOccurrenceElement, true) and
      compareDeep(noteList, o.noteList, true) and compareDeep(reactionList, o.reactionList, true);
  end;
end;

function TFhirAllergyIntolerance.Link : TFhirAllergyIntolerance;
begin
  result := TFhirAllergyIntolerance(inherited Link);
end;

function TFhirAllergyIntolerance.Clone : TFhirAllergyIntolerance;
begin
  result := TFhirAllergyIntolerance(inherited Clone);
end;

procedure TFhirAllergyIntolerance.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('clinicalStatus');
  fields.add('verificationStatus');
  fields.add('type');
  fields.add('category');
  fields.add('criticality');
  fields.add('code');
  fields.add('patient');
  fields.add('onset[x]');
  fields.add('assertedDate');
  fields.add('recorder');
  fields.add('asserter');
  fields.add('lastOccurrence');
  fields.add('note');
  fields.add('reaction');
end;

{ TFhirAllergyIntolerance }

Function TFhirAllergyIntolerance.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirAllergyIntolerance.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirAllergyIntolerance.SetClinicalStatus(value : TFhirEnum);
begin
  FClinicalStatus.free;
  FClinicalStatus := value;
end;

Function TFhirAllergyIntolerance.GetClinicalStatusST : TFhirAllergyClinicalStatusEnum;
begin
  if FClinicalStatus = nil then
    result := TFhirAllergyClinicalStatusEnum(0)
  else
    result := TFhirAllergyClinicalStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirAllergyClinicalStatusEnum, FClinicalStatus.value));
end;

Procedure TFhirAllergyIntolerance.SetClinicalStatusST(value : TFhirAllergyClinicalStatusEnum);
begin
  if ord(value) = 0 then
    ClinicalStatusElement := nil
  else
    ClinicalStatusElement := TFhirEnum.create(SYSTEMS_TFhirAllergyClinicalStatusEnum[value], CODES_TFhirAllergyClinicalStatusEnum[value]);
end;

Procedure TFhirAllergyIntolerance.SetVerificationStatus(value : TFhirEnum);
begin
  FVerificationStatus.free;
  FVerificationStatus := value;
end;

Function TFhirAllergyIntolerance.GetVerificationStatusST : TFhirAllergyVerificationStatusEnum;
begin
  if FVerificationStatus = nil then
    result := TFhirAllergyVerificationStatusEnum(0)
  else
    result := TFhirAllergyVerificationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirAllergyVerificationStatusEnum, FVerificationStatus.value));
end;

Procedure TFhirAllergyIntolerance.SetVerificationStatusST(value : TFhirAllergyVerificationStatusEnum);
begin
  if ord(value) = 0 then
    VerificationStatusElement := nil
  else
    VerificationStatusElement := TFhirEnum.create(SYSTEMS_TFhirAllergyVerificationStatusEnum[value], CODES_TFhirAllergyVerificationStatusEnum[value]);
end;

Procedure TFhirAllergyIntolerance.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirAllergyIntolerance.GetType_ST : TFhirAllergyIntoleranceTypeEnum;
begin
  if FType_ = nil then
    result := TFhirAllergyIntoleranceTypeEnum(0)
  else
    result := TFhirAllergyIntoleranceTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirAllergyIntoleranceTypeEnum, FType_.value));
end;

Procedure TFhirAllergyIntolerance.SetType_ST(value : TFhirAllergyIntoleranceTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirAllergyIntoleranceTypeEnum[value], CODES_TFhirAllergyIntoleranceTypeEnum[value]);
end;

Function TFhirAllergyIntolerance.GetCategory : TFhirEnumList;
begin
  if FCategory = nil then
    FCategory := TFHIREnumList.Create(SYSTEMS_TFhirAllergyIntoleranceCategoryEnum, CODES_TFhirAllergyIntoleranceCategoryEnum);
  result := FCategory;
end;

Function TFhirAllergyIntolerance.GetHasCategory : boolean;
begin
  result := (FCategory <> nil) and (FCategory.count > 0);
end;

Function TFhirAllergyIntolerance.GetCategoryST : TFhirAllergyIntoleranceCategoryEnumList;
  var i : integer;
begin
  result := [];
  if Fcategory <> nil then
    for i := 0 to Fcategory.count - 1 do
      result := result + [TFhirAllergyIntoleranceCategoryEnum(StringArrayIndexOfSensitive(CODES_TFhirAllergyIntoleranceCategoryEnum, Fcategory[i].value))];
end;

Procedure TFhirAllergyIntolerance.SetCategoryST(value : TFhirAllergyIntoleranceCategoryEnumList);
var a : TFhirAllergyIntoleranceCategoryEnum;
begin
  if Fcategory = nil then
    Fcategory := TFhirEnumList.create(SYSTEMS_TFhirAllergyIntoleranceCategoryEnum, CODES_TFhirAllergyIntoleranceCategoryEnum);
  Fcategory.clear;
  for a := low(TFhirAllergyIntoleranceCategoryEnum) to high(TFhirAllergyIntoleranceCategoryEnum) do
    if a in value then
      begin
         if Fcategory = nil then
           Fcategory := TFhirEnumList.create(SYSTEMS_TFhirAllergyIntoleranceCategoryEnum, CODES_TFhirAllergyIntoleranceCategoryEnum);
         Fcategory.add(TFhirEnum.create(SYSTEMS_TFhirAllergyIntoleranceCategoryEnum[a], CODES_TFhirAllergyIntoleranceCategoryEnum[a]));
      end;
end;

Procedure TFhirAllergyIntolerance.SetCriticality(value : TFhirEnum);
begin
  FCriticality.free;
  FCriticality := value;
end;

Function TFhirAllergyIntolerance.GetCriticalityST : TFhirAllergyIntoleranceCriticalityEnum;
begin
  if FCriticality = nil then
    result := TFhirAllergyIntoleranceCriticalityEnum(0)
  else
    result := TFhirAllergyIntoleranceCriticalityEnum(StringArrayIndexOfSensitive(CODES_TFhirAllergyIntoleranceCriticalityEnum, FCriticality.value));
end;

Procedure TFhirAllergyIntolerance.SetCriticalityST(value : TFhirAllergyIntoleranceCriticalityEnum);
begin
  if ord(value) = 0 then
    CriticalityElement := nil
  else
    CriticalityElement := TFhirEnum.create(SYSTEMS_TFhirAllergyIntoleranceCriticalityEnum[value], CODES_TFhirAllergyIntoleranceCriticalityEnum[value]);
end;

Procedure TFhirAllergyIntolerance.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirAllergyIntolerance.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Procedure TFhirAllergyIntolerance.SetOnset(value : TFhirType);
begin
  FOnset.free;
  FOnset := value;
end;

Procedure TFhirAllergyIntolerance.SetAssertedDate(value : TFhirDateTime);
begin
  FAssertedDate.free;
  FAssertedDate := value;
end;

Function TFhirAllergyIntolerance.GetAssertedDateST : TFslDateTime;
begin
  if FAssertedDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FAssertedDate.value;
end;

Procedure TFhirAllergyIntolerance.SetAssertedDateST(value : TFslDateTime);
begin
  if FAssertedDate = nil then
    FAssertedDate := TFhirDateTime.create;
  FAssertedDate.value := value
end;

Procedure TFhirAllergyIntolerance.SetRecorder(value : TFhirReference{Resource});
begin
  FRecorder.free;
  FRecorder := value;
end;

Procedure TFhirAllergyIntolerance.SetAsserter(value : TFhirReference{Resource});
begin
  FAsserter.free;
  FAsserter := value;
end;

Procedure TFhirAllergyIntolerance.SetLastOccurrence(value : TFhirDateTime);
begin
  FLastOccurrence.free;
  FLastOccurrence := value;
end;

Function TFhirAllergyIntolerance.GetLastOccurrenceST : TFslDateTime;
begin
  if FLastOccurrence = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastOccurrence.value;
end;

Procedure TFhirAllergyIntolerance.SetLastOccurrenceST(value : TFslDateTime);
begin
  if FLastOccurrence = nil then
    FLastOccurrence := TFhirDateTime.create;
  FLastOccurrence.value := value
end;

Function TFhirAllergyIntolerance.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirAllergyIntolerance.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

Function TFhirAllergyIntolerance.GetReactionList : TFhirAllergyIntoleranceReactionList;
begin
  if FReactionList = nil then
    FReactionList := TFhirAllergyIntoleranceReactionList.Create;
  result := FReactionList;
end;

Function TFhirAllergyIntolerance.GetHasReactionList : boolean;
begin
  result := (FReactionList <> nil) and (FReactionList.count > 0);
end;

function TFhirAllergyIntolerance.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FClinicalStatus.sizeInBytes);
  inc(result, FVerificationStatus.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FCriticality.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FOnset.sizeInBytes);
  inc(result, FAssertedDate.sizeInBytes);
  inc(result, FRecorder.sizeInBytes);
  inc(result, FAsserter.sizeInBytes);
  inc(result, FLastOccurrence.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FreactionList.sizeInBytes);
end;

{ TFhirAllergyIntoleranceListEnumerator }

Constructor TFhirAllergyIntoleranceListEnumerator.Create(list : TFhirAllergyIntoleranceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAllergyIntoleranceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAllergyIntoleranceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAllergyIntoleranceListEnumerator.GetCurrent : TFhirAllergyIntolerance;
begin
  Result := FList[FIndex];
end;

function TFhirAllergyIntoleranceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAllergyIntoleranceList }
procedure TFhirAllergyIntoleranceList.AddItem(value: TFhirAllergyIntolerance);
begin
  assert(value.ClassName = 'TFhirAllergyIntolerance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAllergyIntolerance');
  add(value);
end;

function TFhirAllergyIntoleranceList.Append: TFhirAllergyIntolerance;
begin
  result := TFhirAllergyIntolerance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAllergyIntoleranceList.ClearItems;
begin
  Clear;
end;

function TFhirAllergyIntoleranceList.GetEnumerator : TFhirAllergyIntoleranceListEnumerator;
begin
  result := TFhirAllergyIntoleranceListEnumerator.Create(self.link);
end;

function TFhirAllergyIntoleranceList.Clone: TFhirAllergyIntoleranceList;
begin
  result := TFhirAllergyIntoleranceList(inherited Clone);
end;

function TFhirAllergyIntoleranceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAllergyIntoleranceList.GetItemN(index: Integer): TFhirAllergyIntolerance;
begin
  result := TFhirAllergyIntolerance(ObjectByIndex[index]);
end;

function TFhirAllergyIntoleranceList.ItemClass: TFslObjectClass;
begin
  result := TFhirAllergyIntolerance;
end;
function TFhirAllergyIntoleranceList.IndexOf(value: TFhirAllergyIntolerance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAllergyIntoleranceList.Insert(index: Integer): TFhirAllergyIntolerance;
begin
  result := TFhirAllergyIntolerance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAllergyIntoleranceList.InsertItem(index: Integer; value: TFhirAllergyIntolerance);
begin
  assert(value is TFhirAllergyIntolerance);
  Inherited Insert(index, value);
end;

function TFhirAllergyIntoleranceList.Item(index: Integer): TFhirAllergyIntolerance;
begin
  result := TFhirAllergyIntolerance(ObjectByIndex[index]);
end;

function TFhirAllergyIntoleranceList.Link: TFhirAllergyIntoleranceList;
begin
  result := TFhirAllergyIntoleranceList(inherited Link);
end;

procedure TFhirAllergyIntoleranceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAllergyIntoleranceList.SetItemByIndex(index: Integer; value: TFhirAllergyIntolerance);
begin
  assert(value is TFhirAllergyIntolerance);
  FhirAllergyIntolerances[index] := value;
end;

procedure TFhirAllergyIntoleranceList.SetItemN(index: Integer; value: TFhirAllergyIntolerance);
begin
  assert(value is TFhirAllergyIntolerance);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ALLERGYINTOLERANCE}

{$IFDEF FHIR_APPOINTMENT}

{ TFhirAppointmentParticipant }

constructor TFhirAppointmentParticipant.Create;
begin
  inherited;
end;

destructor TFhirAppointmentParticipant.Destroy;
begin
  FType_List.Free;
  FActor.free;
  FRequired.free;
  FStatus.free;
  inherited;
end;

procedure TFhirAppointmentParticipant.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirAppointmentParticipant(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirAppointmentParticipant(oSource).FType_List);
  end;
  actor := TFhirAppointmentParticipant(oSource).actor.Clone;
  FRequired := TFhirAppointmentParticipant(oSource).FRequired.Link;
  FStatus := TFhirAppointmentParticipant(oSource).FStatus.Link;
end;

procedure TFhirAppointmentParticipant.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'actor') Then
     list.add(self.link, 'actor', FActor.Link);
  if (child_name = 'required') Then
     list.add(self.link, 'required', FRequired.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
end;

procedure TFhirAppointmentParticipant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'actor', 'Reference(Patient|Practitioner|RelatedPerson|Device|HealthcareService|Location)', false, TFhirReference{Resource}, FActor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'required', 'code', false, TFHIREnum, FRequired.Link));{1}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
end;

function TFhirAppointmentParticipant.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    Actor := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'required') then
  begin
    RequiredElement := asEnum(SYSTEMS_TFhirParticipantrequiredEnum, CODES_TFhirParticipantrequiredEnum, propValue);
    result := propValue
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirParticipationstatusEnum, CODES_TFhirParticipationstatusEnum, propValue);
    result := propValue
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAppointmentParticipant.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirAppointmentParticipant.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := Type_List.new(){2}
  else if (propName = 'actor') then result := TFhirReference{Resource}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAppointmentParticipant.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'actor') then result := 'Reference'
  else if (propName = 'required') then result := 'code'
  else if (propName = 'status') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAppointmentParticipant.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then deletePropertyValue('type', Type_List, value) {2}
  else if (propName = 'actor') then ActorElement := nil
  else if (propName = 'required') then RequiredElement := nil
  else if (propName = 'status') then StatusElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAppointmentParticipant.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new) {2}
  else if (propName = 'actor') then ActorElement := new as TFhirReference{Resource}{4}
  else if (propName = 'required') then RequiredElement := asEnum(SYSTEMS_TFhirParticipantrequiredEnum, CODES_TFhirParticipantrequiredEnum, new){4}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirParticipationstatusEnum, CODES_TFhirParticipationstatusEnum, new){4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAppointmentParticipant.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'type') then Type_List.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAppointmentParticipant.fhirType : string;
begin
  result := 'participant';
end;

function TFhirAppointmentParticipant.Link : TFhirAppointmentParticipant;
begin
  result := TFhirAppointmentParticipant(inherited Link);
end;

function TFhirAppointmentParticipant.Clone : TFhirAppointmentParticipant;
begin
  result := TFhirAppointmentParticipant(inherited Clone);
end;

function TFhirAppointmentParticipant.equals(other : TObject) : boolean;
var
  o : TFhirAppointmentParticipant;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAppointmentParticipant)) then
    result := false
  else
  begin
    o := TFhirAppointmentParticipant(other);
    result := compareDeep(type_List, o.type_List, true) and compareDeep(actorElement, o.actorElement, true) and
      compareDeep(requiredElement, o.requiredElement, true) and compareDeep(statusElement, o.statusElement, true);
  end;
end;

function TFhirAppointmentParticipant.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(Ftype_List) and isEmptyProp(FActor) and isEmptyProp(FRequired) and isEmptyProp(FStatus);
end;

procedure TFhirAppointmentParticipant.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('actor');
  fields.add('required');
  fields.add('status');
end;

{ TFhirAppointmentParticipant }

Function TFhirAppointmentParticipant.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

Function TFhirAppointmentParticipant.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

Procedure TFhirAppointmentParticipant.SetActor(value : TFhirReference{Resource});
begin
  FActor.free;
  FActor := value;
end;

Procedure TFhirAppointmentParticipant.SetRequired(value : TFhirEnum);
begin
  FRequired.free;
  FRequired := value;
end;

Function TFhirAppointmentParticipant.GetRequiredST : TFhirParticipantrequiredEnum;
begin
  if FRequired = nil then
    result := TFhirParticipantrequiredEnum(0)
  else
    result := TFhirParticipantrequiredEnum(StringArrayIndexOfSensitive(CODES_TFhirParticipantrequiredEnum, FRequired.value));
end;

Procedure TFhirAppointmentParticipant.SetRequiredST(value : TFhirParticipantrequiredEnum);
begin
  if ord(value) = 0 then
    RequiredElement := nil
  else
    RequiredElement := TFhirEnum.create(SYSTEMS_TFhirParticipantrequiredEnum[value], CODES_TFhirParticipantrequiredEnum[value]);
end;

Procedure TFhirAppointmentParticipant.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirAppointmentParticipant.GetStatusST : TFhirParticipationstatusEnum;
begin
  if FStatus = nil then
    result := TFhirParticipationstatusEnum(0)
  else
    result := TFhirParticipationstatusEnum(StringArrayIndexOfSensitive(CODES_TFhirParticipationstatusEnum, FStatus.value));
end;

Procedure TFhirAppointmentParticipant.SetStatusST(value : TFhirParticipationstatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirParticipationstatusEnum[value], CODES_TFhirParticipationstatusEnum[value]);
end;

function TFhirAppointmentParticipant.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, Ftype_List.sizeInBytes);
  inc(result, FActor.sizeInBytes);
  inc(result, FRequired.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
end;

{ TFhirAppointmentParticipantListEnumerator }

Constructor TFhirAppointmentParticipantListEnumerator.Create(list : TFhirAppointmentParticipantList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAppointmentParticipantListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAppointmentParticipantListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAppointmentParticipantListEnumerator.GetCurrent : TFhirAppointmentParticipant;
begin
  Result := FList[FIndex];
end;

function TFhirAppointmentParticipantListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAppointmentParticipantList }
procedure TFhirAppointmentParticipantList.AddItem(value: TFhirAppointmentParticipant);
begin
  assert(value.ClassName = 'TFhirAppointmentParticipant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAppointmentParticipant');
  add(value);
end;

function TFhirAppointmentParticipantList.Append: TFhirAppointmentParticipant;
begin
  result := TFhirAppointmentParticipant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAppointmentParticipantList.ClearItems;
begin
  Clear;
end;

function TFhirAppointmentParticipantList.GetEnumerator : TFhirAppointmentParticipantListEnumerator;
begin
  result := TFhirAppointmentParticipantListEnumerator.Create(self.link);
end;

function TFhirAppointmentParticipantList.Clone: TFhirAppointmentParticipantList;
begin
  result := TFhirAppointmentParticipantList(inherited Clone);
end;

function TFhirAppointmentParticipantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAppointmentParticipantList.GetItemN(index: Integer): TFhirAppointmentParticipant;
begin
  result := TFhirAppointmentParticipant(ObjectByIndex[index]);
end;

function TFhirAppointmentParticipantList.ItemClass: TFslObjectClass;
begin
  result := TFhirAppointmentParticipant;
end;
function TFhirAppointmentParticipantList.IndexOf(value: TFhirAppointmentParticipant): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAppointmentParticipantList.Insert(index: Integer): TFhirAppointmentParticipant;
begin
  result := TFhirAppointmentParticipant.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAppointmentParticipantList.InsertItem(index: Integer; value: TFhirAppointmentParticipant);
begin
  assert(value is TFhirAppointmentParticipant);
  Inherited Insert(index, value);
end;

function TFhirAppointmentParticipantList.Item(index: Integer): TFhirAppointmentParticipant;
begin
  result := TFhirAppointmentParticipant(ObjectByIndex[index]);
end;

function TFhirAppointmentParticipantList.Link: TFhirAppointmentParticipantList;
begin
  result := TFhirAppointmentParticipantList(inherited Link);
end;

procedure TFhirAppointmentParticipantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAppointmentParticipantList.SetItemByIndex(index: Integer; value: TFhirAppointmentParticipant);
begin
  assert(value is TFhirAppointmentParticipant);
  FhirAppointmentParticipants[index] := value;
end;

procedure TFhirAppointmentParticipantList.SetItemN(index: Integer; value: TFhirAppointmentParticipant);
begin
  assert(value is TFhirAppointmentParticipant);
  ObjectByIndex[index] := value;
end;

{ TFhirAppointment }

constructor TFhirAppointment.Create;
begin
  inherited;
end;

destructor TFhirAppointment.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FServiceCategory.free;
  FServiceTypeList.Free;
  FSpecialtyList.Free;
  FAppointmentType.free;
  FReasonList.Free;
  FIndicationList.Free;
  FPriority.free;
  FDescription.free;
  FSupportingInformationList.Free;
  FStart.free;
  FEnd_.free;
  FMinutesDuration.free;
  FSlotList.Free;
  FCreated.free;
  FComment.free;
  FIncomingReferralList.Free;
  FParticipantList.Free;
  FRequestedPeriodList.Free;
  inherited;
end;

function TFhirAppointment.GetResourceType : TFhirResourceType;
begin
  result := frtAppointment;
end;

procedure TFhirAppointment.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirAppointment(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirAppointment(oSource).FIdentifierList);
  end;
  FStatus := TFhirAppointment(oSource).FStatus.Link;
  serviceCategory := TFhirAppointment(oSource).serviceCategory.Clone;
  if (TFhirAppointment(oSource).FServiceTypeList = nil) then
  begin
    FServiceTypeList.free;
    FServiceTypeList := nil;
  end
  else
  begin
    if FServiceTypeList = nil then
      FServiceTypeList := TFhirCodeableConceptList.Create;
    FServiceTypeList.Assign(TFhirAppointment(oSource).FServiceTypeList);
  end;
  if (TFhirAppointment(oSource).FSpecialtyList = nil) then
  begin
    FSpecialtyList.free;
    FSpecialtyList := nil;
  end
  else
  begin
    if FSpecialtyList = nil then
      FSpecialtyList := TFhirCodeableConceptList.Create;
    FSpecialtyList.Assign(TFhirAppointment(oSource).FSpecialtyList);
  end;
  appointmentType := TFhirAppointment(oSource).appointmentType.Clone;
  if (TFhirAppointment(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableConceptList.Create;
    FReasonList.Assign(TFhirAppointment(oSource).FReasonList);
  end;
  if (TFhirAppointment(oSource).FIndicationList = nil) then
  begin
    FIndicationList.free;
    FIndicationList := nil;
  end
  else
  begin
    if FIndicationList = nil then
      FIndicationList := TFhirReferenceList{Resource}.Create;
    FIndicationList.Assign(TFhirAppointment(oSource).FIndicationList);
  end;
  priorityElement := TFhirAppointment(oSource).priorityElement.Clone;
  descriptionElement := TFhirAppointment(oSource).descriptionElement.Clone;
  if (TFhirAppointment(oSource).FSupportingInformationList = nil) then
  begin
    FSupportingInformationList.free;
    FSupportingInformationList := nil;
  end
  else
  begin
    if FSupportingInformationList = nil then
      FSupportingInformationList := TFhirReferenceList{TFhirReference}.Create;
    FSupportingInformationList.Assign(TFhirAppointment(oSource).FSupportingInformationList);
  end;
  startElement := TFhirAppointment(oSource).startElement.Clone;
  end_Element := TFhirAppointment(oSource).end_Element.Clone;
  minutesDurationElement := TFhirAppointment(oSource).minutesDurationElement.Clone;
  if (TFhirAppointment(oSource).FSlotList = nil) then
  begin
    FSlotList.free;
    FSlotList := nil;
  end
  else
  begin
    if FSlotList = nil then
      FSlotList := TFhirReferenceList{TFhirSlot}.Create;
    FSlotList.Assign(TFhirAppointment(oSource).FSlotList);
  end;
  createdElement := TFhirAppointment(oSource).createdElement.Clone;
  commentElement := TFhirAppointment(oSource).commentElement.Clone;
  if (TFhirAppointment(oSource).FIncomingReferralList = nil) then
  begin
    FIncomingReferralList.free;
    FIncomingReferralList := nil;
  end
  else
  begin
    if FIncomingReferralList = nil then
      FIncomingReferralList := TFhirReferenceList{TFhirReferralRequest}.Create;
    FIncomingReferralList.Assign(TFhirAppointment(oSource).FIncomingReferralList);
  end;
  if (TFhirAppointment(oSource).FParticipantList = nil) then
  begin
    FParticipantList.free;
    FParticipantList := nil;
  end
  else
  begin
    if FParticipantList = nil then
      FParticipantList := TFhirAppointmentParticipantList.Create;
    FParticipantList.Assign(TFhirAppointment(oSource).FParticipantList);
  end;
  if (TFhirAppointment(oSource).FRequestedPeriodList = nil) then
  begin
    FRequestedPeriodList.free;
    FRequestedPeriodList := nil;
  end
  else
  begin
    if FRequestedPeriodList = nil then
      FRequestedPeriodList := TFhirPeriodList.Create;
    FRequestedPeriodList.Assign(TFhirAppointment(oSource).FRequestedPeriodList);
  end;
end;

procedure TFhirAppointment.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'serviceCategory') Then
     list.add(self.link, 'serviceCategory', FServiceCategory.Link);
  if (child_name = 'serviceType') Then
    list.addAll(self, 'serviceType', FServiceTypeList);
  if (child_name = 'specialty') Then
    list.addAll(self, 'specialty', FSpecialtyList);
  if (child_name = 'appointmentType') Then
     list.add(self.link, 'appointmentType', FAppointmentType.Link);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'indication') Then
    list.addAll(self, 'indication', FIndicationList);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'supportingInformation') Then
    list.addAll(self, 'supportingInformation', FSupportingInformationList);
  if (child_name = 'start') Then
     list.add(self.link, 'start', FStart.Link);
  if (child_name = 'end') Then
     list.add(self.link, 'end', FEnd_.Link);
  if (child_name = 'minutesDuration') Then
     list.add(self.link, 'minutesDuration', FMinutesDuration.Link);
  if (child_name = 'slot') Then
    list.addAll(self, 'slot', FSlotList);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
  if (child_name = 'incomingReferral') Then
    list.addAll(self, 'incomingReferral', FIncomingReferralList);
  if (child_name = 'participant') Then
    list.addAll(self, 'participant', FParticipantList);
  if (child_name = 'requestedPeriod') Then
    list.addAll(self, 'requestedPeriod', FRequestedPeriodList);
end;

procedure TFhirAppointment.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'serviceCategory', 'CodeableConcept', false, TFhirCodeableConcept, FServiceCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'serviceType', 'CodeableConcept', true, TFhirCodeableConcept, FServiceTypeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'specialty', 'CodeableConcept', true, TFhirCodeableConcept, FSpecialtyList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'appointmentType', 'CodeableConcept', false, TFhirCodeableConcept, FAppointmentType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', true, TFhirCodeableConcept, FReasonList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'indication', 'Reference(Condition|Procedure)', true, TFhirReference{Resource}, FIndicationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'priority', 'unsignedInt', false, TFhirUnsignedInt, FPriority.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'supportingInformation', 'Reference(Any)', true, TFhirReference{TFhirReference}, FSupportingInformationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'start', 'instant', false, TFhirInstant, FStart.Link));{2}
  oList.add(TFHIRProperty.create(self, 'end', 'instant', false, TFhirInstant, FEnd_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'minutesDuration', 'positiveInt', false, TFhirPositiveInt, FMinutesDuration.Link));{2}
  oList.add(TFHIRProperty.create(self, 'slot', 'Reference(Slot)', true, TFhirReference{TFhirSlot}, FSlotList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));{2}
  oList.add(TFHIRProperty.create(self, 'comment', 'string', false, TFhirString, FComment.Link));{2}
  oList.add(TFHIRProperty.create(self, 'incomingReferral', 'Reference(ReferralRequest)', true, TFhirReference{TFhirReferralRequest}, FIncomingReferralList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'participant', '', true, TFhirAppointmentParticipant, FParticipantList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'requestedPeriod', 'Period', true, TFhirPeriod, FRequestedPeriodList.Link)){3};
end;

function TFhirAppointment.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirAppointmentstatusEnum, CODES_TFhirAppointmentstatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'serviceCategory') then
  begin
    ServiceCategory := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'serviceType') then
  begin
    ServiceTypeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'specialty') then
  begin
    SpecialtyList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'appointmentType') then
  begin
    AppointmentType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'indication') then
  begin
    IndicationList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asUnsignedInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'supportingInformation') then
  begin
    SupportingInformationList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'start') then
  begin
    StartElement := asInstant(propValue){5a};
    result := propValue;
  end
  else if (propName = 'end') then
  begin
    End_Element := asInstant(propValue){5a};
    result := propValue;
  end
  else if (propName = 'minutesDuration') then
  begin
    MinutesDurationElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'slot') then
  begin
    SlotList.add(propValue as TFhirReference{TFhirSlot}){2a};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'incomingReferral') then
  begin
    IncomingReferralList.add(propValue as TFhirReference{TFhirReferralRequest}){2a};
    result := propValue;
  end
  else if (propName = 'participant') then
  begin
    ParticipantList.add(propValue as TFhirAppointmentParticipant){2a};
    result := propValue;
  end
  else if (propName = 'requestedPeriod') then
  begin
    RequestedPeriodList.add(propValue as TFhirPeriod){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirAppointment.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'serviceType') then ServiceTypeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'specialty') then SpecialtyList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'indication') then IndicationList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'supportingInformation') then SupportingInformationList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'slot') then SlotList.insertItem(index, propValue as TFhirReference{TFhirSlot}){2a}
  else if (propName = 'incomingReferral') then IncomingReferralList.insertItem(index, propValue as TFhirReference{TFhirReferralRequest}){2a}
  else if (propName = 'participant') then ParticipantList.insertItem(index, propValue as TFhirAppointmentParticipant){2a}
  else if (propName = 'requestedPeriod') then RequestedPeriodList.insertItem(index, propValue as TFhirPeriod){2a}
  else inherited;
end;

function TFhirAppointment.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'serviceCategory') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'serviceType') then result := ServiceTypeList.new(){2}
  else if (propName = 'specialty') then result := SpecialtyList.new(){2}
  else if (propName = 'appointmentType') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'reason') then result := ReasonList.new(){2}
  else if (propName = 'indication') then result := IndicationList.new(){2}
  else if (propName = 'priority') then result := TFhirUnsignedInt.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'supportingInformation') then result := SupportingInformationList.new(){2}
  else if (propName = 'start') then result := TFhirInstant.create() {5b}
  else if (propName = 'end') then result := TFhirInstant.create() {5b}
  else if (propName = 'minutesDuration') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'slot') then result := SlotList.new(){2}
  else if (propName = 'created') then result := TFhirDateTime.create() {5b}
  else if (propName = 'comment') then result := TFhirString.create() {5b}
  else if (propName = 'incomingReferral') then result := IncomingReferralList.new(){2}
  else if (propName = 'participant') then result := ParticipantList.new(){2}
  else if (propName = 'requestedPeriod') then result := RequestedPeriodList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAppointment.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'serviceCategory') then result := 'CodeableConcept'
  else if (propName = 'serviceType') then result := 'CodeableConcept'
  else if (propName = 'specialty') then result := 'CodeableConcept'
  else if (propName = 'appointmentType') then result := 'CodeableConcept'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else if (propName = 'indication') then result := 'Reference'
  else if (propName = 'priority') then result := 'unsignedInt'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'supportingInformation') then result := 'Reference'
  else if (propName = 'start') then result := 'instant'
  else if (propName = 'end') then result := 'instant'
  else if (propName = 'minutesDuration') then result := 'positiveInt'
  else if (propName = 'slot') then result := 'Reference'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'comment') then result := 'string'
  else if (propName = 'incomingReferral') then result := 'Reference'
  else if (propName = 'participant') then result := ''
  else if (propName = 'requestedPeriod') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAppointment.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'serviceCategory') then ServiceCategoryElement := nil
  else if (propName = 'serviceType') then deletePropertyValue('serviceType', ServiceTypeList, value) {2}
  else if (propName = 'specialty') then deletePropertyValue('specialty', SpecialtyList, value) {2}
  else if (propName = 'appointmentType') then AppointmentTypeElement := nil
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value) {2}
  else if (propName = 'indication') then deletePropertyValue('indication', IndicationList, value) {2}
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'supportingInformation') then deletePropertyValue('supportingInformation', SupportingInformationList, value) {2}
  else if (propName = 'start') then StartElement := nil
  else if (propName = 'end') then End_Element := nil
  else if (propName = 'minutesDuration') then MinutesDurationElement := nil
  else if (propName = 'slot') then deletePropertyValue('slot', SlotList, value) {2}
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'comment') then CommentElement := nil
  else if (propName = 'incomingReferral') then deletePropertyValue('incomingReferral', IncomingReferralList, value) {2}
  else if (propName = 'participant') then deletePropertyValue('participant', ParticipantList, value) {2}
  else if (propName = 'requestedPeriod') then deletePropertyValue('requestedPeriod', RequestedPeriodList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAppointment.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirAppointmentstatusEnum, CODES_TFhirAppointmentstatusEnum, new){4}
  else if (propName = 'serviceCategory') then ServiceCategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'serviceType') then replacePropertyValue('serviceType', ServiceTypeList, existing, new) {2}
  else if (propName = 'specialty') then replacePropertyValue('specialty', SpecialtyList, existing, new) {2}
  else if (propName = 'appointmentType') then AppointmentTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new) {2}
  else if (propName = 'indication') then replacePropertyValue('indication', IndicationList, existing, new) {2}
  else if (propName = 'priority') then PriorityElement := asUnsignedInt(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'supportingInformation') then replacePropertyValue('supportingInformation', SupportingInformationList, existing, new) {2}
  else if (propName = 'start') then StartElement := asInstant(new){5b}
  else if (propName = 'end') then End_Element := asInstant(new){5b}
  else if (propName = 'minutesDuration') then MinutesDurationElement := asPositiveInt(new){5b}
  else if (propName = 'slot') then replacePropertyValue('slot', SlotList, existing, new) {2}
  else if (propName = 'created') then CreatedElement := asDateTime(new){5b}
  else if (propName = 'comment') then CommentElement := asString(new){5b}
  else if (propName = 'incomingReferral') then replacePropertyValue('incomingReferral', IncomingReferralList, existing, new) {2}
  else if (propName = 'participant') then replacePropertyValue('participant', ParticipantList, existing, new) {2}
  else if (propName = 'requestedPeriod') then replacePropertyValue('requestedPeriod', RequestedPeriodList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAppointment.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'serviceType') then ServiceTypeList.move(source, destination){2a}
  else if (propName = 'specialty') then SpecialtyList.move(source, destination){2a}
  else if (propName = 'reason') then ReasonList.move(source, destination){2a}
  else if (propName = 'indication') then IndicationList.move(source, destination){2a}
  else if (propName = 'supportingInformation') then SupportingInformationList.move(source, destination){2a}
  else if (propName = 'slot') then SlotList.move(source, destination){2a}
  else if (propName = 'incomingReferral') then IncomingReferralList.move(source, destination){2a}
  else if (propName = 'participant') then ParticipantList.move(source, destination){2a}
  else if (propName = 'requestedPeriod') then RequestedPeriodList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAppointment.fhirType : string;
begin
  result := 'Appointment';
end;

function TFhirAppointment.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FServiceCategory) and isEmptyProp(FserviceTypeList) and isEmptyProp(FspecialtyList) and isEmptyProp(FAppointmentType) and isEmptyProp(FreasonList) and isEmptyProp(FindicationList) and isEmptyProp(FPriority) and isEmptyProp(FDescription) and isEmptyProp(FsupportingInformationList) and isEmptyProp(FStart) and isEmptyProp(FEnd_) and isEmptyProp(FMinutesDuration) and isEmptyProp(FslotList) and isEmptyProp(FCreated) and isEmptyProp(FComment) and isEmptyProp(FincomingReferralList) and isEmptyProp(FparticipantList) and isEmptyProp(FrequestedPeriodList);
end;

function TFhirAppointment.equals(other : TObject) : boolean;
var
  o : TFhirAppointment;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAppointment)) then
    result := false
  else
  begin
    o := TFhirAppointment(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(serviceCategoryElement, o.serviceCategoryElement, true) and compareDeep(serviceTypeList, o.serviceTypeList, true) and
      compareDeep(specialtyList, o.specialtyList, true) and compareDeep(appointmentTypeElement, o.appointmentTypeElement, true) and
      compareDeep(reasonList, o.reasonList, true) and compareDeep(indicationList, o.indicationList, true) and
      compareDeep(priorityElement, o.priorityElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and
      compareDeep(supportingInformationList, o.supportingInformationList, true) and
      compareDeep(startElement, o.startElement, true) and compareDeep(end_Element, o.end_Element, true) and
      compareDeep(minutesDurationElement, o.minutesDurationElement, true) and compareDeep(slotList, o.slotList, true) and
      compareDeep(createdElement, o.createdElement, true) and compareDeep(commentElement, o.commentElement, true) and
      compareDeep(incomingReferralList, o.incomingReferralList, true) and compareDeep(participantList, o.participantList, true) and
      compareDeep(requestedPeriodList, o.requestedPeriodList, true);
  end;
end;

function TFhirAppointment.Link : TFhirAppointment;
begin
  result := TFhirAppointment(inherited Link);
end;

function TFhirAppointment.Clone : TFhirAppointment;
begin
  result := TFhirAppointment(inherited Clone);
end;

procedure TFhirAppointment.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('serviceCategory');
  fields.add('serviceType');
  fields.add('specialty');
  fields.add('appointmentType');
  fields.add('reason');
  fields.add('indication');
  fields.add('priority');
  fields.add('description');
  fields.add('supportingInformation');
  fields.add('start');
  fields.add('end');
  fields.add('minutesDuration');
  fields.add('slot');
  fields.add('created');
  fields.add('comment');
  fields.add('incomingReferral');
  fields.add('participant');
  fields.add('requestedPeriod');
end;

{ TFhirAppointment }

Function TFhirAppointment.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirAppointment.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirAppointment.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirAppointment.GetStatusST : TFhirAppointmentstatusEnum;
begin
  if FStatus = nil then
    result := TFhirAppointmentstatusEnum(0)
  else
    result := TFhirAppointmentstatusEnum(StringArrayIndexOfSensitive(CODES_TFhirAppointmentstatusEnum, FStatus.value));
end;

Procedure TFhirAppointment.SetStatusST(value : TFhirAppointmentstatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirAppointmentstatusEnum[value], CODES_TFhirAppointmentstatusEnum[value]);
end;

Procedure TFhirAppointment.SetServiceCategory(value : TFhirCodeableConcept);
begin
  FServiceCategory.free;
  FServiceCategory := value;
end;

Function TFhirAppointment.GetServiceTypeList : TFhirCodeableConceptList;
begin
  if FServiceTypeList = nil then
    FServiceTypeList := TFhirCodeableConceptList.Create;
  result := FServiceTypeList;
end;

Function TFhirAppointment.GetHasServiceTypeList : boolean;
begin
  result := (FServiceTypeList <> nil) and (FServiceTypeList.count > 0);
end;

Function TFhirAppointment.GetSpecialtyList : TFhirCodeableConceptList;
begin
  if FSpecialtyList = nil then
    FSpecialtyList := TFhirCodeableConceptList.Create;
  result := FSpecialtyList;
end;

Function TFhirAppointment.GetHasSpecialtyList : boolean;
begin
  result := (FSpecialtyList <> nil) and (FSpecialtyList.count > 0);
end;

Procedure TFhirAppointment.SetAppointmentType(value : TFhirCodeableConcept);
begin
  FAppointmentType.free;
  FAppointmentType := value;
end;

Function TFhirAppointment.GetReasonList : TFhirCodeableConceptList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableConceptList.Create;
  result := FReasonList;
end;

Function TFhirAppointment.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

Function TFhirAppointment.GetIndicationList : TFhirReferenceList{Resource};
begin
  if FIndicationList = nil then
    FIndicationList := TFhirReferenceList{Resource}.Create;
  result := FIndicationList;
end;

Function TFhirAppointment.GetHasIndicationList : boolean;
begin
  result := (FIndicationList <> nil) and (FIndicationList.count > 0);
end;

Procedure TFhirAppointment.SetPriority(value : TFhirUnsignedInt);
begin
  FPriority.free;
  FPriority := value;
end;

Function TFhirAppointment.GetPriorityST : String;
begin
  if FPriority = nil then
    result := ''
  else
    result := FPriority.value;
end;

Procedure TFhirAppointment.SetPriorityST(value : String);
begin
  if value <> '' then
  begin
    if FPriority = nil then
      FPriority := TFhirUnsignedInt.create;
    FPriority.value := value
  end
  else if FPriority <> nil then
    FPriority.value := '';
end;

Procedure TFhirAppointment.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirAppointment.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirAppointment.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Function TFhirAppointment.GetSupportingInformationList : TFhirReferenceList{TFhirReference};
begin
  if FSupportingInformationList = nil then
    FSupportingInformationList := TFhirReferenceList{TFhirReference}.Create;
  result := FSupportingInformationList;
end;

Function TFhirAppointment.GetHasSupportingInformationList : boolean;
begin
  result := (FSupportingInformationList <> nil) and (FSupportingInformationList.count > 0);
end;

Procedure TFhirAppointment.SetStart(value : TFhirInstant);
begin
  FStart.free;
  FStart := value;
end;

Function TFhirAppointment.GetStartST : TFslDateTime;
begin
  if FStart = nil then
    result := TFslDateTime.makeNull
  else
    result := FStart.value;
end;

Procedure TFhirAppointment.SetStartST(value : TFslDateTime);
begin
  if FStart = nil then
    FStart := TFhirInstant.create;
  FStart.value := value
end;

Procedure TFhirAppointment.SetEnd_(value : TFhirInstant);
begin
  FEnd_.free;
  FEnd_ := value;
end;

Function TFhirAppointment.GetEnd_ST : TFslDateTime;
begin
  if FEnd_ = nil then
    result := TFslDateTime.makeNull
  else
    result := FEnd_.value;
end;

Procedure TFhirAppointment.SetEnd_ST(value : TFslDateTime);
begin
  if FEnd_ = nil then
    FEnd_ := TFhirInstant.create;
  FEnd_.value := value
end;

Procedure TFhirAppointment.SetMinutesDuration(value : TFhirPositiveInt);
begin
  FMinutesDuration.free;
  FMinutesDuration := value;
end;

Function TFhirAppointment.GetMinutesDurationST : String;
begin
  if FMinutesDuration = nil then
    result := ''
  else
    result := FMinutesDuration.value;
end;

Procedure TFhirAppointment.SetMinutesDurationST(value : String);
begin
  if value <> '' then
  begin
    if FMinutesDuration = nil then
      FMinutesDuration := TFhirPositiveInt.create;
    FMinutesDuration.value := value
  end
  else if FMinutesDuration <> nil then
    FMinutesDuration.value := '';
end;

Function TFhirAppointment.GetSlotList : TFhirReferenceList{TFhirSlot};
begin
  if FSlotList = nil then
    FSlotList := TFhirReferenceList{TFhirSlot}.Create;
  result := FSlotList;
end;

Function TFhirAppointment.GetHasSlotList : boolean;
begin
  result := (FSlotList <> nil) and (FSlotList.count > 0);
end;

Procedure TFhirAppointment.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

Function TFhirAppointment.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

Procedure TFhirAppointment.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

Procedure TFhirAppointment.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value;
end;

Function TFhirAppointment.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

Procedure TFhirAppointment.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

Function TFhirAppointment.GetIncomingReferralList : TFhirReferenceList{TFhirReferralRequest};
begin
  if FIncomingReferralList = nil then
    FIncomingReferralList := TFhirReferenceList{TFhirReferralRequest}.Create;
  result := FIncomingReferralList;
end;

Function TFhirAppointment.GetHasIncomingReferralList : boolean;
begin
  result := (FIncomingReferralList <> nil) and (FIncomingReferralList.count > 0);
end;

Function TFhirAppointment.GetParticipantList : TFhirAppointmentParticipantList;
begin
  if FParticipantList = nil then
    FParticipantList := TFhirAppointmentParticipantList.Create;
  result := FParticipantList;
end;

Function TFhirAppointment.GetHasParticipantList : boolean;
begin
  result := (FParticipantList <> nil) and (FParticipantList.count > 0);
end;

Function TFhirAppointment.GetRequestedPeriodList : TFhirPeriodList;
begin
  if FRequestedPeriodList = nil then
    FRequestedPeriodList := TFhirPeriodList.Create;
  result := FRequestedPeriodList;
end;

Function TFhirAppointment.GetHasRequestedPeriodList : boolean;
begin
  result := (FRequestedPeriodList <> nil) and (FRequestedPeriodList.count > 0);
end;

function TFhirAppointment.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FServiceCategory.sizeInBytes);
  inc(result, FserviceTypeList.sizeInBytes);
  inc(result, FspecialtyList.sizeInBytes);
  inc(result, FAppointmentType.sizeInBytes);
  inc(result, FreasonList.sizeInBytes);
  inc(result, FindicationList.sizeInBytes);
  inc(result, FPriority.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FsupportingInformationList.sizeInBytes);
  inc(result, FStart.sizeInBytes);
  inc(result, FEnd_.sizeInBytes);
  inc(result, FMinutesDuration.sizeInBytes);
  inc(result, FslotList.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FComment.sizeInBytes);
  inc(result, FincomingReferralList.sizeInBytes);
  inc(result, FparticipantList.sizeInBytes);
  inc(result, FrequestedPeriodList.sizeInBytes);
end;

{ TFhirAppointmentListEnumerator }

Constructor TFhirAppointmentListEnumerator.Create(list : TFhirAppointmentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAppointmentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAppointmentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAppointmentListEnumerator.GetCurrent : TFhirAppointment;
begin
  Result := FList[FIndex];
end;

function TFhirAppointmentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAppointmentList }
procedure TFhirAppointmentList.AddItem(value: TFhirAppointment);
begin
  assert(value.ClassName = 'TFhirAppointment', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAppointment');
  add(value);
end;

function TFhirAppointmentList.Append: TFhirAppointment;
begin
  result := TFhirAppointment.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAppointmentList.ClearItems;
begin
  Clear;
end;

function TFhirAppointmentList.GetEnumerator : TFhirAppointmentListEnumerator;
begin
  result := TFhirAppointmentListEnumerator.Create(self.link);
end;

function TFhirAppointmentList.Clone: TFhirAppointmentList;
begin
  result := TFhirAppointmentList(inherited Clone);
end;

function TFhirAppointmentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAppointmentList.GetItemN(index: Integer): TFhirAppointment;
begin
  result := TFhirAppointment(ObjectByIndex[index]);
end;

function TFhirAppointmentList.ItemClass: TFslObjectClass;
begin
  result := TFhirAppointment;
end;
function TFhirAppointmentList.IndexOf(value: TFhirAppointment): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAppointmentList.Insert(index: Integer): TFhirAppointment;
begin
  result := TFhirAppointment.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAppointmentList.InsertItem(index: Integer; value: TFhirAppointment);
begin
  assert(value is TFhirAppointment);
  Inherited Insert(index, value);
end;

function TFhirAppointmentList.Item(index: Integer): TFhirAppointment;
begin
  result := TFhirAppointment(ObjectByIndex[index]);
end;

function TFhirAppointmentList.Link: TFhirAppointmentList;
begin
  result := TFhirAppointmentList(inherited Link);
end;

procedure TFhirAppointmentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAppointmentList.SetItemByIndex(index: Integer; value: TFhirAppointment);
begin
  assert(value is TFhirAppointment);
  FhirAppointments[index] := value;
end;

procedure TFhirAppointmentList.SetItemN(index: Integer; value: TFhirAppointment);
begin
  assert(value is TFhirAppointment);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_APPOINTMENT}

{$IFDEF FHIR_APPOINTMENTRESPONSE}

{ TFhirAppointmentResponse }

constructor TFhirAppointmentResponse.Create;
begin
  inherited;
end;

destructor TFhirAppointmentResponse.Destroy;
begin
  FIdentifierList.Free;
  FAppointment.free;
  FStart.free;
  FEnd_.free;
  FParticipantTypeList.Free;
  FActor.free;
  FParticipantStatus.free;
  FComment.free;
  inherited;
end;

function TFhirAppointmentResponse.GetResourceType : TFhirResourceType;
begin
  result := frtAppointmentResponse;
end;

procedure TFhirAppointmentResponse.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirAppointmentResponse(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirAppointmentResponse(oSource).FIdentifierList);
  end;
  appointment := TFhirAppointmentResponse(oSource).appointment.Clone;
  startElement := TFhirAppointmentResponse(oSource).startElement.Clone;
  end_Element := TFhirAppointmentResponse(oSource).end_Element.Clone;
  if (TFhirAppointmentResponse(oSource).FParticipantTypeList = nil) then
  begin
    FParticipantTypeList.free;
    FParticipantTypeList := nil;
  end
  else
  begin
    if FParticipantTypeList = nil then
      FParticipantTypeList := TFhirCodeableConceptList.Create;
    FParticipantTypeList.Assign(TFhirAppointmentResponse(oSource).FParticipantTypeList);
  end;
  actor := TFhirAppointmentResponse(oSource).actor.Clone;
  FParticipantStatus := TFhirAppointmentResponse(oSource).FParticipantStatus.Link;
  commentElement := TFhirAppointmentResponse(oSource).commentElement.Clone;
end;

procedure TFhirAppointmentResponse.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'appointment') Then
     list.add(self.link, 'appointment', FAppointment.Link);
  if (child_name = 'start') Then
     list.add(self.link, 'start', FStart.Link);
  if (child_name = 'end') Then
     list.add(self.link, 'end', FEnd_.Link);
  if (child_name = 'participantType') Then
    list.addAll(self, 'participantType', FParticipantTypeList);
  if (child_name = 'actor') Then
     list.add(self.link, 'actor', FActor.Link);
  if (child_name = 'participantStatus') Then
     list.add(self.link, 'participantStatus', FParticipantStatus.Link);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
end;

procedure TFhirAppointmentResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'appointment', 'Reference(Appointment)', false, TFhirReference{TFhirAppointment}, FAppointment.Link));{2}
  oList.add(TFHIRProperty.create(self, 'start', 'instant', false, TFhirInstant, FStart.Link));{2}
  oList.add(TFHIRProperty.create(self, 'end', 'instant', false, TFhirInstant, FEnd_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'participantType', 'CodeableConcept', true, TFhirCodeableConcept, FParticipantTypeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'actor', 'Reference(Patient|Practitioner|RelatedPerson|Device|HealthcareService|Location)', false, TFhirReference{Resource}, FActor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'participantStatus', 'code', false, TFHIREnum, FParticipantStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'comment', 'string', false, TFhirString, FComment.Link));{2}
end;

function TFhirAppointmentResponse.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'appointment') then
  begin
    Appointment := propValue as TFhirReference{TFhirAppointment}{4b};
    result := propValue;
  end
  else if (propName = 'start') then
  begin
    StartElement := asInstant(propValue){5a};
    result := propValue;
  end
  else if (propName = 'end') then
  begin
    End_Element := asInstant(propValue){5a};
    result := propValue;
  end
  else if (propName = 'participantType') then
  begin
    ParticipantTypeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    Actor := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'participantStatus') then
  begin
    ParticipantStatusElement := asEnum(SYSTEMS_TFhirParticipationstatusEnum, CODES_TFhirParticipationstatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'comment') then
  begin
    CommentElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirAppointmentResponse.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'participantType') then ParticipantTypeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirAppointmentResponse.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'appointment') then result := TFhirReference{TFhirAppointment}.create(){4b}
  else if (propName = 'start') then result := TFhirInstant.create() {5b}
  else if (propName = 'end') then result := TFhirInstant.create() {5b}
  else if (propName = 'participantType') then result := ParticipantTypeList.new(){2}
  else if (propName = 'actor') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'comment') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirAppointmentResponse.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'appointment') then result := 'Reference'
  else if (propName = 'start') then result := 'instant'
  else if (propName = 'end') then result := 'instant'
  else if (propName = 'participantType') then result := 'CodeableConcept'
  else if (propName = 'actor') then result := 'Reference'
  else if (propName = 'participantStatus') then result := 'code'
  else if (propName = 'comment') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAppointmentResponse.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'appointment') then AppointmentElement := nil
  else if (propName = 'start') then StartElement := nil
  else if (propName = 'end') then End_Element := nil
  else if (propName = 'participantType') then deletePropertyValue('participantType', ParticipantTypeList, value) {2}
  else if (propName = 'actor') then ActorElement := nil
  else if (propName = 'participantStatus') then ParticipantStatusElement := nil
  else if (propName = 'comment') then CommentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAppointmentResponse.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'appointment') then AppointmentElement := new as TFhirReference{TFhirAppointment}{4}
  else if (propName = 'start') then StartElement := asInstant(new){5b}
  else if (propName = 'end') then End_Element := asInstant(new){5b}
  else if (propName = 'participantType') then replacePropertyValue('participantType', ParticipantTypeList, existing, new) {2}
  else if (propName = 'actor') then ActorElement := new as TFhirReference{Resource}{4}
  else if (propName = 'participantStatus') then ParticipantStatusElement := asEnum(SYSTEMS_TFhirParticipationstatusEnum, CODES_TFhirParticipationstatusEnum, new){4}
  else if (propName = 'comment') then CommentElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAppointmentResponse.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'participantType') then ParticipantTypeList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAppointmentResponse.fhirType : string;
begin
  result := 'AppointmentResponse';
end;

function TFhirAppointmentResponse.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FAppointment) and isEmptyProp(FStart) and isEmptyProp(FEnd_) and isEmptyProp(FparticipantTypeList) and isEmptyProp(FActor) and isEmptyProp(FParticipantStatus) and isEmptyProp(FComment);
end;

function TFhirAppointmentResponse.equals(other : TObject) : boolean;
var
  o : TFhirAppointmentResponse;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAppointmentResponse)) then
    result := false
  else
  begin
    o := TFhirAppointmentResponse(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(appointmentElement, o.appointmentElement, true) and
      compareDeep(startElement, o.startElement, true) and compareDeep(end_Element, o.end_Element, true) and
      compareDeep(participantTypeList, o.participantTypeList, true) and compareDeep(actorElement, o.actorElement, true) and
      compareDeep(participantStatusElement, o.participantStatusElement, true) and compareDeep(commentElement, o.commentElement, true);
  end;
end;

function TFhirAppointmentResponse.Link : TFhirAppointmentResponse;
begin
  result := TFhirAppointmentResponse(inherited Link);
end;

function TFhirAppointmentResponse.Clone : TFhirAppointmentResponse;
begin
  result := TFhirAppointmentResponse(inherited Clone);
end;

procedure TFhirAppointmentResponse.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('appointment');
  fields.add('start');
  fields.add('end');
  fields.add('participantType');
  fields.add('actor');
  fields.add('participantStatus');
  fields.add('comment');
end;

{ TFhirAppointmentResponse }

Function TFhirAppointmentResponse.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirAppointmentResponse.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirAppointmentResponse.SetAppointment(value : TFhirReference{TFhirAppointment});
begin
  FAppointment.free;
  FAppointment := value;
end;

Procedure TFhirAppointmentResponse.SetStart(value : TFhirInstant);
begin
  FStart.free;
  FStart := value;
end;

Function TFhirAppointmentResponse.GetStartST : TFslDateTime;
begin
  if FStart = nil then
    result := TFslDateTime.makeNull
  else
    result := FStart.value;
end;

Procedure TFhirAppointmentResponse.SetStartST(value : TFslDateTime);
begin
  if FStart = nil then
    FStart := TFhirInstant.create;
  FStart.value := value
end;

Procedure TFhirAppointmentResponse.SetEnd_(value : TFhirInstant);
begin
  FEnd_.free;
  FEnd_ := value;
end;

Function TFhirAppointmentResponse.GetEnd_ST : TFslDateTime;
begin
  if FEnd_ = nil then
    result := TFslDateTime.makeNull
  else
    result := FEnd_.value;
end;

Procedure TFhirAppointmentResponse.SetEnd_ST(value : TFslDateTime);
begin
  if FEnd_ = nil then
    FEnd_ := TFhirInstant.create;
  FEnd_.value := value
end;

Function TFhirAppointmentResponse.GetParticipantTypeList : TFhirCodeableConceptList;
begin
  if FParticipantTypeList = nil then
    FParticipantTypeList := TFhirCodeableConceptList.Create;
  result := FParticipantTypeList;
end;

Function TFhirAppointmentResponse.GetHasParticipantTypeList : boolean;
begin
  result := (FParticipantTypeList <> nil) and (FParticipantTypeList.count > 0);
end;

Procedure TFhirAppointmentResponse.SetActor(value : TFhirReference{Resource});
begin
  FActor.free;
  FActor := value;
end;

Procedure TFhirAppointmentResponse.SetParticipantStatus(value : TFhirEnum);
begin
  FParticipantStatus.free;
  FParticipantStatus := value;
end;

Function TFhirAppointmentResponse.GetParticipantStatusST : TFhirParticipationstatusEnum;
begin
  if FParticipantStatus = nil then
    result := TFhirParticipationstatusEnum(0)
  else
    result := TFhirParticipationstatusEnum(StringArrayIndexOfSensitive(CODES_TFhirParticipationstatusEnum, FParticipantStatus.value));
end;

Procedure TFhirAppointmentResponse.SetParticipantStatusST(value : TFhirParticipationstatusEnum);
begin
  if ord(value) = 0 then
    ParticipantStatusElement := nil
  else
    ParticipantStatusElement := TFhirEnum.create(SYSTEMS_TFhirParticipationstatusEnum[value], CODES_TFhirParticipationstatusEnum[value]);
end;

Procedure TFhirAppointmentResponse.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value;
end;

Function TFhirAppointmentResponse.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

Procedure TFhirAppointmentResponse.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

function TFhirAppointmentResponse.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FAppointment.sizeInBytes);
  inc(result, FStart.sizeInBytes);
  inc(result, FEnd_.sizeInBytes);
  inc(result, FparticipantTypeList.sizeInBytes);
  inc(result, FActor.sizeInBytes);
  inc(result, FParticipantStatus.sizeInBytes);
  inc(result, FComment.sizeInBytes);
end;

{ TFhirAppointmentResponseListEnumerator }

Constructor TFhirAppointmentResponseListEnumerator.Create(list : TFhirAppointmentResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAppointmentResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAppointmentResponseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAppointmentResponseListEnumerator.GetCurrent : TFhirAppointmentResponse;
begin
  Result := FList[FIndex];
end;

function TFhirAppointmentResponseListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirAppointmentResponseList }
procedure TFhirAppointmentResponseList.AddItem(value: TFhirAppointmentResponse);
begin
  assert(value.ClassName = 'TFhirAppointmentResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAppointmentResponse');
  add(value);
end;

function TFhirAppointmentResponseList.Append: TFhirAppointmentResponse;
begin
  result := TFhirAppointmentResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAppointmentResponseList.ClearItems;
begin
  Clear;
end;

function TFhirAppointmentResponseList.GetEnumerator : TFhirAppointmentResponseListEnumerator;
begin
  result := TFhirAppointmentResponseListEnumerator.Create(self.link);
end;

function TFhirAppointmentResponseList.Clone: TFhirAppointmentResponseList;
begin
  result := TFhirAppointmentResponseList(inherited Clone);
end;

function TFhirAppointmentResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAppointmentResponseList.GetItemN(index: Integer): TFhirAppointmentResponse;
begin
  result := TFhirAppointmentResponse(ObjectByIndex[index]);
end;

function TFhirAppointmentResponseList.ItemClass: TFslObjectClass;
begin
  result := TFhirAppointmentResponse;
end;
function TFhirAppointmentResponseList.IndexOf(value: TFhirAppointmentResponse): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAppointmentResponseList.Insert(index: Integer): TFhirAppointmentResponse;
begin
  result := TFhirAppointmentResponse.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAppointmentResponseList.InsertItem(index: Integer; value: TFhirAppointmentResponse);
begin
  assert(value is TFhirAppointmentResponse);
  Inherited Insert(index, value);
end;

function TFhirAppointmentResponseList.Item(index: Integer): TFhirAppointmentResponse;
begin
  result := TFhirAppointmentResponse(ObjectByIndex[index]);
end;

function TFhirAppointmentResponseList.Link: TFhirAppointmentResponseList;
begin
  result := TFhirAppointmentResponseList(inherited Link);
end;

procedure TFhirAppointmentResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAppointmentResponseList.SetItemByIndex(index: Integer; value: TFhirAppointmentResponse);
begin
  assert(value is TFhirAppointmentResponse);
  FhirAppointmentResponses[index] := value;
end;

procedure TFhirAppointmentResponseList.SetItemN(index: Integer; value: TFhirAppointmentResponse);
begin
  assert(value is TFhirAppointmentResponse);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_APPOINTMENTRESPONSE}

{$IFDEF FHIR_BASIC}

{ TFhirBasic }

constructor TFhirBasic.Create;
begin
  inherited;
end;

destructor TFhirBasic.Destroy;
begin
  FIdentifierList.Free;
  FCode.free;
  FSubject.free;
  FCreated.free;
  FAuthor.free;
  inherited;
end;

function TFhirBasic.GetResourceType : TFhirResourceType;
begin
  result := frtBasic;
end;

procedure TFhirBasic.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirBasic(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirBasic(oSource).FIdentifierList);
  end;
  code := TFhirBasic(oSource).code.Clone;
  subject := TFhirBasic(oSource).subject.Clone;
  createdElement := TFhirBasic(oSource).createdElement.Clone;
  author := TFhirBasic(oSource).author.Clone;
end;

procedure TFhirBasic.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
end;

procedure TFhirBasic.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Any)', false, TFhirReference{TFhirReference}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'created', 'date', false, TFhirDate, FCreated.Link));{2}
  oList.add(TFHIRProperty.create(self, 'author', 'Reference(Practitioner|Patient|RelatedPerson)', false, TFhirReference{Resource}, FAuthor.Link));{2}
end;

function TFhirBasic.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirBasic.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else inherited;
end;

function TFhirBasic.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subject') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'created') then result := TFhirDate.create() {5b}
  else if (propName = 'author') then result := TFhirReference{Resource}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirBasic.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'created') then result := 'date'
  else if (propName = 'author') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBasic.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'author') then AuthorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBasic.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'created') then CreatedElement := asDate(new){5b}
  else if (propName = 'author') then AuthorElement := new as TFhirReference{Resource}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBasic.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirBasic.fhirType : string;
begin
  result := 'Basic';
end;

function TFhirBasic.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FCode) and isEmptyProp(FSubject) and isEmptyProp(FCreated) and isEmptyProp(FAuthor);
end;

function TFhirBasic.equals(other : TObject) : boolean;
var
  o : TFhirBasic;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBasic)) then
    result := false
  else
  begin
    o := TFhirBasic(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(codeElement, o.codeElement, true) and
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(createdElement, o.createdElement, true) and
      compareDeep(authorElement, o.authorElement, true);
  end;
end;

function TFhirBasic.Link : TFhirBasic;
begin
  result := TFhirBasic(inherited Link);
end;

function TFhirBasic.Clone : TFhirBasic;
begin
  result := TFhirBasic(inherited Clone);
end;

procedure TFhirBasic.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('code');
  fields.add('subject');
  fields.add('created');
  fields.add('author');
end;

{ TFhirBasic }

Function TFhirBasic.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirBasic.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirBasic.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirBasic.SetSubject(value : TFhirReference{TFhirReference});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirBasic.SetCreated(value : TFhirDate);
begin
  FCreated.free;
  FCreated := value;
end;

Function TFhirBasic.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

Procedure TFhirBasic.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDate.create;
  FCreated.value := value
end;

Procedure TFhirBasic.SetAuthor(value : TFhirReference{Resource});
begin
  FAuthor.free;
  FAuthor := value;
end;

function TFhirBasic.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FAuthor.sizeInBytes);
end;

{ TFhirBasicListEnumerator }

Constructor TFhirBasicListEnumerator.Create(list : TFhirBasicList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBasicListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBasicListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBasicListEnumerator.GetCurrent : TFhirBasic;
begin
  Result := FList[FIndex];
end;

function TFhirBasicListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirBasicList }
procedure TFhirBasicList.AddItem(value: TFhirBasic);
begin
  assert(value.ClassName = 'TFhirBasic', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBasic');
  add(value);
end;

function TFhirBasicList.Append: TFhirBasic;
begin
  result := TFhirBasic.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBasicList.ClearItems;
begin
  Clear;
end;

function TFhirBasicList.GetEnumerator : TFhirBasicListEnumerator;
begin
  result := TFhirBasicListEnumerator.Create(self.link);
end;

function TFhirBasicList.Clone: TFhirBasicList;
begin
  result := TFhirBasicList(inherited Clone);
end;

function TFhirBasicList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBasicList.GetItemN(index: Integer): TFhirBasic;
begin
  result := TFhirBasic(ObjectByIndex[index]);
end;

function TFhirBasicList.ItemClass: TFslObjectClass;
begin
  result := TFhirBasic;
end;
function TFhirBasicList.IndexOf(value: TFhirBasic): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBasicList.Insert(index: Integer): TFhirBasic;
begin
  result := TFhirBasic.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBasicList.InsertItem(index: Integer; value: TFhirBasic);
begin
  assert(value is TFhirBasic);
  Inherited Insert(index, value);
end;

function TFhirBasicList.Item(index: Integer): TFhirBasic;
begin
  result := TFhirBasic(ObjectByIndex[index]);
end;

function TFhirBasicList.Link: TFhirBasicList;
begin
  result := TFhirBasicList(inherited Link);
end;

procedure TFhirBasicList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBasicList.SetItemByIndex(index: Integer; value: TFhirBasic);
begin
  assert(value is TFhirBasic);
  FhirBasics[index] := value;
end;

procedure TFhirBasicList.SetItemN(index: Integer; value: TFhirBasic);
begin
  assert(value is TFhirBasic);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_BASIC}

{$IFDEF FHIR_BODYSITE}

{ TFhirBodySite }

constructor TFhirBodySite.Create;
begin
  inherited;
end;

destructor TFhirBodySite.Destroy;
begin
  FIdentifierList.Free;
  FActive.free;
  FCode.free;
  FQualifierList.Free;
  FDescription.free;
  FImageList.Free;
  FPatient.free;
  inherited;
end;

function TFhirBodySite.GetResourceType : TFhirResourceType;
begin
  result := frtBodySite;
end;

procedure TFhirBodySite.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirBodySite(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirBodySite(oSource).FIdentifierList);
  end;
  activeElement := TFhirBodySite(oSource).activeElement.Clone;
  code := TFhirBodySite(oSource).code.Clone;
  if (TFhirBodySite(oSource).FQualifierList = nil) then
  begin
    FQualifierList.free;
    FQualifierList := nil;
  end
  else
  begin
    if FQualifierList = nil then
      FQualifierList := TFhirCodeableConceptList.Create;
    FQualifierList.Assign(TFhirBodySite(oSource).FQualifierList);
  end;
  descriptionElement := TFhirBodySite(oSource).descriptionElement.Clone;
  if (TFhirBodySite(oSource).FImageList = nil) then
  begin
    FImageList.free;
    FImageList := nil;
  end
  else
  begin
    if FImageList = nil then
      FImageList := TFhirAttachmentList.Create;
    FImageList.Assign(TFhirBodySite(oSource).FImageList);
  end;
  patient := TFhirBodySite(oSource).patient.Clone;
end;

procedure TFhirBodySite.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'qualifier') Then
    list.addAll(self, 'qualifier', FQualifierList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'image') Then
    list.addAll(self, 'image', FImageList);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
end;

procedure TFhirBodySite.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'qualifier', 'CodeableConcept', true, TFhirCodeableConcept, FQualifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'image', 'Attachment', true, TFhirAttachment, FImageList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
end;

function TFhirBodySite.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'qualifier') then
  begin
    QualifierList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'image') then
  begin
    ImageList.add(propValue as TFhirAttachment){2a};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirBodySite.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'qualifier') then QualifierList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'image') then ImageList.insertItem(index, propValue as TFhirAttachment){2a}
  else inherited;
end;

function TFhirBodySite.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'active') then result := TFhirBoolean.create() {5b}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'qualifier') then result := QualifierList.new(){2}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'image') then result := ImageList.new(){2}
  else if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirBodySite.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'qualifier') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'image') then result := 'Attachment'
  else if (propName = 'patient') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBodySite.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'qualifier') then deletePropertyValue('qualifier', QualifierList, value) {2}
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'image') then deletePropertyValue('image', ImageList, value) {2}
  else if (propName = 'patient') then PatientElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBodySite.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'active') then ActiveElement := asBoolean(new){5b}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'qualifier') then replacePropertyValue('qualifier', QualifierList, existing, new) {2}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'image') then replacePropertyValue('image', ImageList, existing, new) {2}
  else if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBodySite.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'qualifier') then QualifierList.move(source, destination){2a}
  else if (propName = 'image') then ImageList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirBodySite.fhirType : string;
begin
  result := 'BodySite';
end;

function TFhirBodySite.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FActive) and isEmptyProp(FCode) and isEmptyProp(FqualifierList) and isEmptyProp(FDescription) and isEmptyProp(FimageList) and isEmptyProp(FPatient);
end;

function TFhirBodySite.equals(other : TObject) : boolean;
var
  o : TFhirBodySite;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBodySite)) then
    result := false
  else
  begin
    o := TFhirBodySite(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(activeElement, o.activeElement, true) and
      compareDeep(codeElement, o.codeElement, true) and compareDeep(qualifierList, o.qualifierList, true) and
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(imageList, o.imageList, true) and
      compareDeep(patientElement, o.patientElement, true);
  end;
end;

function TFhirBodySite.Link : TFhirBodySite;
begin
  result := TFhirBodySite(inherited Link);
end;

function TFhirBodySite.Clone : TFhirBodySite;
begin
  result := TFhirBodySite(inherited Clone);
end;

procedure TFhirBodySite.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('active');
  fields.add('code');
  fields.add('qualifier');
  fields.add('description');
  fields.add('image');
  fields.add('patient');
end;

{ TFhirBodySite }

Function TFhirBodySite.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirBodySite.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirBodySite.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value;
end;

Function TFhirBodySite.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

Procedure TFhirBodySite.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.create;
  FActive.value := value
end;

Procedure TFhirBodySite.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirBodySite.GetQualifierList : TFhirCodeableConceptList;
begin
  if FQualifierList = nil then
    FQualifierList := TFhirCodeableConceptList.Create;
  result := FQualifierList;
end;

Function TFhirBodySite.GetHasQualifierList : boolean;
begin
  result := (FQualifierList <> nil) and (FQualifierList.count > 0);
end;

Procedure TFhirBodySite.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirBodySite.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirBodySite.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Function TFhirBodySite.GetImageList : TFhirAttachmentList;
begin
  if FImageList = nil then
    FImageList := TFhirAttachmentList.Create;
  result := FImageList;
end;

Function TFhirBodySite.GetHasImageList : boolean;
begin
  result := (FImageList <> nil) and (FImageList.count > 0);
end;

Procedure TFhirBodySite.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

function TFhirBodySite.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FActive.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FqualifierList.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FimageList.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
end;

{ TFhirBodySiteListEnumerator }

Constructor TFhirBodySiteListEnumerator.Create(list : TFhirBodySiteList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBodySiteListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBodySiteListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBodySiteListEnumerator.GetCurrent : TFhirBodySite;
begin
  Result := FList[FIndex];
end;

function TFhirBodySiteListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirBodySiteList }
procedure TFhirBodySiteList.AddItem(value: TFhirBodySite);
begin
  assert(value.ClassName = 'TFhirBodySite', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBodySite');
  add(value);
end;

function TFhirBodySiteList.Append: TFhirBodySite;
begin
  result := TFhirBodySite.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBodySiteList.ClearItems;
begin
  Clear;
end;

function TFhirBodySiteList.GetEnumerator : TFhirBodySiteListEnumerator;
begin
  result := TFhirBodySiteListEnumerator.Create(self.link);
end;

function TFhirBodySiteList.Clone: TFhirBodySiteList;
begin
  result := TFhirBodySiteList(inherited Clone);
end;

function TFhirBodySiteList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBodySiteList.GetItemN(index: Integer): TFhirBodySite;
begin
  result := TFhirBodySite(ObjectByIndex[index]);
end;

function TFhirBodySiteList.ItemClass: TFslObjectClass;
begin
  result := TFhirBodySite;
end;
function TFhirBodySiteList.IndexOf(value: TFhirBodySite): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBodySiteList.Insert(index: Integer): TFhirBodySite;
begin
  result := TFhirBodySite.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBodySiteList.InsertItem(index: Integer; value: TFhirBodySite);
begin
  assert(value is TFhirBodySite);
  Inherited Insert(index, value);
end;

function TFhirBodySiteList.Item(index: Integer): TFhirBodySite;
begin
  result := TFhirBodySite(ObjectByIndex[index]);
end;

function TFhirBodySiteList.Link: TFhirBodySiteList;
begin
  result := TFhirBodySiteList(inherited Link);
end;

procedure TFhirBodySiteList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBodySiteList.SetItemByIndex(index: Integer; value: TFhirBodySite);
begin
  assert(value is TFhirBodySite);
  FhirBodySites[index] := value;
end;

procedure TFhirBodySiteList.SetItemN(index: Integer; value: TFhirBodySite);
begin
  assert(value is TFhirBodySite);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_BODYSITE}

{$IFDEF FHIR_CAREPLAN}

{ TFhirCarePlanActivity }

constructor TFhirCarePlanActivity.Create;
begin
  inherited;
end;

destructor TFhirCarePlanActivity.Destroy;
begin
  FOutcomeCodeableConceptList.Free;
  FOutcomeReferenceList.Free;
  FProgressList.Free;
  FReference.free;
  FDetail.free;
  inherited;
end;

procedure TFhirCarePlanActivity.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCarePlanActivity(oSource).FOutcomeCodeableConceptList = nil) then
  begin
    FOutcomeCodeableConceptList.free;
    FOutcomeCodeableConceptList := nil;
  end
  else
  begin
    if FOutcomeCodeableConceptList = nil then
      FOutcomeCodeableConceptList := TFhirCodeableConceptList.Create;
    FOutcomeCodeableConceptList.Assign(TFhirCarePlanActivity(oSource).FOutcomeCodeableConceptList);
  end;
  if (TFhirCarePlanActivity(oSource).FOutcomeReferenceList = nil) then
  begin
    FOutcomeReferenceList.free;
    FOutcomeReferenceList := nil;
  end
  else
  begin
    if FOutcomeReferenceList = nil then
      FOutcomeReferenceList := TFhirReferenceList{TFhirReference}.Create;
    FOutcomeReferenceList.Assign(TFhirCarePlanActivity(oSource).FOutcomeReferenceList);
  end;
  if (TFhirCarePlanActivity(oSource).FProgressList = nil) then
  begin
    FProgressList.free;
    FProgressList := nil;
  end
  else
  begin
    if FProgressList = nil then
      FProgressList := TFhirAnnotationList.Create;
    FProgressList.Assign(TFhirCarePlanActivity(oSource).FProgressList);
  end;
  reference := TFhirCarePlanActivity(oSource).reference.Clone;
  detail := TFhirCarePlanActivity(oSource).detail.Clone;
end;

procedure TFhirCarePlanActivity.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'outcomeCodeableConcept') Then
    list.addAll(self, 'outcomeCodeableConcept', FOutcomeCodeableConceptList);
  if (child_name = 'outcomeReference') Then
    list.addAll(self, 'outcomeReference', FOutcomeReferenceList);
  if (child_name = 'progress') Then
    list.addAll(self, 'progress', FProgressList);
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
  if (child_name = 'detail') Then
     list.add(self.link, 'detail', FDetail.Link);
end;

procedure TFhirCarePlanActivity.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'outcomeCodeableConcept', 'CodeableConcept', true, TFhirCodeableConcept, FOutcomeCodeableConceptList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'outcomeReference', 'Reference(Any)', true, TFhirReference{TFhirReference}, FOutcomeReferenceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'progress', 'Annotation', true, TFhirAnnotation, FProgressList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reference', 'Reference(Appointment|CommunicationRequest|DeviceRequest|MedicationRequest|NutritionOrder|Task|ProcedureRequest|ReferralRequest|VisionPrescription|RequestGroup)', false, TFhirReference{Resource}, FReference.Link));{2}
  oList.add(TFHIRProperty.create(self, 'detail', '', false, TFhirCarePlanActivityDetail, FDetail.Link));{2}
end;

function TFhirCarePlanActivity.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'outcomeCodeableConcept') then
  begin
    OutcomeCodeableConceptList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'outcomeReference') then
  begin
    OutcomeReferenceList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'progress') then
  begin
    ProgressList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else if (propName = 'reference') then
  begin
    Reference := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    Detail := propValue as TFhirCarePlanActivityDetail{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCarePlanActivity.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'outcomeCodeableConcept') then OutcomeCodeableConceptList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'outcomeReference') then OutcomeReferenceList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'progress') then ProgressList.insertItem(index, propValue as TFhirAnnotation){2a}
  else inherited;
end;

function TFhirCarePlanActivity.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'outcomeCodeableConcept') then result := OutcomeCodeableConceptList.new(){2}
  else if (propName = 'outcomeReference') then result := OutcomeReferenceList.new(){2}
  else if (propName = 'progress') then result := ProgressList.new(){2}
  else if (propName = 'reference') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'detail') then result := TFhirCarePlanActivityDetail.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCarePlanActivity.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'outcomeCodeableConcept') then result := 'CodeableConcept'
  else if (propName = 'outcomeReference') then result := 'Reference'
  else if (propName = 'progress') then result := 'Annotation'
  else if (propName = 'reference') then result := 'Reference'
  else if (propName = 'detail') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCarePlanActivity.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'outcomeCodeableConcept') then deletePropertyValue('outcomeCodeableConcept', OutcomeCodeableConceptList, value) {2}
  else if (propName = 'outcomeReference') then deletePropertyValue('outcomeReference', OutcomeReferenceList, value) {2}
  else if (propName = 'progress') then deletePropertyValue('progress', ProgressList, value) {2}
  else if (propName = 'reference') then ReferenceElement := nil
  else if (propName = 'detail') then DetailElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCarePlanActivity.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'outcomeCodeableConcept') then replacePropertyValue('outcomeCodeableConcept', OutcomeCodeableConceptList, existing, new) {2}
  else if (propName = 'outcomeReference') then replacePropertyValue('outcomeReference', OutcomeReferenceList, existing, new) {2}
  else if (propName = 'progress') then replacePropertyValue('progress', ProgressList, existing, new) {2}
  else if (propName = 'reference') then ReferenceElement := new as TFhirReference{Resource}{4}
  else if (propName = 'detail') then DetailElement := new as TFhirCarePlanActivityDetail{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCarePlanActivity.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'outcomeCodeableConcept') then OutcomeCodeableConceptList.move(source, destination){2a}
  else if (propName = 'outcomeReference') then OutcomeReferenceList.move(source, destination){2a}
  else if (propName = 'progress') then ProgressList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCarePlanActivity.fhirType : string;
begin
  result := 'activity';
end;

function TFhirCarePlanActivity.Link : TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity(inherited Link);
end;

function TFhirCarePlanActivity.Clone : TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity(inherited Clone);
end;

function TFhirCarePlanActivity.equals(other : TObject) : boolean;
var
  o : TFhirCarePlanActivity;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCarePlanActivity)) then
    result := false
  else
  begin
    o := TFhirCarePlanActivity(other);
    result := compareDeep(outcomeCodeableConceptList, o.outcomeCodeableConceptList, true) and
      compareDeep(outcomeReferenceList, o.outcomeReferenceList, true) and compareDeep(progressList, o.progressList, true) and
      compareDeep(referenceElement, o.referenceElement, true) and compareDeep(detailElement, o.detailElement, true);
  end;
end;

function TFhirCarePlanActivity.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FoutcomeCodeableConceptList) and isEmptyProp(FoutcomeReferenceList) and isEmptyProp(FprogressList) and isEmptyProp(FReference) and isEmptyProp(FDetail);
end;

procedure TFhirCarePlanActivity.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('outcomeCodeableConcept');
  fields.add('outcomeReference');
  fields.add('progress');
  fields.add('reference');
  fields.add('detail');
end;

{ TFhirCarePlanActivity }

Function TFhirCarePlanActivity.GetOutcomeCodeableConceptList : TFhirCodeableConceptList;
begin
  if FOutcomeCodeableConceptList = nil then
    FOutcomeCodeableConceptList := TFhirCodeableConceptList.Create;
  result := FOutcomeCodeableConceptList;
end;

Function TFhirCarePlanActivity.GetHasOutcomeCodeableConceptList : boolean;
begin
  result := (FOutcomeCodeableConceptList <> nil) and (FOutcomeCodeableConceptList.count > 0);
end;

Function TFhirCarePlanActivity.GetOutcomeReferenceList : TFhirReferenceList{TFhirReference};
begin
  if FOutcomeReferenceList = nil then
    FOutcomeReferenceList := TFhirReferenceList{TFhirReference}.Create;
  result := FOutcomeReferenceList;
end;

Function TFhirCarePlanActivity.GetHasOutcomeReferenceList : boolean;
begin
  result := (FOutcomeReferenceList <> nil) and (FOutcomeReferenceList.count > 0);
end;

Function TFhirCarePlanActivity.GetProgressList : TFhirAnnotationList;
begin
  if FProgressList = nil then
    FProgressList := TFhirAnnotationList.Create;
  result := FProgressList;
end;

Function TFhirCarePlanActivity.GetHasProgressList : boolean;
begin
  result := (FProgressList <> nil) and (FProgressList.count > 0);
end;

Procedure TFhirCarePlanActivity.SetReference(value : TFhirReference{Resource});
begin
  FReference.free;
  FReference := value;
end;

Procedure TFhirCarePlanActivity.SetDetail(value : TFhirCarePlanActivityDetail);
begin
  FDetail.free;
  FDetail := value;
end;

function TFhirCarePlanActivity.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FoutcomeCodeableConceptList.sizeInBytes);
  inc(result, FoutcomeReferenceList.sizeInBytes);
  inc(result, FprogressList.sizeInBytes);
  inc(result, FReference.sizeInBytes);
  inc(result, FDetail.sizeInBytes);
end;

{ TFhirCarePlanActivityListEnumerator }

Constructor TFhirCarePlanActivityListEnumerator.Create(list : TFhirCarePlanActivityList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCarePlanActivityListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCarePlanActivityListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCarePlanActivityListEnumerator.GetCurrent : TFhirCarePlanActivity;
begin
  Result := FList[FIndex];
end;

function TFhirCarePlanActivityListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCarePlanActivityList }
procedure TFhirCarePlanActivityList.AddItem(value: TFhirCarePlanActivity);
begin
  assert(value.ClassName = 'TFhirCarePlanActivity', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCarePlanActivity');
  add(value);
end;

function TFhirCarePlanActivityList.Append: TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCarePlanActivityList.ClearItems;
begin
  Clear;
end;

function TFhirCarePlanActivityList.GetEnumerator : TFhirCarePlanActivityListEnumerator;
begin
  result := TFhirCarePlanActivityListEnumerator.Create(self.link);
end;

function TFhirCarePlanActivityList.Clone: TFhirCarePlanActivityList;
begin
  result := TFhirCarePlanActivityList(inherited Clone);
end;

function TFhirCarePlanActivityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCarePlanActivityList.GetItemN(index: Integer): TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity(ObjectByIndex[index]);
end;

function TFhirCarePlanActivityList.ItemClass: TFslObjectClass;
begin
  result := TFhirCarePlanActivity;
end;
function TFhirCarePlanActivityList.IndexOf(value: TFhirCarePlanActivity): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCarePlanActivityList.Insert(index: Integer): TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCarePlanActivityList.InsertItem(index: Integer; value: TFhirCarePlanActivity);
begin
  assert(value is TFhirCarePlanActivity);
  Inherited Insert(index, value);
end;

function TFhirCarePlanActivityList.Item(index: Integer): TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity(ObjectByIndex[index]);
end;

function TFhirCarePlanActivityList.Link: TFhirCarePlanActivityList;
begin
  result := TFhirCarePlanActivityList(inherited Link);
end;

procedure TFhirCarePlanActivityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCarePlanActivityList.SetItemByIndex(index: Integer; value: TFhirCarePlanActivity);
begin
  assert(value is TFhirCarePlanActivity);
  FhirCarePlanActivities[index] := value;
end;

procedure TFhirCarePlanActivityList.SetItemN(index: Integer; value: TFhirCarePlanActivity);
begin
  assert(value is TFhirCarePlanActivity);
  ObjectByIndex[index] := value;
end;

{ TFhirCarePlanActivityDetail }

constructor TFhirCarePlanActivityDetail.Create;
begin
  inherited;
end;

destructor TFhirCarePlanActivityDetail.Destroy;
begin
  FCategory.free;
  FDefinition.free;
  FCode.free;
  FReasonCodeList.Free;
  FReasonReferenceList.Free;
  FGoalList.Free;
  FStatus.free;
  FStatusReason.free;
  FProhibited.free;
  FScheduled.free;
  FLocation.free;
  FPerformerList.Free;
  FProduct.free;
  FDailyAmount.free;
  FQuantity.free;
  FDescription.free;
  inherited;
end;

procedure TFhirCarePlanActivityDetail.Assign(oSource : TFslObject);
begin
  inherited;
  category := TFhirCarePlanActivityDetail(oSource).category.Clone;
  definition := TFhirCarePlanActivityDetail(oSource).definition.Clone;
  code := TFhirCarePlanActivityDetail(oSource).code.Clone;
  if (TFhirCarePlanActivityDetail(oSource).FReasonCodeList = nil) then
  begin
    FReasonCodeList.free;
    FReasonCodeList := nil;
  end
  else
  begin
    if FReasonCodeList = nil then
      FReasonCodeList := TFhirCodeableConceptList.Create;
    FReasonCodeList.Assign(TFhirCarePlanActivityDetail(oSource).FReasonCodeList);
  end;
  if (TFhirCarePlanActivityDetail(oSource).FReasonReferenceList = nil) then
  begin
    FReasonReferenceList.free;
    FReasonReferenceList := nil;
  end
  else
  begin
    if FReasonReferenceList = nil then
      FReasonReferenceList := TFhirReferenceList{TFhirCondition}.Create;
    FReasonReferenceList.Assign(TFhirCarePlanActivityDetail(oSource).FReasonReferenceList);
  end;
  if (TFhirCarePlanActivityDetail(oSource).FGoalList = nil) then
  begin
    FGoalList.free;
    FGoalList := nil;
  end
  else
  begin
    if FGoalList = nil then
      FGoalList := TFhirReferenceList{TFhirGoal}.Create;
    FGoalList.Assign(TFhirCarePlanActivityDetail(oSource).FGoalList);
  end;
  FStatus := TFhirCarePlanActivityDetail(oSource).FStatus.Link;
  statusReasonElement := TFhirCarePlanActivityDetail(oSource).statusReasonElement.Clone;
  prohibitedElement := TFhirCarePlanActivityDetail(oSource).prohibitedElement.Clone;
  scheduled := TFhirCarePlanActivityDetail(oSource).scheduled.Clone;
  location := TFhirCarePlanActivityDetail(oSource).location.Clone;
  if (TFhirCarePlanActivityDetail(oSource).FPerformerList = nil) then
  begin
    FPerformerList.free;
    FPerformerList := nil;
  end
  else
  begin
    if FPerformerList = nil then
      FPerformerList := TFhirReferenceList{Resource}.Create;
    FPerformerList.Assign(TFhirCarePlanActivityDetail(oSource).FPerformerList);
  end;
  product := TFhirCarePlanActivityDetail(oSource).product.Clone;
  dailyAmount := TFhirCarePlanActivityDetail(oSource).dailyAmount.Clone;
  quantity := TFhirCarePlanActivityDetail(oSource).quantity.Clone;
  descriptionElement := TFhirCarePlanActivityDetail(oSource).descriptionElement.Clone;
end;

procedure TFhirCarePlanActivityDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'definition') Then
     list.add(self.link, 'definition', FDefinition.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'reasonCode') Then
    list.addAll(self, 'reasonCode', FReasonCodeList);
  if (child_name = 'reasonReference') Then
    list.addAll(self, 'reasonReference', FReasonReferenceList);
  if (child_name = 'goal') Then
    list.addAll(self, 'goal', FGoalList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusReason') Then
     list.add(self.link, 'statusReason', FStatusReason.Link);
  if (child_name = 'prohibited') Then
     list.add(self.link, 'prohibited', FProhibited.Link);
  if (child_name = 'scheduled[x]') or (child_name = 'scheduled') Then
     list.add(self.link, 'scheduled[x]', FScheduled.Link);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'performer') Then
    list.addAll(self, 'performer', FPerformerList);
  if (child_name = 'product[x]') or (child_name = 'product') Then
     list.add(self.link, 'product[x]', FProduct.Link);
  if (child_name = 'dailyAmount') Then
     list.add(self.link, 'dailyAmount', FDailyAmount.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
end;

procedure TFhirCarePlanActivityDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'definition', 'Reference(PlanDefinition|ActivityDefinition|Questionnaire)', false, TFhirReference{Resource}, FDefinition.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reasonCode', 'CodeableConcept', true, TFhirCodeableConcept, FReasonCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reasonReference', 'Reference(Condition)', true, TFhirReference{TFhirCondition}, FReasonReferenceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'goal', 'Reference(Goal)', true, TFhirReference{TFhirGoal}, FGoalList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'statusReason', 'string', false, TFhirString, FStatusReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'prohibited', 'boolean', false, TFhirBoolean, FProhibited.Link));{2}
  oList.add(TFHIRProperty.create(self, 'scheduled[x]', 'Timing|Period|string', false, TFhirType, FScheduled.Link));{2}
  oList.add(TFHIRProperty.create(self, 'location', 'Reference(Location)', false, TFhirReference{TFhirLocation}, FLocation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'performer', 'Reference(Practitioner|Organization|RelatedPerson|Patient|CareTeam)', true, TFhirReference{Resource}, FPerformerList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'product[x]', 'CodeableConcept|Reference(Medication|Substance)', false, TFhirType, FProduct.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dailyAmount', 'Quantity', false, TFhirQuantity, FDailyAmount.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
end;

function TFhirCarePlanActivityDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'definition') then
  begin
    Definition := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'reasonCode') then
  begin
    ReasonCodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'reasonReference') then
  begin
    ReasonReferenceList.add(propValue as TFhirReference{TFhirCondition}){2a};
    result := propValue;
  end
  else if (propName = 'goal') then
  begin
    GoalList.add(propValue as TFhirReference{TFhirGoal}){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirCarePlanActivityStatusEnum, CODES_TFhirCarePlanActivityStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'statusReason') then
  begin
    StatusReasonElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'prohibited') then
  begin
    ProhibitedElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'scheduled', ['Timing', 'Period', 'String'])) then
  begin
    Scheduled := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirReference{TFhirLocation}{4b};
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    PerformerList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'product', ['CodeableConcept', 'Reference'])) then
  begin
    Product := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'dailyAmount') then
  begin
    DailyAmount := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCarePlanActivityDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'reasonCode') then ReasonCodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'reasonReference') then ReasonReferenceList.insertItem(index, propValue as TFhirReference{TFhirCondition}){2a}
  else if (propName = 'goal') then GoalList.insertItem(index, propValue as TFhirReference{TFhirGoal}){2a}
  else if (propName = 'performer') then PerformerList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else inherited;
end;

function TFhirCarePlanActivityDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'definition') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'reasonCode') then result := ReasonCodeList.new(){2}
  else if (propName = 'reasonReference') then result := ReasonReferenceList.new(){2}
  else if (propName = 'goal') then result := GoalList.new(){2}
  else if (propName = 'statusReason') then result := TFhirString.create() {5b}
  else if (propName = 'prohibited') then result := TFhirBoolean.create() {5b}
  else if (isMatchingName(propName, 'scheduled', ['Timing', 'Period', 'String'])) then raise EFHIRException.create('Cannot make property Scheduled'){4x}
  else if (propName = 'location') then result := TFhirReference{TFhirLocation}.create(){4b}
  else if (propName = 'performer') then result := PerformerList.new(){2}
  else if (isMatchingName(propName, 'product', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Product'){4x}
  else if (propName = 'dailyAmount') then result := TFhirQuantity.create(){4b}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCarePlanActivityDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'definition') then result := 'Reference'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'reasonCode') then result := 'CodeableConcept'
  else if (propName = 'reasonReference') then result := 'Reference'
  else if (propName = 'goal') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'statusReason') then result := 'string'
  else if (propName = 'prohibited') then result := 'boolean'
  else if (propName = 'scheduled[x]') then result := 'Timing|Period|string'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'performer') then result := 'Reference'
  else if (propName = 'product[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'dailyAmount') then result := 'Quantity'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'description') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCarePlanActivityDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := nil
  else if (propName = 'definition') then DefinitionElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'reasonCode') then deletePropertyValue('reasonCode', ReasonCodeList, value) {2}
  else if (propName = 'reasonReference') then deletePropertyValue('reasonReference', ReasonReferenceList, value) {2}
  else if (propName = 'goal') then deletePropertyValue('goal', GoalList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusReason') then StatusReasonElement := nil
  else if (propName = 'prohibited') then ProhibitedElement := nil
  else if (isMatchingName(propName, 'scheduled', ['Timing', 'Period', 'String'])) then ScheduledElement := nil{4x}
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'performer') then deletePropertyValue('performer', PerformerList, value) {2}
  else if (isMatchingName(propName, 'product', ['CodeableConcept', 'Reference'])) then ProductElement := nil{4x}
  else if (propName = 'dailyAmount') then DailyAmountElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCarePlanActivityDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'definition') then DefinitionElement := new as TFhirReference{Resource}{4}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'reasonCode') then replacePropertyValue('reasonCode', ReasonCodeList, existing, new) {2}
  else if (propName = 'reasonReference') then replacePropertyValue('reasonReference', ReasonReferenceList, existing, new) {2}
  else if (propName = 'goal') then replacePropertyValue('goal', GoalList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirCarePlanActivityStatusEnum, CODES_TFhirCarePlanActivityStatusEnum, new){4}
  else if (propName = 'statusReason') then StatusReasonElement := asString(new){5b}
  else if (propName = 'prohibited') then ProhibitedElement := asBoolean(new){5b}
  else if (isMatchingName(propName, 'scheduled', ['Timing', 'Period', 'String'])) then ScheduledElement := new as TFhirType{4x}
  else if (propName = 'location') then LocationElement := new as TFhirReference{TFhirLocation}{4}
  else if (propName = 'performer') then replacePropertyValue('performer', PerformerList, existing, new) {2}
  else if (isMatchingName(propName, 'product', ['CodeableConcept', 'Reference'])) then ProductElement := new as TFhirType{4x}
  else if (propName = 'dailyAmount') then DailyAmountElement := new as TFhirQuantity{4}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCarePlanActivityDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'reasonCode') then ReasonCodeList.move(source, destination){2a}
  else if (propName = 'reasonReference') then ReasonReferenceList.move(source, destination){2a}
  else if (propName = 'goal') then GoalList.move(source, destination){2a}
  else if (propName = 'performer') then PerformerList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCarePlanActivityDetail.fhirType : string;
begin
  result := 'detail';
end;

function TFhirCarePlanActivityDetail.Link : TFhirCarePlanActivityDetail;
begin
  result := TFhirCarePlanActivityDetail(inherited Link);
end;

function TFhirCarePlanActivityDetail.Clone : TFhirCarePlanActivityDetail;
begin
  result := TFhirCarePlanActivityDetail(inherited Clone);
end;

function TFhirCarePlanActivityDetail.equals(other : TObject) : boolean;
var
  o : TFhirCarePlanActivityDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCarePlanActivityDetail)) then
    result := false
  else
  begin
    o := TFhirCarePlanActivityDetail(other);
    result := compareDeep(categoryElement, o.categoryElement, true) and compareDeep(definitionElement, o.definitionElement, true) and
      compareDeep(codeElement, o.codeElement, true) and compareDeep(reasonCodeList, o.reasonCodeList, true) and
      compareDeep(reasonReferenceList, o.reasonReferenceList, true) and compareDeep(goalList, o.goalList, true) and
      compareDeep(statusElement, o.statusElement, true) and compareDeep(statusReasonElement, o.statusReasonElement, true) and
      compareDeep(prohibitedElement, o.prohibitedElement, true) and compareDeep(scheduledElement, o.scheduledElement, true) and
      compareDeep(locationElement, o.locationElement, true) and compareDeep(performerList, o.performerList, true) and
      compareDeep(productElement, o.productElement, true) and compareDeep(dailyAmountElement, o.dailyAmountElement, true) and
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(descriptionElement, o.descriptionElement, true);
  end;
end;

function TFhirCarePlanActivityDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCategory) and isEmptyProp(FDefinition) and isEmptyProp(FCode) and isEmptyProp(FreasonCodeList) and isEmptyProp(FreasonReferenceList) and isEmptyProp(FgoalList) and isEmptyProp(FStatus) and isEmptyProp(FStatusReason) and isEmptyProp(FProhibited) and isEmptyProp(FScheduled) and isEmptyProp(FLocation) and isEmptyProp(FperformerList) and isEmptyProp(FProduct) and isEmptyProp(FDailyAmount) and isEmptyProp(FQuantity) and isEmptyProp(FDescription);
end;

procedure TFhirCarePlanActivityDetail.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('category');
  fields.add('definition');
  fields.add('code');
  fields.add('reasonCode');
  fields.add('reasonReference');
  fields.add('goal');
  fields.add('status');
  fields.add('statusReason');
  fields.add('prohibited');
  fields.add('scheduled[x]');
  fields.add('location');
  fields.add('performer');
  fields.add('product[x]');
  fields.add('dailyAmount');
  fields.add('quantity');
  fields.add('description');
end;

{ TFhirCarePlanActivityDetail }

Procedure TFhirCarePlanActivityDetail.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirCarePlanActivityDetail.SetDefinition(value : TFhirReference{Resource});
begin
  FDefinition.free;
  FDefinition := value;
end;

Procedure TFhirCarePlanActivityDetail.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirCarePlanActivityDetail.GetReasonCodeList : TFhirCodeableConceptList;
begin
  if FReasonCodeList = nil then
    FReasonCodeList := TFhirCodeableConceptList.Create;
  result := FReasonCodeList;
end;

Function TFhirCarePlanActivityDetail.GetHasReasonCodeList : boolean;
begin
  result := (FReasonCodeList <> nil) and (FReasonCodeList.count > 0);
end;

Function TFhirCarePlanActivityDetail.GetReasonReferenceList : TFhirReferenceList{TFhirCondition};
begin
  if FReasonReferenceList = nil then
    FReasonReferenceList := TFhirReferenceList{TFhirCondition}.Create;
  result := FReasonReferenceList;
end;

Function TFhirCarePlanActivityDetail.GetHasReasonReferenceList : boolean;
begin
  result := (FReasonReferenceList <> nil) and (FReasonReferenceList.count > 0);
end;

Function TFhirCarePlanActivityDetail.GetGoalList : TFhirReferenceList{TFhirGoal};
begin
  if FGoalList = nil then
    FGoalList := TFhirReferenceList{TFhirGoal}.Create;
  result := FGoalList;
end;

Function TFhirCarePlanActivityDetail.GetHasGoalList : boolean;
begin
  result := (FGoalList <> nil) and (FGoalList.count > 0);
end;

Procedure TFhirCarePlanActivityDetail.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirCarePlanActivityDetail.GetStatusST : TFhirCarePlanActivityStatusEnum;
begin
  if FStatus = nil then
    result := TFhirCarePlanActivityStatusEnum(0)
  else
    result := TFhirCarePlanActivityStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirCarePlanActivityStatusEnum, FStatus.value));
end;

Procedure TFhirCarePlanActivityDetail.SetStatusST(value : TFhirCarePlanActivityStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirCarePlanActivityStatusEnum[value], CODES_TFhirCarePlanActivityStatusEnum[value]);
end;

Procedure TFhirCarePlanActivityDetail.SetStatusReason(value : TFhirString);
begin
  FStatusReason.free;
  FStatusReason := value;
end;

Function TFhirCarePlanActivityDetail.GetStatusReasonST : String;
begin
  if FStatusReason = nil then
    result := ''
  else
    result := FStatusReason.value;
end;

Procedure TFhirCarePlanActivityDetail.SetStatusReasonST(value : String);
begin
  if value <> '' then
  begin
    if FStatusReason = nil then
      FStatusReason := TFhirString.create;
    FStatusReason.value := value
  end
  else if FStatusReason <> nil then
    FStatusReason.value := '';
end;

Procedure TFhirCarePlanActivityDetail.SetProhibited(value : TFhirBoolean);
begin
  FProhibited.free;
  FProhibited := value;
end;

Function TFhirCarePlanActivityDetail.GetProhibitedST : Boolean;
begin
  if FProhibited = nil then
    result := false
  else
    result := FProhibited.value;
end;

Procedure TFhirCarePlanActivityDetail.SetProhibitedST(value : Boolean);
begin
  if FProhibited = nil then
    FProhibited := TFhirBoolean.create;
  FProhibited.value := value
end;

Procedure TFhirCarePlanActivityDetail.SetScheduled(value : TFhirType);
begin
  FScheduled.free;
  FScheduled := value;
end;

Procedure TFhirCarePlanActivityDetail.SetLocation(value : TFhirReference{TFhirLocation});
begin
  FLocation.free;
  FLocation := value;
end;

Function TFhirCarePlanActivityDetail.GetPerformerList : TFhirReferenceList{Resource};
begin
  if FPerformerList = nil then
    FPerformerList := TFhirReferenceList{Resource}.Create;
  result := FPerformerList;
end;

Function TFhirCarePlanActivityDetail.GetHasPerformerList : boolean;
begin
  result := (FPerformerList <> nil) and (FPerformerList.count > 0);
end;

Procedure TFhirCarePlanActivityDetail.SetProduct(value : TFhirType);
begin
  FProduct.free;
  FProduct := value;
end;

Procedure TFhirCarePlanActivityDetail.SetDailyAmount(value : TFhirQuantity);
begin
  FDailyAmount.free;
  FDailyAmount := value;
end;

Procedure TFhirCarePlanActivityDetail.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirCarePlanActivityDetail.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirCarePlanActivityDetail.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirCarePlanActivityDetail.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirCarePlanActivityDetail.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCategory.sizeInBytes);
  inc(result, FDefinition.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FreasonCodeList.sizeInBytes);
  inc(result, FreasonReferenceList.sizeInBytes);
  inc(result, FgoalList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FStatusReason.sizeInBytes);
  inc(result, FProhibited.sizeInBytes);
  inc(result, FScheduled.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
  inc(result, FperformerList.sizeInBytes);
  inc(result, FProduct.sizeInBytes);
  inc(result, FDailyAmount.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
end;

{ TFhirCarePlanActivityDetailListEnumerator }

Constructor TFhirCarePlanActivityDetailListEnumerator.Create(list : TFhirCarePlanActivityDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCarePlanActivityDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCarePlanActivityDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCarePlanActivityDetailListEnumerator.GetCurrent : TFhirCarePlanActivityDetail;
begin
  Result := FList[FIndex];
end;

function TFhirCarePlanActivityDetailListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCarePlanActivityDetailList }
procedure TFhirCarePlanActivityDetailList.AddItem(value: TFhirCarePlanActivityDetail);
begin
  assert(value.ClassName = 'TFhirCarePlanActivityDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCarePlanActivityDetail');
  add(value);
end;

function TFhirCarePlanActivityDetailList.Append: TFhirCarePlanActivityDetail;
begin
  result := TFhirCarePlanActivityDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCarePlanActivityDetailList.ClearItems;
begin
  Clear;
end;

function TFhirCarePlanActivityDetailList.GetEnumerator : TFhirCarePlanActivityDetailListEnumerator;
begin
  result := TFhirCarePlanActivityDetailListEnumerator.Create(self.link);
end;

function TFhirCarePlanActivityDetailList.Clone: TFhirCarePlanActivityDetailList;
begin
  result := TFhirCarePlanActivityDetailList(inherited Clone);
end;

function TFhirCarePlanActivityDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCarePlanActivityDetailList.GetItemN(index: Integer): TFhirCarePlanActivityDetail;
begin
  result := TFhirCarePlanActivityDetail(ObjectByIndex[index]);
end;

function TFhirCarePlanActivityDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirCarePlanActivityDetail;
end;
function TFhirCarePlanActivityDetailList.IndexOf(value: TFhirCarePlanActivityDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCarePlanActivityDetailList.Insert(index: Integer): TFhirCarePlanActivityDetail;
begin
  result := TFhirCarePlanActivityDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCarePlanActivityDetailList.InsertItem(index: Integer; value: TFhirCarePlanActivityDetail);
begin
  assert(value is TFhirCarePlanActivityDetail);
  Inherited Insert(index, value);
end;

function TFhirCarePlanActivityDetailList.Item(index: Integer): TFhirCarePlanActivityDetail;
begin
  result := TFhirCarePlanActivityDetail(ObjectByIndex[index]);
end;

function TFhirCarePlanActivityDetailList.Link: TFhirCarePlanActivityDetailList;
begin
  result := TFhirCarePlanActivityDetailList(inherited Link);
end;

procedure TFhirCarePlanActivityDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCarePlanActivityDetailList.SetItemByIndex(index: Integer; value: TFhirCarePlanActivityDetail);
begin
  assert(value is TFhirCarePlanActivityDetail);
  FhirCarePlanActivityDetails[index] := value;
end;

procedure TFhirCarePlanActivityDetailList.SetItemN(index: Integer; value: TFhirCarePlanActivityDetail);
begin
  assert(value is TFhirCarePlanActivityDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirCarePlan }

constructor TFhirCarePlan.Create;
begin
  inherited;
end;

destructor TFhirCarePlan.Destroy;
begin
  FIdentifierList.Free;
  FDefinitionList.Free;
  FBasedOnList.Free;
  FReplacesList.Free;
  FPartOfList.Free;
  FStatus.free;
  FIntent.free;
  FCategoryList.Free;
  FTitle.free;
  FDescription.free;
  FSubject.free;
  FContext.free;
  FPeriod.free;
  FAuthorList.Free;
  FCareTeamList.Free;
  FAddressesList.Free;
  FSupportingInfoList.Free;
  FGoalList.Free;
  FActivityList.Free;
  FNoteList.Free;
  inherited;
end;

function TFhirCarePlan.GetResourceType : TFhirResourceType;
begin
  result := frtCarePlan;
end;

procedure TFhirCarePlan.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCarePlan(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCarePlan(oSource).FIdentifierList);
  end;
  if (TFhirCarePlan(oSource).FDefinitionList = nil) then
  begin
    FDefinitionList.free;
    FDefinitionList := nil;
  end
  else
  begin
    if FDefinitionList = nil then
      FDefinitionList := TFhirReferenceList{Resource}.Create;
    FDefinitionList.Assign(TFhirCarePlan(oSource).FDefinitionList);
  end;
  if (TFhirCarePlan(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList{TFhirCarePlan}.Create;
    FBasedOnList.Assign(TFhirCarePlan(oSource).FBasedOnList);
  end;
  if (TFhirCarePlan(oSource).FReplacesList = nil) then
  begin
    FReplacesList.free;
    FReplacesList := nil;
  end
  else
  begin
    if FReplacesList = nil then
      FReplacesList := TFhirReferenceList{TFhirCarePlan}.Create;
    FReplacesList.Assign(TFhirCarePlan(oSource).FReplacesList);
  end;
  if (TFhirCarePlan(oSource).FPartOfList = nil) then
  begin
    FPartOfList.free;
    FPartOfList := nil;
  end
  else
  begin
    if FPartOfList = nil then
      FPartOfList := TFhirReferenceList{TFhirCarePlan}.Create;
    FPartOfList.Assign(TFhirCarePlan(oSource).FPartOfList);
  end;
  FStatus := TFhirCarePlan(oSource).FStatus.Link;
  FIntent := TFhirCarePlan(oSource).FIntent.Link;
  if (TFhirCarePlan(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirCarePlan(oSource).FCategoryList);
  end;
  titleElement := TFhirCarePlan(oSource).titleElement.Clone;
  descriptionElement := TFhirCarePlan(oSource).descriptionElement.Clone;
  subject := TFhirCarePlan(oSource).subject.Clone;
  context := TFhirCarePlan(oSource).context.Clone;
  period := TFhirCarePlan(oSource).period.Clone;
  if (TFhirCarePlan(oSource).FAuthorList = nil) then
  begin
    FAuthorList.free;
    FAuthorList := nil;
  end
  else
  begin
    if FAuthorList = nil then
      FAuthorList := TFhirReferenceList{Resource}.Create;
    FAuthorList.Assign(TFhirCarePlan(oSource).FAuthorList);
  end;
  if (TFhirCarePlan(oSource).FCareTeamList = nil) then
  begin
    FCareTeamList.free;
    FCareTeamList := nil;
  end
  else
  begin
    if FCareTeamList = nil then
      FCareTeamList := TFhirReferenceList{TFhirCareTeam}.Create;
    FCareTeamList.Assign(TFhirCarePlan(oSource).FCareTeamList);
  end;
  if (TFhirCarePlan(oSource).FAddressesList = nil) then
  begin
    FAddressesList.free;
    FAddressesList := nil;
  end
  else
  begin
    if FAddressesList = nil then
      FAddressesList := TFhirReferenceList{TFhirCondition}.Create;
    FAddressesList.Assign(TFhirCarePlan(oSource).FAddressesList);
  end;
  if (TFhirCarePlan(oSource).FSupportingInfoList = nil) then
  begin
    FSupportingInfoList.free;
    FSupportingInfoList := nil;
  end
  else
  begin
    if FSupportingInfoList = nil then
      FSupportingInfoList := TFhirReferenceList{TFhirReference}.Create;
    FSupportingInfoList.Assign(TFhirCarePlan(oSource).FSupportingInfoList);
  end;
  if (TFhirCarePlan(oSource).FGoalList = nil) then
  begin
    FGoalList.free;
    FGoalList := nil;
  end
  else
  begin
    if FGoalList = nil then
      FGoalList := TFhirReferenceList{TFhirGoal}.Create;
    FGoalList.Assign(TFhirCarePlan(oSource).FGoalList);
  end;
  if (TFhirCarePlan(oSource).FActivityList = nil) then
  begin
    FActivityList.free;
    FActivityList := nil;
  end
  else
  begin
    if FActivityList = nil then
      FActivityList := TFhirCarePlanActivityList.Create;
    FActivityList.Assign(TFhirCarePlan(oSource).FActivityList);
  end;
  if (TFhirCarePlan(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirCarePlan(oSource).FNoteList);
  end;
end;

procedure TFhirCarePlan.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'definition') Then
    list.addAll(self, 'definition', FDefinitionList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'replaces') Then
    list.addAll(self, 'replaces', FReplacesList);
  if (child_name = 'partOf') Then
    list.addAll(self, 'partOf', FPartOfList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'intent') Then
     list.add(self.link, 'intent', FIntent.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'author') Then
    list.addAll(self, 'author', FAuthorList);
  if (child_name = 'careTeam') Then
    list.addAll(self, 'careTeam', FCareTeamList);
  if (child_name = 'addresses') Then
    list.addAll(self, 'addresses', FAddressesList);
  if (child_name = 'supportingInfo') Then
    list.addAll(self, 'supportingInfo', FSupportingInfoList);
  if (child_name = 'goal') Then
    list.addAll(self, 'goal', FGoalList);
  if (child_name = 'activity') Then
    list.addAll(self, 'activity', FActivityList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirCarePlan.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'definition', 'Reference(PlanDefinition|Questionnaire)', true, TFhirReference{Resource}, FDefinitionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference(CarePlan)', true, TFhirReference{TFhirCarePlan}, FBasedOnList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'replaces', 'Reference(CarePlan)', true, TFhirReference{TFhirCarePlan}, FReplacesList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference(CarePlan)', true, TFhirReference{TFhirCarePlan}, FPartOfList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'intent', 'code', false, TFHIREnum, FIntent.Link));{1}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Group)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'context', 'Reference(Encounter|EpisodeOfCare)', false, TFhirReference{Resource}, FContext.Link));{2}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'author', 'Reference(Patient|Practitioner|RelatedPerson|Organization|CareTeam)', true, TFhirReference{Resource}, FAuthorList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'careTeam', 'Reference(CareTeam)', true, TFhirReference{TFhirCareTeam}, FCareTeamList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'addresses', 'Reference(Condition)', true, TFhirReference{TFhirCondition}, FAddressesList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'supportingInfo', 'Reference(Any)', true, TFhirReference{TFhirReference}, FSupportingInfoList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'goal', 'Reference(Goal)', true, TFhirReference{TFhirGoal}, FGoalList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'activity', '', true, TFhirCarePlanActivity, FActivityList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
end;

function TFhirCarePlan.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'definition') then
  begin
    DefinitionList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference{TFhirCarePlan}){2a};
    result := propValue;
  end
  else if (propName = 'replaces') then
  begin
    ReplacesList.add(propValue as TFhirReference{TFhirCarePlan}){2a};
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOfList.add(propValue as TFhirReference{TFhirCarePlan}){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirCarePlanStatusEnum, CODES_TFhirCarePlanStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'intent') then
  begin
    IntentElement := asEnum(SYSTEMS_TFhirCarePlanIntentEnum, CODES_TFhirCarePlanIntentEnum, propValue);
    result := propValue
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'context') then
  begin
    Context := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    AuthorList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'careTeam') then
  begin
    CareTeamList.add(propValue as TFhirReference{TFhirCareTeam}){2a};
    result := propValue;
  end
  else if (propName = 'addresses') then
  begin
    AddressesList.add(propValue as TFhirReference{TFhirCondition}){2a};
    result := propValue;
  end
  else if (propName = 'supportingInfo') then
  begin
    SupportingInfoList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'goal') then
  begin
    GoalList.add(propValue as TFhirReference{TFhirGoal}){2a};
    result := propValue;
  end
  else if (propName = 'activity') then
  begin
    ActivityList.add(propValue as TFhirCarePlanActivity){2a};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirCarePlan.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'definition') then DefinitionList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference{TFhirCarePlan}){2a}
  else if (propName = 'replaces') then ReplacesList.insertItem(index, propValue as TFhirReference{TFhirCarePlan}){2a}
  else if (propName = 'partOf') then PartOfList.insertItem(index, propValue as TFhirReference{TFhirCarePlan}){2a}
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'author') then AuthorList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'careTeam') then CareTeamList.insertItem(index, propValue as TFhirReference{TFhirCareTeam}){2a}
  else if (propName = 'addresses') then AddressesList.insertItem(index, propValue as TFhirReference{TFhirCondition}){2a}
  else if (propName = 'supportingInfo') then SupportingInfoList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'goal') then GoalList.insertItem(index, propValue as TFhirReference{TFhirGoal}){2a}
  else if (propName = 'activity') then ActivityList.insertItem(index, propValue as TFhirCarePlanActivity){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else inherited;
end;

function TFhirCarePlan.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'definition') then result := DefinitionList.new(){2}
  else if (propName = 'basedOn') then result := BasedOnList.new(){2}
  else if (propName = 'replaces') then result := ReplacesList.new(){2}
  else if (propName = 'partOf') then result := PartOfList.new(){2}
  else if (propName = 'category') then result := CategoryList.new(){2}
  else if (propName = 'title') then result := TFhirString.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'context') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'period') then result := TFhirPeriod.create(){4b}
  else if (propName = 'author') then result := AuthorList.new(){2}
  else if (propName = 'careTeam') then result := CareTeamList.new(){2}
  else if (propName = 'addresses') then result := AddressesList.new(){2}
  else if (propName = 'supportingInfo') then result := SupportingInfoList.new(){2}
  else if (propName = 'goal') then result := GoalList.new(){2}
  else if (propName = 'activity') then result := ActivityList.new(){2}
  else if (propName = 'note') then result := NoteList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCarePlan.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'definition') then result := 'Reference'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'replaces') then result := 'Reference'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'intent') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'context') then result := 'Reference'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'careTeam') then result := 'Reference'
  else if (propName = 'addresses') then result := 'Reference'
  else if (propName = 'supportingInfo') then result := 'Reference'
  else if (propName = 'goal') then result := 'Reference'
  else if (propName = 'activity') then result := ''
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCarePlan.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'definition') then deletePropertyValue('definition', DefinitionList, value) {2}
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value) {2}
  else if (propName = 'replaces') then deletePropertyValue('replaces', ReplacesList, value) {2}
  else if (propName = 'partOf') then deletePropertyValue('partOf', PartOfList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'intent') then IntentElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value) {2}
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'context') then ContextElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'author') then deletePropertyValue('author', AuthorList, value) {2}
  else if (propName = 'careTeam') then deletePropertyValue('careTeam', CareTeamList, value) {2}
  else if (propName = 'addresses') then deletePropertyValue('addresses', AddressesList, value) {2}
  else if (propName = 'supportingInfo') then deletePropertyValue('supportingInfo', SupportingInfoList, value) {2}
  else if (propName = 'goal') then deletePropertyValue('goal', GoalList, value) {2}
  else if (propName = 'activity') then deletePropertyValue('activity', ActivityList, value) {2}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCarePlan.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'definition') then replacePropertyValue('definition', DefinitionList, existing, new) {2}
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new) {2}
  else if (propName = 'replaces') then replacePropertyValue('replaces', ReplacesList, existing, new) {2}
  else if (propName = 'partOf') then replacePropertyValue('partOf', PartOfList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirCarePlanStatusEnum, CODES_TFhirCarePlanStatusEnum, new){4}
  else if (propName = 'intent') then IntentElement := asEnum(SYSTEMS_TFhirCarePlanIntentEnum, CODES_TFhirCarePlanIntentEnum, new){4}
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new) {2}
  else if (propName = 'title') then TitleElement := asString(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'context') then ContextElement := new as TFhirReference{Resource}{4}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else if (propName = 'author') then replacePropertyValue('author', AuthorList, existing, new) {2}
  else if (propName = 'careTeam') then replacePropertyValue('careTeam', CareTeamList, existing, new) {2}
  else if (propName = 'addresses') then replacePropertyValue('addresses', AddressesList, existing, new) {2}
  else if (propName = 'supportingInfo') then replacePropertyValue('supportingInfo', SupportingInfoList, existing, new) {2}
  else if (propName = 'goal') then replacePropertyValue('goal', GoalList, existing, new) {2}
  else if (propName = 'activity') then replacePropertyValue('activity', ActivityList, existing, new) {2}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCarePlan.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'definition') then DefinitionList.move(source, destination){2a}
  else if (propName = 'basedOn') then BasedOnList.move(source, destination){2a}
  else if (propName = 'replaces') then ReplacesList.move(source, destination){2a}
  else if (propName = 'partOf') then PartOfList.move(source, destination){2a}
  else if (propName = 'category') then CategoryList.move(source, destination){2a}
  else if (propName = 'author') then AuthorList.move(source, destination){2a}
  else if (propName = 'careTeam') then CareTeamList.move(source, destination){2a}
  else if (propName = 'addresses') then AddressesList.move(source, destination){2a}
  else if (propName = 'supportingInfo') then SupportingInfoList.move(source, destination){2a}
  else if (propName = 'goal') then GoalList.move(source, destination){2a}
  else if (propName = 'activity') then ActivityList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCarePlan.fhirType : string;
begin
  result := 'CarePlan';
end;

function TFhirCarePlan.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FdefinitionList) and isEmptyProp(FbasedOnList) and isEmptyProp(FreplacesList) and isEmptyProp(FpartOfList) and isEmptyProp(FStatus) and isEmptyProp(FIntent) and isEmptyProp(FcategoryList) and isEmptyProp(FTitle) and isEmptyProp(FDescription) and isEmptyProp(FSubject) and isEmptyProp(FContext) and isEmptyProp(FPeriod) and isEmptyProp(FauthorList) and isEmptyProp(FcareTeamList) and isEmptyProp(FaddressesList) and isEmptyProp(FsupportingInfoList) and isEmptyProp(FgoalList) and isEmptyProp(FactivityList) and isEmptyProp(FnoteList);
end;

function TFhirCarePlan.equals(other : TObject) : boolean;
var
  o : TFhirCarePlan;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCarePlan)) then
    result := false
  else
  begin
    o := TFhirCarePlan(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(definitionList, o.definitionList, true) and
      compareDeep(basedOnList, o.basedOnList, true) and compareDeep(replacesList, o.replacesList, true) and
      compareDeep(partOfList, o.partOfList, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(intentElement, o.intentElement, true) and compareDeep(categoryList, o.categoryList, true) and
      compareDeep(titleElement, o.titleElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(contextElement, o.contextElement, true) and
      compareDeep(periodElement, o.periodElement, true) and compareDeep(authorList, o.authorList, true) and
      compareDeep(careTeamList, o.careTeamList, true) and compareDeep(addressesList, o.addressesList, true) and
      compareDeep(supportingInfoList, o.supportingInfoList, true) and compareDeep(goalList, o.goalList, true) and
      compareDeep(activityList, o.activityList, true) and compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirCarePlan.Link : TFhirCarePlan;
begin
  result := TFhirCarePlan(inherited Link);
end;

function TFhirCarePlan.Clone : TFhirCarePlan;
begin
  result := TFhirCarePlan(inherited Clone);
end;

procedure TFhirCarePlan.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('definition');
  fields.add('basedOn');
  fields.add('replaces');
  fields.add('partOf');
  fields.add('status');
  fields.add('intent');
  fields.add('category');
  fields.add('title');
  fields.add('description');
  fields.add('subject');
  fields.add('context');
  fields.add('period');
  fields.add('author');
  fields.add('careTeam');
  fields.add('addresses');
  fields.add('supportingInfo');
  fields.add('goal');
  fields.add('activity');
  fields.add('note');
end;

{ TFhirCarePlan }

Function TFhirCarePlan.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirCarePlan.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Function TFhirCarePlan.GetDefinitionList : TFhirReferenceList{Resource};
begin
  if FDefinitionList = nil then
    FDefinitionList := TFhirReferenceList{Resource}.Create;
  result := FDefinitionList;
end;

Function TFhirCarePlan.GetHasDefinitionList : boolean;
begin
  result := (FDefinitionList <> nil) and (FDefinitionList.count > 0);
end;

Function TFhirCarePlan.GetBasedOnList : TFhirReferenceList{TFhirCarePlan};
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList{TFhirCarePlan}.Create;
  result := FBasedOnList;
end;

Function TFhirCarePlan.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

Function TFhirCarePlan.GetReplacesList : TFhirReferenceList{TFhirCarePlan};
begin
  if FReplacesList = nil then
    FReplacesList := TFhirReferenceList{TFhirCarePlan}.Create;
  result := FReplacesList;
end;

Function TFhirCarePlan.GetHasReplacesList : boolean;
begin
  result := (FReplacesList <> nil) and (FReplacesList.count > 0);
end;

Function TFhirCarePlan.GetPartOfList : TFhirReferenceList{TFhirCarePlan};
begin
  if FPartOfList = nil then
    FPartOfList := TFhirReferenceList{TFhirCarePlan}.Create;
  result := FPartOfList;
end;

Function TFhirCarePlan.GetHasPartOfList : boolean;
begin
  result := (FPartOfList <> nil) and (FPartOfList.count > 0);
end;

Procedure TFhirCarePlan.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirCarePlan.GetStatusST : TFhirCarePlanStatusEnum;
begin
  if FStatus = nil then
    result := TFhirCarePlanStatusEnum(0)
  else
    result := TFhirCarePlanStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirCarePlanStatusEnum, FStatus.value));
end;

Procedure TFhirCarePlan.SetStatusST(value : TFhirCarePlanStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirCarePlanStatusEnum[value], CODES_TFhirCarePlanStatusEnum[value]);
end;

Procedure TFhirCarePlan.SetIntent(value : TFhirEnum);
begin
  FIntent.free;
  FIntent := value;
end;

Function TFhirCarePlan.GetIntentST : TFhirCarePlanIntentEnum;
begin
  if FIntent = nil then
    result := TFhirCarePlanIntentEnum(0)
  else
    result := TFhirCarePlanIntentEnum(StringArrayIndexOfSensitive(CODES_TFhirCarePlanIntentEnum, FIntent.value));
end;

Procedure TFhirCarePlan.SetIntentST(value : TFhirCarePlanIntentEnum);
begin
  if ord(value) = 0 then
    IntentElement := nil
  else
    IntentElement := TFhirEnum.create(SYSTEMS_TFhirCarePlanIntentEnum[value], CODES_TFhirCarePlanIntentEnum[value]);
end;

Function TFhirCarePlan.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

Function TFhirCarePlan.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

Procedure TFhirCarePlan.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

Function TFhirCarePlan.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

Procedure TFhirCarePlan.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

Procedure TFhirCarePlan.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirCarePlan.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirCarePlan.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirCarePlan.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirCarePlan.SetContext(value : TFhirReference{Resource});
begin
  FContext.free;
  FContext := value;
end;

Procedure TFhirCarePlan.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Function TFhirCarePlan.GetAuthorList : TFhirReferenceList{Resource};
begin
  if FAuthorList = nil then
    FAuthorList := TFhirReferenceList{Resource}.Create;
  result := FAuthorList;
end;

Function TFhirCarePlan.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

Function TFhirCarePlan.GetCareTeamList : TFhirReferenceList{TFhirCareTeam};
begin
  if FCareTeamList = nil then
    FCareTeamList := TFhirReferenceList{TFhirCareTeam}.Create;
  result := FCareTeamList;
end;

Function TFhirCarePlan.GetHasCareTeamList : boolean;
begin
  result := (FCareTeamList <> nil) and (FCareTeamList.count > 0);
end;

Function TFhirCarePlan.GetAddressesList : TFhirReferenceList{TFhirCondition};
begin
  if FAddressesList = nil then
    FAddressesList := TFhirReferenceList{TFhirCondition}.Create;
  result := FAddressesList;
end;

Function TFhirCarePlan.GetHasAddressesList : boolean;
begin
  result := (FAddressesList <> nil) and (FAddressesList.count > 0);
end;

Function TFhirCarePlan.GetSupportingInfoList : TFhirReferenceList{TFhirReference};
begin
  if FSupportingInfoList = nil then
    FSupportingInfoList := TFhirReferenceList{TFhirReference}.Create;
  result := FSupportingInfoList;
end;

Function TFhirCarePlan.GetHasSupportingInfoList : boolean;
begin
  result := (FSupportingInfoList <> nil) and (FSupportingInfoList.count > 0);
end;

Function TFhirCarePlan.GetGoalList : TFhirReferenceList{TFhirGoal};
begin
  if FGoalList = nil then
    FGoalList := TFhirReferenceList{TFhirGoal}.Create;
  result := FGoalList;
end;

Function TFhirCarePlan.GetHasGoalList : boolean;
begin
  result := (FGoalList <> nil) and (FGoalList.count > 0);
end;

Function TFhirCarePlan.GetActivityList : TFhirCarePlanActivityList;
begin
  if FActivityList = nil then
    FActivityList := TFhirCarePlanActivityList.Create;
  result := FActivityList;
end;

Function TFhirCarePlan.GetHasActivityList : boolean;
begin
  result := (FActivityList <> nil) and (FActivityList.count > 0);
end;

Function TFhirCarePlan.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirCarePlan.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirCarePlan.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FdefinitionList.sizeInBytes);
  inc(result, FbasedOnList.sizeInBytes);
  inc(result, FreplacesList.sizeInBytes);
  inc(result, FpartOfList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FIntent.sizeInBytes);
  inc(result, FcategoryList.sizeInBytes);
  inc(result, FTitle.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FContext.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FauthorList.sizeInBytes);
  inc(result, FcareTeamList.sizeInBytes);
  inc(result, FaddressesList.sizeInBytes);
  inc(result, FsupportingInfoList.sizeInBytes);
  inc(result, FgoalList.sizeInBytes);
  inc(result, FactivityList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
end;

{ TFhirCarePlanListEnumerator }

Constructor TFhirCarePlanListEnumerator.Create(list : TFhirCarePlanList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCarePlanListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCarePlanListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCarePlanListEnumerator.GetCurrent : TFhirCarePlan;
begin
  Result := FList[FIndex];
end;

function TFhirCarePlanListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCarePlanList }
procedure TFhirCarePlanList.AddItem(value: TFhirCarePlan);
begin
  assert(value.ClassName = 'TFhirCarePlan', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCarePlan');
  add(value);
end;

function TFhirCarePlanList.Append: TFhirCarePlan;
begin
  result := TFhirCarePlan.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCarePlanList.ClearItems;
begin
  Clear;
end;

function TFhirCarePlanList.GetEnumerator : TFhirCarePlanListEnumerator;
begin
  result := TFhirCarePlanListEnumerator.Create(self.link);
end;

function TFhirCarePlanList.Clone: TFhirCarePlanList;
begin
  result := TFhirCarePlanList(inherited Clone);
end;

function TFhirCarePlanList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCarePlanList.GetItemN(index: Integer): TFhirCarePlan;
begin
  result := TFhirCarePlan(ObjectByIndex[index]);
end;

function TFhirCarePlanList.ItemClass: TFslObjectClass;
begin
  result := TFhirCarePlan;
end;
function TFhirCarePlanList.IndexOf(value: TFhirCarePlan): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCarePlanList.Insert(index: Integer): TFhirCarePlan;
begin
  result := TFhirCarePlan.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCarePlanList.InsertItem(index: Integer; value: TFhirCarePlan);
begin
  assert(value is TFhirCarePlan);
  Inherited Insert(index, value);
end;

function TFhirCarePlanList.Item(index: Integer): TFhirCarePlan;
begin
  result := TFhirCarePlan(ObjectByIndex[index]);
end;

function TFhirCarePlanList.Link: TFhirCarePlanList;
begin
  result := TFhirCarePlanList(inherited Link);
end;

procedure TFhirCarePlanList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCarePlanList.SetItemByIndex(index: Integer; value: TFhirCarePlan);
begin
  assert(value is TFhirCarePlan);
  FhirCarePlans[index] := value;
end;

procedure TFhirCarePlanList.SetItemN(index: Integer; value: TFhirCarePlan);
begin
  assert(value is TFhirCarePlan);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CAREPLAN}

{$IFDEF FHIR_CARETEAM}

{ TFhirCareTeamParticipant }

constructor TFhirCareTeamParticipant.Create;
begin
  inherited;
end;

destructor TFhirCareTeamParticipant.Destroy;
begin
  FRole.free;
  FMember.free;
  FOnBehalfOf.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirCareTeamParticipant.Assign(oSource : TFslObject);
begin
  inherited;
  role := TFhirCareTeamParticipant(oSource).role.Clone;
  member := TFhirCareTeamParticipant(oSource).member.Clone;
  onBehalfOf := TFhirCareTeamParticipant(oSource).onBehalfOf.Clone;
  period := TFhirCareTeamParticipant(oSource).period.Clone;
end;

procedure TFhirCareTeamParticipant.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'member') Then
     list.add(self.link, 'member', FMember.Link);
  if (child_name = 'onBehalfOf') Then
     list.add(self.link, 'onBehalfOf', FOnBehalfOf.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirCareTeamParticipant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));{2}
  oList.add(TFHIRProperty.create(self, 'member', 'Reference(Practitioner|RelatedPerson|Patient|Organization|CareTeam)', false, TFhirReference{Resource}, FMember.Link));{2}
  oList.add(TFHIRProperty.create(self, 'onBehalfOf', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FOnBehalfOf.Link));{2}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
end;

function TFhirCareTeamParticipant.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'member') then
  begin
    Member := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'onBehalfOf') then
  begin
    OnBehalfOf := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCareTeamParticipant.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCareTeamParticipant.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'role') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'member') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'onBehalfOf') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'period') then result := TFhirPeriod.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCareTeamParticipant.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'member') then result := 'Reference'
  else if (propName = 'onBehalfOf') then result := 'Reference'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCareTeamParticipant.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := nil
  else if (propName = 'member') then MemberElement := nil
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCareTeamParticipant.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := new as TFhirCodeableConcept{4}
  else if (propName = 'member') then MemberElement := new as TFhirReference{Resource}{4}
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCareTeamParticipant.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCareTeamParticipant.fhirType : string;
begin
  result := 'participant';
end;

function TFhirCareTeamParticipant.Link : TFhirCareTeamParticipant;
begin
  result := TFhirCareTeamParticipant(inherited Link);
end;

function TFhirCareTeamParticipant.Clone : TFhirCareTeamParticipant;
begin
  result := TFhirCareTeamParticipant(inherited Clone);
end;

function TFhirCareTeamParticipant.equals(other : TObject) : boolean;
var
  o : TFhirCareTeamParticipant;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCareTeamParticipant)) then
    result := false
  else
  begin
    o := TFhirCareTeamParticipant(other);
    result := compareDeep(roleElement, o.roleElement, true) and compareDeep(memberElement, o.memberElement, true) and
      compareDeep(onBehalfOfElement, o.onBehalfOfElement, true) and compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirCareTeamParticipant.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRole) and isEmptyProp(FMember) and isEmptyProp(FOnBehalfOf) and isEmptyProp(FPeriod);
end;

procedure TFhirCareTeamParticipant.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('role');
  fields.add('member');
  fields.add('onBehalfOf');
  fields.add('period');
end;

{ TFhirCareTeamParticipant }

Procedure TFhirCareTeamParticipant.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

Procedure TFhirCareTeamParticipant.SetMember(value : TFhirReference{Resource});
begin
  FMember.free;
  FMember := value;
end;

Procedure TFhirCareTeamParticipant.SetOnBehalfOf(value : TFhirReference{TFhirOrganization});
begin
  FOnBehalfOf.free;
  FOnBehalfOf := value;
end;

Procedure TFhirCareTeamParticipant.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

function TFhirCareTeamParticipant.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FRole.sizeInBytes);
  inc(result, FMember.sizeInBytes);
  inc(result, FOnBehalfOf.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
end;

{ TFhirCareTeamParticipantListEnumerator }

Constructor TFhirCareTeamParticipantListEnumerator.Create(list : TFhirCareTeamParticipantList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCareTeamParticipantListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCareTeamParticipantListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCareTeamParticipantListEnumerator.GetCurrent : TFhirCareTeamParticipant;
begin
  Result := FList[FIndex];
end;

function TFhirCareTeamParticipantListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCareTeamParticipantList }
procedure TFhirCareTeamParticipantList.AddItem(value: TFhirCareTeamParticipant);
begin
  assert(value.ClassName = 'TFhirCareTeamParticipant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCareTeamParticipant');
  add(value);
end;

function TFhirCareTeamParticipantList.Append: TFhirCareTeamParticipant;
begin
  result := TFhirCareTeamParticipant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCareTeamParticipantList.ClearItems;
begin
  Clear;
end;

function TFhirCareTeamParticipantList.GetEnumerator : TFhirCareTeamParticipantListEnumerator;
begin
  result := TFhirCareTeamParticipantListEnumerator.Create(self.link);
end;

function TFhirCareTeamParticipantList.Clone: TFhirCareTeamParticipantList;
begin
  result := TFhirCareTeamParticipantList(inherited Clone);
end;

function TFhirCareTeamParticipantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCareTeamParticipantList.GetItemN(index: Integer): TFhirCareTeamParticipant;
begin
  result := TFhirCareTeamParticipant(ObjectByIndex[index]);
end;

function TFhirCareTeamParticipantList.ItemClass: TFslObjectClass;
begin
  result := TFhirCareTeamParticipant;
end;
function TFhirCareTeamParticipantList.IndexOf(value: TFhirCareTeamParticipant): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCareTeamParticipantList.Insert(index: Integer): TFhirCareTeamParticipant;
begin
  result := TFhirCareTeamParticipant.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCareTeamParticipantList.InsertItem(index: Integer; value: TFhirCareTeamParticipant);
begin
  assert(value is TFhirCareTeamParticipant);
  Inherited Insert(index, value);
end;

function TFhirCareTeamParticipantList.Item(index: Integer): TFhirCareTeamParticipant;
begin
  result := TFhirCareTeamParticipant(ObjectByIndex[index]);
end;

function TFhirCareTeamParticipantList.Link: TFhirCareTeamParticipantList;
begin
  result := TFhirCareTeamParticipantList(inherited Link);
end;

procedure TFhirCareTeamParticipantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCareTeamParticipantList.SetItemByIndex(index: Integer; value: TFhirCareTeamParticipant);
begin
  assert(value is TFhirCareTeamParticipant);
  FhirCareTeamParticipants[index] := value;
end;

procedure TFhirCareTeamParticipantList.SetItemN(index: Integer; value: TFhirCareTeamParticipant);
begin
  assert(value is TFhirCareTeamParticipant);
  ObjectByIndex[index] := value;
end;

{ TFhirCareTeam }

constructor TFhirCareTeam.Create;
begin
  inherited;
end;

destructor TFhirCareTeam.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FCategoryList.Free;
  FName.free;
  FSubject.free;
  FContext.free;
  FPeriod.free;
  FParticipantList.Free;
  FReasonCodeList.Free;
  FReasonReferenceList.Free;
  FManagingOrganizationList.Free;
  FNoteList.Free;
  inherited;
end;

function TFhirCareTeam.GetResourceType : TFhirResourceType;
begin
  result := frtCareTeam;
end;

procedure TFhirCareTeam.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCareTeam(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCareTeam(oSource).FIdentifierList);
  end;
  FStatus := TFhirCareTeam(oSource).FStatus.Link;
  if (TFhirCareTeam(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirCareTeam(oSource).FCategoryList);
  end;
  nameElement := TFhirCareTeam(oSource).nameElement.Clone;
  subject := TFhirCareTeam(oSource).subject.Clone;
  context := TFhirCareTeam(oSource).context.Clone;
  period := TFhirCareTeam(oSource).period.Clone;
  if (TFhirCareTeam(oSource).FParticipantList = nil) then
  begin
    FParticipantList.free;
    FParticipantList := nil;
  end
  else
  begin
    if FParticipantList = nil then
      FParticipantList := TFhirCareTeamParticipantList.Create;
    FParticipantList.Assign(TFhirCareTeam(oSource).FParticipantList);
  end;
  if (TFhirCareTeam(oSource).FReasonCodeList = nil) then
  begin
    FReasonCodeList.free;
    FReasonCodeList := nil;
  end
  else
  begin
    if FReasonCodeList = nil then
      FReasonCodeList := TFhirCodeableConceptList.Create;
    FReasonCodeList.Assign(TFhirCareTeam(oSource).FReasonCodeList);
  end;
  if (TFhirCareTeam(oSource).FReasonReferenceList = nil) then
  begin
    FReasonReferenceList.free;
    FReasonReferenceList := nil;
  end
  else
  begin
    if FReasonReferenceList = nil then
      FReasonReferenceList := TFhirReferenceList{TFhirCondition}.Create;
    FReasonReferenceList.Assign(TFhirCareTeam(oSource).FReasonReferenceList);
  end;
  if (TFhirCareTeam(oSource).FManagingOrganizationList = nil) then
  begin
    FManagingOrganizationList.free;
    FManagingOrganizationList := nil;
  end
  else
  begin
    if FManagingOrganizationList = nil then
      FManagingOrganizationList := TFhirReferenceList{TFhirOrganization}.Create;
    FManagingOrganizationList.Assign(TFhirCareTeam(oSource).FManagingOrganizationList);
  end;
  if (TFhirCareTeam(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirCareTeam(oSource).FNoteList);
  end;
end;

procedure TFhirCareTeam.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'participant') Then
    list.addAll(self, 'participant', FParticipantList);
  if (child_name = 'reasonCode') Then
    list.addAll(self, 'reasonCode', FReasonCodeList);
  if (child_name = 'reasonReference') Then
    list.addAll(self, 'reasonReference', FReasonReferenceList);
  if (child_name = 'managingOrganization') Then
    list.addAll(self, 'managingOrganization', FManagingOrganizationList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirCareTeam.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Group)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'context', 'Reference(Encounter|EpisodeOfCare)', false, TFhirReference{Resource}, FContext.Link));{2}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'participant', '', true, TFhirCareTeamParticipant, FParticipantList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reasonCode', 'CodeableConcept', true, TFhirCodeableConcept, FReasonCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reasonReference', 'Reference(Condition)', true, TFhirReference{TFhirCondition}, FReasonReferenceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'managingOrganization', 'Reference(Organization)', true, TFhirReference{TFhirOrganization}, FManagingOrganizationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
end;

function TFhirCareTeam.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirCareTeamStatusEnum, CODES_TFhirCareTeamStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'context') then
  begin
    Context := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'participant') then
  begin
    ParticipantList.add(propValue as TFhirCareTeamParticipant){2a};
    result := propValue;
  end
  else if (propName = 'reasonCode') then
  begin
    ReasonCodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'reasonReference') then
  begin
    ReasonReferenceList.add(propValue as TFhirReference{TFhirCondition}){2a};
    result := propValue;
  end
  else if (propName = 'managingOrganization') then
  begin
    ManagingOrganizationList.add(propValue as TFhirReference{TFhirOrganization}){2a};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirCareTeam.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'participant') then ParticipantList.insertItem(index, propValue as TFhirCareTeamParticipant){2a}
  else if (propName = 'reasonCode') then ReasonCodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'reasonReference') then ReasonReferenceList.insertItem(index, propValue as TFhirReference{TFhirCondition}){2a}
  else if (propName = 'managingOrganization') then ManagingOrganizationList.insertItem(index, propValue as TFhirReference{TFhirOrganization}){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else inherited;
end;

function TFhirCareTeam.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'category') then result := CategoryList.new(){2}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'context') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'period') then result := TFhirPeriod.create(){4b}
  else if (propName = 'participant') then result := ParticipantList.new(){2}
  else if (propName = 'reasonCode') then result := ReasonCodeList.new(){2}
  else if (propName = 'reasonReference') then result := ReasonReferenceList.new(){2}
  else if (propName = 'managingOrganization') then result := ManagingOrganizationList.new(){2}
  else if (propName = 'note') then result := NoteList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCareTeam.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'context') then result := 'Reference'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'participant') then result := ''
  else if (propName = 'reasonCode') then result := 'CodeableConcept'
  else if (propName = 'reasonReference') then result := 'Reference'
  else if (propName = 'managingOrganization') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCareTeam.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value) {2}
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'context') then ContextElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'participant') then deletePropertyValue('participant', ParticipantList, value) {2}
  else if (propName = 'reasonCode') then deletePropertyValue('reasonCode', ReasonCodeList, value) {2}
  else if (propName = 'reasonReference') then deletePropertyValue('reasonReference', ReasonReferenceList, value) {2}
  else if (propName = 'managingOrganization') then deletePropertyValue('managingOrganization', ManagingOrganizationList, value) {2}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCareTeam.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirCareTeamStatusEnum, CODES_TFhirCareTeamStatusEnum, new){4}
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new) {2}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'context') then ContextElement := new as TFhirReference{Resource}{4}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else if (propName = 'participant') then replacePropertyValue('participant', ParticipantList, existing, new) {2}
  else if (propName = 'reasonCode') then replacePropertyValue('reasonCode', ReasonCodeList, existing, new) {2}
  else if (propName = 'reasonReference') then replacePropertyValue('reasonReference', ReasonReferenceList, existing, new) {2}
  else if (propName = 'managingOrganization') then replacePropertyValue('managingOrganization', ManagingOrganizationList, existing, new) {2}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCareTeam.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'category') then CategoryList.move(source, destination){2a}
  else if (propName = 'participant') then ParticipantList.move(source, destination){2a}
  else if (propName = 'reasonCode') then ReasonCodeList.move(source, destination){2a}
  else if (propName = 'reasonReference') then ReasonReferenceList.move(source, destination){2a}
  else if (propName = 'managingOrganization') then ManagingOrganizationList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCareTeam.fhirType : string;
begin
  result := 'CareTeam';
end;

function TFhirCareTeam.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FcategoryList) and isEmptyProp(FName) and isEmptyProp(FSubject) and isEmptyProp(FContext) and isEmptyProp(FPeriod) and isEmptyProp(FparticipantList) and isEmptyProp(FreasonCodeList) and isEmptyProp(FreasonReferenceList) and isEmptyProp(FmanagingOrganizationList) and isEmptyProp(FnoteList);
end;

function TFhirCareTeam.equals(other : TObject) : boolean;
var
  o : TFhirCareTeam;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCareTeam)) then
    result := false
  else
  begin
    o := TFhirCareTeam(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(categoryList, o.categoryList, true) and compareDeep(nameElement, o.nameElement, true) and
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(contextElement, o.contextElement, true) and
      compareDeep(periodElement, o.periodElement, true) and compareDeep(participantList, o.participantList, true) and
      compareDeep(reasonCodeList, o.reasonCodeList, true) and compareDeep(reasonReferenceList, o.reasonReferenceList, true) and
      compareDeep(managingOrganizationList, o.managingOrganizationList, true) and compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirCareTeam.Link : TFhirCareTeam;
begin
  result := TFhirCareTeam(inherited Link);
end;

function TFhirCareTeam.Clone : TFhirCareTeam;
begin
  result := TFhirCareTeam(inherited Clone);
end;

procedure TFhirCareTeam.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('category');
  fields.add('name');
  fields.add('subject');
  fields.add('context');
  fields.add('period');
  fields.add('participant');
  fields.add('reasonCode');
  fields.add('reasonReference');
  fields.add('managingOrganization');
  fields.add('note');
end;

{ TFhirCareTeam }

Function TFhirCareTeam.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirCareTeam.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirCareTeam.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirCareTeam.GetStatusST : TFhirCareTeamStatusEnum;
begin
  if FStatus = nil then
    result := TFhirCareTeamStatusEnum(0)
  else
    result := TFhirCareTeamStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirCareTeamStatusEnum, FStatus.value));
end;

Procedure TFhirCareTeam.SetStatusST(value : TFhirCareTeamStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirCareTeamStatusEnum[value], CODES_TFhirCareTeamStatusEnum[value]);
end;

Function TFhirCareTeam.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

Function TFhirCareTeam.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

Procedure TFhirCareTeam.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirCareTeam.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirCareTeam.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirCareTeam.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirCareTeam.SetContext(value : TFhirReference{Resource});
begin
  FContext.free;
  FContext := value;
end;

Procedure TFhirCareTeam.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Function TFhirCareTeam.GetParticipantList : TFhirCareTeamParticipantList;
begin
  if FParticipantList = nil then
    FParticipantList := TFhirCareTeamParticipantList.Create;
  result := FParticipantList;
end;

Function TFhirCareTeam.GetHasParticipantList : boolean;
begin
  result := (FParticipantList <> nil) and (FParticipantList.count > 0);
end;

Function TFhirCareTeam.GetReasonCodeList : TFhirCodeableConceptList;
begin
  if FReasonCodeList = nil then
    FReasonCodeList := TFhirCodeableConceptList.Create;
  result := FReasonCodeList;
end;

Function TFhirCareTeam.GetHasReasonCodeList : boolean;
begin
  result := (FReasonCodeList <> nil) and (FReasonCodeList.count > 0);
end;

Function TFhirCareTeam.GetReasonReferenceList : TFhirReferenceList{TFhirCondition};
begin
  if FReasonReferenceList = nil then
    FReasonReferenceList := TFhirReferenceList{TFhirCondition}.Create;
  result := FReasonReferenceList;
end;

Function TFhirCareTeam.GetHasReasonReferenceList : boolean;
begin
  result := (FReasonReferenceList <> nil) and (FReasonReferenceList.count > 0);
end;

Function TFhirCareTeam.GetManagingOrganizationList : TFhirReferenceList{TFhirOrganization};
begin
  if FManagingOrganizationList = nil then
    FManagingOrganizationList := TFhirReferenceList{TFhirOrganization}.Create;
  result := FManagingOrganizationList;
end;

Function TFhirCareTeam.GetHasManagingOrganizationList : boolean;
begin
  result := (FManagingOrganizationList <> nil) and (FManagingOrganizationList.count > 0);
end;

Function TFhirCareTeam.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirCareTeam.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirCareTeam.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FcategoryList.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FContext.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FparticipantList.sizeInBytes);
  inc(result, FreasonCodeList.sizeInBytes);
  inc(result, FreasonReferenceList.sizeInBytes);
  inc(result, FmanagingOrganizationList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
end;

{ TFhirCareTeamListEnumerator }

Constructor TFhirCareTeamListEnumerator.Create(list : TFhirCareTeamList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCareTeamListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCareTeamListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCareTeamListEnumerator.GetCurrent : TFhirCareTeam;
begin
  Result := FList[FIndex];
end;

function TFhirCareTeamListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCareTeamList }
procedure TFhirCareTeamList.AddItem(value: TFhirCareTeam);
begin
  assert(value.ClassName = 'TFhirCareTeam', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCareTeam');
  add(value);
end;

function TFhirCareTeamList.Append: TFhirCareTeam;
begin
  result := TFhirCareTeam.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCareTeamList.ClearItems;
begin
  Clear;
end;

function TFhirCareTeamList.GetEnumerator : TFhirCareTeamListEnumerator;
begin
  result := TFhirCareTeamListEnumerator.Create(self.link);
end;

function TFhirCareTeamList.Clone: TFhirCareTeamList;
begin
  result := TFhirCareTeamList(inherited Clone);
end;

function TFhirCareTeamList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCareTeamList.GetItemN(index: Integer): TFhirCareTeam;
begin
  result := TFhirCareTeam(ObjectByIndex[index]);
end;

function TFhirCareTeamList.ItemClass: TFslObjectClass;
begin
  result := TFhirCareTeam;
end;
function TFhirCareTeamList.IndexOf(value: TFhirCareTeam): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCareTeamList.Insert(index: Integer): TFhirCareTeam;
begin
  result := TFhirCareTeam.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCareTeamList.InsertItem(index: Integer; value: TFhirCareTeam);
begin
  assert(value is TFhirCareTeam);
  Inherited Insert(index, value);
end;

function TFhirCareTeamList.Item(index: Integer): TFhirCareTeam;
begin
  result := TFhirCareTeam(ObjectByIndex[index]);
end;

function TFhirCareTeamList.Link: TFhirCareTeamList;
begin
  result := TFhirCareTeamList(inherited Link);
end;

procedure TFhirCareTeamList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCareTeamList.SetItemByIndex(index: Integer; value: TFhirCareTeam);
begin
  assert(value is TFhirCareTeam);
  FhirCareTeams[index] := value;
end;

procedure TFhirCareTeamList.SetItemN(index: Integer; value: TFhirCareTeam);
begin
  assert(value is TFhirCareTeam);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CARETEAM}

{$IFDEF FHIR_CLINICALIMPRESSION}

{ TFhirClinicalImpressionInvestigation }

constructor TFhirClinicalImpressionInvestigation.Create;
begin
  inherited;
end;

destructor TFhirClinicalImpressionInvestigation.Destroy;
begin
  FCode.free;
  FItemList.Free;
  inherited;
end;

procedure TFhirClinicalImpressionInvestigation.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirClinicalImpressionInvestigation(oSource).code.Clone;
  if (TFhirClinicalImpressionInvestigation(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirReferenceList{Resource}.Create;
    FItemList.Assign(TFhirClinicalImpressionInvestigation(oSource).FItemList);
  end;
end;

procedure TFhirClinicalImpressionInvestigation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
end;

procedure TFhirClinicalImpressionInvestigation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'item', 'Reference(Observation|QuestionnaireResponse|FamilyMemberHistory|DiagnosticReport|RiskAssessment|ImagingStudy)', true, TFhirReference{Resource}, FItemList.Link)){3};
end;

function TFhirClinicalImpressionInvestigation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClinicalImpressionInvestigation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else inherited;
end;

function TFhirClinicalImpressionInvestigation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'item') then result := ItemList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClinicalImpressionInvestigation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'item') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClinicalImpressionInvestigation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClinicalImpressionInvestigation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClinicalImpressionInvestigation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'item') then ItemList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClinicalImpressionInvestigation.fhirType : string;
begin
  result := 'investigation';
end;

function TFhirClinicalImpressionInvestigation.Link : TFhirClinicalImpressionInvestigation;
begin
  result := TFhirClinicalImpressionInvestigation(inherited Link);
end;

function TFhirClinicalImpressionInvestigation.Clone : TFhirClinicalImpressionInvestigation;
begin
  result := TFhirClinicalImpressionInvestigation(inherited Clone);
end;

function TFhirClinicalImpressionInvestigation.equals(other : TObject) : boolean;
var
  o : TFhirClinicalImpressionInvestigation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClinicalImpressionInvestigation)) then
    result := false
  else
  begin
    o := TFhirClinicalImpressionInvestigation(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(itemList, o.itemList, true);
  end;
end;

function TFhirClinicalImpressionInvestigation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FitemList);
end;

procedure TFhirClinicalImpressionInvestigation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('item');
end;

{ TFhirClinicalImpressionInvestigation }

Procedure TFhirClinicalImpressionInvestigation.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirClinicalImpressionInvestigation.GetItemList : TFhirReferenceList{Resource};
begin
  if FItemList = nil then
    FItemList := TFhirReferenceList{Resource}.Create;
  result := FItemList;
end;

Function TFhirClinicalImpressionInvestigation.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

function TFhirClinicalImpressionInvestigation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FitemList.sizeInBytes);
end;

{ TFhirClinicalImpressionInvestigationListEnumerator }

Constructor TFhirClinicalImpressionInvestigationListEnumerator.Create(list : TFhirClinicalImpressionInvestigationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClinicalImpressionInvestigationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClinicalImpressionInvestigationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClinicalImpressionInvestigationListEnumerator.GetCurrent : TFhirClinicalImpressionInvestigation;
begin
  Result := FList[FIndex];
end;

function TFhirClinicalImpressionInvestigationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClinicalImpressionInvestigationList }
procedure TFhirClinicalImpressionInvestigationList.AddItem(value: TFhirClinicalImpressionInvestigation);
begin
  assert(value.ClassName = 'TFhirClinicalImpressionInvestigation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClinicalImpressionInvestigation');
  add(value);
end;

function TFhirClinicalImpressionInvestigationList.Append: TFhirClinicalImpressionInvestigation;
begin
  result := TFhirClinicalImpressionInvestigation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalImpressionInvestigationList.ClearItems;
begin
  Clear;
end;

function TFhirClinicalImpressionInvestigationList.GetEnumerator : TFhirClinicalImpressionInvestigationListEnumerator;
begin
  result := TFhirClinicalImpressionInvestigationListEnumerator.Create(self.link);
end;

function TFhirClinicalImpressionInvestigationList.Clone: TFhirClinicalImpressionInvestigationList;
begin
  result := TFhirClinicalImpressionInvestigationList(inherited Clone);
end;

function TFhirClinicalImpressionInvestigationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClinicalImpressionInvestigationList.GetItemN(index: Integer): TFhirClinicalImpressionInvestigation;
begin
  result := TFhirClinicalImpressionInvestigation(ObjectByIndex[index]);
end;

function TFhirClinicalImpressionInvestigationList.ItemClass: TFslObjectClass;
begin
  result := TFhirClinicalImpressionInvestigation;
end;
function TFhirClinicalImpressionInvestigationList.IndexOf(value: TFhirClinicalImpressionInvestigation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClinicalImpressionInvestigationList.Insert(index: Integer): TFhirClinicalImpressionInvestigation;
begin
  result := TFhirClinicalImpressionInvestigation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalImpressionInvestigationList.InsertItem(index: Integer; value: TFhirClinicalImpressionInvestigation);
begin
  assert(value is TFhirClinicalImpressionInvestigation);
  Inherited Insert(index, value);
end;

function TFhirClinicalImpressionInvestigationList.Item(index: Integer): TFhirClinicalImpressionInvestigation;
begin
  result := TFhirClinicalImpressionInvestigation(ObjectByIndex[index]);
end;

function TFhirClinicalImpressionInvestigationList.Link: TFhirClinicalImpressionInvestigationList;
begin
  result := TFhirClinicalImpressionInvestigationList(inherited Link);
end;

procedure TFhirClinicalImpressionInvestigationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClinicalImpressionInvestigationList.SetItemByIndex(index: Integer; value: TFhirClinicalImpressionInvestigation);
begin
  assert(value is TFhirClinicalImpressionInvestigation);
  FhirClinicalImpressionInvestigations[index] := value;
end;

procedure TFhirClinicalImpressionInvestigationList.SetItemN(index: Integer; value: TFhirClinicalImpressionInvestigation);
begin
  assert(value is TFhirClinicalImpressionInvestigation);
  ObjectByIndex[index] := value;
end;

{ TFhirClinicalImpressionFinding }

constructor TFhirClinicalImpressionFinding.Create;
begin
  inherited;
end;

destructor TFhirClinicalImpressionFinding.Destroy;
begin
  FItem.free;
  FBasis.free;
  inherited;
end;

procedure TFhirClinicalImpressionFinding.Assign(oSource : TFslObject);
begin
  inherited;
  item := TFhirClinicalImpressionFinding(oSource).item.Clone;
  basisElement := TFhirClinicalImpressionFinding(oSource).basisElement.Clone;
end;

procedure TFhirClinicalImpressionFinding.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'item[x]') or (child_name = 'item') Then
     list.add(self.link, 'item[x]', FItem.Link);
  if (child_name = 'basis') Then
     list.add(self.link, 'basis', FBasis.Link);
end;

procedure TFhirClinicalImpressionFinding.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'item[x]', 'CodeableConcept|Reference(Condition|Observation)', false, TFhirType, FItem.Link));{2}
  oList.add(TFHIRProperty.create(self, 'basis', 'string', false, TFhirString, FBasis.Link));{2}
end;

function TFhirClinicalImpressionFinding.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then
  begin
    Item := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'basis') then
  begin
    BasisElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClinicalImpressionFinding.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClinicalImpressionFinding.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Item'){4x}
  else if (propName = 'basis') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClinicalImpressionFinding.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'item[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'basis') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClinicalImpressionFinding.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then ItemElement := nil{4x}
  else if (propName = 'basis') then BasisElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClinicalImpressionFinding.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then ItemElement := new as TFhirType{4x}
  else if (propName = 'basis') then BasisElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClinicalImpressionFinding.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClinicalImpressionFinding.fhirType : string;
begin
  result := 'finding';
end;

function TFhirClinicalImpressionFinding.Link : TFhirClinicalImpressionFinding;
begin
  result := TFhirClinicalImpressionFinding(inherited Link);
end;

function TFhirClinicalImpressionFinding.Clone : TFhirClinicalImpressionFinding;
begin
  result := TFhirClinicalImpressionFinding(inherited Clone);
end;

function TFhirClinicalImpressionFinding.equals(other : TObject) : boolean;
var
  o : TFhirClinicalImpressionFinding;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClinicalImpressionFinding)) then
    result := false
  else
  begin
    o := TFhirClinicalImpressionFinding(other);
    result := compareDeep(itemElement, o.itemElement, true) and compareDeep(basisElement, o.basisElement, true);
  end;
end;

function TFhirClinicalImpressionFinding.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FItem) and isEmptyProp(FBasis);
end;

procedure TFhirClinicalImpressionFinding.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('item[x]');
  fields.add('basis');
end;

{ TFhirClinicalImpressionFinding }

Procedure TFhirClinicalImpressionFinding.SetItem(value : TFhirType);
begin
  FItem.free;
  FItem := value;
end;

Procedure TFhirClinicalImpressionFinding.SetBasis(value : TFhirString);
begin
  FBasis.free;
  FBasis := value;
end;

Function TFhirClinicalImpressionFinding.GetBasisST : String;
begin
  if FBasis = nil then
    result := ''
  else
    result := FBasis.value;
end;

Procedure TFhirClinicalImpressionFinding.SetBasisST(value : String);
begin
  if value <> '' then
  begin
    if FBasis = nil then
      FBasis := TFhirString.create;
    FBasis.value := value
  end
  else if FBasis <> nil then
    FBasis.value := '';
end;

function TFhirClinicalImpressionFinding.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FItem.sizeInBytes);
  inc(result, FBasis.sizeInBytes);
end;

{ TFhirClinicalImpressionFindingListEnumerator }

Constructor TFhirClinicalImpressionFindingListEnumerator.Create(list : TFhirClinicalImpressionFindingList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClinicalImpressionFindingListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClinicalImpressionFindingListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClinicalImpressionFindingListEnumerator.GetCurrent : TFhirClinicalImpressionFinding;
begin
  Result := FList[FIndex];
end;

function TFhirClinicalImpressionFindingListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClinicalImpressionFindingList }
procedure TFhirClinicalImpressionFindingList.AddItem(value: TFhirClinicalImpressionFinding);
begin
  assert(value.ClassName = 'TFhirClinicalImpressionFinding', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClinicalImpressionFinding');
  add(value);
end;

function TFhirClinicalImpressionFindingList.Append: TFhirClinicalImpressionFinding;
begin
  result := TFhirClinicalImpressionFinding.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalImpressionFindingList.ClearItems;
begin
  Clear;
end;

function TFhirClinicalImpressionFindingList.GetEnumerator : TFhirClinicalImpressionFindingListEnumerator;
begin
  result := TFhirClinicalImpressionFindingListEnumerator.Create(self.link);
end;

function TFhirClinicalImpressionFindingList.Clone: TFhirClinicalImpressionFindingList;
begin
  result := TFhirClinicalImpressionFindingList(inherited Clone);
end;

function TFhirClinicalImpressionFindingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClinicalImpressionFindingList.GetItemN(index: Integer): TFhirClinicalImpressionFinding;
begin
  result := TFhirClinicalImpressionFinding(ObjectByIndex[index]);
end;

function TFhirClinicalImpressionFindingList.ItemClass: TFslObjectClass;
begin
  result := TFhirClinicalImpressionFinding;
end;
function TFhirClinicalImpressionFindingList.IndexOf(value: TFhirClinicalImpressionFinding): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClinicalImpressionFindingList.Insert(index: Integer): TFhirClinicalImpressionFinding;
begin
  result := TFhirClinicalImpressionFinding.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalImpressionFindingList.InsertItem(index: Integer; value: TFhirClinicalImpressionFinding);
begin
  assert(value is TFhirClinicalImpressionFinding);
  Inherited Insert(index, value);
end;

function TFhirClinicalImpressionFindingList.Item(index: Integer): TFhirClinicalImpressionFinding;
begin
  result := TFhirClinicalImpressionFinding(ObjectByIndex[index]);
end;

function TFhirClinicalImpressionFindingList.Link: TFhirClinicalImpressionFindingList;
begin
  result := TFhirClinicalImpressionFindingList(inherited Link);
end;

procedure TFhirClinicalImpressionFindingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClinicalImpressionFindingList.SetItemByIndex(index: Integer; value: TFhirClinicalImpressionFinding);
begin
  assert(value is TFhirClinicalImpressionFinding);
  FhirClinicalImpressionFindings[index] := value;
end;

procedure TFhirClinicalImpressionFindingList.SetItemN(index: Integer; value: TFhirClinicalImpressionFinding);
begin
  assert(value is TFhirClinicalImpressionFinding);
  ObjectByIndex[index] := value;
end;

{ TFhirClinicalImpression }

constructor TFhirClinicalImpression.Create;
begin
  inherited;
end;

destructor TFhirClinicalImpression.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FCode.free;
  FDescription.free;
  FSubject.free;
  FContext.free;
  FEffective.free;
  FDate.free;
  FAssessor.free;
  FPrevious.free;
  FProblemList.Free;
  FInvestigationList.Free;
  FProtocolList.Free;
  FSummary.free;
  FFindingList.Free;
  FPrognosisCodeableConceptList.Free;
  FPrognosisReferenceList.Free;
  FActionList.Free;
  FNoteList.Free;
  inherited;
end;

function TFhirClinicalImpression.GetResourceType : TFhirResourceType;
begin
  result := frtClinicalImpression;
end;

procedure TFhirClinicalImpression.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirClinicalImpression(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirClinicalImpression(oSource).FIdentifierList);
  end;
  FStatus := TFhirClinicalImpression(oSource).FStatus.Link;
  code := TFhirClinicalImpression(oSource).code.Clone;
  descriptionElement := TFhirClinicalImpression(oSource).descriptionElement.Clone;
  subject := TFhirClinicalImpression(oSource).subject.Clone;
  context := TFhirClinicalImpression(oSource).context.Clone;
  effective := TFhirClinicalImpression(oSource).effective.Clone;
  dateElement := TFhirClinicalImpression(oSource).dateElement.Clone;
  assessor := TFhirClinicalImpression(oSource).assessor.Clone;
  previous := TFhirClinicalImpression(oSource).previous.Clone;
  if (TFhirClinicalImpression(oSource).FProblemList = nil) then
  begin
    FProblemList.free;
    FProblemList := nil;
  end
  else
  begin
    if FProblemList = nil then
      FProblemList := TFhirReferenceList{Resource}.Create;
    FProblemList.Assign(TFhirClinicalImpression(oSource).FProblemList);
  end;
  if (TFhirClinicalImpression(oSource).FInvestigationList = nil) then
  begin
    FInvestigationList.free;
    FInvestigationList := nil;
  end
  else
  begin
    if FInvestigationList = nil then
      FInvestigationList := TFhirClinicalImpressionInvestigationList.Create;
    FInvestigationList.Assign(TFhirClinicalImpression(oSource).FInvestigationList);
  end;
  if (TFhirClinicalImpression(oSource).FProtocolList = nil) then
  begin
    FProtocolList.free;
    FProtocolList := nil;
  end
  else
  begin
    if FProtocolList = nil then
      FProtocolList := TFhirUriList.Create;
    FProtocolList.Assign(TFhirClinicalImpression(oSource).FProtocolList);
  end;
  summaryElement := TFhirClinicalImpression(oSource).summaryElement.Clone;
  if (TFhirClinicalImpression(oSource).FFindingList = nil) then
  begin
    FFindingList.free;
    FFindingList := nil;
  end
  else
  begin
    if FFindingList = nil then
      FFindingList := TFhirClinicalImpressionFindingList.Create;
    FFindingList.Assign(TFhirClinicalImpression(oSource).FFindingList);
  end;
  if (TFhirClinicalImpression(oSource).FPrognosisCodeableConceptList = nil) then
  begin
    FPrognosisCodeableConceptList.free;
    FPrognosisCodeableConceptList := nil;
  end
  else
  begin
    if FPrognosisCodeableConceptList = nil then
      FPrognosisCodeableConceptList := TFhirCodeableConceptList.Create;
    FPrognosisCodeableConceptList.Assign(TFhirClinicalImpression(oSource).FPrognosisCodeableConceptList);
  end;
  if (TFhirClinicalImpression(oSource).FPrognosisReferenceList = nil) then
  begin
    FPrognosisReferenceList.free;
    FPrognosisReferenceList := nil;
  end
  else
  begin
    if FPrognosisReferenceList = nil then
      FPrognosisReferenceList := TFhirReferenceList{TFhirRiskAssessment}.Create;
    FPrognosisReferenceList.Assign(TFhirClinicalImpression(oSource).FPrognosisReferenceList);
  end;
  if (TFhirClinicalImpression(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirReferenceList{Resource}.Create;
    FActionList.Assign(TFhirClinicalImpression(oSource).FActionList);
  end;
  if (TFhirClinicalImpression(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirClinicalImpression(oSource).FNoteList);
  end;
end;

procedure TFhirClinicalImpression.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
  if (child_name = 'effective[x]') or (child_name = 'effective') Then
     list.add(self.link, 'effective[x]', FEffective.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'assessor') Then
     list.add(self.link, 'assessor', FAssessor.Link);
  if (child_name = 'previous') Then
     list.add(self.link, 'previous', FPrevious.Link);
  if (child_name = 'problem') Then
    list.addAll(self, 'problem', FProblemList);
  if (child_name = 'investigation') Then
    list.addAll(self, 'investigation', FInvestigationList);
  if (child_name = 'protocol') Then
    list.addAll(self, 'protocol', FProtocolList);
  if (child_name = 'summary') Then
     list.add(self.link, 'summary', FSummary.Link);
  if (child_name = 'finding') Then
    list.addAll(self, 'finding', FFindingList);
  if (child_name = 'prognosisCodeableConcept') Then
    list.addAll(self, 'prognosisCodeableConcept', FPrognosisCodeableConceptList);
  if (child_name = 'prognosisReference') Then
    list.addAll(self, 'prognosisReference', FPrognosisReferenceList);
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirClinicalImpression.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Group)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'context', 'Reference(Encounter|EpisodeOfCare)', false, TFhirReference{Resource}, FContext.Link));{2}
  oList.add(TFHIRProperty.create(self, 'effective[x]', 'dateTime|Period', false, TFhirType, FEffective.Link));{2}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'assessor', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FAssessor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'previous', 'Reference(ClinicalImpression)', false, TFhirReference{TFhirClinicalImpression}, FPrevious.Link));{2}
  oList.add(TFHIRProperty.create(self, 'problem', 'Reference(Condition|AllergyIntolerance)', true, TFhirReference{Resource}, FProblemList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'investigation', '', true, TFhirClinicalImpressionInvestigation, FInvestigationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'protocol', 'uri', true, TFhirUri, FProtocolList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'summary', 'string', false, TFhirString, FSummary.Link));{2}
  oList.add(TFHIRProperty.create(self, 'finding', '', true, TFhirClinicalImpressionFinding, FFindingList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'prognosisCodeableConcept', 'CodeableConcept', true, TFhirCodeableConcept, FPrognosisCodeableConceptList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'prognosisReference', 'Reference(RiskAssessment)', true, TFhirReference{TFhirRiskAssessment}, FPrognosisReferenceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'action', 'Reference(ReferralRequest|ProcedureRequest|Procedure|MedicationRequest|Appointment)', true, TFhirReference{Resource}, FActionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
end;

function TFhirClinicalImpression.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirClinicalImpressionStatusEnum, CODES_TFhirClinicalImpressionStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'context') then
  begin
    Context := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then
  begin
    Effective := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'assessor') then
  begin
    Assessor := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'previous') then
  begin
    Previous := propValue as TFhirReference{TFhirClinicalImpression}{4b};
    result := propValue;
  end
  else if (propName = 'problem') then
  begin
    ProblemList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'investigation') then
  begin
    InvestigationList.add(propValue as TFhirClinicalImpressionInvestigation){2a};
    result := propValue;
  end
  else if (propName = 'protocol') then
  begin
    ProtocolList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'summary') then
  begin
    SummaryElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'finding') then
  begin
    FindingList.add(propValue as TFhirClinicalImpressionFinding){2a};
    result := propValue;
  end
  else if (propName = 'prognosisCodeableConcept') then
  begin
    PrognosisCodeableConceptList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'prognosisReference') then
  begin
    PrognosisReferenceList.add(propValue as TFhirReference{TFhirRiskAssessment}){2a};
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirClinicalImpression.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'problem') then ProblemList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'investigation') then InvestigationList.insertItem(index, propValue as TFhirClinicalImpressionInvestigation){2a}
  else if (propName = 'protocol') then ProtocolList.insertItem(index, asUri(propValue)){2}
  else if (propName = 'finding') then FindingList.insertItem(index, propValue as TFhirClinicalImpressionFinding){2a}
  else if (propName = 'prognosisCodeableConcept') then PrognosisCodeableConceptList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'prognosisReference') then PrognosisReferenceList.insertItem(index, propValue as TFhirReference{TFhirRiskAssessment}){2a}
  else if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else inherited;
end;

function TFhirClinicalImpression.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'context') then result := TFhirReference{Resource}.create(){4b}
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Effective'){4x}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'assessor') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'previous') then result := TFhirReference{TFhirClinicalImpression}.create(){4b}
  else if (propName = 'problem') then result := ProblemList.new(){2}
  else if (propName = 'investigation') then result := InvestigationList.new(){2}
  else if (propName = 'protocol') then result := ProtocolList.new(){2}
  else if (propName = 'summary') then result := TFhirString.create() {5b}
  else if (propName = 'finding') then result := FindingList.new(){2}
  else if (propName = 'prognosisCodeableConcept') then result := PrognosisCodeableConceptList.new(){2}
  else if (propName = 'prognosisReference') then result := PrognosisReferenceList.new(){2}
  else if (propName = 'action') then result := ActionList.new(){2}
  else if (propName = 'note') then result := NoteList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirClinicalImpression.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'context') then result := 'Reference'
  else if (propName = 'effective[x]') then result := 'dateTime|Period'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'assessor') then result := 'Reference'
  else if (propName = 'previous') then result := 'Reference'
  else if (propName = 'problem') then result := 'Reference'
  else if (propName = 'investigation') then result := ''
  else if (propName = 'protocol') then result := 'uri'
  else if (propName = 'summary') then result := 'string'
  else if (propName = 'finding') then result := ''
  else if (propName = 'prognosisCodeableConcept') then result := 'CodeableConcept'
  else if (propName = 'prognosisReference') then result := 'Reference'
  else if (propName = 'action') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClinicalImpression.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'context') then ContextElement := nil
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then EffectiveElement := nil{4x}
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'assessor') then AssessorElement := nil
  else if (propName = 'previous') then PreviousElement := nil
  else if (propName = 'problem') then deletePropertyValue('problem', ProblemList, value) {2}
  else if (propName = 'investigation') then deletePropertyValue('investigation', InvestigationList, value) {2}
  else if (propName = 'protocol') then deletePropertyValue('protocol', ProtocolList, value) {2}
  else if (propName = 'summary') then SummaryElement := nil
  else if (propName = 'finding') then deletePropertyValue('finding', FindingList, value) {2}
  else if (propName = 'prognosisCodeableConcept') then deletePropertyValue('prognosisCodeableConcept', PrognosisCodeableConceptList, value) {2}
  else if (propName = 'prognosisReference') then deletePropertyValue('prognosisReference', PrognosisReferenceList, value) {2}
  else if (propName = 'action') then deletePropertyValue('action', ActionList, value) {2}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClinicalImpression.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirClinicalImpressionStatusEnum, CODES_TFhirClinicalImpressionStatusEnum, new){4}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'context') then ContextElement := new as TFhirReference{Resource}{4}
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then EffectiveElement := new as TFhirType{4x}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'assessor') then AssessorElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'previous') then PreviousElement := new as TFhirReference{TFhirClinicalImpression}{4}
  else if (propName = 'problem') then replacePropertyValue('problem', ProblemList, existing, new) {2}
  else if (propName = 'investigation') then replacePropertyValue('investigation', InvestigationList, existing, new) {2}
  else if (propName = 'protocol') then replacePropertyValue('protocol', ProtocolList, existing, new) {2}
  else if (propName = 'summary') then SummaryElement := asString(new){5b}
  else if (propName = 'finding') then replacePropertyValue('finding', FindingList, existing, new) {2}
  else if (propName = 'prognosisCodeableConcept') then replacePropertyValue('prognosisCodeableConcept', PrognosisCodeableConceptList, existing, new) {2}
  else if (propName = 'prognosisReference') then replacePropertyValue('prognosisReference', PrognosisReferenceList, existing, new) {2}
  else if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new) {2}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClinicalImpression.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'problem') then ProblemList.move(source, destination){2a}
  else if (propName = 'investigation') then InvestigationList.move(source, destination){2a}
  else if (propName = 'protocol') then ProtocolList.move(source, destination){2}
  else if (propName = 'finding') then FindingList.move(source, destination){2a}
  else if (propName = 'prognosisCodeableConcept') then PrognosisCodeableConceptList.move(source, destination){2a}
  else if (propName = 'prognosisReference') then PrognosisReferenceList.move(source, destination){2a}
  else if (propName = 'action') then ActionList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClinicalImpression.fhirType : string;
begin
  result := 'ClinicalImpression';
end;

function TFhirClinicalImpression.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FCode) and isEmptyProp(FDescription) and isEmptyProp(FSubject) and isEmptyProp(FContext) and isEmptyProp(FEffective) and isEmptyProp(FDate) and isEmptyProp(FAssessor) and isEmptyProp(FPrevious) and isEmptyProp(FproblemList) and isEmptyProp(FinvestigationList) and isEmptyProp(FprotocolList) and isEmptyProp(FSummary) and isEmptyProp(FfindingList) and isEmptyProp(FprognosisCodeableConceptList) and isEmptyProp(FprognosisReferenceList) and isEmptyProp(FactionList) and isEmptyProp(FnoteList);
end;

function TFhirClinicalImpression.equals(other : TObject) : boolean;
var
  o : TFhirClinicalImpression;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClinicalImpression)) then
    result := false
  else
  begin
    o := TFhirClinicalImpression(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(codeElement, o.codeElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(contextElement, o.contextElement, true) and
      compareDeep(effectiveElement, o.effectiveElement, true) and compareDeep(dateElement, o.dateElement, true) and
      compareDeep(assessorElement, o.assessorElement, true) and compareDeep(previousElement, o.previousElement, true) and
      compareDeep(problemList, o.problemList, true) and compareDeep(investigationList, o.investigationList, true) and
      compareDeep(protocolList, o.protocolList, true) and compareDeep(summaryElement, o.summaryElement, true) and
      compareDeep(findingList, o.findingList, true) and compareDeep(prognosisCodeableConceptList, o.prognosisCodeableConceptList, true) and
      compareDeep(prognosisReferenceList, o.prognosisReferenceList, true) and compareDeep(actionList, o.actionList, true) and
      compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirClinicalImpression.Link : TFhirClinicalImpression;
begin
  result := TFhirClinicalImpression(inherited Link);
end;

function TFhirClinicalImpression.Clone : TFhirClinicalImpression;
begin
  result := TFhirClinicalImpression(inherited Clone);
end;

procedure TFhirClinicalImpression.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('code');
  fields.add('description');
  fields.add('subject');
  fields.add('context');
  fields.add('effective[x]');
  fields.add('date');
  fields.add('assessor');
  fields.add('previous');
  fields.add('problem');
  fields.add('investigation');
  fields.add('protocol');
  fields.add('summary');
  fields.add('finding');
  fields.add('prognosisCodeableConcept');
  fields.add('prognosisReference');
  fields.add('action');
  fields.add('note');
end;

{ TFhirClinicalImpression }

Function TFhirClinicalImpression.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirClinicalImpression.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirClinicalImpression.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirClinicalImpression.GetStatusST : TFhirClinicalImpressionStatusEnum;
begin
  if FStatus = nil then
    result := TFhirClinicalImpressionStatusEnum(0)
  else
    result := TFhirClinicalImpressionStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirClinicalImpressionStatusEnum, FStatus.value));
end;

Procedure TFhirClinicalImpression.SetStatusST(value : TFhirClinicalImpressionStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirClinicalImpressionStatusEnum[value], CODES_TFhirClinicalImpressionStatusEnum[value]);
end;

Procedure TFhirClinicalImpression.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirClinicalImpression.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirClinicalImpression.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirClinicalImpression.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirClinicalImpression.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirClinicalImpression.SetContext(value : TFhirReference{Resource});
begin
  FContext.free;
  FContext := value;
end;

Procedure TFhirClinicalImpression.SetEffective(value : TFhirType);
begin
  FEffective.free;
  FEffective := value;
end;

Procedure TFhirClinicalImpression.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirClinicalImpression.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirClinicalImpression.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirClinicalImpression.SetAssessor(value : TFhirReference{TFhirPractitioner});
begin
  FAssessor.free;
  FAssessor := value;
end;

Procedure TFhirClinicalImpression.SetPrevious(value : TFhirReference{TFhirClinicalImpression});
begin
  FPrevious.free;
  FPrevious := value;
end;

Function TFhirClinicalImpression.GetProblemList : TFhirReferenceList{Resource};
begin
  if FProblemList = nil then
    FProblemList := TFhirReferenceList{Resource}.Create;
  result := FProblemList;
end;

Function TFhirClinicalImpression.GetHasProblemList : boolean;
begin
  result := (FProblemList <> nil) and (FProblemList.count > 0);
end;

Function TFhirClinicalImpression.GetInvestigationList : TFhirClinicalImpressionInvestigationList;
begin
  if FInvestigationList = nil then
    FInvestigationList := TFhirClinicalImpressionInvestigationList.Create;
  result := FInvestigationList;
end;

Function TFhirClinicalImpression.GetHasInvestigationList : boolean;
begin
  result := (FInvestigationList <> nil) and (FInvestigationList.count > 0);
end;

Function TFhirClinicalImpression.GetProtocolList : TFhirUriList;
begin
  if FProtocolList = nil then
    FProtocolList := TFhirUriList.Create;
  result := FProtocolList;
end;

Function TFhirClinicalImpression.GetHasProtocolList : boolean;
begin
  result := (FProtocolList <> nil) and (FProtocolList.count > 0);
end;

Procedure TFhirClinicalImpression.SetSummary(value : TFhirString);
begin
  FSummary.free;
  FSummary := value;
end;

Function TFhirClinicalImpression.GetSummaryST : String;
begin
  if FSummary = nil then
    result := ''
  else
    result := FSummary.value;
end;

Procedure TFhirClinicalImpression.SetSummaryST(value : String);
begin
  if value <> '' then
  begin
    if FSummary = nil then
      FSummary := TFhirString.create;
    FSummary.value := value
  end
  else if FSummary <> nil then
    FSummary.value := '';
end;

Function TFhirClinicalImpression.GetFindingList : TFhirClinicalImpressionFindingList;
begin
  if FFindingList = nil then
    FFindingList := TFhirClinicalImpressionFindingList.Create;
  result := FFindingList;
end;

Function TFhirClinicalImpression.GetHasFindingList : boolean;
begin
  result := (FFindingList <> nil) and (FFindingList.count > 0);
end;

Function TFhirClinicalImpression.GetPrognosisCodeableConceptList : TFhirCodeableConceptList;
begin
  if FPrognosisCodeableConceptList = nil then
    FPrognosisCodeableConceptList := TFhirCodeableConceptList.Create;
  result := FPrognosisCodeableConceptList;
end;

Function TFhirClinicalImpression.GetHasPrognosisCodeableConceptList : boolean;
begin
  result := (FPrognosisCodeableConceptList <> nil) and (FPrognosisCodeableConceptList.count > 0);
end;

Function TFhirClinicalImpression.GetPrognosisReferenceList : TFhirReferenceList{TFhirRiskAssessment};
begin
  if FPrognosisReferenceList = nil then
    FPrognosisReferenceList := TFhirReferenceList{TFhirRiskAssessment}.Create;
  result := FPrognosisReferenceList;
end;

Function TFhirClinicalImpression.GetHasPrognosisReferenceList : boolean;
begin
  result := (FPrognosisReferenceList <> nil) and (FPrognosisReferenceList.count > 0);
end;

Function TFhirClinicalImpression.GetActionList : TFhirReferenceList{Resource};
begin
  if FActionList = nil then
    FActionList := TFhirReferenceList{Resource}.Create;
  result := FActionList;
end;

Function TFhirClinicalImpression.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

Function TFhirClinicalImpression.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirClinicalImpression.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirClinicalImpression.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FContext.sizeInBytes);
  inc(result, FEffective.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FAssessor.sizeInBytes);
  inc(result, FPrevious.sizeInBytes);
  inc(result, FproblemList.sizeInBytes);
  inc(result, FinvestigationList.sizeInBytes);
  inc(result, FprotocolList.sizeInBytes);
  inc(result, FSummary.sizeInBytes);
  inc(result, FfindingList.sizeInBytes);
  inc(result, FprognosisCodeableConceptList.sizeInBytes);
  inc(result, FprognosisReferenceList.sizeInBytes);
  inc(result, FactionList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
end;

{ TFhirClinicalImpressionListEnumerator }

Constructor TFhirClinicalImpressionListEnumerator.Create(list : TFhirClinicalImpressionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClinicalImpressionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClinicalImpressionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClinicalImpressionListEnumerator.GetCurrent : TFhirClinicalImpression;
begin
  Result := FList[FIndex];
end;

function TFhirClinicalImpressionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirClinicalImpressionList }
procedure TFhirClinicalImpressionList.AddItem(value: TFhirClinicalImpression);
begin
  assert(value.ClassName = 'TFhirClinicalImpression', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClinicalImpression');
  add(value);
end;

function TFhirClinicalImpressionList.Append: TFhirClinicalImpression;
begin
  result := TFhirClinicalImpression.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalImpressionList.ClearItems;
begin
  Clear;
end;

function TFhirClinicalImpressionList.GetEnumerator : TFhirClinicalImpressionListEnumerator;
begin
  result := TFhirClinicalImpressionListEnumerator.Create(self.link);
end;

function TFhirClinicalImpressionList.Clone: TFhirClinicalImpressionList;
begin
  result := TFhirClinicalImpressionList(inherited Clone);
end;

function TFhirClinicalImpressionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClinicalImpressionList.GetItemN(index: Integer): TFhirClinicalImpression;
begin
  result := TFhirClinicalImpression(ObjectByIndex[index]);
end;

function TFhirClinicalImpressionList.ItemClass: TFslObjectClass;
begin
  result := TFhirClinicalImpression;
end;
function TFhirClinicalImpressionList.IndexOf(value: TFhirClinicalImpression): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClinicalImpressionList.Insert(index: Integer): TFhirClinicalImpression;
begin
  result := TFhirClinicalImpression.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalImpressionList.InsertItem(index: Integer; value: TFhirClinicalImpression);
begin
  assert(value is TFhirClinicalImpression);
  Inherited Insert(index, value);
end;

function TFhirClinicalImpressionList.Item(index: Integer): TFhirClinicalImpression;
begin
  result := TFhirClinicalImpression(ObjectByIndex[index]);
end;

function TFhirClinicalImpressionList.Link: TFhirClinicalImpressionList;
begin
  result := TFhirClinicalImpressionList(inherited Link);
end;

procedure TFhirClinicalImpressionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClinicalImpressionList.SetItemByIndex(index: Integer; value: TFhirClinicalImpression);
begin
  assert(value is TFhirClinicalImpression);
  FhirClinicalImpressions[index] := value;
end;

procedure TFhirClinicalImpressionList.SetItemN(index: Integer; value: TFhirClinicalImpression);
begin
  assert(value is TFhirClinicalImpression);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CLINICALIMPRESSION}

{$IFDEF FHIR_COMMUNICATION}

{ TFhirCommunicationPayload }

constructor TFhirCommunicationPayload.Create;
begin
  inherited;
end;

destructor TFhirCommunicationPayload.Destroy;
begin
  FContent.free;
  inherited;
end;

procedure TFhirCommunicationPayload.Assign(oSource : TFslObject);
begin
  inherited;
  content := TFhirCommunicationPayload(oSource).content.Clone;
end;

procedure TFhirCommunicationPayload.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'content[x]') or (child_name = 'content') Then
     list.add(self.link, 'content[x]', FContent.Link);
end;

procedure TFhirCommunicationPayload.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'content[x]', 'string|Attachment|Reference(Any)', false, TFhirType, FContent.Link));{2}
end;

function TFhirCommunicationPayload.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['String', 'Attachment', 'Reference'])) then
  begin
    Content := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCommunicationPayload.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCommunicationPayload.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['String', 'Attachment', 'Reference'])) then raise EFHIRException.create('Cannot make property Content'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCommunicationPayload.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'content[x]') then result := 'string|Attachment|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCommunicationPayload.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['String', 'Attachment', 'Reference'])) then ContentElement := nil{4x}
  else
  inherited deleteProperty(propName, value);
end;

procedure TFhirCommunicationPayload.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['String', 'Attachment', 'Reference'])) then ContentElement := new as TFhirType{4x}
  else
  inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCommunicationPayload.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCommunicationPayload.fhirType : string;
begin
  result := 'payload';
end;

function TFhirCommunicationPayload.Link : TFhirCommunicationPayload;
begin
  result := TFhirCommunicationPayload(inherited Link);
end;

function TFhirCommunicationPayload.Clone : TFhirCommunicationPayload;
begin
  result := TFhirCommunicationPayload(inherited Clone);
end;

function TFhirCommunicationPayload.equals(other : TObject) : boolean;
var
  o : TFhirCommunicationPayload;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCommunicationPayload)) then
    result := false
  else
  begin
    o := TFhirCommunicationPayload(other);
    result := compareDeep(contentElement, o.contentElement, true);
  end;
end;

function TFhirCommunicationPayload.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FContent);
end;

procedure TFhirCommunicationPayload.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('content[x]');
end;

{ TFhirCommunicationPayload }

Procedure TFhirCommunicationPayload.SetContent(value : TFhirType);
begin
  FContent.free;
  FContent := value;
end;

function TFhirCommunicationPayload.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FContent.sizeInBytes);
end;

{ TFhirCommunicationPayloadListEnumerator }

Constructor TFhirCommunicationPayloadListEnumerator.Create(list : TFhirCommunicationPayloadList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCommunicationPayloadListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCommunicationPayloadListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCommunicationPayloadListEnumerator.GetCurrent : TFhirCommunicationPayload;
begin
  Result := FList[FIndex];
end;

function TFhirCommunicationPayloadListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCommunicationPayloadList }
procedure TFhirCommunicationPayloadList.AddItem(value: TFhirCommunicationPayload);
begin
  assert(value.ClassName = 'TFhirCommunicationPayload', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCommunicationPayload');
  add(value);
end;

function TFhirCommunicationPayloadList.Append: TFhirCommunicationPayload;
begin
  result := TFhirCommunicationPayload.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCommunicationPayloadList.ClearItems;
begin
  Clear;
end;

function TFhirCommunicationPayloadList.GetEnumerator : TFhirCommunicationPayloadListEnumerator;
begin
  result := TFhirCommunicationPayloadListEnumerator.Create(self.link);
end;

function TFhirCommunicationPayloadList.Clone: TFhirCommunicationPayloadList;
begin
  result := TFhirCommunicationPayloadList(inherited Clone);
end;

function TFhirCommunicationPayloadList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCommunicationPayloadList.GetItemN(index: Integer): TFhirCommunicationPayload;
begin
  result := TFhirCommunicationPayload(ObjectByIndex[index]);
end;

function TFhirCommunicationPayloadList.ItemClass: TFslObjectClass;
begin
  result := TFhirCommunicationPayload;
end;
function TFhirCommunicationPayloadList.IndexOf(value: TFhirCommunicationPayload): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCommunicationPayloadList.Insert(index: Integer): TFhirCommunicationPayload;
begin
  result := TFhirCommunicationPayload.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCommunicationPayloadList.InsertItem(index: Integer; value: TFhirCommunicationPayload);
begin
  assert(value is TFhirCommunicationPayload);
  Inherited Insert(index, value);
end;

function TFhirCommunicationPayloadList.Item(index: Integer): TFhirCommunicationPayload;
begin
  result := TFhirCommunicationPayload(ObjectByIndex[index]);
end;

function TFhirCommunicationPayloadList.Link: TFhirCommunicationPayloadList;
begin
  result := TFhirCommunicationPayloadList(inherited Link);
end;

procedure TFhirCommunicationPayloadList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCommunicationPayloadList.SetItemByIndex(index: Integer; value: TFhirCommunicationPayload);
begin
  assert(value is TFhirCommunicationPayload);
  FhirCommunicationPayloads[index] := value;
end;

procedure TFhirCommunicationPayloadList.SetItemN(index: Integer; value: TFhirCommunicationPayload);
begin
  assert(value is TFhirCommunicationPayload);
  ObjectByIndex[index] := value;
end;

{ TFhirCommunication }

constructor TFhirCommunication.Create;
begin
  inherited;
end;

destructor TFhirCommunication.Destroy;
begin
  FIdentifierList.Free;
  FDefinitionList.Free;
  FBasedOnList.Free;
  FPartOfList.Free;
  FStatus.free;
  FNotDone.free;
  FNotDoneReason.free;
  FCategoryList.Free;
  FMediumList.Free;
  FSubject.free;
  FRecipientList.Free;
  FTopicList.Free;
  FContext.free;
  FSent.free;
  FReceived.free;
  FSender.free;
  FReasonCodeList.Free;
  FReasonReferenceList.Free;
  FPayloadList.Free;
  FNoteList.Free;
  inherited;
end;

function TFhirCommunication.GetResourceType : TFhirResourceType;
begin
  result := frtCommunication;
end;

procedure TFhirCommunication.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCommunication(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCommunication(oSource).FIdentifierList);
  end;
  if (TFhirCommunication(oSource).FDefinitionList = nil) then
  begin
    FDefinitionList.free;
    FDefinitionList := nil;
  end
  else
  begin
    if FDefinitionList = nil then
      FDefinitionList := TFhirReferenceList{Resource}.Create;
    FDefinitionList.Assign(TFhirCommunication(oSource).FDefinitionList);
  end;
  if (TFhirCommunication(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList{TFhirReference}.Create;
    FBasedOnList.Assign(TFhirCommunication(oSource).FBasedOnList);
  end;
  if (TFhirCommunication(oSource).FPartOfList = nil) then
  begin
    FPartOfList.free;
    FPartOfList := nil;
  end
  else
  begin
    if FPartOfList = nil then
      FPartOfList := TFhirReferenceList{TFhirReference}.Create;
    FPartOfList.Assign(TFhirCommunication(oSource).FPartOfList);
  end;
  FStatus := TFhirCommunication(oSource).FStatus.Link;
  notDoneElement := TFhirCommunication(oSource).notDoneElement.Clone;
  notDoneReason := TFhirCommunication(oSource).notDoneReason.Clone;
  if (TFhirCommunication(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirCommunication(oSource).FCategoryList);
  end;
  if (TFhirCommunication(oSource).FMediumList = nil) then
  begin
    FMediumList.free;
    FMediumList := nil;
  end
  else
  begin
    if FMediumList = nil then
      FMediumList := TFhirCodeableConceptList.Create;
    FMediumList.Assign(TFhirCommunication(oSource).FMediumList);
  end;
  subject := TFhirCommunication(oSource).subject.Clone;
  if (TFhirCommunication(oSource).FRecipientList = nil) then
  begin
    FRecipientList.free;
    FRecipientList := nil;
  end
  else
  begin
    if FRecipientList = nil then
      FRecipientList := TFhirReferenceList{Resource}.Create;
    FRecipientList.Assign(TFhirCommunication(oSource).FRecipientList);
  end;
  if (TFhirCommunication(oSource).FTopicList = nil) then
  begin
    FTopicList.free;
    FTopicList := nil;
  end
  else
  begin
    if FTopicList = nil then
      FTopicList := TFhirReferenceList{TFhirReference}.Create;
    FTopicList.Assign(TFhirCommunication(oSource).FTopicList);
  end;
  context := TFhirCommunication(oSource).context.Clone;
  sentElement := TFhirCommunication(oSource).sentElement.Clone;
  receivedElement := TFhirCommunication(oSource).receivedElement.Clone;
  sender := TFhirCommunication(oSource).sender.Clone;
  if (TFhirCommunication(oSource).FReasonCodeList = nil) then
  begin
    FReasonCodeList.free;
    FReasonCodeList := nil;
  end
  else
  begin
    if FReasonCodeList = nil then
      FReasonCodeList := TFhirCodeableConceptList.Create;
    FReasonCodeList.Assign(TFhirCommunication(oSource).FReasonCodeList);
  end;
  if (TFhirCommunication(oSource).FReasonReferenceList = nil) then
  begin
    FReasonReferenceList.free;
    FReasonReferenceList := nil;
  end
  else
  begin
    if FReasonReferenceList = nil then
      FReasonReferenceList := TFhirReferenceList{Resource}.Create;
    FReasonReferenceList.Assign(TFhirCommunication(oSource).FReasonReferenceList);
  end;
  if (TFhirCommunication(oSource).FPayloadList = nil) then
  begin
    FPayloadList.free;
    FPayloadList := nil;
  end
  else
  begin
    if FPayloadList = nil then
      FPayloadList := TFhirCommunicationPayloadList.Create;
    FPayloadList.Assign(TFhirCommunication(oSource).FPayloadList);
  end;
  if (TFhirCommunication(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirCommunication(oSource).FNoteList);
  end;
end;

procedure TFhirCommunication.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'definition') Then
    list.addAll(self, 'definition', FDefinitionList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'partOf') Then
    list.addAll(self, 'partOf', FPartOfList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'notDone') Then
     list.add(self.link, 'notDone', FNotDone.Link);
  if (child_name = 'notDoneReason') Then
     list.add(self.link, 'notDoneReason', FNotDoneReason.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'medium') Then
    list.addAll(self, 'medium', FMediumList);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'recipient') Then
    list.addAll(self, 'recipient', FRecipientList);
  if (child_name = 'topic') Then
    list.addAll(self, 'topic', FTopicList);
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
  if (child_name = 'sent') Then
     list.add(self.link, 'sent', FSent.Link);
  if (child_name = 'received') Then
     list.add(self.link, 'received', FReceived.Link);
  if (child_name = 'sender') Then
     list.add(self.link, 'sender', FSender.Link);
  if (child_name = 'reasonCode') Then
    list.addAll(self, 'reasonCode', FReasonCodeList);
  if (child_name = 'reasonReference') Then
    list.addAll(self, 'reasonReference', FReasonReferenceList);
  if (child_name = 'payload') Then
    list.addAll(self, 'payload', FPayloadList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirCommunication.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'definition', 'Reference(PlanDefinition|ActivityDefinition)', true, TFhirReference{Resource}, FDefinitionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference(Any)', true, TFhirReference{TFhirReference}, FBasedOnList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference(Any)', true, TFhirReference{TFhirReference}, FPartOfList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'notDone', 'boolean', false, TFhirBoolean, FNotDone.Link));{2}
  oList.add(TFHIRProperty.create(self, 'notDoneReason', 'CodeableConcept', false, TFhirCodeableConcept, FNotDoneReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'medium', 'CodeableConcept', true, TFhirCodeableConcept, FMediumList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Group)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'recipient', 'Reference(Device|Organization|Patient|Practitioner|RelatedPerson|Group)', true, TFhirReference{Resource}, FRecipientList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'topic', 'Reference(Any)', true, TFhirReference{TFhirReference}, FTopicList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'context', 'Reference(Encounter|EpisodeOfCare)', false, TFhirReference{Resource}, FContext.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sent', 'dateTime', false, TFhirDateTime, FSent.Link));{2}
  oList.add(TFHIRProperty.create(self, 'received', 'dateTime', false, TFhirDateTime, FReceived.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sender', 'Reference(Device|Organization|Patient|Practitioner|RelatedPerson)', false, TFhirReference{Resource}, FSender.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reasonCode', 'CodeableConcept', true, TFhirCodeableConcept, FReasonCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reasonReference', 'Reference(Condition|Observation)', true, TFhirReference{Resource}, FReasonReferenceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'payload', '', true, TFhirCommunicationPayload, FPayloadList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
end;

function TFhirCommunication.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'definition') then
  begin
    DefinitionList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOfList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirEventStatusEnum, CODES_TFhirEventStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'notDone') then
  begin
    NotDoneElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'notDoneReason') then
  begin
    NotDoneReason := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'medium') then
  begin
    MediumList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'recipient') then
  begin
    RecipientList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'topic') then
  begin
    TopicList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'context') then
  begin
    Context := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'sent') then
  begin
    SentElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'received') then
  begin
    ReceivedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'sender') then
  begin
    Sender := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'reasonCode') then
  begin
    ReasonCodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'reasonReference') then
  begin
    ReasonReferenceList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'payload') then
  begin
    PayloadList.add(propValue as TFhirCommunicationPayload){2a};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirCommunication.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'definition') then DefinitionList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'partOf') then PartOfList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'medium') then MediumList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'recipient') then RecipientList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'topic') then TopicList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'reasonCode') then ReasonCodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'reasonReference') then ReasonReferenceList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'payload') then PayloadList.insertItem(index, propValue as TFhirCommunicationPayload){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else inherited;
end;

function TFhirCommunication.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'definition') then result := DefinitionList.new(){2}
  else if (propName = 'basedOn') then result := BasedOnList.new(){2}
  else if (propName = 'partOf') then result := PartOfList.new(){2}
  else if (propName = 'notDone') then result := TFhirBoolean.create() {5b}
  else if (propName = 'notDoneReason') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'category') then result := CategoryList.new(){2}
  else if (propName = 'medium') then result := MediumList.new(){2}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'recipient') then result := RecipientList.new(){2}
  else if (propName = 'topic') then result := TopicList.new(){2}
  else if (propName = 'context') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'sent') then result := TFhirDateTime.create() {5b}
  else if (propName = 'received') then result := TFhirDateTime.create() {5b}
  else if (propName = 'sender') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'reasonCode') then result := ReasonCodeList.new(){2}
  else if (propName = 'reasonReference') then result := ReasonReferenceList.new(){2}
  else if (propName = 'payload') then result := PayloadList.new(){2}
  else if (propName = 'note') then result := NoteList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCommunication.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'definition') then result := 'Reference'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'notDone') then result := 'boolean'
  else if (propName = 'notDoneReason') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'medium') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'recipient') then result := 'Reference'
  else if (propName = 'topic') then result := 'Reference'
  else if (propName = 'context') then result := 'Reference'
  else if (propName = 'sent') then result := 'dateTime'
  else if (propName = 'received') then result := 'dateTime'
  else if (propName = 'sender') then result := 'Reference'
  else if (propName = 'reasonCode') then result := 'CodeableConcept'
  else if (propName = 'reasonReference') then result := 'Reference'
  else if (propName = 'payload') then result := ''
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCommunication.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'definition') then deletePropertyValue('definition', DefinitionList, value) {2}
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value) {2}
  else if (propName = 'partOf') then deletePropertyValue('partOf', PartOfList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'notDone') then NotDoneElement := nil
  else if (propName = 'notDoneReason') then NotDoneReasonElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value) {2}
  else if (propName = 'medium') then deletePropertyValue('medium', MediumList, value) {2}
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'recipient') then deletePropertyValue('recipient', RecipientList, value) {2}
  else if (propName = 'topic') then deletePropertyValue('topic', TopicList, value) {2}
  else if (propName = 'context') then ContextElement := nil
  else if (propName = 'sent') then SentElement := nil
  else if (propName = 'received') then ReceivedElement := nil
  else if (propName = 'sender') then SenderElement := nil
  else if (propName = 'reasonCode') then deletePropertyValue('reasonCode', ReasonCodeList, value) {2}
  else if (propName = 'reasonReference') then deletePropertyValue('reasonReference', ReasonReferenceList, value) {2}
  else if (propName = 'payload') then deletePropertyValue('payload', PayloadList, value) {2}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCommunication.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'definition') then replacePropertyValue('definition', DefinitionList, existing, new) {2}
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new) {2}
  else if (propName = 'partOf') then replacePropertyValue('partOf', PartOfList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirEventStatusEnum, CODES_TFhirEventStatusEnum, new){4}
  else if (propName = 'notDone') then NotDoneElement := asBoolean(new){5b}
  else if (propName = 'notDoneReason') then NotDoneReasonElement := new as TFhirCodeableConcept{4}
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new) {2}
  else if (propName = 'medium') then replacePropertyValue('medium', MediumList, existing, new) {2}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'recipient') then replacePropertyValue('recipient', RecipientList, existing, new) {2}
  else if (propName = 'topic') then replacePropertyValue('topic', TopicList, existing, new) {2}
  else if (propName = 'context') then ContextElement := new as TFhirReference{Resource}{4}
  else if (propName = 'sent') then SentElement := asDateTime(new){5b}
  else if (propName = 'received') then ReceivedElement := asDateTime(new){5b}
  else if (propName = 'sender') then SenderElement := new as TFhirReference{Resource}{4}
  else if (propName = 'reasonCode') then replacePropertyValue('reasonCode', ReasonCodeList, existing, new) {2}
  else if (propName = 'reasonReference') then replacePropertyValue('reasonReference', ReasonReferenceList, existing, new) {2}
  else if (propName = 'payload') then replacePropertyValue('payload', PayloadList, existing, new) {2}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCommunication.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'definition') then DefinitionList.move(source, destination){2a}
  else if (propName = 'basedOn') then BasedOnList.move(source, destination){2a}
  else if (propName = 'partOf') then PartOfList.move(source, destination){2a}
  else if (propName = 'category') then CategoryList.move(source, destination){2a}
  else if (propName = 'medium') then MediumList.move(source, destination){2a}
  else if (propName = 'recipient') then RecipientList.move(source, destination){2a}
  else if (propName = 'topic') then TopicList.move(source, destination){2a}
  else if (propName = 'reasonCode') then ReasonCodeList.move(source, destination){2a}
  else if (propName = 'reasonReference') then ReasonReferenceList.move(source, destination){2a}
  else if (propName = 'payload') then PayloadList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCommunication.fhirType : string;
begin
  result := 'Communication';
end;

function TFhirCommunication.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FdefinitionList) and isEmptyProp(FbasedOnList) and isEmptyProp(FpartOfList) and isEmptyProp(FStatus) and isEmptyProp(FNotDone) and isEmptyProp(FNotDoneReason) and isEmptyProp(FcategoryList) and isEmptyProp(FmediumList) and isEmptyProp(FSubject) and isEmptyProp(FrecipientList) and isEmptyProp(FtopicList) and isEmptyProp(FContext) and isEmptyProp(FSent) and isEmptyProp(FReceived) and isEmptyProp(FSender) and isEmptyProp(FreasonCodeList) and isEmptyProp(FreasonReferenceList) and isEmptyProp(FpayloadList) and isEmptyProp(FnoteList);
end;

function TFhirCommunication.equals(other : TObject) : boolean;
var
  o : TFhirCommunication;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCommunication)) then
    result := false
  else
  begin
    o := TFhirCommunication(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(definitionList, o.definitionList, true) and
      compareDeep(basedOnList, o.basedOnList, true) and compareDeep(partOfList, o.partOfList, true) and
      compareDeep(statusElement, o.statusElement, true) and compareDeep(notDoneElement, o.notDoneElement, true) and
      compareDeep(notDoneReasonElement, o.notDoneReasonElement, true) and compareDeep(categoryList, o.categoryList, true) and
      compareDeep(mediumList, o.mediumList, true) and compareDeep(subjectElement, o.subjectElement, true) and
      compareDeep(recipientList, o.recipientList, true) and compareDeep(topicList, o.topicList, true) and
      compareDeep(contextElement, o.contextElement, true) and compareDeep(sentElement, o.sentElement, true) and
      compareDeep(receivedElement, o.receivedElement, true) and compareDeep(senderElement, o.senderElement, true) and
      compareDeep(reasonCodeList, o.reasonCodeList, true) and compareDeep(reasonReferenceList, o.reasonReferenceList, true) and
      compareDeep(payloadList, o.payloadList, true) and compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirCommunication.Link : TFhirCommunication;
begin
  result := TFhirCommunication(inherited Link);
end;

function TFhirCommunication.Clone : TFhirCommunication;
begin
  result := TFhirCommunication(inherited Clone);
end;

procedure TFhirCommunication.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('definition');
  fields.add('basedOn');
  fields.add('partOf');
  fields.add('status');
  fields.add('notDone');
  fields.add('notDoneReason');
  fields.add('category');
  fields.add('medium');
  fields.add('subject');
  fields.add('recipient');
  fields.add('topic');
  fields.add('context');
  fields.add('sent');
  fields.add('received');
  fields.add('sender');
  fields.add('reasonCode');
  fields.add('reasonReference');
  fields.add('payload');
  fields.add('note');
end;

{ TFhirCommunication }

Function TFhirCommunication.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirCommunication.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Function TFhirCommunication.GetDefinitionList : TFhirReferenceList{Resource};
begin
  if FDefinitionList = nil then
    FDefinitionList := TFhirReferenceList{Resource}.Create;
  result := FDefinitionList;
end;

Function TFhirCommunication.GetHasDefinitionList : boolean;
begin
  result := (FDefinitionList <> nil) and (FDefinitionList.count > 0);
end;

Function TFhirCommunication.GetBasedOnList : TFhirReferenceList{TFhirReference};
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList{TFhirReference}.Create;
  result := FBasedOnList;
end;

Function TFhirCommunication.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

Function TFhirCommunication.GetPartOfList : TFhirReferenceList{TFhirReference};
begin
  if FPartOfList = nil then
    FPartOfList := TFhirReferenceList{TFhirReference}.Create;
  result := FPartOfList;
end;

Function TFhirCommunication.GetHasPartOfList : boolean;
begin
  result := (FPartOfList <> nil) and (FPartOfList.count > 0);
end;

Procedure TFhirCommunication.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirCommunication.GetStatusST : TFhirEventStatusEnum;
begin
  if FStatus = nil then
    result := TFhirEventStatusEnum(0)
  else
    result := TFhirEventStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirEventStatusEnum, FStatus.value));
end;

Procedure TFhirCommunication.SetStatusST(value : TFhirEventStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirEventStatusEnum[value], CODES_TFhirEventStatusEnum[value]);
end;

Procedure TFhirCommunication.SetNotDone(value : TFhirBoolean);
begin
  FNotDone.free;
  FNotDone := value;
end;

Function TFhirCommunication.GetNotDoneST : Boolean;
begin
  if FNotDone = nil then
    result := false
  else
    result := FNotDone.value;
end;

Procedure TFhirCommunication.SetNotDoneST(value : Boolean);
begin
  if FNotDone = nil then
    FNotDone := TFhirBoolean.create;
  FNotDone.value := value
end;

Procedure TFhirCommunication.SetNotDoneReason(value : TFhirCodeableConcept);
begin
  FNotDoneReason.free;
  FNotDoneReason := value;
end;

Function TFhirCommunication.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

Function TFhirCommunication.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

Function TFhirCommunication.GetMediumList : TFhirCodeableConceptList;
begin
  if FMediumList = nil then
    FMediumList := TFhirCodeableConceptList.Create;
  result := FMediumList;
end;

Function TFhirCommunication.GetHasMediumList : boolean;
begin
  result := (FMediumList <> nil) and (FMediumList.count > 0);
end;

Procedure TFhirCommunication.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Function TFhirCommunication.GetRecipientList : TFhirReferenceList{Resource};
begin
  if FRecipientList = nil then
    FRecipientList := TFhirReferenceList{Resource}.Create;
  result := FRecipientList;
end;

Function TFhirCommunication.GetHasRecipientList : boolean;
begin
  result := (FRecipientList <> nil) and (FRecipientList.count > 0);
end;

Function TFhirCommunication.GetTopicList : TFhirReferenceList{TFhirReference};
begin
  if FTopicList = nil then
    FTopicList := TFhirReferenceList{TFhirReference}.Create;
  result := FTopicList;
end;

Function TFhirCommunication.GetHasTopicList : boolean;
begin
  result := (FTopicList <> nil) and (FTopicList.count > 0);
end;

Procedure TFhirCommunication.SetContext(value : TFhirReference{Resource});
begin
  FContext.free;
  FContext := value;
end;

Procedure TFhirCommunication.SetSent(value : TFhirDateTime);
begin
  FSent.free;
  FSent := value;
end;

Function TFhirCommunication.GetSentST : TFslDateTime;
begin
  if FSent = nil then
    result := TFslDateTime.makeNull
  else
    result := FSent.value;
end;

Procedure TFhirCommunication.SetSentST(value : TFslDateTime);
begin
  if FSent = nil then
    FSent := TFhirDateTime.create;
  FSent.value := value
end;

Procedure TFhirCommunication.SetReceived(value : TFhirDateTime);
begin
  FReceived.free;
  FReceived := value;
end;

Function TFhirCommunication.GetReceivedST : TFslDateTime;
begin
  if FReceived = nil then
    result := TFslDateTime.makeNull
  else
    result := FReceived.value;
end;

Procedure TFhirCommunication.SetReceivedST(value : TFslDateTime);
begin
  if FReceived = nil then
    FReceived := TFhirDateTime.create;
  FReceived.value := value
end;

Procedure TFhirCommunication.SetSender(value : TFhirReference{Resource});
begin
  FSender.free;
  FSender := value;
end;

Function TFhirCommunication.GetReasonCodeList : TFhirCodeableConceptList;
begin
  if FReasonCodeList = nil then
    FReasonCodeList := TFhirCodeableConceptList.Create;
  result := FReasonCodeList;
end;

Function TFhirCommunication.GetHasReasonCodeList : boolean;
begin
  result := (FReasonCodeList <> nil) and (FReasonCodeList.count > 0);
end;

Function TFhirCommunication.GetReasonReferenceList : TFhirReferenceList{Resource};
begin
  if FReasonReferenceList = nil then
    FReasonReferenceList := TFhirReferenceList{Resource}.Create;
  result := FReasonReferenceList;
end;

Function TFhirCommunication.GetHasReasonReferenceList : boolean;
begin
  result := (FReasonReferenceList <> nil) and (FReasonReferenceList.count > 0);
end;

Function TFhirCommunication.GetPayloadList : TFhirCommunicationPayloadList;
begin
  if FPayloadList = nil then
    FPayloadList := TFhirCommunicationPayloadList.Create;
  result := FPayloadList;
end;

Function TFhirCommunication.GetHasPayloadList : boolean;
begin
  result := (FPayloadList <> nil) and (FPayloadList.count > 0);
end;

Function TFhirCommunication.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirCommunication.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirCommunication.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FdefinitionList.sizeInBytes);
  inc(result, FbasedOnList.sizeInBytes);
  inc(result, FpartOfList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FNotDone.sizeInBytes);
  inc(result, FNotDoneReason.sizeInBytes);
  inc(result, FcategoryList.sizeInBytes);
  inc(result, FmediumList.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FrecipientList.sizeInBytes);
  inc(result, FtopicList.sizeInBytes);
  inc(result, FContext.sizeInBytes);
  inc(result, FSent.sizeInBytes);
  inc(result, FReceived.sizeInBytes);
  inc(result, FSender.sizeInBytes);
  inc(result, FreasonCodeList.sizeInBytes);
  inc(result, FreasonReferenceList.sizeInBytes);
  inc(result, FpayloadList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
end;

{ TFhirCommunicationListEnumerator }

Constructor TFhirCommunicationListEnumerator.Create(list : TFhirCommunicationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCommunicationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCommunicationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCommunicationListEnumerator.GetCurrent : TFhirCommunication;
begin
  Result := FList[FIndex];
end;

function TFhirCommunicationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCommunicationList }
procedure TFhirCommunicationList.AddItem(value: TFhirCommunication);
begin
  assert(value.ClassName = 'TFhirCommunication', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCommunication');
  add(value);
end;

function TFhirCommunicationList.Append: TFhirCommunication;
begin
  result := TFhirCommunication.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCommunicationList.ClearItems;
begin
  Clear;
end;

function TFhirCommunicationList.GetEnumerator : TFhirCommunicationListEnumerator;
begin
  result := TFhirCommunicationListEnumerator.Create(self.link);
end;

function TFhirCommunicationList.Clone: TFhirCommunicationList;
begin
  result := TFhirCommunicationList(inherited Clone);
end;

function TFhirCommunicationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCommunicationList.GetItemN(index: Integer): TFhirCommunication;
begin
  result := TFhirCommunication(ObjectByIndex[index]);
end;

function TFhirCommunicationList.ItemClass: TFslObjectClass;
begin
  result := TFhirCommunication;
end;
function TFhirCommunicationList.IndexOf(value: TFhirCommunication): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCommunicationList.Insert(index: Integer): TFhirCommunication;
begin
  result := TFhirCommunication.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCommunicationList.InsertItem(index: Integer; value: TFhirCommunication);
begin
  assert(value is TFhirCommunication);
  Inherited Insert(index, value);
end;

function TFhirCommunicationList.Item(index: Integer): TFhirCommunication;
begin
  result := TFhirCommunication(ObjectByIndex[index]);
end;

function TFhirCommunicationList.Link: TFhirCommunicationList;
begin
  result := TFhirCommunicationList(inherited Link);
end;

procedure TFhirCommunicationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCommunicationList.SetItemByIndex(index: Integer; value: TFhirCommunication);
begin
  assert(value is TFhirCommunication);
  FhirCommunications[index] := value;
end;

procedure TFhirCommunicationList.SetItemN(index: Integer; value: TFhirCommunication);
begin
  assert(value is TFhirCommunication);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_COMMUNICATION}

{$IFDEF FHIR_COMMUNICATIONREQUEST}

{ TFhirCommunicationRequestPayload }

constructor TFhirCommunicationRequestPayload.Create;
begin
  inherited;
end;

destructor TFhirCommunicationRequestPayload.Destroy;
begin
  FContent.free;
  inherited;
end;

procedure TFhirCommunicationRequestPayload.Assign(oSource : TFslObject);
begin
  inherited;
  content := TFhirCommunicationRequestPayload(oSource).content.Clone;
end;

procedure TFhirCommunicationRequestPayload.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'content[x]') or (child_name = 'content') Then
     list.add(self.link, 'content[x]', FContent.Link);
end;

procedure TFhirCommunicationRequestPayload.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'content[x]', 'string|Attachment|Reference(Any)', false, TFhirType, FContent.Link));{2}
end;

function TFhirCommunicationRequestPayload.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['String', 'Attachment', 'Reference'])) then
  begin
    Content := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCommunicationRequestPayload.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCommunicationRequestPayload.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['String', 'Attachment', 'Reference'])) then raise EFHIRException.create('Cannot make property Content'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCommunicationRequestPayload.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'content[x]') then result := 'string|Attachment|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCommunicationRequestPayload.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['String', 'Attachment', 'Reference'])) then ContentElement := nil{4x}
  else
  inherited deleteProperty(propName, value);
end;

procedure TFhirCommunicationRequestPayload.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['String', 'Attachment', 'Reference'])) then ContentElement := new as TFhirType{4x}
  else
  inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCommunicationRequestPayload.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCommunicationRequestPayload.fhirType : string;
begin
  result := 'payload';
end;

function TFhirCommunicationRequestPayload.Link : TFhirCommunicationRequestPayload;
begin
  result := TFhirCommunicationRequestPayload(inherited Link);
end;

function TFhirCommunicationRequestPayload.Clone : TFhirCommunicationRequestPayload;
begin
  result := TFhirCommunicationRequestPayload(inherited Clone);
end;

function TFhirCommunicationRequestPayload.equals(other : TObject) : boolean;
var
  o : TFhirCommunicationRequestPayload;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCommunicationRequestPayload)) then
    result := false
  else
  begin
    o := TFhirCommunicationRequestPayload(other);
    result := compareDeep(contentElement, o.contentElement, true);
  end;
end;

function TFhirCommunicationRequestPayload.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FContent);
end;

procedure TFhirCommunicationRequestPayload.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('content[x]');
end;

{ TFhirCommunicationRequestPayload }

Procedure TFhirCommunicationRequestPayload.SetContent(value : TFhirType);
begin
  FContent.free;
  FContent := value;
end;

function TFhirCommunicationRequestPayload.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FContent.sizeInBytes);
end;

{ TFhirCommunicationRequestPayloadListEnumerator }

Constructor TFhirCommunicationRequestPayloadListEnumerator.Create(list : TFhirCommunicationRequestPayloadList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCommunicationRequestPayloadListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCommunicationRequestPayloadListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCommunicationRequestPayloadListEnumerator.GetCurrent : TFhirCommunicationRequestPayload;
begin
  Result := FList[FIndex];
end;

function TFhirCommunicationRequestPayloadListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCommunicationRequestPayloadList }
procedure TFhirCommunicationRequestPayloadList.AddItem(value: TFhirCommunicationRequestPayload);
begin
  assert(value.ClassName = 'TFhirCommunicationRequestPayload', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCommunicationRequestPayload');
  add(value);
end;

function TFhirCommunicationRequestPayloadList.Append: TFhirCommunicationRequestPayload;
begin
  result := TFhirCommunicationRequestPayload.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCommunicationRequestPayloadList.ClearItems;
begin
  Clear;
end;

function TFhirCommunicationRequestPayloadList.GetEnumerator : TFhirCommunicationRequestPayloadListEnumerator;
begin
  result := TFhirCommunicationRequestPayloadListEnumerator.Create(self.link);
end;

function TFhirCommunicationRequestPayloadList.Clone: TFhirCommunicationRequestPayloadList;
begin
  result := TFhirCommunicationRequestPayloadList(inherited Clone);
end;

function TFhirCommunicationRequestPayloadList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCommunicationRequestPayloadList.GetItemN(index: Integer): TFhirCommunicationRequestPayload;
begin
  result := TFhirCommunicationRequestPayload(ObjectByIndex[index]);
end;

function TFhirCommunicationRequestPayloadList.ItemClass: TFslObjectClass;
begin
  result := TFhirCommunicationRequestPayload;
end;
function TFhirCommunicationRequestPayloadList.IndexOf(value: TFhirCommunicationRequestPayload): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCommunicationRequestPayloadList.Insert(index: Integer): TFhirCommunicationRequestPayload;
begin
  result := TFhirCommunicationRequestPayload.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCommunicationRequestPayloadList.InsertItem(index: Integer; value: TFhirCommunicationRequestPayload);
begin
  assert(value is TFhirCommunicationRequestPayload);
  Inherited Insert(index, value);
end;

function TFhirCommunicationRequestPayloadList.Item(index: Integer): TFhirCommunicationRequestPayload;
begin
  result := TFhirCommunicationRequestPayload(ObjectByIndex[index]);
end;

function TFhirCommunicationRequestPayloadList.Link: TFhirCommunicationRequestPayloadList;
begin
  result := TFhirCommunicationRequestPayloadList(inherited Link);
end;

procedure TFhirCommunicationRequestPayloadList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCommunicationRequestPayloadList.SetItemByIndex(index: Integer; value: TFhirCommunicationRequestPayload);
begin
  assert(value is TFhirCommunicationRequestPayload);
  FhirCommunicationRequestPayloads[index] := value;
end;

procedure TFhirCommunicationRequestPayloadList.SetItemN(index: Integer; value: TFhirCommunicationRequestPayload);
begin
  assert(value is TFhirCommunicationRequestPayload);
  ObjectByIndex[index] := value;
end;

{ TFhirCommunicationRequestRequester }

constructor TFhirCommunicationRequestRequester.Create;
begin
  inherited;
end;

destructor TFhirCommunicationRequestRequester.Destroy;
begin
  FAgent.free;
  FOnBehalfOf.free;
  inherited;
end;

procedure TFhirCommunicationRequestRequester.Assign(oSource : TFslObject);
begin
  inherited;
  agent := TFhirCommunicationRequestRequester(oSource).agent.Clone;
  onBehalfOf := TFhirCommunicationRequestRequester(oSource).onBehalfOf.Clone;
end;

procedure TFhirCommunicationRequestRequester.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'agent') Then
     list.add(self.link, 'agent', FAgent.Link);
  if (child_name = 'onBehalfOf') Then
     list.add(self.link, 'onBehalfOf', FOnBehalfOf.Link);
end;

procedure TFhirCommunicationRequestRequester.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'agent', 'Reference(Practitioner|Organization|Patient|RelatedPerson|Device)', false, TFhirReference{Resource}, FAgent.Link));{2}
  oList.add(TFHIRProperty.create(self, 'onBehalfOf', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FOnBehalfOf.Link));{2}
end;

function TFhirCommunicationRequestRequester.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'agent') then
  begin
    Agent := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'onBehalfOf') then
  begin
    OnBehalfOf := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCommunicationRequestRequester.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCommunicationRequestRequester.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'agent') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'onBehalfOf') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCommunicationRequestRequester.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'agent') then result := 'Reference'
  else if (propName = 'onBehalfOf') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCommunicationRequestRequester.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'agent') then AgentElement := nil
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCommunicationRequestRequester.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'agent') then AgentElement := new as TFhirReference{Resource}{4}
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := new as TFhirReference{TFhirOrganization}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCommunicationRequestRequester.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCommunicationRequestRequester.fhirType : string;
begin
  result := 'requester';
end;

function TFhirCommunicationRequestRequester.Link : TFhirCommunicationRequestRequester;
begin
  result := TFhirCommunicationRequestRequester(inherited Link);
end;

function TFhirCommunicationRequestRequester.Clone : TFhirCommunicationRequestRequester;
begin
  result := TFhirCommunicationRequestRequester(inherited Clone);
end;

function TFhirCommunicationRequestRequester.equals(other : TObject) : boolean;
var
  o : TFhirCommunicationRequestRequester;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCommunicationRequestRequester)) then
    result := false
  else
  begin
    o := TFhirCommunicationRequestRequester(other);
    result := compareDeep(agentElement, o.agentElement, true) and compareDeep(onBehalfOfElement, o.onBehalfOfElement, true);
  end;
end;

function TFhirCommunicationRequestRequester.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAgent) and isEmptyProp(FOnBehalfOf);
end;

procedure TFhirCommunicationRequestRequester.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('agent');
  fields.add('onBehalfOf');
end;

{ TFhirCommunicationRequestRequester }

Procedure TFhirCommunicationRequestRequester.SetAgent(value : TFhirReference{Resource});
begin
  FAgent.free;
  FAgent := value;
end;

Procedure TFhirCommunicationRequestRequester.SetOnBehalfOf(value : TFhirReference{TFhirOrganization});
begin
  FOnBehalfOf.free;
  FOnBehalfOf := value;
end;

function TFhirCommunicationRequestRequester.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FAgent.sizeInBytes);
  inc(result, FOnBehalfOf.sizeInBytes);
end;

{ TFhirCommunicationRequestRequesterListEnumerator }

Constructor TFhirCommunicationRequestRequesterListEnumerator.Create(list : TFhirCommunicationRequestRequesterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCommunicationRequestRequesterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCommunicationRequestRequesterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCommunicationRequestRequesterListEnumerator.GetCurrent : TFhirCommunicationRequestRequester;
begin
  Result := FList[FIndex];
end;

function TFhirCommunicationRequestRequesterListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCommunicationRequestRequesterList }
procedure TFhirCommunicationRequestRequesterList.AddItem(value: TFhirCommunicationRequestRequester);
begin
  assert(value.ClassName = 'TFhirCommunicationRequestRequester', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCommunicationRequestRequester');
  add(value);
end;

function TFhirCommunicationRequestRequesterList.Append: TFhirCommunicationRequestRequester;
begin
  result := TFhirCommunicationRequestRequester.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCommunicationRequestRequesterList.ClearItems;
begin
  Clear;
end;

function TFhirCommunicationRequestRequesterList.GetEnumerator : TFhirCommunicationRequestRequesterListEnumerator;
begin
  result := TFhirCommunicationRequestRequesterListEnumerator.Create(self.link);
end;

function TFhirCommunicationRequestRequesterList.Clone: TFhirCommunicationRequestRequesterList;
begin
  result := TFhirCommunicationRequestRequesterList(inherited Clone);
end;

function TFhirCommunicationRequestRequesterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCommunicationRequestRequesterList.GetItemN(index: Integer): TFhirCommunicationRequestRequester;
begin
  result := TFhirCommunicationRequestRequester(ObjectByIndex[index]);
end;

function TFhirCommunicationRequestRequesterList.ItemClass: TFslObjectClass;
begin
  result := TFhirCommunicationRequestRequester;
end;
function TFhirCommunicationRequestRequesterList.IndexOf(value: TFhirCommunicationRequestRequester): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCommunicationRequestRequesterList.Insert(index: Integer): TFhirCommunicationRequestRequester;
begin
  result := TFhirCommunicationRequestRequester.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCommunicationRequestRequesterList.InsertItem(index: Integer; value: TFhirCommunicationRequestRequester);
begin
  assert(value is TFhirCommunicationRequestRequester);
  Inherited Insert(index, value);
end;

function TFhirCommunicationRequestRequesterList.Item(index: Integer): TFhirCommunicationRequestRequester;
begin
  result := TFhirCommunicationRequestRequester(ObjectByIndex[index]);
end;

function TFhirCommunicationRequestRequesterList.Link: TFhirCommunicationRequestRequesterList;
begin
  result := TFhirCommunicationRequestRequesterList(inherited Link);
end;

procedure TFhirCommunicationRequestRequesterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCommunicationRequestRequesterList.SetItemByIndex(index: Integer; value: TFhirCommunicationRequestRequester);
begin
  assert(value is TFhirCommunicationRequestRequester);
  FhirCommunicationRequestRequesters[index] := value;
end;

procedure TFhirCommunicationRequestRequesterList.SetItemN(index: Integer; value: TFhirCommunicationRequestRequester);
begin
  assert(value is TFhirCommunicationRequestRequester);
  ObjectByIndex[index] := value;
end;

{ TFhirCommunicationRequest }

constructor TFhirCommunicationRequest.Create;
begin
  inherited;
end;

destructor TFhirCommunicationRequest.Destroy;
begin
  FIdentifierList.Free;
  FBasedOnList.Free;
  FReplacesList.Free;
  FGroupIdentifier.free;
  FStatus.free;
  FCategoryList.Free;
  FPriority.free;
  FMediumList.Free;
  FSubject.free;
  FRecipientList.Free;
  FTopicList.Free;
  FContext.free;
  FPayloadList.Free;
  FOccurrence.free;
  FAuthoredOn.free;
  FSender.free;
  FRequester.free;
  FReasonCodeList.Free;
  FReasonReferenceList.Free;
  FNoteList.Free;
  inherited;
end;

function TFhirCommunicationRequest.GetResourceType : TFhirResourceType;
begin
  result := frtCommunicationRequest;
end;

procedure TFhirCommunicationRequest.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCommunicationRequest(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCommunicationRequest(oSource).FIdentifierList);
  end;
  if (TFhirCommunicationRequest(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList{TFhirReference}.Create;
    FBasedOnList.Assign(TFhirCommunicationRequest(oSource).FBasedOnList);
  end;
  if (TFhirCommunicationRequest(oSource).FReplacesList = nil) then
  begin
    FReplacesList.free;
    FReplacesList := nil;
  end
  else
  begin
    if FReplacesList = nil then
      FReplacesList := TFhirReferenceList{TFhirCommunicationRequest}.Create;
    FReplacesList.Assign(TFhirCommunicationRequest(oSource).FReplacesList);
  end;
  groupIdentifier := TFhirCommunicationRequest(oSource).groupIdentifier.Clone;
  FStatus := TFhirCommunicationRequest(oSource).FStatus.Link;
  if (TFhirCommunicationRequest(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirCommunicationRequest(oSource).FCategoryList);
  end;
  FPriority := TFhirCommunicationRequest(oSource).FPriority.Link;
  if (TFhirCommunicationRequest(oSource).FMediumList = nil) then
  begin
    FMediumList.free;
    FMediumList := nil;
  end
  else
  begin
    if FMediumList = nil then
      FMediumList := TFhirCodeableConceptList.Create;
    FMediumList.Assign(TFhirCommunicationRequest(oSource).FMediumList);
  end;
  subject := TFhirCommunicationRequest(oSource).subject.Clone;
  if (TFhirCommunicationRequest(oSource).FRecipientList = nil) then
  begin
    FRecipientList.free;
    FRecipientList := nil;
  end
  else
  begin
    if FRecipientList = nil then
      FRecipientList := TFhirReferenceList{Resource}.Create;
    FRecipientList.Assign(TFhirCommunicationRequest(oSource).FRecipientList);
  end;
  if (TFhirCommunicationRequest(oSource).FTopicList = nil) then
  begin
    FTopicList.free;
    FTopicList := nil;
  end
  else
  begin
    if FTopicList = nil then
      FTopicList := TFhirReferenceList{TFhirReference}.Create;
    FTopicList.Assign(TFhirCommunicationRequest(oSource).FTopicList);
  end;
  context := TFhirCommunicationRequest(oSource).context.Clone;
  if (TFhirCommunicationRequest(oSource).FPayloadList = nil) then
  begin
    FPayloadList.free;
    FPayloadList := nil;
  end
  else
  begin
    if FPayloadList = nil then
      FPayloadList := TFhirCommunicationRequestPayloadList.Create;
    FPayloadList.Assign(TFhirCommunicationRequest(oSource).FPayloadList);
  end;
  occurrence := TFhirCommunicationRequest(oSource).occurrence.Clone;
  authoredOnElement := TFhirCommunicationRequest(oSource).authoredOnElement.Clone;
  sender := TFhirCommunicationRequest(oSource).sender.Clone;
  requester := TFhirCommunicationRequest(oSource).requester.Clone;
  if (TFhirCommunicationRequest(oSource).FReasonCodeList = nil) then
  begin
    FReasonCodeList.free;
    FReasonCodeList := nil;
  end
  else
  begin
    if FReasonCodeList = nil then
      FReasonCodeList := TFhirCodeableConceptList.Create;
    FReasonCodeList.Assign(TFhirCommunicationRequest(oSource).FReasonCodeList);
  end;
  if (TFhirCommunicationRequest(oSource).FReasonReferenceList = nil) then
  begin
    FReasonReferenceList.free;
    FReasonReferenceList := nil;
  end
  else
  begin
    if FReasonReferenceList = nil then
      FReasonReferenceList := TFhirReferenceList{Resource}.Create;
    FReasonReferenceList.Assign(TFhirCommunicationRequest(oSource).FReasonReferenceList);
  end;
  if (TFhirCommunicationRequest(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirCommunicationRequest(oSource).FNoteList);
  end;
end;

procedure TFhirCommunicationRequest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'replaces') Then
    list.addAll(self, 'replaces', FReplacesList);
  if (child_name = 'groupIdentifier') Then
     list.add(self.link, 'groupIdentifier', FGroupIdentifier.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'medium') Then
    list.addAll(self, 'medium', FMediumList);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'recipient') Then
    list.addAll(self, 'recipient', FRecipientList);
  if (child_name = 'topic') Then
    list.addAll(self, 'topic', FTopicList);
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
  if (child_name = 'payload') Then
    list.addAll(self, 'payload', FPayloadList);
  if (child_name = 'occurrence[x]') or (child_name = 'occurrence') Then
     list.add(self.link, 'occurrence[x]', FOccurrence.Link);
  if (child_name = 'authoredOn') Then
     list.add(self.link, 'authoredOn', FAuthoredOn.Link);
  if (child_name = 'sender') Then
     list.add(self.link, 'sender', FSender.Link);
  if (child_name = 'requester') Then
     list.add(self.link, 'requester', FRequester.Link);
  if (child_name = 'reasonCode') Then
    list.addAll(self, 'reasonCode', FReasonCodeList);
  if (child_name = 'reasonReference') Then
    list.addAll(self, 'reasonReference', FReasonReferenceList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirCommunicationRequest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference(Any)', true, TFhirReference{TFhirReference}, FBasedOnList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'replaces', 'Reference(CommunicationRequest)', true, TFhirReference{TFhirCommunicationRequest}, FReplacesList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'groupIdentifier', 'Identifier', false, TFhirIdentifier, FGroupIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'priority', 'code', false, TFHIREnum, FPriority.Link));{1}
  oList.add(TFHIRProperty.create(self, 'medium', 'CodeableConcept', true, TFhirCodeableConcept, FMediumList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Group)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'recipient', 'Reference(Device|Organization|Patient|Practitioner|RelatedPerson|Group|CareTeam)', true, TFhirReference{Resource}, FRecipientList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'topic', 'Reference(Any)', true, TFhirReference{TFhirReference}, FTopicList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'context', 'Reference(Encounter|EpisodeOfCare)', false, TFhirReference{Resource}, FContext.Link));{2}
  oList.add(TFHIRProperty.create(self, 'payload', '', true, TFhirCommunicationRequestPayload, FPayloadList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'occurrence[x]', 'dateTime|Period', false, TFhirType, FOccurrence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'authoredOn', 'dateTime', false, TFhirDateTime, FAuthoredOn.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sender', 'Reference(Device|Organization|Patient|Practitioner|RelatedPerson)', false, TFhirReference{Resource}, FSender.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requester', '', false, TFhirCommunicationRequestRequester, FRequester.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reasonCode', 'CodeableConcept', true, TFhirCodeableConcept, FReasonCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reasonReference', 'Reference(Condition|Observation)', true, TFhirReference{Resource}, FReasonReferenceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
end;

function TFhirCommunicationRequest.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'replaces') then
  begin
    ReplacesList.add(propValue as TFhirReference{TFhirCommunicationRequest}){2a};
    result := propValue;
  end
  else if (propName = 'groupIdentifier') then
  begin
    GroupIdentifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirRequestStatusEnum, CODES_TFhirRequestStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, propValue);
    result := propValue
  end
  else if (propName = 'medium') then
  begin
    MediumList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'recipient') then
  begin
    RecipientList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'topic') then
  begin
    TopicList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'context') then
  begin
    Context := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'payload') then
  begin
    PayloadList.add(propValue as TFhirCommunicationRequestPayload){2a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period'])) then
  begin
    Occurrence := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'authoredOn') then
  begin
    AuthoredOnElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'sender') then
  begin
    Sender := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'requester') then
  begin
    Requester := propValue as TFhirCommunicationRequestRequester{4b};
    result := propValue;
  end
  else if (propName = 'reasonCode') then
  begin
    ReasonCodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'reasonReference') then
  begin
    ReasonReferenceList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirCommunicationRequest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'replaces') then ReplacesList.insertItem(index, propValue as TFhirReference{TFhirCommunicationRequest}){2a}
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'medium') then MediumList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'recipient') then RecipientList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'topic') then TopicList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'payload') then PayloadList.insertItem(index, propValue as TFhirCommunicationRequestPayload){2a}
  else if (propName = 'reasonCode') then ReasonCodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'reasonReference') then ReasonReferenceList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else inherited;
end;

function TFhirCommunicationRequest.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'basedOn') then result := BasedOnList.new(){2}
  else if (propName = 'replaces') then result := ReplacesList.new(){2}
  else if (propName = 'groupIdentifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'category') then result := CategoryList.new(){2}
  else if (propName = 'medium') then result := MediumList.new(){2}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'recipient') then result := RecipientList.new(){2}
  else if (propName = 'topic') then result := TopicList.new(){2}
  else if (propName = 'context') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'payload') then result := PayloadList.new(){2}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Occurrence'){4x}
  else if (propName = 'authoredOn') then result := TFhirDateTime.create() {5b}
  else if (propName = 'sender') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'requester') then result := TFhirCommunicationRequestRequester.create(){4b}
  else if (propName = 'reasonCode') then result := ReasonCodeList.new(){2}
  else if (propName = 'reasonReference') then result := ReasonReferenceList.new(){2}
  else if (propName = 'note') then result := NoteList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCommunicationRequest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'replaces') then result := 'Reference'
  else if (propName = 'groupIdentifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'priority') then result := 'code'
  else if (propName = 'medium') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'recipient') then result := 'Reference'
  else if (propName = 'topic') then result := 'Reference'
  else if (propName = 'context') then result := 'Reference'
  else if (propName = 'payload') then result := ''
  else if (propName = 'occurrence[x]') then result := 'dateTime|Period'
  else if (propName = 'authoredOn') then result := 'dateTime'
  else if (propName = 'sender') then result := 'Reference'
  else if (propName = 'requester') then result := ''
  else if (propName = 'reasonCode') then result := 'CodeableConcept'
  else if (propName = 'reasonReference') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCommunicationRequest.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value) {2}
  else if (propName = 'replaces') then deletePropertyValue('replaces', ReplacesList, value) {2}
  else if (propName = 'groupIdentifier') then GroupIdentifierElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value) {2}
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'medium') then deletePropertyValue('medium', MediumList, value) {2}
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'recipient') then deletePropertyValue('recipient', RecipientList, value) {2}
  else if (propName = 'topic') then deletePropertyValue('topic', TopicList, value) {2}
  else if (propName = 'context') then ContextElement := nil
  else if (propName = 'payload') then deletePropertyValue('payload', PayloadList, value) {2}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period'])) then OccurrenceElement := nil{4x}
  else if (propName = 'authoredOn') then AuthoredOnElement := nil
  else if (propName = 'sender') then SenderElement := nil
  else if (propName = 'requester') then RequesterElement := nil
  else if (propName = 'reasonCode') then deletePropertyValue('reasonCode', ReasonCodeList, value) {2}
  else if (propName = 'reasonReference') then deletePropertyValue('reasonReference', ReasonReferenceList, value) {2}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCommunicationRequest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new) {2}
  else if (propName = 'replaces') then replacePropertyValue('replaces', ReplacesList, existing, new) {2}
  else if (propName = 'groupIdentifier') then GroupIdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirRequestStatusEnum, CODES_TFhirRequestStatusEnum, new){4}
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new) {2}
  else if (propName = 'priority') then PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, new){4}
  else if (propName = 'medium') then replacePropertyValue('medium', MediumList, existing, new) {2}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'recipient') then replacePropertyValue('recipient', RecipientList, existing, new) {2}
  else if (propName = 'topic') then replacePropertyValue('topic', TopicList, existing, new) {2}
  else if (propName = 'context') then ContextElement := new as TFhirReference{Resource}{4}
  else if (propName = 'payload') then replacePropertyValue('payload', PayloadList, existing, new) {2}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period'])) then OccurrenceElement := new as TFhirType{4x}
  else if (propName = 'authoredOn') then AuthoredOnElement := asDateTime(new){5b}
  else if (propName = 'sender') then SenderElement := new as TFhirReference{Resource}{4}
  else if (propName = 'requester') then RequesterElement := new as TFhirCommunicationRequestRequester{4}
  else if (propName = 'reasonCode') then replacePropertyValue('reasonCode', ReasonCodeList, existing, new) {2}
  else if (propName = 'reasonReference') then replacePropertyValue('reasonReference', ReasonReferenceList, existing, new) {2}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCommunicationRequest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'basedOn') then BasedOnList.move(source, destination){2a}
  else if (propName = 'replaces') then ReplacesList.move(source, destination){2a}
  else if (propName = 'category') then CategoryList.move(source, destination){2a}
  else if (propName = 'medium') then MediumList.move(source, destination){2a}
  else if (propName = 'recipient') then RecipientList.move(source, destination){2a}
  else if (propName = 'topic') then TopicList.move(source, destination){2a}
  else if (propName = 'payload') then PayloadList.move(source, destination){2a}
  else if (propName = 'reasonCode') then ReasonCodeList.move(source, destination){2a}
  else if (propName = 'reasonReference') then ReasonReferenceList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCommunicationRequest.fhirType : string;
begin
  result := 'CommunicationRequest';
end;

function TFhirCommunicationRequest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FbasedOnList) and isEmptyProp(FreplacesList) and isEmptyProp(FGroupIdentifier) and isEmptyProp(FStatus) and isEmptyProp(FcategoryList) and isEmptyProp(FPriority) and isEmptyProp(FmediumList) and isEmptyProp(FSubject) and isEmptyProp(FrecipientList) and isEmptyProp(FtopicList) and isEmptyProp(FContext) and isEmptyProp(FpayloadList) and isEmptyProp(FOccurrence) and isEmptyProp(FAuthoredOn) and isEmptyProp(FSender) and isEmptyProp(FRequester) and isEmptyProp(FreasonCodeList) and isEmptyProp(FreasonReferenceList) and isEmptyProp(FnoteList);
end;

function TFhirCommunicationRequest.equals(other : TObject) : boolean;
var
  o : TFhirCommunicationRequest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCommunicationRequest)) then
    result := false
  else
  begin
    o := TFhirCommunicationRequest(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(basedOnList, o.basedOnList, true) and
      compareDeep(replacesList, o.replacesList, true) and compareDeep(groupIdentifierElement, o.groupIdentifierElement, true) and
      compareDeep(statusElement, o.statusElement, true) and compareDeep(categoryList, o.categoryList, true) and
      compareDeep(priorityElement, o.priorityElement, true) and compareDeep(mediumList, o.mediumList, true) and
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(recipientList, o.recipientList, true) and
      compareDeep(topicList, o.topicList, true) and compareDeep(contextElement, o.contextElement, true) and
      compareDeep(payloadList, o.payloadList, true) and compareDeep(occurrenceElement, o.occurrenceElement, true) and
      compareDeep(authoredOnElement, o.authoredOnElement, true) and compareDeep(senderElement, o.senderElement, true) and
      compareDeep(requesterElement, o.requesterElement, true) and compareDeep(reasonCodeList, o.reasonCodeList, true) and
      compareDeep(reasonReferenceList, o.reasonReferenceList, true) and compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirCommunicationRequest.Link : TFhirCommunicationRequest;
begin
  result := TFhirCommunicationRequest(inherited Link);
end;

function TFhirCommunicationRequest.Clone : TFhirCommunicationRequest;
begin
  result := TFhirCommunicationRequest(inherited Clone);
end;

procedure TFhirCommunicationRequest.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('basedOn');
  fields.add('replaces');
  fields.add('groupIdentifier');
  fields.add('status');
  fields.add('category');
  fields.add('priority');
  fields.add('medium');
  fields.add('subject');
  fields.add('recipient');
  fields.add('topic');
  fields.add('context');
  fields.add('payload');
  fields.add('occurrence[x]');
  fields.add('authoredOn');
  fields.add('sender');
  fields.add('requester');
  fields.add('reasonCode');
  fields.add('reasonReference');
  fields.add('note');
end;

{ TFhirCommunicationRequest }

Function TFhirCommunicationRequest.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirCommunicationRequest.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Function TFhirCommunicationRequest.GetBasedOnList : TFhirReferenceList{TFhirReference};
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList{TFhirReference}.Create;
  result := FBasedOnList;
end;

Function TFhirCommunicationRequest.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

Function TFhirCommunicationRequest.GetReplacesList : TFhirReferenceList{TFhirCommunicationRequest};
begin
  if FReplacesList = nil then
    FReplacesList := TFhirReferenceList{TFhirCommunicationRequest}.Create;
  result := FReplacesList;
end;

Function TFhirCommunicationRequest.GetHasReplacesList : boolean;
begin
  result := (FReplacesList <> nil) and (FReplacesList.count > 0);
end;

Procedure TFhirCommunicationRequest.SetGroupIdentifier(value : TFhirIdentifier);
begin
  FGroupIdentifier.free;
  FGroupIdentifier := value;
end;

Procedure TFhirCommunicationRequest.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirCommunicationRequest.GetStatusST : TFhirRequestStatusEnum;
begin
  if FStatus = nil then
    result := TFhirRequestStatusEnum(0)
  else
    result := TFhirRequestStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestStatusEnum, FStatus.value));
end;

Procedure TFhirCommunicationRequest.SetStatusST(value : TFhirRequestStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirRequestStatusEnum[value], CODES_TFhirRequestStatusEnum[value]);
end;

Function TFhirCommunicationRequest.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

Function TFhirCommunicationRequest.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

Procedure TFhirCommunicationRequest.SetPriority(value : TFhirEnum);
begin
  FPriority.free;
  FPriority := value;
end;

Function TFhirCommunicationRequest.GetPriorityST : TFhirRequestPriorityEnum;
begin
  if FPriority = nil then
    result := TFhirRequestPriorityEnum(0)
  else
    result := TFhirRequestPriorityEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestPriorityEnum, FPriority.value));
end;

Procedure TFhirCommunicationRequest.SetPriorityST(value : TFhirRequestPriorityEnum);
begin
  if ord(value) = 0 then
    PriorityElement := nil
  else
    PriorityElement := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[value], CODES_TFhirRequestPriorityEnum[value]);
end;

Function TFhirCommunicationRequest.GetMediumList : TFhirCodeableConceptList;
begin
  if FMediumList = nil then
    FMediumList := TFhirCodeableConceptList.Create;
  result := FMediumList;
end;

Function TFhirCommunicationRequest.GetHasMediumList : boolean;
begin
  result := (FMediumList <> nil) and (FMediumList.count > 0);
end;

Procedure TFhirCommunicationRequest.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Function TFhirCommunicationRequest.GetRecipientList : TFhirReferenceList{Resource};
begin
  if FRecipientList = nil then
    FRecipientList := TFhirReferenceList{Resource}.Create;
  result := FRecipientList;
end;

Function TFhirCommunicationRequest.GetHasRecipientList : boolean;
begin
  result := (FRecipientList <> nil) and (FRecipientList.count > 0);
end;

Function TFhirCommunicationRequest.GetTopicList : TFhirReferenceList{TFhirReference};
begin
  if FTopicList = nil then
    FTopicList := TFhirReferenceList{TFhirReference}.Create;
  result := FTopicList;
end;

Function TFhirCommunicationRequest.GetHasTopicList : boolean;
begin
  result := (FTopicList <> nil) and (FTopicList.count > 0);
end;

Procedure TFhirCommunicationRequest.SetContext(value : TFhirReference{Resource});
begin
  FContext.free;
  FContext := value;
end;

Function TFhirCommunicationRequest.GetPayloadList : TFhirCommunicationRequestPayloadList;
begin
  if FPayloadList = nil then
    FPayloadList := TFhirCommunicationRequestPayloadList.Create;
  result := FPayloadList;
end;

Function TFhirCommunicationRequest.GetHasPayloadList : boolean;
begin
  result := (FPayloadList <> nil) and (FPayloadList.count > 0);
end;

Procedure TFhirCommunicationRequest.SetOccurrence(value : TFhirType);
begin
  FOccurrence.free;
  FOccurrence := value;
end;

Procedure TFhirCommunicationRequest.SetAuthoredOn(value : TFhirDateTime);
begin
  FAuthoredOn.free;
  FAuthoredOn := value;
end;

Function TFhirCommunicationRequest.GetAuthoredOnST : TFslDateTime;
begin
  if FAuthoredOn = nil then
    result := TFslDateTime.makeNull
  else
    result := FAuthoredOn.value;
end;

Procedure TFhirCommunicationRequest.SetAuthoredOnST(value : TFslDateTime);
begin
  if FAuthoredOn = nil then
    FAuthoredOn := TFhirDateTime.create;
  FAuthoredOn.value := value
end;

Procedure TFhirCommunicationRequest.SetSender(value : TFhirReference{Resource});
begin
  FSender.free;
  FSender := value;
end;

Procedure TFhirCommunicationRequest.SetRequester(value : TFhirCommunicationRequestRequester);
begin
  FRequester.free;
  FRequester := value;
end;

Function TFhirCommunicationRequest.GetReasonCodeList : TFhirCodeableConceptList;
begin
  if FReasonCodeList = nil then
    FReasonCodeList := TFhirCodeableConceptList.Create;
  result := FReasonCodeList;
end;

Function TFhirCommunicationRequest.GetHasReasonCodeList : boolean;
begin
  result := (FReasonCodeList <> nil) and (FReasonCodeList.count > 0);
end;

Function TFhirCommunicationRequest.GetReasonReferenceList : TFhirReferenceList{Resource};
begin
  if FReasonReferenceList = nil then
    FReasonReferenceList := TFhirReferenceList{Resource}.Create;
  result := FReasonReferenceList;
end;

Function TFhirCommunicationRequest.GetHasReasonReferenceList : boolean;
begin
  result := (FReasonReferenceList <> nil) and (FReasonReferenceList.count > 0);
end;

Function TFhirCommunicationRequest.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirCommunicationRequest.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirCommunicationRequest.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FbasedOnList.sizeInBytes);
  inc(result, FreplacesList.sizeInBytes);
  inc(result, FGroupIdentifier.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FcategoryList.sizeInBytes);
  inc(result, FPriority.sizeInBytes);
  inc(result, FmediumList.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FrecipientList.sizeInBytes);
  inc(result, FtopicList.sizeInBytes);
  inc(result, FContext.sizeInBytes);
  inc(result, FpayloadList.sizeInBytes);
  inc(result, FOccurrence.sizeInBytes);
  inc(result, FAuthoredOn.sizeInBytes);
  inc(result, FSender.sizeInBytes);
  inc(result, FRequester.sizeInBytes);
  inc(result, FreasonCodeList.sizeInBytes);
  inc(result, FreasonReferenceList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
end;

{ TFhirCommunicationRequestListEnumerator }

Constructor TFhirCommunicationRequestListEnumerator.Create(list : TFhirCommunicationRequestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCommunicationRequestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCommunicationRequestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCommunicationRequestListEnumerator.GetCurrent : TFhirCommunicationRequest;
begin
  Result := FList[FIndex];
end;

function TFhirCommunicationRequestListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCommunicationRequestList }
procedure TFhirCommunicationRequestList.AddItem(value: TFhirCommunicationRequest);
begin
  assert(value.ClassName = 'TFhirCommunicationRequest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCommunicationRequest');
  add(value);
end;

function TFhirCommunicationRequestList.Append: TFhirCommunicationRequest;
begin
  result := TFhirCommunicationRequest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCommunicationRequestList.ClearItems;
begin
  Clear;
end;

function TFhirCommunicationRequestList.GetEnumerator : TFhirCommunicationRequestListEnumerator;
begin
  result := TFhirCommunicationRequestListEnumerator.Create(self.link);
end;

function TFhirCommunicationRequestList.Clone: TFhirCommunicationRequestList;
begin
  result := TFhirCommunicationRequestList(inherited Clone);
end;

function TFhirCommunicationRequestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCommunicationRequestList.GetItemN(index: Integer): TFhirCommunicationRequest;
begin
  result := TFhirCommunicationRequest(ObjectByIndex[index]);
end;

function TFhirCommunicationRequestList.ItemClass: TFslObjectClass;
begin
  result := TFhirCommunicationRequest;
end;
function TFhirCommunicationRequestList.IndexOf(value: TFhirCommunicationRequest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCommunicationRequestList.Insert(index: Integer): TFhirCommunicationRequest;
begin
  result := TFhirCommunicationRequest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCommunicationRequestList.InsertItem(index: Integer; value: TFhirCommunicationRequest);
begin
  assert(value is TFhirCommunicationRequest);
  Inherited Insert(index, value);
end;

function TFhirCommunicationRequestList.Item(index: Integer): TFhirCommunicationRequest;
begin
  result := TFhirCommunicationRequest(ObjectByIndex[index]);
end;

function TFhirCommunicationRequestList.Link: TFhirCommunicationRequestList;
begin
  result := TFhirCommunicationRequestList(inherited Link);
end;

procedure TFhirCommunicationRequestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCommunicationRequestList.SetItemByIndex(index: Integer; value: TFhirCommunicationRequest);
begin
  assert(value is TFhirCommunicationRequest);
  FhirCommunicationRequests[index] := value;
end;

procedure TFhirCommunicationRequestList.SetItemN(index: Integer; value: TFhirCommunicationRequest);
begin
  assert(value is TFhirCommunicationRequest);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_COMMUNICATIONREQUEST}

{$IFDEF FHIR_COMPOSITION}

{ TFhirCompositionAttester }

constructor TFhirCompositionAttester.Create;
begin
  inherited;
end;

destructor TFhirCompositionAttester.Destroy;
begin
  FMode.Free;
  FTime.free;
  FParty.free;
  inherited;
end;

procedure TFhirCompositionAttester.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCompositionAttester(oSource).FMode = nil) then
  begin
    FMode.free;
    FMode := nil;
  end
  else
  begin
    FMode := TFHIREnumList.Create(SYSTEMS_TFhirCompositionAttestationModeEnum, CODES_TFhirCompositionAttestationModeEnum);
    FMode.Assign(TFhirCompositionAttester(oSource).FMode);
  end;
  timeElement := TFhirCompositionAttester(oSource).timeElement.Clone;
  party := TFhirCompositionAttester(oSource).party.Clone;
end;

procedure TFhirCompositionAttester.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'mode') Then
     list.addAll(self, 'mode', FMode);
  if (child_name = 'time') Then
     list.add(self.link, 'time', FTime.Link);
  if (child_name = 'party') Then
     list.add(self.link, 'party', FParty.Link);
end;

procedure TFhirCompositionAttester.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'mode', 'code', true, TFHIREnum, FMode.Link)){3};
  oList.add(TFHIRProperty.create(self, 'time', 'dateTime', false, TFhirDateTime, FTime.Link));{2}
  oList.add(TFHIRProperty.create(self, 'party', 'Reference(Patient|Practitioner|Organization)', false, TFhirReference{Resource}, FParty.Link));{2}
end;

function TFhirCompositionAttester.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'mode') then
  begin
    ModeList.add(asEnum(SYSTEMS_TFhirCompositionAttestationModeEnum, CODES_TFhirCompositionAttestationModeEnum, propValue)); {1}
    result := propValue;
  end
  else if (propName = 'time') then
  begin
    TimeElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'party') then
  begin
    Party := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCompositionAttester.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'mode') then FMode.insertItem(index, asEnum(SYSTEMS_TFhirCompositionAttestationModeEnum, CODES_TFhirCompositionAttestationModeEnum, propValue)) {1}
  else inherited;
end;

function TFhirCompositionAttester.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'time') then result := TFhirDateTime.create() {5b}
  else if (propName = 'party') then result := TFhirReference{Resource}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCompositionAttester.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'mode') then result := 'code'
  else if (propName = 'time') then result := 'dateTime'
  else if (propName = 'party') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCompositionAttester.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'time') then TimeElement := nil
  else if (propName = 'party') then PartyElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCompositionAttester.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'time') then TimeElement := asDateTime(new){5b}
  else if (propName = 'party') then PartyElement := new as TFhirReference{Resource}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCompositionAttester.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'mode') then FMode.move(source, destination) {1}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCompositionAttester.fhirType : string;
begin
  result := 'attester';
end;

function TFhirCompositionAttester.Link : TFhirCompositionAttester;
begin
  result := TFhirCompositionAttester(inherited Link);
end;

function TFhirCompositionAttester.Clone : TFhirCompositionAttester;
begin
  result := TFhirCompositionAttester(inherited Clone);
end;

function TFhirCompositionAttester.equals(other : TObject) : boolean;
var
  o : TFhirCompositionAttester;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCompositionAttester)) then
    result := false
  else
  begin
    o := TFhirCompositionAttester(other);
    result := compareDeep(modeList, o.modeList, true) and compareDeep(timeElement, o.timeElement, true) and
      compareDeep(partyElement, o.partyElement, true);
  end;
end;

function TFhirCompositionAttester.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMode) and isEmptyProp(FTime) and isEmptyProp(FParty);
end;

procedure TFhirCompositionAttester.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('mode');
  fields.add('time');
  fields.add('party');
end;

{ TFhirCompositionAttester }

Function TFhirCompositionAttester.GetMode : TFhirEnumList;
begin
  if FMode = nil then
    FMode := TFHIREnumList.Create(SYSTEMS_TFhirCompositionAttestationModeEnum, CODES_TFhirCompositionAttestationModeEnum);
  result := FMode;
end;

Function TFhirCompositionAttester.GetHasMode : boolean;
begin
  result := (FMode <> nil) and (FMode.count > 0);
end;

Function TFhirCompositionAttester.GetModeST : TFhirCompositionAttestationModeEnumList;
  var i : integer;
begin
  result := [];
  if Fmode <> nil then
    for i := 0 to Fmode.count - 1 do
      result := result + [TFhirCompositionAttestationModeEnum(StringArrayIndexOfSensitive(CODES_TFhirCompositionAttestationModeEnum, Fmode[i].value))];
end;

Procedure TFhirCompositionAttester.SetModeST(value : TFhirCompositionAttestationModeEnumList);
var a : TFhirCompositionAttestationModeEnum;
begin
  if Fmode = nil then
    Fmode := TFhirEnumList.create(SYSTEMS_TFhirCompositionAttestationModeEnum, CODES_TFhirCompositionAttestationModeEnum);
  Fmode.clear;
  for a := low(TFhirCompositionAttestationModeEnum) to high(TFhirCompositionAttestationModeEnum) do
    if a in value then
      begin
         if Fmode = nil then
           Fmode := TFhirEnumList.create(SYSTEMS_TFhirCompositionAttestationModeEnum, CODES_TFhirCompositionAttestationModeEnum);
         Fmode.add(TFhirEnum.create(SYSTEMS_TFhirCompositionAttestationModeEnum[a], CODES_TFhirCompositionAttestationModeEnum[a]));
      end;
end;

Procedure TFhirCompositionAttester.SetTime(value : TFhirDateTime);
begin
  FTime.free;
  FTime := value;
end;

Function TFhirCompositionAttester.GetTimeST : TFslDateTime;
begin
  if FTime = nil then
    result := TFslDateTime.makeNull
  else
    result := FTime.value;
end;

Procedure TFhirCompositionAttester.SetTimeST(value : TFslDateTime);
begin
  if FTime = nil then
    FTime := TFhirDateTime.create;
  FTime.value := value
end;

Procedure TFhirCompositionAttester.SetParty(value : TFhirReference{Resource});
begin
  FParty.free;
  FParty := value;
end;

function TFhirCompositionAttester.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FMode.sizeInBytes);
  inc(result, FTime.sizeInBytes);
  inc(result, FParty.sizeInBytes);
end;

{ TFhirCompositionAttesterListEnumerator }

Constructor TFhirCompositionAttesterListEnumerator.Create(list : TFhirCompositionAttesterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCompositionAttesterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCompositionAttesterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCompositionAttesterListEnumerator.GetCurrent : TFhirCompositionAttester;
begin
  Result := FList[FIndex];
end;

function TFhirCompositionAttesterListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCompositionAttesterList }
procedure TFhirCompositionAttesterList.AddItem(value: TFhirCompositionAttester);
begin
  assert(value.ClassName = 'TFhirCompositionAttester', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCompositionAttester');
  add(value);
end;

function TFhirCompositionAttesterList.Append: TFhirCompositionAttester;
begin
  result := TFhirCompositionAttester.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompositionAttesterList.ClearItems;
begin
  Clear;
end;

function TFhirCompositionAttesterList.GetEnumerator : TFhirCompositionAttesterListEnumerator;
begin
  result := TFhirCompositionAttesterListEnumerator.Create(self.link);
end;

function TFhirCompositionAttesterList.Clone: TFhirCompositionAttesterList;
begin
  result := TFhirCompositionAttesterList(inherited Clone);
end;

function TFhirCompositionAttesterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCompositionAttesterList.GetItemN(index: Integer): TFhirCompositionAttester;
begin
  result := TFhirCompositionAttester(ObjectByIndex[index]);
end;

function TFhirCompositionAttesterList.ItemClass: TFslObjectClass;
begin
  result := TFhirCompositionAttester;
end;
function TFhirCompositionAttesterList.IndexOf(value: TFhirCompositionAttester): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCompositionAttesterList.Insert(index: Integer): TFhirCompositionAttester;
begin
  result := TFhirCompositionAttester.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompositionAttesterList.InsertItem(index: Integer; value: TFhirCompositionAttester);
begin
  assert(value is TFhirCompositionAttester);
  Inherited Insert(index, value);
end;

function TFhirCompositionAttesterList.Item(index: Integer): TFhirCompositionAttester;
begin
  result := TFhirCompositionAttester(ObjectByIndex[index]);
end;

function TFhirCompositionAttesterList.Link: TFhirCompositionAttesterList;
begin
  result := TFhirCompositionAttesterList(inherited Link);
end;

procedure TFhirCompositionAttesterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCompositionAttesterList.SetItemByIndex(index: Integer; value: TFhirCompositionAttester);
begin
  assert(value is TFhirCompositionAttester);
  FhirCompositionAttesters[index] := value;
end;

procedure TFhirCompositionAttesterList.SetItemN(index: Integer; value: TFhirCompositionAttester);
begin
  assert(value is TFhirCompositionAttester);
  ObjectByIndex[index] := value;
end;

{ TFhirCompositionRelatesTo }

constructor TFhirCompositionRelatesTo.Create;
begin
  inherited;
end;

destructor TFhirCompositionRelatesTo.Destroy;
begin
  FCode.free;
  FTarget.free;
  inherited;
end;

procedure TFhirCompositionRelatesTo.Assign(oSource : TFslObject);
begin
  inherited;
  FCode := TFhirCompositionRelatesTo(oSource).FCode.Link;
  target := TFhirCompositionRelatesTo(oSource).target.Clone;
end;

procedure TFhirCompositionRelatesTo.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'target[x]') or (child_name = 'target') Then
     list.add(self.link, 'target[x]', FTarget.Link);
end;

procedure TFhirCompositionRelatesTo.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFHIREnum, FCode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'target[x]', 'Identifier|Reference(Composition)', false, TFhirType, FTarget.Link));{2}
end;

function TFhirCompositionRelatesTo.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asEnum(SYSTEMS_TFhirDocumentRelationshipTypeEnum, CODES_TFhirDocumentRelationshipTypeEnum, propValue);
    result := propValue
  end
  else if (isMatchingName(propName, 'target', ['Identifier', 'Reference'])) then
  begin
    Target := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCompositionRelatesTo.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCompositionRelatesTo.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'target', ['Identifier', 'Reference'])) then raise EFHIRException.create('Cannot make property Target'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCompositionRelatesTo.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'code'
  else if (propName = 'target[x]') then result := 'Identifier|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCompositionRelatesTo.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (isMatchingName(propName, 'target', ['Identifier', 'Reference'])) then TargetElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCompositionRelatesTo.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asEnum(SYSTEMS_TFhirDocumentRelationshipTypeEnum, CODES_TFhirDocumentRelationshipTypeEnum, new){4}
  else if (isMatchingName(propName, 'target', ['Identifier', 'Reference'])) then TargetElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCompositionRelatesTo.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCompositionRelatesTo.fhirType : string;
begin
  result := 'relatesTo';
end;

function TFhirCompositionRelatesTo.Link : TFhirCompositionRelatesTo;
begin
  result := TFhirCompositionRelatesTo(inherited Link);
end;

function TFhirCompositionRelatesTo.Clone : TFhirCompositionRelatesTo;
begin
  result := TFhirCompositionRelatesTo(inherited Clone);
end;

function TFhirCompositionRelatesTo.equals(other : TObject) : boolean;
var
  o : TFhirCompositionRelatesTo;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCompositionRelatesTo)) then
    result := false
  else
  begin
    o := TFhirCompositionRelatesTo(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(targetElement, o.targetElement, true);
  end;
end;

function TFhirCompositionRelatesTo.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FTarget);
end;

procedure TFhirCompositionRelatesTo.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('target[x]');
end;

{ TFhirCompositionRelatesTo }

Procedure TFhirCompositionRelatesTo.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirCompositionRelatesTo.GetCodeST : TFhirDocumentRelationshipTypeEnum;
begin
  if FCode = nil then
    result := TFhirDocumentRelationshipTypeEnum(0)
  else
    result := TFhirDocumentRelationshipTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirDocumentRelationshipTypeEnum, FCode.value));
end;

Procedure TFhirCompositionRelatesTo.SetCodeST(value : TFhirDocumentRelationshipTypeEnum);
begin
  if ord(value) = 0 then
    CodeElement := nil
  else
    CodeElement := TFhirEnum.create(SYSTEMS_TFhirDocumentRelationshipTypeEnum[value], CODES_TFhirDocumentRelationshipTypeEnum[value]);
end;

Procedure TFhirCompositionRelatesTo.SetTarget(value : TFhirType);
begin
  FTarget.free;
  FTarget := value;
end;

function TFhirCompositionRelatesTo.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FTarget.sizeInBytes);
end;

{ TFhirCompositionRelatesToListEnumerator }

Constructor TFhirCompositionRelatesToListEnumerator.Create(list : TFhirCompositionRelatesToList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCompositionRelatesToListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCompositionRelatesToListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCompositionRelatesToListEnumerator.GetCurrent : TFhirCompositionRelatesTo;
begin
  Result := FList[FIndex];
end;

function TFhirCompositionRelatesToListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCompositionRelatesToList }
procedure TFhirCompositionRelatesToList.AddItem(value: TFhirCompositionRelatesTo);
begin
  assert(value.ClassName = 'TFhirCompositionRelatesTo', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCompositionRelatesTo');
  add(value);
end;

function TFhirCompositionRelatesToList.Append: TFhirCompositionRelatesTo;
begin
  result := TFhirCompositionRelatesTo.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompositionRelatesToList.ClearItems;
begin
  Clear;
end;

function TFhirCompositionRelatesToList.GetEnumerator : TFhirCompositionRelatesToListEnumerator;
begin
  result := TFhirCompositionRelatesToListEnumerator.Create(self.link);
end;

function TFhirCompositionRelatesToList.Clone: TFhirCompositionRelatesToList;
begin
  result := TFhirCompositionRelatesToList(inherited Clone);
end;

function TFhirCompositionRelatesToList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCompositionRelatesToList.GetItemN(index: Integer): TFhirCompositionRelatesTo;
begin
  result := TFhirCompositionRelatesTo(ObjectByIndex[index]);
end;

function TFhirCompositionRelatesToList.ItemClass: TFslObjectClass;
begin
  result := TFhirCompositionRelatesTo;
end;
function TFhirCompositionRelatesToList.IndexOf(value: TFhirCompositionRelatesTo): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCompositionRelatesToList.Insert(index: Integer): TFhirCompositionRelatesTo;
begin
  result := TFhirCompositionRelatesTo.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompositionRelatesToList.InsertItem(index: Integer; value: TFhirCompositionRelatesTo);
begin
  assert(value is TFhirCompositionRelatesTo);
  Inherited Insert(index, value);
end;

function TFhirCompositionRelatesToList.Item(index: Integer): TFhirCompositionRelatesTo;
begin
  result := TFhirCompositionRelatesTo(ObjectByIndex[index]);
end;

function TFhirCompositionRelatesToList.Link: TFhirCompositionRelatesToList;
begin
  result := TFhirCompositionRelatesToList(inherited Link);
end;

procedure TFhirCompositionRelatesToList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCompositionRelatesToList.SetItemByIndex(index: Integer; value: TFhirCompositionRelatesTo);
begin
  assert(value is TFhirCompositionRelatesTo);
  FhirCompositionRelatesTos[index] := value;
end;

procedure TFhirCompositionRelatesToList.SetItemN(index: Integer; value: TFhirCompositionRelatesTo);
begin
  assert(value is TFhirCompositionRelatesTo);
  ObjectByIndex[index] := value;
end;

{ TFhirCompositionEvent }

constructor TFhirCompositionEvent.Create;
begin
  inherited;
end;

destructor TFhirCompositionEvent.Destroy;
begin
  FCodeList.Free;
  FPeriod.free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirCompositionEvent.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCompositionEvent(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirCodeableConceptList.Create;
    FCodeList.Assign(TFhirCompositionEvent(oSource).FCodeList);
  end;
  period := TFhirCompositionEvent(oSource).period.Clone;
  if (TFhirCompositionEvent(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirReferenceList{TFhirReference}.Create;
    FDetailList.Assign(TFhirCompositionEvent(oSource).FDetailList);
  end;
end;

procedure TFhirCompositionEvent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
end;

procedure TFhirCompositionEvent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', true, TFhirCodeableConcept, FCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'detail', 'Reference(Any)', true, TFhirReference{TFhirReference}, FDetailList.Link)){3};
end;

function TFhirCompositionEvent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCompositionEvent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else inherited;
end;

function TFhirCompositionEvent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := CodeList.new(){2}
  else if (propName = 'period') then result := TFhirPeriod.create(){4b}
  else if (propName = 'detail') then result := DetailList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCompositionEvent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'detail') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCompositionEvent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then deletePropertyValue('code', CodeList, value) {2}
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCompositionEvent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new) {2}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCompositionEvent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'code') then CodeList.move(source, destination){2a}
  else if (propName = 'detail') then DetailList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCompositionEvent.fhirType : string;
begin
  result := 'event';
end;

function TFhirCompositionEvent.Link : TFhirCompositionEvent;
begin
  result := TFhirCompositionEvent(inherited Link);
end;

function TFhirCompositionEvent.Clone : TFhirCompositionEvent;
begin
  result := TFhirCompositionEvent(inherited Clone);
end;

function TFhirCompositionEvent.equals(other : TObject) : boolean;
var
  o : TFhirCompositionEvent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCompositionEvent)) then
    result := false
  else
  begin
    o := TFhirCompositionEvent(other);
    result := compareDeep(codeList, o.codeList, true) and compareDeep(periodElement, o.periodElement, true) and
      compareDeep(detailList, o.detailList, true);
  end;
end;

function TFhirCompositionEvent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FcodeList) and isEmptyProp(FPeriod) and isEmptyProp(FdetailList);
end;

procedure TFhirCompositionEvent.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('period');
  fields.add('detail');
end;

{ TFhirCompositionEvent }

Function TFhirCompositionEvent.GetCodeList : TFhirCodeableConceptList;
begin
  if FCodeList = nil then
    FCodeList := TFhirCodeableConceptList.Create;
  result := FCodeList;
end;

Function TFhirCompositionEvent.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

Procedure TFhirCompositionEvent.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Function TFhirCompositionEvent.GetDetailList : TFhirReferenceList{TFhirReference};
begin
  if FDetailList = nil then
    FDetailList := TFhirReferenceList{TFhirReference}.Create;
  result := FDetailList;
end;

Function TFhirCompositionEvent.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

function TFhirCompositionEvent.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FcodeList.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FdetailList.sizeInBytes);
end;

{ TFhirCompositionEventListEnumerator }

Constructor TFhirCompositionEventListEnumerator.Create(list : TFhirCompositionEventList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCompositionEventListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCompositionEventListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCompositionEventListEnumerator.GetCurrent : TFhirCompositionEvent;
begin
  Result := FList[FIndex];
end;

function TFhirCompositionEventListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCompositionEventList }
procedure TFhirCompositionEventList.AddItem(value: TFhirCompositionEvent);
begin
  assert(value.ClassName = 'TFhirCompositionEvent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCompositionEvent');
  add(value);
end;

function TFhirCompositionEventList.Append: TFhirCompositionEvent;
begin
  result := TFhirCompositionEvent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompositionEventList.ClearItems;
begin
  Clear;
end;

function TFhirCompositionEventList.GetEnumerator : TFhirCompositionEventListEnumerator;
begin
  result := TFhirCompositionEventListEnumerator.Create(self.link);
end;

function TFhirCompositionEventList.Clone: TFhirCompositionEventList;
begin
  result := TFhirCompositionEventList(inherited Clone);
end;

function TFhirCompositionEventList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCompositionEventList.GetItemN(index: Integer): TFhirCompositionEvent;
begin
  result := TFhirCompositionEvent(ObjectByIndex[index]);
end;

function TFhirCompositionEventList.ItemClass: TFslObjectClass;
begin
  result := TFhirCompositionEvent;
end;
function TFhirCompositionEventList.IndexOf(value: TFhirCompositionEvent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCompositionEventList.Insert(index: Integer): TFhirCompositionEvent;
begin
  result := TFhirCompositionEvent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompositionEventList.InsertItem(index: Integer; value: TFhirCompositionEvent);
begin
  assert(value is TFhirCompositionEvent);
  Inherited Insert(index, value);
end;

function TFhirCompositionEventList.Item(index: Integer): TFhirCompositionEvent;
begin
  result := TFhirCompositionEvent(ObjectByIndex[index]);
end;

function TFhirCompositionEventList.Link: TFhirCompositionEventList;
begin
  result := TFhirCompositionEventList(inherited Link);
end;

procedure TFhirCompositionEventList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCompositionEventList.SetItemByIndex(index: Integer; value: TFhirCompositionEvent);
begin
  assert(value is TFhirCompositionEvent);
  FhirCompositionEvents[index] := value;
end;

procedure TFhirCompositionEventList.SetItemN(index: Integer; value: TFhirCompositionEvent);
begin
  assert(value is TFhirCompositionEvent);
  ObjectByIndex[index] := value;
end;

{ TFhirCompositionSection }

constructor TFhirCompositionSection.Create;
begin
  inherited;
end;

destructor TFhirCompositionSection.Destroy;
begin
  FTitle.free;
  FCode.free;
  FText.free;
  FMode.free;
  FOrderedBy.free;
  FEntryList.Free;
  FEmptyReason.free;
  FSectionList.Free;
  inherited;
end;

procedure TFhirCompositionSection.Assign(oSource : TFslObject);
begin
  inherited;
  titleElement := TFhirCompositionSection(oSource).titleElement.Clone;
  code := TFhirCompositionSection(oSource).code.Clone;
  text := TFhirCompositionSection(oSource).text.Clone;
  FMode := TFhirCompositionSection(oSource).FMode.Link;
  orderedBy := TFhirCompositionSection(oSource).orderedBy.Clone;
  if (TFhirCompositionSection(oSource).FEntryList = nil) then
  begin
    FEntryList.free;
    FEntryList := nil;
  end
  else
  begin
    if FEntryList = nil then
      FEntryList := TFhirReferenceList{TFhirReference}.Create;
    FEntryList.Assign(TFhirCompositionSection(oSource).FEntryList);
  end;
  emptyReason := TFhirCompositionSection(oSource).emptyReason.Clone;
  if (TFhirCompositionSection(oSource).FSectionList = nil) then
  begin
    FSectionList.free;
    FSectionList := nil;
  end
  else
  begin
    if FSectionList = nil then
      FSectionList := TFhirCompositionSectionList.Create;
    FSectionList.Assign(TFhirCompositionSection(oSource).FSectionList);
  end;
end;

procedure TFhirCompositionSection.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'mode') Then
     list.add(self.link, 'mode', FMode.Link);
  if (child_name = 'orderedBy') Then
     list.add(self.link, 'orderedBy', FOrderedBy.Link);
  if (child_name = 'entry') Then
    list.addAll(self, 'entry', FEntryList);
  if (child_name = 'emptyReason') Then
     list.add(self.link, 'emptyReason', FEmptyReason.Link);
  if (child_name = 'section') Then
    list.addAll(self, 'section', FSectionList);
end;

procedure TFhirCompositionSection.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'text', 'Narrative', false, TFhirNarrative, FText.Link));{2}
  oList.add(TFHIRProperty.create(self, 'mode', 'code', false, TFHIREnum, FMode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'orderedBy', 'CodeableConcept', false, TFhirCodeableConcept, FOrderedBy.Link));{2}
  oList.add(TFHIRProperty.create(self, 'entry', 'Reference(Any)', true, TFhirReference{TFhirReference}, FEntryList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'emptyReason', 'CodeableConcept', false, TFhirCodeableConcept, FEmptyReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'section', '@Composition.section', true, TFhirCompositionSection, FSectionList.Link)){3};
end;

function TFhirCompositionSection.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'title') then
  begin
    TitleElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    Text := propValue as TFhirNarrative{4b};
    result := propValue;
  end
  else if (propName = 'mode') then
  begin
    ModeElement := asEnum(SYSTEMS_TFhirListModeEnum, CODES_TFhirListModeEnum, propValue);
    result := propValue
  end
  else if (propName = 'orderedBy') then
  begin
    OrderedBy := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'entry') then
  begin
    EntryList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'emptyReason') then
  begin
    EmptyReason := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'section') then
  begin
    SectionList.add(propValue as TFhirCompositionSection){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCompositionSection.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'entry') then EntryList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'section') then SectionList.insertItem(index, propValue as TFhirCompositionSection){2a}
  else inherited;
end;

function TFhirCompositionSection.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'title') then result := TFhirString.create() {5b}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'text') then result := TFhirNarrative.create(){4b}
  else if (propName = 'orderedBy') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'entry') then result := EntryList.new(){2}
  else if (propName = 'emptyReason') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'section') then result := SectionList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCompositionSection.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'title') then result := 'string'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'text') then result := 'Narrative'
  else if (propName = 'mode') then result := 'code'
  else if (propName = 'orderedBy') then result := 'CodeableConcept'
  else if (propName = 'entry') then result := 'Reference'
  else if (propName = 'emptyReason') then result := 'CodeableConcept'
  else if (propName = 'section') then result := '@Composition.section'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCompositionSection.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'title') then TitleElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'text') then TextElement := nil
  else if (propName = 'mode') then ModeElement := nil
  else if (propName = 'orderedBy') then OrderedByElement := nil
  else if (propName = 'entry') then deletePropertyValue('entry', EntryList, value) {2}
  else if (propName = 'emptyReason') then EmptyReasonElement := nil
  else if (propName = 'section') then deletePropertyValue('section', SectionList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCompositionSection.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'title') then TitleElement := asString(new){5b}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'text') then TextElement := new as TFhirNarrative{4}
  else if (propName = 'mode') then ModeElement := asEnum(SYSTEMS_TFhirListModeEnum, CODES_TFhirListModeEnum, new){4}
  else if (propName = 'orderedBy') then OrderedByElement := new as TFhirCodeableConcept{4}
  else if (propName = 'entry') then replacePropertyValue('entry', EntryList, existing, new) {2}
  else if (propName = 'emptyReason') then EmptyReasonElement := new as TFhirCodeableConcept{4}
  else if (propName = 'section') then replacePropertyValue('section', SectionList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCompositionSection.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'entry') then EntryList.move(source, destination){2a}
  else if (propName = 'section') then SectionList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCompositionSection.fhirType : string;
begin
  result := 'section';
end;

function TFhirCompositionSection.Link : TFhirCompositionSection;
begin
  result := TFhirCompositionSection(inherited Link);
end;

function TFhirCompositionSection.Clone : TFhirCompositionSection;
begin
  result := TFhirCompositionSection(inherited Clone);
end;

function TFhirCompositionSection.equals(other : TObject) : boolean;
var
  o : TFhirCompositionSection;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCompositionSection)) then
    result := false
  else
  begin
    o := TFhirCompositionSection(other);
    result := compareDeep(titleElement, o.titleElement, true) and compareDeep(codeElement, o.codeElement, true) and
      compareDeep(textElement, o.textElement, true) and compareDeep(modeElement, o.modeElement, true) and
      compareDeep(orderedByElement, o.orderedByElement, true) and compareDeep(entryList, o.entryList, true) and
      compareDeep(emptyReasonElement, o.emptyReasonElement, true) and compareDeep(sectionList, o.sectionList, true);
  end;
end;

function TFhirCompositionSection.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FTitle) and isEmptyProp(FCode) and isEmptyProp(FText) and isEmptyProp(FMode) and isEmptyProp(FOrderedBy) and isEmptyProp(FentryList) and isEmptyProp(FEmptyReason) and isEmptyProp(FsectionList);
end;

procedure TFhirCompositionSection.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('title');
  fields.add('code');
  fields.add('text');
  fields.add('mode');
  fields.add('orderedBy');
  fields.add('entry');
  fields.add('emptyReason');
  fields.add('section');
end;

{ TFhirCompositionSection }

Procedure TFhirCompositionSection.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

Function TFhirCompositionSection.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

Procedure TFhirCompositionSection.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

Procedure TFhirCompositionSection.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirCompositionSection.SetText(value : TFhirNarrative);
begin
  FText.free;
  FText := value;
end;

Procedure TFhirCompositionSection.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

Function TFhirCompositionSection.GetModeST : TFhirListModeEnum;
begin
  if FMode = nil then
    result := TFhirListModeEnum(0)
  else
    result := TFhirListModeEnum(StringArrayIndexOfSensitive(CODES_TFhirListModeEnum, FMode.value));
end;

Procedure TFhirCompositionSection.SetModeST(value : TFhirListModeEnum);
begin
  if ord(value) = 0 then
    ModeElement := nil
  else
    ModeElement := TFhirEnum.create(SYSTEMS_TFhirListModeEnum[value], CODES_TFhirListModeEnum[value]);
end;

Procedure TFhirCompositionSection.SetOrderedBy(value : TFhirCodeableConcept);
begin
  FOrderedBy.free;
  FOrderedBy := value;
end;

Function TFhirCompositionSection.GetEntryList : TFhirReferenceList{TFhirReference};
begin
  if FEntryList = nil then
    FEntryList := TFhirReferenceList{TFhirReference}.Create;
  result := FEntryList;
end;

Function TFhirCompositionSection.GetHasEntryList : boolean;
begin
  result := (FEntryList <> nil) and (FEntryList.count > 0);
end;

Procedure TFhirCompositionSection.SetEmptyReason(value : TFhirCodeableConcept);
begin
  FEmptyReason.free;
  FEmptyReason := value;
end;

Function TFhirCompositionSection.GetSectionList : TFhirCompositionSectionList;
begin
  if FSectionList = nil then
    FSectionList := TFhirCompositionSectionList.Create;
  result := FSectionList;
end;

Function TFhirCompositionSection.GetHasSectionList : boolean;
begin
  result := (FSectionList <> nil) and (FSectionList.count > 0);
end;

function TFhirCompositionSection.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FTitle.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FText.sizeInBytes);
  inc(result, FMode.sizeInBytes);
  inc(result, FOrderedBy.sizeInBytes);
  inc(result, FentryList.sizeInBytes);
  inc(result, FEmptyReason.sizeInBytes);
  inc(result, FsectionList.sizeInBytes);
end;

{ TFhirCompositionSectionListEnumerator }

Constructor TFhirCompositionSectionListEnumerator.Create(list : TFhirCompositionSectionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCompositionSectionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCompositionSectionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCompositionSectionListEnumerator.GetCurrent : TFhirCompositionSection;
begin
  Result := FList[FIndex];
end;

function TFhirCompositionSectionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCompositionSectionList }
procedure TFhirCompositionSectionList.AddItem(value: TFhirCompositionSection);
begin
  assert(value.ClassName = 'TFhirCompositionSection', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCompositionSection');
  add(value);
end;

function TFhirCompositionSectionList.Append: TFhirCompositionSection;
begin
  result := TFhirCompositionSection.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompositionSectionList.ClearItems;
begin
  Clear;
end;

function TFhirCompositionSectionList.GetEnumerator : TFhirCompositionSectionListEnumerator;
begin
  result := TFhirCompositionSectionListEnumerator.Create(self.link);
end;

function TFhirCompositionSectionList.Clone: TFhirCompositionSectionList;
begin
  result := TFhirCompositionSectionList(inherited Clone);
end;

function TFhirCompositionSectionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCompositionSectionList.GetItemN(index: Integer): TFhirCompositionSection;
begin
  result := TFhirCompositionSection(ObjectByIndex[index]);
end;

function TFhirCompositionSectionList.ItemClass: TFslObjectClass;
begin
  result := TFhirCompositionSection;
end;
function TFhirCompositionSectionList.IndexOf(value: TFhirCompositionSection): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCompositionSectionList.Insert(index: Integer): TFhirCompositionSection;
begin
  result := TFhirCompositionSection.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompositionSectionList.InsertItem(index: Integer; value: TFhirCompositionSection);
begin
  assert(value is TFhirCompositionSection);
  Inherited Insert(index, value);
end;

function TFhirCompositionSectionList.Item(index: Integer): TFhirCompositionSection;
begin
  result := TFhirCompositionSection(ObjectByIndex[index]);
end;

function TFhirCompositionSectionList.Link: TFhirCompositionSectionList;
begin
  result := TFhirCompositionSectionList(inherited Link);
end;

procedure TFhirCompositionSectionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCompositionSectionList.SetItemByIndex(index: Integer; value: TFhirCompositionSection);
begin
  assert(value is TFhirCompositionSection);
  FhirCompositionSections[index] := value;
end;

procedure TFhirCompositionSectionList.SetItemN(index: Integer; value: TFhirCompositionSection);
begin
  assert(value is TFhirCompositionSection);
  ObjectByIndex[index] := value;
end;

{ TFhirComposition }

constructor TFhirComposition.Create;
begin
  inherited;
end;

destructor TFhirComposition.Destroy;
begin
  FIdentifier.free;
  FStatus.free;
  FType_.free;
  FClass_.free;
  FSubject.free;
  FEncounter.free;
  FDate.free;
  FAuthorList.Free;
  FTitle.free;
  FConfidentiality.free;
  FAttesterList.Free;
  FCustodian.free;
  FRelatesToList.Free;
  FEventList.Free;
  FSectionList.Free;
  inherited;
end;

function TFhirComposition.GetResourceType : TFhirResourceType;
begin
  result := frtComposition;
end;

procedure TFhirComposition.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirComposition(oSource).identifier.Clone;
  FStatus := TFhirComposition(oSource).FStatus.Link;
  type_ := TFhirComposition(oSource).type_.Clone;
  class_ := TFhirComposition(oSource).class_.Clone;
  subject := TFhirComposition(oSource).subject.Clone;
  encounter := TFhirComposition(oSource).encounter.Clone;
  dateElement := TFhirComposition(oSource).dateElement.Clone;
  if (TFhirComposition(oSource).FAuthorList = nil) then
  begin
    FAuthorList.free;
    FAuthorList := nil;
  end
  else
  begin
    if FAuthorList = nil then
      FAuthorList := TFhirReferenceList{Resource}.Create;
    FAuthorList.Assign(TFhirComposition(oSource).FAuthorList);
  end;
  titleElement := TFhirComposition(oSource).titleElement.Clone;
  FConfidentiality := TFhirComposition(oSource).FConfidentiality.Link;
  if (TFhirComposition(oSource).FAttesterList = nil) then
  begin
    FAttesterList.free;
    FAttesterList := nil;
  end
  else
  begin
    if FAttesterList = nil then
      FAttesterList := TFhirCompositionAttesterList.Create;
    FAttesterList.Assign(TFhirComposition(oSource).FAttesterList);
  end;
  custodian := TFhirComposition(oSource).custodian.Clone;
  if (TFhirComposition(oSource).FRelatesToList = nil) then
  begin
    FRelatesToList.free;
    FRelatesToList := nil;
  end
  else
  begin
    if FRelatesToList = nil then
      FRelatesToList := TFhirCompositionRelatesToList.Create;
    FRelatesToList.Assign(TFhirComposition(oSource).FRelatesToList);
  end;
  if (TFhirComposition(oSource).FEventList = nil) then
  begin
    FEventList.free;
    FEventList := nil;
  end
  else
  begin
    if FEventList = nil then
      FEventList := TFhirCompositionEventList.Create;
    FEventList.Assign(TFhirComposition(oSource).FEventList);
  end;
  if (TFhirComposition(oSource).FSectionList = nil) then
  begin
    FSectionList.free;
    FSectionList := nil;
  end
  else
  begin
    if FSectionList = nil then
      FSectionList := TFhirCompositionSectionList.Create;
    FSectionList.Assign(TFhirComposition(oSource).FSectionList);
  end;
end;

procedure TFhirComposition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'class') Then
     list.add(self.link, 'class', FClass_.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'author') Then
    list.addAll(self, 'author', FAuthorList);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'confidentiality') Then
     list.add(self.link, 'confidentiality', FConfidentiality.Link);
  if (child_name = 'attester') Then
    list.addAll(self, 'attester', FAttesterList);
  if (child_name = 'custodian') Then
     list.add(self.link, 'custodian', FCustodian.Link);
  if (child_name = 'relatesTo') Then
    list.addAll(self, 'relatesTo', FRelatesToList);
  if (child_name = 'event') Then
    list.addAll(self, 'event', FEventList);
  if (child_name = 'section') Then
    list.addAll(self, 'section', FSectionList);
end;

procedure TFhirComposition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'class', 'CodeableConcept', false, TFhirCodeableConcept, FClass_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Any)', false, TFhirReference{TFhirReference}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference(Encounter)', false, TFhirReference{TFhirEncounter}, FEncounter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'author', 'Reference(Practitioner|Device|Patient|RelatedPerson)', true, TFhirReference{Resource}, FAuthorList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));{2}
  oList.add(TFHIRProperty.create(self, 'confidentiality', 'code', false, TFHIREnum, FConfidentiality.Link));{1}
  oList.add(TFHIRProperty.create(self, 'attester', '', true, TFhirCompositionAttester, FAttesterList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'custodian', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FCustodian.Link));{2}
  oList.add(TFHIRProperty.create(self, 'relatesTo', '', true, TFhirCompositionRelatesTo, FRelatesToList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'event', '', true, TFhirCompositionEvent, FEventList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'section', '', true, TFhirCompositionSection, FSectionList.Link)){3};
end;

function TFhirComposition.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirCompositionStatusEnum, CODES_TFhirCompositionStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'class') then
  begin
    Class_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference{TFhirEncounter}{4b};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    AuthorList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'confidentiality') then
  begin
    ConfidentialityElement := asEnum(SYSTEMS_TFhirV3ConfidentialityClassificationEnum, CODES_TFhirV3ConfidentialityClassificationEnum, propValue);
    result := propValue
  end
  else if (propName = 'attester') then
  begin
    AttesterList.add(propValue as TFhirCompositionAttester){2a};
    result := propValue;
  end
  else if (propName = 'custodian') then
  begin
    Custodian := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'relatesTo') then
  begin
    RelatesToList.add(propValue as TFhirCompositionRelatesTo){2a};
    result := propValue;
  end
  else if (propName = 'event') then
  begin
    EventList.add(propValue as TFhirCompositionEvent){2a};
    result := propValue;
  end
  else if (propName = 'section') then
  begin
    SectionList.add(propValue as TFhirCompositionSection){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirComposition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'author') then AuthorList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'attester') then AttesterList.insertItem(index, propValue as TFhirCompositionAttester){2a}
  else if (propName = 'relatesTo') then RelatesToList.insertItem(index, propValue as TFhirCompositionRelatesTo){2a}
  else if (propName = 'event') then EventList.insertItem(index, propValue as TFhirCompositionEvent){2a}
  else if (propName = 'section') then SectionList.insertItem(index, propValue as TFhirCompositionSection){2a}
  else inherited;
end;

function TFhirComposition.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'class') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subject') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'encounter') then result := TFhirReference{TFhirEncounter}.create(){4b}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'author') then result := AuthorList.new(){2}
  else if (propName = 'title') then result := TFhirString.create() {5b}
  else if (propName = 'attester') then result := AttesterList.new(){2}
  else if (propName = 'custodian') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'relatesTo') then result := RelatesToList.new(){2}
  else if (propName = 'event') then result := EventList.new(){2}
  else if (propName = 'section') then result := SectionList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirComposition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'class') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'confidentiality') then result := 'code'
  else if (propName = 'attester') then result := ''
  else if (propName = 'custodian') then result := 'Reference'
  else if (propName = 'relatesTo') then result := ''
  else if (propName = 'event') then result := ''
  else if (propName = 'section') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirComposition.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'class') then Class_Element := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'author') then deletePropertyValue('author', AuthorList, value) {2}
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'confidentiality') then ConfidentialityElement := nil
  else if (propName = 'attester') then deletePropertyValue('attester', AttesterList, value) {2}
  else if (propName = 'custodian') then CustodianElement := nil
  else if (propName = 'relatesTo') then deletePropertyValue('relatesTo', RelatesToList, value) {2}
  else if (propName = 'event') then deletePropertyValue('event', EventList, value) {2}
  else if (propName = 'section') then deletePropertyValue('section', SectionList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirComposition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirCompositionStatusEnum, CODES_TFhirCompositionStatusEnum, new){4}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'class') then Class_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference{TFhirEncounter}{4}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'author') then replacePropertyValue('author', AuthorList, existing, new) {2}
  else if (propName = 'title') then TitleElement := asString(new){5b}
  else if (propName = 'confidentiality') then ConfidentialityElement := asEnum(SYSTEMS_TFhirV3ConfidentialityClassificationEnum, CODES_TFhirV3ConfidentialityClassificationEnum, new){4}
  else if (propName = 'attester') then replacePropertyValue('attester', AttesterList, existing, new) {2}
  else if (propName = 'custodian') then CustodianElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'relatesTo') then replacePropertyValue('relatesTo', RelatesToList, existing, new) {2}
  else if (propName = 'event') then replacePropertyValue('event', EventList, existing, new) {2}
  else if (propName = 'section') then replacePropertyValue('section', SectionList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirComposition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'author') then AuthorList.move(source, destination){2a}
  else if (propName = 'attester') then AttesterList.move(source, destination){2a}
  else if (propName = 'relatesTo') then RelatesToList.move(source, destination){2a}
  else if (propName = 'event') then EventList.move(source, destination){2a}
  else if (propName = 'section') then SectionList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirComposition.fhirType : string;
begin
  result := 'Composition';
end;

function TFhirComposition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FStatus) and isEmptyProp(FType_) and isEmptyProp(FClass_) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FDate) and isEmptyProp(FauthorList) and isEmptyProp(FTitle) and isEmptyProp(FConfidentiality) and isEmptyProp(FattesterList) and isEmptyProp(FCustodian) and isEmptyProp(FrelatesToList) and isEmptyProp(FeventList) and isEmptyProp(FsectionList);
end;

function TFhirComposition.equals(other : TObject) : boolean;
var
  o : TFhirComposition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirComposition)) then
    result := false
  else
  begin
    o := TFhirComposition(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(type_Element, o.type_Element, true) and compareDeep(class_Element, o.class_Element, true) and
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(encounterElement, o.encounterElement, true) and
      compareDeep(dateElement, o.dateElement, true) and compareDeep(authorList, o.authorList, true) and
      compareDeep(titleElement, o.titleElement, true) and compareDeep(confidentialityElement, o.confidentialityElement, true) and
      compareDeep(attesterList, o.attesterList, true) and compareDeep(custodianElement, o.custodianElement, true) and
      compareDeep(relatesToList, o.relatesToList, true) and compareDeep(eventList, o.eventList, true) and
      compareDeep(sectionList, o.sectionList, true);
  end;
end;

function TFhirComposition.Link : TFhirComposition;
begin
  result := TFhirComposition(inherited Link);
end;

function TFhirComposition.Clone : TFhirComposition;
begin
  result := TFhirComposition(inherited Clone);
end;

procedure TFhirComposition.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('type');
  fields.add('class');
  fields.add('subject');
  fields.add('encounter');
  fields.add('date');
  fields.add('author');
  fields.add('title');
  fields.add('confidentiality');
  fields.add('attester');
  fields.add('custodian');
  fields.add('relatesTo');
  fields.add('event');
  fields.add('section');
end;

{ TFhirComposition }

Procedure TFhirComposition.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirComposition.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirComposition.GetStatusST : TFhirCompositionStatusEnum;
begin
  if FStatus = nil then
    result := TFhirCompositionStatusEnum(0)
  else
    result := TFhirCompositionStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirCompositionStatusEnum, FStatus.value));
end;

Procedure TFhirComposition.SetStatusST(value : TFhirCompositionStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirCompositionStatusEnum[value], CODES_TFhirCompositionStatusEnum[value]);
end;

Procedure TFhirComposition.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirComposition.SetClass_(value : TFhirCodeableConcept);
begin
  FClass_.free;
  FClass_ := value;
end;

Procedure TFhirComposition.SetSubject(value : TFhirReference{TFhirReference});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirComposition.SetEncounter(value : TFhirReference{TFhirEncounter});
begin
  FEncounter.free;
  FEncounter := value;
end;

Procedure TFhirComposition.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirComposition.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirComposition.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Function TFhirComposition.GetAuthorList : TFhirReferenceList{Resource};
begin
  if FAuthorList = nil then
    FAuthorList := TFhirReferenceList{Resource}.Create;
  result := FAuthorList;
end;

Function TFhirComposition.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

Procedure TFhirComposition.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

Function TFhirComposition.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

Procedure TFhirComposition.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

Procedure TFhirComposition.SetConfidentiality(value : TFhirEnum);
begin
  FConfidentiality.free;
  FConfidentiality := value;
end;

Function TFhirComposition.GetConfidentialityST : TFhirV3ConfidentialityClassificationEnum;
begin
  if FConfidentiality = nil then
    result := TFhirV3ConfidentialityClassificationEnum(0)
  else
    result := TFhirV3ConfidentialityClassificationEnum(StringArrayIndexOfSensitive(CODES_TFhirV3ConfidentialityClassificationEnum, FConfidentiality.value));
end;

Procedure TFhirComposition.SetConfidentialityST(value : TFhirV3ConfidentialityClassificationEnum);
begin
  if ord(value) = 0 then
    ConfidentialityElement := nil
  else
    ConfidentialityElement := TFhirEnum.create(SYSTEMS_TFhirV3ConfidentialityClassificationEnum[value], CODES_TFhirV3ConfidentialityClassificationEnum[value]);
end;

Function TFhirComposition.GetAttesterList : TFhirCompositionAttesterList;
begin
  if FAttesterList = nil then
    FAttesterList := TFhirCompositionAttesterList.Create;
  result := FAttesterList;
end;

Function TFhirComposition.GetHasAttesterList : boolean;
begin
  result := (FAttesterList <> nil) and (FAttesterList.count > 0);
end;

Procedure TFhirComposition.SetCustodian(value : TFhirReference{TFhirOrganization});
begin
  FCustodian.free;
  FCustodian := value;
end;

Function TFhirComposition.GetRelatesToList : TFhirCompositionRelatesToList;
begin
  if FRelatesToList = nil then
    FRelatesToList := TFhirCompositionRelatesToList.Create;
  result := FRelatesToList;
end;

Function TFhirComposition.GetHasRelatesToList : boolean;
begin
  result := (FRelatesToList <> nil) and (FRelatesToList.count > 0);
end;

Function TFhirComposition.GetEventList : TFhirCompositionEventList;
begin
  if FEventList = nil then
    FEventList := TFhirCompositionEventList.Create;
  result := FEventList;
end;

Function TFhirComposition.GetHasEventList : boolean;
begin
  result := (FEventList <> nil) and (FEventList.count > 0);
end;

Function TFhirComposition.GetSectionList : TFhirCompositionSectionList;
begin
  if FSectionList = nil then
    FSectionList := TFhirCompositionSectionList.Create;
  result := FSectionList;
end;

Function TFhirComposition.GetHasSectionList : boolean;
begin
  result := (FSectionList <> nil) and (FSectionList.count > 0);
end;

function TFhirComposition.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FClass_.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FauthorList.sizeInBytes);
  inc(result, FTitle.sizeInBytes);
  inc(result, FConfidentiality.sizeInBytes);
  inc(result, FattesterList.sizeInBytes);
  inc(result, FCustodian.sizeInBytes);
  inc(result, FrelatesToList.sizeInBytes);
  inc(result, FeventList.sizeInBytes);
  inc(result, FsectionList.sizeInBytes);
end;

{ TFhirCompositionListEnumerator }

Constructor TFhirCompositionListEnumerator.Create(list : TFhirCompositionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCompositionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCompositionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCompositionListEnumerator.GetCurrent : TFhirComposition;
begin
  Result := FList[FIndex];
end;

function TFhirCompositionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCompositionList }
procedure TFhirCompositionList.AddItem(value: TFhirComposition);
begin
  assert(value.ClassName = 'TFhirComposition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirComposition');
  add(value);
end;

function TFhirCompositionList.Append: TFhirComposition;
begin
  result := TFhirComposition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompositionList.ClearItems;
begin
  Clear;
end;

function TFhirCompositionList.GetEnumerator : TFhirCompositionListEnumerator;
begin
  result := TFhirCompositionListEnumerator.Create(self.link);
end;

function TFhirCompositionList.Clone: TFhirCompositionList;
begin
  result := TFhirCompositionList(inherited Clone);
end;

function TFhirCompositionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCompositionList.GetItemN(index: Integer): TFhirComposition;
begin
  result := TFhirComposition(ObjectByIndex[index]);
end;

function TFhirCompositionList.ItemClass: TFslObjectClass;
begin
  result := TFhirComposition;
end;
function TFhirCompositionList.IndexOf(value: TFhirComposition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCompositionList.Insert(index: Integer): TFhirComposition;
begin
  result := TFhirComposition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompositionList.InsertItem(index: Integer; value: TFhirComposition);
begin
  assert(value is TFhirComposition);
  Inherited Insert(index, value);
end;

function TFhirCompositionList.Item(index: Integer): TFhirComposition;
begin
  result := TFhirComposition(ObjectByIndex[index]);
end;

function TFhirCompositionList.Link: TFhirCompositionList;
begin
  result := TFhirCompositionList(inherited Link);
end;

procedure TFhirCompositionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCompositionList.SetItemByIndex(index: Integer; value: TFhirComposition);
begin
  assert(value is TFhirComposition);
  FhirCompositions[index] := value;
end;

procedure TFhirCompositionList.SetItemN(index: Integer; value: TFhirComposition);
begin
  assert(value is TFhirComposition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_COMPOSITION}

{$IFDEF FHIR_CONDITION}

{ TFhirConditionStage }

constructor TFhirConditionStage.Create;
begin
  inherited;
end;

destructor TFhirConditionStage.Destroy;
begin
  FSummary.free;
  FAssessmentList.Free;
  inherited;
end;

procedure TFhirConditionStage.Assign(oSource : TFslObject);
begin
  inherited;
  summary := TFhirConditionStage(oSource).summary.Clone;
  if (TFhirConditionStage(oSource).FAssessmentList = nil) then
  begin
    FAssessmentList.free;
    FAssessmentList := nil;
  end
  else
  begin
    if FAssessmentList = nil then
      FAssessmentList := TFhirReferenceList{Resource}.Create;
    FAssessmentList.Assign(TFhirConditionStage(oSource).FAssessmentList);
  end;
end;

procedure TFhirConditionStage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'summary') Then
     list.add(self.link, 'summary', FSummary.Link);
  if (child_name = 'assessment') Then
    list.addAll(self, 'assessment', FAssessmentList);
end;

procedure TFhirConditionStage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'summary', 'CodeableConcept', false, TFhirCodeableConcept, FSummary.Link));{2}
  oList.add(TFHIRProperty.create(self, 'assessment', 'Reference(ClinicalImpression|DiagnosticReport|Observation)', true, TFhirReference{Resource}, FAssessmentList.Link)){3};
end;

function TFhirConditionStage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'summary') then
  begin
    Summary := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'assessment') then
  begin
    AssessmentList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConditionStage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'assessment') then AssessmentList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else inherited;
end;

function TFhirConditionStage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'summary') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'assessment') then result := AssessmentList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConditionStage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'summary') then result := 'CodeableConcept'
  else if (propName = 'assessment') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConditionStage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'summary') then SummaryElement := nil
  else if (propName = 'assessment') then deletePropertyValue('assessment', AssessmentList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConditionStage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'summary') then SummaryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'assessment') then replacePropertyValue('assessment', AssessmentList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConditionStage.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'assessment') then AssessmentList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirConditionStage.fhirType : string;
begin
  result := 'stage';
end;

function TFhirConditionStage.Link : TFhirConditionStage;
begin
  result := TFhirConditionStage(inherited Link);
end;

function TFhirConditionStage.Clone : TFhirConditionStage;
begin
  result := TFhirConditionStage(inherited Clone);
end;

function TFhirConditionStage.equals(other : TObject) : boolean;
var
  o : TFhirConditionStage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConditionStage)) then
    result := false
  else
  begin
    o := TFhirConditionStage(other);
    result := compareDeep(summaryElement, o.summaryElement, true) and compareDeep(assessmentList, o.assessmentList, true);
  end;
end;

function TFhirConditionStage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSummary) and isEmptyProp(FassessmentList);
end;

procedure TFhirConditionStage.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('summary');
  fields.add('assessment');
end;

{ TFhirConditionStage }

Procedure TFhirConditionStage.SetSummary(value : TFhirCodeableConcept);
begin
  FSummary.free;
  FSummary := value;
end;

Function TFhirConditionStage.GetAssessmentList : TFhirReferenceList{Resource};
begin
  if FAssessmentList = nil then
    FAssessmentList := TFhirReferenceList{Resource}.Create;
  result := FAssessmentList;
end;

Function TFhirConditionStage.GetHasAssessmentList : boolean;
begin
  result := (FAssessmentList <> nil) and (FAssessmentList.count > 0);
end;

function TFhirConditionStage.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSummary.sizeInBytes);
  inc(result, FassessmentList.sizeInBytes);
end;

{ TFhirConditionStageListEnumerator }

Constructor TFhirConditionStageListEnumerator.Create(list : TFhirConditionStageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConditionStageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConditionStageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConditionStageListEnumerator.GetCurrent : TFhirConditionStage;
begin
  Result := FList[FIndex];
end;

function TFhirConditionStageListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConditionStageList }
procedure TFhirConditionStageList.AddItem(value: TFhirConditionStage);
begin
  assert(value.ClassName = 'TFhirConditionStage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConditionStage');
  add(value);
end;

function TFhirConditionStageList.Append: TFhirConditionStage;
begin
  result := TFhirConditionStage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConditionStageList.ClearItems;
begin
  Clear;
end;

function TFhirConditionStageList.GetEnumerator : TFhirConditionStageListEnumerator;
begin
  result := TFhirConditionStageListEnumerator.Create(self.link);
end;

function TFhirConditionStageList.Clone: TFhirConditionStageList;
begin
  result := TFhirConditionStageList(inherited Clone);
end;

function TFhirConditionStageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConditionStageList.GetItemN(index: Integer): TFhirConditionStage;
begin
  result := TFhirConditionStage(ObjectByIndex[index]);
end;

function TFhirConditionStageList.ItemClass: TFslObjectClass;
begin
  result := TFhirConditionStage;
end;
function TFhirConditionStageList.IndexOf(value: TFhirConditionStage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConditionStageList.Insert(index: Integer): TFhirConditionStage;
begin
  result := TFhirConditionStage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConditionStageList.InsertItem(index: Integer; value: TFhirConditionStage);
begin
  assert(value is TFhirConditionStage);
  Inherited Insert(index, value);
end;

function TFhirConditionStageList.Item(index: Integer): TFhirConditionStage;
begin
  result := TFhirConditionStage(ObjectByIndex[index]);
end;

function TFhirConditionStageList.Link: TFhirConditionStageList;
begin
  result := TFhirConditionStageList(inherited Link);
end;

procedure TFhirConditionStageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConditionStageList.SetItemByIndex(index: Integer; value: TFhirConditionStage);
begin
  assert(value is TFhirConditionStage);
  FhirConditionStages[index] := value;
end;

procedure TFhirConditionStageList.SetItemN(index: Integer; value: TFhirConditionStage);
begin
  assert(value is TFhirConditionStage);
  ObjectByIndex[index] := value;
end;

{ TFhirConditionEvidence }

constructor TFhirConditionEvidence.Create;
begin
  inherited;
end;

destructor TFhirConditionEvidence.Destroy;
begin
  FCodeList.Free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirConditionEvidence.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirConditionEvidence(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirCodeableConceptList.Create;
    FCodeList.Assign(TFhirConditionEvidence(oSource).FCodeList);
  end;
  if (TFhirConditionEvidence(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirReferenceList{TFhirReference}.Create;
    FDetailList.Assign(TFhirConditionEvidence(oSource).FDetailList);
  end;
end;

procedure TFhirConditionEvidence.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
end;

procedure TFhirConditionEvidence.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', true, TFhirCodeableConcept, FCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'detail', 'Reference(Any)', true, TFhirReference{TFhirReference}, FDetailList.Link)){3};
end;

function TFhirConditionEvidence.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConditionEvidence.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else inherited;
end;

function TFhirConditionEvidence.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := CodeList.new(){2}
  else if (propName = 'detail') then result := DetailList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConditionEvidence.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'detail') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConditionEvidence.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then deletePropertyValue('code', CodeList, value) {2}
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConditionEvidence.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new) {2}
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConditionEvidence.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'code') then CodeList.move(source, destination){2a}
  else if (propName = 'detail') then DetailList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirConditionEvidence.fhirType : string;
begin
  result := 'evidence';
end;

function TFhirConditionEvidence.Link : TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence(inherited Link);
end;

function TFhirConditionEvidence.Clone : TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence(inherited Clone);
end;

function TFhirConditionEvidence.equals(other : TObject) : boolean;
var
  o : TFhirConditionEvidence;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConditionEvidence)) then
    result := false
  else
  begin
    o := TFhirConditionEvidence(other);
    result := compareDeep(codeList, o.codeList, true) and compareDeep(detailList, o.detailList, true);
  end;
end;

function TFhirConditionEvidence.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FcodeList) and isEmptyProp(FdetailList);
end;

procedure TFhirConditionEvidence.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('detail');
end;

{ TFhirConditionEvidence }

Function TFhirConditionEvidence.GetCodeList : TFhirCodeableConceptList;
begin
  if FCodeList = nil then
    FCodeList := TFhirCodeableConceptList.Create;
  result := FCodeList;
end;

Function TFhirConditionEvidence.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

Function TFhirConditionEvidence.GetDetailList : TFhirReferenceList{TFhirReference};
begin
  if FDetailList = nil then
    FDetailList := TFhirReferenceList{TFhirReference}.Create;
  result := FDetailList;
end;

Function TFhirConditionEvidence.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

function TFhirConditionEvidence.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FcodeList.sizeInBytes);
  inc(result, FdetailList.sizeInBytes);
end;

{ TFhirConditionEvidenceListEnumerator }

Constructor TFhirConditionEvidenceListEnumerator.Create(list : TFhirConditionEvidenceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConditionEvidenceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConditionEvidenceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConditionEvidenceListEnumerator.GetCurrent : TFhirConditionEvidence;
begin
  Result := FList[FIndex];
end;

function TFhirConditionEvidenceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConditionEvidenceList }
procedure TFhirConditionEvidenceList.AddItem(value: TFhirConditionEvidence);
begin
  assert(value.ClassName = 'TFhirConditionEvidence', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConditionEvidence');
  add(value);
end;

function TFhirConditionEvidenceList.Append: TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConditionEvidenceList.ClearItems;
begin
  Clear;
end;

function TFhirConditionEvidenceList.GetEnumerator : TFhirConditionEvidenceListEnumerator;
begin
  result := TFhirConditionEvidenceListEnumerator.Create(self.link);
end;

function TFhirConditionEvidenceList.Clone: TFhirConditionEvidenceList;
begin
  result := TFhirConditionEvidenceList(inherited Clone);
end;

function TFhirConditionEvidenceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConditionEvidenceList.GetItemN(index: Integer): TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence(ObjectByIndex[index]);
end;

function TFhirConditionEvidenceList.ItemClass: TFslObjectClass;
begin
  result := TFhirConditionEvidence;
end;
function TFhirConditionEvidenceList.IndexOf(value: TFhirConditionEvidence): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConditionEvidenceList.Insert(index: Integer): TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConditionEvidenceList.InsertItem(index: Integer; value: TFhirConditionEvidence);
begin
  assert(value is TFhirConditionEvidence);
  Inherited Insert(index, value);
end;

function TFhirConditionEvidenceList.Item(index: Integer): TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence(ObjectByIndex[index]);
end;

function TFhirConditionEvidenceList.Link: TFhirConditionEvidenceList;
begin
  result := TFhirConditionEvidenceList(inherited Link);
end;

procedure TFhirConditionEvidenceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConditionEvidenceList.SetItemByIndex(index: Integer; value: TFhirConditionEvidence);
begin
  assert(value is TFhirConditionEvidence);
  FhirConditionEvidences[index] := value;
end;

procedure TFhirConditionEvidenceList.SetItemN(index: Integer; value: TFhirConditionEvidence);
begin
  assert(value is TFhirConditionEvidence);
  ObjectByIndex[index] := value;
end;

{ TFhirCondition }

constructor TFhirCondition.Create;
begin
  inherited;
end;

destructor TFhirCondition.Destroy;
begin
  FIdentifierList.Free;
  FClinicalStatus.free;
  FVerificationStatus.free;
  FCategoryList.Free;
  FSeverity.free;
  FCode.free;
  FBodySiteList.Free;
  FSubject.free;
  FContext.free;
  FOnset.free;
  FAbatement.free;
  FAssertedDate.free;
  FAsserter.free;
  FStage.free;
  FEvidenceList.Free;
  FNoteList.Free;
  inherited;
end;

function TFhirCondition.GetResourceType : TFhirResourceType;
begin
  result := frtCondition;
end;

procedure TFhirCondition.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCondition(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCondition(oSource).FIdentifierList);
  end;
  FClinicalStatus := TFhirCondition(oSource).FClinicalStatus.Link;
  FVerificationStatus := TFhirCondition(oSource).FVerificationStatus.Link;
  if (TFhirCondition(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirCondition(oSource).FCategoryList);
  end;
  severity := TFhirCondition(oSource).severity.Clone;
  code := TFhirCondition(oSource).code.Clone;
  if (TFhirCondition(oSource).FBodySiteList = nil) then
  begin
    FBodySiteList.free;
    FBodySiteList := nil;
  end
  else
  begin
    if FBodySiteList = nil then
      FBodySiteList := TFhirCodeableConceptList.Create;
    FBodySiteList.Assign(TFhirCondition(oSource).FBodySiteList);
  end;
  subject := TFhirCondition(oSource).subject.Clone;
  context := TFhirCondition(oSource).context.Clone;
  onset := TFhirCondition(oSource).onset.Clone;
  abatement := TFhirCondition(oSource).abatement.Clone;
  assertedDateElement := TFhirCondition(oSource).assertedDateElement.Clone;
  asserter := TFhirCondition(oSource).asserter.Clone;
  stage := TFhirCondition(oSource).stage.Clone;
  if (TFhirCondition(oSource).FEvidenceList = nil) then
  begin
    FEvidenceList.free;
    FEvidenceList := nil;
  end
  else
  begin
    if FEvidenceList = nil then
      FEvidenceList := TFhirConditionEvidenceList.Create;
    FEvidenceList.Assign(TFhirCondition(oSource).FEvidenceList);
  end;
  if (TFhirCondition(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirCondition(oSource).FNoteList);
  end;
end;

procedure TFhirCondition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'clinicalStatus') Then
     list.add(self.link, 'clinicalStatus', FClinicalStatus.Link);
  if (child_name = 'verificationStatus') Then
     list.add(self.link, 'verificationStatus', FVerificationStatus.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'severity') Then
     list.add(self.link, 'severity', FSeverity.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'bodySite') Then
    list.addAll(self, 'bodySite', FBodySiteList);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
  if (child_name = 'onset[x]') or (child_name = 'onset') Then
     list.add(self.link, 'onset[x]', FOnset.Link);
  if (child_name = 'abatement[x]') or (child_name = 'abatement') Then
     list.add(self.link, 'abatement[x]', FAbatement.Link);
  if (child_name = 'assertedDate') Then
     list.add(self.link, 'assertedDate', FAssertedDate.Link);
  if (child_name = 'asserter') Then
     list.add(self.link, 'asserter', FAsserter.Link);
  if (child_name = 'stage') Then
     list.add(self.link, 'stage', FStage.Link);
  if (child_name = 'evidence') Then
    list.addAll(self, 'evidence', FEvidenceList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirCondition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'clinicalStatus', 'code', false, TFHIREnum, FClinicalStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'verificationStatus', 'code', false, TFHIREnum, FVerificationStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'severity', 'CodeableConcept', false, TFhirCodeableConcept, FSeverity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', true, TFhirCodeableConcept, FBodySiteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Group)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'context', 'Reference(Encounter|EpisodeOfCare)', false, TFhirReference{Resource}, FContext.Link));{2}
  oList.add(TFHIRProperty.create(self, 'onset[x]', 'dateTime|Age|Period|Range|string', false, TFhirType, FOnset.Link));{2}
  oList.add(TFHIRProperty.create(self, 'abatement[x]', 'dateTime|Age|boolean|Period|Range|string', false, TFhirType, FAbatement.Link));{2}
  oList.add(TFHIRProperty.create(self, 'assertedDate', 'dateTime', false, TFhirDateTime, FAssertedDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'asserter', 'Reference(Practitioner|Patient|RelatedPerson)', false, TFhirReference{Resource}, FAsserter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'stage', '', false, TFhirConditionStage, FStage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'evidence', '', true, TFhirConditionEvidence, FEvidenceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
end;

function TFhirCondition.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'clinicalStatus') then
  begin
    ClinicalStatusElement := asEnum(SYSTEMS_TFhirConditionClinicalEnum, CODES_TFhirConditionClinicalEnum, propValue);
    result := propValue
  end
  else if (propName = 'verificationStatus') then
  begin
    VerificationStatusElement := asEnum(SYSTEMS_TFhirConditionVerStatusEnum, CODES_TFhirConditionVerStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'severity') then
  begin
    Severity := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySiteList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'context') then
  begin
    Context := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'onset', ['DateTime', 'Age', 'Period', 'Range', 'String'])) then
  begin
    Onset := propValue as TFhirType{4};
    result := propValue;
  end
  else if (isMatchingName(propName, 'abatement', ['DateTime', 'Age', 'Boolean', 'Period', 'Range', 'String'])) then
  begin
    Abatement := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'assertedDate') then
  begin
    AssertedDateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'asserter') then
  begin
    Asserter := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'stage') then
  begin
    Stage := propValue as TFhirConditionStage{4b};
    result := propValue;
  end
  else if (propName = 'evidence') then
  begin
    EvidenceList.add(propValue as TFhirConditionEvidence){2a};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirCondition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'bodySite') then BodySiteList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'evidence') then EvidenceList.insertItem(index, propValue as TFhirConditionEvidence){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else inherited;
end;

function TFhirCondition.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'category') then result := CategoryList.new(){2}
  else if (propName = 'severity') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'bodySite') then result := BodySiteList.new(){2}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'context') then result := TFhirReference{Resource}.create(){4b}
  else if (isMatchingName(propName, 'onset', ['DateTime', 'Age', 'Period', 'Range', 'String'])) then raise EFHIRException.create('Cannot make property Onset'){4x}
  else if (isMatchingName(propName, 'abatement', ['DateTime', 'Age', 'Boolean', 'Period', 'Range', 'String'])) then raise EFHIRException.create('Cannot make property Abatement'){4x}
  else if (propName = 'assertedDate') then result := TFhirDateTime.create() {5b}
  else if (propName = 'asserter') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'stage') then result := TFhirConditionStage.create(){4b}
  else if (propName = 'evidence') then result := EvidenceList.new(){2}
  else if (propName = 'note') then result := NoteList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCondition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'clinicalStatus') then result := 'code'
  else if (propName = 'verificationStatus') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'severity') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'bodySite') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'context') then result := 'Reference'
  else if (propName = 'onset[x]') then result := 'dateTime|Age|Period|Range|string'
  else if (propName = 'abatement[x]') then result := 'dateTime|Age|boolean|Period|Range|string'
  else if (propName = 'assertedDate') then result := 'dateTime'
  else if (propName = 'asserter') then result := 'Reference'
  else if (propName = 'stage') then result := ''
  else if (propName = 'evidence') then result := ''
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCondition.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'clinicalStatus') then ClinicalStatusElement := nil
  else if (propName = 'verificationStatus') then VerificationStatusElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value) {2}
  else if (propName = 'severity') then SeverityElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'bodySite') then deletePropertyValue('bodySite', BodySiteList, value) {2}
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'context') then ContextElement := nil
  else if (isMatchingName(propName, 'onset', ['DateTime', 'Age', 'Period', 'Range', 'String'])) then OnsetElement := nil{4x}
  else if (isMatchingName(propName, 'abatement', ['DateTime', 'Age', 'Boolean', 'Period', 'Range', 'String'])) then AbatementElement := nil{4x}
  else if (propName = 'assertedDate') then AssertedDateElement := nil
  else if (propName = 'asserter') then AsserterElement := nil
  else if (propName = 'stage') then StageElement := nil
  else if (propName = 'evidence') then deletePropertyValue('evidence', EvidenceList, value) {2}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCondition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'clinicalStatus') then ClinicalStatusElement := asEnum(SYSTEMS_TFhirConditionClinicalEnum, CODES_TFhirConditionClinicalEnum, new){4}
  else if (propName = 'verificationStatus') then VerificationStatusElement := asEnum(SYSTEMS_TFhirConditionVerStatusEnum, CODES_TFhirConditionVerStatusEnum, new){4}
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new) {2}
  else if (propName = 'severity') then SeverityElement := new as TFhirCodeableConcept{4}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'bodySite') then replacePropertyValue('bodySite', BodySiteList, existing, new) {2}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'context') then ContextElement := new as TFhirReference{Resource}{4}
  else if (isMatchingName(propName, 'onset', ['DateTime', 'Age', 'Period', 'Range', 'String'])) then OnsetElement := new as TFhirType{4x}
  else if (isMatchingName(propName, 'abatement', ['DateTime', 'Age', 'Boolean', 'Period', 'Range', 'String'])) then AbatementElement := new as TFhirType{4x}
  else if (propName = 'assertedDate') then AssertedDateElement := asDateTime(new){5b}
  else if (propName = 'asserter') then AsserterElement := new as TFhirReference{Resource}{4}
  else if (propName = 'stage') then StageElement := new as TFhirConditionStage{4}
  else if (propName = 'evidence') then replacePropertyValue('evidence', EvidenceList, existing, new) {2}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCondition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'category') then CategoryList.move(source, destination){2a}
  else if (propName = 'bodySite') then BodySiteList.move(source, destination){2a}
  else if (propName = 'evidence') then EvidenceList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCondition.fhirType : string;
begin
  result := 'Condition';
end;

function TFhirCondition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FClinicalStatus) and isEmptyProp(FVerificationStatus) and isEmptyProp(FcategoryList) and isEmptyProp(FSeverity) and isEmptyProp(FCode) and isEmptyProp(FbodySiteList) and isEmptyProp(FSubject) and isEmptyProp(FContext) and isEmptyProp(FOnset) and isEmptyProp(FAbatement) and isEmptyProp(FAssertedDate) and isEmptyProp(FAsserter) and isEmptyProp(FStage) and isEmptyProp(FevidenceList) and isEmptyProp(FnoteList);
end;

function TFhirCondition.equals(other : TObject) : boolean;
var
  o : TFhirCondition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCondition)) then
    result := false
  else
  begin
    o := TFhirCondition(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(clinicalStatusElement, o.clinicalStatusElement, true) and
      compareDeep(verificationStatusElement, o.verificationStatusElement, true) and
      compareDeep(categoryList, o.categoryList, true) and compareDeep(severityElement, o.severityElement, true) and
      compareDeep(codeElement, o.codeElement, true) and compareDeep(bodySiteList, o.bodySiteList, true) and
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(contextElement, o.contextElement, true) and
      compareDeep(onsetElement, o.onsetElement, true) and compareDeep(abatementElement, o.abatementElement, true) and
      compareDeep(assertedDateElement, o.assertedDateElement, true) and compareDeep(asserterElement, o.asserterElement, true) and
      compareDeep(stageElement, o.stageElement, true) and compareDeep(evidenceList, o.evidenceList, true) and
      compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirCondition.Link : TFhirCondition;
begin
  result := TFhirCondition(inherited Link);
end;

function TFhirCondition.Clone : TFhirCondition;
begin
  result := TFhirCondition(inherited Clone);
end;

procedure TFhirCondition.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('clinicalStatus');
  fields.add('verificationStatus');
  fields.add('category');
  fields.add('severity');
  fields.add('code');
  fields.add('bodySite');
  fields.add('subject');
  fields.add('context');
  fields.add('onset[x]');
  fields.add('abatement[x]');
  fields.add('assertedDate');
  fields.add('asserter');
  fields.add('stage');
  fields.add('evidence');
  fields.add('note');
end;

{ TFhirCondition }

Function TFhirCondition.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirCondition.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirCondition.SetClinicalStatus(value : TFhirEnum);
begin
  FClinicalStatus.free;
  FClinicalStatus := value;
end;

Function TFhirCondition.GetClinicalStatusST : TFhirConditionClinicalEnum;
begin
  if FClinicalStatus = nil then
    result := TFhirConditionClinicalEnum(0)
  else
    result := TFhirConditionClinicalEnum(StringArrayIndexOfSensitive(CODES_TFhirConditionClinicalEnum, FClinicalStatus.value));
end;

Procedure TFhirCondition.SetClinicalStatusST(value : TFhirConditionClinicalEnum);
begin
  if ord(value) = 0 then
    ClinicalStatusElement := nil
  else
    ClinicalStatusElement := TFhirEnum.create(SYSTEMS_TFhirConditionClinicalEnum[value], CODES_TFhirConditionClinicalEnum[value]);
end;

Procedure TFhirCondition.SetVerificationStatus(value : TFhirEnum);
begin
  FVerificationStatus.free;
  FVerificationStatus := value;
end;

Function TFhirCondition.GetVerificationStatusST : TFhirConditionVerStatusEnum;
begin
  if FVerificationStatus = nil then
    result := TFhirConditionVerStatusEnum(0)
  else
    result := TFhirConditionVerStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirConditionVerStatusEnum, FVerificationStatus.value));
end;

Procedure TFhirCondition.SetVerificationStatusST(value : TFhirConditionVerStatusEnum);
begin
  if ord(value) = 0 then
    VerificationStatusElement := nil
  else
    VerificationStatusElement := TFhirEnum.create(SYSTEMS_TFhirConditionVerStatusEnum[value], CODES_TFhirConditionVerStatusEnum[value]);
end;

Function TFhirCondition.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

Function TFhirCondition.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

Procedure TFhirCondition.SetSeverity(value : TFhirCodeableConcept);
begin
  FSeverity.free;
  FSeverity := value;
end;

Procedure TFhirCondition.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirCondition.GetBodySiteList : TFhirCodeableConceptList;
begin
  if FBodySiteList = nil then
    FBodySiteList := TFhirCodeableConceptList.Create;
  result := FBodySiteList;
end;

Function TFhirCondition.GetHasBodySiteList : boolean;
begin
  result := (FBodySiteList <> nil) and (FBodySiteList.count > 0);
end;

Procedure TFhirCondition.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirCondition.SetContext(value : TFhirReference{Resource});
begin
  FContext.free;
  FContext := value;
end;

Procedure TFhirCondition.SetOnset(value : TFhirType);
begin
  FOnset.free;
  FOnset := value;
end;

Procedure TFhirCondition.SetAbatement(value : TFhirType);
begin
  FAbatement.free;
  FAbatement := value;
end;

Procedure TFhirCondition.SetAssertedDate(value : TFhirDateTime);
begin
  FAssertedDate.free;
  FAssertedDate := value;
end;

Function TFhirCondition.GetAssertedDateST : TFslDateTime;
begin
  if FAssertedDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FAssertedDate.value;
end;

Procedure TFhirCondition.SetAssertedDateST(value : TFslDateTime);
begin
  if FAssertedDate = nil then
    FAssertedDate := TFhirDateTime.create;
  FAssertedDate.value := value
end;

Procedure TFhirCondition.SetAsserter(value : TFhirReference{Resource});
begin
  FAsserter.free;
  FAsserter := value;
end;

Procedure TFhirCondition.SetStage(value : TFhirConditionStage);
begin
  FStage.free;
  FStage := value;
end;

Function TFhirCondition.GetEvidenceList : TFhirConditionEvidenceList;
begin
  if FEvidenceList = nil then
    FEvidenceList := TFhirConditionEvidenceList.Create;
  result := FEvidenceList;
end;

Function TFhirCondition.GetHasEvidenceList : boolean;
begin
  result := (FEvidenceList <> nil) and (FEvidenceList.count > 0);
end;

Function TFhirCondition.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirCondition.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirCondition.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FClinicalStatus.sizeInBytes);
  inc(result, FVerificationStatus.sizeInBytes);
  inc(result, FcategoryList.sizeInBytes);
  inc(result, FSeverity.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FbodySiteList.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FContext.sizeInBytes);
  inc(result, FOnset.sizeInBytes);
  inc(result, FAbatement.sizeInBytes);
  inc(result, FAssertedDate.sizeInBytes);
  inc(result, FAsserter.sizeInBytes);
  inc(result, FStage.sizeInBytes);
  inc(result, FevidenceList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
end;

{ TFhirConditionListEnumerator }

Constructor TFhirConditionListEnumerator.Create(list : TFhirConditionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConditionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConditionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConditionListEnumerator.GetCurrent : TFhirCondition;
begin
  Result := FList[FIndex];
end;

function TFhirConditionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConditionList }
procedure TFhirConditionList.AddItem(value: TFhirCondition);
begin
  assert(value.ClassName = 'TFhirCondition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCondition');
  add(value);
end;

function TFhirConditionList.Append: TFhirCondition;
begin
  result := TFhirCondition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConditionList.ClearItems;
begin
  Clear;
end;

function TFhirConditionList.GetEnumerator : TFhirConditionListEnumerator;
begin
  result := TFhirConditionListEnumerator.Create(self.link);
end;

function TFhirConditionList.Clone: TFhirConditionList;
begin
  result := TFhirConditionList(inherited Clone);
end;

function TFhirConditionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConditionList.GetItemN(index: Integer): TFhirCondition;
begin
  result := TFhirCondition(ObjectByIndex[index]);
end;

function TFhirConditionList.ItemClass: TFslObjectClass;
begin
  result := TFhirCondition;
end;
function TFhirConditionList.IndexOf(value: TFhirCondition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConditionList.Insert(index: Integer): TFhirCondition;
begin
  result := TFhirCondition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConditionList.InsertItem(index: Integer; value: TFhirCondition);
begin
  assert(value is TFhirCondition);
  Inherited Insert(index, value);
end;

function TFhirConditionList.Item(index: Integer): TFhirCondition;
begin
  result := TFhirCondition(ObjectByIndex[index]);
end;

function TFhirConditionList.Link: TFhirConditionList;
begin
  result := TFhirConditionList(inherited Link);
end;

procedure TFhirConditionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConditionList.SetItemByIndex(index: Integer; value: TFhirCondition);
begin
  assert(value is TFhirCondition);
  FhirConditions[index] := value;
end;

procedure TFhirConditionList.SetItemN(index: Integer; value: TFhirCondition);
begin
  assert(value is TFhirCondition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CONDITION}

{$IFDEF FHIR_COVERAGE}

{ TFhirCoverageGrouping }

constructor TFhirCoverageGrouping.Create;
begin
  inherited;
end;

destructor TFhirCoverageGrouping.Destroy;
begin
  FGroup.free;
  FGroupDisplay.free;
  FSubGroup.free;
  FSubGroupDisplay.free;
  FPlan.free;
  FPlanDisplay.free;
  FSubPlan.free;
  FSubPlanDisplay.free;
  FClass_.free;
  FClassDisplay.free;
  FSubClass.free;
  FSubClassDisplay.free;
  inherited;
end;

procedure TFhirCoverageGrouping.Assign(oSource : TFslObject);
begin
  inherited;
  groupElement := TFhirCoverageGrouping(oSource).groupElement.Clone;
  groupDisplayElement := TFhirCoverageGrouping(oSource).groupDisplayElement.Clone;
  subGroupElement := TFhirCoverageGrouping(oSource).subGroupElement.Clone;
  subGroupDisplayElement := TFhirCoverageGrouping(oSource).subGroupDisplayElement.Clone;
  planElement := TFhirCoverageGrouping(oSource).planElement.Clone;
  planDisplayElement := TFhirCoverageGrouping(oSource).planDisplayElement.Clone;
  subPlanElement := TFhirCoverageGrouping(oSource).subPlanElement.Clone;
  subPlanDisplayElement := TFhirCoverageGrouping(oSource).subPlanDisplayElement.Clone;
  class_Element := TFhirCoverageGrouping(oSource).class_Element.Clone;
  classDisplayElement := TFhirCoverageGrouping(oSource).classDisplayElement.Clone;
  subClassElement := TFhirCoverageGrouping(oSource).subClassElement.Clone;
  subClassDisplayElement := TFhirCoverageGrouping(oSource).subClassDisplayElement.Clone;
end;

procedure TFhirCoverageGrouping.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'group') Then
     list.add(self.link, 'group', FGroup.Link);
  if (child_name = 'groupDisplay') Then
     list.add(self.link, 'groupDisplay', FGroupDisplay.Link);
  if (child_name = 'subGroup') Then
     list.add(self.link, 'subGroup', FSubGroup.Link);
  if (child_name = 'subGroupDisplay') Then
     list.add(self.link, 'subGroupDisplay', FSubGroupDisplay.Link);
  if (child_name = 'plan') Then
     list.add(self.link, 'plan', FPlan.Link);
  if (child_name = 'planDisplay') Then
     list.add(self.link, 'planDisplay', FPlanDisplay.Link);
  if (child_name = 'subPlan') Then
     list.add(self.link, 'subPlan', FSubPlan.Link);
  if (child_name = 'subPlanDisplay') Then
     list.add(self.link, 'subPlanDisplay', FSubPlanDisplay.Link);
  if (child_name = 'class') Then
     list.add(self.link, 'class', FClass_.Link);
  if (child_name = 'classDisplay') Then
     list.add(self.link, 'classDisplay', FClassDisplay.Link);
  if (child_name = 'subClass') Then
     list.add(self.link, 'subClass', FSubClass.Link);
  if (child_name = 'subClassDisplay') Then
     list.add(self.link, 'subClassDisplay', FSubClassDisplay.Link);
end;

procedure TFhirCoverageGrouping.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'group', 'string', false, TFhirString, FGroup.Link));{2}
  oList.add(TFHIRProperty.create(self, 'groupDisplay', 'string', false, TFhirString, FGroupDisplay.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subGroup', 'string', false, TFhirString, FSubGroup.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subGroupDisplay', 'string', false, TFhirString, FSubGroupDisplay.Link));{2}
  oList.add(TFHIRProperty.create(self, 'plan', 'string', false, TFhirString, FPlan.Link));{2}
  oList.add(TFHIRProperty.create(self, 'planDisplay', 'string', false, TFhirString, FPlanDisplay.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subPlan', 'string', false, TFhirString, FSubPlan.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subPlanDisplay', 'string', false, TFhirString, FSubPlanDisplay.Link));{2}
  oList.add(TFHIRProperty.create(self, 'class', 'string', false, TFhirString, FClass_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'classDisplay', 'string', false, TFhirString, FClassDisplay.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subClass', 'string', false, TFhirString, FSubClass.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subClassDisplay', 'string', false, TFhirString, FSubClassDisplay.Link));{2}
end;

function TFhirCoverageGrouping.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'group') then
  begin
    GroupElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'groupDisplay') then
  begin
    GroupDisplayElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'subGroup') then
  begin
    SubGroupElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'subGroupDisplay') then
  begin
    SubGroupDisplayElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'plan') then
  begin
    PlanElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'planDisplay') then
  begin
    PlanDisplayElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'subPlan') then
  begin
    SubPlanElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'subPlanDisplay') then
  begin
    SubPlanDisplayElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'class') then
  begin
    Class_Element := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'classDisplay') then
  begin
    ClassDisplayElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'subClass') then
  begin
    SubClassElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'subClassDisplay') then
  begin
    SubClassDisplayElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCoverageGrouping.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCoverageGrouping.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'group') then result := TFhirString.create() {5b}
  else if (propName = 'groupDisplay') then result := TFhirString.create() {5b}
  else if (propName = 'subGroup') then result := TFhirString.create() {5b}
  else if (propName = 'subGroupDisplay') then result := TFhirString.create() {5b}
  else if (propName = 'plan') then result := TFhirString.create() {5b}
  else if (propName = 'planDisplay') then result := TFhirString.create() {5b}
  else if (propName = 'subPlan') then result := TFhirString.create() {5b}
  else if (propName = 'subPlanDisplay') then result := TFhirString.create() {5b}
  else if (propName = 'class') then result := TFhirString.create() {5b}
  else if (propName = 'classDisplay') then result := TFhirString.create() {5b}
  else if (propName = 'subClass') then result := TFhirString.create() {5b}
  else if (propName = 'subClassDisplay') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverageGrouping.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'group') then result := 'string'
  else if (propName = 'groupDisplay') then result := 'string'
  else if (propName = 'subGroup') then result := 'string'
  else if (propName = 'subGroupDisplay') then result := 'string'
  else if (propName = 'plan') then result := 'string'
  else if (propName = 'planDisplay') then result := 'string'
  else if (propName = 'subPlan') then result := 'string'
  else if (propName = 'subPlanDisplay') then result := 'string'
  else if (propName = 'class') then result := 'string'
  else if (propName = 'classDisplay') then result := 'string'
  else if (propName = 'subClass') then result := 'string'
  else if (propName = 'subClassDisplay') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverageGrouping.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'group') then GroupElement := nil
  else if (propName = 'groupDisplay') then GroupDisplayElement := nil
  else if (propName = 'subGroup') then SubGroupElement := nil
  else if (propName = 'subGroupDisplay') then SubGroupDisplayElement := nil
  else if (propName = 'plan') then PlanElement := nil
  else if (propName = 'planDisplay') then PlanDisplayElement := nil
  else if (propName = 'subPlan') then SubPlanElement := nil
  else if (propName = 'subPlanDisplay') then SubPlanDisplayElement := nil
  else if (propName = 'class') then Class_Element := nil
  else if (propName = 'classDisplay') then ClassDisplayElement := nil
  else if (propName = 'subClass') then SubClassElement := nil
  else if (propName = 'subClassDisplay') then SubClassDisplayElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverageGrouping.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'group') then GroupElement := asString(new){5b}
  else if (propName = 'groupDisplay') then GroupDisplayElement := asString(new){5b}
  else if (propName = 'subGroup') then SubGroupElement := asString(new){5b}
  else if (propName = 'subGroupDisplay') then SubGroupDisplayElement := asString(new){5b}
  else if (propName = 'plan') then PlanElement := asString(new){5b}
  else if (propName = 'planDisplay') then PlanDisplayElement := asString(new){5b}
  else if (propName = 'subPlan') then SubPlanElement := asString(new){5b}
  else if (propName = 'subPlanDisplay') then SubPlanDisplayElement := asString(new){5b}
  else if (propName = 'class') then Class_Element := asString(new){5b}
  else if (propName = 'classDisplay') then ClassDisplayElement := asString(new){5b}
  else if (propName = 'subClass') then SubClassElement := asString(new){5b}
  else if (propName = 'subClassDisplay') then SubClassDisplayElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverageGrouping.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverageGrouping.fhirType : string;
begin
  result := 'grouping';
end;

function TFhirCoverageGrouping.Link : TFhirCoverageGrouping;
begin
  result := TFhirCoverageGrouping(inherited Link);
end;

function TFhirCoverageGrouping.Clone : TFhirCoverageGrouping;
begin
  result := TFhirCoverageGrouping(inherited Clone);
end;

function TFhirCoverageGrouping.equals(other : TObject) : boolean;
var
  o : TFhirCoverageGrouping;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverageGrouping)) then
    result := false
  else
  begin
    o := TFhirCoverageGrouping(other);
    result := compareDeep(groupElement, o.groupElement, true) and compareDeep(groupDisplayElement, o.groupDisplayElement, true) and
      compareDeep(subGroupElement, o.subGroupElement, true) and compareDeep(subGroupDisplayElement, o.subGroupDisplayElement, true) and
      compareDeep(planElement, o.planElement, true) and compareDeep(planDisplayElement, o.planDisplayElement, true) and
      compareDeep(subPlanElement, o.subPlanElement, true) and compareDeep(subPlanDisplayElement, o.subPlanDisplayElement, true) and
      compareDeep(class_Element, o.class_Element, true) and compareDeep(classDisplayElement, o.classDisplayElement, true) and
      compareDeep(subClassElement, o.subClassElement, true) and compareDeep(subClassDisplayElement, o.subClassDisplayElement, true);
  end;
end;

function TFhirCoverageGrouping.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FGroup) and isEmptyProp(FGroupDisplay) and isEmptyProp(FSubGroup) and isEmptyProp(FSubGroupDisplay) and isEmptyProp(FPlan) and isEmptyProp(FPlanDisplay) and isEmptyProp(FSubPlan) and isEmptyProp(FSubPlanDisplay) and isEmptyProp(FClass_) and isEmptyProp(FClassDisplay) and isEmptyProp(FSubClass) and isEmptyProp(FSubClassDisplay);
end;

procedure TFhirCoverageGrouping.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('group');
  fields.add('groupDisplay');
  fields.add('subGroup');
  fields.add('subGroupDisplay');
  fields.add('plan');
  fields.add('planDisplay');
  fields.add('subPlan');
  fields.add('subPlanDisplay');
  fields.add('class');
  fields.add('classDisplay');
  fields.add('subClass');
  fields.add('subClassDisplay');
end;

{ TFhirCoverageGrouping }

Procedure TFhirCoverageGrouping.SetGroup(value : TFhirString);
begin
  FGroup.free;
  FGroup := value;
end;

Function TFhirCoverageGrouping.GetGroupST : String;
begin
  if FGroup = nil then
    result := ''
  else
    result := FGroup.value;
end;

Procedure TFhirCoverageGrouping.SetGroupST(value : String);
begin
  if value <> '' then
  begin
    if FGroup = nil then
      FGroup := TFhirString.create;
    FGroup.value := value
  end
  else if FGroup <> nil then
    FGroup.value := '';
end;

Procedure TFhirCoverageGrouping.SetGroupDisplay(value : TFhirString);
begin
  FGroupDisplay.free;
  FGroupDisplay := value;
end;

Function TFhirCoverageGrouping.GetGroupDisplayST : String;
begin
  if FGroupDisplay = nil then
    result := ''
  else
    result := FGroupDisplay.value;
end;

Procedure TFhirCoverageGrouping.SetGroupDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FGroupDisplay = nil then
      FGroupDisplay := TFhirString.create;
    FGroupDisplay.value := value
  end
  else if FGroupDisplay <> nil then
    FGroupDisplay.value := '';
end;

Procedure TFhirCoverageGrouping.SetSubGroup(value : TFhirString);
begin
  FSubGroup.free;
  FSubGroup := value;
end;

Function TFhirCoverageGrouping.GetSubGroupST : String;
begin
  if FSubGroup = nil then
    result := ''
  else
    result := FSubGroup.value;
end;

Procedure TFhirCoverageGrouping.SetSubGroupST(value : String);
begin
  if value <> '' then
  begin
    if FSubGroup = nil then
      FSubGroup := TFhirString.create;
    FSubGroup.value := value
  end
  else if FSubGroup <> nil then
    FSubGroup.value := '';
end;

Procedure TFhirCoverageGrouping.SetSubGroupDisplay(value : TFhirString);
begin
  FSubGroupDisplay.free;
  FSubGroupDisplay := value;
end;

Function TFhirCoverageGrouping.GetSubGroupDisplayST : String;
begin
  if FSubGroupDisplay = nil then
    result := ''
  else
    result := FSubGroupDisplay.value;
end;

Procedure TFhirCoverageGrouping.SetSubGroupDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FSubGroupDisplay = nil then
      FSubGroupDisplay := TFhirString.create;
    FSubGroupDisplay.value := value
  end
  else if FSubGroupDisplay <> nil then
    FSubGroupDisplay.value := '';
end;

Procedure TFhirCoverageGrouping.SetPlan(value : TFhirString);
begin
  FPlan.free;
  FPlan := value;
end;

Function TFhirCoverageGrouping.GetPlanST : String;
begin
  if FPlan = nil then
    result := ''
  else
    result := FPlan.value;
end;

Procedure TFhirCoverageGrouping.SetPlanST(value : String);
begin
  if value <> '' then
  begin
    if FPlan = nil then
      FPlan := TFhirString.create;
    FPlan.value := value
  end
  else if FPlan <> nil then
    FPlan.value := '';
end;

Procedure TFhirCoverageGrouping.SetPlanDisplay(value : TFhirString);
begin
  FPlanDisplay.free;
  FPlanDisplay := value;
end;

Function TFhirCoverageGrouping.GetPlanDisplayST : String;
begin
  if FPlanDisplay = nil then
    result := ''
  else
    result := FPlanDisplay.value;
end;

Procedure TFhirCoverageGrouping.SetPlanDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FPlanDisplay = nil then
      FPlanDisplay := TFhirString.create;
    FPlanDisplay.value := value
  end
  else if FPlanDisplay <> nil then
    FPlanDisplay.value := '';
end;

Procedure TFhirCoverageGrouping.SetSubPlan(value : TFhirString);
begin
  FSubPlan.free;
  FSubPlan := value;
end;

Function TFhirCoverageGrouping.GetSubPlanST : String;
begin
  if FSubPlan = nil then
    result := ''
  else
    result := FSubPlan.value;
end;

Procedure TFhirCoverageGrouping.SetSubPlanST(value : String);
begin
  if value <> '' then
  begin
    if FSubPlan = nil then
      FSubPlan := TFhirString.create;
    FSubPlan.value := value
  end
  else if FSubPlan <> nil then
    FSubPlan.value := '';
end;

Procedure TFhirCoverageGrouping.SetSubPlanDisplay(value : TFhirString);
begin
  FSubPlanDisplay.free;
  FSubPlanDisplay := value;
end;

Function TFhirCoverageGrouping.GetSubPlanDisplayST : String;
begin
  if FSubPlanDisplay = nil then
    result := ''
  else
    result := FSubPlanDisplay.value;
end;

Procedure TFhirCoverageGrouping.SetSubPlanDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FSubPlanDisplay = nil then
      FSubPlanDisplay := TFhirString.create;
    FSubPlanDisplay.value := value
  end
  else if FSubPlanDisplay <> nil then
    FSubPlanDisplay.value := '';
end;

Procedure TFhirCoverageGrouping.SetClass_(value : TFhirString);
begin
  FClass_.free;
  FClass_ := value;
end;

Function TFhirCoverageGrouping.GetClass_ST : String;
begin
  if FClass_ = nil then
    result := ''
  else
    result := FClass_.value;
end;

Procedure TFhirCoverageGrouping.SetClass_ST(value : String);
begin
  if value <> '' then
  begin
    if FClass_ = nil then
      FClass_ := TFhirString.create;
    FClass_.value := value
  end
  else if FClass_ <> nil then
    FClass_.value := '';
end;

Procedure TFhirCoverageGrouping.SetClassDisplay(value : TFhirString);
begin
  FClassDisplay.free;
  FClassDisplay := value;
end;

Function TFhirCoverageGrouping.GetClassDisplayST : String;
begin
  if FClassDisplay = nil then
    result := ''
  else
    result := FClassDisplay.value;
end;

Procedure TFhirCoverageGrouping.SetClassDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FClassDisplay = nil then
      FClassDisplay := TFhirString.create;
    FClassDisplay.value := value
  end
  else if FClassDisplay <> nil then
    FClassDisplay.value := '';
end;

Procedure TFhirCoverageGrouping.SetSubClass(value : TFhirString);
begin
  FSubClass.free;
  FSubClass := value;
end;

Function TFhirCoverageGrouping.GetSubClassST : String;
begin
  if FSubClass = nil then
    result := ''
  else
    result := FSubClass.value;
end;

Procedure TFhirCoverageGrouping.SetSubClassST(value : String);
begin
  if value <> '' then
  begin
    if FSubClass = nil then
      FSubClass := TFhirString.create;
    FSubClass.value := value
  end
  else if FSubClass <> nil then
    FSubClass.value := '';
end;

Procedure TFhirCoverageGrouping.SetSubClassDisplay(value : TFhirString);
begin
  FSubClassDisplay.free;
  FSubClassDisplay := value;
end;

Function TFhirCoverageGrouping.GetSubClassDisplayST : String;
begin
  if FSubClassDisplay = nil then
    result := ''
  else
    result := FSubClassDisplay.value;
end;

Procedure TFhirCoverageGrouping.SetSubClassDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FSubClassDisplay = nil then
      FSubClassDisplay := TFhirString.create;
    FSubClassDisplay.value := value
  end
  else if FSubClassDisplay <> nil then
    FSubClassDisplay.value := '';
end;

function TFhirCoverageGrouping.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FGroup.sizeInBytes);
  inc(result, FGroupDisplay.sizeInBytes);
  inc(result, FSubGroup.sizeInBytes);
  inc(result, FSubGroupDisplay.sizeInBytes);
  inc(result, FPlan.sizeInBytes);
  inc(result, FPlanDisplay.sizeInBytes);
  inc(result, FSubPlan.sizeInBytes);
  inc(result, FSubPlanDisplay.sizeInBytes);
  inc(result, FClass_.sizeInBytes);
  inc(result, FClassDisplay.sizeInBytes);
  inc(result, FSubClass.sizeInBytes);
  inc(result, FSubClassDisplay.sizeInBytes);
end;

{ TFhirCoverageGroupingListEnumerator }

Constructor TFhirCoverageGroupingListEnumerator.Create(list : TFhirCoverageGroupingList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageGroupingListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageGroupingListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageGroupingListEnumerator.GetCurrent : TFhirCoverageGrouping;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageGroupingListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCoverageGroupingList }
procedure TFhirCoverageGroupingList.AddItem(value: TFhirCoverageGrouping);
begin
  assert(value.ClassName = 'TFhirCoverageGrouping', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverageGrouping');
  add(value);
end;

function TFhirCoverageGroupingList.Append: TFhirCoverageGrouping;
begin
  result := TFhirCoverageGrouping.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageGroupingList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageGroupingList.GetEnumerator : TFhirCoverageGroupingListEnumerator;
begin
  result := TFhirCoverageGroupingListEnumerator.Create(self.link);
end;

function TFhirCoverageGroupingList.Clone: TFhirCoverageGroupingList;
begin
  result := TFhirCoverageGroupingList(inherited Clone);
end;

function TFhirCoverageGroupingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageGroupingList.GetItemN(index: Integer): TFhirCoverageGrouping;
begin
  result := TFhirCoverageGrouping(ObjectByIndex[index]);
end;

function TFhirCoverageGroupingList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverageGrouping;
end;
function TFhirCoverageGroupingList.IndexOf(value: TFhirCoverageGrouping): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageGroupingList.Insert(index: Integer): TFhirCoverageGrouping;
begin
  result := TFhirCoverageGrouping.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageGroupingList.InsertItem(index: Integer; value: TFhirCoverageGrouping);
begin
  assert(value is TFhirCoverageGrouping);
  Inherited Insert(index, value);
end;

function TFhirCoverageGroupingList.Item(index: Integer): TFhirCoverageGrouping;
begin
  result := TFhirCoverageGrouping(ObjectByIndex[index]);
end;

function TFhirCoverageGroupingList.Link: TFhirCoverageGroupingList;
begin
  result := TFhirCoverageGroupingList(inherited Link);
end;

procedure TFhirCoverageGroupingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageGroupingList.SetItemByIndex(index: Integer; value: TFhirCoverageGrouping);
begin
  assert(value is TFhirCoverageGrouping);
  FhirCoverageGroupings[index] := value;
end;

procedure TFhirCoverageGroupingList.SetItemN(index: Integer; value: TFhirCoverageGrouping);
begin
  assert(value is TFhirCoverageGrouping);
  ObjectByIndex[index] := value;
end;

{ TFhirCoverage }

constructor TFhirCoverage.Create;
begin
  inherited;
end;

destructor TFhirCoverage.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FType_.free;
  FPolicyHolder.free;
  FSubscriber.free;
  FSubscriberId.free;
  FBeneficiary.free;
  FRelationship.free;
  FPeriod.free;
  FPayorList.Free;
  FGrouping.free;
  FDependent.free;
  FSequence.free;
  FOrder.free;
  FNetwork.free;
  FContractList.Free;
  inherited;
end;

function TFhirCoverage.GetResourceType : TFhirResourceType;
begin
  result := frtCoverage;
end;

procedure TFhirCoverage.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCoverage(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCoverage(oSource).FIdentifierList);
  end;
  FStatus := TFhirCoverage(oSource).FStatus.Link;
  type_ := TFhirCoverage(oSource).type_.Clone;
  policyHolder := TFhirCoverage(oSource).policyHolder.Clone;
  subscriber := TFhirCoverage(oSource).subscriber.Clone;
  subscriberIdElement := TFhirCoverage(oSource).subscriberIdElement.Clone;
  beneficiary := TFhirCoverage(oSource).beneficiary.Clone;
  relationship := TFhirCoverage(oSource).relationship.Clone;
  period := TFhirCoverage(oSource).period.Clone;
  if (TFhirCoverage(oSource).FPayorList = nil) then
  begin
    FPayorList.free;
    FPayorList := nil;
  end
  else
  begin
    if FPayorList = nil then
      FPayorList := TFhirReferenceList{Resource}.Create;
    FPayorList.Assign(TFhirCoverage(oSource).FPayorList);
  end;
  grouping := TFhirCoverage(oSource).grouping.Clone;
  dependentElement := TFhirCoverage(oSource).dependentElement.Clone;
  sequenceElement := TFhirCoverage(oSource).sequenceElement.Clone;
  orderElement := TFhirCoverage(oSource).orderElement.Clone;
  networkElement := TFhirCoverage(oSource).networkElement.Clone;
  if (TFhirCoverage(oSource).FContractList = nil) then
  begin
    FContractList.free;
    FContractList := nil;
  end
  else
  begin
    if FContractList = nil then
      FContractList := TFhirReferenceList{TFhirContract}.Create;
    FContractList.Assign(TFhirCoverage(oSource).FContractList);
  end;
end;

procedure TFhirCoverage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'policyHolder') Then
     list.add(self.link, 'policyHolder', FPolicyHolder.Link);
  if (child_name = 'subscriber') Then
     list.add(self.link, 'subscriber', FSubscriber.Link);
  if (child_name = 'subscriberId') Then
     list.add(self.link, 'subscriberId', FSubscriberId.Link);
  if (child_name = 'beneficiary') Then
     list.add(self.link, 'beneficiary', FBeneficiary.Link);
  if (child_name = 'relationship') Then
     list.add(self.link, 'relationship', FRelationship.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'payor') Then
    list.addAll(self, 'payor', FPayorList);
  if (child_name = 'grouping') Then
     list.add(self.link, 'grouping', FGrouping.Link);
  if (child_name = 'dependent') Then
     list.add(self.link, 'dependent', FDependent.Link);
  if (child_name = 'sequence') Then
     list.add(self.link, 'sequence', FSequence.Link);
  if (child_name = 'order') Then
     list.add(self.link, 'order', FOrder.Link);
  if (child_name = 'network') Then
     list.add(self.link, 'network', FNetwork.Link);
  if (child_name = 'contract') Then
    list.addAll(self, 'contract', FContractList);
end;

procedure TFhirCoverage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'policyHolder', 'Reference(Patient|RelatedPerson|Organization)', false, TFhirReference{Resource}, FPolicyHolder.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subscriber', 'Reference(Patient|RelatedPerson)', false, TFhirReference{Resource}, FSubscriber.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subscriberId', 'string', false, TFhirString, FSubscriberId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'beneficiary', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FBeneficiary.Link));{2}
  oList.add(TFHIRProperty.create(self, 'relationship', 'CodeableConcept', false, TFhirCodeableConcept, FRelationship.Link));{2}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'payor', 'Reference(Organization|Patient|RelatedPerson)', true, TFhirReference{Resource}, FPayorList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'grouping', '', false, TFhirCoverageGrouping, FGrouping.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dependent', 'string', false, TFhirString, FDependent.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sequence', 'string', false, TFhirString, FSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'order', 'positiveInt', false, TFhirPositiveInt, FOrder.Link));{2}
  oList.add(TFHIRProperty.create(self, 'network', 'string', false, TFhirString, FNetwork.Link));{2}
  oList.add(TFHIRProperty.create(self, 'contract', 'Reference(Contract)', true, TFhirReference{TFhirContract}, FContractList.Link)){3};
end;

function TFhirCoverage.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFmStatusEnum, CODES_TFhirFmStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'policyHolder') then
  begin
    PolicyHolder := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'subscriber') then
  begin
    Subscriber := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'subscriberId') then
  begin
    SubscriberIdElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'beneficiary') then
  begin
    Beneficiary := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'relationship') then
  begin
    Relationship := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'payor') then
  begin
    PayorList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'grouping') then
  begin
    Grouping := propValue as TFhirCoverageGrouping{4b};
    result := propValue;
  end
  else if (propName = 'dependent') then
  begin
    DependentElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'sequence') then
  begin
    SequenceElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'order') then
  begin
    OrderElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'network') then
  begin
    NetworkElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'contract') then
  begin
    ContractList.add(propValue as TFhirReference{TFhirContract}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirCoverage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'payor') then PayorList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'contract') then ContractList.insertItem(index, propValue as TFhirReference{TFhirContract}){2a}
  else inherited;
end;

function TFhirCoverage.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'policyHolder') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'subscriber') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'subscriberId') then result := TFhirString.create() {5b}
  else if (propName = 'beneficiary') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'relationship') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'period') then result := TFhirPeriod.create(){4b}
  else if (propName = 'payor') then result := PayorList.new(){2}
  else if (propName = 'grouping') then result := TFhirCoverageGrouping.create(){4b}
  else if (propName = 'dependent') then result := TFhirString.create() {5b}
  else if (propName = 'sequence') then result := TFhirString.create() {5b}
  else if (propName = 'order') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'network') then result := TFhirString.create() {5b}
  else if (propName = 'contract') then result := ContractList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCoverage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'policyHolder') then result := 'Reference'
  else if (propName = 'subscriber') then result := 'Reference'
  else if (propName = 'subscriberId') then result := 'string'
  else if (propName = 'beneficiary') then result := 'Reference'
  else if (propName = 'relationship') then result := 'CodeableConcept'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'payor') then result := 'Reference'
  else if (propName = 'grouping') then result := ''
  else if (propName = 'dependent') then result := 'string'
  else if (propName = 'sequence') then result := 'string'
  else if (propName = 'order') then result := 'positiveInt'
  else if (propName = 'network') then result := 'string'
  else if (propName = 'contract') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCoverage.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'policyHolder') then PolicyHolderElement := nil
  else if (propName = 'subscriber') then SubscriberElement := nil
  else if (propName = 'subscriberId') then SubscriberIdElement := nil
  else if (propName = 'beneficiary') then BeneficiaryElement := nil
  else if (propName = 'relationship') then RelationshipElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'payor') then deletePropertyValue('payor', PayorList, value) {2}
  else if (propName = 'grouping') then GroupingElement := nil
  else if (propName = 'dependent') then DependentElement := nil
  else if (propName = 'sequence') then SequenceElement := nil
  else if (propName = 'order') then OrderElement := nil
  else if (propName = 'network') then NetworkElement := nil
  else if (propName = 'contract') then deletePropertyValue('contract', ContractList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCoverage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFmStatusEnum, CODES_TFhirFmStatusEnum, new){4}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'policyHolder') then PolicyHolderElement := new as TFhirReference{Resource}{4}
  else if (propName = 'subscriber') then SubscriberElement := new as TFhirReference{Resource}{4}
  else if (propName = 'subscriberId') then SubscriberIdElement := asString(new){5b}
  else if (propName = 'beneficiary') then BeneficiaryElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'relationship') then RelationshipElement := new as TFhirCodeableConcept{4}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else if (propName = 'payor') then replacePropertyValue('payor', PayorList, existing, new) {2}
  else if (propName = 'grouping') then GroupingElement := new as TFhirCoverageGrouping{4}
  else if (propName = 'dependent') then DependentElement := asString(new){5b}
  else if (propName = 'sequence') then SequenceElement := asString(new){5b}
  else if (propName = 'order') then OrderElement := asPositiveInt(new){5b}
  else if (propName = 'network') then NetworkElement := asString(new){5b}
  else if (propName = 'contract') then replacePropertyValue('contract', ContractList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCoverage.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'payor') then PayorList.move(source, destination){2a}
  else if (propName = 'contract') then ContractList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCoverage.fhirType : string;
begin
  result := 'Coverage';
end;

function TFhirCoverage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FType_) and isEmptyProp(FPolicyHolder) and isEmptyProp(FSubscriber) and isEmptyProp(FSubscriberId) and isEmptyProp(FBeneficiary) and isEmptyProp(FRelationship) and isEmptyProp(FPeriod) and isEmptyProp(FpayorList) and isEmptyProp(FGrouping) and isEmptyProp(FDependent) and isEmptyProp(FSequence) and isEmptyProp(FOrder) and isEmptyProp(FNetwork) and isEmptyProp(FcontractList);
end;

function TFhirCoverage.equals(other : TObject) : boolean;
var
  o : TFhirCoverage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCoverage)) then
    result := false
  else
  begin
    o := TFhirCoverage(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(type_Element, o.type_Element, true) and compareDeep(policyHolderElement, o.policyHolderElement, true) and
      compareDeep(subscriberElement, o.subscriberElement, true) and compareDeep(subscriberIdElement, o.subscriberIdElement, true) and
      compareDeep(beneficiaryElement, o.beneficiaryElement, true) and compareDeep(relationshipElement, o.relationshipElement, true) and
      compareDeep(periodElement, o.periodElement, true) and compareDeep(payorList, o.payorList, true) and
      compareDeep(groupingElement, o.groupingElement, true) and compareDeep(dependentElement, o.dependentElement, true) and
      compareDeep(sequenceElement, o.sequenceElement, true) and compareDeep(orderElement, o.orderElement, true) and
      compareDeep(networkElement, o.networkElement, true) and compareDeep(contractList, o.contractList, true);
  end;
end;

function TFhirCoverage.Link : TFhirCoverage;
begin
  result := TFhirCoverage(inherited Link);
end;

function TFhirCoverage.Clone : TFhirCoverage;
begin
  result := TFhirCoverage(inherited Clone);
end;

procedure TFhirCoverage.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('type');
  fields.add('policyHolder');
  fields.add('subscriber');
  fields.add('subscriberId');
  fields.add('beneficiary');
  fields.add('relationship');
  fields.add('period');
  fields.add('payor');
  fields.add('grouping');
  fields.add('dependent');
  fields.add('sequence');
  fields.add('order');
  fields.add('network');
  fields.add('contract');
end;

{ TFhirCoverage }

Function TFhirCoverage.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirCoverage.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirCoverage.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirCoverage.GetStatusST : TFhirFmStatusEnum;
begin
  if FStatus = nil then
    result := TFhirFmStatusEnum(0)
  else
    result := TFhirFmStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirFmStatusEnum, FStatus.value));
end;

Procedure TFhirCoverage.SetStatusST(value : TFhirFmStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFmStatusEnum[value], CODES_TFhirFmStatusEnum[value]);
end;

Procedure TFhirCoverage.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirCoverage.SetPolicyHolder(value : TFhirReference{Resource});
begin
  FPolicyHolder.free;
  FPolicyHolder := value;
end;

Procedure TFhirCoverage.SetSubscriber(value : TFhirReference{Resource});
begin
  FSubscriber.free;
  FSubscriber := value;
end;

Procedure TFhirCoverage.SetSubscriberId(value : TFhirString);
begin
  FSubscriberId.free;
  FSubscriberId := value;
end;

Function TFhirCoverage.GetSubscriberIdST : String;
begin
  if FSubscriberId = nil then
    result := ''
  else
    result := FSubscriberId.value;
end;

Procedure TFhirCoverage.SetSubscriberIdST(value : String);
begin
  if value <> '' then
  begin
    if FSubscriberId = nil then
      FSubscriberId := TFhirString.create;
    FSubscriberId.value := value
  end
  else if FSubscriberId <> nil then
    FSubscriberId.value := '';
end;

Procedure TFhirCoverage.SetBeneficiary(value : TFhirReference{TFhirPatient});
begin
  FBeneficiary.free;
  FBeneficiary := value;
end;

Procedure TFhirCoverage.SetRelationship(value : TFhirCodeableConcept);
begin
  FRelationship.free;
  FRelationship := value;
end;

Procedure TFhirCoverage.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Function TFhirCoverage.GetPayorList : TFhirReferenceList{Resource};
begin
  if FPayorList = nil then
    FPayorList := TFhirReferenceList{Resource}.Create;
  result := FPayorList;
end;

Function TFhirCoverage.GetHasPayorList : boolean;
begin
  result := (FPayorList <> nil) and (FPayorList.count > 0);
end;

Procedure TFhirCoverage.SetGrouping(value : TFhirCoverageGrouping);
begin
  FGrouping.free;
  FGrouping := value;
end;

Procedure TFhirCoverage.SetDependent(value : TFhirString);
begin
  FDependent.free;
  FDependent := value;
end;

Function TFhirCoverage.GetDependentST : String;
begin
  if FDependent = nil then
    result := ''
  else
    result := FDependent.value;
end;

Procedure TFhirCoverage.SetDependentST(value : String);
begin
  if value <> '' then
  begin
    if FDependent = nil then
      FDependent := TFhirString.create;
    FDependent.value := value
  end
  else if FDependent <> nil then
    FDependent.value := '';
end;

Procedure TFhirCoverage.SetSequence(value : TFhirString);
begin
  FSequence.free;
  FSequence := value;
end;

Function TFhirCoverage.GetSequenceST : String;
begin
  if FSequence = nil then
    result := ''
  else
    result := FSequence.value;
end;

Procedure TFhirCoverage.SetSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FSequence = nil then
      FSequence := TFhirString.create;
    FSequence.value := value
  end
  else if FSequence <> nil then
    FSequence.value := '';
end;

Procedure TFhirCoverage.SetOrder(value : TFhirPositiveInt);
begin
  FOrder.free;
  FOrder := value;
end;

Function TFhirCoverage.GetOrderST : String;
begin
  if FOrder = nil then
    result := ''
  else
    result := FOrder.value;
end;

Procedure TFhirCoverage.SetOrderST(value : String);
begin
  if value <> '' then
  begin
    if FOrder = nil then
      FOrder := TFhirPositiveInt.create;
    FOrder.value := value
  end
  else if FOrder <> nil then
    FOrder.value := '';
end;

Procedure TFhirCoverage.SetNetwork(value : TFhirString);
begin
  FNetwork.free;
  FNetwork := value;
end;

Function TFhirCoverage.GetNetworkST : String;
begin
  if FNetwork = nil then
    result := ''
  else
    result := FNetwork.value;
end;

Procedure TFhirCoverage.SetNetworkST(value : String);
begin
  if value <> '' then
  begin
    if FNetwork = nil then
      FNetwork := TFhirString.create;
    FNetwork.value := value
  end
  else if FNetwork <> nil then
    FNetwork.value := '';
end;

Function TFhirCoverage.GetContractList : TFhirReferenceList{TFhirContract};
begin
  if FContractList = nil then
    FContractList := TFhirReferenceList{TFhirContract}.Create;
  result := FContractList;
end;

Function TFhirCoverage.GetHasContractList : boolean;
begin
  result := (FContractList <> nil) and (FContractList.count > 0);
end;

function TFhirCoverage.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FPolicyHolder.sizeInBytes);
  inc(result, FSubscriber.sizeInBytes);
  inc(result, FSubscriberId.sizeInBytes);
  inc(result, FBeneficiary.sizeInBytes);
  inc(result, FRelationship.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FpayorList.sizeInBytes);
  inc(result, FGrouping.sizeInBytes);
  inc(result, FDependent.sizeInBytes);
  inc(result, FSequence.sizeInBytes);
  inc(result, FOrder.sizeInBytes);
  inc(result, FNetwork.sizeInBytes);
  inc(result, FcontractList.sizeInBytes);
end;

{ TFhirCoverageListEnumerator }

Constructor TFhirCoverageListEnumerator.Create(list : TFhirCoverageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCoverageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCoverageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCoverageListEnumerator.GetCurrent : TFhirCoverage;
begin
  Result := FList[FIndex];
end;

function TFhirCoverageListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCoverageList }
procedure TFhirCoverageList.AddItem(value: TFhirCoverage);
begin
  assert(value.ClassName = 'TFhirCoverage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCoverage');
  add(value);
end;

function TFhirCoverageList.Append: TFhirCoverage;
begin
  result := TFhirCoverage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageList.ClearItems;
begin
  Clear;
end;

function TFhirCoverageList.GetEnumerator : TFhirCoverageListEnumerator;
begin
  result := TFhirCoverageListEnumerator.Create(self.link);
end;

function TFhirCoverageList.Clone: TFhirCoverageList;
begin
  result := TFhirCoverageList(inherited Clone);
end;

function TFhirCoverageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCoverageList.GetItemN(index: Integer): TFhirCoverage;
begin
  result := TFhirCoverage(ObjectByIndex[index]);
end;

function TFhirCoverageList.ItemClass: TFslObjectClass;
begin
  result := TFhirCoverage;
end;
function TFhirCoverageList.IndexOf(value: TFhirCoverage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCoverageList.Insert(index: Integer): TFhirCoverage;
begin
  result := TFhirCoverage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCoverageList.InsertItem(index: Integer; value: TFhirCoverage);
begin
  assert(value is TFhirCoverage);
  Inherited Insert(index, value);
end;

function TFhirCoverageList.Item(index: Integer): TFhirCoverage;
begin
  result := TFhirCoverage(ObjectByIndex[index]);
end;

function TFhirCoverageList.Link: TFhirCoverageList;
begin
  result := TFhirCoverageList(inherited Link);
end;

procedure TFhirCoverageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCoverageList.SetItemByIndex(index: Integer; value: TFhirCoverage);
begin
  assert(value is TFhirCoverage);
  FhirCoverages[index] := value;
end;

procedure TFhirCoverageList.SetItemN(index: Integer; value: TFhirCoverage);
begin
  assert(value is TFhirCoverage);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_COVERAGE}

{$IFDEF FHIR_DETECTEDISSUE}

{ TFhirDetectedIssueMitigation }

constructor TFhirDetectedIssueMitigation.Create;
begin
  inherited;
end;

destructor TFhirDetectedIssueMitigation.Destroy;
begin
  FAction.free;
  FDate.free;
  FAuthor.free;
  inherited;
end;

procedure TFhirDetectedIssueMitigation.Assign(oSource : TFslObject);
begin
  inherited;
  action := TFhirDetectedIssueMitigation(oSource).action.Clone;
  dateElement := TFhirDetectedIssueMitigation(oSource).dateElement.Clone;
  author := TFhirDetectedIssueMitigation(oSource).author.Clone;
end;

procedure TFhirDetectedIssueMitigation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'action') Then
     list.add(self.link, 'action', FAction.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
end;

procedure TFhirDetectedIssueMitigation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'action', 'CodeableConcept', false, TFhirCodeableConcept, FAction.Link));{2}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'author', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FAuthor.Link));{2}
end;

function TFhirDetectedIssueMitigation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'action') then
  begin
    Action := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDetectedIssueMitigation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDetectedIssueMitigation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'action') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'author') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDetectedIssueMitigation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'action') then result := 'CodeableConcept'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'author') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDetectedIssueMitigation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'action') then ActionElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'author') then AuthorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDetectedIssueMitigation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'action') then ActionElement := new as TFhirCodeableConcept{4}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'author') then AuthorElement := new as TFhirReference{TFhirPractitioner}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDetectedIssueMitigation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDetectedIssueMitigation.fhirType : string;
begin
  result := 'mitigation';
end;

function TFhirDetectedIssueMitigation.Link : TFhirDetectedIssueMitigation;
begin
  result := TFhirDetectedIssueMitigation(inherited Link);
end;

function TFhirDetectedIssueMitigation.Clone : TFhirDetectedIssueMitigation;
begin
  result := TFhirDetectedIssueMitigation(inherited Clone);
end;

function TFhirDetectedIssueMitigation.equals(other : TObject) : boolean;
var
  o : TFhirDetectedIssueMitigation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDetectedIssueMitigation)) then
    result := false
  else
  begin
    o := TFhirDetectedIssueMitigation(other);
    result := compareDeep(actionElement, o.actionElement, true) and compareDeep(dateElement, o.dateElement, true) and
      compareDeep(authorElement, o.authorElement, true);
  end;
end;

function TFhirDetectedIssueMitigation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAction) and isEmptyProp(FDate) and isEmptyProp(FAuthor);
end;

procedure TFhirDetectedIssueMitigation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('action');
  fields.add('date');
  fields.add('author');
end;

{ TFhirDetectedIssueMitigation }

Procedure TFhirDetectedIssueMitigation.SetAction(value : TFhirCodeableConcept);
begin
  FAction.free;
  FAction := value;
end;

Procedure TFhirDetectedIssueMitigation.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirDetectedIssueMitigation.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirDetectedIssueMitigation.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirDetectedIssueMitigation.SetAuthor(value : TFhirReference{TFhirPractitioner});
begin
  FAuthor.free;
  FAuthor := value;
end;

function TFhirDetectedIssueMitigation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FAction.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FAuthor.sizeInBytes);
end;

{ TFhirDetectedIssueMitigationListEnumerator }

Constructor TFhirDetectedIssueMitigationListEnumerator.Create(list : TFhirDetectedIssueMitigationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDetectedIssueMitigationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDetectedIssueMitigationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDetectedIssueMitigationListEnumerator.GetCurrent : TFhirDetectedIssueMitigation;
begin
  Result := FList[FIndex];
end;

function TFhirDetectedIssueMitigationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDetectedIssueMitigationList }
procedure TFhirDetectedIssueMitigationList.AddItem(value: TFhirDetectedIssueMitigation);
begin
  assert(value.ClassName = 'TFhirDetectedIssueMitigation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDetectedIssueMitigation');
  add(value);
end;

function TFhirDetectedIssueMitigationList.Append: TFhirDetectedIssueMitigation;
begin
  result := TFhirDetectedIssueMitigation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDetectedIssueMitigationList.ClearItems;
begin
  Clear;
end;

function TFhirDetectedIssueMitigationList.GetEnumerator : TFhirDetectedIssueMitigationListEnumerator;
begin
  result := TFhirDetectedIssueMitigationListEnumerator.Create(self.link);
end;

function TFhirDetectedIssueMitigationList.Clone: TFhirDetectedIssueMitigationList;
begin
  result := TFhirDetectedIssueMitigationList(inherited Clone);
end;

function TFhirDetectedIssueMitigationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDetectedIssueMitigationList.GetItemN(index: Integer): TFhirDetectedIssueMitigation;
begin
  result := TFhirDetectedIssueMitigation(ObjectByIndex[index]);
end;

function TFhirDetectedIssueMitigationList.ItemClass: TFslObjectClass;
begin
  result := TFhirDetectedIssueMitigation;
end;
function TFhirDetectedIssueMitigationList.IndexOf(value: TFhirDetectedIssueMitigation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDetectedIssueMitigationList.Insert(index: Integer): TFhirDetectedIssueMitigation;
begin
  result := TFhirDetectedIssueMitigation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDetectedIssueMitigationList.InsertItem(index: Integer; value: TFhirDetectedIssueMitigation);
begin
  assert(value is TFhirDetectedIssueMitigation);
  Inherited Insert(index, value);
end;

function TFhirDetectedIssueMitigationList.Item(index: Integer): TFhirDetectedIssueMitigation;
begin
  result := TFhirDetectedIssueMitigation(ObjectByIndex[index]);
end;

function TFhirDetectedIssueMitigationList.Link: TFhirDetectedIssueMitigationList;
begin
  result := TFhirDetectedIssueMitigationList(inherited Link);
end;

procedure TFhirDetectedIssueMitigationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDetectedIssueMitigationList.SetItemByIndex(index: Integer; value: TFhirDetectedIssueMitigation);
begin
  assert(value is TFhirDetectedIssueMitigation);
  FhirDetectedIssueMitigations[index] := value;
end;

procedure TFhirDetectedIssueMitigationList.SetItemN(index: Integer; value: TFhirDetectedIssueMitigation);
begin
  assert(value is TFhirDetectedIssueMitigation);
  ObjectByIndex[index] := value;
end;

{ TFhirDetectedIssue }

constructor TFhirDetectedIssue.Create;
begin
  inherited;
end;

destructor TFhirDetectedIssue.Destroy;
begin
  FIdentifier.free;
  FStatus.free;
  FCategory.free;
  FSeverity.free;
  FPatient.free;
  FDate.free;
  FAuthor.free;
  FImplicatedList.Free;
  FDetail.free;
  FReference.free;
  FMitigationList.Free;
  inherited;
end;

function TFhirDetectedIssue.GetResourceType : TFhirResourceType;
begin
  result := frtDetectedIssue;
end;

procedure TFhirDetectedIssue.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirDetectedIssue(oSource).identifier.Clone;
  FStatus := TFhirDetectedIssue(oSource).FStatus.Link;
  category := TFhirDetectedIssue(oSource).category.Clone;
  FSeverity := TFhirDetectedIssue(oSource).FSeverity.Link;
  patient := TFhirDetectedIssue(oSource).patient.Clone;
  dateElement := TFhirDetectedIssue(oSource).dateElement.Clone;
  author := TFhirDetectedIssue(oSource).author.Clone;
  if (TFhirDetectedIssue(oSource).FImplicatedList = nil) then
  begin
    FImplicatedList.free;
    FImplicatedList := nil;
  end
  else
  begin
    if FImplicatedList = nil then
      FImplicatedList := TFhirReferenceList{TFhirReference}.Create;
    FImplicatedList.Assign(TFhirDetectedIssue(oSource).FImplicatedList);
  end;
  detailElement := TFhirDetectedIssue(oSource).detailElement.Clone;
  referenceElement := TFhirDetectedIssue(oSource).referenceElement.Clone;
  if (TFhirDetectedIssue(oSource).FMitigationList = nil) then
  begin
    FMitigationList.free;
    FMitigationList := nil;
  end
  else
  begin
    if FMitigationList = nil then
      FMitigationList := TFhirDetectedIssueMitigationList.Create;
    FMitigationList.Assign(TFhirDetectedIssue(oSource).FMitigationList);
  end;
end;

procedure TFhirDetectedIssue.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'severity') Then
     list.add(self.link, 'severity', FSeverity.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
  if (child_name = 'implicated') Then
    list.addAll(self, 'implicated', FImplicatedList);
  if (child_name = 'detail') Then
     list.add(self.link, 'detail', FDetail.Link);
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
  if (child_name = 'mitigation') Then
    list.addAll(self, 'mitigation', FMitigationList);
end;

procedure TFhirDetectedIssue.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'severity', 'code', false, TFHIREnum, FSeverity.Link));{1}
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'author', 'Reference(Practitioner|Device)', false, TFhirReference{Resource}, FAuthor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'implicated', 'Reference(Any)', true, TFhirReference{TFhirReference}, FImplicatedList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'detail', 'string', false, TFhirString, FDetail.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reference', 'uri', false, TFhirUri, FReference.Link));{2}
  oList.add(TFHIRProperty.create(self, 'mitigation', '', true, TFhirDetectedIssueMitigation, FMitigationList.Link)){3};
end;

function TFhirDetectedIssue.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirObservationStatusEnum, CODES_TFhirObservationStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'severity') then
  begin
    SeverityElement := asEnum(SYSTEMS_TFhirDetectedissueSeverityEnum, CODES_TFhirDetectedissueSeverityEnum, propValue);
    result := propValue
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'implicated') then
  begin
    ImplicatedList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'reference') then
  begin
    ReferenceElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'mitigation') then
  begin
    MitigationList.add(propValue as TFhirDetectedIssueMitigation){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirDetectedIssue.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'implicated') then ImplicatedList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'mitigation') then MitigationList.insertItem(index, propValue as TFhirDetectedIssueMitigation){2a}
  else inherited;
end;

function TFhirDetectedIssue.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'author') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'implicated') then result := ImplicatedList.new(){2}
  else if (propName = 'detail') then result := TFhirString.create() {5b}
  else if (propName = 'reference') then result := TFhirUri.create() {5b}
  else if (propName = 'mitigation') then result := MitigationList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDetectedIssue.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'severity') then result := 'code'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'implicated') then result := 'Reference'
  else if (propName = 'detail') then result := 'string'
  else if (propName = 'reference') then result := 'uri'
  else if (propName = 'mitigation') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDetectedIssue.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'severity') then SeverityElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'author') then AuthorElement := nil
  else if (propName = 'implicated') then deletePropertyValue('implicated', ImplicatedList, value) {2}
  else if (propName = 'detail') then DetailElement := nil
  else if (propName = 'reference') then ReferenceElement := nil
  else if (propName = 'mitigation') then deletePropertyValue('mitigation', MitigationList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDetectedIssue.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirObservationStatusEnum, CODES_TFhirObservationStatusEnum, new){4}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'severity') then SeverityElement := asEnum(SYSTEMS_TFhirDetectedissueSeverityEnum, CODES_TFhirDetectedissueSeverityEnum, new){4}
  else if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'author') then AuthorElement := new as TFhirReference{Resource}{4}
  else if (propName = 'implicated') then replacePropertyValue('implicated', ImplicatedList, existing, new) {2}
  else if (propName = 'detail') then DetailElement := asString(new){5b}
  else if (propName = 'reference') then ReferenceElement := asUri(new){5b}
  else if (propName = 'mitigation') then replacePropertyValue('mitigation', MitigationList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDetectedIssue.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'implicated') then ImplicatedList.move(source, destination){2a}
  else if (propName = 'mitigation') then MitigationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDetectedIssue.fhirType : string;
begin
  result := 'DetectedIssue';
end;

function TFhirDetectedIssue.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FStatus) and isEmptyProp(FCategory) and isEmptyProp(FSeverity) and isEmptyProp(FPatient) and isEmptyProp(FDate) and isEmptyProp(FAuthor) and isEmptyProp(FimplicatedList) and isEmptyProp(FDetail) and isEmptyProp(FReference) and isEmptyProp(FmitigationList);
end;

function TFhirDetectedIssue.equals(other : TObject) : boolean;
var
  o : TFhirDetectedIssue;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDetectedIssue)) then
    result := false
  else
  begin
    o := TFhirDetectedIssue(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(categoryElement, o.categoryElement, true) and compareDeep(severityElement, o.severityElement, true) and
      compareDeep(patientElement, o.patientElement, true) and compareDeep(dateElement, o.dateElement, true) and
      compareDeep(authorElement, o.authorElement, true) and compareDeep(implicatedList, o.implicatedList, true) and
      compareDeep(detailElement, o.detailElement, true) and compareDeep(referenceElement, o.referenceElement, true) and
      compareDeep(mitigationList, o.mitigationList, true);
  end;
end;

function TFhirDetectedIssue.Link : TFhirDetectedIssue;
begin
  result := TFhirDetectedIssue(inherited Link);
end;

function TFhirDetectedIssue.Clone : TFhirDetectedIssue;
begin
  result := TFhirDetectedIssue(inherited Clone);
end;

procedure TFhirDetectedIssue.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('category');
  fields.add('severity');
  fields.add('patient');
  fields.add('date');
  fields.add('author');
  fields.add('implicated');
  fields.add('detail');
  fields.add('reference');
  fields.add('mitigation');
end;

{ TFhirDetectedIssue }

Procedure TFhirDetectedIssue.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirDetectedIssue.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirDetectedIssue.GetStatusST : TFhirObservationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirObservationStatusEnum(0)
  else
    result := TFhirObservationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirObservationStatusEnum, FStatus.value));
end;

Procedure TFhirDetectedIssue.SetStatusST(value : TFhirObservationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirObservationStatusEnum[value], CODES_TFhirObservationStatusEnum[value]);
end;

Procedure TFhirDetectedIssue.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirDetectedIssue.SetSeverity(value : TFhirEnum);
begin
  FSeverity.free;
  FSeverity := value;
end;

Function TFhirDetectedIssue.GetSeverityST : TFhirDetectedissueSeverityEnum;
begin
  if FSeverity = nil then
    result := TFhirDetectedissueSeverityEnum(0)
  else
    result := TFhirDetectedissueSeverityEnum(StringArrayIndexOfSensitive(CODES_TFhirDetectedissueSeverityEnum, FSeverity.value));
end;

Procedure TFhirDetectedIssue.SetSeverityST(value : TFhirDetectedissueSeverityEnum);
begin
  if ord(value) = 0 then
    SeverityElement := nil
  else
    SeverityElement := TFhirEnum.create(SYSTEMS_TFhirDetectedissueSeverityEnum[value], CODES_TFhirDetectedissueSeverityEnum[value]);
end;

Procedure TFhirDetectedIssue.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Procedure TFhirDetectedIssue.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirDetectedIssue.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirDetectedIssue.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirDetectedIssue.SetAuthor(value : TFhirReference{Resource});
begin
  FAuthor.free;
  FAuthor := value;
end;

Function TFhirDetectedIssue.GetImplicatedList : TFhirReferenceList{TFhirReference};
begin
  if FImplicatedList = nil then
    FImplicatedList := TFhirReferenceList{TFhirReference}.Create;
  result := FImplicatedList;
end;

Function TFhirDetectedIssue.GetHasImplicatedList : boolean;
begin
  result := (FImplicatedList <> nil) and (FImplicatedList.count > 0);
end;

Procedure TFhirDetectedIssue.SetDetail(value : TFhirString);
begin
  FDetail.free;
  FDetail := value;
end;

Function TFhirDetectedIssue.GetDetailST : String;
begin
  if FDetail = nil then
    result := ''
  else
    result := FDetail.value;
end;

Procedure TFhirDetectedIssue.SetDetailST(value : String);
begin
  if value <> '' then
  begin
    if FDetail = nil then
      FDetail := TFhirString.create;
    FDetail.value := value
  end
  else if FDetail <> nil then
    FDetail.value := '';
end;

Procedure TFhirDetectedIssue.SetReference(value : TFhirUri);
begin
  FReference.free;
  FReference := value;
end;

Function TFhirDetectedIssue.GetReferenceST : String;
begin
  if FReference = nil then
    result := ''
  else
    result := FReference.value;
end;

Procedure TFhirDetectedIssue.SetReferenceST(value : String);
begin
  if value <> '' then
  begin
    if FReference = nil then
      FReference := TFhirUri.create;
    FReference.value := value
  end
  else if FReference <> nil then
    FReference.value := '';
end;

Function TFhirDetectedIssue.GetMitigationList : TFhirDetectedIssueMitigationList;
begin
  if FMitigationList = nil then
    FMitigationList := TFhirDetectedIssueMitigationList.Create;
  result := FMitigationList;
end;

Function TFhirDetectedIssue.GetHasMitigationList : boolean;
begin
  result := (FMitigationList <> nil) and (FMitigationList.count > 0);
end;

function TFhirDetectedIssue.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FSeverity.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FAuthor.sizeInBytes);
  inc(result, FimplicatedList.sizeInBytes);
  inc(result, FDetail.sizeInBytes);
  inc(result, FReference.sizeInBytes);
  inc(result, FmitigationList.sizeInBytes);
end;

{ TFhirDetectedIssueListEnumerator }

Constructor TFhirDetectedIssueListEnumerator.Create(list : TFhirDetectedIssueList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDetectedIssueListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDetectedIssueListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDetectedIssueListEnumerator.GetCurrent : TFhirDetectedIssue;
begin
  Result := FList[FIndex];
end;

function TFhirDetectedIssueListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDetectedIssueList }
procedure TFhirDetectedIssueList.AddItem(value: TFhirDetectedIssue);
begin
  assert(value.ClassName = 'TFhirDetectedIssue', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDetectedIssue');
  add(value);
end;

function TFhirDetectedIssueList.Append: TFhirDetectedIssue;
begin
  result := TFhirDetectedIssue.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDetectedIssueList.ClearItems;
begin
  Clear;
end;

function TFhirDetectedIssueList.GetEnumerator : TFhirDetectedIssueListEnumerator;
begin
  result := TFhirDetectedIssueListEnumerator.Create(self.link);
end;

function TFhirDetectedIssueList.Clone: TFhirDetectedIssueList;
begin
  result := TFhirDetectedIssueList(inherited Clone);
end;

function TFhirDetectedIssueList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDetectedIssueList.GetItemN(index: Integer): TFhirDetectedIssue;
begin
  result := TFhirDetectedIssue(ObjectByIndex[index]);
end;

function TFhirDetectedIssueList.ItemClass: TFslObjectClass;
begin
  result := TFhirDetectedIssue;
end;
function TFhirDetectedIssueList.IndexOf(value: TFhirDetectedIssue): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDetectedIssueList.Insert(index: Integer): TFhirDetectedIssue;
begin
  result := TFhirDetectedIssue.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDetectedIssueList.InsertItem(index: Integer; value: TFhirDetectedIssue);
begin
  assert(value is TFhirDetectedIssue);
  Inherited Insert(index, value);
end;

function TFhirDetectedIssueList.Item(index: Integer): TFhirDetectedIssue;
begin
  result := TFhirDetectedIssue(ObjectByIndex[index]);
end;

function TFhirDetectedIssueList.Link: TFhirDetectedIssueList;
begin
  result := TFhirDetectedIssueList(inherited Link);
end;

procedure TFhirDetectedIssueList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDetectedIssueList.SetItemByIndex(index: Integer; value: TFhirDetectedIssue);
begin
  assert(value is TFhirDetectedIssue);
  FhirDetectedIssues[index] := value;
end;

procedure TFhirDetectedIssueList.SetItemN(index: Integer; value: TFhirDetectedIssue);
begin
  assert(value is TFhirDetectedIssue);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_DETECTEDISSUE}

{$IFDEF FHIR_DEVICEREQUEST}

{ TFhirDeviceRequestRequester }

constructor TFhirDeviceRequestRequester.Create;
begin
  inherited;
end;

destructor TFhirDeviceRequestRequester.Destroy;
begin
  FAgent.free;
  FOnBehalfOf.free;
  inherited;
end;

procedure TFhirDeviceRequestRequester.Assign(oSource : TFslObject);
begin
  inherited;
  agent := TFhirDeviceRequestRequester(oSource).agent.Clone;
  onBehalfOf := TFhirDeviceRequestRequester(oSource).onBehalfOf.Clone;
end;

procedure TFhirDeviceRequestRequester.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'agent') Then
     list.add(self.link, 'agent', FAgent.Link);
  if (child_name = 'onBehalfOf') Then
     list.add(self.link, 'onBehalfOf', FOnBehalfOf.Link);
end;

procedure TFhirDeviceRequestRequester.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'agent', 'Reference(Device|Practitioner|Organization)', false, TFhirReference{Resource}, FAgent.Link));{2}
  oList.add(TFHIRProperty.create(self, 'onBehalfOf', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FOnBehalfOf.Link));{2}
end;

function TFhirDeviceRequestRequester.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'agent') then
  begin
    Agent := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'onBehalfOf') then
  begin
    OnBehalfOf := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceRequestRequester.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDeviceRequestRequester.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'agent') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'onBehalfOf') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceRequestRequester.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'agent') then result := 'Reference'
  else if (propName = 'onBehalfOf') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceRequestRequester.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'agent') then AgentElement := nil
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceRequestRequester.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'agent') then AgentElement := new as TFhirReference{Resource}{4}
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := new as TFhirReference{TFhirOrganization}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceRequestRequester.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceRequestRequester.fhirType : string;
begin
  result := 'requester';
end;

function TFhirDeviceRequestRequester.Link : TFhirDeviceRequestRequester;
begin
  result := TFhirDeviceRequestRequester(inherited Link);
end;

function TFhirDeviceRequestRequester.Clone : TFhirDeviceRequestRequester;
begin
  result := TFhirDeviceRequestRequester(inherited Clone);
end;

function TFhirDeviceRequestRequester.equals(other : TObject) : boolean;
var
  o : TFhirDeviceRequestRequester;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceRequestRequester)) then
    result := false
  else
  begin
    o := TFhirDeviceRequestRequester(other);
    result := compareDeep(agentElement, o.agentElement, true) and compareDeep(onBehalfOfElement, o.onBehalfOfElement, true);
  end;
end;

function TFhirDeviceRequestRequester.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAgent) and isEmptyProp(FOnBehalfOf);
end;

procedure TFhirDeviceRequestRequester.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('agent');
  fields.add('onBehalfOf');
end;

{ TFhirDeviceRequestRequester }

Procedure TFhirDeviceRequestRequester.SetAgent(value : TFhirReference{Resource});
begin
  FAgent.free;
  FAgent := value;
end;

Procedure TFhirDeviceRequestRequester.SetOnBehalfOf(value : TFhirReference{TFhirOrganization});
begin
  FOnBehalfOf.free;
  FOnBehalfOf := value;
end;

function TFhirDeviceRequestRequester.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FAgent.sizeInBytes);
  inc(result, FOnBehalfOf.sizeInBytes);
end;

{ TFhirDeviceRequestRequesterListEnumerator }

Constructor TFhirDeviceRequestRequesterListEnumerator.Create(list : TFhirDeviceRequestRequesterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceRequestRequesterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceRequestRequesterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceRequestRequesterListEnumerator.GetCurrent : TFhirDeviceRequestRequester;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceRequestRequesterListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDeviceRequestRequesterList }
procedure TFhirDeviceRequestRequesterList.AddItem(value: TFhirDeviceRequestRequester);
begin
  assert(value.ClassName = 'TFhirDeviceRequestRequester', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceRequestRequester');
  add(value);
end;

function TFhirDeviceRequestRequesterList.Append: TFhirDeviceRequestRequester;
begin
  result := TFhirDeviceRequestRequester.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceRequestRequesterList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceRequestRequesterList.GetEnumerator : TFhirDeviceRequestRequesterListEnumerator;
begin
  result := TFhirDeviceRequestRequesterListEnumerator.Create(self.link);
end;

function TFhirDeviceRequestRequesterList.Clone: TFhirDeviceRequestRequesterList;
begin
  result := TFhirDeviceRequestRequesterList(inherited Clone);
end;

function TFhirDeviceRequestRequesterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceRequestRequesterList.GetItemN(index: Integer): TFhirDeviceRequestRequester;
begin
  result := TFhirDeviceRequestRequester(ObjectByIndex[index]);
end;

function TFhirDeviceRequestRequesterList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceRequestRequester;
end;
function TFhirDeviceRequestRequesterList.IndexOf(value: TFhirDeviceRequestRequester): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceRequestRequesterList.Insert(index: Integer): TFhirDeviceRequestRequester;
begin
  result := TFhirDeviceRequestRequester.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceRequestRequesterList.InsertItem(index: Integer; value: TFhirDeviceRequestRequester);
begin
  assert(value is TFhirDeviceRequestRequester);
  Inherited Insert(index, value);
end;

function TFhirDeviceRequestRequesterList.Item(index: Integer): TFhirDeviceRequestRequester;
begin
  result := TFhirDeviceRequestRequester(ObjectByIndex[index]);
end;

function TFhirDeviceRequestRequesterList.Link: TFhirDeviceRequestRequesterList;
begin
  result := TFhirDeviceRequestRequesterList(inherited Link);
end;

procedure TFhirDeviceRequestRequesterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceRequestRequesterList.SetItemByIndex(index: Integer; value: TFhirDeviceRequestRequester);
begin
  assert(value is TFhirDeviceRequestRequester);
  FhirDeviceRequestRequesters[index] := value;
end;

procedure TFhirDeviceRequestRequesterList.SetItemN(index: Integer; value: TFhirDeviceRequestRequester);
begin
  assert(value is TFhirDeviceRequestRequester);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceRequest }

constructor TFhirDeviceRequest.Create;
begin
  inherited;
end;

destructor TFhirDeviceRequest.Destroy;
begin
  FIdentifierList.Free;
  FDefinitionList.Free;
  FBasedOnList.Free;
  FPriorRequestList.Free;
  FGroupIdentifier.free;
  FStatus.free;
  FIntent.free;
  FPriority.free;
  FCode.free;
  FSubject.free;
  FContext.free;
  FOccurrence.free;
  FAuthoredOn.free;
  FRequester.free;
  FPerformerType.free;
  FPerformer.free;
  FReasonCodeList.Free;
  FReasonReferenceList.Free;
  FSupportingInfoList.Free;
  FNoteList.Free;
  FRelevantHistoryList.Free;
  inherited;
end;

function TFhirDeviceRequest.GetResourceType : TFhirResourceType;
begin
  result := frtDeviceRequest;
end;

procedure TFhirDeviceRequest.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirDeviceRequest(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirDeviceRequest(oSource).FIdentifierList);
  end;
  if (TFhirDeviceRequest(oSource).FDefinitionList = nil) then
  begin
    FDefinitionList.free;
    FDefinitionList := nil;
  end
  else
  begin
    if FDefinitionList = nil then
      FDefinitionList := TFhirReferenceList{Resource}.Create;
    FDefinitionList.Assign(TFhirDeviceRequest(oSource).FDefinitionList);
  end;
  if (TFhirDeviceRequest(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList{TFhirReference}.Create;
    FBasedOnList.Assign(TFhirDeviceRequest(oSource).FBasedOnList);
  end;
  if (TFhirDeviceRequest(oSource).FPriorRequestList = nil) then
  begin
    FPriorRequestList.free;
    FPriorRequestList := nil;
  end
  else
  begin
    if FPriorRequestList = nil then
      FPriorRequestList := TFhirReferenceList{TFhirReference}.Create;
    FPriorRequestList.Assign(TFhirDeviceRequest(oSource).FPriorRequestList);
  end;
  groupIdentifier := TFhirDeviceRequest(oSource).groupIdentifier.Clone;
  FStatus := TFhirDeviceRequest(oSource).FStatus.Link;
  intent := TFhirDeviceRequest(oSource).intent.Clone;
  FPriority := TFhirDeviceRequest(oSource).FPriority.Link;
  code := TFhirDeviceRequest(oSource).code.Clone;
  subject := TFhirDeviceRequest(oSource).subject.Clone;
  context := TFhirDeviceRequest(oSource).context.Clone;
  occurrence := TFhirDeviceRequest(oSource).occurrence.Clone;
  authoredOnElement := TFhirDeviceRequest(oSource).authoredOnElement.Clone;
  requester := TFhirDeviceRequest(oSource).requester.Clone;
  performerType := TFhirDeviceRequest(oSource).performerType.Clone;
  performer := TFhirDeviceRequest(oSource).performer.Clone;
  if (TFhirDeviceRequest(oSource).FReasonCodeList = nil) then
  begin
    FReasonCodeList.free;
    FReasonCodeList := nil;
  end
  else
  begin
    if FReasonCodeList = nil then
      FReasonCodeList := TFhirCodeableConceptList.Create;
    FReasonCodeList.Assign(TFhirDeviceRequest(oSource).FReasonCodeList);
  end;
  if (TFhirDeviceRequest(oSource).FReasonReferenceList = nil) then
  begin
    FReasonReferenceList.free;
    FReasonReferenceList := nil;
  end
  else
  begin
    if FReasonReferenceList = nil then
      FReasonReferenceList := TFhirReferenceList{TFhirReference}.Create;
    FReasonReferenceList.Assign(TFhirDeviceRequest(oSource).FReasonReferenceList);
  end;
  if (TFhirDeviceRequest(oSource).FSupportingInfoList = nil) then
  begin
    FSupportingInfoList.free;
    FSupportingInfoList := nil;
  end
  else
  begin
    if FSupportingInfoList = nil then
      FSupportingInfoList := TFhirReferenceList{TFhirReference}.Create;
    FSupportingInfoList.Assign(TFhirDeviceRequest(oSource).FSupportingInfoList);
  end;
  if (TFhirDeviceRequest(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirDeviceRequest(oSource).FNoteList);
  end;
  if (TFhirDeviceRequest(oSource).FRelevantHistoryList = nil) then
  begin
    FRelevantHistoryList.free;
    FRelevantHistoryList := nil;
  end
  else
  begin
    if FRelevantHistoryList = nil then
      FRelevantHistoryList := TFhirReferenceList{TFhirProvenance}.Create;
    FRelevantHistoryList.Assign(TFhirDeviceRequest(oSource).FRelevantHistoryList);
  end;
end;

procedure TFhirDeviceRequest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'definition') Then
    list.addAll(self, 'definition', FDefinitionList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'priorRequest') Then
    list.addAll(self, 'priorRequest', FPriorRequestList);
  if (child_name = 'groupIdentifier') Then
     list.add(self.link, 'groupIdentifier', FGroupIdentifier.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'intent') Then
     list.add(self.link, 'intent', FIntent.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'code[x]') or (child_name = 'code') Then
     list.add(self.link, 'code[x]', FCode.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
  if (child_name = 'occurrence[x]') or (child_name = 'occurrence') Then
     list.add(self.link, 'occurrence[x]', FOccurrence.Link);
  if (child_name = 'authoredOn') Then
     list.add(self.link, 'authoredOn', FAuthoredOn.Link);
  if (child_name = 'requester') Then
     list.add(self.link, 'requester', FRequester.Link);
  if (child_name = 'performerType') Then
     list.add(self.link, 'performerType', FPerformerType.Link);
  if (child_name = 'performer') Then
     list.add(self.link, 'performer', FPerformer.Link);
  if (child_name = 'reasonCode') Then
    list.addAll(self, 'reasonCode', FReasonCodeList);
  if (child_name = 'reasonReference') Then
    list.addAll(self, 'reasonReference', FReasonReferenceList);
  if (child_name = 'supportingInfo') Then
    list.addAll(self, 'supportingInfo', FSupportingInfoList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'relevantHistory') Then
    list.addAll(self, 'relevantHistory', FRelevantHistoryList);
end;

procedure TFhirDeviceRequest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'definition', 'Reference(ActivityDefinition|PlanDefinition)', true, TFhirReference{Resource}, FDefinitionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference(Any)', true, TFhirReference{TFhirReference}, FBasedOnList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'priorRequest', 'Reference(Any)', true, TFhirReference{TFhirReference}, FPriorRequestList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'groupIdentifier', 'Identifier', false, TFhirIdentifier, FGroupIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'intent', 'CodeableConcept', false, TFhirCodeableConcept, FIntent.Link));{2}
  oList.add(TFHIRProperty.create(self, 'priority', 'code', false, TFHIREnum, FPriority.Link));{1}
  oList.add(TFHIRProperty.create(self, 'code[x]', 'Reference(Device)|CodeableConcept', false, TFhirType, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Group|Location|Device)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'context', 'Reference(Encounter|EpisodeOfCare)', false, TFhirReference{Resource}, FContext.Link));{2}
  oList.add(TFHIRProperty.create(self, 'occurrence[x]', 'dateTime|Period|Timing', false, TFhirType, FOccurrence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'authoredOn', 'dateTime', false, TFhirDateTime, FAuthoredOn.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requester', '', false, TFhirDeviceRequestRequester, FRequester.Link));{2}
  oList.add(TFHIRProperty.create(self, 'performerType', 'CodeableConcept', false, TFhirCodeableConcept, FPerformerType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'performer', 'Reference(Practitioner|Organization|Patient|Device|RelatedPerson|HealthcareService)', false, TFhirReference{Resource}, FPerformer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reasonCode', 'CodeableConcept', true, TFhirCodeableConcept, FReasonCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reasonReference', 'Reference(Any)', true, TFhirReference{TFhirReference}, FReasonReferenceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'supportingInfo', 'Reference(Any)', true, TFhirReference{TFhirReference}, FSupportingInfoList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'relevantHistory', 'Reference(Provenance)', true, TFhirReference{TFhirProvenance}, FRelevantHistoryList.Link)){3};
end;

function TFhirDeviceRequest.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'definition') then
  begin
    DefinitionList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'priorRequest') then
  begin
    PriorRequestList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'groupIdentifier') then
  begin
    GroupIdentifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirRequestStatusEnum, CODES_TFhirRequestStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'intent') then
  begin
    Intent := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, propValue);
    result := propValue
  end
  else if (isMatchingName(propName, 'code', ['Reference', 'CodeableConcept'])) then
  begin
    Code := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'context') then
  begin
    Context := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then
  begin
    Occurrence := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'authoredOn') then
  begin
    AuthoredOnElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'requester') then
  begin
    Requester := propValue as TFhirDeviceRequestRequester{4b};
    result := propValue;
  end
  else if (propName = 'performerType') then
  begin
    PerformerType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    Performer := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'reasonCode') then
  begin
    ReasonCodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'reasonReference') then
  begin
    ReasonReferenceList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'supportingInfo') then
  begin
    SupportingInfoList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else if (propName = 'relevantHistory') then
  begin
    RelevantHistoryList.add(propValue as TFhirReference{TFhirProvenance}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirDeviceRequest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'definition') then DefinitionList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'priorRequest') then PriorRequestList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'reasonCode') then ReasonCodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'reasonReference') then ReasonReferenceList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'supportingInfo') then SupportingInfoList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else if (propName = 'relevantHistory') then RelevantHistoryList.insertItem(index, propValue as TFhirReference{TFhirProvenance}){2a}
  else inherited;
end;

function TFhirDeviceRequest.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'definition') then result := DefinitionList.new(){2}
  else if (propName = 'basedOn') then result := BasedOnList.new(){2}
  else if (propName = 'priorRequest') then result := PriorRequestList.new(){2}
  else if (propName = 'groupIdentifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'intent') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'code', ['Reference', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property Code'){4x}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'context') then result := TFhirReference{Resource}.create(){4b}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then raise EFHIRException.create('Cannot make property Occurrence'){4x}
  else if (propName = 'authoredOn') then result := TFhirDateTime.create() {5b}
  else if (propName = 'requester') then result := TFhirDeviceRequestRequester.create(){4b}
  else if (propName = 'performerType') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'performer') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'reasonCode') then result := ReasonCodeList.new(){2}
  else if (propName = 'reasonReference') then result := ReasonReferenceList.new(){2}
  else if (propName = 'supportingInfo') then result := SupportingInfoList.new(){2}
  else if (propName = 'note') then result := NoteList.new(){2}
  else if (propName = 'relevantHistory') then result := RelevantHistoryList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceRequest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'definition') then result := 'Reference'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'priorRequest') then result := 'Reference'
  else if (propName = 'groupIdentifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'intent') then result := 'CodeableConcept'
  else if (propName = 'priority') then result := 'code'
  else if (propName = 'code[x]') then result := 'Reference|CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'context') then result := 'Reference'
  else if (propName = 'occurrence[x]') then result := 'dateTime|Period|Timing'
  else if (propName = 'authoredOn') then result := 'dateTime'
  else if (propName = 'requester') then result := ''
  else if (propName = 'performerType') then result := 'CodeableConcept'
  else if (propName = 'performer') then result := 'Reference'
  else if (propName = 'reasonCode') then result := 'CodeableConcept'
  else if (propName = 'reasonReference') then result := 'Reference'
  else if (propName = 'supportingInfo') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'relevantHistory') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceRequest.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'definition') then deletePropertyValue('definition', DefinitionList, value) {2}
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value) {2}
  else if (propName = 'priorRequest') then deletePropertyValue('priorRequest', PriorRequestList, value) {2}
  else if (propName = 'groupIdentifier') then GroupIdentifierElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'intent') then IntentElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (isMatchingName(propName, 'code', ['Reference', 'CodeableConcept'])) then CodeElement := nil{4x}
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'context') then ContextElement := nil
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then OccurrenceElement := nil{4x}
  else if (propName = 'authoredOn') then AuthoredOnElement := nil
  else if (propName = 'requester') then RequesterElement := nil
  else if (propName = 'performerType') then PerformerTypeElement := nil
  else if (propName = 'performer') then PerformerElement := nil
  else if (propName = 'reasonCode') then deletePropertyValue('reasonCode', ReasonCodeList, value) {2}
  else if (propName = 'reasonReference') then deletePropertyValue('reasonReference', ReasonReferenceList, value) {2}
  else if (propName = 'supportingInfo') then deletePropertyValue('supportingInfo', SupportingInfoList, value) {2}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else if (propName = 'relevantHistory') then deletePropertyValue('relevantHistory', RelevantHistoryList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceRequest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'definition') then replacePropertyValue('definition', DefinitionList, existing, new) {2}
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new) {2}
  else if (propName = 'priorRequest') then replacePropertyValue('priorRequest', PriorRequestList, existing, new) {2}
  else if (propName = 'groupIdentifier') then GroupIdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirRequestStatusEnum, CODES_TFhirRequestStatusEnum, new){4}
  else if (propName = 'intent') then IntentElement := new as TFhirCodeableConcept{4}
  else if (propName = 'priority') then PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, new){4}
  else if (isMatchingName(propName, 'code', ['Reference', 'CodeableConcept'])) then CodeElement := new as TFhirType{4x}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'context') then ContextElement := new as TFhirReference{Resource}{4}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then OccurrenceElement := new as TFhirType{4x}
  else if (propName = 'authoredOn') then AuthoredOnElement := asDateTime(new){5b}
  else if (propName = 'requester') then RequesterElement := new as TFhirDeviceRequestRequester{4}
  else if (propName = 'performerType') then PerformerTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'performer') then PerformerElement := new as TFhirReference{Resource}{4}
  else if (propName = 'reasonCode') then replacePropertyValue('reasonCode', ReasonCodeList, existing, new) {2}
  else if (propName = 'reasonReference') then replacePropertyValue('reasonReference', ReasonReferenceList, existing, new) {2}
  else if (propName = 'supportingInfo') then replacePropertyValue('supportingInfo', SupportingInfoList, existing, new) {2}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else if (propName = 'relevantHistory') then replacePropertyValue('relevantHistory', RelevantHistoryList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceRequest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'definition') then DefinitionList.move(source, destination){2a}
  else if (propName = 'basedOn') then BasedOnList.move(source, destination){2a}
  else if (propName = 'priorRequest') then PriorRequestList.move(source, destination){2a}
  else if (propName = 'reasonCode') then ReasonCodeList.move(source, destination){2a}
  else if (propName = 'reasonReference') then ReasonReferenceList.move(source, destination){2a}
  else if (propName = 'supportingInfo') then SupportingInfoList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else if (propName = 'relevantHistory') then RelevantHistoryList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceRequest.fhirType : string;
begin
  result := 'DeviceRequest';
end;

function TFhirDeviceRequest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FdefinitionList) and isEmptyProp(FbasedOnList) and isEmptyProp(FpriorRequestList) and isEmptyProp(FGroupIdentifier) and isEmptyProp(FStatus) and isEmptyProp(FIntent) and isEmptyProp(FPriority) and isEmptyProp(FCode) and isEmptyProp(FSubject) and isEmptyProp(FContext) and isEmptyProp(FOccurrence) and isEmptyProp(FAuthoredOn) and isEmptyProp(FRequester) and isEmptyProp(FPerformerType) and isEmptyProp(FPerformer) and isEmptyProp(FreasonCodeList) and isEmptyProp(FreasonReferenceList) and isEmptyProp(FsupportingInfoList) and isEmptyProp(FnoteList) and isEmptyProp(FrelevantHistoryList);
end;

function TFhirDeviceRequest.equals(other : TObject) : boolean;
var
  o : TFhirDeviceRequest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceRequest)) then
    result := false
  else
  begin
    o := TFhirDeviceRequest(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(definitionList, o.definitionList, true) and
      compareDeep(basedOnList, o.basedOnList, true) and compareDeep(priorRequestList, o.priorRequestList, true) and
      compareDeep(groupIdentifierElement, o.groupIdentifierElement, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(intentElement, o.intentElement, true) and compareDeep(priorityElement, o.priorityElement, true) and
      compareDeep(codeElement, o.codeElement, true) and compareDeep(subjectElement, o.subjectElement, true) and
      compareDeep(contextElement, o.contextElement, true) and compareDeep(occurrenceElement, o.occurrenceElement, true) and
      compareDeep(authoredOnElement, o.authoredOnElement, true) and compareDeep(requesterElement, o.requesterElement, true) and
      compareDeep(performerTypeElement, o.performerTypeElement, true) and compareDeep(performerElement, o.performerElement, true) and
      compareDeep(reasonCodeList, o.reasonCodeList, true) and compareDeep(reasonReferenceList, o.reasonReferenceList, true) and
      compareDeep(supportingInfoList, o.supportingInfoList, true) and compareDeep(noteList, o.noteList, true) and
      compareDeep(relevantHistoryList, o.relevantHistoryList, true);
  end;
end;

function TFhirDeviceRequest.Link : TFhirDeviceRequest;
begin
  result := TFhirDeviceRequest(inherited Link);
end;

function TFhirDeviceRequest.Clone : TFhirDeviceRequest;
begin
  result := TFhirDeviceRequest(inherited Clone);
end;

procedure TFhirDeviceRequest.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('definition');
  fields.add('basedOn');
  fields.add('priorRequest');
  fields.add('groupIdentifier');
  fields.add('status');
  fields.add('intent');
  fields.add('priority');
  fields.add('code[x]');
  fields.add('subject');
  fields.add('context');
  fields.add('occurrence[x]');
  fields.add('authoredOn');
  fields.add('requester');
  fields.add('performerType');
  fields.add('performer');
  fields.add('reasonCode');
  fields.add('reasonReference');
  fields.add('supportingInfo');
  fields.add('note');
  fields.add('relevantHistory');
end;

{ TFhirDeviceRequest }

Function TFhirDeviceRequest.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirDeviceRequest.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Function TFhirDeviceRequest.GetDefinitionList : TFhirReferenceList{Resource};
begin
  if FDefinitionList = nil then
    FDefinitionList := TFhirReferenceList{Resource}.Create;
  result := FDefinitionList;
end;

Function TFhirDeviceRequest.GetHasDefinitionList : boolean;
begin
  result := (FDefinitionList <> nil) and (FDefinitionList.count > 0);
end;

Function TFhirDeviceRequest.GetBasedOnList : TFhirReferenceList{TFhirReference};
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList{TFhirReference}.Create;
  result := FBasedOnList;
end;

Function TFhirDeviceRequest.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

Function TFhirDeviceRequest.GetPriorRequestList : TFhirReferenceList{TFhirReference};
begin
  if FPriorRequestList = nil then
    FPriorRequestList := TFhirReferenceList{TFhirReference}.Create;
  result := FPriorRequestList;
end;

Function TFhirDeviceRequest.GetHasPriorRequestList : boolean;
begin
  result := (FPriorRequestList <> nil) and (FPriorRequestList.count > 0);
end;

Procedure TFhirDeviceRequest.SetGroupIdentifier(value : TFhirIdentifier);
begin
  FGroupIdentifier.free;
  FGroupIdentifier := value;
end;

Procedure TFhirDeviceRequest.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirDeviceRequest.GetStatusST : TFhirRequestStatusEnum;
begin
  if FStatus = nil then
    result := TFhirRequestStatusEnum(0)
  else
    result := TFhirRequestStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestStatusEnum, FStatus.value));
end;

Procedure TFhirDeviceRequest.SetStatusST(value : TFhirRequestStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirRequestStatusEnum[value], CODES_TFhirRequestStatusEnum[value]);
end;

Procedure TFhirDeviceRequest.SetIntent(value : TFhirCodeableConcept);
begin
  FIntent.free;
  FIntent := value;
end;

Procedure TFhirDeviceRequest.SetPriority(value : TFhirEnum);
begin
  FPriority.free;
  FPriority := value;
end;

Function TFhirDeviceRequest.GetPriorityST : TFhirRequestPriorityEnum;
begin
  if FPriority = nil then
    result := TFhirRequestPriorityEnum(0)
  else
    result := TFhirRequestPriorityEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestPriorityEnum, FPriority.value));
end;

Procedure TFhirDeviceRequest.SetPriorityST(value : TFhirRequestPriorityEnum);
begin
  if ord(value) = 0 then
    PriorityElement := nil
  else
    PriorityElement := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[value], CODES_TFhirRequestPriorityEnum[value]);
end;

Procedure TFhirDeviceRequest.SetCode(value : TFhirType);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirDeviceRequest.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirDeviceRequest.SetContext(value : TFhirReference{Resource});
begin
  FContext.free;
  FContext := value;
end;

Procedure TFhirDeviceRequest.SetOccurrence(value : TFhirType);
begin
  FOccurrence.free;
  FOccurrence := value;
end;

Procedure TFhirDeviceRequest.SetAuthoredOn(value : TFhirDateTime);
begin
  FAuthoredOn.free;
  FAuthoredOn := value;
end;

Function TFhirDeviceRequest.GetAuthoredOnST : TFslDateTime;
begin
  if FAuthoredOn = nil then
    result := TFslDateTime.makeNull
  else
    result := FAuthoredOn.value;
end;

Procedure TFhirDeviceRequest.SetAuthoredOnST(value : TFslDateTime);
begin
  if FAuthoredOn = nil then
    FAuthoredOn := TFhirDateTime.create;
  FAuthoredOn.value := value
end;

Procedure TFhirDeviceRequest.SetRequester(value : TFhirDeviceRequestRequester);
begin
  FRequester.free;
  FRequester := value;
end;

Procedure TFhirDeviceRequest.SetPerformerType(value : TFhirCodeableConcept);
begin
  FPerformerType.free;
  FPerformerType := value;
end;

Procedure TFhirDeviceRequest.SetPerformer(value : TFhirReference{Resource});
begin
  FPerformer.free;
  FPerformer := value;
end;

Function TFhirDeviceRequest.GetReasonCodeList : TFhirCodeableConceptList;
begin
  if FReasonCodeList = nil then
    FReasonCodeList := TFhirCodeableConceptList.Create;
  result := FReasonCodeList;
end;

Function TFhirDeviceRequest.GetHasReasonCodeList : boolean;
begin
  result := (FReasonCodeList <> nil) and (FReasonCodeList.count > 0);
end;

Function TFhirDeviceRequest.GetReasonReferenceList : TFhirReferenceList{TFhirReference};
begin
  if FReasonReferenceList = nil then
    FReasonReferenceList := TFhirReferenceList{TFhirReference}.Create;
  result := FReasonReferenceList;
end;

Function TFhirDeviceRequest.GetHasReasonReferenceList : boolean;
begin
  result := (FReasonReferenceList <> nil) and (FReasonReferenceList.count > 0);
end;

Function TFhirDeviceRequest.GetSupportingInfoList : TFhirReferenceList{TFhirReference};
begin
  if FSupportingInfoList = nil then
    FSupportingInfoList := TFhirReferenceList{TFhirReference}.Create;
  result := FSupportingInfoList;
end;

Function TFhirDeviceRequest.GetHasSupportingInfoList : boolean;
begin
  result := (FSupportingInfoList <> nil) and (FSupportingInfoList.count > 0);
end;

Function TFhirDeviceRequest.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirDeviceRequest.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

Function TFhirDeviceRequest.GetRelevantHistoryList : TFhirReferenceList{TFhirProvenance};
begin
  if FRelevantHistoryList = nil then
    FRelevantHistoryList := TFhirReferenceList{TFhirProvenance}.Create;
  result := FRelevantHistoryList;
end;

Function TFhirDeviceRequest.GetHasRelevantHistoryList : boolean;
begin
  result := (FRelevantHistoryList <> nil) and (FRelevantHistoryList.count > 0);
end;

function TFhirDeviceRequest.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FdefinitionList.sizeInBytes);
  inc(result, FbasedOnList.sizeInBytes);
  inc(result, FpriorRequestList.sizeInBytes);
  inc(result, FGroupIdentifier.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FIntent.sizeInBytes);
  inc(result, FPriority.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FContext.sizeInBytes);
  inc(result, FOccurrence.sizeInBytes);
  inc(result, FAuthoredOn.sizeInBytes);
  inc(result, FRequester.sizeInBytes);
  inc(result, FPerformerType.sizeInBytes);
  inc(result, FPerformer.sizeInBytes);
  inc(result, FreasonCodeList.sizeInBytes);
  inc(result, FreasonReferenceList.sizeInBytes);
  inc(result, FsupportingInfoList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FrelevantHistoryList.sizeInBytes);
end;

{ TFhirDeviceRequestListEnumerator }

Constructor TFhirDeviceRequestListEnumerator.Create(list : TFhirDeviceRequestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceRequestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceRequestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceRequestListEnumerator.GetCurrent : TFhirDeviceRequest;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceRequestListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDeviceRequestList }
procedure TFhirDeviceRequestList.AddItem(value: TFhirDeviceRequest);
begin
  assert(value.ClassName = 'TFhirDeviceRequest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceRequest');
  add(value);
end;

function TFhirDeviceRequestList.Append: TFhirDeviceRequest;
begin
  result := TFhirDeviceRequest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceRequestList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceRequestList.GetEnumerator : TFhirDeviceRequestListEnumerator;
begin
  result := TFhirDeviceRequestListEnumerator.Create(self.link);
end;

function TFhirDeviceRequestList.Clone: TFhirDeviceRequestList;
begin
  result := TFhirDeviceRequestList(inherited Clone);
end;

function TFhirDeviceRequestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceRequestList.GetItemN(index: Integer): TFhirDeviceRequest;
begin
  result := TFhirDeviceRequest(ObjectByIndex[index]);
end;

function TFhirDeviceRequestList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceRequest;
end;
function TFhirDeviceRequestList.IndexOf(value: TFhirDeviceRequest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceRequestList.Insert(index: Integer): TFhirDeviceRequest;
begin
  result := TFhirDeviceRequest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceRequestList.InsertItem(index: Integer; value: TFhirDeviceRequest);
begin
  assert(value is TFhirDeviceRequest);
  Inherited Insert(index, value);
end;

function TFhirDeviceRequestList.Item(index: Integer): TFhirDeviceRequest;
begin
  result := TFhirDeviceRequest(ObjectByIndex[index]);
end;

function TFhirDeviceRequestList.Link: TFhirDeviceRequestList;
begin
  result := TFhirDeviceRequestList(inherited Link);
end;

procedure TFhirDeviceRequestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceRequestList.SetItemByIndex(index: Integer; value: TFhirDeviceRequest);
begin
  assert(value is TFhirDeviceRequest);
  FhirDeviceRequests[index] := value;
end;

procedure TFhirDeviceRequestList.SetItemN(index: Integer; value: TFhirDeviceRequest);
begin
  assert(value is TFhirDeviceRequest);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_DEVICEREQUEST}

{$IFDEF FHIR_DEVICEUSESTATEMENT}

{ TFhirDeviceUseStatement }

constructor TFhirDeviceUseStatement.Create;
begin
  inherited;
end;

destructor TFhirDeviceUseStatement.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FSubject.free;
  FWhenUsed.free;
  FTiming.free;
  FRecordedOn.free;
  FSource.free;
  FDevice.free;
  FIndicationList.Free;
  FBodySite.free;
  FNoteList.Free;
  inherited;
end;

function TFhirDeviceUseStatement.GetResourceType : TFhirResourceType;
begin
  result := frtDeviceUseStatement;
end;

procedure TFhirDeviceUseStatement.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirDeviceUseStatement(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirDeviceUseStatement(oSource).FIdentifierList);
  end;
  FStatus := TFhirDeviceUseStatement(oSource).FStatus.Link;
  subject := TFhirDeviceUseStatement(oSource).subject.Clone;
  whenUsed := TFhirDeviceUseStatement(oSource).whenUsed.Clone;
  timing := TFhirDeviceUseStatement(oSource).timing.Clone;
  recordedOnElement := TFhirDeviceUseStatement(oSource).recordedOnElement.Clone;
  source := TFhirDeviceUseStatement(oSource).source.Clone;
  device := TFhirDeviceUseStatement(oSource).device.Clone;
  if (TFhirDeviceUseStatement(oSource).FIndicationList = nil) then
  begin
    FIndicationList.free;
    FIndicationList := nil;
  end
  else
  begin
    if FIndicationList = nil then
      FIndicationList := TFhirCodeableConceptList.Create;
    FIndicationList.Assign(TFhirDeviceUseStatement(oSource).FIndicationList);
  end;
  bodySite := TFhirDeviceUseStatement(oSource).bodySite.Clone;
  if (TFhirDeviceUseStatement(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirDeviceUseStatement(oSource).FNoteList);
  end;
end;

procedure TFhirDeviceUseStatement.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'whenUsed') Then
     list.add(self.link, 'whenUsed', FWhenUsed.Link);
  if (child_name = 'timing[x]') or (child_name = 'timing') Then
     list.add(self.link, 'timing[x]', FTiming.Link);
  if (child_name = 'recordedOn') Then
     list.add(self.link, 'recordedOn', FRecordedOn.Link);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'device') Then
     list.add(self.link, 'device', FDevice.Link);
  if (child_name = 'indication') Then
    list.addAll(self, 'indication', FIndicationList);
  if (child_name = 'bodySite') Then
     list.add(self.link, 'bodySite', FBodySite.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirDeviceUseStatement.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Group)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'whenUsed', 'Period', false, TFhirPeriod, FWhenUsed.Link));{2}
  oList.add(TFHIRProperty.create(self, 'timing[x]', 'Timing|Period|dateTime', false, TFhirType, FTiming.Link));{2}
  oList.add(TFHIRProperty.create(self, 'recordedOn', 'dateTime', false, TFhirDateTime, FRecordedOn.Link));{2}
  oList.add(TFHIRProperty.create(self, 'source', 'Reference(Patient|Practitioner|RelatedPerson)', false, TFhirReference{Resource}, FSource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'device', 'Reference(Device)', false, TFhirReference{TFhirDevice}, FDevice.Link));{2}
  oList.add(TFHIRProperty.create(self, 'indication', 'CodeableConcept', true, TFhirCodeableConcept, FIndicationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', false, TFhirCodeableConcept, FBodySite.Link));{2}
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
end;

function TFhirDeviceUseStatement.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirDeviceStatementStatusEnum, CODES_TFhirDeviceStatementStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'whenUsed') then
  begin
    WhenUsed := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'timing', ['Timing', 'Period', 'DateTime'])) then
  begin
    Timing := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'recordedOn') then
  begin
    RecordedOnElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    Source := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'device') then
  begin
    Device := propValue as TFhirReference{TFhirDevice}{4b};
    result := propValue;
  end
  else if (propName = 'indication') then
  begin
    IndicationList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySite := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirDeviceUseStatement.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'indication') then IndicationList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else inherited;
end;

function TFhirDeviceUseStatement.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'whenUsed') then result := TFhirPeriod.create(){4b}
  else if (isMatchingName(propName, 'timing', ['Timing', 'Period', 'DateTime'])) then raise EFHIRException.create('Cannot make property Timing'){4x}
  else if (propName = 'recordedOn') then result := TFhirDateTime.create() {5b}
  else if (propName = 'source') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'device') then result := TFhirReference{TFhirDevice}.create(){4b}
  else if (propName = 'indication') then result := IndicationList.new(){2}
  else if (propName = 'bodySite') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'note') then result := NoteList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceUseStatement.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'whenUsed') then result := 'Period'
  else if (propName = 'timing[x]') then result := 'Timing|Period|dateTime'
  else if (propName = 'recordedOn') then result := 'dateTime'
  else if (propName = 'source') then result := 'Reference'
  else if (propName = 'device') then result := 'Reference'
  else if (propName = 'indication') then result := 'CodeableConcept'
  else if (propName = 'bodySite') then result := 'CodeableConcept'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceUseStatement.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'whenUsed') then WhenUsedElement := nil
  else if (isMatchingName(propName, 'timing', ['Timing', 'Period', 'DateTime'])) then TimingElement := nil{4x}
  else if (propName = 'recordedOn') then RecordedOnElement := nil
  else if (propName = 'source') then SourceElement := nil
  else if (propName = 'device') then DeviceElement := nil
  else if (propName = 'indication') then deletePropertyValue('indication', IndicationList, value) {2}
  else if (propName = 'bodySite') then BodySiteElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceUseStatement.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirDeviceStatementStatusEnum, CODES_TFhirDeviceStatementStatusEnum, new){4}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'whenUsed') then WhenUsedElement := new as TFhirPeriod{4}
  else if (isMatchingName(propName, 'timing', ['Timing', 'Period', 'DateTime'])) then TimingElement := new as TFhirType{4x}
  else if (propName = 'recordedOn') then RecordedOnElement := asDateTime(new){5b}
  else if (propName = 'source') then SourceElement := new as TFhirReference{Resource}{4}
  else if (propName = 'device') then DeviceElement := new as TFhirReference{TFhirDevice}{4}
  else if (propName = 'indication') then replacePropertyValue('indication', IndicationList, existing, new) {2}
  else if (propName = 'bodySite') then BodySiteElement := new as TFhirCodeableConcept{4}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceUseStatement.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'indication') then IndicationList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceUseStatement.fhirType : string;
begin
  result := 'DeviceUseStatement';
end;

function TFhirDeviceUseStatement.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FSubject) and isEmptyProp(FWhenUsed) and isEmptyProp(FTiming) and isEmptyProp(FRecordedOn) and isEmptyProp(FSource) and isEmptyProp(FDevice) and isEmptyProp(FindicationList) and isEmptyProp(FBodySite) and isEmptyProp(FnoteList);
end;

function TFhirDeviceUseStatement.equals(other : TObject) : boolean;
var
  o : TFhirDeviceUseStatement;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceUseStatement)) then
    result := false
  else
  begin
    o := TFhirDeviceUseStatement(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(whenUsedElement, o.whenUsedElement, true) and
      compareDeep(timingElement, o.timingElement, true) and compareDeep(recordedOnElement, o.recordedOnElement, true) and
      compareDeep(sourceElement, o.sourceElement, true) and compareDeep(deviceElement, o.deviceElement, true) and
      compareDeep(indicationList, o.indicationList, true) and compareDeep(bodySiteElement, o.bodySiteElement, true) and
      compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirDeviceUseStatement.Link : TFhirDeviceUseStatement;
begin
  result := TFhirDeviceUseStatement(inherited Link);
end;

function TFhirDeviceUseStatement.Clone : TFhirDeviceUseStatement;
begin
  result := TFhirDeviceUseStatement(inherited Clone);
end;

procedure TFhirDeviceUseStatement.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('subject');
  fields.add('whenUsed');
  fields.add('timing[x]');
  fields.add('recordedOn');
  fields.add('source');
  fields.add('device');
  fields.add('indication');
  fields.add('bodySite');
  fields.add('note');
end;

{ TFhirDeviceUseStatement }

Function TFhirDeviceUseStatement.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirDeviceUseStatement.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirDeviceUseStatement.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirDeviceUseStatement.GetStatusST : TFhirDeviceStatementStatusEnum;
begin
  if FStatus = nil then
    result := TFhirDeviceStatementStatusEnum(0)
  else
    result := TFhirDeviceStatementStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirDeviceStatementStatusEnum, FStatus.value));
end;

Procedure TFhirDeviceUseStatement.SetStatusST(value : TFhirDeviceStatementStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirDeviceStatementStatusEnum[value], CODES_TFhirDeviceStatementStatusEnum[value]);
end;

Procedure TFhirDeviceUseStatement.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirDeviceUseStatement.SetWhenUsed(value : TFhirPeriod);
begin
  FWhenUsed.free;
  FWhenUsed := value;
end;

Procedure TFhirDeviceUseStatement.SetTiming(value : TFhirType);
begin
  FTiming.free;
  FTiming := value;
end;

Procedure TFhirDeviceUseStatement.SetRecordedOn(value : TFhirDateTime);
begin
  FRecordedOn.free;
  FRecordedOn := value;
end;

Function TFhirDeviceUseStatement.GetRecordedOnST : TFslDateTime;
begin
  if FRecordedOn = nil then
    result := TFslDateTime.makeNull
  else
    result := FRecordedOn.value;
end;

Procedure TFhirDeviceUseStatement.SetRecordedOnST(value : TFslDateTime);
begin
  if FRecordedOn = nil then
    FRecordedOn := TFhirDateTime.create;
  FRecordedOn.value := value
end;

Procedure TFhirDeviceUseStatement.SetSource(value : TFhirReference{Resource});
begin
  FSource.free;
  FSource := value;
end;

Procedure TFhirDeviceUseStatement.SetDevice(value : TFhirReference{TFhirDevice});
begin
  FDevice.free;
  FDevice := value;
end;

Function TFhirDeviceUseStatement.GetIndicationList : TFhirCodeableConceptList;
begin
  if FIndicationList = nil then
    FIndicationList := TFhirCodeableConceptList.Create;
  result := FIndicationList;
end;

Function TFhirDeviceUseStatement.GetHasIndicationList : boolean;
begin
  result := (FIndicationList <> nil) and (FIndicationList.count > 0);
end;

Procedure TFhirDeviceUseStatement.SetBodySite(value : TFhirCodeableConcept);
begin
  FBodySite.free;
  FBodySite := value;
end;

Function TFhirDeviceUseStatement.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirDeviceUseStatement.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirDeviceUseStatement.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FWhenUsed.sizeInBytes);
  inc(result, FTiming.sizeInBytes);
  inc(result, FRecordedOn.sizeInBytes);
  inc(result, FSource.sizeInBytes);
  inc(result, FDevice.sizeInBytes);
  inc(result, FindicationList.sizeInBytes);
  inc(result, FBodySite.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
end;

{ TFhirDeviceUseStatementListEnumerator }

Constructor TFhirDeviceUseStatementListEnumerator.Create(list : TFhirDeviceUseStatementList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceUseStatementListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceUseStatementListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceUseStatementListEnumerator.GetCurrent : TFhirDeviceUseStatement;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceUseStatementListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDeviceUseStatementList }
procedure TFhirDeviceUseStatementList.AddItem(value: TFhirDeviceUseStatement);
begin
  assert(value.ClassName = 'TFhirDeviceUseStatement', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceUseStatement');
  add(value);
end;

function TFhirDeviceUseStatementList.Append: TFhirDeviceUseStatement;
begin
  result := TFhirDeviceUseStatement.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceUseStatementList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceUseStatementList.GetEnumerator : TFhirDeviceUseStatementListEnumerator;
begin
  result := TFhirDeviceUseStatementListEnumerator.Create(self.link);
end;

function TFhirDeviceUseStatementList.Clone: TFhirDeviceUseStatementList;
begin
  result := TFhirDeviceUseStatementList(inherited Clone);
end;

function TFhirDeviceUseStatementList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceUseStatementList.GetItemN(index: Integer): TFhirDeviceUseStatement;
begin
  result := TFhirDeviceUseStatement(ObjectByIndex[index]);
end;

function TFhirDeviceUseStatementList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceUseStatement;
end;
function TFhirDeviceUseStatementList.IndexOf(value: TFhirDeviceUseStatement): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceUseStatementList.Insert(index: Integer): TFhirDeviceUseStatement;
begin
  result := TFhirDeviceUseStatement.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceUseStatementList.InsertItem(index: Integer; value: TFhirDeviceUseStatement);
begin
  assert(value is TFhirDeviceUseStatement);
  Inherited Insert(index, value);
end;

function TFhirDeviceUseStatementList.Item(index: Integer): TFhirDeviceUseStatement;
begin
  result := TFhirDeviceUseStatement(ObjectByIndex[index]);
end;

function TFhirDeviceUseStatementList.Link: TFhirDeviceUseStatementList;
begin
  result := TFhirDeviceUseStatementList(inherited Link);
end;

procedure TFhirDeviceUseStatementList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceUseStatementList.SetItemByIndex(index: Integer; value: TFhirDeviceUseStatement);
begin
  assert(value is TFhirDeviceUseStatement);
  FhirDeviceUseStatements[index] := value;
end;

procedure TFhirDeviceUseStatementList.SetItemN(index: Integer; value: TFhirDeviceUseStatement);
begin
  assert(value is TFhirDeviceUseStatement);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_DEVICEUSESTATEMENT}

{$IFDEF FHIR_DIAGNOSTICREPORT}

{ TFhirDiagnosticReportPerformer }

constructor TFhirDiagnosticReportPerformer.Create;
begin
  inherited;
end;

destructor TFhirDiagnosticReportPerformer.Destroy;
begin
  FRole.free;
  FActor.free;
  inherited;
end;

procedure TFhirDiagnosticReportPerformer.Assign(oSource : TFslObject);
begin
  inherited;
  role := TFhirDiagnosticReportPerformer(oSource).role.Clone;
  actor := TFhirDiagnosticReportPerformer(oSource).actor.Clone;
end;

procedure TFhirDiagnosticReportPerformer.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'actor') Then
     list.add(self.link, 'actor', FActor.Link);
end;

procedure TFhirDiagnosticReportPerformer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));{2}
  oList.add(TFHIRProperty.create(self, 'actor', 'Reference(Practitioner|Organization)', false, TFhirReference{Resource}, FActor.Link));{2}
end;

function TFhirDiagnosticReportPerformer.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    Actor := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDiagnosticReportPerformer.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDiagnosticReportPerformer.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'role') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'actor') then result := TFhirReference{Resource}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDiagnosticReportPerformer.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'actor') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDiagnosticReportPerformer.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := nil
  else if (propName = 'actor') then ActorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDiagnosticReportPerformer.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := new as TFhirCodeableConcept{4}
  else if (propName = 'actor') then ActorElement := new as TFhirReference{Resource}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDiagnosticReportPerformer.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDiagnosticReportPerformer.fhirType : string;
begin
  result := 'performer';
end;

function TFhirDiagnosticReportPerformer.Link : TFhirDiagnosticReportPerformer;
begin
  result := TFhirDiagnosticReportPerformer(inherited Link);
end;

function TFhirDiagnosticReportPerformer.Clone : TFhirDiagnosticReportPerformer;
begin
  result := TFhirDiagnosticReportPerformer(inherited Clone);
end;

function TFhirDiagnosticReportPerformer.equals(other : TObject) : boolean;
var
  o : TFhirDiagnosticReportPerformer;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDiagnosticReportPerformer)) then
    result := false
  else
  begin
    o := TFhirDiagnosticReportPerformer(other);
    result := compareDeep(roleElement, o.roleElement, true) and compareDeep(actorElement, o.actorElement, true);
  end;
end;

function TFhirDiagnosticReportPerformer.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRole) and isEmptyProp(FActor);
end;

procedure TFhirDiagnosticReportPerformer.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('role');
  fields.add('actor');
end;

{ TFhirDiagnosticReportPerformer }

Procedure TFhirDiagnosticReportPerformer.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

Procedure TFhirDiagnosticReportPerformer.SetActor(value : TFhirReference{Resource});
begin
  FActor.free;
  FActor := value;
end;

function TFhirDiagnosticReportPerformer.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FRole.sizeInBytes);
  inc(result, FActor.sizeInBytes);
end;

{ TFhirDiagnosticReportPerformerListEnumerator }

Constructor TFhirDiagnosticReportPerformerListEnumerator.Create(list : TFhirDiagnosticReportPerformerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDiagnosticReportPerformerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDiagnosticReportPerformerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDiagnosticReportPerformerListEnumerator.GetCurrent : TFhirDiagnosticReportPerformer;
begin
  Result := FList[FIndex];
end;

function TFhirDiagnosticReportPerformerListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDiagnosticReportPerformerList }
procedure TFhirDiagnosticReportPerformerList.AddItem(value: TFhirDiagnosticReportPerformer);
begin
  assert(value.ClassName = 'TFhirDiagnosticReportPerformer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDiagnosticReportPerformer');
  add(value);
end;

function TFhirDiagnosticReportPerformerList.Append: TFhirDiagnosticReportPerformer;
begin
  result := TFhirDiagnosticReportPerformer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDiagnosticReportPerformerList.ClearItems;
begin
  Clear;
end;

function TFhirDiagnosticReportPerformerList.GetEnumerator : TFhirDiagnosticReportPerformerListEnumerator;
begin
  result := TFhirDiagnosticReportPerformerListEnumerator.Create(self.link);
end;

function TFhirDiagnosticReportPerformerList.Clone: TFhirDiagnosticReportPerformerList;
begin
  result := TFhirDiagnosticReportPerformerList(inherited Clone);
end;

function TFhirDiagnosticReportPerformerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDiagnosticReportPerformerList.GetItemN(index: Integer): TFhirDiagnosticReportPerformer;
begin
  result := TFhirDiagnosticReportPerformer(ObjectByIndex[index]);
end;

function TFhirDiagnosticReportPerformerList.ItemClass: TFslObjectClass;
begin
  result := TFhirDiagnosticReportPerformer;
end;
function TFhirDiagnosticReportPerformerList.IndexOf(value: TFhirDiagnosticReportPerformer): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDiagnosticReportPerformerList.Insert(index: Integer): TFhirDiagnosticReportPerformer;
begin
  result := TFhirDiagnosticReportPerformer.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDiagnosticReportPerformerList.InsertItem(index: Integer; value: TFhirDiagnosticReportPerformer);
begin
  assert(value is TFhirDiagnosticReportPerformer);
  Inherited Insert(index, value);
end;

function TFhirDiagnosticReportPerformerList.Item(index: Integer): TFhirDiagnosticReportPerformer;
begin
  result := TFhirDiagnosticReportPerformer(ObjectByIndex[index]);
end;

function TFhirDiagnosticReportPerformerList.Link: TFhirDiagnosticReportPerformerList;
begin
  result := TFhirDiagnosticReportPerformerList(inherited Link);
end;

procedure TFhirDiagnosticReportPerformerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDiagnosticReportPerformerList.SetItemByIndex(index: Integer; value: TFhirDiagnosticReportPerformer);
begin
  assert(value is TFhirDiagnosticReportPerformer);
  FhirDiagnosticReportPerformers[index] := value;
end;

procedure TFhirDiagnosticReportPerformerList.SetItemN(index: Integer; value: TFhirDiagnosticReportPerformer);
begin
  assert(value is TFhirDiagnosticReportPerformer);
  ObjectByIndex[index] := value;
end;

{ TFhirDiagnosticReportImage }

constructor TFhirDiagnosticReportImage.Create;
begin
  inherited;
end;

destructor TFhirDiagnosticReportImage.Destroy;
begin
  FComment.free;
  FLink_.free;
  inherited;
end;

procedure TFhirDiagnosticReportImage.Assign(oSource : TFslObject);
begin
  inherited;
  commentElement := TFhirDiagnosticReportImage(oSource).commentElement.Clone;
  link_ := TFhirDiagnosticReportImage(oSource).link_.Clone;
end;

procedure TFhirDiagnosticReportImage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
  if (child_name = 'link') Then
     list.add(self.link, 'link', FLink_.Link);
end;

procedure TFhirDiagnosticReportImage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'comment', 'string', false, TFhirString, FComment.Link));{2}
  oList.add(TFHIRProperty.create(self, 'link', 'Reference(Media)', false, TFhirReference{TFhirMedia}, FLink_.Link));{2}
end;

function TFhirDiagnosticReportImage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'comment') then
  begin
    CommentElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'link') then
  begin
    Link_ := propValue as TFhirReference{TFhirMedia}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDiagnosticReportImage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDiagnosticReportImage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'comment') then result := TFhirString.create() {5b}
  else if (propName = 'link') then result := TFhirReference{TFhirMedia}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDiagnosticReportImage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'comment') then result := 'string'
  else if (propName = 'link') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDiagnosticReportImage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'comment') then CommentElement := nil
  else if (propName = 'link') then Link_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDiagnosticReportImage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'comment') then CommentElement := asString(new){5b}
  else if (propName = 'link') then Link_Element := new as TFhirReference{TFhirMedia}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDiagnosticReportImage.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDiagnosticReportImage.fhirType : string;
begin
  result := 'image';
end;

function TFhirDiagnosticReportImage.Link : TFhirDiagnosticReportImage;
begin
  result := TFhirDiagnosticReportImage(inherited Link);
end;

function TFhirDiagnosticReportImage.Clone : TFhirDiagnosticReportImage;
begin
  result := TFhirDiagnosticReportImage(inherited Clone);
end;

function TFhirDiagnosticReportImage.equals(other : TObject) : boolean;
var
  o : TFhirDiagnosticReportImage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDiagnosticReportImage)) then
    result := false
  else
  begin
    o := TFhirDiagnosticReportImage(other);
    result := compareDeep(commentElement, o.commentElement, true) and compareDeep(link_Element, o.link_Element, true);
  end;
end;

function TFhirDiagnosticReportImage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FComment) and isEmptyProp(FLink_);
end;

procedure TFhirDiagnosticReportImage.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('comment');
  fields.add('link');
end;

{ TFhirDiagnosticReportImage }

Procedure TFhirDiagnosticReportImage.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value;
end;

Function TFhirDiagnosticReportImage.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

Procedure TFhirDiagnosticReportImage.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

Procedure TFhirDiagnosticReportImage.SetLink_(value : TFhirReference{TFhirMedia});
begin
  FLink_.free;
  FLink_ := value;
end;

function TFhirDiagnosticReportImage.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FComment.sizeInBytes);
  inc(result, FLink_.sizeInBytes);
end;

{ TFhirDiagnosticReportImageListEnumerator }

Constructor TFhirDiagnosticReportImageListEnumerator.Create(list : TFhirDiagnosticReportImageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDiagnosticReportImageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDiagnosticReportImageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDiagnosticReportImageListEnumerator.GetCurrent : TFhirDiagnosticReportImage;
begin
  Result := FList[FIndex];
end;

function TFhirDiagnosticReportImageListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDiagnosticReportImageList }
procedure TFhirDiagnosticReportImageList.AddItem(value: TFhirDiagnosticReportImage);
begin
  assert(value.ClassName = 'TFhirDiagnosticReportImage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDiagnosticReportImage');
  add(value);
end;

function TFhirDiagnosticReportImageList.Append: TFhirDiagnosticReportImage;
begin
  result := TFhirDiagnosticReportImage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDiagnosticReportImageList.ClearItems;
begin
  Clear;
end;

function TFhirDiagnosticReportImageList.GetEnumerator : TFhirDiagnosticReportImageListEnumerator;
begin
  result := TFhirDiagnosticReportImageListEnumerator.Create(self.link);
end;

function TFhirDiagnosticReportImageList.Clone: TFhirDiagnosticReportImageList;
begin
  result := TFhirDiagnosticReportImageList(inherited Clone);
end;

function TFhirDiagnosticReportImageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDiagnosticReportImageList.GetItemN(index: Integer): TFhirDiagnosticReportImage;
begin
  result := TFhirDiagnosticReportImage(ObjectByIndex[index]);
end;

function TFhirDiagnosticReportImageList.ItemClass: TFslObjectClass;
begin
  result := TFhirDiagnosticReportImage;
end;
function TFhirDiagnosticReportImageList.IndexOf(value: TFhirDiagnosticReportImage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDiagnosticReportImageList.Insert(index: Integer): TFhirDiagnosticReportImage;
begin
  result := TFhirDiagnosticReportImage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDiagnosticReportImageList.InsertItem(index: Integer; value: TFhirDiagnosticReportImage);
begin
  assert(value is TFhirDiagnosticReportImage);
  Inherited Insert(index, value);
end;

function TFhirDiagnosticReportImageList.Item(index: Integer): TFhirDiagnosticReportImage;
begin
  result := TFhirDiagnosticReportImage(ObjectByIndex[index]);
end;

function TFhirDiagnosticReportImageList.Link: TFhirDiagnosticReportImageList;
begin
  result := TFhirDiagnosticReportImageList(inherited Link);
end;

procedure TFhirDiagnosticReportImageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDiagnosticReportImageList.SetItemByIndex(index: Integer; value: TFhirDiagnosticReportImage);
begin
  assert(value is TFhirDiagnosticReportImage);
  FhirDiagnosticReportImages[index] := value;
end;

procedure TFhirDiagnosticReportImageList.SetItemN(index: Integer; value: TFhirDiagnosticReportImage);
begin
  assert(value is TFhirDiagnosticReportImage);
  ObjectByIndex[index] := value;
end;

{ TFhirDiagnosticReport }

constructor TFhirDiagnosticReport.Create;
begin
  inherited;
end;

destructor TFhirDiagnosticReport.Destroy;
begin
  FIdentifierList.Free;
  FBasedOnList.Free;
  FStatus.free;
  FCategory.free;
  FCode.free;
  FSubject.free;
  FContext.free;
  FEffective.free;
  FIssued.free;
  FPerformerList.Free;
  FSpecimenList.Free;
  FResultList.Free;
  FImagingStudyList.Free;
  FImageList.Free;
  FConclusion.free;
  FCodedDiagnosisList.Free;
  FPresentedFormList.Free;
  inherited;
end;

function TFhirDiagnosticReport.GetResourceType : TFhirResourceType;
begin
  result := frtDiagnosticReport;
end;

procedure TFhirDiagnosticReport.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirDiagnosticReport(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirDiagnosticReport(oSource).FIdentifierList);
  end;
  if (TFhirDiagnosticReport(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList{Resource}.Create;
    FBasedOnList.Assign(TFhirDiagnosticReport(oSource).FBasedOnList);
  end;
  FStatus := TFhirDiagnosticReport(oSource).FStatus.Link;
  category := TFhirDiagnosticReport(oSource).category.Clone;
  code := TFhirDiagnosticReport(oSource).code.Clone;
  subject := TFhirDiagnosticReport(oSource).subject.Clone;
  context := TFhirDiagnosticReport(oSource).context.Clone;
  effective := TFhirDiagnosticReport(oSource).effective.Clone;
  issuedElement := TFhirDiagnosticReport(oSource).issuedElement.Clone;
  if (TFhirDiagnosticReport(oSource).FPerformerList = nil) then
  begin
    FPerformerList.free;
    FPerformerList := nil;
  end
  else
  begin
    if FPerformerList = nil then
      FPerformerList := TFhirDiagnosticReportPerformerList.Create;
    FPerformerList.Assign(TFhirDiagnosticReport(oSource).FPerformerList);
  end;
  if (TFhirDiagnosticReport(oSource).FSpecimenList = nil) then
  begin
    FSpecimenList.free;
    FSpecimenList := nil;
  end
  else
  begin
    if FSpecimenList = nil then
      FSpecimenList := TFhirReferenceList{TFhirSpecimen}.Create;
    FSpecimenList.Assign(TFhirDiagnosticReport(oSource).FSpecimenList);
  end;
  if (TFhirDiagnosticReport(oSource).FResultList = nil) then
  begin
    FResultList.free;
    FResultList := nil;
  end
  else
  begin
    if FResultList = nil then
      FResultList := TFhirReferenceList{TFhirObservation}.Create;
    FResultList.Assign(TFhirDiagnosticReport(oSource).FResultList);
  end;
  if (TFhirDiagnosticReport(oSource).FImagingStudyList = nil) then
  begin
    FImagingStudyList.free;
    FImagingStudyList := nil;
  end
  else
  begin
    if FImagingStudyList = nil then
      FImagingStudyList := TFhirReferenceList{Resource}.Create;
    FImagingStudyList.Assign(TFhirDiagnosticReport(oSource).FImagingStudyList);
  end;
  if (TFhirDiagnosticReport(oSource).FImageList = nil) then
  begin
    FImageList.free;
    FImageList := nil;
  end
  else
  begin
    if FImageList = nil then
      FImageList := TFhirDiagnosticReportImageList.Create;
    FImageList.Assign(TFhirDiagnosticReport(oSource).FImageList);
  end;
  conclusionElement := TFhirDiagnosticReport(oSource).conclusionElement.Clone;
  if (TFhirDiagnosticReport(oSource).FCodedDiagnosisList = nil) then
  begin
    FCodedDiagnosisList.free;
    FCodedDiagnosisList := nil;
  end
  else
  begin
    if FCodedDiagnosisList = nil then
      FCodedDiagnosisList := TFhirCodeableConceptList.Create;
    FCodedDiagnosisList.Assign(TFhirDiagnosticReport(oSource).FCodedDiagnosisList);
  end;
  if (TFhirDiagnosticReport(oSource).FPresentedFormList = nil) then
  begin
    FPresentedFormList.free;
    FPresentedFormList := nil;
  end
  else
  begin
    if FPresentedFormList = nil then
      FPresentedFormList := TFhirAttachmentList.Create;
    FPresentedFormList.Assign(TFhirDiagnosticReport(oSource).FPresentedFormList);
  end;
end;

procedure TFhirDiagnosticReport.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
  if (child_name = 'effective[x]') or (child_name = 'effective') Then
     list.add(self.link, 'effective[x]', FEffective.Link);
  if (child_name = 'issued') Then
     list.add(self.link, 'issued', FIssued.Link);
  if (child_name = 'performer') Then
    list.addAll(self, 'performer', FPerformerList);
  if (child_name = 'specimen') Then
    list.addAll(self, 'specimen', FSpecimenList);
  if (child_name = 'result') Then
    list.addAll(self, 'result', FResultList);
  if (child_name = 'imagingStudy') Then
    list.addAll(self, 'imagingStudy', FImagingStudyList);
  if (child_name = 'image') Then
    list.addAll(self, 'image', FImageList);
  if (child_name = 'conclusion') Then
     list.add(self.link, 'conclusion', FConclusion.Link);
  if (child_name = 'codedDiagnosis') Then
    list.addAll(self, 'codedDiagnosis', FCodedDiagnosisList);
  if (child_name = 'presentedForm') Then
    list.addAll(self, 'presentedForm', FPresentedFormList);
end;

procedure TFhirDiagnosticReport.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference(CarePlan|ImmunizationRecommendation|MedicationRequest|NutritionOrder|ProcedureRequest|ReferralRequest)', true, TFhirReference{Resource}, FBasedOnList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Group|Device|Location)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'context', 'Reference(Encounter|EpisodeOfCare)', false, TFhirReference{Resource}, FContext.Link));{2}
  oList.add(TFHIRProperty.create(self, 'effective[x]', 'dateTime|Period', false, TFhirType, FEffective.Link));{2}
  oList.add(TFHIRProperty.create(self, 'issued', 'instant', false, TFhirInstant, FIssued.Link));{2}
  oList.add(TFHIRProperty.create(self, 'performer', '', true, TFhirDiagnosticReportPerformer, FPerformerList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'specimen', 'Reference(Specimen)', true, TFhirReference{TFhirSpecimen}, FSpecimenList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'result', 'Reference(Observation)', true, TFhirReference{TFhirObservation}, FResultList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'imagingStudy', 'Reference(ImagingStudy|ImagingManifest)', true, TFhirReference{Resource}, FImagingStudyList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'image', '', true, TFhirDiagnosticReportImage, FImageList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'conclusion', 'string', false, TFhirString, FConclusion.Link));{2}
  oList.add(TFHIRProperty.create(self, 'codedDiagnosis', 'CodeableConcept', true, TFhirCodeableConcept, FCodedDiagnosisList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'presentedForm', 'Attachment', true, TFhirAttachment, FPresentedFormList.Link)){3};
end;

function TFhirDiagnosticReport.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirDiagnosticReportStatusEnum, CODES_TFhirDiagnosticReportStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'context') then
  begin
    Context := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then
  begin
    Effective := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'issued') then
  begin
    IssuedElement := asInstant(propValue){5a};
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    PerformerList.add(propValue as TFhirDiagnosticReportPerformer){2a};
    result := propValue;
  end
  else if (propName = 'specimen') then
  begin
    SpecimenList.add(propValue as TFhirReference{TFhirSpecimen}){2a};
    result := propValue;
  end
  else if (propName = 'result') then
  begin
    ResultList.add(propValue as TFhirReference{TFhirObservation}){2a};
    result := propValue;
  end
  else if (propName = 'imagingStudy') then
  begin
    ImagingStudyList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'image') then
  begin
    ImageList.add(propValue as TFhirDiagnosticReportImage){2a};
    result := propValue;
  end
  else if (propName = 'conclusion') then
  begin
    ConclusionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'codedDiagnosis') then
  begin
    CodedDiagnosisList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'presentedForm') then
  begin
    PresentedFormList.add(propValue as TFhirAttachment){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirDiagnosticReport.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'performer') then PerformerList.insertItem(index, propValue as TFhirDiagnosticReportPerformer){2a}
  else if (propName = 'specimen') then SpecimenList.insertItem(index, propValue as TFhirReference{TFhirSpecimen}){2a}
  else if (propName = 'result') then ResultList.insertItem(index, propValue as TFhirReference{TFhirObservation}){2a}
  else if (propName = 'imagingStudy') then ImagingStudyList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'image') then ImageList.insertItem(index, propValue as TFhirDiagnosticReportImage){2a}
  else if (propName = 'codedDiagnosis') then CodedDiagnosisList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'presentedForm') then PresentedFormList.insertItem(index, propValue as TFhirAttachment){2a}
  else inherited;
end;

function TFhirDiagnosticReport.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'basedOn') then result := BasedOnList.new(){2}
  else if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'context') then result := TFhirReference{Resource}.create(){4b}
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Effective'){4x}
  else if (propName = 'issued') then result := TFhirInstant.create() {5b}
  else if (propName = 'performer') then result := PerformerList.new(){2}
  else if (propName = 'specimen') then result := SpecimenList.new(){2}
  else if (propName = 'result') then result := ResultList.new(){2}
  else if (propName = 'imagingStudy') then result := ImagingStudyList.new(){2}
  else if (propName = 'image') then result := ImageList.new(){2}
  else if (propName = 'conclusion') then result := TFhirString.create() {5b}
  else if (propName = 'codedDiagnosis') then result := CodedDiagnosisList.new(){2}
  else if (propName = 'presentedForm') then result := PresentedFormList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDiagnosticReport.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'context') then result := 'Reference'
  else if (propName = 'effective[x]') then result := 'dateTime|Period'
  else if (propName = 'issued') then result := 'instant'
  else if (propName = 'performer') then result := ''
  else if (propName = 'specimen') then result := 'Reference'
  else if (propName = 'result') then result := 'Reference'
  else if (propName = 'imagingStudy') then result := 'Reference'
  else if (propName = 'image') then result := ''
  else if (propName = 'conclusion') then result := 'string'
  else if (propName = 'codedDiagnosis') then result := 'CodeableConcept'
  else if (propName = 'presentedForm') then result := 'Attachment'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDiagnosticReport.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'context') then ContextElement := nil
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then EffectiveElement := nil{4x}
  else if (propName = 'issued') then IssuedElement := nil
  else if (propName = 'performer') then deletePropertyValue('performer', PerformerList, value) {2}
  else if (propName = 'specimen') then deletePropertyValue('specimen', SpecimenList, value) {2}
  else if (propName = 'result') then deletePropertyValue('result', ResultList, value) {2}
  else if (propName = 'imagingStudy') then deletePropertyValue('imagingStudy', ImagingStudyList, value) {2}
  else if (propName = 'image') then deletePropertyValue('image', ImageList, value) {2}
  else if (propName = 'conclusion') then ConclusionElement := nil
  else if (propName = 'codedDiagnosis') then deletePropertyValue('codedDiagnosis', CodedDiagnosisList, value) {2}
  else if (propName = 'presentedForm') then deletePropertyValue('presentedForm', PresentedFormList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDiagnosticReport.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirDiagnosticReportStatusEnum, CODES_TFhirDiagnosticReportStatusEnum, new){4}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'context') then ContextElement := new as TFhirReference{Resource}{4}
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then EffectiveElement := new as TFhirType{4x}
  else if (propName = 'issued') then IssuedElement := asInstant(new){5b}
  else if (propName = 'performer') then replacePropertyValue('performer', PerformerList, existing, new) {2}
  else if (propName = 'specimen') then replacePropertyValue('specimen', SpecimenList, existing, new) {2}
  else if (propName = 'result') then replacePropertyValue('result', ResultList, existing, new) {2}
  else if (propName = 'imagingStudy') then replacePropertyValue('imagingStudy', ImagingStudyList, existing, new) {2}
  else if (propName = 'image') then replacePropertyValue('image', ImageList, existing, new) {2}
  else if (propName = 'conclusion') then ConclusionElement := asString(new){5b}
  else if (propName = 'codedDiagnosis') then replacePropertyValue('codedDiagnosis', CodedDiagnosisList, existing, new) {2}
  else if (propName = 'presentedForm') then replacePropertyValue('presentedForm', PresentedFormList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDiagnosticReport.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'basedOn') then BasedOnList.move(source, destination){2a}
  else if (propName = 'performer') then PerformerList.move(source, destination){2a}
  else if (propName = 'specimen') then SpecimenList.move(source, destination){2a}
  else if (propName = 'result') then ResultList.move(source, destination){2a}
  else if (propName = 'imagingStudy') then ImagingStudyList.move(source, destination){2a}
  else if (propName = 'image') then ImageList.move(source, destination){2a}
  else if (propName = 'codedDiagnosis') then CodedDiagnosisList.move(source, destination){2a}
  else if (propName = 'presentedForm') then PresentedFormList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDiagnosticReport.fhirType : string;
begin
  result := 'DiagnosticReport';
end;

function TFhirDiagnosticReport.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FbasedOnList) and isEmptyProp(FStatus) and isEmptyProp(FCategory) and isEmptyProp(FCode) and isEmptyProp(FSubject) and isEmptyProp(FContext) and isEmptyProp(FEffective) and isEmptyProp(FIssued) and isEmptyProp(FperformerList) and isEmptyProp(FspecimenList) and isEmptyProp(FresultList) and isEmptyProp(FimagingStudyList) and isEmptyProp(FimageList) and isEmptyProp(FConclusion) and isEmptyProp(FcodedDiagnosisList) and isEmptyProp(FpresentedFormList);
end;

function TFhirDiagnosticReport.equals(other : TObject) : boolean;
var
  o : TFhirDiagnosticReport;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDiagnosticReport)) then
    result := false
  else
  begin
    o := TFhirDiagnosticReport(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(basedOnList, o.basedOnList, true) and
      compareDeep(statusElement, o.statusElement, true) and compareDeep(categoryElement, o.categoryElement, true) and
      compareDeep(codeElement, o.codeElement, true) and compareDeep(subjectElement, o.subjectElement, true) and
      compareDeep(contextElement, o.contextElement, true) and compareDeep(effectiveElement, o.effectiveElement, true) and
      compareDeep(issuedElement, o.issuedElement, true) and compareDeep(performerList, o.performerList, true) and
      compareDeep(specimenList, o.specimenList, true) and compareDeep(resultList, o.resultList, true) and
      compareDeep(imagingStudyList, o.imagingStudyList, true) and compareDeep(imageList, o.imageList, true) and
      compareDeep(conclusionElement, o.conclusionElement, true) and compareDeep(codedDiagnosisList, o.codedDiagnosisList, true) and
      compareDeep(presentedFormList, o.presentedFormList, true);
  end;
end;

function TFhirDiagnosticReport.Link : TFhirDiagnosticReport;
begin
  result := TFhirDiagnosticReport(inherited Link);
end;

function TFhirDiagnosticReport.Clone : TFhirDiagnosticReport;
begin
  result := TFhirDiagnosticReport(inherited Clone);
end;

procedure TFhirDiagnosticReport.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('basedOn');
  fields.add('status');
  fields.add('category');
  fields.add('code');
  fields.add('subject');
  fields.add('context');
  fields.add('effective[x]');
  fields.add('issued');
  fields.add('performer');
  fields.add('specimen');
  fields.add('result');
  fields.add('imagingStudy');
  fields.add('image');
  fields.add('conclusion');
  fields.add('codedDiagnosis');
  fields.add('presentedForm');
end;

{ TFhirDiagnosticReport }

Function TFhirDiagnosticReport.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirDiagnosticReport.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Function TFhirDiagnosticReport.GetBasedOnList : TFhirReferenceList{Resource};
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList{Resource}.Create;
  result := FBasedOnList;
end;

Function TFhirDiagnosticReport.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

Procedure TFhirDiagnosticReport.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirDiagnosticReport.GetStatusST : TFhirDiagnosticReportStatusEnum;
begin
  if FStatus = nil then
    result := TFhirDiagnosticReportStatusEnum(0)
  else
    result := TFhirDiagnosticReportStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirDiagnosticReportStatusEnum, FStatus.value));
end;

Procedure TFhirDiagnosticReport.SetStatusST(value : TFhirDiagnosticReportStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirDiagnosticReportStatusEnum[value], CODES_TFhirDiagnosticReportStatusEnum[value]);
end;

Procedure TFhirDiagnosticReport.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirDiagnosticReport.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirDiagnosticReport.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirDiagnosticReport.SetContext(value : TFhirReference{Resource});
begin
  FContext.free;
  FContext := value;
end;

Procedure TFhirDiagnosticReport.SetEffective(value : TFhirType);
begin
  FEffective.free;
  FEffective := value;
end;

Procedure TFhirDiagnosticReport.SetIssued(value : TFhirInstant);
begin
  FIssued.free;
  FIssued := value;
end;

Function TFhirDiagnosticReport.GetIssuedST : TFslDateTime;
begin
  if FIssued = nil then
    result := TFslDateTime.makeNull
  else
    result := FIssued.value;
end;

Procedure TFhirDiagnosticReport.SetIssuedST(value : TFslDateTime);
begin
  if FIssued = nil then
    FIssued := TFhirInstant.create;
  FIssued.value := value
end;

Function TFhirDiagnosticReport.GetPerformerList : TFhirDiagnosticReportPerformerList;
begin
  if FPerformerList = nil then
    FPerformerList := TFhirDiagnosticReportPerformerList.Create;
  result := FPerformerList;
end;

Function TFhirDiagnosticReport.GetHasPerformerList : boolean;
begin
  result := (FPerformerList <> nil) and (FPerformerList.count > 0);
end;

Function TFhirDiagnosticReport.GetSpecimenList : TFhirReferenceList{TFhirSpecimen};
begin
  if FSpecimenList = nil then
    FSpecimenList := TFhirReferenceList{TFhirSpecimen}.Create;
  result := FSpecimenList;
end;

Function TFhirDiagnosticReport.GetHasSpecimenList : boolean;
begin
  result := (FSpecimenList <> nil) and (FSpecimenList.count > 0);
end;

Function TFhirDiagnosticReport.GetResultList : TFhirReferenceList{TFhirObservation};
begin
  if FResultList = nil then
    FResultList := TFhirReferenceList{TFhirObservation}.Create;
  result := FResultList;
end;

Function TFhirDiagnosticReport.GetHasResultList : boolean;
begin
  result := (FResultList <> nil) and (FResultList.count > 0);
end;

Function TFhirDiagnosticReport.GetImagingStudyList : TFhirReferenceList{Resource};
begin
  if FImagingStudyList = nil then
    FImagingStudyList := TFhirReferenceList{Resource}.Create;
  result := FImagingStudyList;
end;

Function TFhirDiagnosticReport.GetHasImagingStudyList : boolean;
begin
  result := (FImagingStudyList <> nil) and (FImagingStudyList.count > 0);
end;

Function TFhirDiagnosticReport.GetImageList : TFhirDiagnosticReportImageList;
begin
  if FImageList = nil then
    FImageList := TFhirDiagnosticReportImageList.Create;
  result := FImageList;
end;

Function TFhirDiagnosticReport.GetHasImageList : boolean;
begin
  result := (FImageList <> nil) and (FImageList.count > 0);
end;

Procedure TFhirDiagnosticReport.SetConclusion(value : TFhirString);
begin
  FConclusion.free;
  FConclusion := value;
end;

Function TFhirDiagnosticReport.GetConclusionST : String;
begin
  if FConclusion = nil then
    result := ''
  else
    result := FConclusion.value;
end;

Procedure TFhirDiagnosticReport.SetConclusionST(value : String);
begin
  if value <> '' then
  begin
    if FConclusion = nil then
      FConclusion := TFhirString.create;
    FConclusion.value := value
  end
  else if FConclusion <> nil then
    FConclusion.value := '';
end;

Function TFhirDiagnosticReport.GetCodedDiagnosisList : TFhirCodeableConceptList;
begin
  if FCodedDiagnosisList = nil then
    FCodedDiagnosisList := TFhirCodeableConceptList.Create;
  result := FCodedDiagnosisList;
end;

Function TFhirDiagnosticReport.GetHasCodedDiagnosisList : boolean;
begin
  result := (FCodedDiagnosisList <> nil) and (FCodedDiagnosisList.count > 0);
end;

Function TFhirDiagnosticReport.GetPresentedFormList : TFhirAttachmentList;
begin
  if FPresentedFormList = nil then
    FPresentedFormList := TFhirAttachmentList.Create;
  result := FPresentedFormList;
end;

Function TFhirDiagnosticReport.GetHasPresentedFormList : boolean;
begin
  result := (FPresentedFormList <> nil) and (FPresentedFormList.count > 0);
end;

function TFhirDiagnosticReport.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FbasedOnList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FContext.sizeInBytes);
  inc(result, FEffective.sizeInBytes);
  inc(result, FIssued.sizeInBytes);
  inc(result, FperformerList.sizeInBytes);
  inc(result, FspecimenList.sizeInBytes);
  inc(result, FresultList.sizeInBytes);
  inc(result, FimagingStudyList.sizeInBytes);
  inc(result, FimageList.sizeInBytes);
  inc(result, FConclusion.sizeInBytes);
  inc(result, FcodedDiagnosisList.sizeInBytes);
  inc(result, FpresentedFormList.sizeInBytes);
end;

{ TFhirDiagnosticReportListEnumerator }

Constructor TFhirDiagnosticReportListEnumerator.Create(list : TFhirDiagnosticReportList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDiagnosticReportListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDiagnosticReportListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDiagnosticReportListEnumerator.GetCurrent : TFhirDiagnosticReport;
begin
  Result := FList[FIndex];
end;

function TFhirDiagnosticReportListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDiagnosticReportList }
procedure TFhirDiagnosticReportList.AddItem(value: TFhirDiagnosticReport);
begin
  assert(value.ClassName = 'TFhirDiagnosticReport', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDiagnosticReport');
  add(value);
end;

function TFhirDiagnosticReportList.Append: TFhirDiagnosticReport;
begin
  result := TFhirDiagnosticReport.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDiagnosticReportList.ClearItems;
begin
  Clear;
end;

function TFhirDiagnosticReportList.GetEnumerator : TFhirDiagnosticReportListEnumerator;
begin
  result := TFhirDiagnosticReportListEnumerator.Create(self.link);
end;

function TFhirDiagnosticReportList.Clone: TFhirDiagnosticReportList;
begin
  result := TFhirDiagnosticReportList(inherited Clone);
end;

function TFhirDiagnosticReportList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDiagnosticReportList.GetItemN(index: Integer): TFhirDiagnosticReport;
begin
  result := TFhirDiagnosticReport(ObjectByIndex[index]);
end;

function TFhirDiagnosticReportList.ItemClass: TFslObjectClass;
begin
  result := TFhirDiagnosticReport;
end;
function TFhirDiagnosticReportList.IndexOf(value: TFhirDiagnosticReport): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDiagnosticReportList.Insert(index: Integer): TFhirDiagnosticReport;
begin
  result := TFhirDiagnosticReport.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDiagnosticReportList.InsertItem(index: Integer; value: TFhirDiagnosticReport);
begin
  assert(value is TFhirDiagnosticReport);
  Inherited Insert(index, value);
end;

function TFhirDiagnosticReportList.Item(index: Integer): TFhirDiagnosticReport;
begin
  result := TFhirDiagnosticReport(ObjectByIndex[index]);
end;

function TFhirDiagnosticReportList.Link: TFhirDiagnosticReportList;
begin
  result := TFhirDiagnosticReportList(inherited Link);
end;

procedure TFhirDiagnosticReportList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDiagnosticReportList.SetItemByIndex(index: Integer; value: TFhirDiagnosticReport);
begin
  assert(value is TFhirDiagnosticReport);
  FhirDiagnosticReports[index] := value;
end;

procedure TFhirDiagnosticReportList.SetItemN(index: Integer; value: TFhirDiagnosticReport);
begin
  assert(value is TFhirDiagnosticReport);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_DIAGNOSTICREPORT}

{$IFDEF FHIR_DOCUMENTMANIFEST}

{ TFhirDocumentManifestContent }

constructor TFhirDocumentManifestContent.Create;
begin
  inherited;
end;

destructor TFhirDocumentManifestContent.Destroy;
begin
  FP.free;
  inherited;
end;

procedure TFhirDocumentManifestContent.Assign(oSource : TFslObject);
begin
  inherited;
  p := TFhirDocumentManifestContent(oSource).p.Clone;
end;

procedure TFhirDocumentManifestContent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'p[x]') or (child_name = 'p') Then
     list.add(self.link, 'p[x]', FP.Link);
end;

procedure TFhirDocumentManifestContent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'p[x]', 'Attachment|Reference(Any)', false, TFhirType, FP.Link));{2}
end;

function TFhirDocumentManifestContent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'p', ['Attachment', 'Reference'])) then
  begin
    P := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDocumentManifestContent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDocumentManifestContent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'p', ['Attachment', 'Reference'])) then raise EFHIRException.create('Cannot make property P'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDocumentManifestContent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'p[x]') then result := 'Attachment|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDocumentManifestContent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'p', ['Attachment', 'Reference'])) then PElement := nil{4x}
  else
  inherited deleteProperty(propName, value);
end;

procedure TFhirDocumentManifestContent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'p', ['Attachment', 'Reference'])) then PElement := new as TFhirType{4x}
  else
  inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDocumentManifestContent.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDocumentManifestContent.fhirType : string;
begin
  result := 'content';
end;

function TFhirDocumentManifestContent.Link : TFhirDocumentManifestContent;
begin
  result := TFhirDocumentManifestContent(inherited Link);
end;

function TFhirDocumentManifestContent.Clone : TFhirDocumentManifestContent;
begin
  result := TFhirDocumentManifestContent(inherited Clone);
end;

function TFhirDocumentManifestContent.equals(other : TObject) : boolean;
var
  o : TFhirDocumentManifestContent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDocumentManifestContent)) then
    result := false
  else
  begin
    o := TFhirDocumentManifestContent(other);
    result := compareDeep(pElement, o.pElement, true);
  end;
end;

function TFhirDocumentManifestContent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FP);
end;

procedure TFhirDocumentManifestContent.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('p[x]');
end;

{ TFhirDocumentManifestContent }

Procedure TFhirDocumentManifestContent.SetP(value : TFhirType);
begin
  FP.free;
  FP := value;
end;

function TFhirDocumentManifestContent.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FP.sizeInBytes);
end;

{ TFhirDocumentManifestContentListEnumerator }

Constructor TFhirDocumentManifestContentListEnumerator.Create(list : TFhirDocumentManifestContentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDocumentManifestContentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDocumentManifestContentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDocumentManifestContentListEnumerator.GetCurrent : TFhirDocumentManifestContent;
begin
  Result := FList[FIndex];
end;

function TFhirDocumentManifestContentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDocumentManifestContentList }
procedure TFhirDocumentManifestContentList.AddItem(value: TFhirDocumentManifestContent);
begin
  assert(value.ClassName = 'TFhirDocumentManifestContent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDocumentManifestContent');
  add(value);
end;

function TFhirDocumentManifestContentList.Append: TFhirDocumentManifestContent;
begin
  result := TFhirDocumentManifestContent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentManifestContentList.ClearItems;
begin
  Clear;
end;

function TFhirDocumentManifestContentList.GetEnumerator : TFhirDocumentManifestContentListEnumerator;
begin
  result := TFhirDocumentManifestContentListEnumerator.Create(self.link);
end;

function TFhirDocumentManifestContentList.Clone: TFhirDocumentManifestContentList;
begin
  result := TFhirDocumentManifestContentList(inherited Clone);
end;

function TFhirDocumentManifestContentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDocumentManifestContentList.GetItemN(index: Integer): TFhirDocumentManifestContent;
begin
  result := TFhirDocumentManifestContent(ObjectByIndex[index]);
end;

function TFhirDocumentManifestContentList.ItemClass: TFslObjectClass;
begin
  result := TFhirDocumentManifestContent;
end;
function TFhirDocumentManifestContentList.IndexOf(value: TFhirDocumentManifestContent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDocumentManifestContentList.Insert(index: Integer): TFhirDocumentManifestContent;
begin
  result := TFhirDocumentManifestContent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentManifestContentList.InsertItem(index: Integer; value: TFhirDocumentManifestContent);
begin
  assert(value is TFhirDocumentManifestContent);
  Inherited Insert(index, value);
end;

function TFhirDocumentManifestContentList.Item(index: Integer): TFhirDocumentManifestContent;
begin
  result := TFhirDocumentManifestContent(ObjectByIndex[index]);
end;

function TFhirDocumentManifestContentList.Link: TFhirDocumentManifestContentList;
begin
  result := TFhirDocumentManifestContentList(inherited Link);
end;

procedure TFhirDocumentManifestContentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDocumentManifestContentList.SetItemByIndex(index: Integer; value: TFhirDocumentManifestContent);
begin
  assert(value is TFhirDocumentManifestContent);
  FhirDocumentManifestContents[index] := value;
end;

procedure TFhirDocumentManifestContentList.SetItemN(index: Integer; value: TFhirDocumentManifestContent);
begin
  assert(value is TFhirDocumentManifestContent);
  ObjectByIndex[index] := value;
end;

{ TFhirDocumentManifestRelated }

constructor TFhirDocumentManifestRelated.Create;
begin
  inherited;
end;

destructor TFhirDocumentManifestRelated.Destroy;
begin
  FIdentifier.free;
  FRef.free;
  inherited;
end;

procedure TFhirDocumentManifestRelated.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirDocumentManifestRelated(oSource).identifier.Clone;
  ref := TFhirDocumentManifestRelated(oSource).ref.Clone;
end;

procedure TFhirDocumentManifestRelated.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'ref') Then
     list.add(self.link, 'ref', FRef.Link);
end;

procedure TFhirDocumentManifestRelated.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'ref', 'Reference(Any)', false, TFhirReference{TFhirReference}, FRef.Link));{2}
end;

function TFhirDocumentManifestRelated.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'ref') then
  begin
    Ref := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDocumentManifestRelated.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDocumentManifestRelated.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'ref') then result := TFhirReference{TFhirReference}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDocumentManifestRelated.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'ref') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDocumentManifestRelated.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'ref') then RefElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDocumentManifestRelated.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'ref') then RefElement := new as TFhirReference{TFhirReference}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDocumentManifestRelated.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDocumentManifestRelated.fhirType : string;
begin
  result := 'related';
end;

function TFhirDocumentManifestRelated.Link : TFhirDocumentManifestRelated;
begin
  result := TFhirDocumentManifestRelated(inherited Link);
end;

function TFhirDocumentManifestRelated.Clone : TFhirDocumentManifestRelated;
begin
  result := TFhirDocumentManifestRelated(inherited Clone);
end;

function TFhirDocumentManifestRelated.equals(other : TObject) : boolean;
var
  o : TFhirDocumentManifestRelated;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDocumentManifestRelated)) then
    result := false
  else
  begin
    o := TFhirDocumentManifestRelated(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(refElement, o.refElement, true);
  end;
end;

function TFhirDocumentManifestRelated.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FRef);
end;

procedure TFhirDocumentManifestRelated.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('ref');
end;

{ TFhirDocumentManifestRelated }

Procedure TFhirDocumentManifestRelated.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirDocumentManifestRelated.SetRef(value : TFhirReference{TFhirReference});
begin
  FRef.free;
  FRef := value;
end;

function TFhirDocumentManifestRelated.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FRef.sizeInBytes);
end;

{ TFhirDocumentManifestRelatedListEnumerator }

Constructor TFhirDocumentManifestRelatedListEnumerator.Create(list : TFhirDocumentManifestRelatedList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDocumentManifestRelatedListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDocumentManifestRelatedListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDocumentManifestRelatedListEnumerator.GetCurrent : TFhirDocumentManifestRelated;
begin
  Result := FList[FIndex];
end;

function TFhirDocumentManifestRelatedListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDocumentManifestRelatedList }
procedure TFhirDocumentManifestRelatedList.AddItem(value: TFhirDocumentManifestRelated);
begin
  assert(value.ClassName = 'TFhirDocumentManifestRelated', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDocumentManifestRelated');
  add(value);
end;

function TFhirDocumentManifestRelatedList.Append: TFhirDocumentManifestRelated;
begin
  result := TFhirDocumentManifestRelated.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentManifestRelatedList.ClearItems;
begin
  Clear;
end;

function TFhirDocumentManifestRelatedList.GetEnumerator : TFhirDocumentManifestRelatedListEnumerator;
begin
  result := TFhirDocumentManifestRelatedListEnumerator.Create(self.link);
end;

function TFhirDocumentManifestRelatedList.Clone: TFhirDocumentManifestRelatedList;
begin
  result := TFhirDocumentManifestRelatedList(inherited Clone);
end;

function TFhirDocumentManifestRelatedList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDocumentManifestRelatedList.GetItemN(index: Integer): TFhirDocumentManifestRelated;
begin
  result := TFhirDocumentManifestRelated(ObjectByIndex[index]);
end;

function TFhirDocumentManifestRelatedList.ItemClass: TFslObjectClass;
begin
  result := TFhirDocumentManifestRelated;
end;
function TFhirDocumentManifestRelatedList.IndexOf(value: TFhirDocumentManifestRelated): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDocumentManifestRelatedList.Insert(index: Integer): TFhirDocumentManifestRelated;
begin
  result := TFhirDocumentManifestRelated.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentManifestRelatedList.InsertItem(index: Integer; value: TFhirDocumentManifestRelated);
begin
  assert(value is TFhirDocumentManifestRelated);
  Inherited Insert(index, value);
end;

function TFhirDocumentManifestRelatedList.Item(index: Integer): TFhirDocumentManifestRelated;
begin
  result := TFhirDocumentManifestRelated(ObjectByIndex[index]);
end;

function TFhirDocumentManifestRelatedList.Link: TFhirDocumentManifestRelatedList;
begin
  result := TFhirDocumentManifestRelatedList(inherited Link);
end;

procedure TFhirDocumentManifestRelatedList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDocumentManifestRelatedList.SetItemByIndex(index: Integer; value: TFhirDocumentManifestRelated);
begin
  assert(value is TFhirDocumentManifestRelated);
  FhirDocumentManifestRelateds[index] := value;
end;

procedure TFhirDocumentManifestRelatedList.SetItemN(index: Integer; value: TFhirDocumentManifestRelated);
begin
  assert(value is TFhirDocumentManifestRelated);
  ObjectByIndex[index] := value;
end;

{ TFhirDocumentManifest }

constructor TFhirDocumentManifest.Create;
begin
  inherited;
end;

destructor TFhirDocumentManifest.Destroy;
begin
  FMasterIdentifier.free;
  FIdentifierList.Free;
  FStatus.free;
  FType_.free;
  FSubject.free;
  FCreated.free;
  FAuthorList.Free;
  FRecipientList.Free;
  FSource.free;
  FDescription.free;
  FContentList.Free;
  FRelatedList.Free;
  inherited;
end;

function TFhirDocumentManifest.GetResourceType : TFhirResourceType;
begin
  result := frtDocumentManifest;
end;

procedure TFhirDocumentManifest.Assign(oSource : TFslObject);
begin
  inherited;
  masterIdentifier := TFhirDocumentManifest(oSource).masterIdentifier.Clone;
  if (TFhirDocumentManifest(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirDocumentManifest(oSource).FIdentifierList);
  end;
  FStatus := TFhirDocumentManifest(oSource).FStatus.Link;
  type_ := TFhirDocumentManifest(oSource).type_.Clone;
  subject := TFhirDocumentManifest(oSource).subject.Clone;
  createdElement := TFhirDocumentManifest(oSource).createdElement.Clone;
  if (TFhirDocumentManifest(oSource).FAuthorList = nil) then
  begin
    FAuthorList.free;
    FAuthorList := nil;
  end
  else
  begin
    if FAuthorList = nil then
      FAuthorList := TFhirReferenceList{Resource}.Create;
    FAuthorList.Assign(TFhirDocumentManifest(oSource).FAuthorList);
  end;
  if (TFhirDocumentManifest(oSource).FRecipientList = nil) then
  begin
    FRecipientList.free;
    FRecipientList := nil;
  end
  else
  begin
    if FRecipientList = nil then
      FRecipientList := TFhirReferenceList{Resource}.Create;
    FRecipientList.Assign(TFhirDocumentManifest(oSource).FRecipientList);
  end;
  sourceElement := TFhirDocumentManifest(oSource).sourceElement.Clone;
  descriptionElement := TFhirDocumentManifest(oSource).descriptionElement.Clone;
  if (TFhirDocumentManifest(oSource).FContentList = nil) then
  begin
    FContentList.free;
    FContentList := nil;
  end
  else
  begin
    if FContentList = nil then
      FContentList := TFhirDocumentManifestContentList.Create;
    FContentList.Assign(TFhirDocumentManifest(oSource).FContentList);
  end;
  if (TFhirDocumentManifest(oSource).FRelatedList = nil) then
  begin
    FRelatedList.free;
    FRelatedList := nil;
  end
  else
  begin
    if FRelatedList = nil then
      FRelatedList := TFhirDocumentManifestRelatedList.Create;
    FRelatedList.Assign(TFhirDocumentManifest(oSource).FRelatedList);
  end;
end;

procedure TFhirDocumentManifest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'masterIdentifier') Then
     list.add(self.link, 'masterIdentifier', FMasterIdentifier.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'author') Then
    list.addAll(self, 'author', FAuthorList);
  if (child_name = 'recipient') Then
    list.addAll(self, 'recipient', FRecipientList);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'content') Then
    list.addAll(self, 'content', FContentList);
  if (child_name = 'related') Then
    list.addAll(self, 'related', FRelatedList);
end;

procedure TFhirDocumentManifest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'masterIdentifier', 'Identifier', false, TFhirIdentifier, FMasterIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Practitioner|Group|Device)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));{2}
  oList.add(TFHIRProperty.create(self, 'author', 'Reference(Practitioner|Organization|Device|Patient|RelatedPerson)', true, TFhirReference{Resource}, FAuthorList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'recipient', 'Reference(Patient|Practitioner|RelatedPerson|Organization)', true, TFhirReference{Resource}, FRecipientList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'source', 'uri', false, TFhirUri, FSource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'content', '', true, TFhirDocumentManifestContent, FContentList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'related', '', true, TFhirDocumentManifestRelated, FRelatedList.Link)){3};
end;

function TFhirDocumentManifest.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'masterIdentifier') then
  begin
    MasterIdentifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirDocumentReferenceStatusEnum, CODES_TFhirDocumentReferenceStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    AuthorList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'recipient') then
  begin
    RecipientList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    SourceElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'content') then
  begin
    ContentList.add(propValue as TFhirDocumentManifestContent){2a};
    result := propValue;
  end
  else if (propName = 'related') then
  begin
    RelatedList.add(propValue as TFhirDocumentManifestRelated){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirDocumentManifest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'author') then AuthorList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'recipient') then RecipientList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'content') then ContentList.insertItem(index, propValue as TFhirDocumentManifestContent){2a}
  else if (propName = 'related') then RelatedList.insertItem(index, propValue as TFhirDocumentManifestRelated){2a}
  else inherited;
end;

function TFhirDocumentManifest.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'masterIdentifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'created') then result := TFhirDateTime.create() {5b}
  else if (propName = 'author') then result := AuthorList.new(){2}
  else if (propName = 'recipient') then result := RecipientList.new(){2}
  else if (propName = 'source') then result := TFhirUri.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'content') then result := ContentList.new(){2}
  else if (propName = 'related') then result := RelatedList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDocumentManifest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'masterIdentifier') then result := 'Identifier'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'recipient') then result := 'Reference'
  else if (propName = 'source') then result := 'uri'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'content') then result := ''
  else if (propName = 'related') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDocumentManifest.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'masterIdentifier') then MasterIdentifierElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'author') then deletePropertyValue('author', AuthorList, value) {2}
  else if (propName = 'recipient') then deletePropertyValue('recipient', RecipientList, value) {2}
  else if (propName = 'source') then SourceElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'content') then deletePropertyValue('content', ContentList, value) {2}
  else if (propName = 'related') then deletePropertyValue('related', RelatedList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDocumentManifest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'masterIdentifier') then MasterIdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirDocumentReferenceStatusEnum, CODES_TFhirDocumentReferenceStatusEnum, new){4}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'created') then CreatedElement := asDateTime(new){5b}
  else if (propName = 'author') then replacePropertyValue('author', AuthorList, existing, new) {2}
  else if (propName = 'recipient') then replacePropertyValue('recipient', RecipientList, existing, new) {2}
  else if (propName = 'source') then SourceElement := asUri(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'content') then replacePropertyValue('content', ContentList, existing, new) {2}
  else if (propName = 'related') then replacePropertyValue('related', RelatedList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDocumentManifest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'author') then AuthorList.move(source, destination){2a}
  else if (propName = 'recipient') then RecipientList.move(source, destination){2a}
  else if (propName = 'content') then ContentList.move(source, destination){2a}
  else if (propName = 'related') then RelatedList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDocumentManifest.fhirType : string;
begin
  result := 'DocumentManifest';
end;

function TFhirDocumentManifest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMasterIdentifier) and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FType_) and isEmptyProp(FSubject) and isEmptyProp(FCreated) and isEmptyProp(FauthorList) and isEmptyProp(FrecipientList) and isEmptyProp(FSource) and isEmptyProp(FDescription) and isEmptyProp(FcontentList) and isEmptyProp(FrelatedList);
end;

function TFhirDocumentManifest.equals(other : TObject) : boolean;
var
  o : TFhirDocumentManifest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDocumentManifest)) then
    result := false
  else
  begin
    o := TFhirDocumentManifest(other);
    result := compareDeep(masterIdentifierElement, o.masterIdentifierElement, true) and
      compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(type_Element, o.type_Element, true) and compareDeep(subjectElement, o.subjectElement, true) and
      compareDeep(createdElement, o.createdElement, true) and compareDeep(authorList, o.authorList, true) and
      compareDeep(recipientList, o.recipientList, true) and compareDeep(sourceElement, o.sourceElement, true) and
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(contentList, o.contentList, true) and
      compareDeep(relatedList, o.relatedList, true);
  end;
end;

function TFhirDocumentManifest.Link : TFhirDocumentManifest;
begin
  result := TFhirDocumentManifest(inherited Link);
end;

function TFhirDocumentManifest.Clone : TFhirDocumentManifest;
begin
  result := TFhirDocumentManifest(inherited Clone);
end;

procedure TFhirDocumentManifest.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('masterIdentifier');
  fields.add('identifier');
  fields.add('status');
  fields.add('type');
  fields.add('subject');
  fields.add('created');
  fields.add('author');
  fields.add('recipient');
  fields.add('source');
  fields.add('description');
  fields.add('content');
  fields.add('related');
end;

{ TFhirDocumentManifest }

Procedure TFhirDocumentManifest.SetMasterIdentifier(value : TFhirIdentifier);
begin
  FMasterIdentifier.free;
  FMasterIdentifier := value;
end;

Function TFhirDocumentManifest.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirDocumentManifest.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirDocumentManifest.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirDocumentManifest.GetStatusST : TFhirDocumentReferenceStatusEnum;
begin
  if FStatus = nil then
    result := TFhirDocumentReferenceStatusEnum(0)
  else
    result := TFhirDocumentReferenceStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirDocumentReferenceStatusEnum, FStatus.value));
end;

Procedure TFhirDocumentManifest.SetStatusST(value : TFhirDocumentReferenceStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirDocumentReferenceStatusEnum[value], CODES_TFhirDocumentReferenceStatusEnum[value]);
end;

Procedure TFhirDocumentManifest.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirDocumentManifest.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirDocumentManifest.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

Function TFhirDocumentManifest.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

Procedure TFhirDocumentManifest.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

Function TFhirDocumentManifest.GetAuthorList : TFhirReferenceList{Resource};
begin
  if FAuthorList = nil then
    FAuthorList := TFhirReferenceList{Resource}.Create;
  result := FAuthorList;
end;

Function TFhirDocumentManifest.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

Function TFhirDocumentManifest.GetRecipientList : TFhirReferenceList{Resource};
begin
  if FRecipientList = nil then
    FRecipientList := TFhirReferenceList{Resource}.Create;
  result := FRecipientList;
end;

Function TFhirDocumentManifest.GetHasRecipientList : boolean;
begin
  result := (FRecipientList <> nil) and (FRecipientList.count > 0);
end;

Procedure TFhirDocumentManifest.SetSource(value : TFhirUri);
begin
  FSource.free;
  FSource := value;
end;

Function TFhirDocumentManifest.GetSourceST : String;
begin
  if FSource = nil then
    result := ''
  else
    result := FSource.value;
end;

Procedure TFhirDocumentManifest.SetSourceST(value : String);
begin
  if value <> '' then
  begin
    if FSource = nil then
      FSource := TFhirUri.create;
    FSource.value := value
  end
  else if FSource <> nil then
    FSource.value := '';
end;

Procedure TFhirDocumentManifest.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirDocumentManifest.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirDocumentManifest.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Function TFhirDocumentManifest.GetContentList : TFhirDocumentManifestContentList;
begin
  if FContentList = nil then
    FContentList := TFhirDocumentManifestContentList.Create;
  result := FContentList;
end;

Function TFhirDocumentManifest.GetHasContentList : boolean;
begin
  result := (FContentList <> nil) and (FContentList.count > 0);
end;

Function TFhirDocumentManifest.GetRelatedList : TFhirDocumentManifestRelatedList;
begin
  if FRelatedList = nil then
    FRelatedList := TFhirDocumentManifestRelatedList.Create;
  result := FRelatedList;
end;

Function TFhirDocumentManifest.GetHasRelatedList : boolean;
begin
  result := (FRelatedList <> nil) and (FRelatedList.count > 0);
end;

function TFhirDocumentManifest.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FMasterIdentifier.sizeInBytes);
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FauthorList.sizeInBytes);
  inc(result, FrecipientList.sizeInBytes);
  inc(result, FSource.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FcontentList.sizeInBytes);
  inc(result, FrelatedList.sizeInBytes);
end;

{ TFhirDocumentManifestListEnumerator }

Constructor TFhirDocumentManifestListEnumerator.Create(list : TFhirDocumentManifestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDocumentManifestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDocumentManifestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDocumentManifestListEnumerator.GetCurrent : TFhirDocumentManifest;
begin
  Result := FList[FIndex];
end;

function TFhirDocumentManifestListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDocumentManifestList }
procedure TFhirDocumentManifestList.AddItem(value: TFhirDocumentManifest);
begin
  assert(value.ClassName = 'TFhirDocumentManifest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDocumentManifest');
  add(value);
end;

function TFhirDocumentManifestList.Append: TFhirDocumentManifest;
begin
  result := TFhirDocumentManifest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentManifestList.ClearItems;
begin
  Clear;
end;

function TFhirDocumentManifestList.GetEnumerator : TFhirDocumentManifestListEnumerator;
begin
  result := TFhirDocumentManifestListEnumerator.Create(self.link);
end;

function TFhirDocumentManifestList.Clone: TFhirDocumentManifestList;
begin
  result := TFhirDocumentManifestList(inherited Clone);
end;

function TFhirDocumentManifestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDocumentManifestList.GetItemN(index: Integer): TFhirDocumentManifest;
begin
  result := TFhirDocumentManifest(ObjectByIndex[index]);
end;

function TFhirDocumentManifestList.ItemClass: TFslObjectClass;
begin
  result := TFhirDocumentManifest;
end;
function TFhirDocumentManifestList.IndexOf(value: TFhirDocumentManifest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDocumentManifestList.Insert(index: Integer): TFhirDocumentManifest;
begin
  result := TFhirDocumentManifest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentManifestList.InsertItem(index: Integer; value: TFhirDocumentManifest);
begin
  assert(value is TFhirDocumentManifest);
  Inherited Insert(index, value);
end;

function TFhirDocumentManifestList.Item(index: Integer): TFhirDocumentManifest;
begin
  result := TFhirDocumentManifest(ObjectByIndex[index]);
end;

function TFhirDocumentManifestList.Link: TFhirDocumentManifestList;
begin
  result := TFhirDocumentManifestList(inherited Link);
end;

procedure TFhirDocumentManifestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDocumentManifestList.SetItemByIndex(index: Integer; value: TFhirDocumentManifest);
begin
  assert(value is TFhirDocumentManifest);
  FhirDocumentManifests[index] := value;
end;

procedure TFhirDocumentManifestList.SetItemN(index: Integer; value: TFhirDocumentManifest);
begin
  assert(value is TFhirDocumentManifest);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_DOCUMENTMANIFEST}

{$IFDEF FHIR_DOCUMENTREFERENCE}

{ TFhirDocumentReferenceRelatesTo }

constructor TFhirDocumentReferenceRelatesTo.Create;
begin
  inherited;
end;

destructor TFhirDocumentReferenceRelatesTo.Destroy;
begin
  FCode.free;
  FTarget.free;
  inherited;
end;

procedure TFhirDocumentReferenceRelatesTo.Assign(oSource : TFslObject);
begin
  inherited;
  FCode := TFhirDocumentReferenceRelatesTo(oSource).FCode.Link;
  target := TFhirDocumentReferenceRelatesTo(oSource).target.Clone;
end;

procedure TFhirDocumentReferenceRelatesTo.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'target') Then
     list.add(self.link, 'target', FTarget.Link);
end;

procedure TFhirDocumentReferenceRelatesTo.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFHIREnum, FCode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'target', 'Reference(DocumentReference)', false, TFhirReference{TFhirDocumentReference}, FTarget.Link));{2}
end;

function TFhirDocumentReferenceRelatesTo.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asEnum(SYSTEMS_TFhirDocumentRelationshipTypeEnum, CODES_TFhirDocumentRelationshipTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'target') then
  begin
    Target := propValue as TFhirReference{TFhirDocumentReference}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDocumentReferenceRelatesTo.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDocumentReferenceRelatesTo.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'target') then result := TFhirReference{TFhirDocumentReference}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDocumentReferenceRelatesTo.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'code'
  else if (propName = 'target') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDocumentReferenceRelatesTo.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'target') then TargetElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDocumentReferenceRelatesTo.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asEnum(SYSTEMS_TFhirDocumentRelationshipTypeEnum, CODES_TFhirDocumentRelationshipTypeEnum, new){4}
  else if (propName = 'target') then TargetElement := new as TFhirReference{TFhirDocumentReference}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDocumentReferenceRelatesTo.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDocumentReferenceRelatesTo.fhirType : string;
begin
  result := 'relatesTo';
end;

function TFhirDocumentReferenceRelatesTo.Link : TFhirDocumentReferenceRelatesTo;
begin
  result := TFhirDocumentReferenceRelatesTo(inherited Link);
end;

function TFhirDocumentReferenceRelatesTo.Clone : TFhirDocumentReferenceRelatesTo;
begin
  result := TFhirDocumentReferenceRelatesTo(inherited Clone);
end;

function TFhirDocumentReferenceRelatesTo.equals(other : TObject) : boolean;
var
  o : TFhirDocumentReferenceRelatesTo;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDocumentReferenceRelatesTo)) then
    result := false
  else
  begin
    o := TFhirDocumentReferenceRelatesTo(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(targetElement, o.targetElement, true);
  end;
end;

function TFhirDocumentReferenceRelatesTo.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FTarget);
end;

procedure TFhirDocumentReferenceRelatesTo.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('target');
end;

{ TFhirDocumentReferenceRelatesTo }

Procedure TFhirDocumentReferenceRelatesTo.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirDocumentReferenceRelatesTo.GetCodeST : TFhirDocumentRelationshipTypeEnum;
begin
  if FCode = nil then
    result := TFhirDocumentRelationshipTypeEnum(0)
  else
    result := TFhirDocumentRelationshipTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirDocumentRelationshipTypeEnum, FCode.value));
end;

Procedure TFhirDocumentReferenceRelatesTo.SetCodeST(value : TFhirDocumentRelationshipTypeEnum);
begin
  if ord(value) = 0 then
    CodeElement := nil
  else
    CodeElement := TFhirEnum.create(SYSTEMS_TFhirDocumentRelationshipTypeEnum[value], CODES_TFhirDocumentRelationshipTypeEnum[value]);
end;

Procedure TFhirDocumentReferenceRelatesTo.SetTarget(value : TFhirReference{TFhirDocumentReference});
begin
  FTarget.free;
  FTarget := value;
end;

function TFhirDocumentReferenceRelatesTo.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FTarget.sizeInBytes);
end;

{ TFhirDocumentReferenceRelatesToListEnumerator }

Constructor TFhirDocumentReferenceRelatesToListEnumerator.Create(list : TFhirDocumentReferenceRelatesToList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDocumentReferenceRelatesToListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDocumentReferenceRelatesToListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDocumentReferenceRelatesToListEnumerator.GetCurrent : TFhirDocumentReferenceRelatesTo;
begin
  Result := FList[FIndex];
end;

function TFhirDocumentReferenceRelatesToListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDocumentReferenceRelatesToList }
procedure TFhirDocumentReferenceRelatesToList.AddItem(value: TFhirDocumentReferenceRelatesTo);
begin
  assert(value.ClassName = 'TFhirDocumentReferenceRelatesTo', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDocumentReferenceRelatesTo');
  add(value);
end;

function TFhirDocumentReferenceRelatesToList.Append: TFhirDocumentReferenceRelatesTo;
begin
  result := TFhirDocumentReferenceRelatesTo.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentReferenceRelatesToList.ClearItems;
begin
  Clear;
end;

function TFhirDocumentReferenceRelatesToList.GetEnumerator : TFhirDocumentReferenceRelatesToListEnumerator;
begin
  result := TFhirDocumentReferenceRelatesToListEnumerator.Create(self.link);
end;

function TFhirDocumentReferenceRelatesToList.Clone: TFhirDocumentReferenceRelatesToList;
begin
  result := TFhirDocumentReferenceRelatesToList(inherited Clone);
end;

function TFhirDocumentReferenceRelatesToList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDocumentReferenceRelatesToList.GetItemN(index: Integer): TFhirDocumentReferenceRelatesTo;
begin
  result := TFhirDocumentReferenceRelatesTo(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceRelatesToList.ItemClass: TFslObjectClass;
begin
  result := TFhirDocumentReferenceRelatesTo;
end;
function TFhirDocumentReferenceRelatesToList.IndexOf(value: TFhirDocumentReferenceRelatesTo): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDocumentReferenceRelatesToList.Insert(index: Integer): TFhirDocumentReferenceRelatesTo;
begin
  result := TFhirDocumentReferenceRelatesTo.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentReferenceRelatesToList.InsertItem(index: Integer; value: TFhirDocumentReferenceRelatesTo);
begin
  assert(value is TFhirDocumentReferenceRelatesTo);
  Inherited Insert(index, value);
end;

function TFhirDocumentReferenceRelatesToList.Item(index: Integer): TFhirDocumentReferenceRelatesTo;
begin
  result := TFhirDocumentReferenceRelatesTo(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceRelatesToList.Link: TFhirDocumentReferenceRelatesToList;
begin
  result := TFhirDocumentReferenceRelatesToList(inherited Link);
end;

procedure TFhirDocumentReferenceRelatesToList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDocumentReferenceRelatesToList.SetItemByIndex(index: Integer; value: TFhirDocumentReferenceRelatesTo);
begin
  assert(value is TFhirDocumentReferenceRelatesTo);
  FhirDocumentReferenceRelatesTos[index] := value;
end;

procedure TFhirDocumentReferenceRelatesToList.SetItemN(index: Integer; value: TFhirDocumentReferenceRelatesTo);
begin
  assert(value is TFhirDocumentReferenceRelatesTo);
  ObjectByIndex[index] := value;
end;

{ TFhirDocumentReferenceContent }

constructor TFhirDocumentReferenceContent.Create;
begin
  inherited;
end;

destructor TFhirDocumentReferenceContent.Destroy;
begin
  FAttachment.free;
  FFormat.free;
  inherited;
end;

procedure TFhirDocumentReferenceContent.Assign(oSource : TFslObject);
begin
  inherited;
  attachment := TFhirDocumentReferenceContent(oSource).attachment.Clone;
  format := TFhirDocumentReferenceContent(oSource).format.Clone;
end;

procedure TFhirDocumentReferenceContent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'attachment') Then
     list.add(self.link, 'attachment', FAttachment.Link);
  if (child_name = 'format') Then
     list.add(self.link, 'format', FFormat.Link);
end;

procedure TFhirDocumentReferenceContent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'attachment', 'Attachment', false, TFhirAttachment, FAttachment.Link));{2}
  oList.add(TFHIRProperty.create(self, 'format', 'Coding', false, TFhirCoding, FFormat.Link));{2}
end;

function TFhirDocumentReferenceContent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'attachment') then
  begin
    Attachment := propValue as TFhirAttachment{4b};
    result := propValue;
  end
  else if (propName = 'format') then
  begin
    Format := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDocumentReferenceContent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDocumentReferenceContent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'attachment') then result := TFhirAttachment.create(){4b}
  else if (propName = 'format') then result := TFhirCoding.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDocumentReferenceContent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'attachment') then result := 'Attachment'
  else if (propName = 'format') then result := 'Coding'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDocumentReferenceContent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'attachment') then AttachmentElement := nil
  else if (propName = 'format') then FormatElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDocumentReferenceContent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'attachment') then AttachmentElement := new as TFhirAttachment{4}
  else if (propName = 'format') then FormatElement := new as TFhirCoding{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDocumentReferenceContent.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDocumentReferenceContent.fhirType : string;
begin
  result := 'content';
end;

function TFhirDocumentReferenceContent.Link : TFhirDocumentReferenceContent;
begin
  result := TFhirDocumentReferenceContent(inherited Link);
end;

function TFhirDocumentReferenceContent.Clone : TFhirDocumentReferenceContent;
begin
  result := TFhirDocumentReferenceContent(inherited Clone);
end;

function TFhirDocumentReferenceContent.equals(other : TObject) : boolean;
var
  o : TFhirDocumentReferenceContent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDocumentReferenceContent)) then
    result := false
  else
  begin
    o := TFhirDocumentReferenceContent(other);
    result := compareDeep(attachmentElement, o.attachmentElement, true) and compareDeep(formatElement, o.formatElement, true);
  end;
end;

function TFhirDocumentReferenceContent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAttachment) and isEmptyProp(FFormat);
end;

procedure TFhirDocumentReferenceContent.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('attachment');
  fields.add('format');
end;

{ TFhirDocumentReferenceContent }

Procedure TFhirDocumentReferenceContent.SetAttachment(value : TFhirAttachment);
begin
  FAttachment.free;
  FAttachment := value;
end;

Procedure TFhirDocumentReferenceContent.SetFormat(value : TFhirCoding);
begin
  FFormat.free;
  FFormat := value;
end;

function TFhirDocumentReferenceContent.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FAttachment.sizeInBytes);
  inc(result, FFormat.sizeInBytes);
end;

{ TFhirDocumentReferenceContentListEnumerator }

Constructor TFhirDocumentReferenceContentListEnumerator.Create(list : TFhirDocumentReferenceContentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDocumentReferenceContentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDocumentReferenceContentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDocumentReferenceContentListEnumerator.GetCurrent : TFhirDocumentReferenceContent;
begin
  Result := FList[FIndex];
end;

function TFhirDocumentReferenceContentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDocumentReferenceContentList }
procedure TFhirDocumentReferenceContentList.AddItem(value: TFhirDocumentReferenceContent);
begin
  assert(value.ClassName = 'TFhirDocumentReferenceContent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDocumentReferenceContent');
  add(value);
end;

function TFhirDocumentReferenceContentList.Append: TFhirDocumentReferenceContent;
begin
  result := TFhirDocumentReferenceContent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentReferenceContentList.ClearItems;
begin
  Clear;
end;

function TFhirDocumentReferenceContentList.GetEnumerator : TFhirDocumentReferenceContentListEnumerator;
begin
  result := TFhirDocumentReferenceContentListEnumerator.Create(self.link);
end;

function TFhirDocumentReferenceContentList.Clone: TFhirDocumentReferenceContentList;
begin
  result := TFhirDocumentReferenceContentList(inherited Clone);
end;

function TFhirDocumentReferenceContentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDocumentReferenceContentList.GetItemN(index: Integer): TFhirDocumentReferenceContent;
begin
  result := TFhirDocumentReferenceContent(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceContentList.ItemClass: TFslObjectClass;
begin
  result := TFhirDocumentReferenceContent;
end;
function TFhirDocumentReferenceContentList.IndexOf(value: TFhirDocumentReferenceContent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDocumentReferenceContentList.Insert(index: Integer): TFhirDocumentReferenceContent;
begin
  result := TFhirDocumentReferenceContent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentReferenceContentList.InsertItem(index: Integer; value: TFhirDocumentReferenceContent);
begin
  assert(value is TFhirDocumentReferenceContent);
  Inherited Insert(index, value);
end;

function TFhirDocumentReferenceContentList.Item(index: Integer): TFhirDocumentReferenceContent;
begin
  result := TFhirDocumentReferenceContent(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceContentList.Link: TFhirDocumentReferenceContentList;
begin
  result := TFhirDocumentReferenceContentList(inherited Link);
end;

procedure TFhirDocumentReferenceContentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDocumentReferenceContentList.SetItemByIndex(index: Integer; value: TFhirDocumentReferenceContent);
begin
  assert(value is TFhirDocumentReferenceContent);
  FhirDocumentReferenceContents[index] := value;
end;

procedure TFhirDocumentReferenceContentList.SetItemN(index: Integer; value: TFhirDocumentReferenceContent);
begin
  assert(value is TFhirDocumentReferenceContent);
  ObjectByIndex[index] := value;
end;

{ TFhirDocumentReferenceContext }

constructor TFhirDocumentReferenceContext.Create;
begin
  inherited;
end;

destructor TFhirDocumentReferenceContext.Destroy;
begin
  FEncounter.free;
  FEventList.Free;
  FPeriod.free;
  FFacilityType.free;
  FPracticeSetting.free;
  FSourcePatientInfo.free;
  FRelatedList.Free;
  inherited;
end;

procedure TFhirDocumentReferenceContext.Assign(oSource : TFslObject);
begin
  inherited;
  encounter := TFhirDocumentReferenceContext(oSource).encounter.Clone;
  if (TFhirDocumentReferenceContext(oSource).FEventList = nil) then
  begin
    FEventList.free;
    FEventList := nil;
  end
  else
  begin
    if FEventList = nil then
      FEventList := TFhirCodeableConceptList.Create;
    FEventList.Assign(TFhirDocumentReferenceContext(oSource).FEventList);
  end;
  period := TFhirDocumentReferenceContext(oSource).period.Clone;
  facilityType := TFhirDocumentReferenceContext(oSource).facilityType.Clone;
  practiceSetting := TFhirDocumentReferenceContext(oSource).practiceSetting.Clone;
  sourcePatientInfo := TFhirDocumentReferenceContext(oSource).sourcePatientInfo.Clone;
  if (TFhirDocumentReferenceContext(oSource).FRelatedList = nil) then
  begin
    FRelatedList.free;
    FRelatedList := nil;
  end
  else
  begin
    if FRelatedList = nil then
      FRelatedList := TFhirDocumentReferenceContextRelatedList.Create;
    FRelatedList.Assign(TFhirDocumentReferenceContext(oSource).FRelatedList);
  end;
end;

procedure TFhirDocumentReferenceContext.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'event') Then
    list.addAll(self, 'event', FEventList);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'facilityType') Then
     list.add(self.link, 'facilityType', FFacilityType.Link);
  if (child_name = 'practiceSetting') Then
     list.add(self.link, 'practiceSetting', FPracticeSetting.Link);
  if (child_name = 'sourcePatientInfo') Then
     list.add(self.link, 'sourcePatientInfo', FSourcePatientInfo.Link);
  if (child_name = 'related') Then
    list.addAll(self, 'related', FRelatedList);
end;

procedure TFhirDocumentReferenceContext.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference(Encounter)', false, TFhirReference{TFhirEncounter}, FEncounter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'event', 'CodeableConcept', true, TFhirCodeableConcept, FEventList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'facilityType', 'CodeableConcept', false, TFhirCodeableConcept, FFacilityType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'practiceSetting', 'CodeableConcept', false, TFhirCodeableConcept, FPracticeSetting.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sourcePatientInfo', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FSourcePatientInfo.Link));{2}
  oList.add(TFHIRProperty.create(self, 'related', '', true, TFhirDocumentReferenceContextRelated, FRelatedList.Link)){3};
end;

function TFhirDocumentReferenceContext.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference{TFhirEncounter}{4b};
    result := propValue;
  end
  else if (propName = 'event') then
  begin
    EventList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'facilityType') then
  begin
    FacilityType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'practiceSetting') then
  begin
    PracticeSetting := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'sourcePatientInfo') then
  begin
    SourcePatientInfo := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'related') then
  begin
    RelatedList.add(propValue as TFhirDocumentReferenceContextRelated){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDocumentReferenceContext.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'event') then EventList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'related') then RelatedList.insertItem(index, propValue as TFhirDocumentReferenceContextRelated){2a}
  else inherited;
end;

function TFhirDocumentReferenceContext.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'encounter') then result := TFhirReference{TFhirEncounter}.create(){4b}
  else if (propName = 'event') then result := EventList.new(){2}
  else if (propName = 'period') then result := TFhirPeriod.create(){4b}
  else if (propName = 'facilityType') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'practiceSetting') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'sourcePatientInfo') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'related') then result := RelatedList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDocumentReferenceContext.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'event') then result := 'CodeableConcept'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'facilityType') then result := 'CodeableConcept'
  else if (propName = 'practiceSetting') then result := 'CodeableConcept'
  else if (propName = 'sourcePatientInfo') then result := 'Reference'
  else if (propName = 'related') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDocumentReferenceContext.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'event') then deletePropertyValue('event', EventList, value) {2}
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'facilityType') then FacilityTypeElement := nil
  else if (propName = 'practiceSetting') then PracticeSettingElement := nil
  else if (propName = 'sourcePatientInfo') then SourcePatientInfoElement := nil
  else if (propName = 'related') then deletePropertyValue('related', RelatedList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDocumentReferenceContext.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'encounter') then EncounterElement := new as TFhirReference{TFhirEncounter}{4}
  else if (propName = 'event') then replacePropertyValue('event', EventList, existing, new) {2}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else if (propName = 'facilityType') then FacilityTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'practiceSetting') then PracticeSettingElement := new as TFhirCodeableConcept{4}
  else if (propName = 'sourcePatientInfo') then SourcePatientInfoElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'related') then replacePropertyValue('related', RelatedList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDocumentReferenceContext.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'event') then EventList.move(source, destination){2a}
  else if (propName = 'related') then RelatedList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDocumentReferenceContext.fhirType : string;
begin
  result := 'context';
end;

function TFhirDocumentReferenceContext.Link : TFhirDocumentReferenceContext;
begin
  result := TFhirDocumentReferenceContext(inherited Link);
end;

function TFhirDocumentReferenceContext.Clone : TFhirDocumentReferenceContext;
begin
  result := TFhirDocumentReferenceContext(inherited Clone);
end;

function TFhirDocumentReferenceContext.equals(other : TObject) : boolean;
var
  o : TFhirDocumentReferenceContext;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDocumentReferenceContext)) then
    result := false
  else
  begin
    o := TFhirDocumentReferenceContext(other);
    result := compareDeep(encounterElement, o.encounterElement, true) and compareDeep(eventList, o.eventList, true) and
      compareDeep(periodElement, o.periodElement, true) and compareDeep(facilityTypeElement, o.facilityTypeElement, true) and
      compareDeep(practiceSettingElement, o.practiceSettingElement, true) and compareDeep(sourcePatientInfoElement, o.sourcePatientInfoElement, true) and
      compareDeep(relatedList, o.relatedList, true);
  end;
end;

function TFhirDocumentReferenceContext.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FEncounter) and isEmptyProp(FeventList) and isEmptyProp(FPeriod) and isEmptyProp(FFacilityType) and isEmptyProp(FPracticeSetting) and isEmptyProp(FSourcePatientInfo) and isEmptyProp(FrelatedList);
end;

procedure TFhirDocumentReferenceContext.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('encounter');
  fields.add('event');
  fields.add('period');
  fields.add('facilityType');
  fields.add('practiceSetting');
  fields.add('sourcePatientInfo');
  fields.add('related');
end;

{ TFhirDocumentReferenceContext }

Procedure TFhirDocumentReferenceContext.SetEncounter(value : TFhirReference{TFhirEncounter});
begin
  FEncounter.free;
  FEncounter := value;
end;

Function TFhirDocumentReferenceContext.GetEventList : TFhirCodeableConceptList;
begin
  if FEventList = nil then
    FEventList := TFhirCodeableConceptList.Create;
  result := FEventList;
end;

Function TFhirDocumentReferenceContext.GetHasEventList : boolean;
begin
  result := (FEventList <> nil) and (FEventList.count > 0);
end;

Procedure TFhirDocumentReferenceContext.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Procedure TFhirDocumentReferenceContext.SetFacilityType(value : TFhirCodeableConcept);
begin
  FFacilityType.free;
  FFacilityType := value;
end;

Procedure TFhirDocumentReferenceContext.SetPracticeSetting(value : TFhirCodeableConcept);
begin
  FPracticeSetting.free;
  FPracticeSetting := value;
end;

Procedure TFhirDocumentReferenceContext.SetSourcePatientInfo(value : TFhirReference{TFhirPatient});
begin
  FSourcePatientInfo.free;
  FSourcePatientInfo := value;
end;

Function TFhirDocumentReferenceContext.GetRelatedList : TFhirDocumentReferenceContextRelatedList;
begin
  if FRelatedList = nil then
    FRelatedList := TFhirDocumentReferenceContextRelatedList.Create;
  result := FRelatedList;
end;

Function TFhirDocumentReferenceContext.GetHasRelatedList : boolean;
begin
  result := (FRelatedList <> nil) and (FRelatedList.count > 0);
end;

function TFhirDocumentReferenceContext.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FEncounter.sizeInBytes);
  inc(result, FeventList.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FFacilityType.sizeInBytes);
  inc(result, FPracticeSetting.sizeInBytes);
  inc(result, FSourcePatientInfo.sizeInBytes);
  inc(result, FrelatedList.sizeInBytes);
end;

{ TFhirDocumentReferenceContextListEnumerator }

Constructor TFhirDocumentReferenceContextListEnumerator.Create(list : TFhirDocumentReferenceContextList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDocumentReferenceContextListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDocumentReferenceContextListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDocumentReferenceContextListEnumerator.GetCurrent : TFhirDocumentReferenceContext;
begin
  Result := FList[FIndex];
end;

function TFhirDocumentReferenceContextListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDocumentReferenceContextList }
procedure TFhirDocumentReferenceContextList.AddItem(value: TFhirDocumentReferenceContext);
begin
  assert(value.ClassName = 'TFhirDocumentReferenceContext', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDocumentReferenceContext');
  add(value);
end;

function TFhirDocumentReferenceContextList.Append: TFhirDocumentReferenceContext;
begin
  result := TFhirDocumentReferenceContext.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentReferenceContextList.ClearItems;
begin
  Clear;
end;

function TFhirDocumentReferenceContextList.GetEnumerator : TFhirDocumentReferenceContextListEnumerator;
begin
  result := TFhirDocumentReferenceContextListEnumerator.Create(self.link);
end;

function TFhirDocumentReferenceContextList.Clone: TFhirDocumentReferenceContextList;
begin
  result := TFhirDocumentReferenceContextList(inherited Clone);
end;

function TFhirDocumentReferenceContextList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDocumentReferenceContextList.GetItemN(index: Integer): TFhirDocumentReferenceContext;
begin
  result := TFhirDocumentReferenceContext(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceContextList.ItemClass: TFslObjectClass;
begin
  result := TFhirDocumentReferenceContext;
end;
function TFhirDocumentReferenceContextList.IndexOf(value: TFhirDocumentReferenceContext): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDocumentReferenceContextList.Insert(index: Integer): TFhirDocumentReferenceContext;
begin
  result := TFhirDocumentReferenceContext.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentReferenceContextList.InsertItem(index: Integer; value: TFhirDocumentReferenceContext);
begin
  assert(value is TFhirDocumentReferenceContext);
  Inherited Insert(index, value);
end;

function TFhirDocumentReferenceContextList.Item(index: Integer): TFhirDocumentReferenceContext;
begin
  result := TFhirDocumentReferenceContext(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceContextList.Link: TFhirDocumentReferenceContextList;
begin
  result := TFhirDocumentReferenceContextList(inherited Link);
end;

procedure TFhirDocumentReferenceContextList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDocumentReferenceContextList.SetItemByIndex(index: Integer; value: TFhirDocumentReferenceContext);
begin
  assert(value is TFhirDocumentReferenceContext);
  FhirDocumentReferenceContexts[index] := value;
end;

procedure TFhirDocumentReferenceContextList.SetItemN(index: Integer; value: TFhirDocumentReferenceContext);
begin
  assert(value is TFhirDocumentReferenceContext);
  ObjectByIndex[index] := value;
end;

{ TFhirDocumentReferenceContextRelated }

constructor TFhirDocumentReferenceContextRelated.Create;
begin
  inherited;
end;

destructor TFhirDocumentReferenceContextRelated.Destroy;
begin
  FIdentifier.free;
  FRef.free;
  inherited;
end;

procedure TFhirDocumentReferenceContextRelated.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirDocumentReferenceContextRelated(oSource).identifier.Clone;
  ref := TFhirDocumentReferenceContextRelated(oSource).ref.Clone;
end;

procedure TFhirDocumentReferenceContextRelated.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'ref') Then
     list.add(self.link, 'ref', FRef.Link);
end;

procedure TFhirDocumentReferenceContextRelated.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'ref', 'Reference(Any)', false, TFhirReference{TFhirReference}, FRef.Link));{2}
end;

function TFhirDocumentReferenceContextRelated.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'ref') then
  begin
    Ref := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDocumentReferenceContextRelated.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDocumentReferenceContextRelated.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'ref') then result := TFhirReference{TFhirReference}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDocumentReferenceContextRelated.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'ref') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDocumentReferenceContextRelated.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'ref') then RefElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDocumentReferenceContextRelated.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'ref') then RefElement := new as TFhirReference{TFhirReference}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDocumentReferenceContextRelated.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDocumentReferenceContextRelated.fhirType : string;
begin
  result := 'related';
end;

function TFhirDocumentReferenceContextRelated.Link : TFhirDocumentReferenceContextRelated;
begin
  result := TFhirDocumentReferenceContextRelated(inherited Link);
end;

function TFhirDocumentReferenceContextRelated.Clone : TFhirDocumentReferenceContextRelated;
begin
  result := TFhirDocumentReferenceContextRelated(inherited Clone);
end;

function TFhirDocumentReferenceContextRelated.equals(other : TObject) : boolean;
var
  o : TFhirDocumentReferenceContextRelated;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDocumentReferenceContextRelated)) then
    result := false
  else
  begin
    o := TFhirDocumentReferenceContextRelated(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(refElement, o.refElement, true);
  end;
end;

function TFhirDocumentReferenceContextRelated.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FRef);
end;

procedure TFhirDocumentReferenceContextRelated.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('ref');
end;

{ TFhirDocumentReferenceContextRelated }

Procedure TFhirDocumentReferenceContextRelated.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirDocumentReferenceContextRelated.SetRef(value : TFhirReference{TFhirReference});
begin
  FRef.free;
  FRef := value;
end;

function TFhirDocumentReferenceContextRelated.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FRef.sizeInBytes);
end;

{ TFhirDocumentReferenceContextRelatedListEnumerator }

Constructor TFhirDocumentReferenceContextRelatedListEnumerator.Create(list : TFhirDocumentReferenceContextRelatedList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDocumentReferenceContextRelatedListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDocumentReferenceContextRelatedListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDocumentReferenceContextRelatedListEnumerator.GetCurrent : TFhirDocumentReferenceContextRelated;
begin
  Result := FList[FIndex];
end;

function TFhirDocumentReferenceContextRelatedListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDocumentReferenceContextRelatedList }
procedure TFhirDocumentReferenceContextRelatedList.AddItem(value: TFhirDocumentReferenceContextRelated);
begin
  assert(value.ClassName = 'TFhirDocumentReferenceContextRelated', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDocumentReferenceContextRelated');
  add(value);
end;

function TFhirDocumentReferenceContextRelatedList.Append: TFhirDocumentReferenceContextRelated;
begin
  result := TFhirDocumentReferenceContextRelated.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentReferenceContextRelatedList.ClearItems;
begin
  Clear;
end;

function TFhirDocumentReferenceContextRelatedList.GetEnumerator : TFhirDocumentReferenceContextRelatedListEnumerator;
begin
  result := TFhirDocumentReferenceContextRelatedListEnumerator.Create(self.link);
end;

function TFhirDocumentReferenceContextRelatedList.Clone: TFhirDocumentReferenceContextRelatedList;
begin
  result := TFhirDocumentReferenceContextRelatedList(inherited Clone);
end;

function TFhirDocumentReferenceContextRelatedList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDocumentReferenceContextRelatedList.GetItemN(index: Integer): TFhirDocumentReferenceContextRelated;
begin
  result := TFhirDocumentReferenceContextRelated(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceContextRelatedList.ItemClass: TFslObjectClass;
begin
  result := TFhirDocumentReferenceContextRelated;
end;
function TFhirDocumentReferenceContextRelatedList.IndexOf(value: TFhirDocumentReferenceContextRelated): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDocumentReferenceContextRelatedList.Insert(index: Integer): TFhirDocumentReferenceContextRelated;
begin
  result := TFhirDocumentReferenceContextRelated.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentReferenceContextRelatedList.InsertItem(index: Integer; value: TFhirDocumentReferenceContextRelated);
begin
  assert(value is TFhirDocumentReferenceContextRelated);
  Inherited Insert(index, value);
end;

function TFhirDocumentReferenceContextRelatedList.Item(index: Integer): TFhirDocumentReferenceContextRelated;
begin
  result := TFhirDocumentReferenceContextRelated(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceContextRelatedList.Link: TFhirDocumentReferenceContextRelatedList;
begin
  result := TFhirDocumentReferenceContextRelatedList(inherited Link);
end;

procedure TFhirDocumentReferenceContextRelatedList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDocumentReferenceContextRelatedList.SetItemByIndex(index: Integer; value: TFhirDocumentReferenceContextRelated);
begin
  assert(value is TFhirDocumentReferenceContextRelated);
  FhirDocumentReferenceContextRelateds[index] := value;
end;

procedure TFhirDocumentReferenceContextRelatedList.SetItemN(index: Integer; value: TFhirDocumentReferenceContextRelated);
begin
  assert(value is TFhirDocumentReferenceContextRelated);
  ObjectByIndex[index] := value;
end;

{ TFhirDocumentReference }

constructor TFhirDocumentReference.Create;
begin
  inherited;
end;

destructor TFhirDocumentReference.Destroy;
begin
  FMasterIdentifier.free;
  FIdentifierList.Free;
  FStatus.free;
  FDocStatus.free;
  FType_.free;
  FClass_.free;
  FSubject.free;
  FCreated.free;
  FIndexed.free;
  FAuthorList.Free;
  FAuthenticator.free;
  FCustodian.free;
  FRelatesToList.Free;
  FDescription.free;
  FSecurityLabelList.Free;
  FContentList.Free;
  FContext.free;
  inherited;
end;

function TFhirDocumentReference.GetResourceType : TFhirResourceType;
begin
  result := frtDocumentReference;
end;

procedure TFhirDocumentReference.Assign(oSource : TFslObject);
begin
  inherited;
  masterIdentifier := TFhirDocumentReference(oSource).masterIdentifier.Clone;
  if (TFhirDocumentReference(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirDocumentReference(oSource).FIdentifierList);
  end;
  FStatus := TFhirDocumentReference(oSource).FStatus.Link;
  FDocStatus := TFhirDocumentReference(oSource).FDocStatus.Link;
  type_ := TFhirDocumentReference(oSource).type_.Clone;
  class_ := TFhirDocumentReference(oSource).class_.Clone;
  subject := TFhirDocumentReference(oSource).subject.Clone;
  createdElement := TFhirDocumentReference(oSource).createdElement.Clone;
  indexedElement := TFhirDocumentReference(oSource).indexedElement.Clone;
  if (TFhirDocumentReference(oSource).FAuthorList = nil) then
  begin
    FAuthorList.free;
    FAuthorList := nil;
  end
  else
  begin
    if FAuthorList = nil then
      FAuthorList := TFhirReferenceList{Resource}.Create;
    FAuthorList.Assign(TFhirDocumentReference(oSource).FAuthorList);
  end;
  authenticator := TFhirDocumentReference(oSource).authenticator.Clone;
  custodian := TFhirDocumentReference(oSource).custodian.Clone;
  if (TFhirDocumentReference(oSource).FRelatesToList = nil) then
  begin
    FRelatesToList.free;
    FRelatesToList := nil;
  end
  else
  begin
    if FRelatesToList = nil then
      FRelatesToList := TFhirDocumentReferenceRelatesToList.Create;
    FRelatesToList.Assign(TFhirDocumentReference(oSource).FRelatesToList);
  end;
  descriptionElement := TFhirDocumentReference(oSource).descriptionElement.Clone;
  if (TFhirDocumentReference(oSource).FSecurityLabelList = nil) then
  begin
    FSecurityLabelList.free;
    FSecurityLabelList := nil;
  end
  else
  begin
    if FSecurityLabelList = nil then
      FSecurityLabelList := TFhirCodeableConceptList.Create;
    FSecurityLabelList.Assign(TFhirDocumentReference(oSource).FSecurityLabelList);
  end;
  if (TFhirDocumentReference(oSource).FContentList = nil) then
  begin
    FContentList.free;
    FContentList := nil;
  end
  else
  begin
    if FContentList = nil then
      FContentList := TFhirDocumentReferenceContentList.Create;
    FContentList.Assign(TFhirDocumentReference(oSource).FContentList);
  end;
  context := TFhirDocumentReference(oSource).context.Clone;
end;

procedure TFhirDocumentReference.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'masterIdentifier') Then
     list.add(self.link, 'masterIdentifier', FMasterIdentifier.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'docStatus') Then
     list.add(self.link, 'docStatus', FDocStatus.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'class') Then
     list.add(self.link, 'class', FClass_.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'indexed') Then
     list.add(self.link, 'indexed', FIndexed.Link);
  if (child_name = 'author') Then
    list.addAll(self, 'author', FAuthorList);
  if (child_name = 'authenticator') Then
     list.add(self.link, 'authenticator', FAuthenticator.Link);
  if (child_name = 'custodian') Then
     list.add(self.link, 'custodian', FCustodian.Link);
  if (child_name = 'relatesTo') Then
    list.addAll(self, 'relatesTo', FRelatesToList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'securityLabel') Then
    list.addAll(self, 'securityLabel', FSecurityLabelList);
  if (child_name = 'content') Then
    list.addAll(self, 'content', FContentList);
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
end;

procedure TFhirDocumentReference.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'masterIdentifier', 'Identifier', false, TFhirIdentifier, FMasterIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'docStatus', 'code', false, TFHIREnum, FDocStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'class', 'CodeableConcept', false, TFhirCodeableConcept, FClass_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Practitioner|Group|Device)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));{2}
  oList.add(TFHIRProperty.create(self, 'indexed', 'instant', false, TFhirInstant, FIndexed.Link));{2}
  oList.add(TFHIRProperty.create(self, 'author', 'Reference(Practitioner|Organization|Device|Patient|RelatedPerson)', true, TFhirReference{Resource}, FAuthorList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'authenticator', 'Reference(Practitioner|Organization)', false, TFhirReference{Resource}, FAuthenticator.Link));{2}
  oList.add(TFHIRProperty.create(self, 'custodian', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FCustodian.Link));{2}
  oList.add(TFHIRProperty.create(self, 'relatesTo', '', true, TFhirDocumentReferenceRelatesTo, FRelatesToList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'securityLabel', 'CodeableConcept', true, TFhirCodeableConcept, FSecurityLabelList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'content', '', true, TFhirDocumentReferenceContent, FContentList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'context', '', false, TFhirDocumentReferenceContext, FContext.Link));{2}
end;

function TFhirDocumentReference.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'masterIdentifier') then
  begin
    MasterIdentifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirDocumentReferenceStatusEnum, CODES_TFhirDocumentReferenceStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'docStatus') then
  begin
    DocStatusElement := asEnum(SYSTEMS_TFhirCompositionStatusEnum, CODES_TFhirCompositionStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'class') then
  begin
    Class_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'indexed') then
  begin
    IndexedElement := asInstant(propValue){5a};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    AuthorList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'authenticator') then
  begin
    Authenticator := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'custodian') then
  begin
    Custodian := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'relatesTo') then
  begin
    RelatesToList.add(propValue as TFhirDocumentReferenceRelatesTo){2a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'securityLabel') then
  begin
    SecurityLabelList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'content') then
  begin
    ContentList.add(propValue as TFhirDocumentReferenceContent){2a};
    result := propValue;
  end
  else if (propName = 'context') then
  begin
    Context := propValue as TFhirDocumentReferenceContext{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirDocumentReference.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'author') then AuthorList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'relatesTo') then RelatesToList.insertItem(index, propValue as TFhirDocumentReferenceRelatesTo){2a}
  else if (propName = 'securityLabel') then SecurityLabelList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'content') then ContentList.insertItem(index, propValue as TFhirDocumentReferenceContent){2a}
  else inherited;
end;

function TFhirDocumentReference.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'masterIdentifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'class') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'created') then result := TFhirDateTime.create() {5b}
  else if (propName = 'indexed') then result := TFhirInstant.create() {5b}
  else if (propName = 'author') then result := AuthorList.new(){2}
  else if (propName = 'authenticator') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'custodian') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'relatesTo') then result := RelatesToList.new(){2}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'securityLabel') then result := SecurityLabelList.new(){2}
  else if (propName = 'content') then result := ContentList.new(){2}
  else if (propName = 'context') then result := TFhirDocumentReferenceContext.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDocumentReference.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'masterIdentifier') then result := 'Identifier'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'docStatus') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'class') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'indexed') then result := 'instant'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'authenticator') then result := 'Reference'
  else if (propName = 'custodian') then result := 'Reference'
  else if (propName = 'relatesTo') then result := ''
  else if (propName = 'description') then result := 'string'
  else if (propName = 'securityLabel') then result := 'CodeableConcept'
  else if (propName = 'content') then result := ''
  else if (propName = 'context') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDocumentReference.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'masterIdentifier') then MasterIdentifierElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'docStatus') then DocStatusElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'class') then Class_Element := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'indexed') then IndexedElement := nil
  else if (propName = 'author') then deletePropertyValue('author', AuthorList, value) {2}
  else if (propName = 'authenticator') then AuthenticatorElement := nil
  else if (propName = 'custodian') then CustodianElement := nil
  else if (propName = 'relatesTo') then deletePropertyValue('relatesTo', RelatesToList, value) {2}
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'securityLabel') then deletePropertyValue('securityLabel', SecurityLabelList, value) {2}
  else if (propName = 'content') then deletePropertyValue('content', ContentList, value) {2}
  else if (propName = 'context') then ContextElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDocumentReference.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'masterIdentifier') then MasterIdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirDocumentReferenceStatusEnum, CODES_TFhirDocumentReferenceStatusEnum, new){4}
  else if (propName = 'docStatus') then DocStatusElement := asEnum(SYSTEMS_TFhirCompositionStatusEnum, CODES_TFhirCompositionStatusEnum, new){4}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'class') then Class_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'created') then CreatedElement := asDateTime(new){5b}
  else if (propName = 'indexed') then IndexedElement := asInstant(new){5b}
  else if (propName = 'author') then replacePropertyValue('author', AuthorList, existing, new) {2}
  else if (propName = 'authenticator') then AuthenticatorElement := new as TFhirReference{Resource}{4}
  else if (propName = 'custodian') then CustodianElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'relatesTo') then replacePropertyValue('relatesTo', RelatesToList, existing, new) {2}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'securityLabel') then replacePropertyValue('securityLabel', SecurityLabelList, existing, new) {2}
  else if (propName = 'content') then replacePropertyValue('content', ContentList, existing, new) {2}
  else if (propName = 'context') then ContextElement := new as TFhirDocumentReferenceContext{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDocumentReference.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'author') then AuthorList.move(source, destination){2a}
  else if (propName = 'relatesTo') then RelatesToList.move(source, destination){2a}
  else if (propName = 'securityLabel') then SecurityLabelList.move(source, destination){2a}
  else if (propName = 'content') then ContentList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDocumentReference.fhirType : string;
begin
  result := 'DocumentReference';
end;

function TFhirDocumentReference.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMasterIdentifier) and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FDocStatus) and isEmptyProp(FType_) and isEmptyProp(FClass_) and isEmptyProp(FSubject) and isEmptyProp(FCreated) and isEmptyProp(FIndexed) and isEmptyProp(FauthorList) and isEmptyProp(FAuthenticator) and isEmptyProp(FCustodian) and isEmptyProp(FrelatesToList) and isEmptyProp(FDescription) and isEmptyProp(FsecurityLabelList) and isEmptyProp(FcontentList) and isEmptyProp(FContext);
end;

function TFhirDocumentReference.equals(other : TObject) : boolean;
var
  o : TFhirDocumentReference;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDocumentReference)) then
    result := false
  else
  begin
    o := TFhirDocumentReference(other);
    result := compareDeep(masterIdentifierElement, o.masterIdentifierElement, true) and
      compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(docStatusElement, o.docStatusElement, true) and compareDeep(type_Element, o.type_Element, true) and
      compareDeep(class_Element, o.class_Element, true) and compareDeep(subjectElement, o.subjectElement, true) and
      compareDeep(createdElement, o.createdElement, true) and compareDeep(indexedElement, o.indexedElement, true) and
      compareDeep(authorList, o.authorList, true) and compareDeep(authenticatorElement, o.authenticatorElement, true) and
      compareDeep(custodianElement, o.custodianElement, true) and compareDeep(relatesToList, o.relatesToList, true) and
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(securityLabelList, o.securityLabelList, true) and
      compareDeep(contentList, o.contentList, true) and compareDeep(contextElement, o.contextElement, true);
  end;
end;

function TFhirDocumentReference.Link : TFhirDocumentReference;
begin
  result := TFhirDocumentReference(inherited Link);
end;

function TFhirDocumentReference.Clone : TFhirDocumentReference;
begin
  result := TFhirDocumentReference(inherited Clone);
end;

procedure TFhirDocumentReference.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('masterIdentifier');
  fields.add('identifier');
  fields.add('status');
  fields.add('docStatus');
  fields.add('type');
  fields.add('class');
  fields.add('subject');
  fields.add('created');
  fields.add('indexed');
  fields.add('author');
  fields.add('authenticator');
  fields.add('custodian');
  fields.add('relatesTo');
  fields.add('description');
  fields.add('securityLabel');
  fields.add('content');
  fields.add('context');
end;

{ TFhirDocumentReference }

Procedure TFhirDocumentReference.SetMasterIdentifier(value : TFhirIdentifier);
begin
  FMasterIdentifier.free;
  FMasterIdentifier := value;
end;

Function TFhirDocumentReference.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirDocumentReference.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirDocumentReference.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirDocumentReference.GetStatusST : TFhirDocumentReferenceStatusEnum;
begin
  if FStatus = nil then
    result := TFhirDocumentReferenceStatusEnum(0)
  else
    result := TFhirDocumentReferenceStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirDocumentReferenceStatusEnum, FStatus.value));
end;

Procedure TFhirDocumentReference.SetStatusST(value : TFhirDocumentReferenceStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirDocumentReferenceStatusEnum[value], CODES_TFhirDocumentReferenceStatusEnum[value]);
end;

Procedure TFhirDocumentReference.SetDocStatus(value : TFhirEnum);
begin
  FDocStatus.free;
  FDocStatus := value;
end;

Function TFhirDocumentReference.GetDocStatusST : TFhirCompositionStatusEnum;
begin
  if FDocStatus = nil then
    result := TFhirCompositionStatusEnum(0)
  else
    result := TFhirCompositionStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirCompositionStatusEnum, FDocStatus.value));
end;

Procedure TFhirDocumentReference.SetDocStatusST(value : TFhirCompositionStatusEnum);
begin
  if ord(value) = 0 then
    DocStatusElement := nil
  else
    DocStatusElement := TFhirEnum.create(SYSTEMS_TFhirCompositionStatusEnum[value], CODES_TFhirCompositionStatusEnum[value]);
end;

Procedure TFhirDocumentReference.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirDocumentReference.SetClass_(value : TFhirCodeableConcept);
begin
  FClass_.free;
  FClass_ := value;
end;

Procedure TFhirDocumentReference.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirDocumentReference.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

Function TFhirDocumentReference.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

Procedure TFhirDocumentReference.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

Procedure TFhirDocumentReference.SetIndexed(value : TFhirInstant);
begin
  FIndexed.free;
  FIndexed := value;
end;

Function TFhirDocumentReference.GetIndexedST : TFslDateTime;
begin
  if FIndexed = nil then
    result := TFslDateTime.makeNull
  else
    result := FIndexed.value;
end;

Procedure TFhirDocumentReference.SetIndexedST(value : TFslDateTime);
begin
  if FIndexed = nil then
    FIndexed := TFhirInstant.create;
  FIndexed.value := value
end;

Function TFhirDocumentReference.GetAuthorList : TFhirReferenceList{Resource};
begin
  if FAuthorList = nil then
    FAuthorList := TFhirReferenceList{Resource}.Create;
  result := FAuthorList;
end;

Function TFhirDocumentReference.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

Procedure TFhirDocumentReference.SetAuthenticator(value : TFhirReference{Resource});
begin
  FAuthenticator.free;
  FAuthenticator := value;
end;

Procedure TFhirDocumentReference.SetCustodian(value : TFhirReference{TFhirOrganization});
begin
  FCustodian.free;
  FCustodian := value;
end;

Function TFhirDocumentReference.GetRelatesToList : TFhirDocumentReferenceRelatesToList;
begin
  if FRelatesToList = nil then
    FRelatesToList := TFhirDocumentReferenceRelatesToList.Create;
  result := FRelatesToList;
end;

Function TFhirDocumentReference.GetHasRelatesToList : boolean;
begin
  result := (FRelatesToList <> nil) and (FRelatesToList.count > 0);
end;

Procedure TFhirDocumentReference.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirDocumentReference.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirDocumentReference.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Function TFhirDocumentReference.GetSecurityLabelList : TFhirCodeableConceptList;
begin
  if FSecurityLabelList = nil then
    FSecurityLabelList := TFhirCodeableConceptList.Create;
  result := FSecurityLabelList;
end;

Function TFhirDocumentReference.GetHasSecurityLabelList : boolean;
begin
  result := (FSecurityLabelList <> nil) and (FSecurityLabelList.count > 0);
end;

Function TFhirDocumentReference.GetContentList : TFhirDocumentReferenceContentList;
begin
  if FContentList = nil then
    FContentList := TFhirDocumentReferenceContentList.Create;
  result := FContentList;
end;

Function TFhirDocumentReference.GetHasContentList : boolean;
begin
  result := (FContentList <> nil) and (FContentList.count > 0);
end;

Procedure TFhirDocumentReference.SetContext(value : TFhirDocumentReferenceContext);
begin
  FContext.free;
  FContext := value;
end;

function TFhirDocumentReference.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FMasterIdentifier.sizeInBytes);
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FDocStatus.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FClass_.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FCreated.sizeInBytes);
  inc(result, FIndexed.sizeInBytes);
  inc(result, FauthorList.sizeInBytes);
  inc(result, FAuthenticator.sizeInBytes);
  inc(result, FCustodian.sizeInBytes);
  inc(result, FrelatesToList.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FsecurityLabelList.sizeInBytes);
  inc(result, FcontentList.sizeInBytes);
  inc(result, FContext.sizeInBytes);
end;

{ TFhirDocumentReferenceListEnumerator }

Constructor TFhirDocumentReferenceListEnumerator.Create(list : TFhirDocumentReferenceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDocumentReferenceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDocumentReferenceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDocumentReferenceListEnumerator.GetCurrent : TFhirDocumentReference;
begin
  Result := FList[FIndex];
end;

function TFhirDocumentReferenceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDocumentReferenceList }
procedure TFhirDocumentReferenceList.AddItem(value: TFhirDocumentReference);
begin
  assert(value.ClassName = 'TFhirDocumentReference', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDocumentReference');
  add(value);
end;

function TFhirDocumentReferenceList.Append: TFhirDocumentReference;
begin
  result := TFhirDocumentReference.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentReferenceList.ClearItems;
begin
  Clear;
end;

function TFhirDocumentReferenceList.GetEnumerator : TFhirDocumentReferenceListEnumerator;
begin
  result := TFhirDocumentReferenceListEnumerator.Create(self.link);
end;

function TFhirDocumentReferenceList.Clone: TFhirDocumentReferenceList;
begin
  result := TFhirDocumentReferenceList(inherited Clone);
end;

function TFhirDocumentReferenceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDocumentReferenceList.GetItemN(index: Integer): TFhirDocumentReference;
begin
  result := TFhirDocumentReference(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceList.ItemClass: TFslObjectClass;
begin
  result := TFhirDocumentReference;
end;
function TFhirDocumentReferenceList.IndexOf(value: TFhirDocumentReference): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDocumentReferenceList.Insert(index: Integer): TFhirDocumentReference;
begin
  result := TFhirDocumentReference.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentReferenceList.InsertItem(index: Integer; value: TFhirDocumentReference);
begin
  assert(value is TFhirDocumentReference);
  Inherited Insert(index, value);
end;

function TFhirDocumentReferenceList.Item(index: Integer): TFhirDocumentReference;
begin
  result := TFhirDocumentReference(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceList.Link: TFhirDocumentReferenceList;
begin
  result := TFhirDocumentReferenceList(inherited Link);
end;

procedure TFhirDocumentReferenceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDocumentReferenceList.SetItemByIndex(index: Integer; value: TFhirDocumentReference);
begin
  assert(value is TFhirDocumentReference);
  FhirDocumentReferences[index] := value;
end;

procedure TFhirDocumentReferenceList.SetItemN(index: Integer; value: TFhirDocumentReference);
begin
  assert(value is TFhirDocumentReference);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_DOCUMENTREFERENCE}

{$IFDEF FHIR_FAMILYMEMBERHISTORY}

{ TFhirFamilyMemberHistoryCondition }

constructor TFhirFamilyMemberHistoryCondition.Create;
begin
  inherited;
end;

destructor TFhirFamilyMemberHistoryCondition.Destroy;
begin
  FCode.free;
  FOutcome.free;
  FOnset.free;
  FNoteList.Free;
  inherited;
end;

procedure TFhirFamilyMemberHistoryCondition.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirFamilyMemberHistoryCondition(oSource).code.Clone;
  outcome := TFhirFamilyMemberHistoryCondition(oSource).outcome.Clone;
  onset := TFhirFamilyMemberHistoryCondition(oSource).onset.Clone;
  if (TFhirFamilyMemberHistoryCondition(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirFamilyMemberHistoryCondition(oSource).FNoteList);
  end;
end;

procedure TFhirFamilyMemberHistoryCondition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'onset[x]') or (child_name = 'onset') Then
     list.add(self.link, 'onset[x]', FOnset.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirFamilyMemberHistoryCondition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'outcome', 'CodeableConcept', false, TFhirCodeableConcept, FOutcome.Link));{2}
  oList.add(TFHIRProperty.create(self, 'onset[x]', 'Age|Range|Period|string', false, TFhirType, FOnset.Link));{2}
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
end;

function TFhirFamilyMemberHistoryCondition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    Outcome := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'onset', ['Age', 'Range', 'Period', 'String'])) then
  begin
    Onset := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirFamilyMemberHistoryCondition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else inherited;
end;

function TFhirFamilyMemberHistoryCondition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'outcome') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'onset', ['Age', 'Range', 'Period', 'String'])) then raise EFHIRException.create('Cannot make property Onset'){4x}
  else if (propName = 'note') then result := NoteList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirFamilyMemberHistoryCondition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'outcome') then result := 'CodeableConcept'
  else if (propName = 'onset[x]') then result := 'Age|Range|Period|string'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirFamilyMemberHistoryCondition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (isMatchingName(propName, 'onset', ['Age', 'Range', 'Period', 'String'])) then OnsetElement := nil{4x}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirFamilyMemberHistoryCondition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'outcome') then OutcomeElement := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'onset', ['Age', 'Range', 'Period', 'String'])) then OnsetElement := new as TFhirType{4x}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirFamilyMemberHistoryCondition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'note') then NoteList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirFamilyMemberHistoryCondition.fhirType : string;
begin
  result := 'condition';
end;

function TFhirFamilyMemberHistoryCondition.Link : TFhirFamilyMemberHistoryCondition;
begin
  result := TFhirFamilyMemberHistoryCondition(inherited Link);
end;

function TFhirFamilyMemberHistoryCondition.Clone : TFhirFamilyMemberHistoryCondition;
begin
  result := TFhirFamilyMemberHistoryCondition(inherited Clone);
end;

function TFhirFamilyMemberHistoryCondition.equals(other : TObject) : boolean;
var
  o : TFhirFamilyMemberHistoryCondition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirFamilyMemberHistoryCondition)) then
    result := false
  else
  begin
    o := TFhirFamilyMemberHistoryCondition(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(outcomeElement, o.outcomeElement, true) and
      compareDeep(onsetElement, o.onsetElement, true) and compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirFamilyMemberHistoryCondition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FOutcome) and isEmptyProp(FOnset) and isEmptyProp(FnoteList);
end;

procedure TFhirFamilyMemberHistoryCondition.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('outcome');
  fields.add('onset[x]');
  fields.add('note');
end;

{ TFhirFamilyMemberHistoryCondition }

Procedure TFhirFamilyMemberHistoryCondition.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirFamilyMemberHistoryCondition.SetOutcome(value : TFhirCodeableConcept);
begin
  FOutcome.free;
  FOutcome := value;
end;

Procedure TFhirFamilyMemberHistoryCondition.SetOnset(value : TFhirType);
begin
  FOnset.free;
  FOnset := value;
end;

Function TFhirFamilyMemberHistoryCondition.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirFamilyMemberHistoryCondition.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirFamilyMemberHistoryCondition.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FOutcome.sizeInBytes);
  inc(result, FOnset.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
end;

{ TFhirFamilyMemberHistoryConditionListEnumerator }

Constructor TFhirFamilyMemberHistoryConditionListEnumerator.Create(list : TFhirFamilyMemberHistoryConditionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirFamilyMemberHistoryConditionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirFamilyMemberHistoryConditionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirFamilyMemberHistoryConditionListEnumerator.GetCurrent : TFhirFamilyMemberHistoryCondition;
begin
  Result := FList[FIndex];
end;

function TFhirFamilyMemberHistoryConditionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirFamilyMemberHistoryConditionList }
procedure TFhirFamilyMemberHistoryConditionList.AddItem(value: TFhirFamilyMemberHistoryCondition);
begin
  assert(value.ClassName = 'TFhirFamilyMemberHistoryCondition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirFamilyMemberHistoryCondition');
  add(value);
end;

function TFhirFamilyMemberHistoryConditionList.Append: TFhirFamilyMemberHistoryCondition;
begin
  result := TFhirFamilyMemberHistoryCondition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirFamilyMemberHistoryConditionList.ClearItems;
begin
  Clear;
end;

function TFhirFamilyMemberHistoryConditionList.GetEnumerator : TFhirFamilyMemberHistoryConditionListEnumerator;
begin
  result := TFhirFamilyMemberHistoryConditionListEnumerator.Create(self.link);
end;

function TFhirFamilyMemberHistoryConditionList.Clone: TFhirFamilyMemberHistoryConditionList;
begin
  result := TFhirFamilyMemberHistoryConditionList(inherited Clone);
end;

function TFhirFamilyMemberHistoryConditionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirFamilyMemberHistoryConditionList.GetItemN(index: Integer): TFhirFamilyMemberHistoryCondition;
begin
  result := TFhirFamilyMemberHistoryCondition(ObjectByIndex[index]);
end;

function TFhirFamilyMemberHistoryConditionList.ItemClass: TFslObjectClass;
begin
  result := TFhirFamilyMemberHistoryCondition;
end;
function TFhirFamilyMemberHistoryConditionList.IndexOf(value: TFhirFamilyMemberHistoryCondition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirFamilyMemberHistoryConditionList.Insert(index: Integer): TFhirFamilyMemberHistoryCondition;
begin
  result := TFhirFamilyMemberHistoryCondition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirFamilyMemberHistoryConditionList.InsertItem(index: Integer; value: TFhirFamilyMemberHistoryCondition);
begin
  assert(value is TFhirFamilyMemberHistoryCondition);
  Inherited Insert(index, value);
end;

function TFhirFamilyMemberHistoryConditionList.Item(index: Integer): TFhirFamilyMemberHistoryCondition;
begin
  result := TFhirFamilyMemberHistoryCondition(ObjectByIndex[index]);
end;

function TFhirFamilyMemberHistoryConditionList.Link: TFhirFamilyMemberHistoryConditionList;
begin
  result := TFhirFamilyMemberHistoryConditionList(inherited Link);
end;

procedure TFhirFamilyMemberHistoryConditionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirFamilyMemberHistoryConditionList.SetItemByIndex(index: Integer; value: TFhirFamilyMemberHistoryCondition);
begin
  assert(value is TFhirFamilyMemberHistoryCondition);
  FhirFamilyMemberHistoryConditions[index] := value;
end;

procedure TFhirFamilyMemberHistoryConditionList.SetItemN(index: Integer; value: TFhirFamilyMemberHistoryCondition);
begin
  assert(value is TFhirFamilyMemberHistoryCondition);
  ObjectByIndex[index] := value;
end;

{ TFhirFamilyMemberHistory }

constructor TFhirFamilyMemberHistory.Create;
begin
  inherited;
end;

destructor TFhirFamilyMemberHistory.Destroy;
begin
  FIdentifierList.Free;
  FDefinitionList.Free;
  FStatus.free;
  FNotDone.free;
  FNotDoneReason.free;
  FPatient.free;
  FDate.free;
  FName.free;
  FRelationship.free;
  FGender.free;
  FBorn.free;
  FAge.free;
  FEstimatedAge.free;
  FDeceased.free;
  FReasonCodeList.Free;
  FReasonReferenceList.Free;
  FNoteList.Free;
  FConditionList.Free;
  inherited;
end;

function TFhirFamilyMemberHistory.GetResourceType : TFhirResourceType;
begin
  result := frtFamilyMemberHistory;
end;

procedure TFhirFamilyMemberHistory.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirFamilyMemberHistory(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirFamilyMemberHistory(oSource).FIdentifierList);
  end;
  if (TFhirFamilyMemberHistory(oSource).FDefinitionList = nil) then
  begin
    FDefinitionList.free;
    FDefinitionList := nil;
  end
  else
  begin
    if FDefinitionList = nil then
      FDefinitionList := TFhirReferenceList{Resource}.Create;
    FDefinitionList.Assign(TFhirFamilyMemberHistory(oSource).FDefinitionList);
  end;
  FStatus := TFhirFamilyMemberHistory(oSource).FStatus.Link;
  notDoneElement := TFhirFamilyMemberHistory(oSource).notDoneElement.Clone;
  notDoneReason := TFhirFamilyMemberHistory(oSource).notDoneReason.Clone;
  patient := TFhirFamilyMemberHistory(oSource).patient.Clone;
  dateElement := TFhirFamilyMemberHistory(oSource).dateElement.Clone;
  nameElement := TFhirFamilyMemberHistory(oSource).nameElement.Clone;
  relationship := TFhirFamilyMemberHistory(oSource).relationship.Clone;
  FGender := TFhirFamilyMemberHistory(oSource).FGender.Link;
  born := TFhirFamilyMemberHistory(oSource).born.Clone;
  age := TFhirFamilyMemberHistory(oSource).age.Clone;
  estimatedAgeElement := TFhirFamilyMemberHistory(oSource).estimatedAgeElement.Clone;
  deceased := TFhirFamilyMemberHistory(oSource).deceased.Clone;
  if (TFhirFamilyMemberHistory(oSource).FReasonCodeList = nil) then
  begin
    FReasonCodeList.free;
    FReasonCodeList := nil;
  end
  else
  begin
    if FReasonCodeList = nil then
      FReasonCodeList := TFhirCodeableConceptList.Create;
    FReasonCodeList.Assign(TFhirFamilyMemberHistory(oSource).FReasonCodeList);
  end;
  if (TFhirFamilyMemberHistory(oSource).FReasonReferenceList = nil) then
  begin
    FReasonReferenceList.free;
    FReasonReferenceList := nil;
  end
  else
  begin
    if FReasonReferenceList = nil then
      FReasonReferenceList := TFhirReferenceList{Resource}.Create;
    FReasonReferenceList.Assign(TFhirFamilyMemberHistory(oSource).FReasonReferenceList);
  end;
  if (TFhirFamilyMemberHistory(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirFamilyMemberHistory(oSource).FNoteList);
  end;
  if (TFhirFamilyMemberHistory(oSource).FConditionList = nil) then
  begin
    FConditionList.free;
    FConditionList := nil;
  end
  else
  begin
    if FConditionList = nil then
      FConditionList := TFhirFamilyMemberHistoryConditionList.Create;
    FConditionList.Assign(TFhirFamilyMemberHistory(oSource).FConditionList);
  end;
end;

procedure TFhirFamilyMemberHistory.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'definition') Then
    list.addAll(self, 'definition', FDefinitionList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'notDone') Then
     list.add(self.link, 'notDone', FNotDone.Link);
  if (child_name = 'notDoneReason') Then
     list.add(self.link, 'notDoneReason', FNotDoneReason.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'relationship') Then
     list.add(self.link, 'relationship', FRelationship.Link);
  if (child_name = 'gender') Then
     list.add(self.link, 'gender', FGender.Link);
  if (child_name = 'born[x]') or (child_name = 'born') Then
     list.add(self.link, 'born[x]', FBorn.Link);
  if (child_name = 'age[x]') or (child_name = 'age') Then
     list.add(self.link, 'age[x]', FAge.Link);
  if (child_name = 'estimatedAge') Then
     list.add(self.link, 'estimatedAge', FEstimatedAge.Link);
  if (child_name = 'deceased[x]') or (child_name = 'deceased') Then
     list.add(self.link, 'deceased[x]', FDeceased.Link);
  if (child_name = 'reasonCode') Then
    list.addAll(self, 'reasonCode', FReasonCodeList);
  if (child_name = 'reasonReference') Then
    list.addAll(self, 'reasonReference', FReasonReferenceList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'condition') Then
    list.addAll(self, 'condition', FConditionList);
end;

procedure TFhirFamilyMemberHistory.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'definition', 'Reference(PlanDefinition|Questionnaire)', true, TFhirReference{Resource}, FDefinitionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'notDone', 'boolean', false, TFhirBoolean, FNotDone.Link));{2}
  oList.add(TFHIRProperty.create(self, 'notDoneReason', 'CodeableConcept', false, TFhirCodeableConcept, FNotDoneReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'relationship', 'CodeableConcept', false, TFhirCodeableConcept, FRelationship.Link));{2}
  oList.add(TFHIRProperty.create(self, 'gender', 'code', false, TFHIREnum, FGender.Link));{1}
  oList.add(TFHIRProperty.create(self, 'born[x]', 'Period|date|string', false, TFhirType, FBorn.Link));{2}
  oList.add(TFHIRProperty.create(self, 'age[x]', 'Age|Range|string', false, TFhirType, FAge.Link));{2}
  oList.add(TFHIRProperty.create(self, 'estimatedAge', 'boolean', false, TFhirBoolean, FEstimatedAge.Link));{2}
  oList.add(TFHIRProperty.create(self, 'deceased[x]', 'boolean|Age|Range|date|string', false, TFhirType, FDeceased.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reasonCode', 'CodeableConcept', true, TFhirCodeableConcept, FReasonCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reasonReference', 'Reference(Condition|Observation|AllergyIntolerance|QuestionnaireResponse)', true, TFhirReference{Resource}, FReasonReferenceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'condition', '', true, TFhirFamilyMemberHistoryCondition, FConditionList.Link)){3};
end;

function TFhirFamilyMemberHistory.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'definition') then
  begin
    DefinitionList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirHistoryStatusEnum, CODES_TFhirHistoryStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'notDone') then
  begin
    NotDoneElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'notDoneReason') then
  begin
    NotDoneReason := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'relationship') then
  begin
    Relationship := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'gender') then
  begin
    GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, propValue);
    result := propValue
  end
  else if (isMatchingName(propName, 'born', ['Period', 'Date', 'String'])) then
  begin
    Born := propValue as TFhirType{4};
    result := propValue;
  end
  else if (isMatchingName(propName, 'age', ['Age', 'Range', 'String'])) then
  begin
    Age := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'estimatedAge') then
  begin
    EstimatedAgeElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'deceased', ['Boolean', 'Age', 'Range', 'Date', 'String'])) then
  begin
    Deceased := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'reasonCode') then
  begin
    ReasonCodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'reasonReference') then
  begin
    ReasonReferenceList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else if (propName = 'condition') then
  begin
    ConditionList.add(propValue as TFhirFamilyMemberHistoryCondition){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirFamilyMemberHistory.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'definition') then DefinitionList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'reasonCode') then ReasonCodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'reasonReference') then ReasonReferenceList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else if (propName = 'condition') then ConditionList.insertItem(index, propValue as TFhirFamilyMemberHistoryCondition){2a}
  else inherited;
end;

function TFhirFamilyMemberHistory.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'definition') then result := DefinitionList.new(){2}
  else if (propName = 'notDone') then result := TFhirBoolean.create() {5b}
  else if (propName = 'notDoneReason') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'relationship') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'born', ['Period', 'Date', 'String'])) then raise EFHIRException.create('Cannot make property Born'){4x}
  else if (isMatchingName(propName, 'age', ['Age', 'Range', 'String'])) then raise EFHIRException.create('Cannot make property Age'){4x}
  else if (propName = 'estimatedAge') then result := TFhirBoolean.create() {5b}
  else if (isMatchingName(propName, 'deceased', ['Boolean', 'Age', 'Range', 'Date', 'String'])) then raise EFHIRException.create('Cannot make property Deceased'){4x}
  else if (propName = 'reasonCode') then result := ReasonCodeList.new(){2}
  else if (propName = 'reasonReference') then result := ReasonReferenceList.new(){2}
  else if (propName = 'note') then result := NoteList.new(){2}
  else if (propName = 'condition') then result := ConditionList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirFamilyMemberHistory.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'definition') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'notDone') then result := 'boolean'
  else if (propName = 'notDoneReason') then result := 'CodeableConcept'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'relationship') then result := 'CodeableConcept'
  else if (propName = 'gender') then result := 'code'
  else if (propName = 'born[x]') then result := 'Period|date|string'
  else if (propName = 'age[x]') then result := 'Age|Range|string'
  else if (propName = 'estimatedAge') then result := 'boolean'
  else if (propName = 'deceased[x]') then result := 'boolean|Age|Range|date|string'
  else if (propName = 'reasonCode') then result := 'CodeableConcept'
  else if (propName = 'reasonReference') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'condition') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirFamilyMemberHistory.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'definition') then deletePropertyValue('definition', DefinitionList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'notDone') then NotDoneElement := nil
  else if (propName = 'notDoneReason') then NotDoneReasonElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'relationship') then RelationshipElement := nil
  else if (propName = 'gender') then GenderElement := nil
  else if (isMatchingName(propName, 'born', ['Period', 'Date', 'String'])) then BornElement := nil{4x}
  else if (isMatchingName(propName, 'age', ['Age', 'Range', 'String'])) then AgeElement := nil{4x}
  else if (propName = 'estimatedAge') then EstimatedAgeElement := nil
  else if (isMatchingName(propName, 'deceased', ['Boolean', 'Age', 'Range', 'Date', 'String'])) then DeceasedElement := nil{4x}
  else if (propName = 'reasonCode') then deletePropertyValue('reasonCode', ReasonCodeList, value) {2}
  else if (propName = 'reasonReference') then deletePropertyValue('reasonReference', ReasonReferenceList, value) {2}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else if (propName = 'condition') then deletePropertyValue('condition', ConditionList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirFamilyMemberHistory.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'definition') then replacePropertyValue('definition', DefinitionList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirHistoryStatusEnum, CODES_TFhirHistoryStatusEnum, new){4}
  else if (propName = 'notDone') then NotDoneElement := asBoolean(new){5b}
  else if (propName = 'notDoneReason') then NotDoneReasonElement := new as TFhirCodeableConcept{4}
  else if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'relationship') then RelationshipElement := new as TFhirCodeableConcept{4}
  else if (propName = 'gender') then GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, new){4}
  else if (isMatchingName(propName, 'born', ['Period', 'Date', 'String'])) then BornElement := new as TFhirType{4x}
  else if (isMatchingName(propName, 'age', ['Age', 'Range', 'String'])) then AgeElement := new as TFhirType{4x}
  else if (propName = 'estimatedAge') then EstimatedAgeElement := asBoolean(new){5b}
  else if (isMatchingName(propName, 'deceased', ['Boolean', 'Age', 'Range', 'Date', 'String'])) then DeceasedElement := new as TFhirType{4x}
  else if (propName = 'reasonCode') then replacePropertyValue('reasonCode', ReasonCodeList, existing, new) {2}
  else if (propName = 'reasonReference') then replacePropertyValue('reasonReference', ReasonReferenceList, existing, new) {2}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else if (propName = 'condition') then replacePropertyValue('condition', ConditionList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirFamilyMemberHistory.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'definition') then DefinitionList.move(source, destination){2a}
  else if (propName = 'reasonCode') then ReasonCodeList.move(source, destination){2a}
  else if (propName = 'reasonReference') then ReasonReferenceList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else if (propName = 'condition') then ConditionList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirFamilyMemberHistory.fhirType : string;
begin
  result := 'FamilyMemberHistory';
end;

function TFhirFamilyMemberHistory.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FdefinitionList) and isEmptyProp(FStatus) and isEmptyProp(FNotDone) and isEmptyProp(FNotDoneReason) and isEmptyProp(FPatient) and isEmptyProp(FDate) and isEmptyProp(FName) and isEmptyProp(FRelationship) and isEmptyProp(FGender) and isEmptyProp(FBorn) and isEmptyProp(FAge) and isEmptyProp(FEstimatedAge) and isEmptyProp(FDeceased) and isEmptyProp(FreasonCodeList) and isEmptyProp(FreasonReferenceList) and isEmptyProp(FnoteList) and isEmptyProp(FconditionList);
end;

function TFhirFamilyMemberHistory.equals(other : TObject) : boolean;
var
  o : TFhirFamilyMemberHistory;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirFamilyMemberHistory)) then
    result := false
  else
  begin
    o := TFhirFamilyMemberHistory(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(definitionList, o.definitionList, true) and
      compareDeep(statusElement, o.statusElement, true) and compareDeep(notDoneElement, o.notDoneElement, true) and
      compareDeep(notDoneReasonElement, o.notDoneReasonElement, true) and compareDeep(patientElement, o.patientElement, true) and
      compareDeep(dateElement, o.dateElement, true) and compareDeep(nameElement, o.nameElement, true) and
      compareDeep(relationshipElement, o.relationshipElement, true) and compareDeep(genderElement, o.genderElement, true) and
      compareDeep(bornElement, o.bornElement, true) and compareDeep(ageElement, o.ageElement, true) and
      compareDeep(estimatedAgeElement, o.estimatedAgeElement, true) and compareDeep(deceasedElement, o.deceasedElement, true) and
      compareDeep(reasonCodeList, o.reasonCodeList, true) and compareDeep(reasonReferenceList, o.reasonReferenceList, true) and
      compareDeep(noteList, o.noteList, true) and compareDeep(conditionList, o.conditionList, true);
  end;
end;

function TFhirFamilyMemberHistory.Link : TFhirFamilyMemberHistory;
begin
  result := TFhirFamilyMemberHistory(inherited Link);
end;

function TFhirFamilyMemberHistory.Clone : TFhirFamilyMemberHistory;
begin
  result := TFhirFamilyMemberHistory(inherited Clone);
end;

procedure TFhirFamilyMemberHistory.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('definition');
  fields.add('status');
  fields.add('notDone');
  fields.add('notDoneReason');
  fields.add('patient');
  fields.add('date');
  fields.add('name');
  fields.add('relationship');
  fields.add('gender');
  fields.add('born[x]');
  fields.add('age[x]');
  fields.add('estimatedAge');
  fields.add('deceased[x]');
  fields.add('reasonCode');
  fields.add('reasonReference');
  fields.add('note');
  fields.add('condition');
end;

{ TFhirFamilyMemberHistory }

Function TFhirFamilyMemberHistory.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirFamilyMemberHistory.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Function TFhirFamilyMemberHistory.GetDefinitionList : TFhirReferenceList{Resource};
begin
  if FDefinitionList = nil then
    FDefinitionList := TFhirReferenceList{Resource}.Create;
  result := FDefinitionList;
end;

Function TFhirFamilyMemberHistory.GetHasDefinitionList : boolean;
begin
  result := (FDefinitionList <> nil) and (FDefinitionList.count > 0);
end;

Procedure TFhirFamilyMemberHistory.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirFamilyMemberHistory.GetStatusST : TFhirHistoryStatusEnum;
begin
  if FStatus = nil then
    result := TFhirHistoryStatusEnum(0)
  else
    result := TFhirHistoryStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirHistoryStatusEnum, FStatus.value));
end;

Procedure TFhirFamilyMemberHistory.SetStatusST(value : TFhirHistoryStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirHistoryStatusEnum[value], CODES_TFhirHistoryStatusEnum[value]);
end;

Procedure TFhirFamilyMemberHistory.SetNotDone(value : TFhirBoolean);
begin
  FNotDone.free;
  FNotDone := value;
end;

Function TFhirFamilyMemberHistory.GetNotDoneST : Boolean;
begin
  if FNotDone = nil then
    result := false
  else
    result := FNotDone.value;
end;

Procedure TFhirFamilyMemberHistory.SetNotDoneST(value : Boolean);
begin
  if FNotDone = nil then
    FNotDone := TFhirBoolean.create;
  FNotDone.value := value
end;

Procedure TFhirFamilyMemberHistory.SetNotDoneReason(value : TFhirCodeableConcept);
begin
  FNotDoneReason.free;
  FNotDoneReason := value;
end;

Procedure TFhirFamilyMemberHistory.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Procedure TFhirFamilyMemberHistory.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirFamilyMemberHistory.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirFamilyMemberHistory.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirFamilyMemberHistory.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirFamilyMemberHistory.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirFamilyMemberHistory.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirFamilyMemberHistory.SetRelationship(value : TFhirCodeableConcept);
begin
  FRelationship.free;
  FRelationship := value;
end;

Procedure TFhirFamilyMemberHistory.SetGender(value : TFhirEnum);
begin
  FGender.free;
  FGender := value;
end;

Function TFhirFamilyMemberHistory.GetGenderST : TFhirAdministrativeGenderEnum;
begin
  if FGender = nil then
    result := TFhirAdministrativeGenderEnum(0)
  else
    result := TFhirAdministrativeGenderEnum(StringArrayIndexOfSensitive(CODES_TFhirAdministrativeGenderEnum, FGender.value));
end;

Procedure TFhirFamilyMemberHistory.SetGenderST(value : TFhirAdministrativeGenderEnum);
begin
  if ord(value) = 0 then
    GenderElement := nil
  else
    GenderElement := TFhirEnum.create(SYSTEMS_TFhirAdministrativeGenderEnum[value], CODES_TFhirAdministrativeGenderEnum[value]);
end;

Procedure TFhirFamilyMemberHistory.SetBorn(value : TFhirType);
begin
  FBorn.free;
  FBorn := value;
end;

Procedure TFhirFamilyMemberHistory.SetAge(value : TFhirType);
begin
  FAge.free;
  FAge := value;
end;

Procedure TFhirFamilyMemberHistory.SetEstimatedAge(value : TFhirBoolean);
begin
  FEstimatedAge.free;
  FEstimatedAge := value;
end;

Function TFhirFamilyMemberHistory.GetEstimatedAgeST : Boolean;
begin
  if FEstimatedAge = nil then
    result := false
  else
    result := FEstimatedAge.value;
end;

Procedure TFhirFamilyMemberHistory.SetEstimatedAgeST(value : Boolean);
begin
  if FEstimatedAge = nil then
    FEstimatedAge := TFhirBoolean.create;
  FEstimatedAge.value := value
end;

Procedure TFhirFamilyMemberHistory.SetDeceased(value : TFhirType);
begin
  FDeceased.free;
  FDeceased := value;
end;

Function TFhirFamilyMemberHistory.GetReasonCodeList : TFhirCodeableConceptList;
begin
  if FReasonCodeList = nil then
    FReasonCodeList := TFhirCodeableConceptList.Create;
  result := FReasonCodeList;
end;

Function TFhirFamilyMemberHistory.GetHasReasonCodeList : boolean;
begin
  result := (FReasonCodeList <> nil) and (FReasonCodeList.count > 0);
end;

Function TFhirFamilyMemberHistory.GetReasonReferenceList : TFhirReferenceList{Resource};
begin
  if FReasonReferenceList = nil then
    FReasonReferenceList := TFhirReferenceList{Resource}.Create;
  result := FReasonReferenceList;
end;

Function TFhirFamilyMemberHistory.GetHasReasonReferenceList : boolean;
begin
  result := (FReasonReferenceList <> nil) and (FReasonReferenceList.count > 0);
end;

Function TFhirFamilyMemberHistory.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirFamilyMemberHistory.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

Function TFhirFamilyMemberHistory.GetConditionList : TFhirFamilyMemberHistoryConditionList;
begin
  if FConditionList = nil then
    FConditionList := TFhirFamilyMemberHistoryConditionList.Create;
  result := FConditionList;
end;

Function TFhirFamilyMemberHistory.GetHasConditionList : boolean;
begin
  result := (FConditionList <> nil) and (FConditionList.count > 0);
end;

function TFhirFamilyMemberHistory.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FdefinitionList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FNotDone.sizeInBytes);
  inc(result, FNotDoneReason.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FRelationship.sizeInBytes);
  inc(result, FGender.sizeInBytes);
  inc(result, FBorn.sizeInBytes);
  inc(result, FAge.sizeInBytes);
  inc(result, FEstimatedAge.sizeInBytes);
  inc(result, FDeceased.sizeInBytes);
  inc(result, FreasonCodeList.sizeInBytes);
  inc(result, FreasonReferenceList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FconditionList.sizeInBytes);
end;

{ TFhirFamilyMemberHistoryListEnumerator }

Constructor TFhirFamilyMemberHistoryListEnumerator.Create(list : TFhirFamilyMemberHistoryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirFamilyMemberHistoryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirFamilyMemberHistoryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirFamilyMemberHistoryListEnumerator.GetCurrent : TFhirFamilyMemberHistory;
begin
  Result := FList[FIndex];
end;

function TFhirFamilyMemberHistoryListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirFamilyMemberHistoryList }
procedure TFhirFamilyMemberHistoryList.AddItem(value: TFhirFamilyMemberHistory);
begin
  assert(value.ClassName = 'TFhirFamilyMemberHistory', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirFamilyMemberHistory');
  add(value);
end;

function TFhirFamilyMemberHistoryList.Append: TFhirFamilyMemberHistory;
begin
  result := TFhirFamilyMemberHistory.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirFamilyMemberHistoryList.ClearItems;
begin
  Clear;
end;

function TFhirFamilyMemberHistoryList.GetEnumerator : TFhirFamilyMemberHistoryListEnumerator;
begin
  result := TFhirFamilyMemberHistoryListEnumerator.Create(self.link);
end;

function TFhirFamilyMemberHistoryList.Clone: TFhirFamilyMemberHistoryList;
begin
  result := TFhirFamilyMemberHistoryList(inherited Clone);
end;

function TFhirFamilyMemberHistoryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirFamilyMemberHistoryList.GetItemN(index: Integer): TFhirFamilyMemberHistory;
begin
  result := TFhirFamilyMemberHistory(ObjectByIndex[index]);
end;

function TFhirFamilyMemberHistoryList.ItemClass: TFslObjectClass;
begin
  result := TFhirFamilyMemberHistory;
end;
function TFhirFamilyMemberHistoryList.IndexOf(value: TFhirFamilyMemberHistory): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirFamilyMemberHistoryList.Insert(index: Integer): TFhirFamilyMemberHistory;
begin
  result := TFhirFamilyMemberHistory.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirFamilyMemberHistoryList.InsertItem(index: Integer; value: TFhirFamilyMemberHistory);
begin
  assert(value is TFhirFamilyMemberHistory);
  Inherited Insert(index, value);
end;

function TFhirFamilyMemberHistoryList.Item(index: Integer): TFhirFamilyMemberHistory;
begin
  result := TFhirFamilyMemberHistory(ObjectByIndex[index]);
end;

function TFhirFamilyMemberHistoryList.Link: TFhirFamilyMemberHistoryList;
begin
  result := TFhirFamilyMemberHistoryList(inherited Link);
end;

procedure TFhirFamilyMemberHistoryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirFamilyMemberHistoryList.SetItemByIndex(index: Integer; value: TFhirFamilyMemberHistory);
begin
  assert(value is TFhirFamilyMemberHistory);
  FhirFamilyMemberHistories[index] := value;
end;

procedure TFhirFamilyMemberHistoryList.SetItemN(index: Integer; value: TFhirFamilyMemberHistory);
begin
  assert(value is TFhirFamilyMemberHistory);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_FAMILYMEMBERHISTORY}

{$IFDEF FHIR_FLAG}

{ TFhirFlag }

constructor TFhirFlag.Create;
begin
  inherited;
end;

destructor TFhirFlag.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FCategory.free;
  FCode.free;
  FSubject.free;
  FPeriod.free;
  FEncounter.free;
  FAuthor.free;
  inherited;
end;

function TFhirFlag.GetResourceType : TFhirResourceType;
begin
  result := frtFlag;
end;

procedure TFhirFlag.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirFlag(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirFlag(oSource).FIdentifierList);
  end;
  FStatus := TFhirFlag(oSource).FStatus.Link;
  category := TFhirFlag(oSource).category.Clone;
  code := TFhirFlag(oSource).code.Clone;
  subject := TFhirFlag(oSource).subject.Clone;
  period := TFhirFlag(oSource).period.Clone;
  encounter := TFhirFlag(oSource).encounter.Clone;
  author := TFhirFlag(oSource).author.Clone;
end;

procedure TFhirFlag.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
end;

procedure TFhirFlag.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Location|Group|Organization|Practitioner|PlanDefinition|Medication|Procedure)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference(Encounter)', false, TFhirReference{TFhirEncounter}, FEncounter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'author', 'Reference(Device|Organization|Patient|Practitioner)', false, TFhirReference{Resource}, FAuthor.Link));{2}
end;

function TFhirFlag.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFlagStatusEnum, CODES_TFhirFlagStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference{TFhirEncounter}{4b};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirFlag.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else inherited;
end;

function TFhirFlag.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'period') then result := TFhirPeriod.create(){4b}
  else if (propName = 'encounter') then result := TFhirReference{TFhirEncounter}.create(){4b}
  else if (propName = 'author') then result := TFhirReference{Resource}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirFlag.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'author') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirFlag.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'author') then AuthorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirFlag.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFlagStatusEnum, CODES_TFhirFlagStatusEnum, new){4}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference{TFhirEncounter}{4}
  else if (propName = 'author') then AuthorElement := new as TFhirReference{Resource}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirFlag.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirFlag.fhirType : string;
begin
  result := 'Flag';
end;

function TFhirFlag.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FCategory) and isEmptyProp(FCode) and isEmptyProp(FSubject) and isEmptyProp(FPeriod) and isEmptyProp(FEncounter) and isEmptyProp(FAuthor);
end;

function TFhirFlag.equals(other : TObject) : boolean;
var
  o : TFhirFlag;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirFlag)) then
    result := false
  else
  begin
    o := TFhirFlag(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(categoryElement, o.categoryElement, true) and compareDeep(codeElement, o.codeElement, true) and
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(periodElement, o.periodElement, true) and
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(authorElement, o.authorElement, true);
  end;
end;

function TFhirFlag.Link : TFhirFlag;
begin
  result := TFhirFlag(inherited Link);
end;

function TFhirFlag.Clone : TFhirFlag;
begin
  result := TFhirFlag(inherited Clone);
end;

procedure TFhirFlag.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('category');
  fields.add('code');
  fields.add('subject');
  fields.add('period');
  fields.add('encounter');
  fields.add('author');
end;

{ TFhirFlag }

Function TFhirFlag.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirFlag.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirFlag.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirFlag.GetStatusST : TFhirFlagStatusEnum;
begin
  if FStatus = nil then
    result := TFhirFlagStatusEnum(0)
  else
    result := TFhirFlagStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirFlagStatusEnum, FStatus.value));
end;

Procedure TFhirFlag.SetStatusST(value : TFhirFlagStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFlagStatusEnum[value], CODES_TFhirFlagStatusEnum[value]);
end;

Procedure TFhirFlag.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirFlag.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirFlag.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirFlag.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

Procedure TFhirFlag.SetEncounter(value : TFhirReference{TFhirEncounter});
begin
  FEncounter.free;
  FEncounter := value;
end;

Procedure TFhirFlag.SetAuthor(value : TFhirReference{Resource});
begin
  FAuthor.free;
  FAuthor := value;
end;

function TFhirFlag.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FAuthor.sizeInBytes);
end;

{ TFhirFlagListEnumerator }

Constructor TFhirFlagListEnumerator.Create(list : TFhirFlagList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirFlagListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirFlagListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirFlagListEnumerator.GetCurrent : TFhirFlag;
begin
  Result := FList[FIndex];
end;

function TFhirFlagListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirFlagList }
procedure TFhirFlagList.AddItem(value: TFhirFlag);
begin
  assert(value.ClassName = 'TFhirFlag', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirFlag');
  add(value);
end;

function TFhirFlagList.Append: TFhirFlag;
begin
  result := TFhirFlag.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirFlagList.ClearItems;
begin
  Clear;
end;

function TFhirFlagList.GetEnumerator : TFhirFlagListEnumerator;
begin
  result := TFhirFlagListEnumerator.Create(self.link);
end;

function TFhirFlagList.Clone: TFhirFlagList;
begin
  result := TFhirFlagList(inherited Clone);
end;

function TFhirFlagList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirFlagList.GetItemN(index: Integer): TFhirFlag;
begin
  result := TFhirFlag(ObjectByIndex[index]);
end;

function TFhirFlagList.ItemClass: TFslObjectClass;
begin
  result := TFhirFlag;
end;
function TFhirFlagList.IndexOf(value: TFhirFlag): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirFlagList.Insert(index: Integer): TFhirFlag;
begin
  result := TFhirFlag.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirFlagList.InsertItem(index: Integer; value: TFhirFlag);
begin
  assert(value is TFhirFlag);
  Inherited Insert(index, value);
end;

function TFhirFlagList.Item(index: Integer): TFhirFlag;
begin
  result := TFhirFlag(ObjectByIndex[index]);
end;

function TFhirFlagList.Link: TFhirFlagList;
begin
  result := TFhirFlagList(inherited Link);
end;

procedure TFhirFlagList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirFlagList.SetItemByIndex(index: Integer; value: TFhirFlag);
begin
  assert(value is TFhirFlag);
  FhirFlags[index] := value;
end;

procedure TFhirFlagList.SetItemN(index: Integer; value: TFhirFlag);
begin
  assert(value is TFhirFlag);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_FLAG}

{$IFDEF FHIR_GOAL}

{ TFhirGoalTarget }

constructor TFhirGoalTarget.Create;
begin
  inherited;
end;

destructor TFhirGoalTarget.Destroy;
begin
  FMeasure.free;
  FDetail.free;
  FDue.free;
  inherited;
end;

procedure TFhirGoalTarget.Assign(oSource : TFslObject);
begin
  inherited;
  measure := TFhirGoalTarget(oSource).measure.Clone;
  detail := TFhirGoalTarget(oSource).detail.Clone;
  due := TFhirGoalTarget(oSource).due.Clone;
end;

procedure TFhirGoalTarget.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'measure') Then
     list.add(self.link, 'measure', FMeasure.Link);
  if (child_name = 'detail[x]') or (child_name = 'detail') Then
     list.add(self.link, 'detail[x]', FDetail.Link);
  if (child_name = 'due[x]') or (child_name = 'due') Then
     list.add(self.link, 'due[x]', FDue.Link);
end;

procedure TFhirGoalTarget.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'measure', 'CodeableConcept', false, TFhirCodeableConcept, FMeasure.Link));{2}
  oList.add(TFHIRProperty.create(self, 'detail[x]', 'Quantity|Range|CodeableConcept', false, TFhirType, FDetail.Link));{2}
  oList.add(TFHIRProperty.create(self, 'due[x]', 'date|Duration', false, TFhirType, FDue.Link));{2}
end;

function TFhirGoalTarget.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'measure') then
  begin
    Measure := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'detail', ['Quantity', 'Range', 'CodeableConcept'])) then
  begin
    Detail := propValue as TFhirType{4};
    result := propValue;
  end
  else if (isMatchingName(propName, 'due', ['Date', 'Duration'])) then
  begin
    Due := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirGoalTarget.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirGoalTarget.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'measure') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'detail', ['Quantity', 'Range', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property Detail'){4x}
  else if (isMatchingName(propName, 'due', ['Date', 'Duration'])) then raise EFHIRException.create('Cannot make property Due'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirGoalTarget.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'measure') then result := 'CodeableConcept'
  else if (propName = 'detail[x]') then result := 'Quantity|Range|CodeableConcept'
  else if (propName = 'due[x]') then result := 'date|Duration'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirGoalTarget.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'measure') then MeasureElement := nil
  else if (isMatchingName(propName, 'detail', ['Quantity', 'Range', 'CodeableConcept'])) then DetailElement := nil{4x}
  else if (isMatchingName(propName, 'due', ['Date', 'Duration'])) then DueElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirGoalTarget.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'measure') then MeasureElement := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'detail', ['Quantity', 'Range', 'CodeableConcept'])) then DetailElement := new as TFhirType{4x}
  else if (isMatchingName(propName, 'due', ['Date', 'Duration'])) then DueElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirGoalTarget.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirGoalTarget.fhirType : string;
begin
  result := 'target';
end;

function TFhirGoalTarget.Link : TFhirGoalTarget;
begin
  result := TFhirGoalTarget(inherited Link);
end;

function TFhirGoalTarget.Clone : TFhirGoalTarget;
begin
  result := TFhirGoalTarget(inherited Clone);
end;

function TFhirGoalTarget.equals(other : TObject) : boolean;
var
  o : TFhirGoalTarget;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirGoalTarget)) then
    result := false
  else
  begin
    o := TFhirGoalTarget(other);
    result := compareDeep(measureElement, o.measureElement, true) and compareDeep(detailElement, o.detailElement, true) and
      compareDeep(dueElement, o.dueElement, true);
  end;
end;

function TFhirGoalTarget.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMeasure) and isEmptyProp(FDetail) and isEmptyProp(FDue);
end;

procedure TFhirGoalTarget.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('measure');
  fields.add('detail[x]');
  fields.add('due[x]');
end;

{ TFhirGoalTarget }

Procedure TFhirGoalTarget.SetMeasure(value : TFhirCodeableConcept);
begin
  FMeasure.free;
  FMeasure := value;
end;

Procedure TFhirGoalTarget.SetDetail(value : TFhirType);
begin
  FDetail.free;
  FDetail := value;
end;

Procedure TFhirGoalTarget.SetDue(value : TFhirType);
begin
  FDue.free;
  FDue := value;
end;

function TFhirGoalTarget.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FMeasure.sizeInBytes);
  inc(result, FDetail.sizeInBytes);
  inc(result, FDue.sizeInBytes);
end;

{ TFhirGoalTargetListEnumerator }

Constructor TFhirGoalTargetListEnumerator.Create(list : TFhirGoalTargetList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirGoalTargetListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirGoalTargetListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirGoalTargetListEnumerator.GetCurrent : TFhirGoalTarget;
begin
  Result := FList[FIndex];
end;

function TFhirGoalTargetListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirGoalTargetList }
procedure TFhirGoalTargetList.AddItem(value: TFhirGoalTarget);
begin
  assert(value.ClassName = 'TFhirGoalTarget', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirGoalTarget');
  add(value);
end;

function TFhirGoalTargetList.Append: TFhirGoalTarget;
begin
  result := TFhirGoalTarget.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGoalTargetList.ClearItems;
begin
  Clear;
end;

function TFhirGoalTargetList.GetEnumerator : TFhirGoalTargetListEnumerator;
begin
  result := TFhirGoalTargetListEnumerator.Create(self.link);
end;

function TFhirGoalTargetList.Clone: TFhirGoalTargetList;
begin
  result := TFhirGoalTargetList(inherited Clone);
end;

function TFhirGoalTargetList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirGoalTargetList.GetItemN(index: Integer): TFhirGoalTarget;
begin
  result := TFhirGoalTarget(ObjectByIndex[index]);
end;

function TFhirGoalTargetList.ItemClass: TFslObjectClass;
begin
  result := TFhirGoalTarget;
end;
function TFhirGoalTargetList.IndexOf(value: TFhirGoalTarget): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirGoalTargetList.Insert(index: Integer): TFhirGoalTarget;
begin
  result := TFhirGoalTarget.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGoalTargetList.InsertItem(index: Integer; value: TFhirGoalTarget);
begin
  assert(value is TFhirGoalTarget);
  Inherited Insert(index, value);
end;

function TFhirGoalTargetList.Item(index: Integer): TFhirGoalTarget;
begin
  result := TFhirGoalTarget(ObjectByIndex[index]);
end;

function TFhirGoalTargetList.Link: TFhirGoalTargetList;
begin
  result := TFhirGoalTargetList(inherited Link);
end;

procedure TFhirGoalTargetList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirGoalTargetList.SetItemByIndex(index: Integer; value: TFhirGoalTarget);
begin
  assert(value is TFhirGoalTarget);
  FhirGoalTargets[index] := value;
end;

procedure TFhirGoalTargetList.SetItemN(index: Integer; value: TFhirGoalTarget);
begin
  assert(value is TFhirGoalTarget);
  ObjectByIndex[index] := value;
end;

{ TFhirGoal }

constructor TFhirGoal.Create;
begin
  inherited;
end;

destructor TFhirGoal.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FCategoryList.Free;
  FPriority.free;
  FDescription.free;
  FSubject.free;
  FStart.free;
  FTarget.free;
  FStatusDate.free;
  FStatusReason.free;
  FExpressedBy.free;
  FAddressesList.Free;
  FNoteList.Free;
  FOutcomeCodeList.Free;
  FOutcomeReferenceList.Free;
  inherited;
end;

function TFhirGoal.GetResourceType : TFhirResourceType;
begin
  result := frtGoal;
end;

procedure TFhirGoal.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirGoal(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirGoal(oSource).FIdentifierList);
  end;
  FStatus := TFhirGoal(oSource).FStatus.Link;
  if (TFhirGoal(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirGoal(oSource).FCategoryList);
  end;
  priority := TFhirGoal(oSource).priority.Clone;
  description := TFhirGoal(oSource).description.Clone;
  subject := TFhirGoal(oSource).subject.Clone;
  start := TFhirGoal(oSource).start.Clone;
  target := TFhirGoal(oSource).target.Clone;
  statusDateElement := TFhirGoal(oSource).statusDateElement.Clone;
  statusReasonElement := TFhirGoal(oSource).statusReasonElement.Clone;
  expressedBy := TFhirGoal(oSource).expressedBy.Clone;
  if (TFhirGoal(oSource).FAddressesList = nil) then
  begin
    FAddressesList.free;
    FAddressesList := nil;
  end
  else
  begin
    if FAddressesList = nil then
      FAddressesList := TFhirReferenceList{Resource}.Create;
    FAddressesList.Assign(TFhirGoal(oSource).FAddressesList);
  end;
  if (TFhirGoal(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirGoal(oSource).FNoteList);
  end;
  if (TFhirGoal(oSource).FOutcomeCodeList = nil) then
  begin
    FOutcomeCodeList.free;
    FOutcomeCodeList := nil;
  end
  else
  begin
    if FOutcomeCodeList = nil then
      FOutcomeCodeList := TFhirCodeableConceptList.Create;
    FOutcomeCodeList.Assign(TFhirGoal(oSource).FOutcomeCodeList);
  end;
  if (TFhirGoal(oSource).FOutcomeReferenceList = nil) then
  begin
    FOutcomeReferenceList.free;
    FOutcomeReferenceList := nil;
  end
  else
  begin
    if FOutcomeReferenceList = nil then
      FOutcomeReferenceList := TFhirReferenceList{TFhirObservation}.Create;
    FOutcomeReferenceList.Assign(TFhirGoal(oSource).FOutcomeReferenceList);
  end;
end;

procedure TFhirGoal.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'start[x]') or (child_name = 'start') Then
     list.add(self.link, 'start[x]', FStart.Link);
  if (child_name = 'target') Then
     list.add(self.link, 'target', FTarget.Link);
  if (child_name = 'statusDate') Then
     list.add(self.link, 'statusDate', FStatusDate.Link);
  if (child_name = 'statusReason') Then
     list.add(self.link, 'statusReason', FStatusReason.Link);
  if (child_name = 'expressedBy') Then
     list.add(self.link, 'expressedBy', FExpressedBy.Link);
  if (child_name = 'addresses') Then
    list.addAll(self, 'addresses', FAddressesList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'outcomeCode') Then
    list.addAll(self, 'outcomeCode', FOutcomeCodeList);
  if (child_name = 'outcomeReference') Then
    list.addAll(self, 'outcomeReference', FOutcomeReferenceList);
end;

procedure TFhirGoal.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'priority', 'CodeableConcept', false, TFhirCodeableConcept, FPriority.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'CodeableConcept', false, TFhirCodeableConcept, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Group|Organization)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'start[x]', 'date|CodeableConcept', false, TFhirType, FStart.Link));{2}
  oList.add(TFHIRProperty.create(self, 'target', '', false, TFhirGoalTarget, FTarget.Link));{2}
  oList.add(TFHIRProperty.create(self, 'statusDate', 'date', false, TFhirDate, FStatusDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'statusReason', 'string', false, TFhirString, FStatusReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'expressedBy', 'Reference(Patient|Practitioner|RelatedPerson)', false, TFhirReference{Resource}, FExpressedBy.Link));{2}
  oList.add(TFHIRProperty.create(self, 'addresses', 'Reference(Condition|Observation|MedicationStatement|NutritionOrder|ProcedureRequest|RiskAssessment)', true, TFhirReference{Resource}, FAddressesList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'outcomeCode', 'CodeableConcept', true, TFhirCodeableConcept, FOutcomeCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'outcomeReference', 'Reference(Observation)', true, TFhirReference{TFhirObservation}, FOutcomeReferenceList.Link)){3};
end;

function TFhirGoal.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirGoalStatusEnum, CODES_TFhirGoalStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    Priority := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    Description := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'start', ['Date', 'CodeableConcept'])) then
  begin
    Start := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'target') then
  begin
    Target := propValue as TFhirGoalTarget{4b};
    result := propValue;
  end
  else if (propName = 'statusDate') then
  begin
    StatusDateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'statusReason') then
  begin
    StatusReasonElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'expressedBy') then
  begin
    ExpressedBy := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'addresses') then
  begin
    AddressesList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else if (propName = 'outcomeCode') then
  begin
    OutcomeCodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'outcomeReference') then
  begin
    OutcomeReferenceList.add(propValue as TFhirReference{TFhirObservation}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirGoal.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'addresses') then AddressesList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else if (propName = 'outcomeCode') then OutcomeCodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'outcomeReference') then OutcomeReferenceList.insertItem(index, propValue as TFhirReference{TFhirObservation}){2a}
  else inherited;
end;

function TFhirGoal.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'category') then result := CategoryList.new(){2}
  else if (propName = 'priority') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'description') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (isMatchingName(propName, 'start', ['Date', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property Start'){4x}
  else if (propName = 'target') then result := TFhirGoalTarget.create(){4b}
  else if (propName = 'statusDate') then result := TFhirDate.create() {5b}
  else if (propName = 'statusReason') then result := TFhirString.create() {5b}
  else if (propName = 'expressedBy') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'addresses') then result := AddressesList.new(){2}
  else if (propName = 'note') then result := NoteList.new(){2}
  else if (propName = 'outcomeCode') then result := OutcomeCodeList.new(){2}
  else if (propName = 'outcomeReference') then result := OutcomeReferenceList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirGoal.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'priority') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'start[x]') then result := 'date|CodeableConcept'
  else if (propName = 'target') then result := ''
  else if (propName = 'statusDate') then result := 'date'
  else if (propName = 'statusReason') then result := 'string'
  else if (propName = 'expressedBy') then result := 'Reference'
  else if (propName = 'addresses') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'outcomeCode') then result := 'CodeableConcept'
  else if (propName = 'outcomeReference') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirGoal.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value) {2}
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (isMatchingName(propName, 'start', ['Date', 'CodeableConcept'])) then StartElement := nil{4x}
  else if (propName = 'target') then TargetElement := nil
  else if (propName = 'statusDate') then StatusDateElement := nil
  else if (propName = 'statusReason') then StatusReasonElement := nil
  else if (propName = 'expressedBy') then ExpressedByElement := nil
  else if (propName = 'addresses') then deletePropertyValue('addresses', AddressesList, value) {2}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else if (propName = 'outcomeCode') then deletePropertyValue('outcomeCode', OutcomeCodeList, value) {2}
  else if (propName = 'outcomeReference') then deletePropertyValue('outcomeReference', OutcomeReferenceList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirGoal.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirGoalStatusEnum, CODES_TFhirGoalStatusEnum, new){4}
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new) {2}
  else if (propName = 'priority') then PriorityElement := new as TFhirCodeableConcept{4}
  else if (propName = 'description') then DescriptionElement := new as TFhirCodeableConcept{4}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (isMatchingName(propName, 'start', ['Date', 'CodeableConcept'])) then StartElement := new as TFhirType{4x}
  else if (propName = 'target') then TargetElement := new as TFhirGoalTarget{4}
  else if (propName = 'statusDate') then StatusDateElement := asDate(new){5b}
  else if (propName = 'statusReason') then StatusReasonElement := asString(new){5b}
  else if (propName = 'expressedBy') then ExpressedByElement := new as TFhirReference{Resource}{4}
  else if (propName = 'addresses') then replacePropertyValue('addresses', AddressesList, existing, new) {2}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else if (propName = 'outcomeCode') then replacePropertyValue('outcomeCode', OutcomeCodeList, existing, new) {2}
  else if (propName = 'outcomeReference') then replacePropertyValue('outcomeReference', OutcomeReferenceList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirGoal.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'category') then CategoryList.move(source, destination){2a}
  else if (propName = 'addresses') then AddressesList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else if (propName = 'outcomeCode') then OutcomeCodeList.move(source, destination){2a}
  else if (propName = 'outcomeReference') then OutcomeReferenceList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirGoal.fhirType : string;
begin
  result := 'Goal';
end;

function TFhirGoal.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FcategoryList) and isEmptyProp(FPriority) and isEmptyProp(FDescription) and isEmptyProp(FSubject) and isEmptyProp(FStart) and isEmptyProp(FTarget) and isEmptyProp(FStatusDate) and isEmptyProp(FStatusReason) and isEmptyProp(FExpressedBy) and isEmptyProp(FaddressesList) and isEmptyProp(FnoteList) and isEmptyProp(FoutcomeCodeList) and isEmptyProp(FoutcomeReferenceList);
end;

function TFhirGoal.equals(other : TObject) : boolean;
var
  o : TFhirGoal;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirGoal)) then
    result := false
  else
  begin
    o := TFhirGoal(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(categoryList, o.categoryList, true) and compareDeep(priorityElement, o.priorityElement, true) and
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(subjectElement, o.subjectElement, true) and
      compareDeep(startElement, o.startElement, true) and compareDeep(targetElement, o.targetElement, true) and
      compareDeep(statusDateElement, o.statusDateElement, true) and compareDeep(statusReasonElement, o.statusReasonElement, true) and
      compareDeep(expressedByElement, o.expressedByElement, true) and compareDeep(addressesList, o.addressesList, true) and
      compareDeep(noteList, o.noteList, true) and compareDeep(outcomeCodeList, o.outcomeCodeList, true) and
      compareDeep(outcomeReferenceList, o.outcomeReferenceList, true);
  end;
end;

function TFhirGoal.Link : TFhirGoal;
begin
  result := TFhirGoal(inherited Link);
end;

function TFhirGoal.Clone : TFhirGoal;
begin
  result := TFhirGoal(inherited Clone);
end;

procedure TFhirGoal.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('category');
  fields.add('priority');
  fields.add('description');
  fields.add('subject');
  fields.add('start[x]');
  fields.add('target');
  fields.add('statusDate');
  fields.add('statusReason');
  fields.add('expressedBy');
  fields.add('addresses');
  fields.add('note');
  fields.add('outcomeCode');
  fields.add('outcomeReference');
end;

{ TFhirGoal }

Function TFhirGoal.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirGoal.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirGoal.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirGoal.GetStatusST : TFhirGoalStatusEnum;
begin
  if FStatus = nil then
    result := TFhirGoalStatusEnum(0)
  else
    result := TFhirGoalStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirGoalStatusEnum, FStatus.value));
end;

Procedure TFhirGoal.SetStatusST(value : TFhirGoalStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirGoalStatusEnum[value], CODES_TFhirGoalStatusEnum[value]);
end;

Function TFhirGoal.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

Function TFhirGoal.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

Procedure TFhirGoal.SetPriority(value : TFhirCodeableConcept);
begin
  FPriority.free;
  FPriority := value;
end;

Procedure TFhirGoal.SetDescription(value : TFhirCodeableConcept);
begin
  FDescription.free;
  FDescription := value;
end;

Procedure TFhirGoal.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirGoal.SetStart(value : TFhirType);
begin
  FStart.free;
  FStart := value;
end;

Procedure TFhirGoal.SetTarget(value : TFhirGoalTarget);
begin
  FTarget.free;
  FTarget := value;
end;

Procedure TFhirGoal.SetStatusDate(value : TFhirDate);
begin
  FStatusDate.free;
  FStatusDate := value;
end;

Function TFhirGoal.GetStatusDateST : TFslDateTime;
begin
  if FStatusDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FStatusDate.value;
end;

Procedure TFhirGoal.SetStatusDateST(value : TFslDateTime);
begin
  if FStatusDate = nil then
    FStatusDate := TFhirDate.create;
  FStatusDate.value := value
end;

Procedure TFhirGoal.SetStatusReason(value : TFhirString);
begin
  FStatusReason.free;
  FStatusReason := value;
end;

Function TFhirGoal.GetStatusReasonST : String;
begin
  if FStatusReason = nil then
    result := ''
  else
    result := FStatusReason.value;
end;

Procedure TFhirGoal.SetStatusReasonST(value : String);
begin
  if value <> '' then
  begin
    if FStatusReason = nil then
      FStatusReason := TFhirString.create;
    FStatusReason.value := value
  end
  else if FStatusReason <> nil then
    FStatusReason.value := '';
end;

Procedure TFhirGoal.SetExpressedBy(value : TFhirReference{Resource});
begin
  FExpressedBy.free;
  FExpressedBy := value;
end;

Function TFhirGoal.GetAddressesList : TFhirReferenceList{Resource};
begin
  if FAddressesList = nil then
    FAddressesList := TFhirReferenceList{Resource}.Create;
  result := FAddressesList;
end;

Function TFhirGoal.GetHasAddressesList : boolean;
begin
  result := (FAddressesList <> nil) and (FAddressesList.count > 0);
end;

Function TFhirGoal.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirGoal.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

Function TFhirGoal.GetOutcomeCodeList : TFhirCodeableConceptList;
begin
  if FOutcomeCodeList = nil then
    FOutcomeCodeList := TFhirCodeableConceptList.Create;
  result := FOutcomeCodeList;
end;

Function TFhirGoal.GetHasOutcomeCodeList : boolean;
begin
  result := (FOutcomeCodeList <> nil) and (FOutcomeCodeList.count > 0);
end;

Function TFhirGoal.GetOutcomeReferenceList : TFhirReferenceList{TFhirObservation};
begin
  if FOutcomeReferenceList = nil then
    FOutcomeReferenceList := TFhirReferenceList{TFhirObservation}.Create;
  result := FOutcomeReferenceList;
end;

Function TFhirGoal.GetHasOutcomeReferenceList : boolean;
begin
  result := (FOutcomeReferenceList <> nil) and (FOutcomeReferenceList.count > 0);
end;

function TFhirGoal.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FcategoryList.sizeInBytes);
  inc(result, FPriority.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FStart.sizeInBytes);
  inc(result, FTarget.sizeInBytes);
  inc(result, FStatusDate.sizeInBytes);
  inc(result, FStatusReason.sizeInBytes);
  inc(result, FExpressedBy.sizeInBytes);
  inc(result, FaddressesList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FoutcomeCodeList.sizeInBytes);
  inc(result, FoutcomeReferenceList.sizeInBytes);
end;

{ TFhirGoalListEnumerator }

Constructor TFhirGoalListEnumerator.Create(list : TFhirGoalList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirGoalListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirGoalListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirGoalListEnumerator.GetCurrent : TFhirGoal;
begin
  Result := FList[FIndex];
end;

function TFhirGoalListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirGoalList }
procedure TFhirGoalList.AddItem(value: TFhirGoal);
begin
  assert(value.ClassName = 'TFhirGoal', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirGoal');
  add(value);
end;

function TFhirGoalList.Append: TFhirGoal;
begin
  result := TFhirGoal.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGoalList.ClearItems;
begin
  Clear;
end;

function TFhirGoalList.GetEnumerator : TFhirGoalListEnumerator;
begin
  result := TFhirGoalListEnumerator.Create(self.link);
end;

function TFhirGoalList.Clone: TFhirGoalList;
begin
  result := TFhirGoalList(inherited Clone);
end;

function TFhirGoalList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirGoalList.GetItemN(index: Integer): TFhirGoal;
begin
  result := TFhirGoal(ObjectByIndex[index]);
end;

function TFhirGoalList.ItemClass: TFslObjectClass;
begin
  result := TFhirGoal;
end;
function TFhirGoalList.IndexOf(value: TFhirGoal): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirGoalList.Insert(index: Integer): TFhirGoal;
begin
  result := TFhirGoal.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGoalList.InsertItem(index: Integer; value: TFhirGoal);
begin
  assert(value is TFhirGoal);
  Inherited Insert(index, value);
end;

function TFhirGoalList.Item(index: Integer): TFhirGoal;
begin
  result := TFhirGoal(ObjectByIndex[index]);
end;

function TFhirGoalList.Link: TFhirGoalList;
begin
  result := TFhirGoalList(inherited Link);
end;

procedure TFhirGoalList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirGoalList.SetItemByIndex(index: Integer; value: TFhirGoal);
begin
  assert(value is TFhirGoal);
  FhirGoals[index] := value;
end;

procedure TFhirGoalList.SetItemN(index: Integer; value: TFhirGoal);
begin
  assert(value is TFhirGoal);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_GOAL}

{$IFDEF FHIR_IMAGINGMANIFEST}

{ TFhirImagingManifestStudy }

constructor TFhirImagingManifestStudy.Create;
begin
  inherited;
end;

destructor TFhirImagingManifestStudy.Destroy;
begin
  FUid.free;
  FImagingStudy.free;
  FEndpointList.Free;
  FSeriesList.Free;
  inherited;
end;

procedure TFhirImagingManifestStudy.Assign(oSource : TFslObject);
begin
  inherited;
  uidElement := TFhirImagingManifestStudy(oSource).uidElement.Clone;
  imagingStudy := TFhirImagingManifestStudy(oSource).imagingStudy.Clone;
  if (TFhirImagingManifestStudy(oSource).FEndpointList = nil) then
  begin
    FEndpointList.free;
    FEndpointList := nil;
  end
  else
  begin
    if FEndpointList = nil then
      FEndpointList := TFhirReferenceList{TFhirEndpoint}.Create;
    FEndpointList.Assign(TFhirImagingManifestStudy(oSource).FEndpointList);
  end;
  if (TFhirImagingManifestStudy(oSource).FSeriesList = nil) then
  begin
    FSeriesList.free;
    FSeriesList := nil;
  end
  else
  begin
    if FSeriesList = nil then
      FSeriesList := TFhirImagingManifestStudySeriesList.Create;
    FSeriesList.Assign(TFhirImagingManifestStudy(oSource).FSeriesList);
  end;
end;

procedure TFhirImagingManifestStudy.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'uid') Then
     list.add(self.link, 'uid', FUid.Link);
  if (child_name = 'imagingStudy') Then
     list.add(self.link, 'imagingStudy', FImagingStudy.Link);
  if (child_name = 'endpoint') Then
    list.addAll(self, 'endpoint', FEndpointList);
  if (child_name = 'series') Then
    list.addAll(self, 'series', FSeriesList);
end;

procedure TFhirImagingManifestStudy.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'uid', 'oid', false, TFhirOid, FUid.Link));{2}
  oList.add(TFHIRProperty.create(self, 'imagingStudy', 'Reference(ImagingStudy)', false, TFhirReference{TFhirImagingStudy}, FImagingStudy.Link));{2}
  oList.add(TFHIRProperty.create(self, 'endpoint', 'Reference(Endpoint)', true, TFhirReference{TFhirEndpoint}, FEndpointList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'series', '', true, TFhirImagingManifestStudySeries, FSeriesList.Link)){3};
end;

function TFhirImagingManifestStudy.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'uid') then
  begin
    UidElement := asOid(propValue){5a};
    result := propValue;
  end
  else if (propName = 'imagingStudy') then
  begin
    ImagingStudy := propValue as TFhirReference{TFhirImagingStudy}{4b};
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointList.add(propValue as TFhirReference{TFhirEndpoint}){2a};
    result := propValue;
  end
  else if (propName = 'series') then
  begin
    SeriesList.add(propValue as TFhirImagingManifestStudySeries){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImagingManifestStudy.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'endpoint') then EndpointList.insertItem(index, propValue as TFhirReference{TFhirEndpoint}){2a}
  else if (propName = 'series') then SeriesList.insertItem(index, propValue as TFhirImagingManifestStudySeries){2a}
  else inherited;
end;

function TFhirImagingManifestStudy.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'uid') then result := TFhirOid.create() {5b}
  else if (propName = 'imagingStudy') then result := TFhirReference{TFhirImagingStudy}.create(){4b}
  else if (propName = 'endpoint') then result := EndpointList.new(){2}
  else if (propName = 'series') then result := SeriesList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImagingManifestStudy.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'uid') then result := 'oid'
  else if (propName = 'imagingStudy') then result := 'Reference'
  else if (propName = 'endpoint') then result := 'Reference'
  else if (propName = 'series') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImagingManifestStudy.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'uid') then UidElement := nil
  else if (propName = 'imagingStudy') then ImagingStudyElement := nil
  else if (propName = 'endpoint') then deletePropertyValue('endpoint', EndpointList, value) {2}
  else if (propName = 'series') then deletePropertyValue('series', SeriesList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImagingManifestStudy.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'uid') then UidElement := asOid(new){5b}
  else if (propName = 'imagingStudy') then ImagingStudyElement := new as TFhirReference{TFhirImagingStudy}{4}
  else if (propName = 'endpoint') then replacePropertyValue('endpoint', EndpointList, existing, new) {2}
  else if (propName = 'series') then replacePropertyValue('series', SeriesList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImagingManifestStudy.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'endpoint') then EndpointList.move(source, destination){2a}
  else if (propName = 'series') then SeriesList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImagingManifestStudy.fhirType : string;
begin
  result := 'study';
end;

function TFhirImagingManifestStudy.Link : TFhirImagingManifestStudy;
begin
  result := TFhirImagingManifestStudy(inherited Link);
end;

function TFhirImagingManifestStudy.Clone : TFhirImagingManifestStudy;
begin
  result := TFhirImagingManifestStudy(inherited Clone);
end;

function TFhirImagingManifestStudy.equals(other : TObject) : boolean;
var
  o : TFhirImagingManifestStudy;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImagingManifestStudy)) then
    result := false
  else
  begin
    o := TFhirImagingManifestStudy(other);
    result := compareDeep(uidElement, o.uidElement, true) and compareDeep(imagingStudyElement, o.imagingStudyElement, true) and
      compareDeep(endpointList, o.endpointList, true) and compareDeep(seriesList, o.seriesList, true);
  end;
end;

function TFhirImagingManifestStudy.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUid) and isEmptyProp(FImagingStudy) and isEmptyProp(FendpointList) and isEmptyProp(FseriesList);
end;

procedure TFhirImagingManifestStudy.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('uid');
  fields.add('imagingStudy');
  fields.add('endpoint');
  fields.add('series');
end;

{ TFhirImagingManifestStudy }

Procedure TFhirImagingManifestStudy.SetUid(value : TFhirOid);
begin
  FUid.free;
  FUid := value;
end;

Function TFhirImagingManifestStudy.GetUidST : String;
begin
  if FUid = nil then
    result := ''
  else
    result := FUid.value;
end;

Procedure TFhirImagingManifestStudy.SetUidST(value : String);
begin
  if value <> '' then
  begin
    if FUid = nil then
      FUid := TFhirOid.create;
    FUid.value := value
  end
  else if FUid <> nil then
    FUid.value := '';
end;

Procedure TFhirImagingManifestStudy.SetImagingStudy(value : TFhirReference{TFhirImagingStudy});
begin
  FImagingStudy.free;
  FImagingStudy := value;
end;

Function TFhirImagingManifestStudy.GetEndpointList : TFhirReferenceList{TFhirEndpoint};
begin
  if FEndpointList = nil then
    FEndpointList := TFhirReferenceList{TFhirEndpoint}.Create;
  result := FEndpointList;
end;

Function TFhirImagingManifestStudy.GetHasEndpointList : boolean;
begin
  result := (FEndpointList <> nil) and (FEndpointList.count > 0);
end;

Function TFhirImagingManifestStudy.GetSeriesList : TFhirImagingManifestStudySeriesList;
begin
  if FSeriesList = nil then
    FSeriesList := TFhirImagingManifestStudySeriesList.Create;
  result := FSeriesList;
end;

Function TFhirImagingManifestStudy.GetHasSeriesList : boolean;
begin
  result := (FSeriesList <> nil) and (FSeriesList.count > 0);
end;

function TFhirImagingManifestStudy.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FUid.sizeInBytes);
  inc(result, FImagingStudy.sizeInBytes);
  inc(result, FendpointList.sizeInBytes);
  inc(result, FseriesList.sizeInBytes);
end;

{ TFhirImagingManifestStudyListEnumerator }

Constructor TFhirImagingManifestStudyListEnumerator.Create(list : TFhirImagingManifestStudyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImagingManifestStudyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImagingManifestStudyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImagingManifestStudyListEnumerator.GetCurrent : TFhirImagingManifestStudy;
begin
  Result := FList[FIndex];
end;

function TFhirImagingManifestStudyListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImagingManifestStudyList }
procedure TFhirImagingManifestStudyList.AddItem(value: TFhirImagingManifestStudy);
begin
  assert(value.ClassName = 'TFhirImagingManifestStudy', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImagingManifestStudy');
  add(value);
end;

function TFhirImagingManifestStudyList.Append: TFhirImagingManifestStudy;
begin
  result := TFhirImagingManifestStudy.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingManifestStudyList.ClearItems;
begin
  Clear;
end;

function TFhirImagingManifestStudyList.GetEnumerator : TFhirImagingManifestStudyListEnumerator;
begin
  result := TFhirImagingManifestStudyListEnumerator.Create(self.link);
end;

function TFhirImagingManifestStudyList.Clone: TFhirImagingManifestStudyList;
begin
  result := TFhirImagingManifestStudyList(inherited Clone);
end;

function TFhirImagingManifestStudyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImagingManifestStudyList.GetItemN(index: Integer): TFhirImagingManifestStudy;
begin
  result := TFhirImagingManifestStudy(ObjectByIndex[index]);
end;

function TFhirImagingManifestStudyList.ItemClass: TFslObjectClass;
begin
  result := TFhirImagingManifestStudy;
end;
function TFhirImagingManifestStudyList.IndexOf(value: TFhirImagingManifestStudy): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImagingManifestStudyList.Insert(index: Integer): TFhirImagingManifestStudy;
begin
  result := TFhirImagingManifestStudy.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingManifestStudyList.InsertItem(index: Integer; value: TFhirImagingManifestStudy);
begin
  assert(value is TFhirImagingManifestStudy);
  Inherited Insert(index, value);
end;

function TFhirImagingManifestStudyList.Item(index: Integer): TFhirImagingManifestStudy;
begin
  result := TFhirImagingManifestStudy(ObjectByIndex[index]);
end;

function TFhirImagingManifestStudyList.Link: TFhirImagingManifestStudyList;
begin
  result := TFhirImagingManifestStudyList(inherited Link);
end;

procedure TFhirImagingManifestStudyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImagingManifestStudyList.SetItemByIndex(index: Integer; value: TFhirImagingManifestStudy);
begin
  assert(value is TFhirImagingManifestStudy);
  FhirImagingManifestStudies[index] := value;
end;

procedure TFhirImagingManifestStudyList.SetItemN(index: Integer; value: TFhirImagingManifestStudy);
begin
  assert(value is TFhirImagingManifestStudy);
  ObjectByIndex[index] := value;
end;

{ TFhirImagingManifestStudySeries }

constructor TFhirImagingManifestStudySeries.Create;
begin
  inherited;
end;

destructor TFhirImagingManifestStudySeries.Destroy;
begin
  FUid.free;
  FEndpointList.Free;
  FInstanceList.Free;
  inherited;
end;

procedure TFhirImagingManifestStudySeries.Assign(oSource : TFslObject);
begin
  inherited;
  uidElement := TFhirImagingManifestStudySeries(oSource).uidElement.Clone;
  if (TFhirImagingManifestStudySeries(oSource).FEndpointList = nil) then
  begin
    FEndpointList.free;
    FEndpointList := nil;
  end
  else
  begin
    if FEndpointList = nil then
      FEndpointList := TFhirReferenceList{TFhirEndpoint}.Create;
    FEndpointList.Assign(TFhirImagingManifestStudySeries(oSource).FEndpointList);
  end;
  if (TFhirImagingManifestStudySeries(oSource).FInstanceList = nil) then
  begin
    FInstanceList.free;
    FInstanceList := nil;
  end
  else
  begin
    if FInstanceList = nil then
      FInstanceList := TFhirImagingManifestStudySeriesInstanceList.Create;
    FInstanceList.Assign(TFhirImagingManifestStudySeries(oSource).FInstanceList);
  end;
end;

procedure TFhirImagingManifestStudySeries.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'uid') Then
     list.add(self.link, 'uid', FUid.Link);
  if (child_name = 'endpoint') Then
    list.addAll(self, 'endpoint', FEndpointList);
  if (child_name = 'instance') Then
    list.addAll(self, 'instance', FInstanceList);
end;

procedure TFhirImagingManifestStudySeries.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'uid', 'oid', false, TFhirOid, FUid.Link));{2}
  oList.add(TFHIRProperty.create(self, 'endpoint', 'Reference(Endpoint)', true, TFhirReference{TFhirEndpoint}, FEndpointList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'instance', '', true, TFhirImagingManifestStudySeriesInstance, FInstanceList.Link)){3};
end;

function TFhirImagingManifestStudySeries.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'uid') then
  begin
    UidElement := asOid(propValue){5a};
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointList.add(propValue as TFhirReference{TFhirEndpoint}){2a};
    result := propValue;
  end
  else if (propName = 'instance') then
  begin
    InstanceList.add(propValue as TFhirImagingManifestStudySeriesInstance){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImagingManifestStudySeries.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'endpoint') then EndpointList.insertItem(index, propValue as TFhirReference{TFhirEndpoint}){2a}
  else if (propName = 'instance') then InstanceList.insertItem(index, propValue as TFhirImagingManifestStudySeriesInstance){2a}
  else inherited;
end;

function TFhirImagingManifestStudySeries.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'uid') then result := TFhirOid.create() {5b}
  else if (propName = 'endpoint') then result := EndpointList.new(){2}
  else if (propName = 'instance') then result := InstanceList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImagingManifestStudySeries.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'uid') then result := 'oid'
  else if (propName = 'endpoint') then result := 'Reference'
  else if (propName = 'instance') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImagingManifestStudySeries.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'uid') then UidElement := nil
  else if (propName = 'endpoint') then deletePropertyValue('endpoint', EndpointList, value) {2}
  else if (propName = 'instance') then deletePropertyValue('instance', InstanceList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImagingManifestStudySeries.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'uid') then UidElement := asOid(new){5b}
  else if (propName = 'endpoint') then replacePropertyValue('endpoint', EndpointList, existing, new) {2}
  else if (propName = 'instance') then replacePropertyValue('instance', InstanceList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImagingManifestStudySeries.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'endpoint') then EndpointList.move(source, destination){2a}
  else if (propName = 'instance') then InstanceList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImagingManifestStudySeries.fhirType : string;
begin
  result := 'series';
end;

function TFhirImagingManifestStudySeries.Link : TFhirImagingManifestStudySeries;
begin
  result := TFhirImagingManifestStudySeries(inherited Link);
end;

function TFhirImagingManifestStudySeries.Clone : TFhirImagingManifestStudySeries;
begin
  result := TFhirImagingManifestStudySeries(inherited Clone);
end;

function TFhirImagingManifestStudySeries.equals(other : TObject) : boolean;
var
  o : TFhirImagingManifestStudySeries;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImagingManifestStudySeries)) then
    result := false
  else
  begin
    o := TFhirImagingManifestStudySeries(other);
    result := compareDeep(uidElement, o.uidElement, true) and compareDeep(endpointList, o.endpointList, true) and
      compareDeep(instanceList, o.instanceList, true);
  end;
end;

function TFhirImagingManifestStudySeries.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUid) and isEmptyProp(FendpointList) and isEmptyProp(FinstanceList);
end;

procedure TFhirImagingManifestStudySeries.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('uid');
  fields.add('endpoint');
  fields.add('instance');
end;

{ TFhirImagingManifestStudySeries }

Procedure TFhirImagingManifestStudySeries.SetUid(value : TFhirOid);
begin
  FUid.free;
  FUid := value;
end;

Function TFhirImagingManifestStudySeries.GetUidST : String;
begin
  if FUid = nil then
    result := ''
  else
    result := FUid.value;
end;

Procedure TFhirImagingManifestStudySeries.SetUidST(value : String);
begin
  if value <> '' then
  begin
    if FUid = nil then
      FUid := TFhirOid.create;
    FUid.value := value
  end
  else if FUid <> nil then
    FUid.value := '';
end;

Function TFhirImagingManifestStudySeries.GetEndpointList : TFhirReferenceList{TFhirEndpoint};
begin
  if FEndpointList = nil then
    FEndpointList := TFhirReferenceList{TFhirEndpoint}.Create;
  result := FEndpointList;
end;

Function TFhirImagingManifestStudySeries.GetHasEndpointList : boolean;
begin
  result := (FEndpointList <> nil) and (FEndpointList.count > 0);
end;

Function TFhirImagingManifestStudySeries.GetInstanceList : TFhirImagingManifestStudySeriesInstanceList;
begin
  if FInstanceList = nil then
    FInstanceList := TFhirImagingManifestStudySeriesInstanceList.Create;
  result := FInstanceList;
end;

Function TFhirImagingManifestStudySeries.GetHasInstanceList : boolean;
begin
  result := (FInstanceList <> nil) and (FInstanceList.count > 0);
end;

function TFhirImagingManifestStudySeries.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FUid.sizeInBytes);
  inc(result, FendpointList.sizeInBytes);
  inc(result, FinstanceList.sizeInBytes);
end;

{ TFhirImagingManifestStudySeriesListEnumerator }

Constructor TFhirImagingManifestStudySeriesListEnumerator.Create(list : TFhirImagingManifestStudySeriesList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImagingManifestStudySeriesListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImagingManifestStudySeriesListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImagingManifestStudySeriesListEnumerator.GetCurrent : TFhirImagingManifestStudySeries;
begin
  Result := FList[FIndex];
end;

function TFhirImagingManifestStudySeriesListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImagingManifestStudySeriesList }
procedure TFhirImagingManifestStudySeriesList.AddItem(value: TFhirImagingManifestStudySeries);
begin
  assert(value.ClassName = 'TFhirImagingManifestStudySeries', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImagingManifestStudySeries');
  add(value);
end;

function TFhirImagingManifestStudySeriesList.Append: TFhirImagingManifestStudySeries;
begin
  result := TFhirImagingManifestStudySeries.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingManifestStudySeriesList.ClearItems;
begin
  Clear;
end;

function TFhirImagingManifestStudySeriesList.GetEnumerator : TFhirImagingManifestStudySeriesListEnumerator;
begin
  result := TFhirImagingManifestStudySeriesListEnumerator.Create(self.link);
end;

function TFhirImagingManifestStudySeriesList.Clone: TFhirImagingManifestStudySeriesList;
begin
  result := TFhirImagingManifestStudySeriesList(inherited Clone);
end;

function TFhirImagingManifestStudySeriesList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImagingManifestStudySeriesList.GetItemN(index: Integer): TFhirImagingManifestStudySeries;
begin
  result := TFhirImagingManifestStudySeries(ObjectByIndex[index]);
end;

function TFhirImagingManifestStudySeriesList.ItemClass: TFslObjectClass;
begin
  result := TFhirImagingManifestStudySeries;
end;
function TFhirImagingManifestStudySeriesList.IndexOf(value: TFhirImagingManifestStudySeries): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImagingManifestStudySeriesList.Insert(index: Integer): TFhirImagingManifestStudySeries;
begin
  result := TFhirImagingManifestStudySeries.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingManifestStudySeriesList.InsertItem(index: Integer; value: TFhirImagingManifestStudySeries);
begin
  assert(value is TFhirImagingManifestStudySeries);
  Inherited Insert(index, value);
end;

function TFhirImagingManifestStudySeriesList.Item(index: Integer): TFhirImagingManifestStudySeries;
begin
  result := TFhirImagingManifestStudySeries(ObjectByIndex[index]);
end;

function TFhirImagingManifestStudySeriesList.Link: TFhirImagingManifestStudySeriesList;
begin
  result := TFhirImagingManifestStudySeriesList(inherited Link);
end;

procedure TFhirImagingManifestStudySeriesList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImagingManifestStudySeriesList.SetItemByIndex(index: Integer; value: TFhirImagingManifestStudySeries);
begin
  assert(value is TFhirImagingManifestStudySeries);
  FhirImagingManifestStudySeries[index] := value;
end;

procedure TFhirImagingManifestStudySeriesList.SetItemN(index: Integer; value: TFhirImagingManifestStudySeries);
begin
  assert(value is TFhirImagingManifestStudySeries);
  ObjectByIndex[index] := value;
end;

{ TFhirImagingManifestStudySeriesInstance }

constructor TFhirImagingManifestStudySeriesInstance.Create;
begin
  inherited;
end;

destructor TFhirImagingManifestStudySeriesInstance.Destroy;
begin
  FSopClass.free;
  FUid.free;
  inherited;
end;

procedure TFhirImagingManifestStudySeriesInstance.Assign(oSource : TFslObject);
begin
  inherited;
  sopClassElement := TFhirImagingManifestStudySeriesInstance(oSource).sopClassElement.Clone;
  uidElement := TFhirImagingManifestStudySeriesInstance(oSource).uidElement.Clone;
end;

procedure TFhirImagingManifestStudySeriesInstance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'sopClass') Then
     list.add(self.link, 'sopClass', FSopClass.Link);
  if (child_name = 'uid') Then
     list.add(self.link, 'uid', FUid.Link);
end;

procedure TFhirImagingManifestStudySeriesInstance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'sopClass', 'oid', false, TFhirOid, FSopClass.Link));{2}
  oList.add(TFHIRProperty.create(self, 'uid', 'oid', false, TFhirOid, FUid.Link));{2}
end;

function TFhirImagingManifestStudySeriesInstance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'sopClass') then
  begin
    SopClassElement := asOid(propValue){5a};
    result := propValue;
  end
  else if (propName = 'uid') then
  begin
    UidElement := asOid(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImagingManifestStudySeriesInstance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirImagingManifestStudySeriesInstance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'sopClass') then result := TFhirOid.create() {5b}
  else if (propName = 'uid') then result := TFhirOid.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImagingManifestStudySeriesInstance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'sopClass') then result := 'oid'
  else if (propName = 'uid') then result := 'oid'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImagingManifestStudySeriesInstance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'sopClass') then SopClassElement := nil
  else if (propName = 'uid') then UidElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImagingManifestStudySeriesInstance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'sopClass') then SopClassElement := asOid(new){5b}
  else if (propName = 'uid') then UidElement := asOid(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImagingManifestStudySeriesInstance.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirImagingManifestStudySeriesInstance.fhirType : string;
begin
  result := 'instance';
end;

function TFhirImagingManifestStudySeriesInstance.Link : TFhirImagingManifestStudySeriesInstance;
begin
  result := TFhirImagingManifestStudySeriesInstance(inherited Link);
end;

function TFhirImagingManifestStudySeriesInstance.Clone : TFhirImagingManifestStudySeriesInstance;
begin
  result := TFhirImagingManifestStudySeriesInstance(inherited Clone);
end;

function TFhirImagingManifestStudySeriesInstance.equals(other : TObject) : boolean;
var
  o : TFhirImagingManifestStudySeriesInstance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImagingManifestStudySeriesInstance)) then
    result := false
  else
  begin
    o := TFhirImagingManifestStudySeriesInstance(other);
    result := compareDeep(sopClassElement, o.sopClassElement, true) and compareDeep(uidElement, o.uidElement, true);
  end;
end;

function TFhirImagingManifestStudySeriesInstance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSopClass) and isEmptyProp(FUid);
end;

procedure TFhirImagingManifestStudySeriesInstance.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('sopClass');
  fields.add('uid');
end;

{ TFhirImagingManifestStudySeriesInstance }

Procedure TFhirImagingManifestStudySeriesInstance.SetSopClass(value : TFhirOid);
begin
  FSopClass.free;
  FSopClass := value;
end;

Function TFhirImagingManifestStudySeriesInstance.GetSopClassST : String;
begin
  if FSopClass = nil then
    result := ''
  else
    result := FSopClass.value;
end;

Procedure TFhirImagingManifestStudySeriesInstance.SetSopClassST(value : String);
begin
  if value <> '' then
  begin
    if FSopClass = nil then
      FSopClass := TFhirOid.create;
    FSopClass.value := value
  end
  else if FSopClass <> nil then
    FSopClass.value := '';
end;

Procedure TFhirImagingManifestStudySeriesInstance.SetUid(value : TFhirOid);
begin
  FUid.free;
  FUid := value;
end;

Function TFhirImagingManifestStudySeriesInstance.GetUidST : String;
begin
  if FUid = nil then
    result := ''
  else
    result := FUid.value;
end;

Procedure TFhirImagingManifestStudySeriesInstance.SetUidST(value : String);
begin
  if value <> '' then
  begin
    if FUid = nil then
      FUid := TFhirOid.create;
    FUid.value := value
  end
  else if FUid <> nil then
    FUid.value := '';
end;

function TFhirImagingManifestStudySeriesInstance.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSopClass.sizeInBytes);
  inc(result, FUid.sizeInBytes);
end;

{ TFhirImagingManifestStudySeriesInstanceListEnumerator }

Constructor TFhirImagingManifestStudySeriesInstanceListEnumerator.Create(list : TFhirImagingManifestStudySeriesInstanceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImagingManifestStudySeriesInstanceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImagingManifestStudySeriesInstanceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImagingManifestStudySeriesInstanceListEnumerator.GetCurrent : TFhirImagingManifestStudySeriesInstance;
begin
  Result := FList[FIndex];
end;

function TFhirImagingManifestStudySeriesInstanceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImagingManifestStudySeriesInstanceList }
procedure TFhirImagingManifestStudySeriesInstanceList.AddItem(value: TFhirImagingManifestStudySeriesInstance);
begin
  assert(value.ClassName = 'TFhirImagingManifestStudySeriesInstance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImagingManifestStudySeriesInstance');
  add(value);
end;

function TFhirImagingManifestStudySeriesInstanceList.Append: TFhirImagingManifestStudySeriesInstance;
begin
  result := TFhirImagingManifestStudySeriesInstance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingManifestStudySeriesInstanceList.ClearItems;
begin
  Clear;
end;

function TFhirImagingManifestStudySeriesInstanceList.GetEnumerator : TFhirImagingManifestStudySeriesInstanceListEnumerator;
begin
  result := TFhirImagingManifestStudySeriesInstanceListEnumerator.Create(self.link);
end;

function TFhirImagingManifestStudySeriesInstanceList.Clone: TFhirImagingManifestStudySeriesInstanceList;
begin
  result := TFhirImagingManifestStudySeriesInstanceList(inherited Clone);
end;

function TFhirImagingManifestStudySeriesInstanceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImagingManifestStudySeriesInstanceList.GetItemN(index: Integer): TFhirImagingManifestStudySeriesInstance;
begin
  result := TFhirImagingManifestStudySeriesInstance(ObjectByIndex[index]);
end;

function TFhirImagingManifestStudySeriesInstanceList.ItemClass: TFslObjectClass;
begin
  result := TFhirImagingManifestStudySeriesInstance;
end;
function TFhirImagingManifestStudySeriesInstanceList.IndexOf(value: TFhirImagingManifestStudySeriesInstance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImagingManifestStudySeriesInstanceList.Insert(index: Integer): TFhirImagingManifestStudySeriesInstance;
begin
  result := TFhirImagingManifestStudySeriesInstance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingManifestStudySeriesInstanceList.InsertItem(index: Integer; value: TFhirImagingManifestStudySeriesInstance);
begin
  assert(value is TFhirImagingManifestStudySeriesInstance);
  Inherited Insert(index, value);
end;

function TFhirImagingManifestStudySeriesInstanceList.Item(index: Integer): TFhirImagingManifestStudySeriesInstance;
begin
  result := TFhirImagingManifestStudySeriesInstance(ObjectByIndex[index]);
end;

function TFhirImagingManifestStudySeriesInstanceList.Link: TFhirImagingManifestStudySeriesInstanceList;
begin
  result := TFhirImagingManifestStudySeriesInstanceList(inherited Link);
end;

procedure TFhirImagingManifestStudySeriesInstanceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImagingManifestStudySeriesInstanceList.SetItemByIndex(index: Integer; value: TFhirImagingManifestStudySeriesInstance);
begin
  assert(value is TFhirImagingManifestStudySeriesInstance);
  FhirImagingManifestStudySeriesInstances[index] := value;
end;

procedure TFhirImagingManifestStudySeriesInstanceList.SetItemN(index: Integer; value: TFhirImagingManifestStudySeriesInstance);
begin
  assert(value is TFhirImagingManifestStudySeriesInstance);
  ObjectByIndex[index] := value;
end;

{ TFhirImagingManifest }

constructor TFhirImagingManifest.Create;
begin
  inherited;
end;

destructor TFhirImagingManifest.Destroy;
begin
  FIdentifier.free;
  FPatient.free;
  FAuthoringTime.free;
  FAuthor.free;
  FDescription.free;
  FStudyList.Free;
  inherited;
end;

function TFhirImagingManifest.GetResourceType : TFhirResourceType;
begin
  result := frtImagingManifest;
end;

procedure TFhirImagingManifest.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirImagingManifest(oSource).identifier.Clone;
  patient := TFhirImagingManifest(oSource).patient.Clone;
  authoringTimeElement := TFhirImagingManifest(oSource).authoringTimeElement.Clone;
  author := TFhirImagingManifest(oSource).author.Clone;
  descriptionElement := TFhirImagingManifest(oSource).descriptionElement.Clone;
  if (TFhirImagingManifest(oSource).FStudyList = nil) then
  begin
    FStudyList.free;
    FStudyList := nil;
  end
  else
  begin
    if FStudyList = nil then
      FStudyList := TFhirImagingManifestStudyList.Create;
    FStudyList.Assign(TFhirImagingManifest(oSource).FStudyList);
  end;
end;

procedure TFhirImagingManifest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'authoringTime') Then
     list.add(self.link, 'authoringTime', FAuthoringTime.Link);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'study') Then
    list.addAll(self, 'study', FStudyList);
end;

procedure TFhirImagingManifest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'authoringTime', 'dateTime', false, TFhirDateTime, FAuthoringTime.Link));{2}
  oList.add(TFHIRProperty.create(self, 'author', 'Reference(Practitioner|Device|Organization|Patient|RelatedPerson)', false, TFhirReference{Resource}, FAuthor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'study', '', true, TFhirImagingManifestStudy, FStudyList.Link)){3};
end;

function TFhirImagingManifest.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'authoringTime') then
  begin
    AuthoringTimeElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'study') then
  begin
    StudyList.add(propValue as TFhirImagingManifestStudy){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirImagingManifest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'study') then StudyList.insertItem(index, propValue as TFhirImagingManifestStudy){2a}
  else inherited;
end;

function TFhirImagingManifest.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'authoringTime') then result := TFhirDateTime.create() {5b}
  else if (propName = 'author') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'study') then result := StudyList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImagingManifest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'authoringTime') then result := 'dateTime'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'study') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImagingManifest.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'authoringTime') then AuthoringTimeElement := nil
  else if (propName = 'author') then AuthorElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'study') then deletePropertyValue('study', StudyList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImagingManifest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'authoringTime') then AuthoringTimeElement := asDateTime(new){5b}
  else if (propName = 'author') then AuthorElement := new as TFhirReference{Resource}{4}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'study') then replacePropertyValue('study', StudyList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImagingManifest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'study') then StudyList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImagingManifest.fhirType : string;
begin
  result := 'ImagingManifest';
end;

function TFhirImagingManifest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FPatient) and isEmptyProp(FAuthoringTime) and isEmptyProp(FAuthor) and isEmptyProp(FDescription) and isEmptyProp(FstudyList);
end;

function TFhirImagingManifest.equals(other : TObject) : boolean;
var
  o : TFhirImagingManifest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImagingManifest)) then
    result := false
  else
  begin
    o := TFhirImagingManifest(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(patientElement, o.patientElement, true) and
      compareDeep(authoringTimeElement, o.authoringTimeElement, true) and compareDeep(authorElement, o.authorElement, true) and
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(studyList, o.studyList, true);
  end;
end;

function TFhirImagingManifest.Link : TFhirImagingManifest;
begin
  result := TFhirImagingManifest(inherited Link);
end;

function TFhirImagingManifest.Clone : TFhirImagingManifest;
begin
  result := TFhirImagingManifest(inherited Clone);
end;

procedure TFhirImagingManifest.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('patient');
  fields.add('authoringTime');
  fields.add('author');
  fields.add('description');
  fields.add('study');
end;

{ TFhirImagingManifest }

Procedure TFhirImagingManifest.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirImagingManifest.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Procedure TFhirImagingManifest.SetAuthoringTime(value : TFhirDateTime);
begin
  FAuthoringTime.free;
  FAuthoringTime := value;
end;

Function TFhirImagingManifest.GetAuthoringTimeST : TFslDateTime;
begin
  if FAuthoringTime = nil then
    result := TFslDateTime.makeNull
  else
    result := FAuthoringTime.value;
end;

Procedure TFhirImagingManifest.SetAuthoringTimeST(value : TFslDateTime);
begin
  if FAuthoringTime = nil then
    FAuthoringTime := TFhirDateTime.create;
  FAuthoringTime.value := value
end;

Procedure TFhirImagingManifest.SetAuthor(value : TFhirReference{Resource});
begin
  FAuthor.free;
  FAuthor := value;
end;

Procedure TFhirImagingManifest.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirImagingManifest.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirImagingManifest.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Function TFhirImagingManifest.GetStudyList : TFhirImagingManifestStudyList;
begin
  if FStudyList = nil then
    FStudyList := TFhirImagingManifestStudyList.Create;
  result := FStudyList;
end;

Function TFhirImagingManifest.GetHasStudyList : boolean;
begin
  result := (FStudyList <> nil) and (FStudyList.count > 0);
end;

function TFhirImagingManifest.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FAuthoringTime.sizeInBytes);
  inc(result, FAuthor.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FstudyList.sizeInBytes);
end;

{ TFhirImagingManifestListEnumerator }

Constructor TFhirImagingManifestListEnumerator.Create(list : TFhirImagingManifestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImagingManifestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImagingManifestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImagingManifestListEnumerator.GetCurrent : TFhirImagingManifest;
begin
  Result := FList[FIndex];
end;

function TFhirImagingManifestListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImagingManifestList }
procedure TFhirImagingManifestList.AddItem(value: TFhirImagingManifest);
begin
  assert(value.ClassName = 'TFhirImagingManifest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImagingManifest');
  add(value);
end;

function TFhirImagingManifestList.Append: TFhirImagingManifest;
begin
  result := TFhirImagingManifest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingManifestList.ClearItems;
begin
  Clear;
end;

function TFhirImagingManifestList.GetEnumerator : TFhirImagingManifestListEnumerator;
begin
  result := TFhirImagingManifestListEnumerator.Create(self.link);
end;

function TFhirImagingManifestList.Clone: TFhirImagingManifestList;
begin
  result := TFhirImagingManifestList(inherited Clone);
end;

function TFhirImagingManifestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImagingManifestList.GetItemN(index: Integer): TFhirImagingManifest;
begin
  result := TFhirImagingManifest(ObjectByIndex[index]);
end;

function TFhirImagingManifestList.ItemClass: TFslObjectClass;
begin
  result := TFhirImagingManifest;
end;
function TFhirImagingManifestList.IndexOf(value: TFhirImagingManifest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImagingManifestList.Insert(index: Integer): TFhirImagingManifest;
begin
  result := TFhirImagingManifest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingManifestList.InsertItem(index: Integer; value: TFhirImagingManifest);
begin
  assert(value is TFhirImagingManifest);
  Inherited Insert(index, value);
end;

function TFhirImagingManifestList.Item(index: Integer): TFhirImagingManifest;
begin
  result := TFhirImagingManifest(ObjectByIndex[index]);
end;

function TFhirImagingManifestList.Link: TFhirImagingManifestList;
begin
  result := TFhirImagingManifestList(inherited Link);
end;

procedure TFhirImagingManifestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImagingManifestList.SetItemByIndex(index: Integer; value: TFhirImagingManifest);
begin
  assert(value is TFhirImagingManifest);
  FhirImagingManifests[index] := value;
end;

procedure TFhirImagingManifestList.SetItemN(index: Integer; value: TFhirImagingManifest);
begin
  assert(value is TFhirImagingManifest);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_IMAGINGMANIFEST}

{$IFDEF FHIR_IMAGINGSTUDY}

{ TFhirImagingStudySeries }

constructor TFhirImagingStudySeries.Create;
begin
  inherited;
end;

destructor TFhirImagingStudySeries.Destroy;
begin
  FUid.free;
  FNumber.free;
  FModality.free;
  FDescription.free;
  FNumberOfInstances.free;
  FAvailability.free;
  FEndpointList.Free;
  FBodySite.free;
  FLaterality.free;
  FStarted.free;
  FPerformerList.Free;
  FInstanceList.Free;
  inherited;
end;

procedure TFhirImagingStudySeries.Assign(oSource : TFslObject);
begin
  inherited;
  uidElement := TFhirImagingStudySeries(oSource).uidElement.Clone;
  numberElement := TFhirImagingStudySeries(oSource).numberElement.Clone;
  modality := TFhirImagingStudySeries(oSource).modality.Clone;
  descriptionElement := TFhirImagingStudySeries(oSource).descriptionElement.Clone;
  numberOfInstancesElement := TFhirImagingStudySeries(oSource).numberOfInstancesElement.Clone;
  FAvailability := TFhirImagingStudySeries(oSource).FAvailability.Link;
  if (TFhirImagingStudySeries(oSource).FEndpointList = nil) then
  begin
    FEndpointList.free;
    FEndpointList := nil;
  end
  else
  begin
    if FEndpointList = nil then
      FEndpointList := TFhirReferenceList{TFhirEndpoint}.Create;
    FEndpointList.Assign(TFhirImagingStudySeries(oSource).FEndpointList);
  end;
  bodySite := TFhirImagingStudySeries(oSource).bodySite.Clone;
  laterality := TFhirImagingStudySeries(oSource).laterality.Clone;
  startedElement := TFhirImagingStudySeries(oSource).startedElement.Clone;
  if (TFhirImagingStudySeries(oSource).FPerformerList = nil) then
  begin
    FPerformerList.free;
    FPerformerList := nil;
  end
  else
  begin
    if FPerformerList = nil then
      FPerformerList := TFhirReferenceList{TFhirPractitioner}.Create;
    FPerformerList.Assign(TFhirImagingStudySeries(oSource).FPerformerList);
  end;
  if (TFhirImagingStudySeries(oSource).FInstanceList = nil) then
  begin
    FInstanceList.free;
    FInstanceList := nil;
  end
  else
  begin
    if FInstanceList = nil then
      FInstanceList := TFhirImagingStudySeriesInstanceList.Create;
    FInstanceList.Assign(TFhirImagingStudySeries(oSource).FInstanceList);
  end;
end;

procedure TFhirImagingStudySeries.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'uid') Then
     list.add(self.link, 'uid', FUid.Link);
  if (child_name = 'number') Then
     list.add(self.link, 'number', FNumber.Link);
  if (child_name = 'modality') Then
     list.add(self.link, 'modality', FModality.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'numberOfInstances') Then
     list.add(self.link, 'numberOfInstances', FNumberOfInstances.Link);
  if (child_name = 'availability') Then
     list.add(self.link, 'availability', FAvailability.Link);
  if (child_name = 'endpoint') Then
    list.addAll(self, 'endpoint', FEndpointList);
  if (child_name = 'bodySite') Then
     list.add(self.link, 'bodySite', FBodySite.Link);
  if (child_name = 'laterality') Then
     list.add(self.link, 'laterality', FLaterality.Link);
  if (child_name = 'started') Then
     list.add(self.link, 'started', FStarted.Link);
  if (child_name = 'performer') Then
    list.addAll(self, 'performer', FPerformerList);
  if (child_name = 'instance') Then
    list.addAll(self, 'instance', FInstanceList);
end;

procedure TFhirImagingStudySeries.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'uid', 'oid', false, TFhirOid, FUid.Link));{2}
  oList.add(TFHIRProperty.create(self, 'number', 'unsignedInt', false, TFhirUnsignedInt, FNumber.Link));{2}
  oList.add(TFHIRProperty.create(self, 'modality', 'Coding', false, TFhirCoding, FModality.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'numberOfInstances', 'unsignedInt', false, TFhirUnsignedInt, FNumberOfInstances.Link));{2}
  oList.add(TFHIRProperty.create(self, 'availability', 'code', false, TFHIREnum, FAvailability.Link));{1}
  oList.add(TFHIRProperty.create(self, 'endpoint', 'Reference(Endpoint)', true, TFhirReference{TFhirEndpoint}, FEndpointList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'bodySite', 'Coding', false, TFhirCoding, FBodySite.Link));{2}
  oList.add(TFHIRProperty.create(self, 'laterality', 'Coding', false, TFhirCoding, FLaterality.Link));{2}
  oList.add(TFHIRProperty.create(self, 'started', 'dateTime', false, TFhirDateTime, FStarted.Link));{2}
  oList.add(TFHIRProperty.create(self, 'performer', 'Reference(Practitioner)', true, TFhirReference{TFhirPractitioner}, FPerformerList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'instance', '', true, TFhirImagingStudySeriesInstance, FInstanceList.Link)){3};
end;

function TFhirImagingStudySeries.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'uid') then
  begin
    UidElement := asOid(propValue){5a};
    result := propValue;
  end
  else if (propName = 'number') then
  begin
    NumberElement := asUnsignedInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'modality') then
  begin
    Modality := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'numberOfInstances') then
  begin
    NumberOfInstancesElement := asUnsignedInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'availability') then
  begin
    AvailabilityElement := asEnum(SYSTEMS_TFhirInstanceAvailabilityEnum, CODES_TFhirInstanceAvailabilityEnum, propValue);
    result := propValue
  end
  else if (propName = 'endpoint') then
  begin
    EndpointList.add(propValue as TFhirReference{TFhirEndpoint}){2a};
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySite := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'laterality') then
  begin
    Laterality := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'started') then
  begin
    StartedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    PerformerList.add(propValue as TFhirReference{TFhirPractitioner}){2a};
    result := propValue;
  end
  else if (propName = 'instance') then
  begin
    InstanceList.add(propValue as TFhirImagingStudySeriesInstance){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImagingStudySeries.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'endpoint') then EndpointList.insertItem(index, propValue as TFhirReference{TFhirEndpoint}){2a}
  else if (propName = 'performer') then PerformerList.insertItem(index, propValue as TFhirReference{TFhirPractitioner}){2a}
  else if (propName = 'instance') then InstanceList.insertItem(index, propValue as TFhirImagingStudySeriesInstance){2a}
  else inherited;
end;

function TFhirImagingStudySeries.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'uid') then result := TFhirOid.create() {5b}
  else if (propName = 'number') then result := TFhirUnsignedInt.create() {5b}
  else if (propName = 'modality') then result := TFhirCoding.create(){4b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'numberOfInstances') then result := TFhirUnsignedInt.create() {5b}
  else if (propName = 'endpoint') then result := EndpointList.new(){2}
  else if (propName = 'bodySite') then result := TFhirCoding.create(){4b}
  else if (propName = 'laterality') then result := TFhirCoding.create(){4b}
  else if (propName = 'started') then result := TFhirDateTime.create() {5b}
  else if (propName = 'performer') then result := PerformerList.new(){2}
  else if (propName = 'instance') then result := InstanceList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImagingStudySeries.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'uid') then result := 'oid'
  else if (propName = 'number') then result := 'unsignedInt'
  else if (propName = 'modality') then result := 'Coding'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'numberOfInstances') then result := 'unsignedInt'
  else if (propName = 'availability') then result := 'code'
  else if (propName = 'endpoint') then result := 'Reference'
  else if (propName = 'bodySite') then result := 'Coding'
  else if (propName = 'laterality') then result := 'Coding'
  else if (propName = 'started') then result := 'dateTime'
  else if (propName = 'performer') then result := 'Reference'
  else if (propName = 'instance') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImagingStudySeries.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'uid') then UidElement := nil
  else if (propName = 'number') then NumberElement := nil
  else if (propName = 'modality') then ModalityElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'numberOfInstances') then NumberOfInstancesElement := nil
  else if (propName = 'availability') then AvailabilityElement := nil
  else if (propName = 'endpoint') then deletePropertyValue('endpoint', EndpointList, value) {2}
  else if (propName = 'bodySite') then BodySiteElement := nil
  else if (propName = 'laterality') then LateralityElement := nil
  else if (propName = 'started') then StartedElement := nil
  else if (propName = 'performer') then deletePropertyValue('performer', PerformerList, value) {2}
  else if (propName = 'instance') then deletePropertyValue('instance', InstanceList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImagingStudySeries.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'uid') then UidElement := asOid(new){5b}
  else if (propName = 'number') then NumberElement := asUnsignedInt(new){5b}
  else if (propName = 'modality') then ModalityElement := new as TFhirCoding{4}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'numberOfInstances') then NumberOfInstancesElement := asUnsignedInt(new){5b}
  else if (propName = 'availability') then AvailabilityElement := asEnum(SYSTEMS_TFhirInstanceAvailabilityEnum, CODES_TFhirInstanceAvailabilityEnum, new){4}
  else if (propName = 'endpoint') then replacePropertyValue('endpoint', EndpointList, existing, new) {2}
  else if (propName = 'bodySite') then BodySiteElement := new as TFhirCoding{4}
  else if (propName = 'laterality') then LateralityElement := new as TFhirCoding{4}
  else if (propName = 'started') then StartedElement := asDateTime(new){5b}
  else if (propName = 'performer') then replacePropertyValue('performer', PerformerList, existing, new) {2}
  else if (propName = 'instance') then replacePropertyValue('instance', InstanceList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImagingStudySeries.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'endpoint') then EndpointList.move(source, destination){2a}
  else if (propName = 'performer') then PerformerList.move(source, destination){2a}
  else if (propName = 'instance') then InstanceList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImagingStudySeries.fhirType : string;
begin
  result := 'series';
end;

function TFhirImagingStudySeries.Link : TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries(inherited Link);
end;

function TFhirImagingStudySeries.Clone : TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries(inherited Clone);
end;

function TFhirImagingStudySeries.equals(other : TObject) : boolean;
var
  o : TFhirImagingStudySeries;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImagingStudySeries)) then
    result := false
  else
  begin
    o := TFhirImagingStudySeries(other);
    result := compareDeep(uidElement, o.uidElement, true) and compareDeep(numberElement, o.numberElement, true) and
      compareDeep(modalityElement, o.modalityElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and
      compareDeep(numberOfInstancesElement, o.numberOfInstancesElement, true) and compareDeep(availabilityElement, o.availabilityElement, true) and
      compareDeep(endpointList, o.endpointList, true) and compareDeep(bodySiteElement, o.bodySiteElement, true) and
      compareDeep(lateralityElement, o.lateralityElement, true) and compareDeep(startedElement, o.startedElement, true) and
      compareDeep(performerList, o.performerList, true) and compareDeep(instanceList, o.instanceList, true);
  end;
end;

function TFhirImagingStudySeries.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUid) and isEmptyProp(FNumber) and isEmptyProp(FModality) and isEmptyProp(FDescription) and isEmptyProp(FNumberOfInstances) and isEmptyProp(FAvailability) and isEmptyProp(FendpointList) and isEmptyProp(FBodySite) and isEmptyProp(FLaterality) and isEmptyProp(FStarted) and isEmptyProp(FperformerList) and isEmptyProp(FinstanceList);
end;

procedure TFhirImagingStudySeries.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('uid');
  fields.add('number');
  fields.add('modality');
  fields.add('description');
  fields.add('numberOfInstances');
  fields.add('availability');
  fields.add('endpoint');
  fields.add('bodySite');
  fields.add('laterality');
  fields.add('started');
  fields.add('performer');
  fields.add('instance');
end;

{ TFhirImagingStudySeries }

Procedure TFhirImagingStudySeries.SetUid(value : TFhirOid);
begin
  FUid.free;
  FUid := value;
end;

Function TFhirImagingStudySeries.GetUidST : String;
begin
  if FUid = nil then
    result := ''
  else
    result := FUid.value;
end;

Procedure TFhirImagingStudySeries.SetUidST(value : String);
begin
  if value <> '' then
  begin
    if FUid = nil then
      FUid := TFhirOid.create;
    FUid.value := value
  end
  else if FUid <> nil then
    FUid.value := '';
end;

Procedure TFhirImagingStudySeries.SetNumber(value : TFhirUnsignedInt);
begin
  FNumber.free;
  FNumber := value;
end;

Function TFhirImagingStudySeries.GetNumberST : String;
begin
  if FNumber = nil then
    result := ''
  else
    result := FNumber.value;
end;

Procedure TFhirImagingStudySeries.SetNumberST(value : String);
begin
  if value <> '' then
  begin
    if FNumber = nil then
      FNumber := TFhirUnsignedInt.create;
    FNumber.value := value
  end
  else if FNumber <> nil then
    FNumber.value := '';
end;

Procedure TFhirImagingStudySeries.SetModality(value : TFhirCoding);
begin
  FModality.free;
  FModality := value;
end;

Procedure TFhirImagingStudySeries.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirImagingStudySeries.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirImagingStudySeries.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirImagingStudySeries.SetNumberOfInstances(value : TFhirUnsignedInt);
begin
  FNumberOfInstances.free;
  FNumberOfInstances := value;
end;

Function TFhirImagingStudySeries.GetNumberOfInstancesST : String;
begin
  if FNumberOfInstances = nil then
    result := ''
  else
    result := FNumberOfInstances.value;
end;

Procedure TFhirImagingStudySeries.SetNumberOfInstancesST(value : String);
begin
  if value <> '' then
  begin
    if FNumberOfInstances = nil then
      FNumberOfInstances := TFhirUnsignedInt.create;
    FNumberOfInstances.value := value
  end
  else if FNumberOfInstances <> nil then
    FNumberOfInstances.value := '';
end;

Procedure TFhirImagingStudySeries.SetAvailability(value : TFhirEnum);
begin
  FAvailability.free;
  FAvailability := value;
end;

Function TFhirImagingStudySeries.GetAvailabilityST : TFhirInstanceAvailabilityEnum;
begin
  if FAvailability = nil then
    result := TFhirInstanceAvailabilityEnum(0)
  else
    result := TFhirInstanceAvailabilityEnum(StringArrayIndexOfSensitive(CODES_TFhirInstanceAvailabilityEnum, FAvailability.value));
end;

Procedure TFhirImagingStudySeries.SetAvailabilityST(value : TFhirInstanceAvailabilityEnum);
begin
  if ord(value) = 0 then
    AvailabilityElement := nil
  else
    AvailabilityElement := TFhirEnum.create(SYSTEMS_TFhirInstanceAvailabilityEnum[value], CODES_TFhirInstanceAvailabilityEnum[value]);
end;

Function TFhirImagingStudySeries.GetEndpointList : TFhirReferenceList{TFhirEndpoint};
begin
  if FEndpointList = nil then
    FEndpointList := TFhirReferenceList{TFhirEndpoint}.Create;
  result := FEndpointList;
end;

Function TFhirImagingStudySeries.GetHasEndpointList : boolean;
begin
  result := (FEndpointList <> nil) and (FEndpointList.count > 0);
end;

Procedure TFhirImagingStudySeries.SetBodySite(value : TFhirCoding);
begin
  FBodySite.free;
  FBodySite := value;
end;

Procedure TFhirImagingStudySeries.SetLaterality(value : TFhirCoding);
begin
  FLaterality.free;
  FLaterality := value;
end;

Procedure TFhirImagingStudySeries.SetStarted(value : TFhirDateTime);
begin
  FStarted.free;
  FStarted := value;
end;

Function TFhirImagingStudySeries.GetStartedST : TFslDateTime;
begin
  if FStarted = nil then
    result := TFslDateTime.makeNull
  else
    result := FStarted.value;
end;

Procedure TFhirImagingStudySeries.SetStartedST(value : TFslDateTime);
begin
  if FStarted = nil then
    FStarted := TFhirDateTime.create;
  FStarted.value := value
end;

Function TFhirImagingStudySeries.GetPerformerList : TFhirReferenceList{TFhirPractitioner};
begin
  if FPerformerList = nil then
    FPerformerList := TFhirReferenceList{TFhirPractitioner}.Create;
  result := FPerformerList;
end;

Function TFhirImagingStudySeries.GetHasPerformerList : boolean;
begin
  result := (FPerformerList <> nil) and (FPerformerList.count > 0);
end;

Function TFhirImagingStudySeries.GetInstanceList : TFhirImagingStudySeriesInstanceList;
begin
  if FInstanceList = nil then
    FInstanceList := TFhirImagingStudySeriesInstanceList.Create;
  result := FInstanceList;
end;

Function TFhirImagingStudySeries.GetHasInstanceList : boolean;
begin
  result := (FInstanceList <> nil) and (FInstanceList.count > 0);
end;

function TFhirImagingStudySeries.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FUid.sizeInBytes);
  inc(result, FNumber.sizeInBytes);
  inc(result, FModality.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FNumberOfInstances.sizeInBytes);
  inc(result, FAvailability.sizeInBytes);
  inc(result, FendpointList.sizeInBytes);
  inc(result, FBodySite.sizeInBytes);
  inc(result, FLaterality.sizeInBytes);
  inc(result, FStarted.sizeInBytes);
  inc(result, FperformerList.sizeInBytes);
  inc(result, FinstanceList.sizeInBytes);
end;

{ TFhirImagingStudySeriesListEnumerator }

Constructor TFhirImagingStudySeriesListEnumerator.Create(list : TFhirImagingStudySeriesList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImagingStudySeriesListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImagingStudySeriesListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImagingStudySeriesListEnumerator.GetCurrent : TFhirImagingStudySeries;
begin
  Result := FList[FIndex];
end;

function TFhirImagingStudySeriesListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImagingStudySeriesList }
procedure TFhirImagingStudySeriesList.AddItem(value: TFhirImagingStudySeries);
begin
  assert(value.ClassName = 'TFhirImagingStudySeries', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImagingStudySeries');
  add(value);
end;

function TFhirImagingStudySeriesList.Append: TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingStudySeriesList.ClearItems;
begin
  Clear;
end;

function TFhirImagingStudySeriesList.GetEnumerator : TFhirImagingStudySeriesListEnumerator;
begin
  result := TFhirImagingStudySeriesListEnumerator.Create(self.link);
end;

function TFhirImagingStudySeriesList.Clone: TFhirImagingStudySeriesList;
begin
  result := TFhirImagingStudySeriesList(inherited Clone);
end;

function TFhirImagingStudySeriesList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImagingStudySeriesList.GetItemN(index: Integer): TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries(ObjectByIndex[index]);
end;

function TFhirImagingStudySeriesList.ItemClass: TFslObjectClass;
begin
  result := TFhirImagingStudySeries;
end;
function TFhirImagingStudySeriesList.IndexOf(value: TFhirImagingStudySeries): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImagingStudySeriesList.Insert(index: Integer): TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingStudySeriesList.InsertItem(index: Integer; value: TFhirImagingStudySeries);
begin
  assert(value is TFhirImagingStudySeries);
  Inherited Insert(index, value);
end;

function TFhirImagingStudySeriesList.Item(index: Integer): TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries(ObjectByIndex[index]);
end;

function TFhirImagingStudySeriesList.Link: TFhirImagingStudySeriesList;
begin
  result := TFhirImagingStudySeriesList(inherited Link);
end;

procedure TFhirImagingStudySeriesList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImagingStudySeriesList.SetItemByIndex(index: Integer; value: TFhirImagingStudySeries);
begin
  assert(value is TFhirImagingStudySeries);
  FhirImagingStudySeries[index] := value;
end;

procedure TFhirImagingStudySeriesList.SetItemN(index: Integer; value: TFhirImagingStudySeries);
begin
  assert(value is TFhirImagingStudySeries);
  ObjectByIndex[index] := value;
end;

{ TFhirImagingStudySeriesInstance }

constructor TFhirImagingStudySeriesInstance.Create;
begin
  inherited;
end;

destructor TFhirImagingStudySeriesInstance.Destroy;
begin
  FUid.free;
  FNumber.free;
  FSopClass.free;
  FTitle.free;
  inherited;
end;

procedure TFhirImagingStudySeriesInstance.Assign(oSource : TFslObject);
begin
  inherited;
  uidElement := TFhirImagingStudySeriesInstance(oSource).uidElement.Clone;
  numberElement := TFhirImagingStudySeriesInstance(oSource).numberElement.Clone;
  sopClassElement := TFhirImagingStudySeriesInstance(oSource).sopClassElement.Clone;
  titleElement := TFhirImagingStudySeriesInstance(oSource).titleElement.Clone;
end;

procedure TFhirImagingStudySeriesInstance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'uid') Then
     list.add(self.link, 'uid', FUid.Link);
  if (child_name = 'number') Then
     list.add(self.link, 'number', FNumber.Link);
  if (child_name = 'sopClass') Then
     list.add(self.link, 'sopClass', FSopClass.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
end;

procedure TFhirImagingStudySeriesInstance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'uid', 'oid', false, TFhirOid, FUid.Link));{2}
  oList.add(TFHIRProperty.create(self, 'number', 'unsignedInt', false, TFhirUnsignedInt, FNumber.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sopClass', 'oid', false, TFhirOid, FSopClass.Link));{2}
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));{2}
end;

function TFhirImagingStudySeriesInstance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'uid') then
  begin
    UidElement := asOid(propValue){5a};
    result := propValue;
  end
  else if (propName = 'number') then
  begin
    NumberElement := asUnsignedInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'sopClass') then
  begin
    SopClassElement := asOid(propValue){5a};
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImagingStudySeriesInstance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirImagingStudySeriesInstance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'uid') then result := TFhirOid.create() {5b}
  else if (propName = 'number') then result := TFhirUnsignedInt.create() {5b}
  else if (propName = 'sopClass') then result := TFhirOid.create() {5b}
  else if (propName = 'title') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImagingStudySeriesInstance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'uid') then result := 'oid'
  else if (propName = 'number') then result := 'unsignedInt'
  else if (propName = 'sopClass') then result := 'oid'
  else if (propName = 'title') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImagingStudySeriesInstance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'uid') then UidElement := nil
  else if (propName = 'number') then NumberElement := nil
  else if (propName = 'sopClass') then SopClassElement := nil
  else if (propName = 'title') then TitleElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImagingStudySeriesInstance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'uid') then UidElement := asOid(new){5b}
  else if (propName = 'number') then NumberElement := asUnsignedInt(new){5b}
  else if (propName = 'sopClass') then SopClassElement := asOid(new){5b}
  else if (propName = 'title') then TitleElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImagingStudySeriesInstance.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirImagingStudySeriesInstance.fhirType : string;
begin
  result := 'instance';
end;

function TFhirImagingStudySeriesInstance.Link : TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance(inherited Link);
end;

function TFhirImagingStudySeriesInstance.Clone : TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance(inherited Clone);
end;

function TFhirImagingStudySeriesInstance.equals(other : TObject) : boolean;
var
  o : TFhirImagingStudySeriesInstance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImagingStudySeriesInstance)) then
    result := false
  else
  begin
    o := TFhirImagingStudySeriesInstance(other);
    result := compareDeep(uidElement, o.uidElement, true) and compareDeep(numberElement, o.numberElement, true) and
      compareDeep(sopClassElement, o.sopClassElement, true) and compareDeep(titleElement, o.titleElement, true);
  end;
end;

function TFhirImagingStudySeriesInstance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUid) and isEmptyProp(FNumber) and isEmptyProp(FSopClass) and isEmptyProp(FTitle);
end;

procedure TFhirImagingStudySeriesInstance.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('uid');
  fields.add('number');
  fields.add('sopClass');
  fields.add('title');
end;

{ TFhirImagingStudySeriesInstance }

Procedure TFhirImagingStudySeriesInstance.SetUid(value : TFhirOid);
begin
  FUid.free;
  FUid := value;
end;

Function TFhirImagingStudySeriesInstance.GetUidST : String;
begin
  if FUid = nil then
    result := ''
  else
    result := FUid.value;
end;

Procedure TFhirImagingStudySeriesInstance.SetUidST(value : String);
begin
  if value <> '' then
  begin
    if FUid = nil then
      FUid := TFhirOid.create;
    FUid.value := value
  end
  else if FUid <> nil then
    FUid.value := '';
end;

Procedure TFhirImagingStudySeriesInstance.SetNumber(value : TFhirUnsignedInt);
begin
  FNumber.free;
  FNumber := value;
end;

Function TFhirImagingStudySeriesInstance.GetNumberST : String;
begin
  if FNumber = nil then
    result := ''
  else
    result := FNumber.value;
end;

Procedure TFhirImagingStudySeriesInstance.SetNumberST(value : String);
begin
  if value <> '' then
  begin
    if FNumber = nil then
      FNumber := TFhirUnsignedInt.create;
    FNumber.value := value
  end
  else if FNumber <> nil then
    FNumber.value := '';
end;

Procedure TFhirImagingStudySeriesInstance.SetSopClass(value : TFhirOid);
begin
  FSopClass.free;
  FSopClass := value;
end;

Function TFhirImagingStudySeriesInstance.GetSopClassST : String;
begin
  if FSopClass = nil then
    result := ''
  else
    result := FSopClass.value;
end;

Procedure TFhirImagingStudySeriesInstance.SetSopClassST(value : String);
begin
  if value <> '' then
  begin
    if FSopClass = nil then
      FSopClass := TFhirOid.create;
    FSopClass.value := value
  end
  else if FSopClass <> nil then
    FSopClass.value := '';
end;

Procedure TFhirImagingStudySeriesInstance.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

Function TFhirImagingStudySeriesInstance.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

Procedure TFhirImagingStudySeriesInstance.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

function TFhirImagingStudySeriesInstance.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FUid.sizeInBytes);
  inc(result, FNumber.sizeInBytes);
  inc(result, FSopClass.sizeInBytes);
  inc(result, FTitle.sizeInBytes);
end;

{ TFhirImagingStudySeriesInstanceListEnumerator }

Constructor TFhirImagingStudySeriesInstanceListEnumerator.Create(list : TFhirImagingStudySeriesInstanceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImagingStudySeriesInstanceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImagingStudySeriesInstanceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImagingStudySeriesInstanceListEnumerator.GetCurrent : TFhirImagingStudySeriesInstance;
begin
  Result := FList[FIndex];
end;

function TFhirImagingStudySeriesInstanceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImagingStudySeriesInstanceList }
procedure TFhirImagingStudySeriesInstanceList.AddItem(value: TFhirImagingStudySeriesInstance);
begin
  assert(value.ClassName = 'TFhirImagingStudySeriesInstance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImagingStudySeriesInstance');
  add(value);
end;

function TFhirImagingStudySeriesInstanceList.Append: TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingStudySeriesInstanceList.ClearItems;
begin
  Clear;
end;

function TFhirImagingStudySeriesInstanceList.GetEnumerator : TFhirImagingStudySeriesInstanceListEnumerator;
begin
  result := TFhirImagingStudySeriesInstanceListEnumerator.Create(self.link);
end;

function TFhirImagingStudySeriesInstanceList.Clone: TFhirImagingStudySeriesInstanceList;
begin
  result := TFhirImagingStudySeriesInstanceList(inherited Clone);
end;

function TFhirImagingStudySeriesInstanceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImagingStudySeriesInstanceList.GetItemN(index: Integer): TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance(ObjectByIndex[index]);
end;

function TFhirImagingStudySeriesInstanceList.ItemClass: TFslObjectClass;
begin
  result := TFhirImagingStudySeriesInstance;
end;
function TFhirImagingStudySeriesInstanceList.IndexOf(value: TFhirImagingStudySeriesInstance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImagingStudySeriesInstanceList.Insert(index: Integer): TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingStudySeriesInstanceList.InsertItem(index: Integer; value: TFhirImagingStudySeriesInstance);
begin
  assert(value is TFhirImagingStudySeriesInstance);
  Inherited Insert(index, value);
end;

function TFhirImagingStudySeriesInstanceList.Item(index: Integer): TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance(ObjectByIndex[index]);
end;

function TFhirImagingStudySeriesInstanceList.Link: TFhirImagingStudySeriesInstanceList;
begin
  result := TFhirImagingStudySeriesInstanceList(inherited Link);
end;

procedure TFhirImagingStudySeriesInstanceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImagingStudySeriesInstanceList.SetItemByIndex(index: Integer; value: TFhirImagingStudySeriesInstance);
begin
  assert(value is TFhirImagingStudySeriesInstance);
  FhirImagingStudySeriesInstances[index] := value;
end;

procedure TFhirImagingStudySeriesInstanceList.SetItemN(index: Integer; value: TFhirImagingStudySeriesInstance);
begin
  assert(value is TFhirImagingStudySeriesInstance);
  ObjectByIndex[index] := value;
end;

{ TFhirImagingStudy }

constructor TFhirImagingStudy.Create;
begin
  inherited;
end;

destructor TFhirImagingStudy.Destroy;
begin
  FUid.free;
  FAccession.free;
  FIdentifierList.Free;
  FAvailability.free;
  FModalityListList.Free;
  FPatient.free;
  FContext.free;
  FStarted.free;
  FBasedOnList.Free;
  FReferrer.free;
  FInterpreterList.Free;
  FEndpointList.Free;
  FNumberOfSeries.free;
  FNumberOfInstances.free;
  FProcedureReferenceList.Free;
  FProcedureCodeList.Free;
  FReason.free;
  FDescription.free;
  FSeriesList.Free;
  inherited;
end;

function TFhirImagingStudy.GetResourceType : TFhirResourceType;
begin
  result := frtImagingStudy;
end;

procedure TFhirImagingStudy.Assign(oSource : TFslObject);
begin
  inherited;
  uidElement := TFhirImagingStudy(oSource).uidElement.Clone;
  accession := TFhirImagingStudy(oSource).accession.Clone;
  if (TFhirImagingStudy(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirImagingStudy(oSource).FIdentifierList);
  end;
  FAvailability := TFhirImagingStudy(oSource).FAvailability.Link;
  if (TFhirImagingStudy(oSource).FModalityListList = nil) then
  begin
    FModalityListList.free;
    FModalityListList := nil;
  end
  else
  begin
    if FModalityListList = nil then
      FModalityListList := TFhirCodingList.Create;
    FModalityListList.Assign(TFhirImagingStudy(oSource).FModalityListList);
  end;
  patient := TFhirImagingStudy(oSource).patient.Clone;
  context := TFhirImagingStudy(oSource).context.Clone;
  startedElement := TFhirImagingStudy(oSource).startedElement.Clone;
  if (TFhirImagingStudy(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList{Resource}.Create;
    FBasedOnList.Assign(TFhirImagingStudy(oSource).FBasedOnList);
  end;
  referrer := TFhirImagingStudy(oSource).referrer.Clone;
  if (TFhirImagingStudy(oSource).FInterpreterList = nil) then
  begin
    FInterpreterList.free;
    FInterpreterList := nil;
  end
  else
  begin
    if FInterpreterList = nil then
      FInterpreterList := TFhirReferenceList{TFhirPractitioner}.Create;
    FInterpreterList.Assign(TFhirImagingStudy(oSource).FInterpreterList);
  end;
  if (TFhirImagingStudy(oSource).FEndpointList = nil) then
  begin
    FEndpointList.free;
    FEndpointList := nil;
  end
  else
  begin
    if FEndpointList = nil then
      FEndpointList := TFhirReferenceList{TFhirEndpoint}.Create;
    FEndpointList.Assign(TFhirImagingStudy(oSource).FEndpointList);
  end;
  numberOfSeriesElement := TFhirImagingStudy(oSource).numberOfSeriesElement.Clone;
  numberOfInstancesElement := TFhirImagingStudy(oSource).numberOfInstancesElement.Clone;
  if (TFhirImagingStudy(oSource).FProcedureReferenceList = nil) then
  begin
    FProcedureReferenceList.free;
    FProcedureReferenceList := nil;
  end
  else
  begin
    if FProcedureReferenceList = nil then
      FProcedureReferenceList := TFhirReferenceList{TFhirProcedure}.Create;
    FProcedureReferenceList.Assign(TFhirImagingStudy(oSource).FProcedureReferenceList);
  end;
  if (TFhirImagingStudy(oSource).FProcedureCodeList = nil) then
  begin
    FProcedureCodeList.free;
    FProcedureCodeList := nil;
  end
  else
  begin
    if FProcedureCodeList = nil then
      FProcedureCodeList := TFhirCodeableConceptList.Create;
    FProcedureCodeList.Assign(TFhirImagingStudy(oSource).FProcedureCodeList);
  end;
  reason := TFhirImagingStudy(oSource).reason.Clone;
  descriptionElement := TFhirImagingStudy(oSource).descriptionElement.Clone;
  if (TFhirImagingStudy(oSource).FSeriesList = nil) then
  begin
    FSeriesList.free;
    FSeriesList := nil;
  end
  else
  begin
    if FSeriesList = nil then
      FSeriesList := TFhirImagingStudySeriesList.Create;
    FSeriesList.Assign(TFhirImagingStudy(oSource).FSeriesList);
  end;
end;

procedure TFhirImagingStudy.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'uid') Then
     list.add(self.link, 'uid', FUid.Link);
  if (child_name = 'accession') Then
     list.add(self.link, 'accession', FAccession.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'availability') Then
     list.add(self.link, 'availability', FAvailability.Link);
  if (child_name = 'modalityList') Then
    list.addAll(self, 'modalityList', FModalityListList);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
  if (child_name = 'started') Then
     list.add(self.link, 'started', FStarted.Link);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'referrer') Then
     list.add(self.link, 'referrer', FReferrer.Link);
  if (child_name = 'interpreter') Then
    list.addAll(self, 'interpreter', FInterpreterList);
  if (child_name = 'endpoint') Then
    list.addAll(self, 'endpoint', FEndpointList);
  if (child_name = 'numberOfSeries') Then
     list.add(self.link, 'numberOfSeries', FNumberOfSeries.Link);
  if (child_name = 'numberOfInstances') Then
     list.add(self.link, 'numberOfInstances', FNumberOfInstances.Link);
  if (child_name = 'procedureReference') Then
    list.addAll(self, 'procedureReference', FProcedureReferenceList);
  if (child_name = 'procedureCode') Then
    list.addAll(self, 'procedureCode', FProcedureCodeList);
  if (child_name = 'reason') Then
     list.add(self.link, 'reason', FReason.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'series') Then
    list.addAll(self, 'series', FSeriesList);
end;

procedure TFhirImagingStudy.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'uid', 'oid', false, TFhirOid, FUid.Link));{2}
  oList.add(TFHIRProperty.create(self, 'accession', 'Identifier', false, TFhirIdentifier, FAccession.Link));{2}
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'availability', 'code', false, TFHIREnum, FAvailability.Link));{1}
  oList.add(TFHIRProperty.create(self, 'modalityList', 'Coding', true, TFhirCoding, FModalityListList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'context', 'Reference(Encounter|EpisodeOfCare)', false, TFhirReference{Resource}, FContext.Link));{2}
  oList.add(TFHIRProperty.create(self, 'started', 'dateTime', false, TFhirDateTime, FStarted.Link));{2}
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference(ReferralRequest|CarePlan|ProcedureRequest)', true, TFhirReference{Resource}, FBasedOnList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'referrer', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FReferrer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'interpreter', 'Reference(Practitioner)', true, TFhirReference{TFhirPractitioner}, FInterpreterList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'endpoint', 'Reference(Endpoint)', true, TFhirReference{TFhirEndpoint}, FEndpointList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'numberOfSeries', 'unsignedInt', false, TFhirUnsignedInt, FNumberOfSeries.Link));{2}
  oList.add(TFHIRProperty.create(self, 'numberOfInstances', 'unsignedInt', false, TFhirUnsignedInt, FNumberOfInstances.Link));{2}
  oList.add(TFHIRProperty.create(self, 'procedureReference', 'Reference(Procedure)', true, TFhirReference{TFhirProcedure}, FProcedureReferenceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'procedureCode', 'CodeableConcept', true, TFhirCodeableConcept, FProcedureCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', false, TFhirCodeableConcept, FReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'series', '', true, TFhirImagingStudySeries, FSeriesList.Link)){3};
end;

function TFhirImagingStudy.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'uid') then
  begin
    UidElement := asOid(propValue){5a};
    result := propValue;
  end
  else if (propName = 'accession') then
  begin
    Accession := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'availability') then
  begin
    AvailabilityElement := asEnum(SYSTEMS_TFhirInstanceAvailabilityEnum, CODES_TFhirInstanceAvailabilityEnum, propValue);
    result := propValue
  end
  else if (propName = 'modalityList') then
  begin
    ModalityListList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'context') then
  begin
    Context := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'started') then
  begin
    StartedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'referrer') then
  begin
    Referrer := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'interpreter') then
  begin
    InterpreterList.add(propValue as TFhirReference{TFhirPractitioner}){2a};
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointList.add(propValue as TFhirReference{TFhirEndpoint}){2a};
    result := propValue;
  end
  else if (propName = 'numberOfSeries') then
  begin
    NumberOfSeriesElement := asUnsignedInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'numberOfInstances') then
  begin
    NumberOfInstancesElement := asUnsignedInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'procedureReference') then
  begin
    ProcedureReferenceList.add(propValue as TFhirReference{TFhirProcedure}){2a};
    result := propValue;
  end
  else if (propName = 'procedureCode') then
  begin
    ProcedureCodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    Reason := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'series') then
  begin
    SeriesList.add(propValue as TFhirImagingStudySeries){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirImagingStudy.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'modalityList') then ModalityListList.insertItem(index, propValue as TFhirCoding){2a}
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'interpreter') then InterpreterList.insertItem(index, propValue as TFhirReference{TFhirPractitioner}){2a}
  else if (propName = 'endpoint') then EndpointList.insertItem(index, propValue as TFhirReference{TFhirEndpoint}){2a}
  else if (propName = 'procedureReference') then ProcedureReferenceList.insertItem(index, propValue as TFhirReference{TFhirProcedure}){2a}
  else if (propName = 'procedureCode') then ProcedureCodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'series') then SeriesList.insertItem(index, propValue as TFhirImagingStudySeries){2a}
  else inherited;
end;

function TFhirImagingStudy.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'uid') then result := TFhirOid.create() {5b}
  else if (propName = 'accession') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'modalityList') then result := ModalityListList.new(){2}
  else if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'context') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'started') then result := TFhirDateTime.create() {5b}
  else if (propName = 'basedOn') then result := BasedOnList.new(){2}
  else if (propName = 'referrer') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'interpreter') then result := InterpreterList.new(){2}
  else if (propName = 'endpoint') then result := EndpointList.new(){2}
  else if (propName = 'numberOfSeries') then result := TFhirUnsignedInt.create() {5b}
  else if (propName = 'numberOfInstances') then result := TFhirUnsignedInt.create() {5b}
  else if (propName = 'procedureReference') then result := ProcedureReferenceList.new(){2}
  else if (propName = 'procedureCode') then result := ProcedureCodeList.new(){2}
  else if (propName = 'reason') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'series') then result := SeriesList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImagingStudy.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'uid') then result := 'oid'
  else if (propName = 'accession') then result := 'Identifier'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'availability') then result := 'code'
  else if (propName = 'modalityList') then result := 'Coding'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'context') then result := 'Reference'
  else if (propName = 'started') then result := 'dateTime'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'referrer') then result := 'Reference'
  else if (propName = 'interpreter') then result := 'Reference'
  else if (propName = 'endpoint') then result := 'Reference'
  else if (propName = 'numberOfSeries') then result := 'unsignedInt'
  else if (propName = 'numberOfInstances') then result := 'unsignedInt'
  else if (propName = 'procedureReference') then result := 'Reference'
  else if (propName = 'procedureCode') then result := 'CodeableConcept'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'series') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImagingStudy.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'uid') then UidElement := nil
  else if (propName = 'accession') then AccessionElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'availability') then AvailabilityElement := nil
  else if (propName = 'modalityList') then deletePropertyValue('modalityList', ModalityListList, value) {2}
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'context') then ContextElement := nil
  else if (propName = 'started') then StartedElement := nil
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value) {2}
  else if (propName = 'referrer') then ReferrerElement := nil
  else if (propName = 'interpreter') then deletePropertyValue('interpreter', InterpreterList, value) {2}
  else if (propName = 'endpoint') then deletePropertyValue('endpoint', EndpointList, value) {2}
  else if (propName = 'numberOfSeries') then NumberOfSeriesElement := nil
  else if (propName = 'numberOfInstances') then NumberOfInstancesElement := nil
  else if (propName = 'procedureReference') then deletePropertyValue('procedureReference', ProcedureReferenceList, value) {2}
  else if (propName = 'procedureCode') then deletePropertyValue('procedureCode', ProcedureCodeList, value) {2}
  else if (propName = 'reason') then ReasonElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'series') then deletePropertyValue('series', SeriesList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImagingStudy.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'uid') then UidElement := asOid(new){5b}
  else if (propName = 'accession') then AccessionElement := new as TFhirIdentifier{4}
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'availability') then AvailabilityElement := asEnum(SYSTEMS_TFhirInstanceAvailabilityEnum, CODES_TFhirInstanceAvailabilityEnum, new){4}
  else if (propName = 'modalityList') then replacePropertyValue('modalityList', ModalityListList, existing, new) {2}
  else if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'context') then ContextElement := new as TFhirReference{Resource}{4}
  else if (propName = 'started') then StartedElement := asDateTime(new){5b}
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new) {2}
  else if (propName = 'referrer') then ReferrerElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'interpreter') then replacePropertyValue('interpreter', InterpreterList, existing, new) {2}
  else if (propName = 'endpoint') then replacePropertyValue('endpoint', EndpointList, existing, new) {2}
  else if (propName = 'numberOfSeries') then NumberOfSeriesElement := asUnsignedInt(new){5b}
  else if (propName = 'numberOfInstances') then NumberOfInstancesElement := asUnsignedInt(new){5b}
  else if (propName = 'procedureReference') then replacePropertyValue('procedureReference', ProcedureReferenceList, existing, new) {2}
  else if (propName = 'procedureCode') then replacePropertyValue('procedureCode', ProcedureCodeList, existing, new) {2}
  else if (propName = 'reason') then ReasonElement := new as TFhirCodeableConcept{4}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'series') then replacePropertyValue('series', SeriesList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImagingStudy.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'modalityList') then ModalityListList.move(source, destination){2a}
  else if (propName = 'basedOn') then BasedOnList.move(source, destination){2a}
  else if (propName = 'interpreter') then InterpreterList.move(source, destination){2a}
  else if (propName = 'endpoint') then EndpointList.move(source, destination){2a}
  else if (propName = 'procedureReference') then ProcedureReferenceList.move(source, destination){2a}
  else if (propName = 'procedureCode') then ProcedureCodeList.move(source, destination){2a}
  else if (propName = 'series') then SeriesList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImagingStudy.fhirType : string;
begin
  result := 'ImagingStudy';
end;

function TFhirImagingStudy.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUid) and isEmptyProp(FAccession) and isEmptyProp(FidentifierList) and isEmptyProp(FAvailability) and isEmptyProp(FmodalityListList) and isEmptyProp(FPatient) and isEmptyProp(FContext) and isEmptyProp(FStarted) and isEmptyProp(FbasedOnList) and isEmptyProp(FReferrer) and isEmptyProp(FinterpreterList) and isEmptyProp(FendpointList) and isEmptyProp(FNumberOfSeries) and isEmptyProp(FNumberOfInstances) and isEmptyProp(FprocedureReferenceList) and isEmptyProp(FprocedureCodeList) and isEmptyProp(FReason) and isEmptyProp(FDescription) and isEmptyProp(FseriesList);
end;

function TFhirImagingStudy.equals(other : TObject) : boolean;
var
  o : TFhirImagingStudy;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImagingStudy)) then
    result := false
  else
  begin
    o := TFhirImagingStudy(other);
    result := compareDeep(uidElement, o.uidElement, true) and compareDeep(accessionElement, o.accessionElement, true) and
      compareDeep(identifierList, o.identifierList, true) and compareDeep(availabilityElement, o.availabilityElement, true) and
      compareDeep(modalityListList, o.modalityListList, true) and compareDeep(patientElement, o.patientElement, true) and
      compareDeep(contextElement, o.contextElement, true) and compareDeep(startedElement, o.startedElement, true) and
      compareDeep(basedOnList, o.basedOnList, true) and compareDeep(referrerElement, o.referrerElement, true) and
      compareDeep(interpreterList, o.interpreterList, true) and compareDeep(endpointList, o.endpointList, true) and
      compareDeep(numberOfSeriesElement, o.numberOfSeriesElement, true) and compareDeep(numberOfInstancesElement, o.numberOfInstancesElement, true) and
      compareDeep(procedureReferenceList, o.procedureReferenceList, true) and compareDeep(procedureCodeList, o.procedureCodeList, true) and
      compareDeep(reasonElement, o.reasonElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and
      compareDeep(seriesList, o.seriesList, true);
  end;
end;

function TFhirImagingStudy.Link : TFhirImagingStudy;
begin
  result := TFhirImagingStudy(inherited Link);
end;

function TFhirImagingStudy.Clone : TFhirImagingStudy;
begin
  result := TFhirImagingStudy(inherited Clone);
end;

procedure TFhirImagingStudy.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('uid');
  fields.add('accession');
  fields.add('identifier');
  fields.add('availability');
  fields.add('modalityList');
  fields.add('patient');
  fields.add('context');
  fields.add('started');
  fields.add('basedOn');
  fields.add('referrer');
  fields.add('interpreter');
  fields.add('endpoint');
  fields.add('numberOfSeries');
  fields.add('numberOfInstances');
  fields.add('procedureReference');
  fields.add('procedureCode');
  fields.add('reason');
  fields.add('description');
  fields.add('series');
end;

{ TFhirImagingStudy }

Procedure TFhirImagingStudy.SetUid(value : TFhirOid);
begin
  FUid.free;
  FUid := value;
end;

Function TFhirImagingStudy.GetUidST : String;
begin
  if FUid = nil then
    result := ''
  else
    result := FUid.value;
end;

Procedure TFhirImagingStudy.SetUidST(value : String);
begin
  if value <> '' then
  begin
    if FUid = nil then
      FUid := TFhirOid.create;
    FUid.value := value
  end
  else if FUid <> nil then
    FUid.value := '';
end;

Procedure TFhirImagingStudy.SetAccession(value : TFhirIdentifier);
begin
  FAccession.free;
  FAccession := value;
end;

Function TFhirImagingStudy.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirImagingStudy.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirImagingStudy.SetAvailability(value : TFhirEnum);
begin
  FAvailability.free;
  FAvailability := value;
end;

Function TFhirImagingStudy.GetAvailabilityST : TFhirInstanceAvailabilityEnum;
begin
  if FAvailability = nil then
    result := TFhirInstanceAvailabilityEnum(0)
  else
    result := TFhirInstanceAvailabilityEnum(StringArrayIndexOfSensitive(CODES_TFhirInstanceAvailabilityEnum, FAvailability.value));
end;

Procedure TFhirImagingStudy.SetAvailabilityST(value : TFhirInstanceAvailabilityEnum);
begin
  if ord(value) = 0 then
    AvailabilityElement := nil
  else
    AvailabilityElement := TFhirEnum.create(SYSTEMS_TFhirInstanceAvailabilityEnum[value], CODES_TFhirInstanceAvailabilityEnum[value]);
end;

Function TFhirImagingStudy.GetModalityListList : TFhirCodingList;
begin
  if FModalityListList = nil then
    FModalityListList := TFhirCodingList.Create;
  result := FModalityListList;
end;

Function TFhirImagingStudy.GetHasModalityListList : boolean;
begin
  result := (FModalityListList <> nil) and (FModalityListList.count > 0);
end;

Procedure TFhirImagingStudy.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Procedure TFhirImagingStudy.SetContext(value : TFhirReference{Resource});
begin
  FContext.free;
  FContext := value;
end;

Procedure TFhirImagingStudy.SetStarted(value : TFhirDateTime);
begin
  FStarted.free;
  FStarted := value;
end;

Function TFhirImagingStudy.GetStartedST : TFslDateTime;
begin
  if FStarted = nil then
    result := TFslDateTime.makeNull
  else
    result := FStarted.value;
end;

Procedure TFhirImagingStudy.SetStartedST(value : TFslDateTime);
begin
  if FStarted = nil then
    FStarted := TFhirDateTime.create;
  FStarted.value := value
end;

Function TFhirImagingStudy.GetBasedOnList : TFhirReferenceList{Resource};
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList{Resource}.Create;
  result := FBasedOnList;
end;

Function TFhirImagingStudy.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

Procedure TFhirImagingStudy.SetReferrer(value : TFhirReference{TFhirPractitioner});
begin
  FReferrer.free;
  FReferrer := value;
end;

Function TFhirImagingStudy.GetInterpreterList : TFhirReferenceList{TFhirPractitioner};
begin
  if FInterpreterList = nil then
    FInterpreterList := TFhirReferenceList{TFhirPractitioner}.Create;
  result := FInterpreterList;
end;

Function TFhirImagingStudy.GetHasInterpreterList : boolean;
begin
  result := (FInterpreterList <> nil) and (FInterpreterList.count > 0);
end;

Function TFhirImagingStudy.GetEndpointList : TFhirReferenceList{TFhirEndpoint};
begin
  if FEndpointList = nil then
    FEndpointList := TFhirReferenceList{TFhirEndpoint}.Create;
  result := FEndpointList;
end;

Function TFhirImagingStudy.GetHasEndpointList : boolean;
begin
  result := (FEndpointList <> nil) and (FEndpointList.count > 0);
end;

Procedure TFhirImagingStudy.SetNumberOfSeries(value : TFhirUnsignedInt);
begin
  FNumberOfSeries.free;
  FNumberOfSeries := value;
end;

Function TFhirImagingStudy.GetNumberOfSeriesST : String;
begin
  if FNumberOfSeries = nil then
    result := ''
  else
    result := FNumberOfSeries.value;
end;

Procedure TFhirImagingStudy.SetNumberOfSeriesST(value : String);
begin
  if value <> '' then
  begin
    if FNumberOfSeries = nil then
      FNumberOfSeries := TFhirUnsignedInt.create;
    FNumberOfSeries.value := value
  end
  else if FNumberOfSeries <> nil then
    FNumberOfSeries.value := '';
end;

Procedure TFhirImagingStudy.SetNumberOfInstances(value : TFhirUnsignedInt);
begin
  FNumberOfInstances.free;
  FNumberOfInstances := value;
end;

Function TFhirImagingStudy.GetNumberOfInstancesST : String;
begin
  if FNumberOfInstances = nil then
    result := ''
  else
    result := FNumberOfInstances.value;
end;

Procedure TFhirImagingStudy.SetNumberOfInstancesST(value : String);
begin
  if value <> '' then
  begin
    if FNumberOfInstances = nil then
      FNumberOfInstances := TFhirUnsignedInt.create;
    FNumberOfInstances.value := value
  end
  else if FNumberOfInstances <> nil then
    FNumberOfInstances.value := '';
end;

Function TFhirImagingStudy.GetProcedureReferenceList : TFhirReferenceList{TFhirProcedure};
begin
  if FProcedureReferenceList = nil then
    FProcedureReferenceList := TFhirReferenceList{TFhirProcedure}.Create;
  result := FProcedureReferenceList;
end;

Function TFhirImagingStudy.GetHasProcedureReferenceList : boolean;
begin
  result := (FProcedureReferenceList <> nil) and (FProcedureReferenceList.count > 0);
end;

Function TFhirImagingStudy.GetProcedureCodeList : TFhirCodeableConceptList;
begin
  if FProcedureCodeList = nil then
    FProcedureCodeList := TFhirCodeableConceptList.Create;
  result := FProcedureCodeList;
end;

Function TFhirImagingStudy.GetHasProcedureCodeList : boolean;
begin
  result := (FProcedureCodeList <> nil) and (FProcedureCodeList.count > 0);
end;

Procedure TFhirImagingStudy.SetReason(value : TFhirCodeableConcept);
begin
  FReason.free;
  FReason := value;
end;

Procedure TFhirImagingStudy.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirImagingStudy.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirImagingStudy.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Function TFhirImagingStudy.GetSeriesList : TFhirImagingStudySeriesList;
begin
  if FSeriesList = nil then
    FSeriesList := TFhirImagingStudySeriesList.Create;
  result := FSeriesList;
end;

Function TFhirImagingStudy.GetHasSeriesList : boolean;
begin
  result := (FSeriesList <> nil) and (FSeriesList.count > 0);
end;

function TFhirImagingStudy.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FUid.sizeInBytes);
  inc(result, FAccession.sizeInBytes);
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FAvailability.sizeInBytes);
  inc(result, FmodalityListList.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FContext.sizeInBytes);
  inc(result, FStarted.sizeInBytes);
  inc(result, FbasedOnList.sizeInBytes);
  inc(result, FReferrer.sizeInBytes);
  inc(result, FinterpreterList.sizeInBytes);
  inc(result, FendpointList.sizeInBytes);
  inc(result, FNumberOfSeries.sizeInBytes);
  inc(result, FNumberOfInstances.sizeInBytes);
  inc(result, FprocedureReferenceList.sizeInBytes);
  inc(result, FprocedureCodeList.sizeInBytes);
  inc(result, FReason.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FseriesList.sizeInBytes);
end;

{ TFhirImagingStudyListEnumerator }

Constructor TFhirImagingStudyListEnumerator.Create(list : TFhirImagingStudyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImagingStudyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImagingStudyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImagingStudyListEnumerator.GetCurrent : TFhirImagingStudy;
begin
  Result := FList[FIndex];
end;

function TFhirImagingStudyListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImagingStudyList }
procedure TFhirImagingStudyList.AddItem(value: TFhirImagingStudy);
begin
  assert(value.ClassName = 'TFhirImagingStudy', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImagingStudy');
  add(value);
end;

function TFhirImagingStudyList.Append: TFhirImagingStudy;
begin
  result := TFhirImagingStudy.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingStudyList.ClearItems;
begin
  Clear;
end;

function TFhirImagingStudyList.GetEnumerator : TFhirImagingStudyListEnumerator;
begin
  result := TFhirImagingStudyListEnumerator.Create(self.link);
end;

function TFhirImagingStudyList.Clone: TFhirImagingStudyList;
begin
  result := TFhirImagingStudyList(inherited Clone);
end;

function TFhirImagingStudyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImagingStudyList.GetItemN(index: Integer): TFhirImagingStudy;
begin
  result := TFhirImagingStudy(ObjectByIndex[index]);
end;

function TFhirImagingStudyList.ItemClass: TFslObjectClass;
begin
  result := TFhirImagingStudy;
end;
function TFhirImagingStudyList.IndexOf(value: TFhirImagingStudy): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImagingStudyList.Insert(index: Integer): TFhirImagingStudy;
begin
  result := TFhirImagingStudy.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingStudyList.InsertItem(index: Integer; value: TFhirImagingStudy);
begin
  assert(value is TFhirImagingStudy);
  Inherited Insert(index, value);
end;

function TFhirImagingStudyList.Item(index: Integer): TFhirImagingStudy;
begin
  result := TFhirImagingStudy(ObjectByIndex[index]);
end;

function TFhirImagingStudyList.Link: TFhirImagingStudyList;
begin
  result := TFhirImagingStudyList(inherited Link);
end;

procedure TFhirImagingStudyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImagingStudyList.SetItemByIndex(index: Integer; value: TFhirImagingStudy);
begin
  assert(value is TFhirImagingStudy);
  FhirImagingStudies[index] := value;
end;

procedure TFhirImagingStudyList.SetItemN(index: Integer; value: TFhirImagingStudy);
begin
  assert(value is TFhirImagingStudy);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_IMAGINGSTUDY}

{$IFDEF FHIR_IMMUNIZATION}

{ TFhirImmunizationPractitioner }

constructor TFhirImmunizationPractitioner.Create;
begin
  inherited;
end;

destructor TFhirImmunizationPractitioner.Destroy;
begin
  FRole.free;
  FActor.free;
  inherited;
end;

procedure TFhirImmunizationPractitioner.Assign(oSource : TFslObject);
begin
  inherited;
  role := TFhirImmunizationPractitioner(oSource).role.Clone;
  actor := TFhirImmunizationPractitioner(oSource).actor.Clone;
end;

procedure TFhirImmunizationPractitioner.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'actor') Then
     list.add(self.link, 'actor', FActor.Link);
end;

procedure TFhirImmunizationPractitioner.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));{2}
  oList.add(TFHIRProperty.create(self, 'actor', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FActor.Link));{2}
end;

function TFhirImmunizationPractitioner.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    Actor := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImmunizationPractitioner.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirImmunizationPractitioner.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'role') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'actor') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImmunizationPractitioner.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'actor') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImmunizationPractitioner.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := nil
  else if (propName = 'actor') then ActorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImmunizationPractitioner.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := new as TFhirCodeableConcept{4}
  else if (propName = 'actor') then ActorElement := new as TFhirReference{TFhirPractitioner}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImmunizationPractitioner.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirImmunizationPractitioner.fhirType : string;
begin
  result := 'practitioner';
end;

function TFhirImmunizationPractitioner.Link : TFhirImmunizationPractitioner;
begin
  result := TFhirImmunizationPractitioner(inherited Link);
end;

function TFhirImmunizationPractitioner.Clone : TFhirImmunizationPractitioner;
begin
  result := TFhirImmunizationPractitioner(inherited Clone);
end;

function TFhirImmunizationPractitioner.equals(other : TObject) : boolean;
var
  o : TFhirImmunizationPractitioner;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImmunizationPractitioner)) then
    result := false
  else
  begin
    o := TFhirImmunizationPractitioner(other);
    result := compareDeep(roleElement, o.roleElement, true) and compareDeep(actorElement, o.actorElement, true);
  end;
end;

function TFhirImmunizationPractitioner.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRole) and isEmptyProp(FActor);
end;

procedure TFhirImmunizationPractitioner.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('role');
  fields.add('actor');
end;

{ TFhirImmunizationPractitioner }

Procedure TFhirImmunizationPractitioner.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

Procedure TFhirImmunizationPractitioner.SetActor(value : TFhirReference{TFhirPractitioner});
begin
  FActor.free;
  FActor := value;
end;

function TFhirImmunizationPractitioner.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FRole.sizeInBytes);
  inc(result, FActor.sizeInBytes);
end;

{ TFhirImmunizationPractitionerListEnumerator }

Constructor TFhirImmunizationPractitionerListEnumerator.Create(list : TFhirImmunizationPractitionerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImmunizationPractitionerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImmunizationPractitionerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImmunizationPractitionerListEnumerator.GetCurrent : TFhirImmunizationPractitioner;
begin
  Result := FList[FIndex];
end;

function TFhirImmunizationPractitionerListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImmunizationPractitionerList }
procedure TFhirImmunizationPractitionerList.AddItem(value: TFhirImmunizationPractitioner);
begin
  assert(value.ClassName = 'TFhirImmunizationPractitioner', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationPractitioner');
  add(value);
end;

function TFhirImmunizationPractitionerList.Append: TFhirImmunizationPractitioner;
begin
  result := TFhirImmunizationPractitioner.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationPractitionerList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationPractitionerList.GetEnumerator : TFhirImmunizationPractitionerListEnumerator;
begin
  result := TFhirImmunizationPractitionerListEnumerator.Create(self.link);
end;

function TFhirImmunizationPractitionerList.Clone: TFhirImmunizationPractitionerList;
begin
  result := TFhirImmunizationPractitionerList(inherited Clone);
end;

function TFhirImmunizationPractitionerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationPractitionerList.GetItemN(index: Integer): TFhirImmunizationPractitioner;
begin
  result := TFhirImmunizationPractitioner(ObjectByIndex[index]);
end;

function TFhirImmunizationPractitionerList.ItemClass: TFslObjectClass;
begin
  result := TFhirImmunizationPractitioner;
end;
function TFhirImmunizationPractitionerList.IndexOf(value: TFhirImmunizationPractitioner): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImmunizationPractitionerList.Insert(index: Integer): TFhirImmunizationPractitioner;
begin
  result := TFhirImmunizationPractitioner.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationPractitionerList.InsertItem(index: Integer; value: TFhirImmunizationPractitioner);
begin
  assert(value is TFhirImmunizationPractitioner);
  Inherited Insert(index, value);
end;

function TFhirImmunizationPractitionerList.Item(index: Integer): TFhirImmunizationPractitioner;
begin
  result := TFhirImmunizationPractitioner(ObjectByIndex[index]);
end;

function TFhirImmunizationPractitionerList.Link: TFhirImmunizationPractitionerList;
begin
  result := TFhirImmunizationPractitionerList(inherited Link);
end;

procedure TFhirImmunizationPractitionerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationPractitionerList.SetItemByIndex(index: Integer; value: TFhirImmunizationPractitioner);
begin
  assert(value is TFhirImmunizationPractitioner);
  FhirImmunizationPractitioners[index] := value;
end;

procedure TFhirImmunizationPractitionerList.SetItemN(index: Integer; value: TFhirImmunizationPractitioner);
begin
  assert(value is TFhirImmunizationPractitioner);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunizationExplanation }

constructor TFhirImmunizationExplanation.Create;
begin
  inherited;
end;

destructor TFhirImmunizationExplanation.Destroy;
begin
  FReasonList.Free;
  FReasonNotGivenList.Free;
  inherited;
end;

procedure TFhirImmunizationExplanation.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirImmunizationExplanation(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableConceptList.Create;
    FReasonList.Assign(TFhirImmunizationExplanation(oSource).FReasonList);
  end;
  if (TFhirImmunizationExplanation(oSource).FReasonNotGivenList = nil) then
  begin
    FReasonNotGivenList.free;
    FReasonNotGivenList := nil;
  end
  else
  begin
    if FReasonNotGivenList = nil then
      FReasonNotGivenList := TFhirCodeableConceptList.Create;
    FReasonNotGivenList.Assign(TFhirImmunizationExplanation(oSource).FReasonNotGivenList);
  end;
end;

procedure TFhirImmunizationExplanation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'reasonNotGiven') Then
    list.addAll(self, 'reasonNotGiven', FReasonNotGivenList);
end;

procedure TFhirImmunizationExplanation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', true, TFhirCodeableConcept, FReasonList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reasonNotGiven', 'CodeableConcept', true, TFhirCodeableConcept, FReasonNotGivenList.Link)){3};
end;

function TFhirImmunizationExplanation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'reasonNotGiven') then
  begin
    ReasonNotGivenList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImmunizationExplanation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'reasonNotGiven') then ReasonNotGivenList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirImmunizationExplanation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'reason') then result := ReasonList.new(){2}
  else if (propName = 'reasonNotGiven') then result := ReasonNotGivenList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImmunizationExplanation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'reason') then result := 'CodeableConcept'
  else if (propName = 'reasonNotGiven') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImmunizationExplanation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value) {2}
  else if (propName = 'reasonNotGiven') then deletePropertyValue('reasonNotGiven', ReasonNotGivenList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImmunizationExplanation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new) {2}
  else if (propName = 'reasonNotGiven') then replacePropertyValue('reasonNotGiven', ReasonNotGivenList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImmunizationExplanation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'reason') then ReasonList.move(source, destination){2a}
  else if (propName = 'reasonNotGiven') then ReasonNotGivenList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImmunizationExplanation.fhirType : string;
begin
  result := 'explanation';
end;

function TFhirImmunizationExplanation.Link : TFhirImmunizationExplanation;
begin
  result := TFhirImmunizationExplanation(inherited Link);
end;

function TFhirImmunizationExplanation.Clone : TFhirImmunizationExplanation;
begin
  result := TFhirImmunizationExplanation(inherited Clone);
end;

function TFhirImmunizationExplanation.equals(other : TObject) : boolean;
var
  o : TFhirImmunizationExplanation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImmunizationExplanation)) then
    result := false
  else
  begin
    o := TFhirImmunizationExplanation(other);
    result := compareDeep(reasonList, o.reasonList, true) and compareDeep(reasonNotGivenList, o.reasonNotGivenList, true);
  end;
end;

function TFhirImmunizationExplanation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FreasonList) and isEmptyProp(FreasonNotGivenList);
end;

procedure TFhirImmunizationExplanation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('reason');
  fields.add('reasonNotGiven');
end;

{ TFhirImmunizationExplanation }

Function TFhirImmunizationExplanation.GetReasonList : TFhirCodeableConceptList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableConceptList.Create;
  result := FReasonList;
end;

Function TFhirImmunizationExplanation.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

Function TFhirImmunizationExplanation.GetReasonNotGivenList : TFhirCodeableConceptList;
begin
  if FReasonNotGivenList = nil then
    FReasonNotGivenList := TFhirCodeableConceptList.Create;
  result := FReasonNotGivenList;
end;

Function TFhirImmunizationExplanation.GetHasReasonNotGivenList : boolean;
begin
  result := (FReasonNotGivenList <> nil) and (FReasonNotGivenList.count > 0);
end;

function TFhirImmunizationExplanation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FreasonList.sizeInBytes);
  inc(result, FreasonNotGivenList.sizeInBytes);
end;

{ TFhirImmunizationExplanationListEnumerator }

Constructor TFhirImmunizationExplanationListEnumerator.Create(list : TFhirImmunizationExplanationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImmunizationExplanationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImmunizationExplanationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImmunizationExplanationListEnumerator.GetCurrent : TFhirImmunizationExplanation;
begin
  Result := FList[FIndex];
end;

function TFhirImmunizationExplanationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImmunizationExplanationList }
procedure TFhirImmunizationExplanationList.AddItem(value: TFhirImmunizationExplanation);
begin
  assert(value.ClassName = 'TFhirImmunizationExplanation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationExplanation');
  add(value);
end;

function TFhirImmunizationExplanationList.Append: TFhirImmunizationExplanation;
begin
  result := TFhirImmunizationExplanation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationExplanationList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationExplanationList.GetEnumerator : TFhirImmunizationExplanationListEnumerator;
begin
  result := TFhirImmunizationExplanationListEnumerator.Create(self.link);
end;

function TFhirImmunizationExplanationList.Clone: TFhirImmunizationExplanationList;
begin
  result := TFhirImmunizationExplanationList(inherited Clone);
end;

function TFhirImmunizationExplanationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationExplanationList.GetItemN(index: Integer): TFhirImmunizationExplanation;
begin
  result := TFhirImmunizationExplanation(ObjectByIndex[index]);
end;

function TFhirImmunizationExplanationList.ItemClass: TFslObjectClass;
begin
  result := TFhirImmunizationExplanation;
end;
function TFhirImmunizationExplanationList.IndexOf(value: TFhirImmunizationExplanation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImmunizationExplanationList.Insert(index: Integer): TFhirImmunizationExplanation;
begin
  result := TFhirImmunizationExplanation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationExplanationList.InsertItem(index: Integer; value: TFhirImmunizationExplanation);
begin
  assert(value is TFhirImmunizationExplanation);
  Inherited Insert(index, value);
end;

function TFhirImmunizationExplanationList.Item(index: Integer): TFhirImmunizationExplanation;
begin
  result := TFhirImmunizationExplanation(ObjectByIndex[index]);
end;

function TFhirImmunizationExplanationList.Link: TFhirImmunizationExplanationList;
begin
  result := TFhirImmunizationExplanationList(inherited Link);
end;

procedure TFhirImmunizationExplanationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationExplanationList.SetItemByIndex(index: Integer; value: TFhirImmunizationExplanation);
begin
  assert(value is TFhirImmunizationExplanation);
  FhirImmunizationExplanations[index] := value;
end;

procedure TFhirImmunizationExplanationList.SetItemN(index: Integer; value: TFhirImmunizationExplanation);
begin
  assert(value is TFhirImmunizationExplanation);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunizationReaction }

constructor TFhirImmunizationReaction.Create;
begin
  inherited;
end;

destructor TFhirImmunizationReaction.Destroy;
begin
  FDate.free;
  FDetail.free;
  FReported.free;
  inherited;
end;

procedure TFhirImmunizationReaction.Assign(oSource : TFslObject);
begin
  inherited;
  dateElement := TFhirImmunizationReaction(oSource).dateElement.Clone;
  detail := TFhirImmunizationReaction(oSource).detail.Clone;
  reportedElement := TFhirImmunizationReaction(oSource).reportedElement.Clone;
end;

procedure TFhirImmunizationReaction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'detail') Then
     list.add(self.link, 'detail', FDetail.Link);
  if (child_name = 'reported') Then
     list.add(self.link, 'reported', FReported.Link);
end;

procedure TFhirImmunizationReaction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'detail', 'Reference(Observation)', false, TFhirReference{TFhirObservation}, FDetail.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reported', 'boolean', false, TFhirBoolean, FReported.Link));{2}
end;

function TFhirImmunizationReaction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    Detail := propValue as TFhirReference{TFhirObservation}{4b};
    result := propValue;
  end
  else if (propName = 'reported') then
  begin
    ReportedElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImmunizationReaction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirImmunizationReaction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'detail') then result := TFhirReference{TFhirObservation}.create(){4b}
  else if (propName = 'reported') then result := TFhirBoolean.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImmunizationReaction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'date') then result := 'dateTime'
  else if (propName = 'detail') then result := 'Reference'
  else if (propName = 'reported') then result := 'boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImmunizationReaction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'date') then DateElement := nil
  else if (propName = 'detail') then DetailElement := nil
  else if (propName = 'reported') then ReportedElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImmunizationReaction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'detail') then DetailElement := new as TFhirReference{TFhirObservation}{4}
  else if (propName = 'reported') then ReportedElement := asBoolean(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImmunizationReaction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirImmunizationReaction.fhirType : string;
begin
  result := 'reaction';
end;

function TFhirImmunizationReaction.Link : TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction(inherited Link);
end;

function TFhirImmunizationReaction.Clone : TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction(inherited Clone);
end;

function TFhirImmunizationReaction.equals(other : TObject) : boolean;
var
  o : TFhirImmunizationReaction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImmunizationReaction)) then
    result := false
  else
  begin
    o := TFhirImmunizationReaction(other);
    result := compareDeep(dateElement, o.dateElement, true) and compareDeep(detailElement, o.detailElement, true) and
      compareDeep(reportedElement, o.reportedElement, true);
  end;
end;

function TFhirImmunizationReaction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDate) and isEmptyProp(FDetail) and isEmptyProp(FReported);
end;

procedure TFhirImmunizationReaction.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('date');
  fields.add('detail');
  fields.add('reported');
end;

{ TFhirImmunizationReaction }

Procedure TFhirImmunizationReaction.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirImmunizationReaction.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirImmunizationReaction.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirImmunizationReaction.SetDetail(value : TFhirReference{TFhirObservation});
begin
  FDetail.free;
  FDetail := value;
end;

Procedure TFhirImmunizationReaction.SetReported(value : TFhirBoolean);
begin
  FReported.free;
  FReported := value;
end;

Function TFhirImmunizationReaction.GetReportedST : Boolean;
begin
  if FReported = nil then
    result := false
  else
    result := FReported.value;
end;

Procedure TFhirImmunizationReaction.SetReportedST(value : Boolean);
begin
  if FReported = nil then
    FReported := TFhirBoolean.create;
  FReported.value := value
end;

function TFhirImmunizationReaction.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDate.sizeInBytes);
  inc(result, FDetail.sizeInBytes);
  inc(result, FReported.sizeInBytes);
end;

{ TFhirImmunizationReactionListEnumerator }

Constructor TFhirImmunizationReactionListEnumerator.Create(list : TFhirImmunizationReactionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImmunizationReactionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImmunizationReactionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImmunizationReactionListEnumerator.GetCurrent : TFhirImmunizationReaction;
begin
  Result := FList[FIndex];
end;

function TFhirImmunizationReactionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImmunizationReactionList }
procedure TFhirImmunizationReactionList.AddItem(value: TFhirImmunizationReaction);
begin
  assert(value.ClassName = 'TFhirImmunizationReaction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationReaction');
  add(value);
end;

function TFhirImmunizationReactionList.Append: TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationReactionList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationReactionList.GetEnumerator : TFhirImmunizationReactionListEnumerator;
begin
  result := TFhirImmunizationReactionListEnumerator.Create(self.link);
end;

function TFhirImmunizationReactionList.Clone: TFhirImmunizationReactionList;
begin
  result := TFhirImmunizationReactionList(inherited Clone);
end;

function TFhirImmunizationReactionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationReactionList.GetItemN(index: Integer): TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction(ObjectByIndex[index]);
end;

function TFhirImmunizationReactionList.ItemClass: TFslObjectClass;
begin
  result := TFhirImmunizationReaction;
end;
function TFhirImmunizationReactionList.IndexOf(value: TFhirImmunizationReaction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImmunizationReactionList.Insert(index: Integer): TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationReactionList.InsertItem(index: Integer; value: TFhirImmunizationReaction);
begin
  assert(value is TFhirImmunizationReaction);
  Inherited Insert(index, value);
end;

function TFhirImmunizationReactionList.Item(index: Integer): TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction(ObjectByIndex[index]);
end;

function TFhirImmunizationReactionList.Link: TFhirImmunizationReactionList;
begin
  result := TFhirImmunizationReactionList(inherited Link);
end;

procedure TFhirImmunizationReactionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationReactionList.SetItemByIndex(index: Integer; value: TFhirImmunizationReaction);
begin
  assert(value is TFhirImmunizationReaction);
  FhirImmunizationReactions[index] := value;
end;

procedure TFhirImmunizationReactionList.SetItemN(index: Integer; value: TFhirImmunizationReaction);
begin
  assert(value is TFhirImmunizationReaction);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunizationVaccinationProtocol }

constructor TFhirImmunizationVaccinationProtocol.Create;
begin
  inherited;
end;

destructor TFhirImmunizationVaccinationProtocol.Destroy;
begin
  FDoseSequence.free;
  FDescription.free;
  FAuthority.free;
  FSeries.free;
  FSeriesDoses.free;
  FTargetDiseaseList.Free;
  FDoseStatus.free;
  FDoseStatusReason.free;
  inherited;
end;

procedure TFhirImmunizationVaccinationProtocol.Assign(oSource : TFslObject);
begin
  inherited;
  doseSequenceElement := TFhirImmunizationVaccinationProtocol(oSource).doseSequenceElement.Clone;
  descriptionElement := TFhirImmunizationVaccinationProtocol(oSource).descriptionElement.Clone;
  authority := TFhirImmunizationVaccinationProtocol(oSource).authority.Clone;
  seriesElement := TFhirImmunizationVaccinationProtocol(oSource).seriesElement.Clone;
  seriesDosesElement := TFhirImmunizationVaccinationProtocol(oSource).seriesDosesElement.Clone;
  if (TFhirImmunizationVaccinationProtocol(oSource).FTargetDiseaseList = nil) then
  begin
    FTargetDiseaseList.free;
    FTargetDiseaseList := nil;
  end
  else
  begin
    if FTargetDiseaseList = nil then
      FTargetDiseaseList := TFhirCodeableConceptList.Create;
    FTargetDiseaseList.Assign(TFhirImmunizationVaccinationProtocol(oSource).FTargetDiseaseList);
  end;
  doseStatus := TFhirImmunizationVaccinationProtocol(oSource).doseStatus.Clone;
  doseStatusReason := TFhirImmunizationVaccinationProtocol(oSource).doseStatusReason.Clone;
end;

procedure TFhirImmunizationVaccinationProtocol.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'doseSequence') Then
     list.add(self.link, 'doseSequence', FDoseSequence.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'authority') Then
     list.add(self.link, 'authority', FAuthority.Link);
  if (child_name = 'series') Then
     list.add(self.link, 'series', FSeries.Link);
  if (child_name = 'seriesDoses') Then
     list.add(self.link, 'seriesDoses', FSeriesDoses.Link);
  if (child_name = 'targetDisease') Then
    list.addAll(self, 'targetDisease', FTargetDiseaseList);
  if (child_name = 'doseStatus') Then
     list.add(self.link, 'doseStatus', FDoseStatus.Link);
  if (child_name = 'doseStatusReason') Then
     list.add(self.link, 'doseStatusReason', FDoseStatusReason.Link);
end;

procedure TFhirImmunizationVaccinationProtocol.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'doseSequence', 'positiveInt', false, TFhirPositiveInt, FDoseSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'authority', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FAuthority.Link));{2}
  oList.add(TFHIRProperty.create(self, 'series', 'string', false, TFhirString, FSeries.Link));{2}
  oList.add(TFHIRProperty.create(self, 'seriesDoses', 'positiveInt', false, TFhirPositiveInt, FSeriesDoses.Link));{2}
  oList.add(TFHIRProperty.create(self, 'targetDisease', 'CodeableConcept', true, TFhirCodeableConcept, FTargetDiseaseList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'doseStatus', 'CodeableConcept', false, TFhirCodeableConcept, FDoseStatus.Link));{2}
  oList.add(TFHIRProperty.create(self, 'doseStatusReason', 'CodeableConcept', false, TFhirCodeableConcept, FDoseStatusReason.Link));{2}
end;

function TFhirImmunizationVaccinationProtocol.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'doseSequence') then
  begin
    DoseSequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'authority') then
  begin
    Authority := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'series') then
  begin
    SeriesElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'seriesDoses') then
  begin
    SeriesDosesElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'targetDisease') then
  begin
    TargetDiseaseList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'doseStatus') then
  begin
    DoseStatus := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'doseStatusReason') then
  begin
    DoseStatusReason := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImmunizationVaccinationProtocol.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'targetDisease') then TargetDiseaseList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirImmunizationVaccinationProtocol.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'doseSequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'authority') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'series') then result := TFhirString.create() {5b}
  else if (propName = 'seriesDoses') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'targetDisease') then result := TargetDiseaseList.new(){2}
  else if (propName = 'doseStatus') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'doseStatusReason') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImmunizationVaccinationProtocol.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'doseSequence') then result := 'positiveInt'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'authority') then result := 'Reference'
  else if (propName = 'series') then result := 'string'
  else if (propName = 'seriesDoses') then result := 'positiveInt'
  else if (propName = 'targetDisease') then result := 'CodeableConcept'
  else if (propName = 'doseStatus') then result := 'CodeableConcept'
  else if (propName = 'doseStatusReason') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImmunizationVaccinationProtocol.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'doseSequence') then DoseSequenceElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'authority') then AuthorityElement := nil
  else if (propName = 'series') then SeriesElement := nil
  else if (propName = 'seriesDoses') then SeriesDosesElement := nil
  else if (propName = 'targetDisease') then deletePropertyValue('targetDisease', TargetDiseaseList, value) {2}
  else if (propName = 'doseStatus') then DoseStatusElement := nil
  else if (propName = 'doseStatusReason') then DoseStatusReasonElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImmunizationVaccinationProtocol.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'doseSequence') then DoseSequenceElement := asPositiveInt(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'authority') then AuthorityElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'series') then SeriesElement := asString(new){5b}
  else if (propName = 'seriesDoses') then SeriesDosesElement := asPositiveInt(new){5b}
  else if (propName = 'targetDisease') then replacePropertyValue('targetDisease', TargetDiseaseList, existing, new) {2}
  else if (propName = 'doseStatus') then DoseStatusElement := new as TFhirCodeableConcept{4}
  else if (propName = 'doseStatusReason') then DoseStatusReasonElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImmunizationVaccinationProtocol.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'targetDisease') then TargetDiseaseList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImmunizationVaccinationProtocol.fhirType : string;
begin
  result := 'vaccinationProtocol';
end;

function TFhirImmunizationVaccinationProtocol.Link : TFhirImmunizationVaccinationProtocol;
begin
  result := TFhirImmunizationVaccinationProtocol(inherited Link);
end;

function TFhirImmunizationVaccinationProtocol.Clone : TFhirImmunizationVaccinationProtocol;
begin
  result := TFhirImmunizationVaccinationProtocol(inherited Clone);
end;

function TFhirImmunizationVaccinationProtocol.equals(other : TObject) : boolean;
var
  o : TFhirImmunizationVaccinationProtocol;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImmunizationVaccinationProtocol)) then
    result := false
  else
  begin
    o := TFhirImmunizationVaccinationProtocol(other);
    result := compareDeep(doseSequenceElement, o.doseSequenceElement, true) and
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(authorityElement, o.authorityElement, true) and
      compareDeep(seriesElement, o.seriesElement, true) and compareDeep(seriesDosesElement, o.seriesDosesElement, true) and
      compareDeep(targetDiseaseList, o.targetDiseaseList, true) and compareDeep(doseStatusElement, o.doseStatusElement, true) and
      compareDeep(doseStatusReasonElement, o.doseStatusReasonElement, true);
  end;
end;

function TFhirImmunizationVaccinationProtocol.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDoseSequence) and isEmptyProp(FDescription) and isEmptyProp(FAuthority) and isEmptyProp(FSeries) and isEmptyProp(FSeriesDoses) and isEmptyProp(FtargetDiseaseList) and isEmptyProp(FDoseStatus) and isEmptyProp(FDoseStatusReason);
end;

procedure TFhirImmunizationVaccinationProtocol.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('doseSequence');
  fields.add('description');
  fields.add('authority');
  fields.add('series');
  fields.add('seriesDoses');
  fields.add('targetDisease');
  fields.add('doseStatus');
  fields.add('doseStatusReason');
end;

{ TFhirImmunizationVaccinationProtocol }

Procedure TFhirImmunizationVaccinationProtocol.SetDoseSequence(value : TFhirPositiveInt);
begin
  FDoseSequence.free;
  FDoseSequence := value;
end;

Function TFhirImmunizationVaccinationProtocol.GetDoseSequenceST : String;
begin
  if FDoseSequence = nil then
    result := ''
  else
    result := FDoseSequence.value;
end;

Procedure TFhirImmunizationVaccinationProtocol.SetDoseSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FDoseSequence = nil then
      FDoseSequence := TFhirPositiveInt.create;
    FDoseSequence.value := value
  end
  else if FDoseSequence <> nil then
    FDoseSequence.value := '';
end;

Procedure TFhirImmunizationVaccinationProtocol.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirImmunizationVaccinationProtocol.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirImmunizationVaccinationProtocol.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirImmunizationVaccinationProtocol.SetAuthority(value : TFhirReference{TFhirOrganization});
begin
  FAuthority.free;
  FAuthority := value;
end;

Procedure TFhirImmunizationVaccinationProtocol.SetSeries(value : TFhirString);
begin
  FSeries.free;
  FSeries := value;
end;

Function TFhirImmunizationVaccinationProtocol.GetSeriesST : String;
begin
  if FSeries = nil then
    result := ''
  else
    result := FSeries.value;
end;

Procedure TFhirImmunizationVaccinationProtocol.SetSeriesST(value : String);
begin
  if value <> '' then
  begin
    if FSeries = nil then
      FSeries := TFhirString.create;
    FSeries.value := value
  end
  else if FSeries <> nil then
    FSeries.value := '';
end;

Procedure TFhirImmunizationVaccinationProtocol.SetSeriesDoses(value : TFhirPositiveInt);
begin
  FSeriesDoses.free;
  FSeriesDoses := value;
end;

Function TFhirImmunizationVaccinationProtocol.GetSeriesDosesST : String;
begin
  if FSeriesDoses = nil then
    result := ''
  else
    result := FSeriesDoses.value;
end;

Procedure TFhirImmunizationVaccinationProtocol.SetSeriesDosesST(value : String);
begin
  if value <> '' then
  begin
    if FSeriesDoses = nil then
      FSeriesDoses := TFhirPositiveInt.create;
    FSeriesDoses.value := value
  end
  else if FSeriesDoses <> nil then
    FSeriesDoses.value := '';
end;

Function TFhirImmunizationVaccinationProtocol.GetTargetDiseaseList : TFhirCodeableConceptList;
begin
  if FTargetDiseaseList = nil then
    FTargetDiseaseList := TFhirCodeableConceptList.Create;
  result := FTargetDiseaseList;
end;

Function TFhirImmunizationVaccinationProtocol.GetHasTargetDiseaseList : boolean;
begin
  result := (FTargetDiseaseList <> nil) and (FTargetDiseaseList.count > 0);
end;

Procedure TFhirImmunizationVaccinationProtocol.SetDoseStatus(value : TFhirCodeableConcept);
begin
  FDoseStatus.free;
  FDoseStatus := value;
end;

Procedure TFhirImmunizationVaccinationProtocol.SetDoseStatusReason(value : TFhirCodeableConcept);
begin
  FDoseStatusReason.free;
  FDoseStatusReason := value;
end;

function TFhirImmunizationVaccinationProtocol.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDoseSequence.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FAuthority.sizeInBytes);
  inc(result, FSeries.sizeInBytes);
  inc(result, FSeriesDoses.sizeInBytes);
  inc(result, FtargetDiseaseList.sizeInBytes);
  inc(result, FDoseStatus.sizeInBytes);
  inc(result, FDoseStatusReason.sizeInBytes);
end;

{ TFhirImmunizationVaccinationProtocolListEnumerator }

Constructor TFhirImmunizationVaccinationProtocolListEnumerator.Create(list : TFhirImmunizationVaccinationProtocolList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImmunizationVaccinationProtocolListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImmunizationVaccinationProtocolListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImmunizationVaccinationProtocolListEnumerator.GetCurrent : TFhirImmunizationVaccinationProtocol;
begin
  Result := FList[FIndex];
end;

function TFhirImmunizationVaccinationProtocolListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImmunizationVaccinationProtocolList }
procedure TFhirImmunizationVaccinationProtocolList.AddItem(value: TFhirImmunizationVaccinationProtocol);
begin
  assert(value.ClassName = 'TFhirImmunizationVaccinationProtocol', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationVaccinationProtocol');
  add(value);
end;

function TFhirImmunizationVaccinationProtocolList.Append: TFhirImmunizationVaccinationProtocol;
begin
  result := TFhirImmunizationVaccinationProtocol.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationVaccinationProtocolList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationVaccinationProtocolList.GetEnumerator : TFhirImmunizationVaccinationProtocolListEnumerator;
begin
  result := TFhirImmunizationVaccinationProtocolListEnumerator.Create(self.link);
end;

function TFhirImmunizationVaccinationProtocolList.Clone: TFhirImmunizationVaccinationProtocolList;
begin
  result := TFhirImmunizationVaccinationProtocolList(inherited Clone);
end;

function TFhirImmunizationVaccinationProtocolList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationVaccinationProtocolList.GetItemN(index: Integer): TFhirImmunizationVaccinationProtocol;
begin
  result := TFhirImmunizationVaccinationProtocol(ObjectByIndex[index]);
end;

function TFhirImmunizationVaccinationProtocolList.ItemClass: TFslObjectClass;
begin
  result := TFhirImmunizationVaccinationProtocol;
end;
function TFhirImmunizationVaccinationProtocolList.IndexOf(value: TFhirImmunizationVaccinationProtocol): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImmunizationVaccinationProtocolList.Insert(index: Integer): TFhirImmunizationVaccinationProtocol;
begin
  result := TFhirImmunizationVaccinationProtocol.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationVaccinationProtocolList.InsertItem(index: Integer; value: TFhirImmunizationVaccinationProtocol);
begin
  assert(value is TFhirImmunizationVaccinationProtocol);
  Inherited Insert(index, value);
end;

function TFhirImmunizationVaccinationProtocolList.Item(index: Integer): TFhirImmunizationVaccinationProtocol;
begin
  result := TFhirImmunizationVaccinationProtocol(ObjectByIndex[index]);
end;

function TFhirImmunizationVaccinationProtocolList.Link: TFhirImmunizationVaccinationProtocolList;
begin
  result := TFhirImmunizationVaccinationProtocolList(inherited Link);
end;

procedure TFhirImmunizationVaccinationProtocolList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationVaccinationProtocolList.SetItemByIndex(index: Integer; value: TFhirImmunizationVaccinationProtocol);
begin
  assert(value is TFhirImmunizationVaccinationProtocol);
  FhirImmunizationVaccinationProtocols[index] := value;
end;

procedure TFhirImmunizationVaccinationProtocolList.SetItemN(index: Integer; value: TFhirImmunizationVaccinationProtocol);
begin
  assert(value is TFhirImmunizationVaccinationProtocol);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunization }

constructor TFhirImmunization.Create;
begin
  inherited;
end;

destructor TFhirImmunization.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FNotGiven.free;
  FVaccineCode.free;
  FPatient.free;
  FEncounter.free;
  FDate.free;
  FPrimarySource.free;
  FReportOrigin.free;
  FLocation.free;
  FManufacturer.free;
  FLotNumber.free;
  FExpirationDate.free;
  FSite.free;
  FRoute.free;
  FDoseQuantity.free;
  FPractitionerList.Free;
  FNoteList.Free;
  FExplanation.free;
  FReactionList.Free;
  FVaccinationProtocolList.Free;
  inherited;
end;

function TFhirImmunization.GetResourceType : TFhirResourceType;
begin
  result := frtImmunization;
end;

procedure TFhirImmunization.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirImmunization(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirImmunization(oSource).FIdentifierList);
  end;
  FStatus := TFhirImmunization(oSource).FStatus.Link;
  notGivenElement := TFhirImmunization(oSource).notGivenElement.Clone;
  vaccineCode := TFhirImmunization(oSource).vaccineCode.Clone;
  patient := TFhirImmunization(oSource).patient.Clone;
  encounter := TFhirImmunization(oSource).encounter.Clone;
  dateElement := TFhirImmunization(oSource).dateElement.Clone;
  primarySourceElement := TFhirImmunization(oSource).primarySourceElement.Clone;
  reportOrigin := TFhirImmunization(oSource).reportOrigin.Clone;
  location := TFhirImmunization(oSource).location.Clone;
  manufacturer := TFhirImmunization(oSource).manufacturer.Clone;
  lotNumberElement := TFhirImmunization(oSource).lotNumberElement.Clone;
  expirationDateElement := TFhirImmunization(oSource).expirationDateElement.Clone;
  site := TFhirImmunization(oSource).site.Clone;
  route := TFhirImmunization(oSource).route.Clone;
  doseQuantity := TFhirImmunization(oSource).doseQuantity.Clone;
  if (TFhirImmunization(oSource).FPractitionerList = nil) then
  begin
    FPractitionerList.free;
    FPractitionerList := nil;
  end
  else
  begin
    if FPractitionerList = nil then
      FPractitionerList := TFhirImmunizationPractitionerList.Create;
    FPractitionerList.Assign(TFhirImmunization(oSource).FPractitionerList);
  end;
  if (TFhirImmunization(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirImmunization(oSource).FNoteList);
  end;
  explanation := TFhirImmunization(oSource).explanation.Clone;
  if (TFhirImmunization(oSource).FReactionList = nil) then
  begin
    FReactionList.free;
    FReactionList := nil;
  end
  else
  begin
    if FReactionList = nil then
      FReactionList := TFhirImmunizationReactionList.Create;
    FReactionList.Assign(TFhirImmunization(oSource).FReactionList);
  end;
  if (TFhirImmunization(oSource).FVaccinationProtocolList = nil) then
  begin
    FVaccinationProtocolList.free;
    FVaccinationProtocolList := nil;
  end
  else
  begin
    if FVaccinationProtocolList = nil then
      FVaccinationProtocolList := TFhirImmunizationVaccinationProtocolList.Create;
    FVaccinationProtocolList.Assign(TFhirImmunization(oSource).FVaccinationProtocolList);
  end;
end;

procedure TFhirImmunization.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'notGiven') Then
     list.add(self.link, 'notGiven', FNotGiven.Link);
  if (child_name = 'vaccineCode') Then
     list.add(self.link, 'vaccineCode', FVaccineCode.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'primarySource') Then
     list.add(self.link, 'primarySource', FPrimarySource.Link);
  if (child_name = 'reportOrigin') Then
     list.add(self.link, 'reportOrigin', FReportOrigin.Link);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'manufacturer') Then
     list.add(self.link, 'manufacturer', FManufacturer.Link);
  if (child_name = 'lotNumber') Then
     list.add(self.link, 'lotNumber', FLotNumber.Link);
  if (child_name = 'expirationDate') Then
     list.add(self.link, 'expirationDate', FExpirationDate.Link);
  if (child_name = 'site') Then
     list.add(self.link, 'site', FSite.Link);
  if (child_name = 'route') Then
     list.add(self.link, 'route', FRoute.Link);
  if (child_name = 'doseQuantity') Then
     list.add(self.link, 'doseQuantity', FDoseQuantity.Link);
  if (child_name = 'practitioner') Then
    list.addAll(self, 'practitioner', FPractitionerList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'explanation') Then
     list.add(self.link, 'explanation', FExplanation.Link);
  if (child_name = 'reaction') Then
    list.addAll(self, 'reaction', FReactionList);
  if (child_name = 'vaccinationProtocol') Then
    list.addAll(self, 'vaccinationProtocol', FVaccinationProtocolList);
end;

procedure TFhirImmunization.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'notGiven', 'boolean', false, TFhirBoolean, FNotGiven.Link));{2}
  oList.add(TFHIRProperty.create(self, 'vaccineCode', 'CodeableConcept', false, TFhirCodeableConcept, FVaccineCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference(Encounter)', false, TFhirReference{TFhirEncounter}, FEncounter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'primarySource', 'boolean', false, TFhirBoolean, FPrimarySource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reportOrigin', 'CodeableConcept', false, TFhirCodeableConcept, FReportOrigin.Link));{2}
  oList.add(TFHIRProperty.create(self, 'location', 'Reference(Location)', false, TFhirReference{TFhirLocation}, FLocation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'manufacturer', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FManufacturer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'lotNumber', 'string', false, TFhirString, FLotNumber.Link));{2}
  oList.add(TFHIRProperty.create(self, 'expirationDate', 'date', false, TFhirDate, FExpirationDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'site', 'CodeableConcept', false, TFhirCodeableConcept, FSite.Link));{2}
  oList.add(TFHIRProperty.create(self, 'route', 'CodeableConcept', false, TFhirCodeableConcept, FRoute.Link));{2}
  oList.add(TFHIRProperty.create(self, 'doseQuantity', 'Quantity', false, TFhirQuantity, FDoseQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'practitioner', '', true, TFhirImmunizationPractitioner, FPractitionerList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'explanation', '', false, TFhirImmunizationExplanation, FExplanation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reaction', '', true, TFhirImmunizationReaction, FReactionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'vaccinationProtocol', '', true, TFhirImmunizationVaccinationProtocol, FVaccinationProtocolList.Link)){3};
end;

function TFhirImmunization.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirImmunizationStatusEnum, CODES_TFhirImmunizationStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'notGiven') then
  begin
    NotGivenElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'vaccineCode') then
  begin
    VaccineCode := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference{TFhirEncounter}{4b};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'primarySource') then
  begin
    PrimarySourceElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'reportOrigin') then
  begin
    ReportOrigin := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirReference{TFhirLocation}{4b};
    result := propValue;
  end
  else if (propName = 'manufacturer') then
  begin
    Manufacturer := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'lotNumber') then
  begin
    LotNumberElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'expirationDate') then
  begin
    ExpirationDateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'site') then
  begin
    Site := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'route') then
  begin
    Route := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'doseQuantity') then
  begin
    DoseQuantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'practitioner') then
  begin
    PractitionerList.add(propValue as TFhirImmunizationPractitioner){2a};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else if (propName = 'explanation') then
  begin
    Explanation := propValue as TFhirImmunizationExplanation{4b};
    result := propValue;
  end
  else if (propName = 'reaction') then
  begin
    ReactionList.add(propValue as TFhirImmunizationReaction){2a};
    result := propValue;
  end
  else if (propName = 'vaccinationProtocol') then
  begin
    VaccinationProtocolList.add(propValue as TFhirImmunizationVaccinationProtocol){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirImmunization.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'practitioner') then PractitionerList.insertItem(index, propValue as TFhirImmunizationPractitioner){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else if (propName = 'reaction') then ReactionList.insertItem(index, propValue as TFhirImmunizationReaction){2a}
  else if (propName = 'vaccinationProtocol') then VaccinationProtocolList.insertItem(index, propValue as TFhirImmunizationVaccinationProtocol){2a}
  else inherited;
end;

function TFhirImmunization.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'notGiven') then result := TFhirBoolean.create() {5b}
  else if (propName = 'vaccineCode') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'encounter') then result := TFhirReference{TFhirEncounter}.create(){4b}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'primarySource') then result := TFhirBoolean.create() {5b}
  else if (propName = 'reportOrigin') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'location') then result := TFhirReference{TFhirLocation}.create(){4b}
  else if (propName = 'manufacturer') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'lotNumber') then result := TFhirString.create() {5b}
  else if (propName = 'expirationDate') then result := TFhirDate.create() {5b}
  else if (propName = 'site') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'route') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'doseQuantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'practitioner') then result := PractitionerList.new(){2}
  else if (propName = 'note') then result := NoteList.new(){2}
  else if (propName = 'explanation') then result := TFhirImmunizationExplanation.create(){4b}
  else if (propName = 'reaction') then result := ReactionList.new(){2}
  else if (propName = 'vaccinationProtocol') then result := VaccinationProtocolList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImmunization.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'notGiven') then result := 'boolean'
  else if (propName = 'vaccineCode') then result := 'CodeableConcept'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'primarySource') then result := 'boolean'
  else if (propName = 'reportOrigin') then result := 'CodeableConcept'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'manufacturer') then result := 'Reference'
  else if (propName = 'lotNumber') then result := 'string'
  else if (propName = 'expirationDate') then result := 'date'
  else if (propName = 'site') then result := 'CodeableConcept'
  else if (propName = 'route') then result := 'CodeableConcept'
  else if (propName = 'doseQuantity') then result := 'Quantity'
  else if (propName = 'practitioner') then result := ''
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'explanation') then result := ''
  else if (propName = 'reaction') then result := ''
  else if (propName = 'vaccinationProtocol') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImmunization.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'notGiven') then NotGivenElement := nil
  else if (propName = 'vaccineCode') then VaccineCodeElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'primarySource') then PrimarySourceElement := nil
  else if (propName = 'reportOrigin') then ReportOriginElement := nil
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'manufacturer') then ManufacturerElement := nil
  else if (propName = 'lotNumber') then LotNumberElement := nil
  else if (propName = 'expirationDate') then ExpirationDateElement := nil
  else if (propName = 'site') then SiteElement := nil
  else if (propName = 'route') then RouteElement := nil
  else if (propName = 'doseQuantity') then DoseQuantityElement := nil
  else if (propName = 'practitioner') then deletePropertyValue('practitioner', PractitionerList, value) {2}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else if (propName = 'explanation') then ExplanationElement := nil
  else if (propName = 'reaction') then deletePropertyValue('reaction', ReactionList, value) {2}
  else if (propName = 'vaccinationProtocol') then deletePropertyValue('vaccinationProtocol', VaccinationProtocolList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImmunization.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirImmunizationStatusEnum, CODES_TFhirImmunizationStatusEnum, new){4}
  else if (propName = 'notGiven') then NotGivenElement := asBoolean(new){5b}
  else if (propName = 'vaccineCode') then VaccineCodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference{TFhirEncounter}{4}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'primarySource') then PrimarySourceElement := asBoolean(new){5b}
  else if (propName = 'reportOrigin') then ReportOriginElement := new as TFhirCodeableConcept{4}
  else if (propName = 'location') then LocationElement := new as TFhirReference{TFhirLocation}{4}
  else if (propName = 'manufacturer') then ManufacturerElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'lotNumber') then LotNumberElement := asString(new){5b}
  else if (propName = 'expirationDate') then ExpirationDateElement := asDate(new){5b}
  else if (propName = 'site') then SiteElement := new as TFhirCodeableConcept{4}
  else if (propName = 'route') then RouteElement := new as TFhirCodeableConcept{4}
  else if (propName = 'doseQuantity') then DoseQuantityElement := new as TFhirQuantity{4}
  else if (propName = 'practitioner') then replacePropertyValue('practitioner', PractitionerList, existing, new) {2}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else if (propName = 'explanation') then ExplanationElement := new as TFhirImmunizationExplanation{4}
  else if (propName = 'reaction') then replacePropertyValue('reaction', ReactionList, existing, new) {2}
  else if (propName = 'vaccinationProtocol') then replacePropertyValue('vaccinationProtocol', VaccinationProtocolList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImmunization.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'practitioner') then PractitionerList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else if (propName = 'reaction') then ReactionList.move(source, destination){2a}
  else if (propName = 'vaccinationProtocol') then VaccinationProtocolList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImmunization.fhirType : string;
begin
  result := 'Immunization';
end;

function TFhirImmunization.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FNotGiven) and isEmptyProp(FVaccineCode) and isEmptyProp(FPatient) and isEmptyProp(FEncounter) and isEmptyProp(FDate) and isEmptyProp(FPrimarySource) and isEmptyProp(FReportOrigin) and isEmptyProp(FLocation) and isEmptyProp(FManufacturer) and isEmptyProp(FLotNumber) and isEmptyProp(FExpirationDate) and isEmptyProp(FSite) and isEmptyProp(FRoute) and isEmptyProp(FDoseQuantity) and isEmptyProp(FpractitionerList) and isEmptyProp(FnoteList) and isEmptyProp(FExplanation) and isEmptyProp(FreactionList) and isEmptyProp(FvaccinationProtocolList);
end;

function TFhirImmunization.equals(other : TObject) : boolean;
var
  o : TFhirImmunization;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImmunization)) then
    result := false
  else
  begin
    o := TFhirImmunization(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(notGivenElement, o.notGivenElement, true) and compareDeep(vaccineCodeElement, o.vaccineCodeElement, true) and
      compareDeep(patientElement, o.patientElement, true) and compareDeep(encounterElement, o.encounterElement, true) and
      compareDeep(dateElement, o.dateElement, true) and compareDeep(primarySourceElement, o.primarySourceElement, true) and
      compareDeep(reportOriginElement, o.reportOriginElement, true) and compareDeep(locationElement, o.locationElement, true) and
      compareDeep(manufacturerElement, o.manufacturerElement, true) and compareDeep(lotNumberElement, o.lotNumberElement, true) and
      compareDeep(expirationDateElement, o.expirationDateElement, true) and compareDeep(siteElement, o.siteElement, true) and
      compareDeep(routeElement, o.routeElement, true) and compareDeep(doseQuantityElement, o.doseQuantityElement, true) and
      compareDeep(practitionerList, o.practitionerList, true) and compareDeep(noteList, o.noteList, true) and
      compareDeep(explanationElement, o.explanationElement, true) and compareDeep(reactionList, o.reactionList, true) and
      compareDeep(vaccinationProtocolList, o.vaccinationProtocolList, true);
  end;
end;

function TFhirImmunization.Link : TFhirImmunization;
begin
  result := TFhirImmunization(inherited Link);
end;

function TFhirImmunization.Clone : TFhirImmunization;
begin
  result := TFhirImmunization(inherited Clone);
end;

procedure TFhirImmunization.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('notGiven');
  fields.add('vaccineCode');
  fields.add('patient');
  fields.add('encounter');
  fields.add('date');
  fields.add('primarySource');
  fields.add('reportOrigin');
  fields.add('location');
  fields.add('manufacturer');
  fields.add('lotNumber');
  fields.add('expirationDate');
  fields.add('site');
  fields.add('route');
  fields.add('doseQuantity');
  fields.add('practitioner');
  fields.add('note');
  fields.add('explanation');
  fields.add('reaction');
  fields.add('vaccinationProtocol');
end;

{ TFhirImmunization }

Function TFhirImmunization.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirImmunization.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirImmunization.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirImmunization.GetStatusST : TFhirImmunizationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirImmunizationStatusEnum(0)
  else
    result := TFhirImmunizationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirImmunizationStatusEnum, FStatus.value));
end;

Procedure TFhirImmunization.SetStatusST(value : TFhirImmunizationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirImmunizationStatusEnum[value], CODES_TFhirImmunizationStatusEnum[value]);
end;

Procedure TFhirImmunization.SetNotGiven(value : TFhirBoolean);
begin
  FNotGiven.free;
  FNotGiven := value;
end;

Function TFhirImmunization.GetNotGivenST : Boolean;
begin
  if FNotGiven = nil then
    result := false
  else
    result := FNotGiven.value;
end;

Procedure TFhirImmunization.SetNotGivenST(value : Boolean);
begin
  if FNotGiven = nil then
    FNotGiven := TFhirBoolean.create;
  FNotGiven.value := value
end;

Procedure TFhirImmunization.SetVaccineCode(value : TFhirCodeableConcept);
begin
  FVaccineCode.free;
  FVaccineCode := value;
end;

Procedure TFhirImmunization.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Procedure TFhirImmunization.SetEncounter(value : TFhirReference{TFhirEncounter});
begin
  FEncounter.free;
  FEncounter := value;
end;

Procedure TFhirImmunization.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirImmunization.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirImmunization.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirImmunization.SetPrimarySource(value : TFhirBoolean);
begin
  FPrimarySource.free;
  FPrimarySource := value;
end;

Function TFhirImmunization.GetPrimarySourceST : Boolean;
begin
  if FPrimarySource = nil then
    result := false
  else
    result := FPrimarySource.value;
end;

Procedure TFhirImmunization.SetPrimarySourceST(value : Boolean);
begin
  if FPrimarySource = nil then
    FPrimarySource := TFhirBoolean.create;
  FPrimarySource.value := value
end;

Procedure TFhirImmunization.SetReportOrigin(value : TFhirCodeableConcept);
begin
  FReportOrigin.free;
  FReportOrigin := value;
end;

Procedure TFhirImmunization.SetLocation(value : TFhirReference{TFhirLocation});
begin
  FLocation.free;
  FLocation := value;
end;

Procedure TFhirImmunization.SetManufacturer(value : TFhirReference{TFhirOrganization});
begin
  FManufacturer.free;
  FManufacturer := value;
end;

Procedure TFhirImmunization.SetLotNumber(value : TFhirString);
begin
  FLotNumber.free;
  FLotNumber := value;
end;

Function TFhirImmunization.GetLotNumberST : String;
begin
  if FLotNumber = nil then
    result := ''
  else
    result := FLotNumber.value;
end;

Procedure TFhirImmunization.SetLotNumberST(value : String);
begin
  if value <> '' then
  begin
    if FLotNumber = nil then
      FLotNumber := TFhirString.create;
    FLotNumber.value := value
  end
  else if FLotNumber <> nil then
    FLotNumber.value := '';
end;

Procedure TFhirImmunization.SetExpirationDate(value : TFhirDate);
begin
  FExpirationDate.free;
  FExpirationDate := value;
end;

Function TFhirImmunization.GetExpirationDateST : TFslDateTime;
begin
  if FExpirationDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FExpirationDate.value;
end;

Procedure TFhirImmunization.SetExpirationDateST(value : TFslDateTime);
begin
  if FExpirationDate = nil then
    FExpirationDate := TFhirDate.create;
  FExpirationDate.value := value
end;

Procedure TFhirImmunization.SetSite(value : TFhirCodeableConcept);
begin
  FSite.free;
  FSite := value;
end;

Procedure TFhirImmunization.SetRoute(value : TFhirCodeableConcept);
begin
  FRoute.free;
  FRoute := value;
end;

Procedure TFhirImmunization.SetDoseQuantity(value : TFhirQuantity);
begin
  FDoseQuantity.free;
  FDoseQuantity := value;
end;

Function TFhirImmunization.GetPractitionerList : TFhirImmunizationPractitionerList;
begin
  if FPractitionerList = nil then
    FPractitionerList := TFhirImmunizationPractitionerList.Create;
  result := FPractitionerList;
end;

Function TFhirImmunization.GetHasPractitionerList : boolean;
begin
  result := (FPractitionerList <> nil) and (FPractitionerList.count > 0);
end;

Function TFhirImmunization.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirImmunization.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

Procedure TFhirImmunization.SetExplanation(value : TFhirImmunizationExplanation);
begin
  FExplanation.free;
  FExplanation := value;
end;

Function TFhirImmunization.GetReactionList : TFhirImmunizationReactionList;
begin
  if FReactionList = nil then
    FReactionList := TFhirImmunizationReactionList.Create;
  result := FReactionList;
end;

Function TFhirImmunization.GetHasReactionList : boolean;
begin
  result := (FReactionList <> nil) and (FReactionList.count > 0);
end;

Function TFhirImmunization.GetVaccinationProtocolList : TFhirImmunizationVaccinationProtocolList;
begin
  if FVaccinationProtocolList = nil then
    FVaccinationProtocolList := TFhirImmunizationVaccinationProtocolList.Create;
  result := FVaccinationProtocolList;
end;

Function TFhirImmunization.GetHasVaccinationProtocolList : boolean;
begin
  result := (FVaccinationProtocolList <> nil) and (FVaccinationProtocolList.count > 0);
end;

function TFhirImmunization.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FNotGiven.sizeInBytes);
  inc(result, FVaccineCode.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FDate.sizeInBytes);
  inc(result, FPrimarySource.sizeInBytes);
  inc(result, FReportOrigin.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
  inc(result, FManufacturer.sizeInBytes);
  inc(result, FLotNumber.sizeInBytes);
  inc(result, FExpirationDate.sizeInBytes);
  inc(result, FSite.sizeInBytes);
  inc(result, FRoute.sizeInBytes);
  inc(result, FDoseQuantity.sizeInBytes);
  inc(result, FpractitionerList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FExplanation.sizeInBytes);
  inc(result, FreactionList.sizeInBytes);
  inc(result, FvaccinationProtocolList.sizeInBytes);
end;

{ TFhirImmunizationListEnumerator }

Constructor TFhirImmunizationListEnumerator.Create(list : TFhirImmunizationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImmunizationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImmunizationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImmunizationListEnumerator.GetCurrent : TFhirImmunization;
begin
  Result := FList[FIndex];
end;

function TFhirImmunizationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImmunizationList }
procedure TFhirImmunizationList.AddItem(value: TFhirImmunization);
begin
  assert(value.ClassName = 'TFhirImmunization', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunization');
  add(value);
end;

function TFhirImmunizationList.Append: TFhirImmunization;
begin
  result := TFhirImmunization.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationList.GetEnumerator : TFhirImmunizationListEnumerator;
begin
  result := TFhirImmunizationListEnumerator.Create(self.link);
end;

function TFhirImmunizationList.Clone: TFhirImmunizationList;
begin
  result := TFhirImmunizationList(inherited Clone);
end;

function TFhirImmunizationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationList.GetItemN(index: Integer): TFhirImmunization;
begin
  result := TFhirImmunization(ObjectByIndex[index]);
end;

function TFhirImmunizationList.ItemClass: TFslObjectClass;
begin
  result := TFhirImmunization;
end;
function TFhirImmunizationList.IndexOf(value: TFhirImmunization): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImmunizationList.Insert(index: Integer): TFhirImmunization;
begin
  result := TFhirImmunization.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationList.InsertItem(index: Integer; value: TFhirImmunization);
begin
  assert(value is TFhirImmunization);
  Inherited Insert(index, value);
end;

function TFhirImmunizationList.Item(index: Integer): TFhirImmunization;
begin
  result := TFhirImmunization(ObjectByIndex[index]);
end;

function TFhirImmunizationList.Link: TFhirImmunizationList;
begin
  result := TFhirImmunizationList(inherited Link);
end;

procedure TFhirImmunizationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationList.SetItemByIndex(index: Integer; value: TFhirImmunization);
begin
  assert(value is TFhirImmunization);
  FhirImmunizations[index] := value;
end;

procedure TFhirImmunizationList.SetItemN(index: Integer; value: TFhirImmunization);
begin
  assert(value is TFhirImmunization);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_IMMUNIZATION}

{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}

{ TFhirImmunizationRecommendationRecommendation }

constructor TFhirImmunizationRecommendationRecommendation.Create;
begin
  inherited;
end;

destructor TFhirImmunizationRecommendationRecommendation.Destroy;
begin
  FDate.free;
  FVaccineCode.free;
  FTargetDisease.free;
  FDoseNumber.free;
  FForecastStatus.free;
  FDateCriterionList.Free;
  FProtocol.free;
  FSupportingImmunizationList.Free;
  FSupportingPatientInformationList.Free;
  inherited;
end;

procedure TFhirImmunizationRecommendationRecommendation.Assign(oSource : TFslObject);
begin
  inherited;
  dateElement := TFhirImmunizationRecommendationRecommendation(oSource).dateElement.Clone;
  vaccineCode := TFhirImmunizationRecommendationRecommendation(oSource).vaccineCode.Clone;
  targetDisease := TFhirImmunizationRecommendationRecommendation(oSource).targetDisease.Clone;
  doseNumberElement := TFhirImmunizationRecommendationRecommendation(oSource).doseNumberElement.Clone;
  forecastStatus := TFhirImmunizationRecommendationRecommendation(oSource).forecastStatus.Clone;
  if (TFhirImmunizationRecommendationRecommendation(oSource).FDateCriterionList = nil) then
  begin
    FDateCriterionList.free;
    FDateCriterionList := nil;
  end
  else
  begin
    if FDateCriterionList = nil then
      FDateCriterionList := TFhirImmunizationRecommendationRecommendationDateCriterionList.Create;
    FDateCriterionList.Assign(TFhirImmunizationRecommendationRecommendation(oSource).FDateCriterionList);
  end;
  protocol := TFhirImmunizationRecommendationRecommendation(oSource).protocol.Clone;
  if (TFhirImmunizationRecommendationRecommendation(oSource).FSupportingImmunizationList = nil) then
  begin
    FSupportingImmunizationList.free;
    FSupportingImmunizationList := nil;
  end
  else
  begin
    if FSupportingImmunizationList = nil then
      FSupportingImmunizationList := TFhirReferenceList{TFhirImmunization}.Create;
    FSupportingImmunizationList.Assign(TFhirImmunizationRecommendationRecommendation(oSource).FSupportingImmunizationList);
  end;
  if (TFhirImmunizationRecommendationRecommendation(oSource).FSupportingPatientInformationList = nil) then
  begin
    FSupportingPatientInformationList.free;
    FSupportingPatientInformationList := nil;
  end
  else
  begin
    if FSupportingPatientInformationList = nil then
      FSupportingPatientInformationList := TFhirReferenceList{Resource}.Create;
    FSupportingPatientInformationList.Assign(TFhirImmunizationRecommendationRecommendation(oSource).FSupportingPatientInformationList);
  end;
end;

procedure TFhirImmunizationRecommendationRecommendation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'vaccineCode') Then
     list.add(self.link, 'vaccineCode', FVaccineCode.Link);
  if (child_name = 'targetDisease') Then
     list.add(self.link, 'targetDisease', FTargetDisease.Link);
  if (child_name = 'doseNumber') Then
     list.add(self.link, 'doseNumber', FDoseNumber.Link);
  if (child_name = 'forecastStatus') Then
     list.add(self.link, 'forecastStatus', FForecastStatus.Link);
  if (child_name = 'dateCriterion') Then
    list.addAll(self, 'dateCriterion', FDateCriterionList);
  if (child_name = 'protocol') Then
     list.add(self.link, 'protocol', FProtocol.Link);
  if (child_name = 'supportingImmunization') Then
    list.addAll(self, 'supportingImmunization', FSupportingImmunizationList);
  if (child_name = 'supportingPatientInformation') Then
    list.addAll(self, 'supportingPatientInformation', FSupportingPatientInformationList);
end;

procedure TFhirImmunizationRecommendationRecommendation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'vaccineCode', 'CodeableConcept', false, TFhirCodeableConcept, FVaccineCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'targetDisease', 'CodeableConcept', false, TFhirCodeableConcept, FTargetDisease.Link));{2}
  oList.add(TFHIRProperty.create(self, 'doseNumber', 'positiveInt', false, TFhirPositiveInt, FDoseNumber.Link));{2}
  oList.add(TFHIRProperty.create(self, 'forecastStatus', 'CodeableConcept', false, TFhirCodeableConcept, FForecastStatus.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dateCriterion', '', true, TFhirImmunizationRecommendationRecommendationDateCriterion, FDateCriterionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'protocol', '', false, TFhirImmunizationRecommendationRecommendationProtocol, FProtocol.Link));{2}
  oList.add(TFHIRProperty.create(self, 'supportingImmunization', 'Reference(Immunization)', true, TFhirReference{TFhirImmunization}, FSupportingImmunizationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'supportingPatientInformation', 'Reference(Observation|AllergyIntolerance)', true, TFhirReference{Resource}, FSupportingPatientInformationList.Link)){3};
end;

function TFhirImmunizationRecommendationRecommendation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'vaccineCode') then
  begin
    VaccineCode := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'targetDisease') then
  begin
    TargetDisease := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'doseNumber') then
  begin
    DoseNumberElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'forecastStatus') then
  begin
    ForecastStatus := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'dateCriterion') then
  begin
    DateCriterionList.add(propValue as TFhirImmunizationRecommendationRecommendationDateCriterion){2a};
    result := propValue;
  end
  else if (propName = 'protocol') then
  begin
    Protocol := propValue as TFhirImmunizationRecommendationRecommendationProtocol{4b};
    result := propValue;
  end
  else if (propName = 'supportingImmunization') then
  begin
    SupportingImmunizationList.add(propValue as TFhirReference{TFhirImmunization}){2a};
    result := propValue;
  end
  else if (propName = 'supportingPatientInformation') then
  begin
    SupportingPatientInformationList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImmunizationRecommendationRecommendation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'dateCriterion') then DateCriterionList.insertItem(index, propValue as TFhirImmunizationRecommendationRecommendationDateCriterion){2a}
  else if (propName = 'supportingImmunization') then SupportingImmunizationList.insertItem(index, propValue as TFhirReference{TFhirImmunization}){2a}
  else if (propName = 'supportingPatientInformation') then SupportingPatientInformationList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else inherited;
end;

function TFhirImmunizationRecommendationRecommendation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'vaccineCode') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'targetDisease') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'doseNumber') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'forecastStatus') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'dateCriterion') then result := DateCriterionList.new(){2}
  else if (propName = 'protocol') then result := TFhirImmunizationRecommendationRecommendationProtocol.create(){4b}
  else if (propName = 'supportingImmunization') then result := SupportingImmunizationList.new(){2}
  else if (propName = 'supportingPatientInformation') then result := SupportingPatientInformationList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImmunizationRecommendationRecommendation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'date') then result := 'dateTime'
  else if (propName = 'vaccineCode') then result := 'CodeableConcept'
  else if (propName = 'targetDisease') then result := 'CodeableConcept'
  else if (propName = 'doseNumber') then result := 'positiveInt'
  else if (propName = 'forecastStatus') then result := 'CodeableConcept'
  else if (propName = 'dateCriterion') then result := ''
  else if (propName = 'protocol') then result := ''
  else if (propName = 'supportingImmunization') then result := 'Reference'
  else if (propName = 'supportingPatientInformation') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImmunizationRecommendationRecommendation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'date') then DateElement := nil
  else if (propName = 'vaccineCode') then VaccineCodeElement := nil
  else if (propName = 'targetDisease') then TargetDiseaseElement := nil
  else if (propName = 'doseNumber') then DoseNumberElement := nil
  else if (propName = 'forecastStatus') then ForecastStatusElement := nil
  else if (propName = 'dateCriterion') then deletePropertyValue('dateCriterion', DateCriterionList, value) {2}
  else if (propName = 'protocol') then ProtocolElement := nil
  else if (propName = 'supportingImmunization') then deletePropertyValue('supportingImmunization', SupportingImmunizationList, value) {2}
  else if (propName = 'supportingPatientInformation') then deletePropertyValue('supportingPatientInformation', SupportingPatientInformationList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImmunizationRecommendationRecommendation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'vaccineCode') then VaccineCodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'targetDisease') then TargetDiseaseElement := new as TFhirCodeableConcept{4}
  else if (propName = 'doseNumber') then DoseNumberElement := asPositiveInt(new){5b}
  else if (propName = 'forecastStatus') then ForecastStatusElement := new as TFhirCodeableConcept{4}
  else if (propName = 'dateCriterion') then replacePropertyValue('dateCriterion', DateCriterionList, existing, new) {2}
  else if (propName = 'protocol') then ProtocolElement := new as TFhirImmunizationRecommendationRecommendationProtocol{4}
  else if (propName = 'supportingImmunization') then replacePropertyValue('supportingImmunization', SupportingImmunizationList, existing, new) {2}
  else if (propName = 'supportingPatientInformation') then replacePropertyValue('supportingPatientInformation', SupportingPatientInformationList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImmunizationRecommendationRecommendation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'dateCriterion') then DateCriterionList.move(source, destination){2a}
  else if (propName = 'supportingImmunization') then SupportingImmunizationList.move(source, destination){2a}
  else if (propName = 'supportingPatientInformation') then SupportingPatientInformationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImmunizationRecommendationRecommendation.fhirType : string;
begin
  result := 'recommendation';
end;

function TFhirImmunizationRecommendationRecommendation.Link : TFhirImmunizationRecommendationRecommendation;
begin
  result := TFhirImmunizationRecommendationRecommendation(inherited Link);
end;

function TFhirImmunizationRecommendationRecommendation.Clone : TFhirImmunizationRecommendationRecommendation;
begin
  result := TFhirImmunizationRecommendationRecommendation(inherited Clone);
end;

function TFhirImmunizationRecommendationRecommendation.equals(other : TObject) : boolean;
var
  o : TFhirImmunizationRecommendationRecommendation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImmunizationRecommendationRecommendation)) then
    result := false
  else
  begin
    o := TFhirImmunizationRecommendationRecommendation(other);
    result := compareDeep(dateElement, o.dateElement, true) and compareDeep(vaccineCodeElement, o.vaccineCodeElement, true) and
      compareDeep(targetDiseaseElement, o.targetDiseaseElement, true) and compareDeep(doseNumberElement, o.doseNumberElement, true) and
      compareDeep(forecastStatusElement, o.forecastStatusElement, true) and compareDeep(dateCriterionList, o.dateCriterionList, true) and
      compareDeep(protocolElement, o.protocolElement, true) and compareDeep(supportingImmunizationList, o.supportingImmunizationList, true) and
      compareDeep(supportingPatientInformationList, o.supportingPatientInformationList, true);
  end;
end;

function TFhirImmunizationRecommendationRecommendation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDate) and isEmptyProp(FVaccineCode) and isEmptyProp(FTargetDisease) and isEmptyProp(FDoseNumber) and isEmptyProp(FForecastStatus) and isEmptyProp(FdateCriterionList) and isEmptyProp(FProtocol) and isEmptyProp(FsupportingImmunizationList) and isEmptyProp(FsupportingPatientInformationList);
end;

procedure TFhirImmunizationRecommendationRecommendation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('date');
  fields.add('vaccineCode');
  fields.add('targetDisease');
  fields.add('doseNumber');
  fields.add('forecastStatus');
  fields.add('dateCriterion');
  fields.add('protocol');
  fields.add('supportingImmunization');
  fields.add('supportingPatientInformation');
end;

{ TFhirImmunizationRecommendationRecommendation }

Procedure TFhirImmunizationRecommendationRecommendation.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirImmunizationRecommendationRecommendation.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirImmunizationRecommendationRecommendation.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirImmunizationRecommendationRecommendation.SetVaccineCode(value : TFhirCodeableConcept);
begin
  FVaccineCode.free;
  FVaccineCode := value;
end;

Procedure TFhirImmunizationRecommendationRecommendation.SetTargetDisease(value : TFhirCodeableConcept);
begin
  FTargetDisease.free;
  FTargetDisease := value;
end;

Procedure TFhirImmunizationRecommendationRecommendation.SetDoseNumber(value : TFhirPositiveInt);
begin
  FDoseNumber.free;
  FDoseNumber := value;
end;

Function TFhirImmunizationRecommendationRecommendation.GetDoseNumberST : String;
begin
  if FDoseNumber = nil then
    result := ''
  else
    result := FDoseNumber.value;
end;

Procedure TFhirImmunizationRecommendationRecommendation.SetDoseNumberST(value : String);
begin
  if value <> '' then
  begin
    if FDoseNumber = nil then
      FDoseNumber := TFhirPositiveInt.create;
    FDoseNumber.value := value
  end
  else if FDoseNumber <> nil then
    FDoseNumber.value := '';
end;

Procedure TFhirImmunizationRecommendationRecommendation.SetForecastStatus(value : TFhirCodeableConcept);
begin
  FForecastStatus.free;
  FForecastStatus := value;
end;

Function TFhirImmunizationRecommendationRecommendation.GetDateCriterionList : TFhirImmunizationRecommendationRecommendationDateCriterionList;
begin
  if FDateCriterionList = nil then
    FDateCriterionList := TFhirImmunizationRecommendationRecommendationDateCriterionList.Create;
  result := FDateCriterionList;
end;

Function TFhirImmunizationRecommendationRecommendation.GetHasDateCriterionList : boolean;
begin
  result := (FDateCriterionList <> nil) and (FDateCriterionList.count > 0);
end;

Procedure TFhirImmunizationRecommendationRecommendation.SetProtocol(value : TFhirImmunizationRecommendationRecommendationProtocol);
begin
  FProtocol.free;
  FProtocol := value;
end;

Function TFhirImmunizationRecommendationRecommendation.GetSupportingImmunizationList : TFhirReferenceList{TFhirImmunization};
begin
  if FSupportingImmunizationList = nil then
    FSupportingImmunizationList := TFhirReferenceList{TFhirImmunization}.Create;
  result := FSupportingImmunizationList;
end;

Function TFhirImmunizationRecommendationRecommendation.GetHasSupportingImmunizationList : boolean;
begin
  result := (FSupportingImmunizationList <> nil) and (FSupportingImmunizationList.count > 0);
end;

Function TFhirImmunizationRecommendationRecommendation.GetSupportingPatientInformationList : TFhirReferenceList{Resource};
begin
  if FSupportingPatientInformationList = nil then
    FSupportingPatientInformationList := TFhirReferenceList{Resource}.Create;
  result := FSupportingPatientInformationList;
end;

Function TFhirImmunizationRecommendationRecommendation.GetHasSupportingPatientInformationList : boolean;
begin
  result := (FSupportingPatientInformationList <> nil) and (FSupportingPatientInformationList.count > 0);
end;

function TFhirImmunizationRecommendationRecommendation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDate.sizeInBytes);
  inc(result, FVaccineCode.sizeInBytes);
  inc(result, FTargetDisease.sizeInBytes);
  inc(result, FDoseNumber.sizeInBytes);
  inc(result, FForecastStatus.sizeInBytes);
  inc(result, FdateCriterionList.sizeInBytes);
  inc(result, FProtocol.sizeInBytes);
  inc(result, FsupportingImmunizationList.sizeInBytes);
  inc(result, FsupportingPatientInformationList.sizeInBytes);
end;

{ TFhirImmunizationRecommendationRecommendationListEnumerator }

Constructor TFhirImmunizationRecommendationRecommendationListEnumerator.Create(list : TFhirImmunizationRecommendationRecommendationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImmunizationRecommendationRecommendationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImmunizationRecommendationRecommendationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImmunizationRecommendationRecommendationListEnumerator.GetCurrent : TFhirImmunizationRecommendationRecommendation;
begin
  Result := FList[FIndex];
end;

function TFhirImmunizationRecommendationRecommendationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImmunizationRecommendationRecommendationList }
procedure TFhirImmunizationRecommendationRecommendationList.AddItem(value: TFhirImmunizationRecommendationRecommendation);
begin
  assert(value.ClassName = 'TFhirImmunizationRecommendationRecommendation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationRecommendationRecommendation');
  add(value);
end;

function TFhirImmunizationRecommendationRecommendationList.Append: TFhirImmunizationRecommendationRecommendation;
begin
  result := TFhirImmunizationRecommendationRecommendation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationRecommendationRecommendationList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationRecommendationRecommendationList.GetEnumerator : TFhirImmunizationRecommendationRecommendationListEnumerator;
begin
  result := TFhirImmunizationRecommendationRecommendationListEnumerator.Create(self.link);
end;

function TFhirImmunizationRecommendationRecommendationList.Clone: TFhirImmunizationRecommendationRecommendationList;
begin
  result := TFhirImmunizationRecommendationRecommendationList(inherited Clone);
end;

function TFhirImmunizationRecommendationRecommendationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationRecommendationRecommendationList.GetItemN(index: Integer): TFhirImmunizationRecommendationRecommendation;
begin
  result := TFhirImmunizationRecommendationRecommendation(ObjectByIndex[index]);
end;

function TFhirImmunizationRecommendationRecommendationList.ItemClass: TFslObjectClass;
begin
  result := TFhirImmunizationRecommendationRecommendation;
end;
function TFhirImmunizationRecommendationRecommendationList.IndexOf(value: TFhirImmunizationRecommendationRecommendation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImmunizationRecommendationRecommendationList.Insert(index: Integer): TFhirImmunizationRecommendationRecommendation;
begin
  result := TFhirImmunizationRecommendationRecommendation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationRecommendationRecommendationList.InsertItem(index: Integer; value: TFhirImmunizationRecommendationRecommendation);
begin
  assert(value is TFhirImmunizationRecommendationRecommendation);
  Inherited Insert(index, value);
end;

function TFhirImmunizationRecommendationRecommendationList.Item(index: Integer): TFhirImmunizationRecommendationRecommendation;
begin
  result := TFhirImmunizationRecommendationRecommendation(ObjectByIndex[index]);
end;

function TFhirImmunizationRecommendationRecommendationList.Link: TFhirImmunizationRecommendationRecommendationList;
begin
  result := TFhirImmunizationRecommendationRecommendationList(inherited Link);
end;

procedure TFhirImmunizationRecommendationRecommendationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationRecommendationRecommendationList.SetItemByIndex(index: Integer; value: TFhirImmunizationRecommendationRecommendation);
begin
  assert(value is TFhirImmunizationRecommendationRecommendation);
  FhirImmunizationRecommendationRecommendations[index] := value;
end;

procedure TFhirImmunizationRecommendationRecommendationList.SetItemN(index: Integer; value: TFhirImmunizationRecommendationRecommendation);
begin
  assert(value is TFhirImmunizationRecommendationRecommendation);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunizationRecommendationRecommendationDateCriterion }

constructor TFhirImmunizationRecommendationRecommendationDateCriterion.Create;
begin
  inherited;
end;

destructor TFhirImmunizationRecommendationRecommendationDateCriterion.Destroy;
begin
  FCode.free;
  FValue.free;
  inherited;
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirImmunizationRecommendationRecommendationDateCriterion(oSource).code.Clone;
  valueElement := TFhirImmunizationRecommendationRecommendationDateCriterion(oSource).valueElement.Clone;
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value', 'dateTime', false, TFhirDateTime, FValue.Link));{2}
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'value') then result := TFhirDateTime.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'value') then result := 'dateTime'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'value') then ValueElement := asDateTime(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.fhirType : string;
begin
  result := 'dateCriterion';
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.Link : TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion(inherited Link);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.Clone : TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion(inherited Clone);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.equals(other : TObject) : boolean;
var
  o : TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImmunizationRecommendationRecommendationDateCriterion)) then
    result := false
  else
  begin
    o := TFhirImmunizationRecommendationRecommendationDateCriterion(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FValue);
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('value');
end;

{ TFhirImmunizationRecommendationRecommendationDateCriterion }

Procedure TFhirImmunizationRecommendationRecommendationDateCriterion.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirImmunizationRecommendationRecommendationDateCriterion.SetValue(value : TFhirDateTime);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirImmunizationRecommendationRecommendationDateCriterion.GetValueST : TFslDateTime;
begin
  if FValue = nil then
    result := TFslDateTime.makeNull
  else
    result := FValue.value;
end;

Procedure TFhirImmunizationRecommendationRecommendationDateCriterion.SetValueST(value : TFslDateTime);
begin
  if FValue = nil then
    FValue := TFhirDateTime.create;
  FValue.value := value
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator }

Constructor TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator.Create(list : TFhirImmunizationRecommendationRecommendationDateCriterionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator.GetCurrent : TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  Result := FList[FIndex];
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImmunizationRecommendationRecommendationDateCriterionList }
procedure TFhirImmunizationRecommendationRecommendationDateCriterionList.AddItem(value: TFhirImmunizationRecommendationRecommendationDateCriterion);
begin
  assert(value.ClassName = 'TFhirImmunizationRecommendationRecommendationDateCriterion', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationRecommendationRecommendationDateCriterion');
  add(value);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.Append: TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterionList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.GetEnumerator : TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator.Create(self.link);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.Clone: TFhirImmunizationRecommendationRecommendationDateCriterionList;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterionList(inherited Clone);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.GetItemN(index: Integer): TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion(ObjectByIndex[index]);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.ItemClass: TFslObjectClass;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion;
end;
function TFhirImmunizationRecommendationRecommendationDateCriterionList.IndexOf(value: TFhirImmunizationRecommendationRecommendationDateCriterion): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.Insert(index: Integer): TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterionList.InsertItem(index: Integer; value: TFhirImmunizationRecommendationRecommendationDateCriterion);
begin
  assert(value is TFhirImmunizationRecommendationRecommendationDateCriterion);
  Inherited Insert(index, value);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.Item(index: Integer): TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion(ObjectByIndex[index]);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.Link: TFhirImmunizationRecommendationRecommendationDateCriterionList;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterionList(inherited Link);
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterionList.SetItemByIndex(index: Integer; value: TFhirImmunizationRecommendationRecommendationDateCriterion);
begin
  assert(value is TFhirImmunizationRecommendationRecommendationDateCriterion);
  FhirImmunizationRecommendationRecommendationDateCriterions[index] := value;
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterionList.SetItemN(index: Integer; value: TFhirImmunizationRecommendationRecommendationDateCriterion);
begin
  assert(value is TFhirImmunizationRecommendationRecommendationDateCriterion);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunizationRecommendationRecommendationProtocol }

constructor TFhirImmunizationRecommendationRecommendationProtocol.Create;
begin
  inherited;
end;

destructor TFhirImmunizationRecommendationRecommendationProtocol.Destroy;
begin
  FDoseSequence.free;
  FDescription.free;
  FAuthority.free;
  FSeries.free;
  inherited;
end;

procedure TFhirImmunizationRecommendationRecommendationProtocol.Assign(oSource : TFslObject);
begin
  inherited;
  doseSequenceElement := TFhirImmunizationRecommendationRecommendationProtocol(oSource).doseSequenceElement.Clone;
  descriptionElement := TFhirImmunizationRecommendationRecommendationProtocol(oSource).descriptionElement.Clone;
  authority := TFhirImmunizationRecommendationRecommendationProtocol(oSource).authority.Clone;
  seriesElement := TFhirImmunizationRecommendationRecommendationProtocol(oSource).seriesElement.Clone;
end;

procedure TFhirImmunizationRecommendationRecommendationProtocol.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'doseSequence') Then
     list.add(self.link, 'doseSequence', FDoseSequence.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'authority') Then
     list.add(self.link, 'authority', FAuthority.Link);
  if (child_name = 'series') Then
     list.add(self.link, 'series', FSeries.Link);
end;

procedure TFhirImmunizationRecommendationRecommendationProtocol.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'doseSequence', 'positiveInt', false, TFhirPositiveInt, FDoseSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'authority', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FAuthority.Link));{2}
  oList.add(TFHIRProperty.create(self, 'series', 'string', false, TFhirString, FSeries.Link));{2}
end;

function TFhirImmunizationRecommendationRecommendationProtocol.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'doseSequence') then
  begin
    DoseSequenceElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'authority') then
  begin
    Authority := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'series') then
  begin
    SeriesElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImmunizationRecommendationRecommendationProtocol.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirImmunizationRecommendationRecommendationProtocol.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'doseSequence') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'authority') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'series') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImmunizationRecommendationRecommendationProtocol.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'doseSequence') then result := 'positiveInt'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'authority') then result := 'Reference'
  else if (propName = 'series') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImmunizationRecommendationRecommendationProtocol.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'doseSequence') then DoseSequenceElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'authority') then AuthorityElement := nil
  else if (propName = 'series') then SeriesElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImmunizationRecommendationRecommendationProtocol.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'doseSequence') then DoseSequenceElement := asPositiveInt(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'authority') then AuthorityElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'series') then SeriesElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImmunizationRecommendationRecommendationProtocol.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirImmunizationRecommendationRecommendationProtocol.fhirType : string;
begin
  result := 'protocol';
end;

function TFhirImmunizationRecommendationRecommendationProtocol.Link : TFhirImmunizationRecommendationRecommendationProtocol;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocol(inherited Link);
end;

function TFhirImmunizationRecommendationRecommendationProtocol.Clone : TFhirImmunizationRecommendationRecommendationProtocol;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocol(inherited Clone);
end;

function TFhirImmunizationRecommendationRecommendationProtocol.equals(other : TObject) : boolean;
var
  o : TFhirImmunizationRecommendationRecommendationProtocol;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImmunizationRecommendationRecommendationProtocol)) then
    result := false
  else
  begin
    o := TFhirImmunizationRecommendationRecommendationProtocol(other);
    result := compareDeep(doseSequenceElement, o.doseSequenceElement, true) and
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(authorityElement, o.authorityElement, true) and
      compareDeep(seriesElement, o.seriesElement, true);
  end;
end;

function TFhirImmunizationRecommendationRecommendationProtocol.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDoseSequence) and isEmptyProp(FDescription) and isEmptyProp(FAuthority) and isEmptyProp(FSeries);
end;

procedure TFhirImmunizationRecommendationRecommendationProtocol.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('doseSequence');
  fields.add('description');
  fields.add('authority');
  fields.add('series');
end;

{ TFhirImmunizationRecommendationRecommendationProtocol }

Procedure TFhirImmunizationRecommendationRecommendationProtocol.SetDoseSequence(value : TFhirPositiveInt);
begin
  FDoseSequence.free;
  FDoseSequence := value;
end;

Function TFhirImmunizationRecommendationRecommendationProtocol.GetDoseSequenceST : String;
begin
  if FDoseSequence = nil then
    result := ''
  else
    result := FDoseSequence.value;
end;

Procedure TFhirImmunizationRecommendationRecommendationProtocol.SetDoseSequenceST(value : String);
begin
  if value <> '' then
  begin
    if FDoseSequence = nil then
      FDoseSequence := TFhirPositiveInt.create;
    FDoseSequence.value := value
  end
  else if FDoseSequence <> nil then
    FDoseSequence.value := '';
end;

Procedure TFhirImmunizationRecommendationRecommendationProtocol.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirImmunizationRecommendationRecommendationProtocol.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirImmunizationRecommendationRecommendationProtocol.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirImmunizationRecommendationRecommendationProtocol.SetAuthority(value : TFhirReference{TFhirOrganization});
begin
  FAuthority.free;
  FAuthority := value;
end;

Procedure TFhirImmunizationRecommendationRecommendationProtocol.SetSeries(value : TFhirString);
begin
  FSeries.free;
  FSeries := value;
end;

Function TFhirImmunizationRecommendationRecommendationProtocol.GetSeriesST : String;
begin
  if FSeries = nil then
    result := ''
  else
    result := FSeries.value;
end;

Procedure TFhirImmunizationRecommendationRecommendationProtocol.SetSeriesST(value : String);
begin
  if value <> '' then
  begin
    if FSeries = nil then
      FSeries := TFhirString.create;
    FSeries.value := value
  end
  else if FSeries <> nil then
    FSeries.value := '';
end;

function TFhirImmunizationRecommendationRecommendationProtocol.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDoseSequence.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FAuthority.sizeInBytes);
  inc(result, FSeries.sizeInBytes);
end;

{ TFhirImmunizationRecommendationRecommendationProtocolListEnumerator }

Constructor TFhirImmunizationRecommendationRecommendationProtocolListEnumerator.Create(list : TFhirImmunizationRecommendationRecommendationProtocolList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImmunizationRecommendationRecommendationProtocolListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImmunizationRecommendationRecommendationProtocolListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImmunizationRecommendationRecommendationProtocolListEnumerator.GetCurrent : TFhirImmunizationRecommendationRecommendationProtocol;
begin
  Result := FList[FIndex];
end;

function TFhirImmunizationRecommendationRecommendationProtocolListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImmunizationRecommendationRecommendationProtocolList }
procedure TFhirImmunizationRecommendationRecommendationProtocolList.AddItem(value: TFhirImmunizationRecommendationRecommendationProtocol);
begin
  assert(value.ClassName = 'TFhirImmunizationRecommendationRecommendationProtocol', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationRecommendationRecommendationProtocol');
  add(value);
end;

function TFhirImmunizationRecommendationRecommendationProtocolList.Append: TFhirImmunizationRecommendationRecommendationProtocol;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocol.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationRecommendationRecommendationProtocolList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationRecommendationRecommendationProtocolList.GetEnumerator : TFhirImmunizationRecommendationRecommendationProtocolListEnumerator;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocolListEnumerator.Create(self.link);
end;

function TFhirImmunizationRecommendationRecommendationProtocolList.Clone: TFhirImmunizationRecommendationRecommendationProtocolList;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocolList(inherited Clone);
end;

function TFhirImmunizationRecommendationRecommendationProtocolList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationRecommendationRecommendationProtocolList.GetItemN(index: Integer): TFhirImmunizationRecommendationRecommendationProtocol;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocol(ObjectByIndex[index]);
end;

function TFhirImmunizationRecommendationRecommendationProtocolList.ItemClass: TFslObjectClass;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocol;
end;
function TFhirImmunizationRecommendationRecommendationProtocolList.IndexOf(value: TFhirImmunizationRecommendationRecommendationProtocol): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImmunizationRecommendationRecommendationProtocolList.Insert(index: Integer): TFhirImmunizationRecommendationRecommendationProtocol;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocol.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationRecommendationRecommendationProtocolList.InsertItem(index: Integer; value: TFhirImmunizationRecommendationRecommendationProtocol);
begin
  assert(value is TFhirImmunizationRecommendationRecommendationProtocol);
  Inherited Insert(index, value);
end;

function TFhirImmunizationRecommendationRecommendationProtocolList.Item(index: Integer): TFhirImmunizationRecommendationRecommendationProtocol;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocol(ObjectByIndex[index]);
end;

function TFhirImmunizationRecommendationRecommendationProtocolList.Link: TFhirImmunizationRecommendationRecommendationProtocolList;
begin
  result := TFhirImmunizationRecommendationRecommendationProtocolList(inherited Link);
end;

procedure TFhirImmunizationRecommendationRecommendationProtocolList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationRecommendationRecommendationProtocolList.SetItemByIndex(index: Integer; value: TFhirImmunizationRecommendationRecommendationProtocol);
begin
  assert(value is TFhirImmunizationRecommendationRecommendationProtocol);
  FhirImmunizationRecommendationRecommendationProtocols[index] := value;
end;

procedure TFhirImmunizationRecommendationRecommendationProtocolList.SetItemN(index: Integer; value: TFhirImmunizationRecommendationRecommendationProtocol);
begin
  assert(value is TFhirImmunizationRecommendationRecommendationProtocol);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunizationRecommendation }

constructor TFhirImmunizationRecommendation.Create;
begin
  inherited;
end;

destructor TFhirImmunizationRecommendation.Destroy;
begin
  FIdentifierList.Free;
  FPatient.free;
  FRecommendationList.Free;
  inherited;
end;

function TFhirImmunizationRecommendation.GetResourceType : TFhirResourceType;
begin
  result := frtImmunizationRecommendation;
end;

procedure TFhirImmunizationRecommendation.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirImmunizationRecommendation(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirImmunizationRecommendation(oSource).FIdentifierList);
  end;
  patient := TFhirImmunizationRecommendation(oSource).patient.Clone;
  if (TFhirImmunizationRecommendation(oSource).FRecommendationList = nil) then
  begin
    FRecommendationList.free;
    FRecommendationList := nil;
  end
  else
  begin
    if FRecommendationList = nil then
      FRecommendationList := TFhirImmunizationRecommendationRecommendationList.Create;
    FRecommendationList.Assign(TFhirImmunizationRecommendation(oSource).FRecommendationList);
  end;
end;

procedure TFhirImmunizationRecommendation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'recommendation') Then
    list.addAll(self, 'recommendation', FRecommendationList);
end;

procedure TFhirImmunizationRecommendation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'recommendation', '', true, TFhirImmunizationRecommendationRecommendation, FRecommendationList.Link)){3};
end;

function TFhirImmunizationRecommendation.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'recommendation') then
  begin
    RecommendationList.add(propValue as TFhirImmunizationRecommendationRecommendation){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirImmunizationRecommendation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'recommendation') then RecommendationList.insertItem(index, propValue as TFhirImmunizationRecommendationRecommendation){2a}
  else inherited;
end;

function TFhirImmunizationRecommendation.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'recommendation') then result := RecommendationList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImmunizationRecommendation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'recommendation') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImmunizationRecommendation.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'recommendation') then deletePropertyValue('recommendation', RecommendationList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImmunizationRecommendation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'recommendation') then replacePropertyValue('recommendation', RecommendationList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImmunizationRecommendation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'recommendation') then RecommendationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImmunizationRecommendation.fhirType : string;
begin
  result := 'ImmunizationRecommendation';
end;

function TFhirImmunizationRecommendation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FPatient) and isEmptyProp(FrecommendationList);
end;

function TFhirImmunizationRecommendation.equals(other : TObject) : boolean;
var
  o : TFhirImmunizationRecommendation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImmunizationRecommendation)) then
    result := false
  else
  begin
    o := TFhirImmunizationRecommendation(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(patientElement, o.patientElement, true) and
      compareDeep(recommendationList, o.recommendationList, true);
  end;
end;

function TFhirImmunizationRecommendation.Link : TFhirImmunizationRecommendation;
begin
  result := TFhirImmunizationRecommendation(inherited Link);
end;

function TFhirImmunizationRecommendation.Clone : TFhirImmunizationRecommendation;
begin
  result := TFhirImmunizationRecommendation(inherited Clone);
end;

procedure TFhirImmunizationRecommendation.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('patient');
  fields.add('recommendation');
end;

{ TFhirImmunizationRecommendation }

Function TFhirImmunizationRecommendation.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirImmunizationRecommendation.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirImmunizationRecommendation.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Function TFhirImmunizationRecommendation.GetRecommendationList : TFhirImmunizationRecommendationRecommendationList;
begin
  if FRecommendationList = nil then
    FRecommendationList := TFhirImmunizationRecommendationRecommendationList.Create;
  result := FRecommendationList;
end;

Function TFhirImmunizationRecommendation.GetHasRecommendationList : boolean;
begin
  result := (FRecommendationList <> nil) and (FRecommendationList.count > 0);
end;

function TFhirImmunizationRecommendation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FrecommendationList.sizeInBytes);
end;

{ TFhirImmunizationRecommendationListEnumerator }

Constructor TFhirImmunizationRecommendationListEnumerator.Create(list : TFhirImmunizationRecommendationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImmunizationRecommendationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImmunizationRecommendationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImmunizationRecommendationListEnumerator.GetCurrent : TFhirImmunizationRecommendation;
begin
  Result := FList[FIndex];
end;

function TFhirImmunizationRecommendationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImmunizationRecommendationList }
procedure TFhirImmunizationRecommendationList.AddItem(value: TFhirImmunizationRecommendation);
begin
  assert(value.ClassName = 'TFhirImmunizationRecommendation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationRecommendation');
  add(value);
end;

function TFhirImmunizationRecommendationList.Append: TFhirImmunizationRecommendation;
begin
  result := TFhirImmunizationRecommendation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationRecommendationList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationRecommendationList.GetEnumerator : TFhirImmunizationRecommendationListEnumerator;
begin
  result := TFhirImmunizationRecommendationListEnumerator.Create(self.link);
end;

function TFhirImmunizationRecommendationList.Clone: TFhirImmunizationRecommendationList;
begin
  result := TFhirImmunizationRecommendationList(inherited Clone);
end;

function TFhirImmunizationRecommendationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationRecommendationList.GetItemN(index: Integer): TFhirImmunizationRecommendation;
begin
  result := TFhirImmunizationRecommendation(ObjectByIndex[index]);
end;

function TFhirImmunizationRecommendationList.ItemClass: TFslObjectClass;
begin
  result := TFhirImmunizationRecommendation;
end;
function TFhirImmunizationRecommendationList.IndexOf(value: TFhirImmunizationRecommendation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImmunizationRecommendationList.Insert(index: Integer): TFhirImmunizationRecommendation;
begin
  result := TFhirImmunizationRecommendation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationRecommendationList.InsertItem(index: Integer; value: TFhirImmunizationRecommendation);
begin
  assert(value is TFhirImmunizationRecommendation);
  Inherited Insert(index, value);
end;

function TFhirImmunizationRecommendationList.Item(index: Integer): TFhirImmunizationRecommendation;
begin
  result := TFhirImmunizationRecommendation(ObjectByIndex[index]);
end;

function TFhirImmunizationRecommendationList.Link: TFhirImmunizationRecommendationList;
begin
  result := TFhirImmunizationRecommendationList(inherited Link);
end;

procedure TFhirImmunizationRecommendationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationRecommendationList.SetItemByIndex(index: Integer; value: TFhirImmunizationRecommendation);
begin
  assert(value is TFhirImmunizationRecommendation);
  FhirImmunizationRecommendations[index] := value;
end;

procedure TFhirImmunizationRecommendationList.SetItemN(index: Integer; value: TFhirImmunizationRecommendation);
begin
  assert(value is TFhirImmunizationRecommendation);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}

{$IFDEF FHIR_MEDIA}

{ TFhirMedia }

constructor TFhirMedia.Create;
begin
  inherited;
end;

destructor TFhirMedia.Destroy;
begin
  FIdentifierList.Free;
  FBasedOnList.Free;
  FType_.free;
  FSubtype.free;
  FView.free;
  FSubject.free;
  FContext.free;
  FOccurrence.free;
  FOperator.free;
  FReasonCodeList.Free;
  FBodySite.free;
  FDevice.free;
  FHeight.free;
  FWidth.free;
  FFrames.free;
  FDuration.free;
  FContent.free;
  FNoteList.Free;
  inherited;
end;

function TFhirMedia.GetResourceType : TFhirResourceType;
begin
  result := frtMedia;
end;

procedure TFhirMedia.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedia(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirMedia(oSource).FIdentifierList);
  end;
  if (TFhirMedia(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList{TFhirProcedureRequest}.Create;
    FBasedOnList.Assign(TFhirMedia(oSource).FBasedOnList);
  end;
  FType_ := TFhirMedia(oSource).FType_.Link;
  subtype := TFhirMedia(oSource).subtype.Clone;
  view := TFhirMedia(oSource).view.Clone;
  subject := TFhirMedia(oSource).subject.Clone;
  context := TFhirMedia(oSource).context.Clone;
  occurrence := TFhirMedia(oSource).occurrence.Clone;
  operator := TFhirMedia(oSource).operator.Clone;
  if (TFhirMedia(oSource).FReasonCodeList = nil) then
  begin
    FReasonCodeList.free;
    FReasonCodeList := nil;
  end
  else
  begin
    if FReasonCodeList = nil then
      FReasonCodeList := TFhirCodeableConceptList.Create;
    FReasonCodeList.Assign(TFhirMedia(oSource).FReasonCodeList);
  end;
  bodySite := TFhirMedia(oSource).bodySite.Clone;
  device := TFhirMedia(oSource).device.Clone;
  heightElement := TFhirMedia(oSource).heightElement.Clone;
  widthElement := TFhirMedia(oSource).widthElement.Clone;
  framesElement := TFhirMedia(oSource).framesElement.Clone;
  durationElement := TFhirMedia(oSource).durationElement.Clone;
  content := TFhirMedia(oSource).content.Clone;
  if (TFhirMedia(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirMedia(oSource).FNoteList);
  end;
end;

procedure TFhirMedia.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subtype') Then
     list.add(self.link, 'subtype', FSubtype.Link);
  if (child_name = 'view') Then
     list.add(self.link, 'view', FView.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
  if (child_name = 'occurrence[x]') or (child_name = 'occurrence') Then
     list.add(self.link, 'occurrence[x]', FOccurrence.Link);
  if (child_name = 'operator') Then
     list.add(self.link, 'operator', FOperator.Link);
  if (child_name = 'reasonCode') Then
    list.addAll(self, 'reasonCode', FReasonCodeList);
  if (child_name = 'bodySite') Then
     list.add(self.link, 'bodySite', FBodySite.Link);
  if (child_name = 'device') Then
     list.add(self.link, 'device', FDevice.Link);
  if (child_name = 'height') Then
     list.add(self.link, 'height', FHeight.Link);
  if (child_name = 'width') Then
     list.add(self.link, 'width', FWidth.Link);
  if (child_name = 'frames') Then
     list.add(self.link, 'frames', FFrames.Link);
  if (child_name = 'duration') Then
     list.add(self.link, 'duration', FDuration.Link);
  if (child_name = 'content') Then
     list.add(self.link, 'content', FContent.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirMedia.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference(ProcedureRequest)', true, TFhirReference{TFhirProcedureRequest}, FBasedOnList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'subtype', 'CodeableConcept', false, TFhirCodeableConcept, FSubtype.Link));{2}
  oList.add(TFHIRProperty.create(self, 'view', 'CodeableConcept', false, TFhirCodeableConcept, FView.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Practitioner|Group|Device|Specimen)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'context', 'Reference(Encounter|EpisodeOfCare)', false, TFhirReference{Resource}, FContext.Link));{2}
  oList.add(TFHIRProperty.create(self, 'occurrence[x]', 'dateTime|Period', false, TFhirType, FOccurrence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'operator', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FOperator.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reasonCode', 'CodeableConcept', true, TFhirCodeableConcept, FReasonCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', false, TFhirCodeableConcept, FBodySite.Link));{2}
  oList.add(TFHIRProperty.create(self, 'device', 'Reference(Device|DeviceMetric)', false, TFhirReference{Resource}, FDevice.Link));{2}
  oList.add(TFHIRProperty.create(self, 'height', 'positiveInt', false, TFhirPositiveInt, FHeight.Link));{2}
  oList.add(TFHIRProperty.create(self, 'width', 'positiveInt', false, TFhirPositiveInt, FWidth.Link));{2}
  oList.add(TFHIRProperty.create(self, 'frames', 'positiveInt', false, TFhirPositiveInt, FFrames.Link));{2}
  oList.add(TFHIRProperty.create(self, 'duration', 'unsignedInt', false, TFhirUnsignedInt, FDuration.Link));{2}
  oList.add(TFHIRProperty.create(self, 'content', 'Attachment', false, TFhirAttachment, FContent.Link));{2}
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
end;

function TFhirMedia.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference{TFhirProcedureRequest}){2a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirDigitalMediaTypeEnum, CODES_TFhirDigitalMediaTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'subtype') then
  begin
    Subtype := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'view') then
  begin
    View := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'context') then
  begin
    Context := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period'])) then
  begin
    Occurrence := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'operator') then
  begin
    Operator := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'reasonCode') then
  begin
    ReasonCodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySite := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'device') then
  begin
    Device := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'height') then
  begin
    HeightElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'width') then
  begin
    WidthElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'frames') then
  begin
    FramesElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'duration') then
  begin
    DurationElement := asUnsignedInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'content') then
  begin
    Content := propValue as TFhirAttachment{4b};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirMedia.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference{TFhirProcedureRequest}){2a}
  else if (propName = 'reasonCode') then ReasonCodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else inherited;
end;

function TFhirMedia.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'basedOn') then result := BasedOnList.new(){2}
  else if (propName = 'subtype') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'view') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'context') then result := TFhirReference{Resource}.create(){4b}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Occurrence'){4x}
  else if (propName = 'operator') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'reasonCode') then result := ReasonCodeList.new(){2}
  else if (propName = 'bodySite') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'device') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'height') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'width') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'frames') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'duration') then result := TFhirUnsignedInt.create() {5b}
  else if (propName = 'content') then result := TFhirAttachment.create(){4b}
  else if (propName = 'note') then result := NoteList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedia.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'subtype') then result := 'CodeableConcept'
  else if (propName = 'view') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'context') then result := 'Reference'
  else if (propName = 'occurrence[x]') then result := 'dateTime|Period'
  else if (propName = 'operator') then result := 'Reference'
  else if (propName = 'reasonCode') then result := 'CodeableConcept'
  else if (propName = 'bodySite') then result := 'CodeableConcept'
  else if (propName = 'device') then result := 'Reference'
  else if (propName = 'height') then result := 'positiveInt'
  else if (propName = 'width') then result := 'positiveInt'
  else if (propName = 'frames') then result := 'positiveInt'
  else if (propName = 'duration') then result := 'unsignedInt'
  else if (propName = 'content') then result := 'Attachment'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedia.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value) {2}
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'subtype') then SubtypeElement := nil
  else if (propName = 'view') then ViewElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'context') then ContextElement := nil
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period'])) then OccurrenceElement := nil{4x}
  else if (propName = 'operator') then OperatorElement := nil
  else if (propName = 'reasonCode') then deletePropertyValue('reasonCode', ReasonCodeList, value) {2}
  else if (propName = 'bodySite') then BodySiteElement := nil
  else if (propName = 'device') then DeviceElement := nil
  else if (propName = 'height') then HeightElement := nil
  else if (propName = 'width') then WidthElement := nil
  else if (propName = 'frames') then FramesElement := nil
  else if (propName = 'duration') then DurationElement := nil
  else if (propName = 'content') then ContentElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedia.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new) {2}
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirDigitalMediaTypeEnum, CODES_TFhirDigitalMediaTypeEnum, new){4}
  else if (propName = 'subtype') then SubtypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'view') then ViewElement := new as TFhirCodeableConcept{4}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'context') then ContextElement := new as TFhirReference{Resource}{4}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period'])) then OccurrenceElement := new as TFhirType{4x}
  else if (propName = 'operator') then OperatorElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'reasonCode') then replacePropertyValue('reasonCode', ReasonCodeList, existing, new) {2}
  else if (propName = 'bodySite') then BodySiteElement := new as TFhirCodeableConcept{4}
  else if (propName = 'device') then DeviceElement := new as TFhirReference{Resource}{4}
  else if (propName = 'height') then HeightElement := asPositiveInt(new){5b}
  else if (propName = 'width') then WidthElement := asPositiveInt(new){5b}
  else if (propName = 'frames') then FramesElement := asPositiveInt(new){5b}
  else if (propName = 'duration') then DurationElement := asUnsignedInt(new){5b}
  else if (propName = 'content') then ContentElement := new as TFhirAttachment{4}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedia.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'basedOn') then BasedOnList.move(source, destination){2a}
  else if (propName = 'reasonCode') then ReasonCodeList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedia.fhirType : string;
begin
  result := 'Media';
end;

function TFhirMedia.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FbasedOnList) and isEmptyProp(FType_) and isEmptyProp(FSubtype) and isEmptyProp(FView) and isEmptyProp(FSubject) and isEmptyProp(FContext) and isEmptyProp(FOccurrence) and isEmptyProp(FOperator) and isEmptyProp(FreasonCodeList) and isEmptyProp(FBodySite) and isEmptyProp(FDevice) and isEmptyProp(FHeight) and isEmptyProp(FWidth) and isEmptyProp(FFrames) and isEmptyProp(FDuration) and isEmptyProp(FContent) and isEmptyProp(FnoteList);
end;

function TFhirMedia.equals(other : TObject) : boolean;
var
  o : TFhirMedia;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedia)) then
    result := false
  else
  begin
    o := TFhirMedia(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(basedOnList, o.basedOnList, true) and
      compareDeep(type_Element, o.type_Element, true) and compareDeep(subtypeElement, o.subtypeElement, true) and
      compareDeep(viewElement, o.viewElement, true) and compareDeep(subjectElement, o.subjectElement, true) and
      compareDeep(contextElement, o.contextElement, true) and compareDeep(occurrenceElement, o.occurrenceElement, true) and
      compareDeep(operatorElement, o.operatorElement, true) and compareDeep(reasonCodeList, o.reasonCodeList, true) and
      compareDeep(bodySiteElement, o.bodySiteElement, true) and compareDeep(deviceElement, o.deviceElement, true) and
      compareDeep(heightElement, o.heightElement, true) and compareDeep(widthElement, o.widthElement, true) and
      compareDeep(framesElement, o.framesElement, true) and compareDeep(durationElement, o.durationElement, true) and
      compareDeep(contentElement, o.contentElement, true) and compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirMedia.Link : TFhirMedia;
begin
  result := TFhirMedia(inherited Link);
end;

function TFhirMedia.Clone : TFhirMedia;
begin
  result := TFhirMedia(inherited Clone);
end;

procedure TFhirMedia.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('basedOn');
  fields.add('type');
  fields.add('subtype');
  fields.add('view');
  fields.add('subject');
  fields.add('context');
  fields.add('occurrence[x]');
  fields.add('operator');
  fields.add('reasonCode');
  fields.add('bodySite');
  fields.add('device');
  fields.add('height');
  fields.add('width');
  fields.add('frames');
  fields.add('duration');
  fields.add('content');
  fields.add('note');
end;

{ TFhirMedia }

Function TFhirMedia.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirMedia.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Function TFhirMedia.GetBasedOnList : TFhirReferenceList{TFhirProcedureRequest};
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList{TFhirProcedureRequest}.Create;
  result := FBasedOnList;
end;

Function TFhirMedia.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

Procedure TFhirMedia.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirMedia.GetType_ST : TFhirDigitalMediaTypeEnum;
begin
  if FType_ = nil then
    result := TFhirDigitalMediaTypeEnum(0)
  else
    result := TFhirDigitalMediaTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirDigitalMediaTypeEnum, FType_.value));
end;

Procedure TFhirMedia.SetType_ST(value : TFhirDigitalMediaTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirDigitalMediaTypeEnum[value], CODES_TFhirDigitalMediaTypeEnum[value]);
end;

Procedure TFhirMedia.SetSubtype(value : TFhirCodeableConcept);
begin
  FSubtype.free;
  FSubtype := value;
end;

Procedure TFhirMedia.SetView(value : TFhirCodeableConcept);
begin
  FView.free;
  FView := value;
end;

Procedure TFhirMedia.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirMedia.SetContext(value : TFhirReference{Resource});
begin
  FContext.free;
  FContext := value;
end;

Procedure TFhirMedia.SetOccurrence(value : TFhirType);
begin
  FOccurrence.free;
  FOccurrence := value;
end;

Procedure TFhirMedia.SetOperator(value : TFhirReference{TFhirPractitioner});
begin
  FOperator.free;
  FOperator := value;
end;

Function TFhirMedia.GetReasonCodeList : TFhirCodeableConceptList;
begin
  if FReasonCodeList = nil then
    FReasonCodeList := TFhirCodeableConceptList.Create;
  result := FReasonCodeList;
end;

Function TFhirMedia.GetHasReasonCodeList : boolean;
begin
  result := (FReasonCodeList <> nil) and (FReasonCodeList.count > 0);
end;

Procedure TFhirMedia.SetBodySite(value : TFhirCodeableConcept);
begin
  FBodySite.free;
  FBodySite := value;
end;

Procedure TFhirMedia.SetDevice(value : TFhirReference{Resource});
begin
  FDevice.free;
  FDevice := value;
end;

Procedure TFhirMedia.SetHeight(value : TFhirPositiveInt);
begin
  FHeight.free;
  FHeight := value;
end;

Function TFhirMedia.GetHeightST : String;
begin
  if FHeight = nil then
    result := ''
  else
    result := FHeight.value;
end;

Procedure TFhirMedia.SetHeightST(value : String);
begin
  if value <> '' then
  begin
    if FHeight = nil then
      FHeight := TFhirPositiveInt.create;
    FHeight.value := value
  end
  else if FHeight <> nil then
    FHeight.value := '';
end;

Procedure TFhirMedia.SetWidth(value : TFhirPositiveInt);
begin
  FWidth.free;
  FWidth := value;
end;

Function TFhirMedia.GetWidthST : String;
begin
  if FWidth = nil then
    result := ''
  else
    result := FWidth.value;
end;

Procedure TFhirMedia.SetWidthST(value : String);
begin
  if value <> '' then
  begin
    if FWidth = nil then
      FWidth := TFhirPositiveInt.create;
    FWidth.value := value
  end
  else if FWidth <> nil then
    FWidth.value := '';
end;

Procedure TFhirMedia.SetFrames(value : TFhirPositiveInt);
begin
  FFrames.free;
  FFrames := value;
end;

Function TFhirMedia.GetFramesST : String;
begin
  if FFrames = nil then
    result := ''
  else
    result := FFrames.value;
end;

Procedure TFhirMedia.SetFramesST(value : String);
begin
  if value <> '' then
  begin
    if FFrames = nil then
      FFrames := TFhirPositiveInt.create;
    FFrames.value := value
  end
  else if FFrames <> nil then
    FFrames.value := '';
end;

Procedure TFhirMedia.SetDuration(value : TFhirUnsignedInt);
begin
  FDuration.free;
  FDuration := value;
end;

Function TFhirMedia.GetDurationST : String;
begin
  if FDuration = nil then
    result := ''
  else
    result := FDuration.value;
end;

Procedure TFhirMedia.SetDurationST(value : String);
begin
  if value <> '' then
  begin
    if FDuration = nil then
      FDuration := TFhirUnsignedInt.create;
    FDuration.value := value
  end
  else if FDuration <> nil then
    FDuration.value := '';
end;

Procedure TFhirMedia.SetContent(value : TFhirAttachment);
begin
  FContent.free;
  FContent := value;
end;

Function TFhirMedia.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirMedia.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirMedia.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FbasedOnList.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FSubtype.sizeInBytes);
  inc(result, FView.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FContext.sizeInBytes);
  inc(result, FOccurrence.sizeInBytes);
  inc(result, FOperator.sizeInBytes);
  inc(result, FreasonCodeList.sizeInBytes);
  inc(result, FBodySite.sizeInBytes);
  inc(result, FDevice.sizeInBytes);
  inc(result, FHeight.sizeInBytes);
  inc(result, FWidth.sizeInBytes);
  inc(result, FFrames.sizeInBytes);
  inc(result, FDuration.sizeInBytes);
  inc(result, FContent.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
end;

{ TFhirMediaListEnumerator }

Constructor TFhirMediaListEnumerator.Create(list : TFhirMediaList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMediaListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMediaListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMediaListEnumerator.GetCurrent : TFhirMedia;
begin
  Result := FList[FIndex];
end;

function TFhirMediaListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMediaList }
procedure TFhirMediaList.AddItem(value: TFhirMedia);
begin
  assert(value.ClassName = 'TFhirMedia', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedia');
  add(value);
end;

function TFhirMediaList.Append: TFhirMedia;
begin
  result := TFhirMedia.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMediaList.ClearItems;
begin
  Clear;
end;

function TFhirMediaList.GetEnumerator : TFhirMediaListEnumerator;
begin
  result := TFhirMediaListEnumerator.Create(self.link);
end;

function TFhirMediaList.Clone: TFhirMediaList;
begin
  result := TFhirMediaList(inherited Clone);
end;

function TFhirMediaList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMediaList.GetItemN(index: Integer): TFhirMedia;
begin
  result := TFhirMedia(ObjectByIndex[index]);
end;

function TFhirMediaList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedia;
end;
function TFhirMediaList.IndexOf(value: TFhirMedia): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMediaList.Insert(index: Integer): TFhirMedia;
begin
  result := TFhirMedia.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMediaList.InsertItem(index: Integer; value: TFhirMedia);
begin
  assert(value is TFhirMedia);
  Inherited Insert(index, value);
end;

function TFhirMediaList.Item(index: Integer): TFhirMedia;
begin
  result := TFhirMedia(ObjectByIndex[index]);
end;

function TFhirMediaList.Link: TFhirMediaList;
begin
  result := TFhirMediaList(inherited Link);
end;

procedure TFhirMediaList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMediaList.SetItemByIndex(index: Integer; value: TFhirMedia);
begin
  assert(value is TFhirMedia);
  FhirMedia[index] := value;
end;

procedure TFhirMediaList.SetItemN(index: Integer; value: TFhirMedia);
begin
  assert(value is TFhirMedia);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEDIA}

{$IFDEF FHIR_MEDICATIONADMINISTRATION}

{ TFhirMedicationAdministrationPerformer }

constructor TFhirMedicationAdministrationPerformer.Create;
begin
  inherited;
end;

destructor TFhirMedicationAdministrationPerformer.Destroy;
begin
  FActor.free;
  FOnBehalfOf.free;
  inherited;
end;

procedure TFhirMedicationAdministrationPerformer.Assign(oSource : TFslObject);
begin
  inherited;
  actor := TFhirMedicationAdministrationPerformer(oSource).actor.Clone;
  onBehalfOf := TFhirMedicationAdministrationPerformer(oSource).onBehalfOf.Clone;
end;

procedure TFhirMedicationAdministrationPerformer.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'actor') Then
     list.add(self.link, 'actor', FActor.Link);
  if (child_name = 'onBehalfOf') Then
     list.add(self.link, 'onBehalfOf', FOnBehalfOf.Link);
end;

procedure TFhirMedicationAdministrationPerformer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'actor', 'Reference(Practitioner|Patient|RelatedPerson|Device)', false, TFhirReference{Resource}, FActor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'onBehalfOf', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FOnBehalfOf.Link));{2}
end;

function TFhirMedicationAdministrationPerformer.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'actor') then
  begin
    Actor := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'onBehalfOf') then
  begin
    OnBehalfOf := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationAdministrationPerformer.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationAdministrationPerformer.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'actor') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'onBehalfOf') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationAdministrationPerformer.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'actor') then result := 'Reference'
  else if (propName = 'onBehalfOf') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationAdministrationPerformer.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'actor') then ActorElement := nil
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationAdministrationPerformer.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'actor') then ActorElement := new as TFhirReference{Resource}{4}
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := new as TFhirReference{TFhirOrganization}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationAdministrationPerformer.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationAdministrationPerformer.fhirType : string;
begin
  result := 'performer';
end;

function TFhirMedicationAdministrationPerformer.Link : TFhirMedicationAdministrationPerformer;
begin
  result := TFhirMedicationAdministrationPerformer(inherited Link);
end;

function TFhirMedicationAdministrationPerformer.Clone : TFhirMedicationAdministrationPerformer;
begin
  result := TFhirMedicationAdministrationPerformer(inherited Clone);
end;

function TFhirMedicationAdministrationPerformer.equals(other : TObject) : boolean;
var
  o : TFhirMedicationAdministrationPerformer;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationAdministrationPerformer)) then
    result := false
  else
  begin
    o := TFhirMedicationAdministrationPerformer(other);
    result := compareDeep(actorElement, o.actorElement, true) and compareDeep(onBehalfOfElement, o.onBehalfOfElement, true);
  end;
end;

function TFhirMedicationAdministrationPerformer.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FActor) and isEmptyProp(FOnBehalfOf);
end;

procedure TFhirMedicationAdministrationPerformer.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('actor');
  fields.add('onBehalfOf');
end;

{ TFhirMedicationAdministrationPerformer }

Procedure TFhirMedicationAdministrationPerformer.SetActor(value : TFhirReference{Resource});
begin
  FActor.free;
  FActor := value;
end;

Procedure TFhirMedicationAdministrationPerformer.SetOnBehalfOf(value : TFhirReference{TFhirOrganization});
begin
  FOnBehalfOf.free;
  FOnBehalfOf := value;
end;

function TFhirMedicationAdministrationPerformer.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FActor.sizeInBytes);
  inc(result, FOnBehalfOf.sizeInBytes);
end;

{ TFhirMedicationAdministrationPerformerListEnumerator }

Constructor TFhirMedicationAdministrationPerformerListEnumerator.Create(list : TFhirMedicationAdministrationPerformerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationAdministrationPerformerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationAdministrationPerformerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationAdministrationPerformerListEnumerator.GetCurrent : TFhirMedicationAdministrationPerformer;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationAdministrationPerformerListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationAdministrationPerformerList }
procedure TFhirMedicationAdministrationPerformerList.AddItem(value: TFhirMedicationAdministrationPerformer);
begin
  assert(value.ClassName = 'TFhirMedicationAdministrationPerformer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationAdministrationPerformer');
  add(value);
end;

function TFhirMedicationAdministrationPerformerList.Append: TFhirMedicationAdministrationPerformer;
begin
  result := TFhirMedicationAdministrationPerformer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationAdministrationPerformerList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationAdministrationPerformerList.GetEnumerator : TFhirMedicationAdministrationPerformerListEnumerator;
begin
  result := TFhirMedicationAdministrationPerformerListEnumerator.Create(self.link);
end;

function TFhirMedicationAdministrationPerformerList.Clone: TFhirMedicationAdministrationPerformerList;
begin
  result := TFhirMedicationAdministrationPerformerList(inherited Clone);
end;

function TFhirMedicationAdministrationPerformerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationAdministrationPerformerList.GetItemN(index: Integer): TFhirMedicationAdministrationPerformer;
begin
  result := TFhirMedicationAdministrationPerformer(ObjectByIndex[index]);
end;

function TFhirMedicationAdministrationPerformerList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationAdministrationPerformer;
end;
function TFhirMedicationAdministrationPerformerList.IndexOf(value: TFhirMedicationAdministrationPerformer): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationAdministrationPerformerList.Insert(index: Integer): TFhirMedicationAdministrationPerformer;
begin
  result := TFhirMedicationAdministrationPerformer.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationAdministrationPerformerList.InsertItem(index: Integer; value: TFhirMedicationAdministrationPerformer);
begin
  assert(value is TFhirMedicationAdministrationPerformer);
  Inherited Insert(index, value);
end;

function TFhirMedicationAdministrationPerformerList.Item(index: Integer): TFhirMedicationAdministrationPerformer;
begin
  result := TFhirMedicationAdministrationPerformer(ObjectByIndex[index]);
end;

function TFhirMedicationAdministrationPerformerList.Link: TFhirMedicationAdministrationPerformerList;
begin
  result := TFhirMedicationAdministrationPerformerList(inherited Link);
end;

procedure TFhirMedicationAdministrationPerformerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationAdministrationPerformerList.SetItemByIndex(index: Integer; value: TFhirMedicationAdministrationPerformer);
begin
  assert(value is TFhirMedicationAdministrationPerformer);
  FhirMedicationAdministrationPerformers[index] := value;
end;

procedure TFhirMedicationAdministrationPerformerList.SetItemN(index: Integer; value: TFhirMedicationAdministrationPerformer);
begin
  assert(value is TFhirMedicationAdministrationPerformer);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationAdministrationDosage }

constructor TFhirMedicationAdministrationDosage.Create;
begin
  inherited;
end;

destructor TFhirMedicationAdministrationDosage.Destroy;
begin
  FText.free;
  FSite.free;
  FRoute.free;
  FMethod.free;
  FDose.free;
  FRate.free;
  inherited;
end;

procedure TFhirMedicationAdministrationDosage.Assign(oSource : TFslObject);
begin
  inherited;
  textElement := TFhirMedicationAdministrationDosage(oSource).textElement.Clone;
  site := TFhirMedicationAdministrationDosage(oSource).site.Clone;
  route := TFhirMedicationAdministrationDosage(oSource).route.Clone;
  method := TFhirMedicationAdministrationDosage(oSource).method.Clone;
  dose := TFhirMedicationAdministrationDosage(oSource).dose.Clone;
  rate := TFhirMedicationAdministrationDosage(oSource).rate.Clone;
end;

procedure TFhirMedicationAdministrationDosage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'site') Then
     list.add(self.link, 'site', FSite.Link);
  if (child_name = 'route') Then
     list.add(self.link, 'route', FRoute.Link);
  if (child_name = 'method') Then
     list.add(self.link, 'method', FMethod.Link);
  if (child_name = 'dose') Then
     list.add(self.link, 'dose', FDose.Link);
  if (child_name = 'rate[x]') or (child_name = 'rate') Then
     list.add(self.link, 'rate[x]', FRate.Link);
end;

procedure TFhirMedicationAdministrationDosage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));{2}
  oList.add(TFHIRProperty.create(self, 'site', 'CodeableConcept', false, TFhirCodeableConcept, FSite.Link));{2}
  oList.add(TFHIRProperty.create(self, 'route', 'CodeableConcept', false, TFhirCodeableConcept, FRoute.Link));{2}
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', false, TFhirCodeableConcept, FMethod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dose', 'Quantity', false, TFhirQuantity, FDose.Link));{2}
  oList.add(TFHIRProperty.create(self, 'rate[x]', 'Ratio|Quantity', false, TFhirType, FRate.Link));{2}
end;

function TFhirMedicationAdministrationDosage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'text') then
  begin
    TextElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'site') then
  begin
    Site := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'route') then
  begin
    Route := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'method') then
  begin
    Method := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'dose') then
  begin
    Dose := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'rate', ['Ratio', 'Quantity'])) then
  begin
    Rate := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationAdministrationDosage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationAdministrationDosage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'text') then result := TFhirString.create() {5b}
  else if (propName = 'site') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'route') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'method') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'dose') then result := TFhirQuantity.create(){4b}
  else if (isMatchingName(propName, 'rate', ['Ratio', 'Quantity'])) then raise EFHIRException.create('Cannot make property Rate'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationAdministrationDosage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'text') then result := 'string'
  else if (propName = 'site') then result := 'CodeableConcept'
  else if (propName = 'route') then result := 'CodeableConcept'
  else if (propName = 'method') then result := 'CodeableConcept'
  else if (propName = 'dose') then result := 'Quantity'
  else if (propName = 'rate[x]') then result := 'Ratio|Quantity'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationAdministrationDosage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'text') then TextElement := nil
  else if (propName = 'site') then SiteElement := nil
  else if (propName = 'route') then RouteElement := nil
  else if (propName = 'method') then MethodElement := nil
  else if (propName = 'dose') then DoseElement := nil
  else if (isMatchingName(propName, 'rate', ['Ratio', 'Quantity'])) then RateElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationAdministrationDosage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'text') then TextElement := asString(new){5b}
  else if (propName = 'site') then SiteElement := new as TFhirCodeableConcept{4}
  else if (propName = 'route') then RouteElement := new as TFhirCodeableConcept{4}
  else if (propName = 'method') then MethodElement := new as TFhirCodeableConcept{4}
  else if (propName = 'dose') then DoseElement := new as TFhirQuantity{4}
  else if (isMatchingName(propName, 'rate', ['Ratio', 'Quantity'])) then RateElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationAdministrationDosage.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationAdministrationDosage.fhirType : string;
begin
  result := 'dosage';
end;

function TFhirMedicationAdministrationDosage.Link : TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage(inherited Link);
end;

function TFhirMedicationAdministrationDosage.Clone : TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage(inherited Clone);
end;

function TFhirMedicationAdministrationDosage.equals(other : TObject) : boolean;
var
  o : TFhirMedicationAdministrationDosage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationAdministrationDosage)) then
    result := false
  else
  begin
    o := TFhirMedicationAdministrationDosage(other);
    result := compareDeep(textElement, o.textElement, true) and compareDeep(siteElement, o.siteElement, true) and
      compareDeep(routeElement, o.routeElement, true) and compareDeep(methodElement, o.methodElement, true) and
      compareDeep(doseElement, o.doseElement, true) and compareDeep(rateElement, o.rateElement, true);
  end;
end;

function TFhirMedicationAdministrationDosage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FText) and isEmptyProp(FSite) and isEmptyProp(FRoute) and isEmptyProp(FMethod) and isEmptyProp(FDose) and isEmptyProp(FRate);
end;

procedure TFhirMedicationAdministrationDosage.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('text');
  fields.add('site');
  fields.add('route');
  fields.add('method');
  fields.add('dose');
  fields.add('rate[x]');
end;

{ TFhirMedicationAdministrationDosage }

Procedure TFhirMedicationAdministrationDosage.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

Function TFhirMedicationAdministrationDosage.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

Procedure TFhirMedicationAdministrationDosage.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

Procedure TFhirMedicationAdministrationDosage.SetSite(value : TFhirCodeableConcept);
begin
  FSite.free;
  FSite := value;
end;

Procedure TFhirMedicationAdministrationDosage.SetRoute(value : TFhirCodeableConcept);
begin
  FRoute.free;
  FRoute := value;
end;

Procedure TFhirMedicationAdministrationDosage.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value;
end;

Procedure TFhirMedicationAdministrationDosage.SetDose(value : TFhirQuantity);
begin
  FDose.free;
  FDose := value;
end;

Procedure TFhirMedicationAdministrationDosage.SetRate(value : TFhirType);
begin
  FRate.free;
  FRate := value;
end;

function TFhirMedicationAdministrationDosage.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FText.sizeInBytes);
  inc(result, FSite.sizeInBytes);
  inc(result, FRoute.sizeInBytes);
  inc(result, FMethod.sizeInBytes);
  inc(result, FDose.sizeInBytes);
  inc(result, FRate.sizeInBytes);
end;

{ TFhirMedicationAdministrationDosageListEnumerator }

Constructor TFhirMedicationAdministrationDosageListEnumerator.Create(list : TFhirMedicationAdministrationDosageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationAdministrationDosageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationAdministrationDosageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationAdministrationDosageListEnumerator.GetCurrent : TFhirMedicationAdministrationDosage;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationAdministrationDosageListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationAdministrationDosageList }
procedure TFhirMedicationAdministrationDosageList.AddItem(value: TFhirMedicationAdministrationDosage);
begin
  assert(value.ClassName = 'TFhirMedicationAdministrationDosage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationAdministrationDosage');
  add(value);
end;

function TFhirMedicationAdministrationDosageList.Append: TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationAdministrationDosageList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationAdministrationDosageList.GetEnumerator : TFhirMedicationAdministrationDosageListEnumerator;
begin
  result := TFhirMedicationAdministrationDosageListEnumerator.Create(self.link);
end;

function TFhirMedicationAdministrationDosageList.Clone: TFhirMedicationAdministrationDosageList;
begin
  result := TFhirMedicationAdministrationDosageList(inherited Clone);
end;

function TFhirMedicationAdministrationDosageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationAdministrationDosageList.GetItemN(index: Integer): TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage(ObjectByIndex[index]);
end;

function TFhirMedicationAdministrationDosageList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationAdministrationDosage;
end;
function TFhirMedicationAdministrationDosageList.IndexOf(value: TFhirMedicationAdministrationDosage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationAdministrationDosageList.Insert(index: Integer): TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationAdministrationDosageList.InsertItem(index: Integer; value: TFhirMedicationAdministrationDosage);
begin
  assert(value is TFhirMedicationAdministrationDosage);
  Inherited Insert(index, value);
end;

function TFhirMedicationAdministrationDosageList.Item(index: Integer): TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage(ObjectByIndex[index]);
end;

function TFhirMedicationAdministrationDosageList.Link: TFhirMedicationAdministrationDosageList;
begin
  result := TFhirMedicationAdministrationDosageList(inherited Link);
end;

procedure TFhirMedicationAdministrationDosageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationAdministrationDosageList.SetItemByIndex(index: Integer; value: TFhirMedicationAdministrationDosage);
begin
  assert(value is TFhirMedicationAdministrationDosage);
  FhirMedicationAdministrationDosages[index] := value;
end;

procedure TFhirMedicationAdministrationDosageList.SetItemN(index: Integer; value: TFhirMedicationAdministrationDosage);
begin
  assert(value is TFhirMedicationAdministrationDosage);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationAdministration }

constructor TFhirMedicationAdministration.Create;
begin
  inherited;
end;

destructor TFhirMedicationAdministration.Destroy;
begin
  FIdentifierList.Free;
  FDefinitionList.Free;
  FPartOfList.Free;
  FStatus.free;
  FCategory.free;
  FMedication.free;
  FSubject.free;
  FContext.free;
  FSupportingInformationList.Free;
  FEffective.free;
  FPerformerList.Free;
  FNotGiven.free;
  FReasonNotGivenList.Free;
  FReasonCodeList.Free;
  FReasonReferenceList.Free;
  FPrescription.free;
  FDeviceList.Free;
  FNoteList.Free;
  FDosage.free;
  FEventHistoryList.Free;
  inherited;
end;

function TFhirMedicationAdministration.GetResourceType : TFhirResourceType;
begin
  result := frtMedicationAdministration;
end;

procedure TFhirMedicationAdministration.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedicationAdministration(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirMedicationAdministration(oSource).FIdentifierList);
  end;
  if (TFhirMedicationAdministration(oSource).FDefinitionList = nil) then
  begin
    FDefinitionList.free;
    FDefinitionList := nil;
  end
  else
  begin
    if FDefinitionList = nil then
      FDefinitionList := TFhirReferenceList{Resource}.Create;
    FDefinitionList.Assign(TFhirMedicationAdministration(oSource).FDefinitionList);
  end;
  if (TFhirMedicationAdministration(oSource).FPartOfList = nil) then
  begin
    FPartOfList.free;
    FPartOfList := nil;
  end
  else
  begin
    if FPartOfList = nil then
      FPartOfList := TFhirReferenceList{Resource}.Create;
    FPartOfList.Assign(TFhirMedicationAdministration(oSource).FPartOfList);
  end;
  FStatus := TFhirMedicationAdministration(oSource).FStatus.Link;
  category := TFhirMedicationAdministration(oSource).category.Clone;
  medication := TFhirMedicationAdministration(oSource).medication.Clone;
  subject := TFhirMedicationAdministration(oSource).subject.Clone;
  context := TFhirMedicationAdministration(oSource).context.Clone;
  if (TFhirMedicationAdministration(oSource).FSupportingInformationList = nil) then
  begin
    FSupportingInformationList.free;
    FSupportingInformationList := nil;
  end
  else
  begin
    if FSupportingInformationList = nil then
      FSupportingInformationList := TFhirReferenceList{TFhirReference}.Create;
    FSupportingInformationList.Assign(TFhirMedicationAdministration(oSource).FSupportingInformationList);
  end;
  effective := TFhirMedicationAdministration(oSource).effective.Clone;
  if (TFhirMedicationAdministration(oSource).FPerformerList = nil) then
  begin
    FPerformerList.free;
    FPerformerList := nil;
  end
  else
  begin
    if FPerformerList = nil then
      FPerformerList := TFhirMedicationAdministrationPerformerList.Create;
    FPerformerList.Assign(TFhirMedicationAdministration(oSource).FPerformerList);
  end;
  notGivenElement := TFhirMedicationAdministration(oSource).notGivenElement.Clone;
  if (TFhirMedicationAdministration(oSource).FReasonNotGivenList = nil) then
  begin
    FReasonNotGivenList.free;
    FReasonNotGivenList := nil;
  end
  else
  begin
    if FReasonNotGivenList = nil then
      FReasonNotGivenList := TFhirCodeableConceptList.Create;
    FReasonNotGivenList.Assign(TFhirMedicationAdministration(oSource).FReasonNotGivenList);
  end;
  if (TFhirMedicationAdministration(oSource).FReasonCodeList = nil) then
  begin
    FReasonCodeList.free;
    FReasonCodeList := nil;
  end
  else
  begin
    if FReasonCodeList = nil then
      FReasonCodeList := TFhirCodeableConceptList.Create;
    FReasonCodeList.Assign(TFhirMedicationAdministration(oSource).FReasonCodeList);
  end;
  if (TFhirMedicationAdministration(oSource).FReasonReferenceList = nil) then
  begin
    FReasonReferenceList.free;
    FReasonReferenceList := nil;
  end
  else
  begin
    if FReasonReferenceList = nil then
      FReasonReferenceList := TFhirReferenceList{Resource}.Create;
    FReasonReferenceList.Assign(TFhirMedicationAdministration(oSource).FReasonReferenceList);
  end;
  prescription := TFhirMedicationAdministration(oSource).prescription.Clone;
  if (TFhirMedicationAdministration(oSource).FDeviceList = nil) then
  begin
    FDeviceList.free;
    FDeviceList := nil;
  end
  else
  begin
    if FDeviceList = nil then
      FDeviceList := TFhirReferenceList{TFhirDevice}.Create;
    FDeviceList.Assign(TFhirMedicationAdministration(oSource).FDeviceList);
  end;
  if (TFhirMedicationAdministration(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirMedicationAdministration(oSource).FNoteList);
  end;
  dosage := TFhirMedicationAdministration(oSource).dosage.Clone;
  if (TFhirMedicationAdministration(oSource).FEventHistoryList = nil) then
  begin
    FEventHistoryList.free;
    FEventHistoryList := nil;
  end
  else
  begin
    if FEventHistoryList = nil then
      FEventHistoryList := TFhirReferenceList{TFhirProvenance}.Create;
    FEventHistoryList.Assign(TFhirMedicationAdministration(oSource).FEventHistoryList);
  end;
end;

procedure TFhirMedicationAdministration.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'definition') Then
    list.addAll(self, 'definition', FDefinitionList);
  if (child_name = 'partOf') Then
    list.addAll(self, 'partOf', FPartOfList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'medication[x]') or (child_name = 'medication') Then
     list.add(self.link, 'medication[x]', FMedication.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
  if (child_name = 'supportingInformation') Then
    list.addAll(self, 'supportingInformation', FSupportingInformationList);
  if (child_name = 'effective[x]') or (child_name = 'effective') Then
     list.add(self.link, 'effective[x]', FEffective.Link);
  if (child_name = 'performer') Then
    list.addAll(self, 'performer', FPerformerList);
  if (child_name = 'notGiven') Then
     list.add(self.link, 'notGiven', FNotGiven.Link);
  if (child_name = 'reasonNotGiven') Then
    list.addAll(self, 'reasonNotGiven', FReasonNotGivenList);
  if (child_name = 'reasonCode') Then
    list.addAll(self, 'reasonCode', FReasonCodeList);
  if (child_name = 'reasonReference') Then
    list.addAll(self, 'reasonReference', FReasonReferenceList);
  if (child_name = 'prescription') Then
     list.add(self.link, 'prescription', FPrescription.Link);
  if (child_name = 'device') Then
    list.addAll(self, 'device', FDeviceList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'dosage') Then
     list.add(self.link, 'dosage', FDosage.Link);
  if (child_name = 'eventHistory') Then
    list.addAll(self, 'eventHistory', FEventHistoryList);
end;

procedure TFhirMedicationAdministration.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'definition', 'Reference(PlanDefinition|ActivityDefinition)', true, TFhirReference{Resource}, FDefinitionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference(MedicationAdministration|Procedure)', true, TFhirReference{Resource}, FPartOfList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'medication[x]', 'CodeableConcept|Reference(Medication)', false, TFhirType, FMedication.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Group)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'context', 'Reference(Encounter|EpisodeOfCare)', false, TFhirReference{Resource}, FContext.Link));{2}
  oList.add(TFHIRProperty.create(self, 'supportingInformation', 'Reference(Any)', true, TFhirReference{TFhirReference}, FSupportingInformationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'effective[x]', 'dateTime|Period', false, TFhirType, FEffective.Link));{2}
  oList.add(TFHIRProperty.create(self, 'performer', '', true, TFhirMedicationAdministrationPerformer, FPerformerList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'notGiven', 'boolean', false, TFhirBoolean, FNotGiven.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reasonNotGiven', 'CodeableConcept', true, TFhirCodeableConcept, FReasonNotGivenList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reasonCode', 'CodeableConcept', true, TFhirCodeableConcept, FReasonCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reasonReference', 'Reference(Condition|Observation)', true, TFhirReference{Resource}, FReasonReferenceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'prescription', 'Reference(MedicationRequest)', false, TFhirReference{TFhirMedicationRequest}, FPrescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'device', 'Reference(Device)', true, TFhirReference{TFhirDevice}, FDeviceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'dosage', '', false, TFhirMedicationAdministrationDosage, FDosage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'eventHistory', 'Reference(Provenance)', true, TFhirReference{TFhirProvenance}, FEventHistoryList.Link)){3};
end;

function TFhirMedicationAdministration.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'definition') then
  begin
    DefinitionList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOfList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirMedicationAdminStatusEnum, CODES_TFhirMedicationAdminStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then
  begin
    Medication := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'context') then
  begin
    Context := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'supportingInformation') then
  begin
    SupportingInformationList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then
  begin
    Effective := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    PerformerList.add(propValue as TFhirMedicationAdministrationPerformer){2a};
    result := propValue;
  end
  else if (propName = 'notGiven') then
  begin
    NotGivenElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'reasonNotGiven') then
  begin
    ReasonNotGivenList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'reasonCode') then
  begin
    ReasonCodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'reasonReference') then
  begin
    ReasonReferenceList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'prescription') then
  begin
    Prescription := propValue as TFhirReference{TFhirMedicationRequest}{4b};
    result := propValue;
  end
  else if (propName = 'device') then
  begin
    DeviceList.add(propValue as TFhirReference{TFhirDevice}){2a};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else if (propName = 'dosage') then
  begin
    Dosage := propValue as TFhirMedicationAdministrationDosage{4b};
    result := propValue;
  end
  else if (propName = 'eventHistory') then
  begin
    EventHistoryList.add(propValue as TFhirReference{TFhirProvenance}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirMedicationAdministration.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'definition') then DefinitionList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'partOf') then PartOfList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'supportingInformation') then SupportingInformationList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'performer') then PerformerList.insertItem(index, propValue as TFhirMedicationAdministrationPerformer){2a}
  else if (propName = 'reasonNotGiven') then ReasonNotGivenList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'reasonCode') then ReasonCodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'reasonReference') then ReasonReferenceList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'device') then DeviceList.insertItem(index, propValue as TFhirReference{TFhirDevice}){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else if (propName = 'eventHistory') then EventHistoryList.insertItem(index, propValue as TFhirReference{TFhirProvenance}){2a}
  else inherited;
end;

function TFhirMedicationAdministration.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'definition') then result := DefinitionList.new(){2}
  else if (propName = 'partOf') then result := PartOfList.new(){2}
  else if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Medication'){4x}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'context') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'supportingInformation') then result := SupportingInformationList.new(){2}
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Effective'){4x}
  else if (propName = 'performer') then result := PerformerList.new(){2}
  else if (propName = 'notGiven') then result := TFhirBoolean.create() {5b}
  else if (propName = 'reasonNotGiven') then result := ReasonNotGivenList.new(){2}
  else if (propName = 'reasonCode') then result := ReasonCodeList.new(){2}
  else if (propName = 'reasonReference') then result := ReasonReferenceList.new(){2}
  else if (propName = 'prescription') then result := TFhirReference{TFhirMedicationRequest}.create(){4b}
  else if (propName = 'device') then result := DeviceList.new(){2}
  else if (propName = 'note') then result := NoteList.new(){2}
  else if (propName = 'dosage') then result := TFhirMedicationAdministrationDosage.create(){4b}
  else if (propName = 'eventHistory') then result := EventHistoryList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationAdministration.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'definition') then result := 'Reference'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'medication[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'context') then result := 'Reference'
  else if (propName = 'supportingInformation') then result := 'Reference'
  else if (propName = 'effective[x]') then result := 'dateTime|Period'
  else if (propName = 'performer') then result := ''
  else if (propName = 'notGiven') then result := 'boolean'
  else if (propName = 'reasonNotGiven') then result := 'CodeableConcept'
  else if (propName = 'reasonCode') then result := 'CodeableConcept'
  else if (propName = 'reasonReference') then result := 'Reference'
  else if (propName = 'prescription') then result := 'Reference'
  else if (propName = 'device') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'dosage') then result := ''
  else if (propName = 'eventHistory') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationAdministration.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'definition') then deletePropertyValue('definition', DefinitionList, value) {2}
  else if (propName = 'partOf') then deletePropertyValue('partOf', PartOfList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then MedicationElement := nil{4x}
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'context') then ContextElement := nil
  else if (propName = 'supportingInformation') then deletePropertyValue('supportingInformation', SupportingInformationList, value) {2}
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then EffectiveElement := nil{4x}
  else if (propName = 'performer') then deletePropertyValue('performer', PerformerList, value) {2}
  else if (propName = 'notGiven') then NotGivenElement := nil
  else if (propName = 'reasonNotGiven') then deletePropertyValue('reasonNotGiven', ReasonNotGivenList, value) {2}
  else if (propName = 'reasonCode') then deletePropertyValue('reasonCode', ReasonCodeList, value) {2}
  else if (propName = 'reasonReference') then deletePropertyValue('reasonReference', ReasonReferenceList, value) {2}
  else if (propName = 'prescription') then PrescriptionElement := nil
  else if (propName = 'device') then deletePropertyValue('device', DeviceList, value) {2}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else if (propName = 'dosage') then DosageElement := nil
  else if (propName = 'eventHistory') then deletePropertyValue('eventHistory', EventHistoryList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationAdministration.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'definition') then replacePropertyValue('definition', DefinitionList, existing, new) {2}
  else if (propName = 'partOf') then replacePropertyValue('partOf', PartOfList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirMedicationAdminStatusEnum, CODES_TFhirMedicationAdminStatusEnum, new){4}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then MedicationElement := new as TFhirType{4x}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'context') then ContextElement := new as TFhirReference{Resource}{4}
  else if (propName = 'supportingInformation') then replacePropertyValue('supportingInformation', SupportingInformationList, existing, new) {2}
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then EffectiveElement := new as TFhirType{4x}
  else if (propName = 'performer') then replacePropertyValue('performer', PerformerList, existing, new) {2}
  else if (propName = 'notGiven') then NotGivenElement := asBoolean(new){5b}
  else if (propName = 'reasonNotGiven') then replacePropertyValue('reasonNotGiven', ReasonNotGivenList, existing, new) {2}
  else if (propName = 'reasonCode') then replacePropertyValue('reasonCode', ReasonCodeList, existing, new) {2}
  else if (propName = 'reasonReference') then replacePropertyValue('reasonReference', ReasonReferenceList, existing, new) {2}
  else if (propName = 'prescription') then PrescriptionElement := new as TFhirReference{TFhirMedicationRequest}{4}
  else if (propName = 'device') then replacePropertyValue('device', DeviceList, existing, new) {2}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else if (propName = 'dosage') then DosageElement := new as TFhirMedicationAdministrationDosage{4}
  else if (propName = 'eventHistory') then replacePropertyValue('eventHistory', EventHistoryList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationAdministration.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'definition') then DefinitionList.move(source, destination){2a}
  else if (propName = 'partOf') then PartOfList.move(source, destination){2a}
  else if (propName = 'supportingInformation') then SupportingInformationList.move(source, destination){2a}
  else if (propName = 'performer') then PerformerList.move(source, destination){2a}
  else if (propName = 'reasonNotGiven') then ReasonNotGivenList.move(source, destination){2a}
  else if (propName = 'reasonCode') then ReasonCodeList.move(source, destination){2a}
  else if (propName = 'reasonReference') then ReasonReferenceList.move(source, destination){2a}
  else if (propName = 'device') then DeviceList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else if (propName = 'eventHistory') then EventHistoryList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationAdministration.fhirType : string;
begin
  result := 'MedicationAdministration';
end;

function TFhirMedicationAdministration.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FdefinitionList) and isEmptyProp(FpartOfList) and isEmptyProp(FStatus) and isEmptyProp(FCategory) and isEmptyProp(FMedication) and isEmptyProp(FSubject) and isEmptyProp(FContext) and isEmptyProp(FsupportingInformationList) and isEmptyProp(FEffective) and isEmptyProp(FperformerList) and isEmptyProp(FNotGiven) and isEmptyProp(FreasonNotGivenList) and isEmptyProp(FreasonCodeList) and isEmptyProp(FreasonReferenceList) and isEmptyProp(FPrescription) and isEmptyProp(FdeviceList) and isEmptyProp(FnoteList) and isEmptyProp(FDosage) and isEmptyProp(FeventHistoryList);
end;

function TFhirMedicationAdministration.equals(other : TObject) : boolean;
var
  o : TFhirMedicationAdministration;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationAdministration)) then
    result := false
  else
  begin
    o := TFhirMedicationAdministration(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(definitionList, o.definitionList, true) and
      compareDeep(partOfList, o.partOfList, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(categoryElement, o.categoryElement, true) and compareDeep(medicationElement, o.medicationElement, true) and
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(contextElement, o.contextElement, true) and
      compareDeep(supportingInformationList, o.supportingInformationList, true) and
      compareDeep(effectiveElement, o.effectiveElement, true) and compareDeep(performerList, o.performerList, true) and
      compareDeep(notGivenElement, o.notGivenElement, true) and compareDeep(reasonNotGivenList, o.reasonNotGivenList, true) and
      compareDeep(reasonCodeList, o.reasonCodeList, true) and compareDeep(reasonReferenceList, o.reasonReferenceList, true) and
      compareDeep(prescriptionElement, o.prescriptionElement, true) and compareDeep(deviceList, o.deviceList, true) and
      compareDeep(noteList, o.noteList, true) and compareDeep(dosageElement, o.dosageElement, true) and
      compareDeep(eventHistoryList, o.eventHistoryList, true);
  end;
end;

function TFhirMedicationAdministration.Link : TFhirMedicationAdministration;
begin
  result := TFhirMedicationAdministration(inherited Link);
end;

function TFhirMedicationAdministration.Clone : TFhirMedicationAdministration;
begin
  result := TFhirMedicationAdministration(inherited Clone);
end;

procedure TFhirMedicationAdministration.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('definition');
  fields.add('partOf');
  fields.add('status');
  fields.add('category');
  fields.add('medication[x]');
  fields.add('subject');
  fields.add('context');
  fields.add('supportingInformation');
  fields.add('effective[x]');
  fields.add('performer');
  fields.add('notGiven');
  fields.add('reasonNotGiven');
  fields.add('reasonCode');
  fields.add('reasonReference');
  fields.add('prescription');
  fields.add('device');
  fields.add('note');
  fields.add('dosage');
  fields.add('eventHistory');
end;

{ TFhirMedicationAdministration }

Function TFhirMedicationAdministration.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirMedicationAdministration.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Function TFhirMedicationAdministration.GetDefinitionList : TFhirReferenceList{Resource};
begin
  if FDefinitionList = nil then
    FDefinitionList := TFhirReferenceList{Resource}.Create;
  result := FDefinitionList;
end;

Function TFhirMedicationAdministration.GetHasDefinitionList : boolean;
begin
  result := (FDefinitionList <> nil) and (FDefinitionList.count > 0);
end;

Function TFhirMedicationAdministration.GetPartOfList : TFhirReferenceList{Resource};
begin
  if FPartOfList = nil then
    FPartOfList := TFhirReferenceList{Resource}.Create;
  result := FPartOfList;
end;

Function TFhirMedicationAdministration.GetHasPartOfList : boolean;
begin
  result := (FPartOfList <> nil) and (FPartOfList.count > 0);
end;

Procedure TFhirMedicationAdministration.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirMedicationAdministration.GetStatusST : TFhirMedicationAdminStatusEnum;
begin
  if FStatus = nil then
    result := TFhirMedicationAdminStatusEnum(0)
  else
    result := TFhirMedicationAdminStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirMedicationAdminStatusEnum, FStatus.value));
end;

Procedure TFhirMedicationAdministration.SetStatusST(value : TFhirMedicationAdminStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirMedicationAdminStatusEnum[value], CODES_TFhirMedicationAdminStatusEnum[value]);
end;

Procedure TFhirMedicationAdministration.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirMedicationAdministration.SetMedication(value : TFhirType);
begin
  FMedication.free;
  FMedication := value;
end;

Procedure TFhirMedicationAdministration.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirMedicationAdministration.SetContext(value : TFhirReference{Resource});
begin
  FContext.free;
  FContext := value;
end;

Function TFhirMedicationAdministration.GetSupportingInformationList : TFhirReferenceList{TFhirReference};
begin
  if FSupportingInformationList = nil then
    FSupportingInformationList := TFhirReferenceList{TFhirReference}.Create;
  result := FSupportingInformationList;
end;

Function TFhirMedicationAdministration.GetHasSupportingInformationList : boolean;
begin
  result := (FSupportingInformationList <> nil) and (FSupportingInformationList.count > 0);
end;

Procedure TFhirMedicationAdministration.SetEffective(value : TFhirType);
begin
  FEffective.free;
  FEffective := value;
end;

Function TFhirMedicationAdministration.GetPerformerList : TFhirMedicationAdministrationPerformerList;
begin
  if FPerformerList = nil then
    FPerformerList := TFhirMedicationAdministrationPerformerList.Create;
  result := FPerformerList;
end;

Function TFhirMedicationAdministration.GetHasPerformerList : boolean;
begin
  result := (FPerformerList <> nil) and (FPerformerList.count > 0);
end;

Procedure TFhirMedicationAdministration.SetNotGiven(value : TFhirBoolean);
begin
  FNotGiven.free;
  FNotGiven := value;
end;

Function TFhirMedicationAdministration.GetNotGivenST : Boolean;
begin
  if FNotGiven = nil then
    result := false
  else
    result := FNotGiven.value;
end;

Procedure TFhirMedicationAdministration.SetNotGivenST(value : Boolean);
begin
  if FNotGiven = nil then
    FNotGiven := TFhirBoolean.create;
  FNotGiven.value := value
end;

Function TFhirMedicationAdministration.GetReasonNotGivenList : TFhirCodeableConceptList;
begin
  if FReasonNotGivenList = nil then
    FReasonNotGivenList := TFhirCodeableConceptList.Create;
  result := FReasonNotGivenList;
end;

Function TFhirMedicationAdministration.GetHasReasonNotGivenList : boolean;
begin
  result := (FReasonNotGivenList <> nil) and (FReasonNotGivenList.count > 0);
end;

Function TFhirMedicationAdministration.GetReasonCodeList : TFhirCodeableConceptList;
begin
  if FReasonCodeList = nil then
    FReasonCodeList := TFhirCodeableConceptList.Create;
  result := FReasonCodeList;
end;

Function TFhirMedicationAdministration.GetHasReasonCodeList : boolean;
begin
  result := (FReasonCodeList <> nil) and (FReasonCodeList.count > 0);
end;

Function TFhirMedicationAdministration.GetReasonReferenceList : TFhirReferenceList{Resource};
begin
  if FReasonReferenceList = nil then
    FReasonReferenceList := TFhirReferenceList{Resource}.Create;
  result := FReasonReferenceList;
end;

Function TFhirMedicationAdministration.GetHasReasonReferenceList : boolean;
begin
  result := (FReasonReferenceList <> nil) and (FReasonReferenceList.count > 0);
end;

Procedure TFhirMedicationAdministration.SetPrescription(value : TFhirReference{TFhirMedicationRequest});
begin
  FPrescription.free;
  FPrescription := value;
end;

Function TFhirMedicationAdministration.GetDeviceList : TFhirReferenceList{TFhirDevice};
begin
  if FDeviceList = nil then
    FDeviceList := TFhirReferenceList{TFhirDevice}.Create;
  result := FDeviceList;
end;

Function TFhirMedicationAdministration.GetHasDeviceList : boolean;
begin
  result := (FDeviceList <> nil) and (FDeviceList.count > 0);
end;

Function TFhirMedicationAdministration.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirMedicationAdministration.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

Procedure TFhirMedicationAdministration.SetDosage(value : TFhirMedicationAdministrationDosage);
begin
  FDosage.free;
  FDosage := value;
end;

Function TFhirMedicationAdministration.GetEventHistoryList : TFhirReferenceList{TFhirProvenance};
begin
  if FEventHistoryList = nil then
    FEventHistoryList := TFhirReferenceList{TFhirProvenance}.Create;
  result := FEventHistoryList;
end;

Function TFhirMedicationAdministration.GetHasEventHistoryList : boolean;
begin
  result := (FEventHistoryList <> nil) and (FEventHistoryList.count > 0);
end;

function TFhirMedicationAdministration.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FdefinitionList.sizeInBytes);
  inc(result, FpartOfList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FMedication.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FContext.sizeInBytes);
  inc(result, FsupportingInformationList.sizeInBytes);
  inc(result, FEffective.sizeInBytes);
  inc(result, FperformerList.sizeInBytes);
  inc(result, FNotGiven.sizeInBytes);
  inc(result, FreasonNotGivenList.sizeInBytes);
  inc(result, FreasonCodeList.sizeInBytes);
  inc(result, FreasonReferenceList.sizeInBytes);
  inc(result, FPrescription.sizeInBytes);
  inc(result, FdeviceList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FDosage.sizeInBytes);
  inc(result, FeventHistoryList.sizeInBytes);
end;

{ TFhirMedicationAdministrationListEnumerator }

Constructor TFhirMedicationAdministrationListEnumerator.Create(list : TFhirMedicationAdministrationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationAdministrationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationAdministrationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationAdministrationListEnumerator.GetCurrent : TFhirMedicationAdministration;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationAdministrationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationAdministrationList }
procedure TFhirMedicationAdministrationList.AddItem(value: TFhirMedicationAdministration);
begin
  assert(value.ClassName = 'TFhirMedicationAdministration', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationAdministration');
  add(value);
end;

function TFhirMedicationAdministrationList.Append: TFhirMedicationAdministration;
begin
  result := TFhirMedicationAdministration.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationAdministrationList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationAdministrationList.GetEnumerator : TFhirMedicationAdministrationListEnumerator;
begin
  result := TFhirMedicationAdministrationListEnumerator.Create(self.link);
end;

function TFhirMedicationAdministrationList.Clone: TFhirMedicationAdministrationList;
begin
  result := TFhirMedicationAdministrationList(inherited Clone);
end;

function TFhirMedicationAdministrationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationAdministrationList.GetItemN(index: Integer): TFhirMedicationAdministration;
begin
  result := TFhirMedicationAdministration(ObjectByIndex[index]);
end;

function TFhirMedicationAdministrationList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationAdministration;
end;
function TFhirMedicationAdministrationList.IndexOf(value: TFhirMedicationAdministration): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationAdministrationList.Insert(index: Integer): TFhirMedicationAdministration;
begin
  result := TFhirMedicationAdministration.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationAdministrationList.InsertItem(index: Integer; value: TFhirMedicationAdministration);
begin
  assert(value is TFhirMedicationAdministration);
  Inherited Insert(index, value);
end;

function TFhirMedicationAdministrationList.Item(index: Integer): TFhirMedicationAdministration;
begin
  result := TFhirMedicationAdministration(ObjectByIndex[index]);
end;

function TFhirMedicationAdministrationList.Link: TFhirMedicationAdministrationList;
begin
  result := TFhirMedicationAdministrationList(inherited Link);
end;

procedure TFhirMedicationAdministrationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationAdministrationList.SetItemByIndex(index: Integer; value: TFhirMedicationAdministration);
begin
  assert(value is TFhirMedicationAdministration);
  FhirMedicationAdministrations[index] := value;
end;

procedure TFhirMedicationAdministrationList.SetItemN(index: Integer; value: TFhirMedicationAdministration);
begin
  assert(value is TFhirMedicationAdministration);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEDICATIONADMINISTRATION}

{$IFDEF FHIR_MEDICATIONDISPENSE}

{ TFhirMedicationDispensePerformer }

constructor TFhirMedicationDispensePerformer.Create;
begin
  inherited;
end;

destructor TFhirMedicationDispensePerformer.Destroy;
begin
  FActor.free;
  FOnBehalfOf.free;
  inherited;
end;

procedure TFhirMedicationDispensePerformer.Assign(oSource : TFslObject);
begin
  inherited;
  actor := TFhirMedicationDispensePerformer(oSource).actor.Clone;
  onBehalfOf := TFhirMedicationDispensePerformer(oSource).onBehalfOf.Clone;
end;

procedure TFhirMedicationDispensePerformer.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'actor') Then
     list.add(self.link, 'actor', FActor.Link);
  if (child_name = 'onBehalfOf') Then
     list.add(self.link, 'onBehalfOf', FOnBehalfOf.Link);
end;

procedure TFhirMedicationDispensePerformer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'actor', 'Reference(Practitioner|Organization|Patient|Device|RelatedPerson)', false, TFhirReference{Resource}, FActor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'onBehalfOf', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FOnBehalfOf.Link));{2}
end;

function TFhirMedicationDispensePerformer.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'actor') then
  begin
    Actor := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'onBehalfOf') then
  begin
    OnBehalfOf := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationDispensePerformer.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationDispensePerformer.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'actor') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'onBehalfOf') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationDispensePerformer.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'actor') then result := 'Reference'
  else if (propName = 'onBehalfOf') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationDispensePerformer.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'actor') then ActorElement := nil
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationDispensePerformer.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'actor') then ActorElement := new as TFhirReference{Resource}{4}
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := new as TFhirReference{TFhirOrganization}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationDispensePerformer.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationDispensePerformer.fhirType : string;
begin
  result := 'performer';
end;

function TFhirMedicationDispensePerformer.Link : TFhirMedicationDispensePerformer;
begin
  result := TFhirMedicationDispensePerformer(inherited Link);
end;

function TFhirMedicationDispensePerformer.Clone : TFhirMedicationDispensePerformer;
begin
  result := TFhirMedicationDispensePerformer(inherited Clone);
end;

function TFhirMedicationDispensePerformer.equals(other : TObject) : boolean;
var
  o : TFhirMedicationDispensePerformer;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationDispensePerformer)) then
    result := false
  else
  begin
    o := TFhirMedicationDispensePerformer(other);
    result := compareDeep(actorElement, o.actorElement, true) and compareDeep(onBehalfOfElement, o.onBehalfOfElement, true);
  end;
end;

function TFhirMedicationDispensePerformer.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FActor) and isEmptyProp(FOnBehalfOf);
end;

procedure TFhirMedicationDispensePerformer.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('actor');
  fields.add('onBehalfOf');
end;

{ TFhirMedicationDispensePerformer }

Procedure TFhirMedicationDispensePerformer.SetActor(value : TFhirReference{Resource});
begin
  FActor.free;
  FActor := value;
end;

Procedure TFhirMedicationDispensePerformer.SetOnBehalfOf(value : TFhirReference{TFhirOrganization});
begin
  FOnBehalfOf.free;
  FOnBehalfOf := value;
end;

function TFhirMedicationDispensePerformer.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FActor.sizeInBytes);
  inc(result, FOnBehalfOf.sizeInBytes);
end;

{ TFhirMedicationDispensePerformerListEnumerator }

Constructor TFhirMedicationDispensePerformerListEnumerator.Create(list : TFhirMedicationDispensePerformerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationDispensePerformerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationDispensePerformerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationDispensePerformerListEnumerator.GetCurrent : TFhirMedicationDispensePerformer;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationDispensePerformerListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationDispensePerformerList }
procedure TFhirMedicationDispensePerformerList.AddItem(value: TFhirMedicationDispensePerformer);
begin
  assert(value.ClassName = 'TFhirMedicationDispensePerformer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationDispensePerformer');
  add(value);
end;

function TFhirMedicationDispensePerformerList.Append: TFhirMedicationDispensePerformer;
begin
  result := TFhirMedicationDispensePerformer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationDispensePerformerList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationDispensePerformerList.GetEnumerator : TFhirMedicationDispensePerformerListEnumerator;
begin
  result := TFhirMedicationDispensePerformerListEnumerator.Create(self.link);
end;

function TFhirMedicationDispensePerformerList.Clone: TFhirMedicationDispensePerformerList;
begin
  result := TFhirMedicationDispensePerformerList(inherited Clone);
end;

function TFhirMedicationDispensePerformerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationDispensePerformerList.GetItemN(index: Integer): TFhirMedicationDispensePerformer;
begin
  result := TFhirMedicationDispensePerformer(ObjectByIndex[index]);
end;

function TFhirMedicationDispensePerformerList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationDispensePerformer;
end;
function TFhirMedicationDispensePerformerList.IndexOf(value: TFhirMedicationDispensePerformer): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationDispensePerformerList.Insert(index: Integer): TFhirMedicationDispensePerformer;
begin
  result := TFhirMedicationDispensePerformer.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationDispensePerformerList.InsertItem(index: Integer; value: TFhirMedicationDispensePerformer);
begin
  assert(value is TFhirMedicationDispensePerformer);
  Inherited Insert(index, value);
end;

function TFhirMedicationDispensePerformerList.Item(index: Integer): TFhirMedicationDispensePerformer;
begin
  result := TFhirMedicationDispensePerformer(ObjectByIndex[index]);
end;

function TFhirMedicationDispensePerformerList.Link: TFhirMedicationDispensePerformerList;
begin
  result := TFhirMedicationDispensePerformerList(inherited Link);
end;

procedure TFhirMedicationDispensePerformerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationDispensePerformerList.SetItemByIndex(index: Integer; value: TFhirMedicationDispensePerformer);
begin
  assert(value is TFhirMedicationDispensePerformer);
  FhirMedicationDispensePerformers[index] := value;
end;

procedure TFhirMedicationDispensePerformerList.SetItemN(index: Integer; value: TFhirMedicationDispensePerformer);
begin
  assert(value is TFhirMedicationDispensePerformer);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationDispenseSubstitution }

constructor TFhirMedicationDispenseSubstitution.Create;
begin
  inherited;
end;

destructor TFhirMedicationDispenseSubstitution.Destroy;
begin
  FWasSubstituted.free;
  FType_.free;
  FReasonList.Free;
  FResponsiblePartyList.Free;
  inherited;
end;

procedure TFhirMedicationDispenseSubstitution.Assign(oSource : TFslObject);
begin
  inherited;
  wasSubstitutedElement := TFhirMedicationDispenseSubstitution(oSource).wasSubstitutedElement.Clone;
  type_ := TFhirMedicationDispenseSubstitution(oSource).type_.Clone;
  if (TFhirMedicationDispenseSubstitution(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableConceptList.Create;
    FReasonList.Assign(TFhirMedicationDispenseSubstitution(oSource).FReasonList);
  end;
  if (TFhirMedicationDispenseSubstitution(oSource).FResponsiblePartyList = nil) then
  begin
    FResponsiblePartyList.free;
    FResponsiblePartyList := nil;
  end
  else
  begin
    if FResponsiblePartyList = nil then
      FResponsiblePartyList := TFhirReferenceList{TFhirPractitioner}.Create;
    FResponsiblePartyList.Assign(TFhirMedicationDispenseSubstitution(oSource).FResponsiblePartyList);
  end;
end;

procedure TFhirMedicationDispenseSubstitution.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'wasSubstituted') Then
     list.add(self.link, 'wasSubstituted', FWasSubstituted.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'responsibleParty') Then
    list.addAll(self, 'responsibleParty', FResponsiblePartyList);
end;

procedure TFhirMedicationDispenseSubstitution.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'wasSubstituted', 'boolean', false, TFhirBoolean, FWasSubstituted.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', true, TFhirCodeableConcept, FReasonList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'responsibleParty', 'Reference(Practitioner)', true, TFhirReference{TFhirPractitioner}, FResponsiblePartyList.Link)){3};
end;

function TFhirMedicationDispenseSubstitution.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'wasSubstituted') then
  begin
    WasSubstitutedElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'responsibleParty') then
  begin
    ResponsiblePartyList.add(propValue as TFhirReference{TFhirPractitioner}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationDispenseSubstitution.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'responsibleParty') then ResponsiblePartyList.insertItem(index, propValue as TFhirReference{TFhirPractitioner}){2a}
  else inherited;
end;

function TFhirMedicationDispenseSubstitution.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'wasSubstituted') then result := TFhirBoolean.create() {5b}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'reason') then result := ReasonList.new(){2}
  else if (propName = 'responsibleParty') then result := ResponsiblePartyList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationDispenseSubstitution.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'wasSubstituted') then result := 'boolean'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else if (propName = 'responsibleParty') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationDispenseSubstitution.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'wasSubstituted') then WasSubstitutedElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value) {2}
  else if (propName = 'responsibleParty') then deletePropertyValue('responsibleParty', ResponsiblePartyList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationDispenseSubstitution.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'wasSubstituted') then WasSubstitutedElement := asBoolean(new){5b}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new) {2}
  else if (propName = 'responsibleParty') then replacePropertyValue('responsibleParty', ResponsiblePartyList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationDispenseSubstitution.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'reason') then ReasonList.move(source, destination){2a}
  else if (propName = 'responsibleParty') then ResponsiblePartyList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationDispenseSubstitution.fhirType : string;
begin
  result := 'substitution';
end;

function TFhirMedicationDispenseSubstitution.Link : TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution(inherited Link);
end;

function TFhirMedicationDispenseSubstitution.Clone : TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution(inherited Clone);
end;

function TFhirMedicationDispenseSubstitution.equals(other : TObject) : boolean;
var
  o : TFhirMedicationDispenseSubstitution;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationDispenseSubstitution)) then
    result := false
  else
  begin
    o := TFhirMedicationDispenseSubstitution(other);
    result := compareDeep(wasSubstitutedElement, o.wasSubstitutedElement, true) and
      compareDeep(type_Element, o.type_Element, true) and compareDeep(reasonList, o.reasonList, true) and
      compareDeep(responsiblePartyList, o.responsiblePartyList, true);
  end;
end;

function TFhirMedicationDispenseSubstitution.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FWasSubstituted) and isEmptyProp(FType_) and isEmptyProp(FreasonList) and isEmptyProp(FresponsiblePartyList);
end;

procedure TFhirMedicationDispenseSubstitution.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('wasSubstituted');
  fields.add('type');
  fields.add('reason');
  fields.add('responsibleParty');
end;

{ TFhirMedicationDispenseSubstitution }

Procedure TFhirMedicationDispenseSubstitution.SetWasSubstituted(value : TFhirBoolean);
begin
  FWasSubstituted.free;
  FWasSubstituted := value;
end;

Function TFhirMedicationDispenseSubstitution.GetWasSubstitutedST : Boolean;
begin
  if FWasSubstituted = nil then
    result := false
  else
    result := FWasSubstituted.value;
end;

Procedure TFhirMedicationDispenseSubstitution.SetWasSubstitutedST(value : Boolean);
begin
  if FWasSubstituted = nil then
    FWasSubstituted := TFhirBoolean.create;
  FWasSubstituted.value := value
end;

Procedure TFhirMedicationDispenseSubstitution.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirMedicationDispenseSubstitution.GetReasonList : TFhirCodeableConceptList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableConceptList.Create;
  result := FReasonList;
end;

Function TFhirMedicationDispenseSubstitution.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

Function TFhirMedicationDispenseSubstitution.GetResponsiblePartyList : TFhirReferenceList{TFhirPractitioner};
begin
  if FResponsiblePartyList = nil then
    FResponsiblePartyList := TFhirReferenceList{TFhirPractitioner}.Create;
  result := FResponsiblePartyList;
end;

Function TFhirMedicationDispenseSubstitution.GetHasResponsiblePartyList : boolean;
begin
  result := (FResponsiblePartyList <> nil) and (FResponsiblePartyList.count > 0);
end;

function TFhirMedicationDispenseSubstitution.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FWasSubstituted.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FreasonList.sizeInBytes);
  inc(result, FresponsiblePartyList.sizeInBytes);
end;

{ TFhirMedicationDispenseSubstitutionListEnumerator }

Constructor TFhirMedicationDispenseSubstitutionListEnumerator.Create(list : TFhirMedicationDispenseSubstitutionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationDispenseSubstitutionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationDispenseSubstitutionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationDispenseSubstitutionListEnumerator.GetCurrent : TFhirMedicationDispenseSubstitution;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationDispenseSubstitutionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationDispenseSubstitutionList }
procedure TFhirMedicationDispenseSubstitutionList.AddItem(value: TFhirMedicationDispenseSubstitution);
begin
  assert(value.ClassName = 'TFhirMedicationDispenseSubstitution', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationDispenseSubstitution');
  add(value);
end;

function TFhirMedicationDispenseSubstitutionList.Append: TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationDispenseSubstitutionList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationDispenseSubstitutionList.GetEnumerator : TFhirMedicationDispenseSubstitutionListEnumerator;
begin
  result := TFhirMedicationDispenseSubstitutionListEnumerator.Create(self.link);
end;

function TFhirMedicationDispenseSubstitutionList.Clone: TFhirMedicationDispenseSubstitutionList;
begin
  result := TFhirMedicationDispenseSubstitutionList(inherited Clone);
end;

function TFhirMedicationDispenseSubstitutionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationDispenseSubstitutionList.GetItemN(index: Integer): TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution(ObjectByIndex[index]);
end;

function TFhirMedicationDispenseSubstitutionList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationDispenseSubstitution;
end;
function TFhirMedicationDispenseSubstitutionList.IndexOf(value: TFhirMedicationDispenseSubstitution): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationDispenseSubstitutionList.Insert(index: Integer): TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationDispenseSubstitutionList.InsertItem(index: Integer; value: TFhirMedicationDispenseSubstitution);
begin
  assert(value is TFhirMedicationDispenseSubstitution);
  Inherited Insert(index, value);
end;

function TFhirMedicationDispenseSubstitutionList.Item(index: Integer): TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution(ObjectByIndex[index]);
end;

function TFhirMedicationDispenseSubstitutionList.Link: TFhirMedicationDispenseSubstitutionList;
begin
  result := TFhirMedicationDispenseSubstitutionList(inherited Link);
end;

procedure TFhirMedicationDispenseSubstitutionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationDispenseSubstitutionList.SetItemByIndex(index: Integer; value: TFhirMedicationDispenseSubstitution);
begin
  assert(value is TFhirMedicationDispenseSubstitution);
  FhirMedicationDispenseSubstitutions[index] := value;
end;

procedure TFhirMedicationDispenseSubstitutionList.SetItemN(index: Integer; value: TFhirMedicationDispenseSubstitution);
begin
  assert(value is TFhirMedicationDispenseSubstitution);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationDispense }

constructor TFhirMedicationDispense.Create;
begin
  inherited;
end;

destructor TFhirMedicationDispense.Destroy;
begin
  FIdentifierList.Free;
  FPartOfList.Free;
  FStatus.free;
  FCategory.free;
  FMedication.free;
  FSubject.free;
  FContext.free;
  FSupportingInformationList.Free;
  FPerformerList.Free;
  FAuthorizingPrescriptionList.Free;
  FType_.free;
  FQuantity.free;
  FDaysSupply.free;
  FWhenPrepared.free;
  FWhenHandedOver.free;
  FDestination.free;
  FReceiverList.Free;
  FNoteList.Free;
  FDosageInstructionList.Free;
  FSubstitution.free;
  FDetectedIssueList.Free;
  FNotDone.free;
  FNotDoneReason.free;
  FEventHistoryList.Free;
  inherited;
end;

function TFhirMedicationDispense.GetResourceType : TFhirResourceType;
begin
  result := frtMedicationDispense;
end;

procedure TFhirMedicationDispense.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedicationDispense(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirMedicationDispense(oSource).FIdentifierList);
  end;
  if (TFhirMedicationDispense(oSource).FPartOfList = nil) then
  begin
    FPartOfList.free;
    FPartOfList := nil;
  end
  else
  begin
    if FPartOfList = nil then
      FPartOfList := TFhirReferenceList{TFhirProcedure}.Create;
    FPartOfList.Assign(TFhirMedicationDispense(oSource).FPartOfList);
  end;
  FStatus := TFhirMedicationDispense(oSource).FStatus.Link;
  category := TFhirMedicationDispense(oSource).category.Clone;
  medication := TFhirMedicationDispense(oSource).medication.Clone;
  subject := TFhirMedicationDispense(oSource).subject.Clone;
  context := TFhirMedicationDispense(oSource).context.Clone;
  if (TFhirMedicationDispense(oSource).FSupportingInformationList = nil) then
  begin
    FSupportingInformationList.free;
    FSupportingInformationList := nil;
  end
  else
  begin
    if FSupportingInformationList = nil then
      FSupportingInformationList := TFhirReferenceList{TFhirReference}.Create;
    FSupportingInformationList.Assign(TFhirMedicationDispense(oSource).FSupportingInformationList);
  end;
  if (TFhirMedicationDispense(oSource).FPerformerList = nil) then
  begin
    FPerformerList.free;
    FPerformerList := nil;
  end
  else
  begin
    if FPerformerList = nil then
      FPerformerList := TFhirMedicationDispensePerformerList.Create;
    FPerformerList.Assign(TFhirMedicationDispense(oSource).FPerformerList);
  end;
  if (TFhirMedicationDispense(oSource).FAuthorizingPrescriptionList = nil) then
  begin
    FAuthorizingPrescriptionList.free;
    FAuthorizingPrescriptionList := nil;
  end
  else
  begin
    if FAuthorizingPrescriptionList = nil then
      FAuthorizingPrescriptionList := TFhirReferenceList{TFhirMedicationRequest}.Create;
    FAuthorizingPrescriptionList.Assign(TFhirMedicationDispense(oSource).FAuthorizingPrescriptionList);
  end;
  type_ := TFhirMedicationDispense(oSource).type_.Clone;
  quantity := TFhirMedicationDispense(oSource).quantity.Clone;
  daysSupply := TFhirMedicationDispense(oSource).daysSupply.Clone;
  whenPreparedElement := TFhirMedicationDispense(oSource).whenPreparedElement.Clone;
  whenHandedOverElement := TFhirMedicationDispense(oSource).whenHandedOverElement.Clone;
  destination := TFhirMedicationDispense(oSource).destination.Clone;
  if (TFhirMedicationDispense(oSource).FReceiverList = nil) then
  begin
    FReceiverList.free;
    FReceiverList := nil;
  end
  else
  begin
    if FReceiverList = nil then
      FReceiverList := TFhirReferenceList{Resource}.Create;
    FReceiverList.Assign(TFhirMedicationDispense(oSource).FReceiverList);
  end;
  if (TFhirMedicationDispense(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirMedicationDispense(oSource).FNoteList);
  end;
  if (TFhirMedicationDispense(oSource).FDosageInstructionList = nil) then
  begin
    FDosageInstructionList.free;
    FDosageInstructionList := nil;
  end
  else
  begin
    if FDosageInstructionList = nil then
      FDosageInstructionList := TFhirDosageList.Create;
    FDosageInstructionList.Assign(TFhirMedicationDispense(oSource).FDosageInstructionList);
  end;
  substitution := TFhirMedicationDispense(oSource).substitution.Clone;
  if (TFhirMedicationDispense(oSource).FDetectedIssueList = nil) then
  begin
    FDetectedIssueList.free;
    FDetectedIssueList := nil;
  end
  else
  begin
    if FDetectedIssueList = nil then
      FDetectedIssueList := TFhirReferenceList{TFhirDetectedIssue}.Create;
    FDetectedIssueList.Assign(TFhirMedicationDispense(oSource).FDetectedIssueList);
  end;
  notDoneElement := TFhirMedicationDispense(oSource).notDoneElement.Clone;
  notDoneReason := TFhirMedicationDispense(oSource).notDoneReason.Clone;
  if (TFhirMedicationDispense(oSource).FEventHistoryList = nil) then
  begin
    FEventHistoryList.free;
    FEventHistoryList := nil;
  end
  else
  begin
    if FEventHistoryList = nil then
      FEventHistoryList := TFhirReferenceList{TFhirProvenance}.Create;
    FEventHistoryList.Assign(TFhirMedicationDispense(oSource).FEventHistoryList);
  end;
end;

procedure TFhirMedicationDispense.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'partOf') Then
    list.addAll(self, 'partOf', FPartOfList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'medication[x]') or (child_name = 'medication') Then
     list.add(self.link, 'medication[x]', FMedication.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
  if (child_name = 'supportingInformation') Then
    list.addAll(self, 'supportingInformation', FSupportingInformationList);
  if (child_name = 'performer') Then
    list.addAll(self, 'performer', FPerformerList);
  if (child_name = 'authorizingPrescription') Then
    list.addAll(self, 'authorizingPrescription', FAuthorizingPrescriptionList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'daysSupply') Then
     list.add(self.link, 'daysSupply', FDaysSupply.Link);
  if (child_name = 'whenPrepared') Then
     list.add(self.link, 'whenPrepared', FWhenPrepared.Link);
  if (child_name = 'whenHandedOver') Then
     list.add(self.link, 'whenHandedOver', FWhenHandedOver.Link);
  if (child_name = 'destination') Then
     list.add(self.link, 'destination', FDestination.Link);
  if (child_name = 'receiver') Then
    list.addAll(self, 'receiver', FReceiverList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'dosageInstruction') Then
    list.addAll(self, 'dosageInstruction', FDosageInstructionList);
  if (child_name = 'substitution') Then
     list.add(self.link, 'substitution', FSubstitution.Link);
  if (child_name = 'detectedIssue') Then
    list.addAll(self, 'detectedIssue', FDetectedIssueList);
  if (child_name = 'notDone') Then
     list.add(self.link, 'notDone', FNotDone.Link);
  if (child_name = 'notDoneReason[x]') or (child_name = 'notDoneReason') Then
     list.add(self.link, 'notDoneReason[x]', FNotDoneReason.Link);
  if (child_name = 'eventHistory') Then
    list.addAll(self, 'eventHistory', FEventHistoryList);
end;

procedure TFhirMedicationDispense.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference(Procedure)', true, TFhirReference{TFhirProcedure}, FPartOfList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'medication[x]', 'CodeableConcept|Reference(Medication)', false, TFhirType, FMedication.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Group)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'context', 'Reference(Encounter|EpisodeOfCare)', false, TFhirReference{Resource}, FContext.Link));{2}
  oList.add(TFHIRProperty.create(self, 'supportingInformation', 'Reference(Any)', true, TFhirReference{TFhirReference}, FSupportingInformationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'performer', '', true, TFhirMedicationDispensePerformer, FPerformerList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'authorizingPrescription', 'Reference(MedicationRequest)', true, TFhirReference{TFhirMedicationRequest}, FAuthorizingPrescriptionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'daysSupply', 'Quantity', false, TFhirQuantity, FDaysSupply.Link));{2}
  oList.add(TFHIRProperty.create(self, 'whenPrepared', 'dateTime', false, TFhirDateTime, FWhenPrepared.Link));{2}
  oList.add(TFHIRProperty.create(self, 'whenHandedOver', 'dateTime', false, TFhirDateTime, FWhenHandedOver.Link));{2}
  oList.add(TFHIRProperty.create(self, 'destination', 'Reference(Location)', false, TFhirReference{TFhirLocation}, FDestination.Link));{2}
  oList.add(TFHIRProperty.create(self, 'receiver', 'Reference(Patient|Practitioner)', true, TFhirReference{Resource}, FReceiverList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'dosageInstruction', 'Dosage', true, TFhirDosage, FDosageInstructionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'substitution', '', false, TFhirMedicationDispenseSubstitution, FSubstitution.Link));{2}
  oList.add(TFHIRProperty.create(self, 'detectedIssue', 'Reference(DetectedIssue)', true, TFhirReference{TFhirDetectedIssue}, FDetectedIssueList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'notDone', 'boolean', false, TFhirBoolean, FNotDone.Link));{2}
  oList.add(TFHIRProperty.create(self, 'notDoneReason[x]', 'CodeableConcept|Reference(DetectedIssue)', false, TFhirType, FNotDoneReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'eventHistory', 'Reference(Provenance)', true, TFhirReference{TFhirProvenance}, FEventHistoryList.Link)){3};
end;

function TFhirMedicationDispense.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOfList.add(propValue as TFhirReference{TFhirProcedure}){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirMedicationDispenseStatusEnum, CODES_TFhirMedicationDispenseStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then
  begin
    Medication := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'context') then
  begin
    Context := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'supportingInformation') then
  begin
    SupportingInformationList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    PerformerList.add(propValue as TFhirMedicationDispensePerformer){2a};
    result := propValue;
  end
  else if (propName = 'authorizingPrescription') then
  begin
    AuthorizingPrescriptionList.add(propValue as TFhirReference{TFhirMedicationRequest}){2a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'daysSupply') then
  begin
    DaysSupply := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'whenPrepared') then
  begin
    WhenPreparedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'whenHandedOver') then
  begin
    WhenHandedOverElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'destination') then
  begin
    Destination := propValue as TFhirReference{TFhirLocation}{4b};
    result := propValue;
  end
  else if (propName = 'receiver') then
  begin
    ReceiverList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else if (propName = 'dosageInstruction') then
  begin
    DosageInstructionList.add(propValue as TFhirDosage){2a};
    result := propValue;
  end
  else if (propName = 'substitution') then
  begin
    Substitution := propValue as TFhirMedicationDispenseSubstitution{4b};
    result := propValue;
  end
  else if (propName = 'detectedIssue') then
  begin
    DetectedIssueList.add(propValue as TFhirReference{TFhirDetectedIssue}){2a};
    result := propValue;
  end
  else if (propName = 'notDone') then
  begin
    NotDoneElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'notDoneReason', ['CodeableConcept', 'Reference'])) then
  begin
    NotDoneReason := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'eventHistory') then
  begin
    EventHistoryList.add(propValue as TFhirReference{TFhirProvenance}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirMedicationDispense.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'partOf') then PartOfList.insertItem(index, propValue as TFhirReference{TFhirProcedure}){2a}
  else if (propName = 'supportingInformation') then SupportingInformationList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'performer') then PerformerList.insertItem(index, propValue as TFhirMedicationDispensePerformer){2a}
  else if (propName = 'authorizingPrescription') then AuthorizingPrescriptionList.insertItem(index, propValue as TFhirReference{TFhirMedicationRequest}){2a}
  else if (propName = 'receiver') then ReceiverList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else if (propName = 'dosageInstruction') then DosageInstructionList.insertItem(index, propValue as TFhirDosage){2a}
  else if (propName = 'detectedIssue') then DetectedIssueList.insertItem(index, propValue as TFhirReference{TFhirDetectedIssue}){2a}
  else if (propName = 'eventHistory') then EventHistoryList.insertItem(index, propValue as TFhirReference{TFhirProvenance}){2a}
  else inherited;
end;

function TFhirMedicationDispense.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'partOf') then result := PartOfList.new(){2}
  else if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Medication'){4x}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'context') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'supportingInformation') then result := SupportingInformationList.new(){2}
  else if (propName = 'performer') then result := PerformerList.new(){2}
  else if (propName = 'authorizingPrescription') then result := AuthorizingPrescriptionList.new(){2}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'daysSupply') then result := TFhirQuantity.create(){4b}
  else if (propName = 'whenPrepared') then result := TFhirDateTime.create() {5b}
  else if (propName = 'whenHandedOver') then result := TFhirDateTime.create() {5b}
  else if (propName = 'destination') then result := TFhirReference{TFhirLocation}.create(){4b}
  else if (propName = 'receiver') then result := ReceiverList.new(){2}
  else if (propName = 'note') then result := NoteList.new(){2}
  else if (propName = 'dosageInstruction') then result := DosageInstructionList.new(){2}
  else if (propName = 'substitution') then result := TFhirMedicationDispenseSubstitution.create(){4b}
  else if (propName = 'detectedIssue') then result := DetectedIssueList.new(){2}
  else if (propName = 'notDone') then result := TFhirBoolean.create() {5b}
  else if (isMatchingName(propName, 'notDoneReason', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property NotDoneReason'){4x}
  else if (propName = 'eventHistory') then result := EventHistoryList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationDispense.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'medication[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'context') then result := 'Reference'
  else if (propName = 'supportingInformation') then result := 'Reference'
  else if (propName = 'performer') then result := ''
  else if (propName = 'authorizingPrescription') then result := 'Reference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'daysSupply') then result := 'Quantity'
  else if (propName = 'whenPrepared') then result := 'dateTime'
  else if (propName = 'whenHandedOver') then result := 'dateTime'
  else if (propName = 'destination') then result := 'Reference'
  else if (propName = 'receiver') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'dosageInstruction') then result := 'Dosage'
  else if (propName = 'substitution') then result := ''
  else if (propName = 'detectedIssue') then result := 'Reference'
  else if (propName = 'notDone') then result := 'boolean'
  else if (propName = 'notDoneReason[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'eventHistory') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationDispense.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'partOf') then deletePropertyValue('partOf', PartOfList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then MedicationElement := nil{4x}
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'context') then ContextElement := nil
  else if (propName = 'supportingInformation') then deletePropertyValue('supportingInformation', SupportingInformationList, value) {2}
  else if (propName = 'performer') then deletePropertyValue('performer', PerformerList, value) {2}
  else if (propName = 'authorizingPrescription') then deletePropertyValue('authorizingPrescription', AuthorizingPrescriptionList, value) {2}
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'daysSupply') then DaysSupplyElement := nil
  else if (propName = 'whenPrepared') then WhenPreparedElement := nil
  else if (propName = 'whenHandedOver') then WhenHandedOverElement := nil
  else if (propName = 'destination') then DestinationElement := nil
  else if (propName = 'receiver') then deletePropertyValue('receiver', ReceiverList, value) {2}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else if (propName = 'dosageInstruction') then deletePropertyValue('dosageInstruction', DosageInstructionList, value) {2}
  else if (propName = 'substitution') then SubstitutionElement := nil
  else if (propName = 'detectedIssue') then deletePropertyValue('detectedIssue', DetectedIssueList, value) {2}
  else if (propName = 'notDone') then NotDoneElement := nil
  else if (isMatchingName(propName, 'notDoneReason', ['CodeableConcept', 'Reference'])) then NotDoneReasonElement := nil{4x}
  else if (propName = 'eventHistory') then deletePropertyValue('eventHistory', EventHistoryList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationDispense.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'partOf') then replacePropertyValue('partOf', PartOfList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirMedicationDispenseStatusEnum, CODES_TFhirMedicationDispenseStatusEnum, new){4}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then MedicationElement := new as TFhirType{4x}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'context') then ContextElement := new as TFhirReference{Resource}{4}
  else if (propName = 'supportingInformation') then replacePropertyValue('supportingInformation', SupportingInformationList, existing, new) {2}
  else if (propName = 'performer') then replacePropertyValue('performer', PerformerList, existing, new) {2}
  else if (propName = 'authorizingPrescription') then replacePropertyValue('authorizingPrescription', AuthorizingPrescriptionList, existing, new) {2}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'daysSupply') then DaysSupplyElement := new as TFhirQuantity{4}
  else if (propName = 'whenPrepared') then WhenPreparedElement := asDateTime(new){5b}
  else if (propName = 'whenHandedOver') then WhenHandedOverElement := asDateTime(new){5b}
  else if (propName = 'destination') then DestinationElement := new as TFhirReference{TFhirLocation}{4}
  else if (propName = 'receiver') then replacePropertyValue('receiver', ReceiverList, existing, new) {2}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else if (propName = 'dosageInstruction') then replacePropertyValue('dosageInstruction', DosageInstructionList, existing, new) {2}
  else if (propName = 'substitution') then SubstitutionElement := new as TFhirMedicationDispenseSubstitution{4}
  else if (propName = 'detectedIssue') then replacePropertyValue('detectedIssue', DetectedIssueList, existing, new) {2}
  else if (propName = 'notDone') then NotDoneElement := asBoolean(new){5b}
  else if (isMatchingName(propName, 'notDoneReason', ['CodeableConcept', 'Reference'])) then NotDoneReasonElement := new as TFhirType{4x}
  else if (propName = 'eventHistory') then replacePropertyValue('eventHistory', EventHistoryList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationDispense.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'partOf') then PartOfList.move(source, destination){2a}
  else if (propName = 'supportingInformation') then SupportingInformationList.move(source, destination){2a}
  else if (propName = 'performer') then PerformerList.move(source, destination){2a}
  else if (propName = 'authorizingPrescription') then AuthorizingPrescriptionList.move(source, destination){2a}
  else if (propName = 'receiver') then ReceiverList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else if (propName = 'dosageInstruction') then DosageInstructionList.move(source, destination){2a}
  else if (propName = 'detectedIssue') then DetectedIssueList.move(source, destination){2a}
  else if (propName = 'eventHistory') then EventHistoryList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationDispense.fhirType : string;
begin
  result := 'MedicationDispense';
end;

function TFhirMedicationDispense.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FpartOfList) and isEmptyProp(FStatus) and isEmptyProp(FCategory) and isEmptyProp(FMedication) and isEmptyProp(FSubject) and isEmptyProp(FContext) and isEmptyProp(FsupportingInformationList) and isEmptyProp(FperformerList) and isEmptyProp(FauthorizingPrescriptionList) and isEmptyProp(FType_) and isEmptyProp(FQuantity) and isEmptyProp(FDaysSupply) and isEmptyProp(FWhenPrepared) and isEmptyProp(FWhenHandedOver) and isEmptyProp(FDestination) and isEmptyProp(FreceiverList) and isEmptyProp(FnoteList) and isEmptyProp(FdosageInstructionList) and isEmptyProp(FSubstitution) and isEmptyProp(FdetectedIssueList) and isEmptyProp(FNotDone) and isEmptyProp(FNotDoneReason) and isEmptyProp(FeventHistoryList);
end;

function TFhirMedicationDispense.equals(other : TObject) : boolean;
var
  o : TFhirMedicationDispense;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationDispense)) then
    result := false
  else
  begin
    o := TFhirMedicationDispense(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(partOfList, o.partOfList, true) and
      compareDeep(statusElement, o.statusElement, true) and compareDeep(categoryElement, o.categoryElement, true) and
      compareDeep(medicationElement, o.medicationElement, true) and compareDeep(subjectElement, o.subjectElement, true) and
      compareDeep(contextElement, o.contextElement, true) and compareDeep(supportingInformationList, o.supportingInformationList, true) and
      compareDeep(performerList, o.performerList, true) and compareDeep(authorizingPrescriptionList, o.authorizingPrescriptionList, true) and
      compareDeep(type_Element, o.type_Element, true) and compareDeep(quantityElement, o.quantityElement, true) and
      compareDeep(daysSupplyElement, o.daysSupplyElement, true) and compareDeep(whenPreparedElement, o.whenPreparedElement, true) and
      compareDeep(whenHandedOverElement, o.whenHandedOverElement, true) and compareDeep(destinationElement, o.destinationElement, true) and
      compareDeep(receiverList, o.receiverList, true) and compareDeep(noteList, o.noteList, true) and
      compareDeep(dosageInstructionList, o.dosageInstructionList, true) and compareDeep(substitutionElement, o.substitutionElement, true) and
      compareDeep(detectedIssueList, o.detectedIssueList, true) and compareDeep(notDoneElement, o.notDoneElement, true) and
      compareDeep(notDoneReasonElement, o.notDoneReasonElement, true) and compareDeep(eventHistoryList, o.eventHistoryList, true);
  end;
end;

function TFhirMedicationDispense.Link : TFhirMedicationDispense;
begin
  result := TFhirMedicationDispense(inherited Link);
end;

function TFhirMedicationDispense.Clone : TFhirMedicationDispense;
begin
  result := TFhirMedicationDispense(inherited Clone);
end;

procedure TFhirMedicationDispense.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('partOf');
  fields.add('status');
  fields.add('category');
  fields.add('medication[x]');
  fields.add('subject');
  fields.add('context');
  fields.add('supportingInformation');
  fields.add('performer');
  fields.add('authorizingPrescription');
  fields.add('type');
  fields.add('quantity');
  fields.add('daysSupply');
  fields.add('whenPrepared');
  fields.add('whenHandedOver');
  fields.add('destination');
  fields.add('receiver');
  fields.add('note');
  fields.add('dosageInstruction');
  fields.add('substitution');
  fields.add('detectedIssue');
  fields.add('notDone');
  fields.add('notDoneReason[x]');
  fields.add('eventHistory');
end;

{ TFhirMedicationDispense }

Function TFhirMedicationDispense.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirMedicationDispense.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Function TFhirMedicationDispense.GetPartOfList : TFhirReferenceList{TFhirProcedure};
begin
  if FPartOfList = nil then
    FPartOfList := TFhirReferenceList{TFhirProcedure}.Create;
  result := FPartOfList;
end;

Function TFhirMedicationDispense.GetHasPartOfList : boolean;
begin
  result := (FPartOfList <> nil) and (FPartOfList.count > 0);
end;

Procedure TFhirMedicationDispense.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirMedicationDispense.GetStatusST : TFhirMedicationDispenseStatusEnum;
begin
  if FStatus = nil then
    result := TFhirMedicationDispenseStatusEnum(0)
  else
    result := TFhirMedicationDispenseStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirMedicationDispenseStatusEnum, FStatus.value));
end;

Procedure TFhirMedicationDispense.SetStatusST(value : TFhirMedicationDispenseStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirMedicationDispenseStatusEnum[value], CODES_TFhirMedicationDispenseStatusEnum[value]);
end;

Procedure TFhirMedicationDispense.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirMedicationDispense.SetMedication(value : TFhirType);
begin
  FMedication.free;
  FMedication := value;
end;

Procedure TFhirMedicationDispense.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirMedicationDispense.SetContext(value : TFhirReference{Resource});
begin
  FContext.free;
  FContext := value;
end;

Function TFhirMedicationDispense.GetSupportingInformationList : TFhirReferenceList{TFhirReference};
begin
  if FSupportingInformationList = nil then
    FSupportingInformationList := TFhirReferenceList{TFhirReference}.Create;
  result := FSupportingInformationList;
end;

Function TFhirMedicationDispense.GetHasSupportingInformationList : boolean;
begin
  result := (FSupportingInformationList <> nil) and (FSupportingInformationList.count > 0);
end;

Function TFhirMedicationDispense.GetPerformerList : TFhirMedicationDispensePerformerList;
begin
  if FPerformerList = nil then
    FPerformerList := TFhirMedicationDispensePerformerList.Create;
  result := FPerformerList;
end;

Function TFhirMedicationDispense.GetHasPerformerList : boolean;
begin
  result := (FPerformerList <> nil) and (FPerformerList.count > 0);
end;

Function TFhirMedicationDispense.GetAuthorizingPrescriptionList : TFhirReferenceList{TFhirMedicationRequest};
begin
  if FAuthorizingPrescriptionList = nil then
    FAuthorizingPrescriptionList := TFhirReferenceList{TFhirMedicationRequest}.Create;
  result := FAuthorizingPrescriptionList;
end;

Function TFhirMedicationDispense.GetHasAuthorizingPrescriptionList : boolean;
begin
  result := (FAuthorizingPrescriptionList <> nil) and (FAuthorizingPrescriptionList.count > 0);
end;

Procedure TFhirMedicationDispense.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirMedicationDispense.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirMedicationDispense.SetDaysSupply(value : TFhirQuantity);
begin
  FDaysSupply.free;
  FDaysSupply := value;
end;

Procedure TFhirMedicationDispense.SetWhenPrepared(value : TFhirDateTime);
begin
  FWhenPrepared.free;
  FWhenPrepared := value;
end;

Function TFhirMedicationDispense.GetWhenPreparedST : TFslDateTime;
begin
  if FWhenPrepared = nil then
    result := TFslDateTime.makeNull
  else
    result := FWhenPrepared.value;
end;

Procedure TFhirMedicationDispense.SetWhenPreparedST(value : TFslDateTime);
begin
  if FWhenPrepared = nil then
    FWhenPrepared := TFhirDateTime.create;
  FWhenPrepared.value := value
end;

Procedure TFhirMedicationDispense.SetWhenHandedOver(value : TFhirDateTime);
begin
  FWhenHandedOver.free;
  FWhenHandedOver := value;
end;

Function TFhirMedicationDispense.GetWhenHandedOverST : TFslDateTime;
begin
  if FWhenHandedOver = nil then
    result := TFslDateTime.makeNull
  else
    result := FWhenHandedOver.value;
end;

Procedure TFhirMedicationDispense.SetWhenHandedOverST(value : TFslDateTime);
begin
  if FWhenHandedOver = nil then
    FWhenHandedOver := TFhirDateTime.create;
  FWhenHandedOver.value := value
end;

Procedure TFhirMedicationDispense.SetDestination(value : TFhirReference{TFhirLocation});
begin
  FDestination.free;
  FDestination := value;
end;

Function TFhirMedicationDispense.GetReceiverList : TFhirReferenceList{Resource};
begin
  if FReceiverList = nil then
    FReceiverList := TFhirReferenceList{Resource}.Create;
  result := FReceiverList;
end;

Function TFhirMedicationDispense.GetHasReceiverList : boolean;
begin
  result := (FReceiverList <> nil) and (FReceiverList.count > 0);
end;

Function TFhirMedicationDispense.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirMedicationDispense.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

Function TFhirMedicationDispense.GetDosageInstructionList : TFhirDosageList;
begin
  if FDosageInstructionList = nil then
    FDosageInstructionList := TFhirDosageList.Create;
  result := FDosageInstructionList;
end;

Function TFhirMedicationDispense.GetHasDosageInstructionList : boolean;
begin
  result := (FDosageInstructionList <> nil) and (FDosageInstructionList.count > 0);
end;

Procedure TFhirMedicationDispense.SetSubstitution(value : TFhirMedicationDispenseSubstitution);
begin
  FSubstitution.free;
  FSubstitution := value;
end;

Function TFhirMedicationDispense.GetDetectedIssueList : TFhirReferenceList{TFhirDetectedIssue};
begin
  if FDetectedIssueList = nil then
    FDetectedIssueList := TFhirReferenceList{TFhirDetectedIssue}.Create;
  result := FDetectedIssueList;
end;

Function TFhirMedicationDispense.GetHasDetectedIssueList : boolean;
begin
  result := (FDetectedIssueList <> nil) and (FDetectedIssueList.count > 0);
end;

Procedure TFhirMedicationDispense.SetNotDone(value : TFhirBoolean);
begin
  FNotDone.free;
  FNotDone := value;
end;

Function TFhirMedicationDispense.GetNotDoneST : Boolean;
begin
  if FNotDone = nil then
    result := false
  else
    result := FNotDone.value;
end;

Procedure TFhirMedicationDispense.SetNotDoneST(value : Boolean);
begin
  if FNotDone = nil then
    FNotDone := TFhirBoolean.create;
  FNotDone.value := value
end;

Procedure TFhirMedicationDispense.SetNotDoneReason(value : TFhirType);
begin
  FNotDoneReason.free;
  FNotDoneReason := value;
end;

Function TFhirMedicationDispense.GetEventHistoryList : TFhirReferenceList{TFhirProvenance};
begin
  if FEventHistoryList = nil then
    FEventHistoryList := TFhirReferenceList{TFhirProvenance}.Create;
  result := FEventHistoryList;
end;

Function TFhirMedicationDispense.GetHasEventHistoryList : boolean;
begin
  result := (FEventHistoryList <> nil) and (FEventHistoryList.count > 0);
end;

function TFhirMedicationDispense.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FpartOfList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FMedication.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FContext.sizeInBytes);
  inc(result, FsupportingInformationList.sizeInBytes);
  inc(result, FperformerList.sizeInBytes);
  inc(result, FauthorizingPrescriptionList.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FDaysSupply.sizeInBytes);
  inc(result, FWhenPrepared.sizeInBytes);
  inc(result, FWhenHandedOver.sizeInBytes);
  inc(result, FDestination.sizeInBytes);
  inc(result, FreceiverList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FdosageInstructionList.sizeInBytes);
  inc(result, FSubstitution.sizeInBytes);
  inc(result, FdetectedIssueList.sizeInBytes);
  inc(result, FNotDone.sizeInBytes);
  inc(result, FNotDoneReason.sizeInBytes);
  inc(result, FeventHistoryList.sizeInBytes);
end;

{ TFhirMedicationDispenseListEnumerator }

Constructor TFhirMedicationDispenseListEnumerator.Create(list : TFhirMedicationDispenseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationDispenseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationDispenseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationDispenseListEnumerator.GetCurrent : TFhirMedicationDispense;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationDispenseListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationDispenseList }
procedure TFhirMedicationDispenseList.AddItem(value: TFhirMedicationDispense);
begin
  assert(value.ClassName = 'TFhirMedicationDispense', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationDispense');
  add(value);
end;

function TFhirMedicationDispenseList.Append: TFhirMedicationDispense;
begin
  result := TFhirMedicationDispense.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationDispenseList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationDispenseList.GetEnumerator : TFhirMedicationDispenseListEnumerator;
begin
  result := TFhirMedicationDispenseListEnumerator.Create(self.link);
end;

function TFhirMedicationDispenseList.Clone: TFhirMedicationDispenseList;
begin
  result := TFhirMedicationDispenseList(inherited Clone);
end;

function TFhirMedicationDispenseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationDispenseList.GetItemN(index: Integer): TFhirMedicationDispense;
begin
  result := TFhirMedicationDispense(ObjectByIndex[index]);
end;

function TFhirMedicationDispenseList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationDispense;
end;
function TFhirMedicationDispenseList.IndexOf(value: TFhirMedicationDispense): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationDispenseList.Insert(index: Integer): TFhirMedicationDispense;
begin
  result := TFhirMedicationDispense.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationDispenseList.InsertItem(index: Integer; value: TFhirMedicationDispense);
begin
  assert(value is TFhirMedicationDispense);
  Inherited Insert(index, value);
end;

function TFhirMedicationDispenseList.Item(index: Integer): TFhirMedicationDispense;
begin
  result := TFhirMedicationDispense(ObjectByIndex[index]);
end;

function TFhirMedicationDispenseList.Link: TFhirMedicationDispenseList;
begin
  result := TFhirMedicationDispenseList(inherited Link);
end;

procedure TFhirMedicationDispenseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationDispenseList.SetItemByIndex(index: Integer; value: TFhirMedicationDispense);
begin
  assert(value is TFhirMedicationDispense);
  FhirMedicationDispenses[index] := value;
end;

procedure TFhirMedicationDispenseList.SetItemN(index: Integer; value: TFhirMedicationDispense);
begin
  assert(value is TFhirMedicationDispense);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEDICATIONDISPENSE}

{$IFDEF FHIR_MEDICATIONREQUEST}

{ TFhirMedicationRequestRequester }

constructor TFhirMedicationRequestRequester.Create;
begin
  inherited;
end;

destructor TFhirMedicationRequestRequester.Destroy;
begin
  FAgent.free;
  FOnBehalfOf.free;
  inherited;
end;

procedure TFhirMedicationRequestRequester.Assign(oSource : TFslObject);
begin
  inherited;
  agent := TFhirMedicationRequestRequester(oSource).agent.Clone;
  onBehalfOf := TFhirMedicationRequestRequester(oSource).onBehalfOf.Clone;
end;

procedure TFhirMedicationRequestRequester.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'agent') Then
     list.add(self.link, 'agent', FAgent.Link);
  if (child_name = 'onBehalfOf') Then
     list.add(self.link, 'onBehalfOf', FOnBehalfOf.Link);
end;

procedure TFhirMedicationRequestRequester.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'agent', 'Reference(Practitioner|Organization|Patient|RelatedPerson|Device)', false, TFhirReference{Resource}, FAgent.Link));{2}
  oList.add(TFHIRProperty.create(self, 'onBehalfOf', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FOnBehalfOf.Link));{2}
end;

function TFhirMedicationRequestRequester.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'agent') then
  begin
    Agent := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'onBehalfOf') then
  begin
    OnBehalfOf := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationRequestRequester.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationRequestRequester.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'agent') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'onBehalfOf') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationRequestRequester.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'agent') then result := 'Reference'
  else if (propName = 'onBehalfOf') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationRequestRequester.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'agent') then AgentElement := nil
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationRequestRequester.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'agent') then AgentElement := new as TFhirReference{Resource}{4}
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := new as TFhirReference{TFhirOrganization}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationRequestRequester.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationRequestRequester.fhirType : string;
begin
  result := 'requester';
end;

function TFhirMedicationRequestRequester.Link : TFhirMedicationRequestRequester;
begin
  result := TFhirMedicationRequestRequester(inherited Link);
end;

function TFhirMedicationRequestRequester.Clone : TFhirMedicationRequestRequester;
begin
  result := TFhirMedicationRequestRequester(inherited Clone);
end;

function TFhirMedicationRequestRequester.equals(other : TObject) : boolean;
var
  o : TFhirMedicationRequestRequester;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationRequestRequester)) then
    result := false
  else
  begin
    o := TFhirMedicationRequestRequester(other);
    result := compareDeep(agentElement, o.agentElement, true) and compareDeep(onBehalfOfElement, o.onBehalfOfElement, true);
  end;
end;

function TFhirMedicationRequestRequester.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAgent) and isEmptyProp(FOnBehalfOf);
end;

procedure TFhirMedicationRequestRequester.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('agent');
  fields.add('onBehalfOf');
end;

{ TFhirMedicationRequestRequester }

Procedure TFhirMedicationRequestRequester.SetAgent(value : TFhirReference{Resource});
begin
  FAgent.free;
  FAgent := value;
end;

Procedure TFhirMedicationRequestRequester.SetOnBehalfOf(value : TFhirReference{TFhirOrganization});
begin
  FOnBehalfOf.free;
  FOnBehalfOf := value;
end;

function TFhirMedicationRequestRequester.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FAgent.sizeInBytes);
  inc(result, FOnBehalfOf.sizeInBytes);
end;

{ TFhirMedicationRequestRequesterListEnumerator }

Constructor TFhirMedicationRequestRequesterListEnumerator.Create(list : TFhirMedicationRequestRequesterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationRequestRequesterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationRequestRequesterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationRequestRequesterListEnumerator.GetCurrent : TFhirMedicationRequestRequester;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationRequestRequesterListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationRequestRequesterList }
procedure TFhirMedicationRequestRequesterList.AddItem(value: TFhirMedicationRequestRequester);
begin
  assert(value.ClassName = 'TFhirMedicationRequestRequester', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationRequestRequester');
  add(value);
end;

function TFhirMedicationRequestRequesterList.Append: TFhirMedicationRequestRequester;
begin
  result := TFhirMedicationRequestRequester.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationRequestRequesterList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationRequestRequesterList.GetEnumerator : TFhirMedicationRequestRequesterListEnumerator;
begin
  result := TFhirMedicationRequestRequesterListEnumerator.Create(self.link);
end;

function TFhirMedicationRequestRequesterList.Clone: TFhirMedicationRequestRequesterList;
begin
  result := TFhirMedicationRequestRequesterList(inherited Clone);
end;

function TFhirMedicationRequestRequesterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationRequestRequesterList.GetItemN(index: Integer): TFhirMedicationRequestRequester;
begin
  result := TFhirMedicationRequestRequester(ObjectByIndex[index]);
end;

function TFhirMedicationRequestRequesterList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationRequestRequester;
end;
function TFhirMedicationRequestRequesterList.IndexOf(value: TFhirMedicationRequestRequester): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationRequestRequesterList.Insert(index: Integer): TFhirMedicationRequestRequester;
begin
  result := TFhirMedicationRequestRequester.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationRequestRequesterList.InsertItem(index: Integer; value: TFhirMedicationRequestRequester);
begin
  assert(value is TFhirMedicationRequestRequester);
  Inherited Insert(index, value);
end;

function TFhirMedicationRequestRequesterList.Item(index: Integer): TFhirMedicationRequestRequester;
begin
  result := TFhirMedicationRequestRequester(ObjectByIndex[index]);
end;

function TFhirMedicationRequestRequesterList.Link: TFhirMedicationRequestRequesterList;
begin
  result := TFhirMedicationRequestRequesterList(inherited Link);
end;

procedure TFhirMedicationRequestRequesterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationRequestRequesterList.SetItemByIndex(index: Integer; value: TFhirMedicationRequestRequester);
begin
  assert(value is TFhirMedicationRequestRequester);
  FhirMedicationRequestRequesters[index] := value;
end;

procedure TFhirMedicationRequestRequesterList.SetItemN(index: Integer; value: TFhirMedicationRequestRequester);
begin
  assert(value is TFhirMedicationRequestRequester);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationRequestDispenseRequest }

constructor TFhirMedicationRequestDispenseRequest.Create;
begin
  inherited;
end;

destructor TFhirMedicationRequestDispenseRequest.Destroy;
begin
  FValidityPeriod.free;
  FNumberOfRepeatsAllowed.free;
  FQuantity.free;
  FExpectedSupplyDuration.free;
  FPerformer.free;
  inherited;
end;

procedure TFhirMedicationRequestDispenseRequest.Assign(oSource : TFslObject);
begin
  inherited;
  validityPeriod := TFhirMedicationRequestDispenseRequest(oSource).validityPeriod.Clone;
  numberOfRepeatsAllowedElement := TFhirMedicationRequestDispenseRequest(oSource).numberOfRepeatsAllowedElement.Clone;
  quantity := TFhirMedicationRequestDispenseRequest(oSource).quantity.Clone;
  expectedSupplyDuration := TFhirMedicationRequestDispenseRequest(oSource).expectedSupplyDuration.Clone;
  performer := TFhirMedicationRequestDispenseRequest(oSource).performer.Clone;
end;

procedure TFhirMedicationRequestDispenseRequest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'validityPeriod') Then
     list.add(self.link, 'validityPeriod', FValidityPeriod.Link);
  if (child_name = 'numberOfRepeatsAllowed') Then
     list.add(self.link, 'numberOfRepeatsAllowed', FNumberOfRepeatsAllowed.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'expectedSupplyDuration') Then
     list.add(self.link, 'expectedSupplyDuration', FExpectedSupplyDuration.Link);
  if (child_name = 'performer') Then
     list.add(self.link, 'performer', FPerformer.Link);
end;

procedure TFhirMedicationRequestDispenseRequest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'validityPeriod', 'Period', false, TFhirPeriod, FValidityPeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'numberOfRepeatsAllowed', 'positiveInt', false, TFhirPositiveInt, FNumberOfRepeatsAllowed.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'expectedSupplyDuration', 'Duration', false, TFhirDuration, FExpectedSupplyDuration.Link));{2}
  oList.add(TFHIRProperty.create(self, 'performer', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FPerformer.Link));{2}
end;

function TFhirMedicationRequestDispenseRequest.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'validityPeriod') then
  begin
    ValidityPeriod := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'numberOfRepeatsAllowed') then
  begin
    NumberOfRepeatsAllowedElement := asPositiveInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'expectedSupplyDuration') then
  begin
    ExpectedSupplyDuration := propValue as TFhirDuration{4b};
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    Performer := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationRequestDispenseRequest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationRequestDispenseRequest.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'validityPeriod') then result := TFhirPeriod.create(){4b}
  else if (propName = 'numberOfRepeatsAllowed') then result := TFhirPositiveInt.create() {5b}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'expectedSupplyDuration') then result := TFhirDuration.create(){4b}
  else if (propName = 'performer') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationRequestDispenseRequest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'validityPeriod') then result := 'Period'
  else if (propName = 'numberOfRepeatsAllowed') then result := 'positiveInt'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'expectedSupplyDuration') then result := 'Duration'
  else if (propName = 'performer') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationRequestDispenseRequest.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'validityPeriod') then ValidityPeriodElement := nil
  else if (propName = 'numberOfRepeatsAllowed') then NumberOfRepeatsAllowedElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'expectedSupplyDuration') then ExpectedSupplyDurationElement := nil
  else if (propName = 'performer') then PerformerElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationRequestDispenseRequest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'validityPeriod') then ValidityPeriodElement := new as TFhirPeriod{4}
  else if (propName = 'numberOfRepeatsAllowed') then NumberOfRepeatsAllowedElement := asPositiveInt(new){5b}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'expectedSupplyDuration') then ExpectedSupplyDurationElement := new as TFhirDuration{4}
  else if (propName = 'performer') then PerformerElement := new as TFhirReference{TFhirOrganization}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationRequestDispenseRequest.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationRequestDispenseRequest.fhirType : string;
begin
  result := 'dispenseRequest';
end;

function TFhirMedicationRequestDispenseRequest.Link : TFhirMedicationRequestDispenseRequest;
begin
  result := TFhirMedicationRequestDispenseRequest(inherited Link);
end;

function TFhirMedicationRequestDispenseRequest.Clone : TFhirMedicationRequestDispenseRequest;
begin
  result := TFhirMedicationRequestDispenseRequest(inherited Clone);
end;

function TFhirMedicationRequestDispenseRequest.equals(other : TObject) : boolean;
var
  o : TFhirMedicationRequestDispenseRequest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationRequestDispenseRequest)) then
    result := false
  else
  begin
    o := TFhirMedicationRequestDispenseRequest(other);
    result := compareDeep(validityPeriodElement, o.validityPeriodElement, true) and
      compareDeep(numberOfRepeatsAllowedElement, o.numberOfRepeatsAllowedElement, true) and
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(expectedSupplyDurationElement, o.expectedSupplyDurationElement, true) and
      compareDeep(performerElement, o.performerElement, true);
  end;
end;

function TFhirMedicationRequestDispenseRequest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FValidityPeriod) and isEmptyProp(FNumberOfRepeatsAllowed) and isEmptyProp(FQuantity) and isEmptyProp(FExpectedSupplyDuration) and isEmptyProp(FPerformer);
end;

procedure TFhirMedicationRequestDispenseRequest.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('validityPeriod');
  fields.add('numberOfRepeatsAllowed');
  fields.add('quantity');
  fields.add('expectedSupplyDuration');
  fields.add('performer');
end;

{ TFhirMedicationRequestDispenseRequest }

Procedure TFhirMedicationRequestDispenseRequest.SetValidityPeriod(value : TFhirPeriod);
begin
  FValidityPeriod.free;
  FValidityPeriod := value;
end;

Procedure TFhirMedicationRequestDispenseRequest.SetNumberOfRepeatsAllowed(value : TFhirPositiveInt);
begin
  FNumberOfRepeatsAllowed.free;
  FNumberOfRepeatsAllowed := value;
end;

Function TFhirMedicationRequestDispenseRequest.GetNumberOfRepeatsAllowedST : String;
begin
  if FNumberOfRepeatsAllowed = nil then
    result := ''
  else
    result := FNumberOfRepeatsAllowed.value;
end;

Procedure TFhirMedicationRequestDispenseRequest.SetNumberOfRepeatsAllowedST(value : String);
begin
  if value <> '' then
  begin
    if FNumberOfRepeatsAllowed = nil then
      FNumberOfRepeatsAllowed := TFhirPositiveInt.create;
    FNumberOfRepeatsAllowed.value := value
  end
  else if FNumberOfRepeatsAllowed <> nil then
    FNumberOfRepeatsAllowed.value := '';
end;

Procedure TFhirMedicationRequestDispenseRequest.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirMedicationRequestDispenseRequest.SetExpectedSupplyDuration(value : TFhirDuration);
begin
  FExpectedSupplyDuration.free;
  FExpectedSupplyDuration := value;
end;

Procedure TFhirMedicationRequestDispenseRequest.SetPerformer(value : TFhirReference{TFhirOrganization});
begin
  FPerformer.free;
  FPerformer := value;
end;

function TFhirMedicationRequestDispenseRequest.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FValidityPeriod.sizeInBytes);
  inc(result, FNumberOfRepeatsAllowed.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FExpectedSupplyDuration.sizeInBytes);
  inc(result, FPerformer.sizeInBytes);
end;

{ TFhirMedicationRequestDispenseRequestListEnumerator }

Constructor TFhirMedicationRequestDispenseRequestListEnumerator.Create(list : TFhirMedicationRequestDispenseRequestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationRequestDispenseRequestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationRequestDispenseRequestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationRequestDispenseRequestListEnumerator.GetCurrent : TFhirMedicationRequestDispenseRequest;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationRequestDispenseRequestListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationRequestDispenseRequestList }
procedure TFhirMedicationRequestDispenseRequestList.AddItem(value: TFhirMedicationRequestDispenseRequest);
begin
  assert(value.ClassName = 'TFhirMedicationRequestDispenseRequest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationRequestDispenseRequest');
  add(value);
end;

function TFhirMedicationRequestDispenseRequestList.Append: TFhirMedicationRequestDispenseRequest;
begin
  result := TFhirMedicationRequestDispenseRequest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationRequestDispenseRequestList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationRequestDispenseRequestList.GetEnumerator : TFhirMedicationRequestDispenseRequestListEnumerator;
begin
  result := TFhirMedicationRequestDispenseRequestListEnumerator.Create(self.link);
end;

function TFhirMedicationRequestDispenseRequestList.Clone: TFhirMedicationRequestDispenseRequestList;
begin
  result := TFhirMedicationRequestDispenseRequestList(inherited Clone);
end;

function TFhirMedicationRequestDispenseRequestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationRequestDispenseRequestList.GetItemN(index: Integer): TFhirMedicationRequestDispenseRequest;
begin
  result := TFhirMedicationRequestDispenseRequest(ObjectByIndex[index]);
end;

function TFhirMedicationRequestDispenseRequestList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationRequestDispenseRequest;
end;
function TFhirMedicationRequestDispenseRequestList.IndexOf(value: TFhirMedicationRequestDispenseRequest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationRequestDispenseRequestList.Insert(index: Integer): TFhirMedicationRequestDispenseRequest;
begin
  result := TFhirMedicationRequestDispenseRequest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationRequestDispenseRequestList.InsertItem(index: Integer; value: TFhirMedicationRequestDispenseRequest);
begin
  assert(value is TFhirMedicationRequestDispenseRequest);
  Inherited Insert(index, value);
end;

function TFhirMedicationRequestDispenseRequestList.Item(index: Integer): TFhirMedicationRequestDispenseRequest;
begin
  result := TFhirMedicationRequestDispenseRequest(ObjectByIndex[index]);
end;

function TFhirMedicationRequestDispenseRequestList.Link: TFhirMedicationRequestDispenseRequestList;
begin
  result := TFhirMedicationRequestDispenseRequestList(inherited Link);
end;

procedure TFhirMedicationRequestDispenseRequestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationRequestDispenseRequestList.SetItemByIndex(index: Integer; value: TFhirMedicationRequestDispenseRequest);
begin
  assert(value is TFhirMedicationRequestDispenseRequest);
  FhirMedicationRequestDispenseRequests[index] := value;
end;

procedure TFhirMedicationRequestDispenseRequestList.SetItemN(index: Integer; value: TFhirMedicationRequestDispenseRequest);
begin
  assert(value is TFhirMedicationRequestDispenseRequest);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationRequestSubstitution }

constructor TFhirMedicationRequestSubstitution.Create;
begin
  inherited;
end;

destructor TFhirMedicationRequestSubstitution.Destroy;
begin
  FAllowed.free;
  FReason.free;
  inherited;
end;

procedure TFhirMedicationRequestSubstitution.Assign(oSource : TFslObject);
begin
  inherited;
  allowedElement := TFhirMedicationRequestSubstitution(oSource).allowedElement.Clone;
  reason := TFhirMedicationRequestSubstitution(oSource).reason.Clone;
end;

procedure TFhirMedicationRequestSubstitution.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'allowed') Then
     list.add(self.link, 'allowed', FAllowed.Link);
  if (child_name = 'reason') Then
     list.add(self.link, 'reason', FReason.Link);
end;

procedure TFhirMedicationRequestSubstitution.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'allowed', 'boolean', false, TFhirBoolean, FAllowed.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', false, TFhirCodeableConcept, FReason.Link));{2}
end;

function TFhirMedicationRequestSubstitution.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'allowed') then
  begin
    AllowedElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    Reason := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationRequestSubstitution.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationRequestSubstitution.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'allowed') then result := TFhirBoolean.create() {5b}
  else if (propName = 'reason') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationRequestSubstitution.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'allowed') then result := 'boolean'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationRequestSubstitution.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'allowed') then AllowedElement := nil
  else if (propName = 'reason') then ReasonElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationRequestSubstitution.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'allowed') then AllowedElement := asBoolean(new){5b}
  else if (propName = 'reason') then ReasonElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationRequestSubstitution.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationRequestSubstitution.fhirType : string;
begin
  result := 'substitution';
end;

function TFhirMedicationRequestSubstitution.Link : TFhirMedicationRequestSubstitution;
begin
  result := TFhirMedicationRequestSubstitution(inherited Link);
end;

function TFhirMedicationRequestSubstitution.Clone : TFhirMedicationRequestSubstitution;
begin
  result := TFhirMedicationRequestSubstitution(inherited Clone);
end;

function TFhirMedicationRequestSubstitution.equals(other : TObject) : boolean;
var
  o : TFhirMedicationRequestSubstitution;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationRequestSubstitution)) then
    result := false
  else
  begin
    o := TFhirMedicationRequestSubstitution(other);
    result := compareDeep(allowedElement, o.allowedElement, true) and compareDeep(reasonElement, o.reasonElement, true);
  end;
end;

function TFhirMedicationRequestSubstitution.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAllowed) and isEmptyProp(FReason);
end;

procedure TFhirMedicationRequestSubstitution.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('allowed');
  fields.add('reason');
end;

{ TFhirMedicationRequestSubstitution }

Procedure TFhirMedicationRequestSubstitution.SetAllowed(value : TFhirBoolean);
begin
  FAllowed.free;
  FAllowed := value;
end;

Function TFhirMedicationRequestSubstitution.GetAllowedST : Boolean;
begin
  if FAllowed = nil then
    result := false
  else
    result := FAllowed.value;
end;

Procedure TFhirMedicationRequestSubstitution.SetAllowedST(value : Boolean);
begin
  if FAllowed = nil then
    FAllowed := TFhirBoolean.create;
  FAllowed.value := value
end;

Procedure TFhirMedicationRequestSubstitution.SetReason(value : TFhirCodeableConcept);
begin
  FReason.free;
  FReason := value;
end;

function TFhirMedicationRequestSubstitution.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FAllowed.sizeInBytes);
  inc(result, FReason.sizeInBytes);
end;

{ TFhirMedicationRequestSubstitutionListEnumerator }

Constructor TFhirMedicationRequestSubstitutionListEnumerator.Create(list : TFhirMedicationRequestSubstitutionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationRequestSubstitutionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationRequestSubstitutionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationRequestSubstitutionListEnumerator.GetCurrent : TFhirMedicationRequestSubstitution;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationRequestSubstitutionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationRequestSubstitutionList }
procedure TFhirMedicationRequestSubstitutionList.AddItem(value: TFhirMedicationRequestSubstitution);
begin
  assert(value.ClassName = 'TFhirMedicationRequestSubstitution', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationRequestSubstitution');
  add(value);
end;

function TFhirMedicationRequestSubstitutionList.Append: TFhirMedicationRequestSubstitution;
begin
  result := TFhirMedicationRequestSubstitution.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationRequestSubstitutionList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationRequestSubstitutionList.GetEnumerator : TFhirMedicationRequestSubstitutionListEnumerator;
begin
  result := TFhirMedicationRequestSubstitutionListEnumerator.Create(self.link);
end;

function TFhirMedicationRequestSubstitutionList.Clone: TFhirMedicationRequestSubstitutionList;
begin
  result := TFhirMedicationRequestSubstitutionList(inherited Clone);
end;

function TFhirMedicationRequestSubstitutionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationRequestSubstitutionList.GetItemN(index: Integer): TFhirMedicationRequestSubstitution;
begin
  result := TFhirMedicationRequestSubstitution(ObjectByIndex[index]);
end;

function TFhirMedicationRequestSubstitutionList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationRequestSubstitution;
end;
function TFhirMedicationRequestSubstitutionList.IndexOf(value: TFhirMedicationRequestSubstitution): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationRequestSubstitutionList.Insert(index: Integer): TFhirMedicationRequestSubstitution;
begin
  result := TFhirMedicationRequestSubstitution.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationRequestSubstitutionList.InsertItem(index: Integer; value: TFhirMedicationRequestSubstitution);
begin
  assert(value is TFhirMedicationRequestSubstitution);
  Inherited Insert(index, value);
end;

function TFhirMedicationRequestSubstitutionList.Item(index: Integer): TFhirMedicationRequestSubstitution;
begin
  result := TFhirMedicationRequestSubstitution(ObjectByIndex[index]);
end;

function TFhirMedicationRequestSubstitutionList.Link: TFhirMedicationRequestSubstitutionList;
begin
  result := TFhirMedicationRequestSubstitutionList(inherited Link);
end;

procedure TFhirMedicationRequestSubstitutionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationRequestSubstitutionList.SetItemByIndex(index: Integer; value: TFhirMedicationRequestSubstitution);
begin
  assert(value is TFhirMedicationRequestSubstitution);
  FhirMedicationRequestSubstitutions[index] := value;
end;

procedure TFhirMedicationRequestSubstitutionList.SetItemN(index: Integer; value: TFhirMedicationRequestSubstitution);
begin
  assert(value is TFhirMedicationRequestSubstitution);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationRequest }

constructor TFhirMedicationRequest.Create;
begin
  inherited;
end;

destructor TFhirMedicationRequest.Destroy;
begin
  FIdentifierList.Free;
  FDefinitionList.Free;
  FBasedOnList.Free;
  FGroupIdentifier.free;
  FStatus.free;
  FIntent.free;
  FCategory.free;
  FPriority.free;
  FMedication.free;
  FSubject.free;
  FContext.free;
  FSupportingInformationList.Free;
  FAuthoredOn.free;
  FRequester.free;
  FRecorder.free;
  FReasonCodeList.Free;
  FReasonReferenceList.Free;
  FNoteList.Free;
  FDosageInstructionList.Free;
  FDispenseRequest.free;
  FSubstitution.free;
  FPriorPrescription.free;
  FDetectedIssueList.Free;
  FEventHistoryList.Free;
  inherited;
end;

function TFhirMedicationRequest.GetResourceType : TFhirResourceType;
begin
  result := frtMedicationRequest;
end;

procedure TFhirMedicationRequest.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedicationRequest(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirMedicationRequest(oSource).FIdentifierList);
  end;
  if (TFhirMedicationRequest(oSource).FDefinitionList = nil) then
  begin
    FDefinitionList.free;
    FDefinitionList := nil;
  end
  else
  begin
    if FDefinitionList = nil then
      FDefinitionList := TFhirReferenceList{Resource}.Create;
    FDefinitionList.Assign(TFhirMedicationRequest(oSource).FDefinitionList);
  end;
  if (TFhirMedicationRequest(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList{Resource}.Create;
    FBasedOnList.Assign(TFhirMedicationRequest(oSource).FBasedOnList);
  end;
  groupIdentifier := TFhirMedicationRequest(oSource).groupIdentifier.Clone;
  FStatus := TFhirMedicationRequest(oSource).FStatus.Link;
  FIntent := TFhirMedicationRequest(oSource).FIntent.Link;
  category := TFhirMedicationRequest(oSource).category.Clone;
  FPriority := TFhirMedicationRequest(oSource).FPriority.Link;
  medication := TFhirMedicationRequest(oSource).medication.Clone;
  subject := TFhirMedicationRequest(oSource).subject.Clone;
  context := TFhirMedicationRequest(oSource).context.Clone;
  if (TFhirMedicationRequest(oSource).FSupportingInformationList = nil) then
  begin
    FSupportingInformationList.free;
    FSupportingInformationList := nil;
  end
  else
  begin
    if FSupportingInformationList = nil then
      FSupportingInformationList := TFhirReferenceList{TFhirReference}.Create;
    FSupportingInformationList.Assign(TFhirMedicationRequest(oSource).FSupportingInformationList);
  end;
  authoredOnElement := TFhirMedicationRequest(oSource).authoredOnElement.Clone;
  requester := TFhirMedicationRequest(oSource).requester.Clone;
  recorder := TFhirMedicationRequest(oSource).recorder.Clone;
  if (TFhirMedicationRequest(oSource).FReasonCodeList = nil) then
  begin
    FReasonCodeList.free;
    FReasonCodeList := nil;
  end
  else
  begin
    if FReasonCodeList = nil then
      FReasonCodeList := TFhirCodeableConceptList.Create;
    FReasonCodeList.Assign(TFhirMedicationRequest(oSource).FReasonCodeList);
  end;
  if (TFhirMedicationRequest(oSource).FReasonReferenceList = nil) then
  begin
    FReasonReferenceList.free;
    FReasonReferenceList := nil;
  end
  else
  begin
    if FReasonReferenceList = nil then
      FReasonReferenceList := TFhirReferenceList{Resource}.Create;
    FReasonReferenceList.Assign(TFhirMedicationRequest(oSource).FReasonReferenceList);
  end;
  if (TFhirMedicationRequest(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirMedicationRequest(oSource).FNoteList);
  end;
  if (TFhirMedicationRequest(oSource).FDosageInstructionList = nil) then
  begin
    FDosageInstructionList.free;
    FDosageInstructionList := nil;
  end
  else
  begin
    if FDosageInstructionList = nil then
      FDosageInstructionList := TFhirDosageList.Create;
    FDosageInstructionList.Assign(TFhirMedicationRequest(oSource).FDosageInstructionList);
  end;
  dispenseRequest := TFhirMedicationRequest(oSource).dispenseRequest.Clone;
  substitution := TFhirMedicationRequest(oSource).substitution.Clone;
  priorPrescription := TFhirMedicationRequest(oSource).priorPrescription.Clone;
  if (TFhirMedicationRequest(oSource).FDetectedIssueList = nil) then
  begin
    FDetectedIssueList.free;
    FDetectedIssueList := nil;
  end
  else
  begin
    if FDetectedIssueList = nil then
      FDetectedIssueList := TFhirReferenceList{TFhirDetectedIssue}.Create;
    FDetectedIssueList.Assign(TFhirMedicationRequest(oSource).FDetectedIssueList);
  end;
  if (TFhirMedicationRequest(oSource).FEventHistoryList = nil) then
  begin
    FEventHistoryList.free;
    FEventHistoryList := nil;
  end
  else
  begin
    if FEventHistoryList = nil then
      FEventHistoryList := TFhirReferenceList{TFhirProvenance}.Create;
    FEventHistoryList.Assign(TFhirMedicationRequest(oSource).FEventHistoryList);
  end;
end;

procedure TFhirMedicationRequest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'definition') Then
    list.addAll(self, 'definition', FDefinitionList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'groupIdentifier') Then
     list.add(self.link, 'groupIdentifier', FGroupIdentifier.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'intent') Then
     list.add(self.link, 'intent', FIntent.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'medication[x]') or (child_name = 'medication') Then
     list.add(self.link, 'medication[x]', FMedication.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
  if (child_name = 'supportingInformation') Then
    list.addAll(self, 'supportingInformation', FSupportingInformationList);
  if (child_name = 'authoredOn') Then
     list.add(self.link, 'authoredOn', FAuthoredOn.Link);
  if (child_name = 'requester') Then
     list.add(self.link, 'requester', FRequester.Link);
  if (child_name = 'recorder') Then
     list.add(self.link, 'recorder', FRecorder.Link);
  if (child_name = 'reasonCode') Then
    list.addAll(self, 'reasonCode', FReasonCodeList);
  if (child_name = 'reasonReference') Then
    list.addAll(self, 'reasonReference', FReasonReferenceList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'dosageInstruction') Then
    list.addAll(self, 'dosageInstruction', FDosageInstructionList);
  if (child_name = 'dispenseRequest') Then
     list.add(self.link, 'dispenseRequest', FDispenseRequest.Link);
  if (child_name = 'substitution') Then
     list.add(self.link, 'substitution', FSubstitution.Link);
  if (child_name = 'priorPrescription') Then
     list.add(self.link, 'priorPrescription', FPriorPrescription.Link);
  if (child_name = 'detectedIssue') Then
    list.addAll(self, 'detectedIssue', FDetectedIssueList);
  if (child_name = 'eventHistory') Then
    list.addAll(self, 'eventHistory', FEventHistoryList);
end;

procedure TFhirMedicationRequest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'definition', 'Reference(ActivityDefinition|PlanDefinition)', true, TFhirReference{Resource}, FDefinitionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference(CarePlan|MedicationRequest|ProcedureRequest|ReferralRequest)', true, TFhirReference{Resource}, FBasedOnList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'groupIdentifier', 'Identifier', false, TFhirIdentifier, FGroupIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'intent', 'code', false, TFHIREnum, FIntent.Link));{1}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'priority', 'code', false, TFHIREnum, FPriority.Link));{1}
  oList.add(TFHIRProperty.create(self, 'medication[x]', 'CodeableConcept|Reference(Medication)', false, TFhirType, FMedication.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Group)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'context', 'Reference(Encounter|EpisodeOfCare)', false, TFhirReference{Resource}, FContext.Link));{2}
  oList.add(TFHIRProperty.create(self, 'supportingInformation', 'Reference(Any)', true, TFhirReference{TFhirReference}, FSupportingInformationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'authoredOn', 'dateTime', false, TFhirDateTime, FAuthoredOn.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requester', '', false, TFhirMedicationRequestRequester, FRequester.Link));{2}
  oList.add(TFHIRProperty.create(self, 'recorder', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FRecorder.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reasonCode', 'CodeableConcept', true, TFhirCodeableConcept, FReasonCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reasonReference', 'Reference(Condition|Observation)', true, TFhirReference{Resource}, FReasonReferenceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'dosageInstruction', 'Dosage', true, TFhirDosage, FDosageInstructionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'dispenseRequest', '', false, TFhirMedicationRequestDispenseRequest, FDispenseRequest.Link));{2}
  oList.add(TFHIRProperty.create(self, 'substitution', '', false, TFhirMedicationRequestSubstitution, FSubstitution.Link));{2}
  oList.add(TFHIRProperty.create(self, 'priorPrescription', 'Reference(MedicationRequest)', false, TFhirReference{TFhirMedicationRequest}, FPriorPrescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'detectedIssue', 'Reference(DetectedIssue)', true, TFhirReference{TFhirDetectedIssue}, FDetectedIssueList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'eventHistory', 'Reference(Provenance)', true, TFhirReference{TFhirProvenance}, FEventHistoryList.Link)){3};
end;

function TFhirMedicationRequest.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'definition') then
  begin
    DefinitionList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'groupIdentifier') then
  begin
    GroupIdentifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirMedicationRequestStatusEnum, CODES_TFhirMedicationRequestStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'intent') then
  begin
    IntentElement := asEnum(SYSTEMS_TFhirMedicationRequestIntentEnum, CODES_TFhirMedicationRequestIntentEnum, propValue);
    result := propValue
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asEnum(SYSTEMS_TFhirMedicationRequestPriorityEnum, CODES_TFhirMedicationRequestPriorityEnum, propValue);
    result := propValue
  end
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then
  begin
    Medication := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'context') then
  begin
    Context := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'supportingInformation') then
  begin
    SupportingInformationList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'authoredOn') then
  begin
    AuthoredOnElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'requester') then
  begin
    Requester := propValue as TFhirMedicationRequestRequester{4b};
    result := propValue;
  end
  else if (propName = 'recorder') then
  begin
    Recorder := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'reasonCode') then
  begin
    ReasonCodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'reasonReference') then
  begin
    ReasonReferenceList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else if (propName = 'dosageInstruction') then
  begin
    DosageInstructionList.add(propValue as TFhirDosage){2a};
    result := propValue;
  end
  else if (propName = 'dispenseRequest') then
  begin
    DispenseRequest := propValue as TFhirMedicationRequestDispenseRequest{4b};
    result := propValue;
  end
  else if (propName = 'substitution') then
  begin
    Substitution := propValue as TFhirMedicationRequestSubstitution{4b};
    result := propValue;
  end
  else if (propName = 'priorPrescription') then
  begin
    PriorPrescription := propValue as TFhirReference{TFhirMedicationRequest}{4b};
    result := propValue;
  end
  else if (propName = 'detectedIssue') then
  begin
    DetectedIssueList.add(propValue as TFhirReference{TFhirDetectedIssue}){2a};
    result := propValue;
  end
  else if (propName = 'eventHistory') then
  begin
    EventHistoryList.add(propValue as TFhirReference{TFhirProvenance}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirMedicationRequest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'definition') then DefinitionList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'supportingInformation') then SupportingInformationList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'reasonCode') then ReasonCodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'reasonReference') then ReasonReferenceList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else if (propName = 'dosageInstruction') then DosageInstructionList.insertItem(index, propValue as TFhirDosage){2a}
  else if (propName = 'detectedIssue') then DetectedIssueList.insertItem(index, propValue as TFhirReference{TFhirDetectedIssue}){2a}
  else if (propName = 'eventHistory') then EventHistoryList.insertItem(index, propValue as TFhirReference{TFhirProvenance}){2a}
  else inherited;
end;

function TFhirMedicationRequest.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'definition') then result := DefinitionList.new(){2}
  else if (propName = 'basedOn') then result := BasedOnList.new(){2}
  else if (propName = 'groupIdentifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Medication'){4x}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'context') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'supportingInformation') then result := SupportingInformationList.new(){2}
  else if (propName = 'authoredOn') then result := TFhirDateTime.create() {5b}
  else if (propName = 'requester') then result := TFhirMedicationRequestRequester.create(){4b}
  else if (propName = 'recorder') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'reasonCode') then result := ReasonCodeList.new(){2}
  else if (propName = 'reasonReference') then result := ReasonReferenceList.new(){2}
  else if (propName = 'note') then result := NoteList.new(){2}
  else if (propName = 'dosageInstruction') then result := DosageInstructionList.new(){2}
  else if (propName = 'dispenseRequest') then result := TFhirMedicationRequestDispenseRequest.create(){4b}
  else if (propName = 'substitution') then result := TFhirMedicationRequestSubstitution.create(){4b}
  else if (propName = 'priorPrescription') then result := TFhirReference{TFhirMedicationRequest}.create(){4b}
  else if (propName = 'detectedIssue') then result := DetectedIssueList.new(){2}
  else if (propName = 'eventHistory') then result := EventHistoryList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationRequest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'definition') then result := 'Reference'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'groupIdentifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'intent') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'priority') then result := 'code'
  else if (propName = 'medication[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'context') then result := 'Reference'
  else if (propName = 'supportingInformation') then result := 'Reference'
  else if (propName = 'authoredOn') then result := 'dateTime'
  else if (propName = 'requester') then result := ''
  else if (propName = 'recorder') then result := 'Reference'
  else if (propName = 'reasonCode') then result := 'CodeableConcept'
  else if (propName = 'reasonReference') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'dosageInstruction') then result := 'Dosage'
  else if (propName = 'dispenseRequest') then result := ''
  else if (propName = 'substitution') then result := ''
  else if (propName = 'priorPrescription') then result := 'Reference'
  else if (propName = 'detectedIssue') then result := 'Reference'
  else if (propName = 'eventHistory') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationRequest.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'definition') then deletePropertyValue('definition', DefinitionList, value) {2}
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value) {2}
  else if (propName = 'groupIdentifier') then GroupIdentifierElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'intent') then IntentElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then MedicationElement := nil{4x}
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'context') then ContextElement := nil
  else if (propName = 'supportingInformation') then deletePropertyValue('supportingInformation', SupportingInformationList, value) {2}
  else if (propName = 'authoredOn') then AuthoredOnElement := nil
  else if (propName = 'requester') then RequesterElement := nil
  else if (propName = 'recorder') then RecorderElement := nil
  else if (propName = 'reasonCode') then deletePropertyValue('reasonCode', ReasonCodeList, value) {2}
  else if (propName = 'reasonReference') then deletePropertyValue('reasonReference', ReasonReferenceList, value) {2}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else if (propName = 'dosageInstruction') then deletePropertyValue('dosageInstruction', DosageInstructionList, value) {2}
  else if (propName = 'dispenseRequest') then DispenseRequestElement := nil
  else if (propName = 'substitution') then SubstitutionElement := nil
  else if (propName = 'priorPrescription') then PriorPrescriptionElement := nil
  else if (propName = 'detectedIssue') then deletePropertyValue('detectedIssue', DetectedIssueList, value) {2}
  else if (propName = 'eventHistory') then deletePropertyValue('eventHistory', EventHistoryList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationRequest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'definition') then replacePropertyValue('definition', DefinitionList, existing, new) {2}
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new) {2}
  else if (propName = 'groupIdentifier') then GroupIdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirMedicationRequestStatusEnum, CODES_TFhirMedicationRequestStatusEnum, new){4}
  else if (propName = 'intent') then IntentElement := asEnum(SYSTEMS_TFhirMedicationRequestIntentEnum, CODES_TFhirMedicationRequestIntentEnum, new){4}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'priority') then PriorityElement := asEnum(SYSTEMS_TFhirMedicationRequestPriorityEnum, CODES_TFhirMedicationRequestPriorityEnum, new){4}
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then MedicationElement := new as TFhirType{4x}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'context') then ContextElement := new as TFhirReference{Resource}{4}
  else if (propName = 'supportingInformation') then replacePropertyValue('supportingInformation', SupportingInformationList, existing, new) {2}
  else if (propName = 'authoredOn') then AuthoredOnElement := asDateTime(new){5b}
  else if (propName = 'requester') then RequesterElement := new as TFhirMedicationRequestRequester{4}
  else if (propName = 'recorder') then RecorderElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'reasonCode') then replacePropertyValue('reasonCode', ReasonCodeList, existing, new) {2}
  else if (propName = 'reasonReference') then replacePropertyValue('reasonReference', ReasonReferenceList, existing, new) {2}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else if (propName = 'dosageInstruction') then replacePropertyValue('dosageInstruction', DosageInstructionList, existing, new) {2}
  else if (propName = 'dispenseRequest') then DispenseRequestElement := new as TFhirMedicationRequestDispenseRequest{4}
  else if (propName = 'substitution') then SubstitutionElement := new as TFhirMedicationRequestSubstitution{4}
  else if (propName = 'priorPrescription') then PriorPrescriptionElement := new as TFhirReference{TFhirMedicationRequest}{4}
  else if (propName = 'detectedIssue') then replacePropertyValue('detectedIssue', DetectedIssueList, existing, new) {2}
  else if (propName = 'eventHistory') then replacePropertyValue('eventHistory', EventHistoryList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationRequest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'definition') then DefinitionList.move(source, destination){2a}
  else if (propName = 'basedOn') then BasedOnList.move(source, destination){2a}
  else if (propName = 'supportingInformation') then SupportingInformationList.move(source, destination){2a}
  else if (propName = 'reasonCode') then ReasonCodeList.move(source, destination){2a}
  else if (propName = 'reasonReference') then ReasonReferenceList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else if (propName = 'dosageInstruction') then DosageInstructionList.move(source, destination){2a}
  else if (propName = 'detectedIssue') then DetectedIssueList.move(source, destination){2a}
  else if (propName = 'eventHistory') then EventHistoryList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationRequest.fhirType : string;
begin
  result := 'MedicationRequest';
end;

function TFhirMedicationRequest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FdefinitionList) and isEmptyProp(FbasedOnList) and isEmptyProp(FGroupIdentifier) and isEmptyProp(FStatus) and isEmptyProp(FIntent) and isEmptyProp(FCategory) and isEmptyProp(FPriority) and isEmptyProp(FMedication) and isEmptyProp(FSubject) and isEmptyProp(FContext) and isEmptyProp(FsupportingInformationList) and isEmptyProp(FAuthoredOn) and isEmptyProp(FRequester) and isEmptyProp(FRecorder) and isEmptyProp(FreasonCodeList) and isEmptyProp(FreasonReferenceList) and isEmptyProp(FnoteList) and isEmptyProp(FdosageInstructionList) and isEmptyProp(FDispenseRequest) and isEmptyProp(FSubstitution) and isEmptyProp(FPriorPrescription) and isEmptyProp(FdetectedIssueList) and isEmptyProp(FeventHistoryList);
end;

function TFhirMedicationRequest.equals(other : TObject) : boolean;
var
  o : TFhirMedicationRequest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationRequest)) then
    result := false
  else
  begin
    o := TFhirMedicationRequest(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(definitionList, o.definitionList, true) and
      compareDeep(basedOnList, o.basedOnList, true) and compareDeep(groupIdentifierElement, o.groupIdentifierElement, true) and
      compareDeep(statusElement, o.statusElement, true) and compareDeep(intentElement, o.intentElement, true) and
      compareDeep(categoryElement, o.categoryElement, true) and compareDeep(priorityElement, o.priorityElement, true) and
      compareDeep(medicationElement, o.medicationElement, true) and compareDeep(subjectElement, o.subjectElement, true) and
      compareDeep(contextElement, o.contextElement, true) and compareDeep(supportingInformationList, o.supportingInformationList, true) and
      compareDeep(authoredOnElement, o.authoredOnElement, true) and compareDeep(requesterElement, o.requesterElement, true) and
      compareDeep(recorderElement, o.recorderElement, true) and compareDeep(reasonCodeList, o.reasonCodeList, true) and
      compareDeep(reasonReferenceList, o.reasonReferenceList, true) and compareDeep(noteList, o.noteList, true) and
      compareDeep(dosageInstructionList, o.dosageInstructionList, true) and compareDeep(dispenseRequestElement, o.dispenseRequestElement, true) and
      compareDeep(substitutionElement, o.substitutionElement, true) and compareDeep(priorPrescriptionElement, o.priorPrescriptionElement, true) and
      compareDeep(detectedIssueList, o.detectedIssueList, true) and compareDeep(eventHistoryList, o.eventHistoryList, true);
  end;
end;

function TFhirMedicationRequest.Link : TFhirMedicationRequest;
begin
  result := TFhirMedicationRequest(inherited Link);
end;

function TFhirMedicationRequest.Clone : TFhirMedicationRequest;
begin
  result := TFhirMedicationRequest(inherited Clone);
end;

procedure TFhirMedicationRequest.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('definition');
  fields.add('basedOn');
  fields.add('groupIdentifier');
  fields.add('status');
  fields.add('intent');
  fields.add('category');
  fields.add('priority');
  fields.add('medication[x]');
  fields.add('subject');
  fields.add('context');
  fields.add('supportingInformation');
  fields.add('authoredOn');
  fields.add('requester');
  fields.add('recorder');
  fields.add('reasonCode');
  fields.add('reasonReference');
  fields.add('note');
  fields.add('dosageInstruction');
  fields.add('dispenseRequest');
  fields.add('substitution');
  fields.add('priorPrescription');
  fields.add('detectedIssue');
  fields.add('eventHistory');
end;

{ TFhirMedicationRequest }

Function TFhirMedicationRequest.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirMedicationRequest.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Function TFhirMedicationRequest.GetDefinitionList : TFhirReferenceList{Resource};
begin
  if FDefinitionList = nil then
    FDefinitionList := TFhirReferenceList{Resource}.Create;
  result := FDefinitionList;
end;

Function TFhirMedicationRequest.GetHasDefinitionList : boolean;
begin
  result := (FDefinitionList <> nil) and (FDefinitionList.count > 0);
end;

Function TFhirMedicationRequest.GetBasedOnList : TFhirReferenceList{Resource};
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList{Resource}.Create;
  result := FBasedOnList;
end;

Function TFhirMedicationRequest.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

Procedure TFhirMedicationRequest.SetGroupIdentifier(value : TFhirIdentifier);
begin
  FGroupIdentifier.free;
  FGroupIdentifier := value;
end;

Procedure TFhirMedicationRequest.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirMedicationRequest.GetStatusST : TFhirMedicationRequestStatusEnum;
begin
  if FStatus = nil then
    result := TFhirMedicationRequestStatusEnum(0)
  else
    result := TFhirMedicationRequestStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirMedicationRequestStatusEnum, FStatus.value));
end;

Procedure TFhirMedicationRequest.SetStatusST(value : TFhirMedicationRequestStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirMedicationRequestStatusEnum[value], CODES_TFhirMedicationRequestStatusEnum[value]);
end;

Procedure TFhirMedicationRequest.SetIntent(value : TFhirEnum);
begin
  FIntent.free;
  FIntent := value;
end;

Function TFhirMedicationRequest.GetIntentST : TFhirMedicationRequestIntentEnum;
begin
  if FIntent = nil then
    result := TFhirMedicationRequestIntentEnum(0)
  else
    result := TFhirMedicationRequestIntentEnum(StringArrayIndexOfSensitive(CODES_TFhirMedicationRequestIntentEnum, FIntent.value));
end;

Procedure TFhirMedicationRequest.SetIntentST(value : TFhirMedicationRequestIntentEnum);
begin
  if ord(value) = 0 then
    IntentElement := nil
  else
    IntentElement := TFhirEnum.create(SYSTEMS_TFhirMedicationRequestIntentEnum[value], CODES_TFhirMedicationRequestIntentEnum[value]);
end;

Procedure TFhirMedicationRequest.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirMedicationRequest.SetPriority(value : TFhirEnum);
begin
  FPriority.free;
  FPriority := value;
end;

Function TFhirMedicationRequest.GetPriorityST : TFhirMedicationRequestPriorityEnum;
begin
  if FPriority = nil then
    result := TFhirMedicationRequestPriorityEnum(0)
  else
    result := TFhirMedicationRequestPriorityEnum(StringArrayIndexOfSensitive(CODES_TFhirMedicationRequestPriorityEnum, FPriority.value));
end;

Procedure TFhirMedicationRequest.SetPriorityST(value : TFhirMedicationRequestPriorityEnum);
begin
  if ord(value) = 0 then
    PriorityElement := nil
  else
    PriorityElement := TFhirEnum.create(SYSTEMS_TFhirMedicationRequestPriorityEnum[value], CODES_TFhirMedicationRequestPriorityEnum[value]);
end;

Procedure TFhirMedicationRequest.SetMedication(value : TFhirType);
begin
  FMedication.free;
  FMedication := value;
end;

Procedure TFhirMedicationRequest.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirMedicationRequest.SetContext(value : TFhirReference{Resource});
begin
  FContext.free;
  FContext := value;
end;

Function TFhirMedicationRequest.GetSupportingInformationList : TFhirReferenceList{TFhirReference};
begin
  if FSupportingInformationList = nil then
    FSupportingInformationList := TFhirReferenceList{TFhirReference}.Create;
  result := FSupportingInformationList;
end;

Function TFhirMedicationRequest.GetHasSupportingInformationList : boolean;
begin
  result := (FSupportingInformationList <> nil) and (FSupportingInformationList.count > 0);
end;

Procedure TFhirMedicationRequest.SetAuthoredOn(value : TFhirDateTime);
begin
  FAuthoredOn.free;
  FAuthoredOn := value;
end;

Function TFhirMedicationRequest.GetAuthoredOnST : TFslDateTime;
begin
  if FAuthoredOn = nil then
    result := TFslDateTime.makeNull
  else
    result := FAuthoredOn.value;
end;

Procedure TFhirMedicationRequest.SetAuthoredOnST(value : TFslDateTime);
begin
  if FAuthoredOn = nil then
    FAuthoredOn := TFhirDateTime.create;
  FAuthoredOn.value := value
end;

Procedure TFhirMedicationRequest.SetRequester(value : TFhirMedicationRequestRequester);
begin
  FRequester.free;
  FRequester := value;
end;

Procedure TFhirMedicationRequest.SetRecorder(value : TFhirReference{TFhirPractitioner});
begin
  FRecorder.free;
  FRecorder := value;
end;

Function TFhirMedicationRequest.GetReasonCodeList : TFhirCodeableConceptList;
begin
  if FReasonCodeList = nil then
    FReasonCodeList := TFhirCodeableConceptList.Create;
  result := FReasonCodeList;
end;

Function TFhirMedicationRequest.GetHasReasonCodeList : boolean;
begin
  result := (FReasonCodeList <> nil) and (FReasonCodeList.count > 0);
end;

Function TFhirMedicationRequest.GetReasonReferenceList : TFhirReferenceList{Resource};
begin
  if FReasonReferenceList = nil then
    FReasonReferenceList := TFhirReferenceList{Resource}.Create;
  result := FReasonReferenceList;
end;

Function TFhirMedicationRequest.GetHasReasonReferenceList : boolean;
begin
  result := (FReasonReferenceList <> nil) and (FReasonReferenceList.count > 0);
end;

Function TFhirMedicationRequest.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirMedicationRequest.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

Function TFhirMedicationRequest.GetDosageInstructionList : TFhirDosageList;
begin
  if FDosageInstructionList = nil then
    FDosageInstructionList := TFhirDosageList.Create;
  result := FDosageInstructionList;
end;

Function TFhirMedicationRequest.GetHasDosageInstructionList : boolean;
begin
  result := (FDosageInstructionList <> nil) and (FDosageInstructionList.count > 0);
end;

Procedure TFhirMedicationRequest.SetDispenseRequest(value : TFhirMedicationRequestDispenseRequest);
begin
  FDispenseRequest.free;
  FDispenseRequest := value;
end;

Procedure TFhirMedicationRequest.SetSubstitution(value : TFhirMedicationRequestSubstitution);
begin
  FSubstitution.free;
  FSubstitution := value;
end;

Procedure TFhirMedicationRequest.SetPriorPrescription(value : TFhirReference{TFhirMedicationRequest});
begin
  FPriorPrescription.free;
  FPriorPrescription := value;
end;

Function TFhirMedicationRequest.GetDetectedIssueList : TFhirReferenceList{TFhirDetectedIssue};
begin
  if FDetectedIssueList = nil then
    FDetectedIssueList := TFhirReferenceList{TFhirDetectedIssue}.Create;
  result := FDetectedIssueList;
end;

Function TFhirMedicationRequest.GetHasDetectedIssueList : boolean;
begin
  result := (FDetectedIssueList <> nil) and (FDetectedIssueList.count > 0);
end;

Function TFhirMedicationRequest.GetEventHistoryList : TFhirReferenceList{TFhirProvenance};
begin
  if FEventHistoryList = nil then
    FEventHistoryList := TFhirReferenceList{TFhirProvenance}.Create;
  result := FEventHistoryList;
end;

Function TFhirMedicationRequest.GetHasEventHistoryList : boolean;
begin
  result := (FEventHistoryList <> nil) and (FEventHistoryList.count > 0);
end;

function TFhirMedicationRequest.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FdefinitionList.sizeInBytes);
  inc(result, FbasedOnList.sizeInBytes);
  inc(result, FGroupIdentifier.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FIntent.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FPriority.sizeInBytes);
  inc(result, FMedication.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FContext.sizeInBytes);
  inc(result, FsupportingInformationList.sizeInBytes);
  inc(result, FAuthoredOn.sizeInBytes);
  inc(result, FRequester.sizeInBytes);
  inc(result, FRecorder.sizeInBytes);
  inc(result, FreasonCodeList.sizeInBytes);
  inc(result, FreasonReferenceList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FdosageInstructionList.sizeInBytes);
  inc(result, FDispenseRequest.sizeInBytes);
  inc(result, FSubstitution.sizeInBytes);
  inc(result, FPriorPrescription.sizeInBytes);
  inc(result, FdetectedIssueList.sizeInBytes);
  inc(result, FeventHistoryList.sizeInBytes);
end;

{ TFhirMedicationRequestListEnumerator }

Constructor TFhirMedicationRequestListEnumerator.Create(list : TFhirMedicationRequestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationRequestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationRequestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationRequestListEnumerator.GetCurrent : TFhirMedicationRequest;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationRequestListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationRequestList }
procedure TFhirMedicationRequestList.AddItem(value: TFhirMedicationRequest);
begin
  assert(value.ClassName = 'TFhirMedicationRequest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationRequest');
  add(value);
end;

function TFhirMedicationRequestList.Append: TFhirMedicationRequest;
begin
  result := TFhirMedicationRequest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationRequestList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationRequestList.GetEnumerator : TFhirMedicationRequestListEnumerator;
begin
  result := TFhirMedicationRequestListEnumerator.Create(self.link);
end;

function TFhirMedicationRequestList.Clone: TFhirMedicationRequestList;
begin
  result := TFhirMedicationRequestList(inherited Clone);
end;

function TFhirMedicationRequestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationRequestList.GetItemN(index: Integer): TFhirMedicationRequest;
begin
  result := TFhirMedicationRequest(ObjectByIndex[index]);
end;

function TFhirMedicationRequestList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationRequest;
end;
function TFhirMedicationRequestList.IndexOf(value: TFhirMedicationRequest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationRequestList.Insert(index: Integer): TFhirMedicationRequest;
begin
  result := TFhirMedicationRequest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationRequestList.InsertItem(index: Integer; value: TFhirMedicationRequest);
begin
  assert(value is TFhirMedicationRequest);
  Inherited Insert(index, value);
end;

function TFhirMedicationRequestList.Item(index: Integer): TFhirMedicationRequest;
begin
  result := TFhirMedicationRequest(ObjectByIndex[index]);
end;

function TFhirMedicationRequestList.Link: TFhirMedicationRequestList;
begin
  result := TFhirMedicationRequestList(inherited Link);
end;

procedure TFhirMedicationRequestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationRequestList.SetItemByIndex(index: Integer; value: TFhirMedicationRequest);
begin
  assert(value is TFhirMedicationRequest);
  FhirMedicationRequests[index] := value;
end;

procedure TFhirMedicationRequestList.SetItemN(index: Integer; value: TFhirMedicationRequest);
begin
  assert(value is TFhirMedicationRequest);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEDICATIONREQUEST}

{$IFDEF FHIR_MEDICATIONSTATEMENT}

{ TFhirMedicationStatement }

constructor TFhirMedicationStatement.Create;
begin
  inherited;
end;

destructor TFhirMedicationStatement.Destroy;
begin
  FIdentifierList.Free;
  FBasedOnList.Free;
  FPartOfList.Free;
  FContext.free;
  FStatus.free;
  FCategory.free;
  FMedication.free;
  FEffective.free;
  FDateAsserted.free;
  FInformationSource.free;
  FSubject.free;
  FDerivedFromList.Free;
  FTaken.free;
  FReasonNotTakenList.Free;
  FReasonCodeList.Free;
  FReasonReferenceList.Free;
  FNoteList.Free;
  FDosageList.Free;
  inherited;
end;

function TFhirMedicationStatement.GetResourceType : TFhirResourceType;
begin
  result := frtMedicationStatement;
end;

procedure TFhirMedicationStatement.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedicationStatement(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirMedicationStatement(oSource).FIdentifierList);
  end;
  if (TFhirMedicationStatement(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList{Resource}.Create;
    FBasedOnList.Assign(TFhirMedicationStatement(oSource).FBasedOnList);
  end;
  if (TFhirMedicationStatement(oSource).FPartOfList = nil) then
  begin
    FPartOfList.free;
    FPartOfList := nil;
  end
  else
  begin
    if FPartOfList = nil then
      FPartOfList := TFhirReferenceList{Resource}.Create;
    FPartOfList.Assign(TFhirMedicationStatement(oSource).FPartOfList);
  end;
  context := TFhirMedicationStatement(oSource).context.Clone;
  FStatus := TFhirMedicationStatement(oSource).FStatus.Link;
  category := TFhirMedicationStatement(oSource).category.Clone;
  medication := TFhirMedicationStatement(oSource).medication.Clone;
  effective := TFhirMedicationStatement(oSource).effective.Clone;
  dateAssertedElement := TFhirMedicationStatement(oSource).dateAssertedElement.Clone;
  informationSource := TFhirMedicationStatement(oSource).informationSource.Clone;
  subject := TFhirMedicationStatement(oSource).subject.Clone;
  if (TFhirMedicationStatement(oSource).FDerivedFromList = nil) then
  begin
    FDerivedFromList.free;
    FDerivedFromList := nil;
  end
  else
  begin
    if FDerivedFromList = nil then
      FDerivedFromList := TFhirReferenceList{TFhirReference}.Create;
    FDerivedFromList.Assign(TFhirMedicationStatement(oSource).FDerivedFromList);
  end;
  FTaken := TFhirMedicationStatement(oSource).FTaken.Link;
  if (TFhirMedicationStatement(oSource).FReasonNotTakenList = nil) then
  begin
    FReasonNotTakenList.free;
    FReasonNotTakenList := nil;
  end
  else
  begin
    if FReasonNotTakenList = nil then
      FReasonNotTakenList := TFhirCodeableConceptList.Create;
    FReasonNotTakenList.Assign(TFhirMedicationStatement(oSource).FReasonNotTakenList);
  end;
  if (TFhirMedicationStatement(oSource).FReasonCodeList = nil) then
  begin
    FReasonCodeList.free;
    FReasonCodeList := nil;
  end
  else
  begin
    if FReasonCodeList = nil then
      FReasonCodeList := TFhirCodeableConceptList.Create;
    FReasonCodeList.Assign(TFhirMedicationStatement(oSource).FReasonCodeList);
  end;
  if (TFhirMedicationStatement(oSource).FReasonReferenceList = nil) then
  begin
    FReasonReferenceList.free;
    FReasonReferenceList := nil;
  end
  else
  begin
    if FReasonReferenceList = nil then
      FReasonReferenceList := TFhirReferenceList{Resource}.Create;
    FReasonReferenceList.Assign(TFhirMedicationStatement(oSource).FReasonReferenceList);
  end;
  if (TFhirMedicationStatement(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirMedicationStatement(oSource).FNoteList);
  end;
  if (TFhirMedicationStatement(oSource).FDosageList = nil) then
  begin
    FDosageList.free;
    FDosageList := nil;
  end
  else
  begin
    if FDosageList = nil then
      FDosageList := TFhirDosageList.Create;
    FDosageList.Assign(TFhirMedicationStatement(oSource).FDosageList);
  end;
end;

procedure TFhirMedicationStatement.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'partOf') Then
    list.addAll(self, 'partOf', FPartOfList);
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'medication[x]') or (child_name = 'medication') Then
     list.add(self.link, 'medication[x]', FMedication.Link);
  if (child_name = 'effective[x]') or (child_name = 'effective') Then
     list.add(self.link, 'effective[x]', FEffective.Link);
  if (child_name = 'dateAsserted') Then
     list.add(self.link, 'dateAsserted', FDateAsserted.Link);
  if (child_name = 'informationSource') Then
     list.add(self.link, 'informationSource', FInformationSource.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'derivedFrom') Then
    list.addAll(self, 'derivedFrom', FDerivedFromList);
  if (child_name = 'taken') Then
     list.add(self.link, 'taken', FTaken.Link);
  if (child_name = 'reasonNotTaken') Then
    list.addAll(self, 'reasonNotTaken', FReasonNotTakenList);
  if (child_name = 'reasonCode') Then
    list.addAll(self, 'reasonCode', FReasonCodeList);
  if (child_name = 'reasonReference') Then
    list.addAll(self, 'reasonReference', FReasonReferenceList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'dosage') Then
    list.addAll(self, 'dosage', FDosageList);
end;

procedure TFhirMedicationStatement.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference(MedicationRequest|CarePlan|ProcedureRequest|ReferralRequest)', true, TFhirReference{Resource}, FBasedOnList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference(MedicationAdministration|MedicationDispense|MedicationStatement|Procedure|Observation)', true, TFhirReference{Resource}, FPartOfList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'context', 'Reference(Encounter|EpisodeOfCare)', false, TFhirReference{Resource}, FContext.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'medication[x]', 'CodeableConcept|Reference(Medication)', false, TFhirType, FMedication.Link));{2}
  oList.add(TFHIRProperty.create(self, 'effective[x]', 'dateTime|Period', false, TFhirType, FEffective.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dateAsserted', 'dateTime', false, TFhirDateTime, FDateAsserted.Link));{2}
  oList.add(TFHIRProperty.create(self, 'informationSource', 'Reference(Patient|Practitioner|RelatedPerson|Organization)', false, TFhirReference{Resource}, FInformationSource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Group)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'derivedFrom', 'Reference(Any)', true, TFhirReference{TFhirReference}, FDerivedFromList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'taken', 'code', false, TFHIREnum, FTaken.Link));{1}
  oList.add(TFHIRProperty.create(self, 'reasonNotTaken', 'CodeableConcept', true, TFhirCodeableConcept, FReasonNotTakenList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reasonCode', 'CodeableConcept', true, TFhirCodeableConcept, FReasonCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reasonReference', 'Reference(Condition|Observation)', true, TFhirReference{Resource}, FReasonReferenceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'dosage', 'Dosage', true, TFhirDosage, FDosageList.Link)){3};
end;

function TFhirMedicationStatement.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOfList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'context') then
  begin
    Context := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirMedicationStatementStatusEnum, CODES_TFhirMedicationStatementStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then
  begin
    Medication := propValue as TFhirType{4};
    result := propValue;
  end
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then
  begin
    Effective := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'dateAsserted') then
  begin
    DateAssertedElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'informationSource') then
  begin
    InformationSource := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'derivedFrom') then
  begin
    DerivedFromList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'taken') then
  begin
    TakenElement := asEnum(SYSTEMS_TFhirMedicationStatementTakenEnum, CODES_TFhirMedicationStatementTakenEnum, propValue);
    result := propValue
  end
  else if (propName = 'reasonNotTaken') then
  begin
    ReasonNotTakenList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'reasonCode') then
  begin
    ReasonCodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'reasonReference') then
  begin
    ReasonReferenceList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else if (propName = 'dosage') then
  begin
    DosageList.add(propValue as TFhirDosage){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirMedicationStatement.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'partOf') then PartOfList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'derivedFrom') then DerivedFromList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'reasonNotTaken') then ReasonNotTakenList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'reasonCode') then ReasonCodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'reasonReference') then ReasonReferenceList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else if (propName = 'dosage') then DosageList.insertItem(index, propValue as TFhirDosage){2a}
  else inherited;
end;

function TFhirMedicationStatement.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'basedOn') then result := BasedOnList.new(){2}
  else if (propName = 'partOf') then result := PartOfList.new(){2}
  else if (propName = 'context') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Medication'){4x}
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Effective'){4x}
  else if (propName = 'dateAsserted') then result := TFhirDateTime.create() {5b}
  else if (propName = 'informationSource') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'derivedFrom') then result := DerivedFromList.new(){2}
  else if (propName = 'reasonNotTaken') then result := ReasonNotTakenList.new(){2}
  else if (propName = 'reasonCode') then result := ReasonCodeList.new(){2}
  else if (propName = 'reasonReference') then result := ReasonReferenceList.new(){2}
  else if (propName = 'note') then result := NoteList.new(){2}
  else if (propName = 'dosage') then result := DosageList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationStatement.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'context') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'medication[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'effective[x]') then result := 'dateTime|Period'
  else if (propName = 'dateAsserted') then result := 'dateTime'
  else if (propName = 'informationSource') then result := 'Reference'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'derivedFrom') then result := 'Reference'
  else if (propName = 'taken') then result := 'code'
  else if (propName = 'reasonNotTaken') then result := 'CodeableConcept'
  else if (propName = 'reasonCode') then result := 'CodeableConcept'
  else if (propName = 'reasonReference') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'dosage') then result := 'Dosage'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationStatement.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value) {2}
  else if (propName = 'partOf') then deletePropertyValue('partOf', PartOfList, value) {2}
  else if (propName = 'context') then ContextElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then MedicationElement := nil{4x}
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then EffectiveElement := nil{4x}
  else if (propName = 'dateAsserted') then DateAssertedElement := nil
  else if (propName = 'informationSource') then InformationSourceElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'derivedFrom') then deletePropertyValue('derivedFrom', DerivedFromList, value) {2}
  else if (propName = 'taken') then TakenElement := nil
  else if (propName = 'reasonNotTaken') then deletePropertyValue('reasonNotTaken', ReasonNotTakenList, value) {2}
  else if (propName = 'reasonCode') then deletePropertyValue('reasonCode', ReasonCodeList, value) {2}
  else if (propName = 'reasonReference') then deletePropertyValue('reasonReference', ReasonReferenceList, value) {2}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else if (propName = 'dosage') then deletePropertyValue('dosage', DosageList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationStatement.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new) {2}
  else if (propName = 'partOf') then replacePropertyValue('partOf', PartOfList, existing, new) {2}
  else if (propName = 'context') then ContextElement := new as TFhirReference{Resource}{4}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirMedicationStatementStatusEnum, CODES_TFhirMedicationStatementStatusEnum, new){4}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then MedicationElement := new as TFhirType{4x}
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then EffectiveElement := new as TFhirType{4x}
  else if (propName = 'dateAsserted') then DateAssertedElement := asDateTime(new){5b}
  else if (propName = 'informationSource') then InformationSourceElement := new as TFhirReference{Resource}{4}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'derivedFrom') then replacePropertyValue('derivedFrom', DerivedFromList, existing, new) {2}
  else if (propName = 'taken') then TakenElement := asEnum(SYSTEMS_TFhirMedicationStatementTakenEnum, CODES_TFhirMedicationStatementTakenEnum, new){4}
  else if (propName = 'reasonNotTaken') then replacePropertyValue('reasonNotTaken', ReasonNotTakenList, existing, new) {2}
  else if (propName = 'reasonCode') then replacePropertyValue('reasonCode', ReasonCodeList, existing, new) {2}
  else if (propName = 'reasonReference') then replacePropertyValue('reasonReference', ReasonReferenceList, existing, new) {2}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else if (propName = 'dosage') then replacePropertyValue('dosage', DosageList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationStatement.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'basedOn') then BasedOnList.move(source, destination){2a}
  else if (propName = 'partOf') then PartOfList.move(source, destination){2a}
  else if (propName = 'derivedFrom') then DerivedFromList.move(source, destination){2a}
  else if (propName = 'reasonNotTaken') then ReasonNotTakenList.move(source, destination){2a}
  else if (propName = 'reasonCode') then ReasonCodeList.move(source, destination){2a}
  else if (propName = 'reasonReference') then ReasonReferenceList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else if (propName = 'dosage') then DosageList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationStatement.fhirType : string;
begin
  result := 'MedicationStatement';
end;

function TFhirMedicationStatement.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FbasedOnList) and isEmptyProp(FpartOfList) and isEmptyProp(FContext) and isEmptyProp(FStatus) and isEmptyProp(FCategory) and isEmptyProp(FMedication) and isEmptyProp(FEffective) and isEmptyProp(FDateAsserted) and isEmptyProp(FInformationSource) and isEmptyProp(FSubject) and isEmptyProp(FderivedFromList) and isEmptyProp(FTaken) and isEmptyProp(FreasonNotTakenList) and isEmptyProp(FreasonCodeList) and isEmptyProp(FreasonReferenceList) and isEmptyProp(FnoteList) and isEmptyProp(FdosageList);
end;

function TFhirMedicationStatement.equals(other : TObject) : boolean;
var
  o : TFhirMedicationStatement;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationStatement)) then
    result := false
  else
  begin
    o := TFhirMedicationStatement(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(basedOnList, o.basedOnList, true) and
      compareDeep(partOfList, o.partOfList, true) and compareDeep(contextElement, o.contextElement, true) and
      compareDeep(statusElement, o.statusElement, true) and compareDeep(categoryElement, o.categoryElement, true) and
      compareDeep(medicationElement, o.medicationElement, true) and compareDeep(effectiveElement, o.effectiveElement, true) and
      compareDeep(dateAssertedElement, o.dateAssertedElement, true) and compareDeep(informationSourceElement, o.informationSourceElement, true) and
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(derivedFromList, o.derivedFromList, true) and
      compareDeep(takenElement, o.takenElement, true) and compareDeep(reasonNotTakenList, o.reasonNotTakenList, true) and
      compareDeep(reasonCodeList, o.reasonCodeList, true) and compareDeep(reasonReferenceList, o.reasonReferenceList, true) and
      compareDeep(noteList, o.noteList, true) and compareDeep(dosageList, o.dosageList, true);
  end;
end;

function TFhirMedicationStatement.Link : TFhirMedicationStatement;
begin
  result := TFhirMedicationStatement(inherited Link);
end;

function TFhirMedicationStatement.Clone : TFhirMedicationStatement;
begin
  result := TFhirMedicationStatement(inherited Clone);
end;

procedure TFhirMedicationStatement.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('basedOn');
  fields.add('partOf');
  fields.add('context');
  fields.add('status');
  fields.add('category');
  fields.add('medication[x]');
  fields.add('effective[x]');
  fields.add('dateAsserted');
  fields.add('informationSource');
  fields.add('subject');
  fields.add('derivedFrom');
  fields.add('taken');
  fields.add('reasonNotTaken');
  fields.add('reasonCode');
  fields.add('reasonReference');
  fields.add('note');
  fields.add('dosage');
end;

{ TFhirMedicationStatement }

Function TFhirMedicationStatement.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirMedicationStatement.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Function TFhirMedicationStatement.GetBasedOnList : TFhirReferenceList{Resource};
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList{Resource}.Create;
  result := FBasedOnList;
end;

Function TFhirMedicationStatement.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

Function TFhirMedicationStatement.GetPartOfList : TFhirReferenceList{Resource};
begin
  if FPartOfList = nil then
    FPartOfList := TFhirReferenceList{Resource}.Create;
  result := FPartOfList;
end;

Function TFhirMedicationStatement.GetHasPartOfList : boolean;
begin
  result := (FPartOfList <> nil) and (FPartOfList.count > 0);
end;

Procedure TFhirMedicationStatement.SetContext(value : TFhirReference{Resource});
begin
  FContext.free;
  FContext := value;
end;

Procedure TFhirMedicationStatement.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirMedicationStatement.GetStatusST : TFhirMedicationStatementStatusEnum;
begin
  if FStatus = nil then
    result := TFhirMedicationStatementStatusEnum(0)
  else
    result := TFhirMedicationStatementStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirMedicationStatementStatusEnum, FStatus.value));
end;

Procedure TFhirMedicationStatement.SetStatusST(value : TFhirMedicationStatementStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirMedicationStatementStatusEnum[value], CODES_TFhirMedicationStatementStatusEnum[value]);
end;

Procedure TFhirMedicationStatement.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirMedicationStatement.SetMedication(value : TFhirType);
begin
  FMedication.free;
  FMedication := value;
end;

Procedure TFhirMedicationStatement.SetEffective(value : TFhirType);
begin
  FEffective.free;
  FEffective := value;
end;

Procedure TFhirMedicationStatement.SetDateAsserted(value : TFhirDateTime);
begin
  FDateAsserted.free;
  FDateAsserted := value;
end;

Function TFhirMedicationStatement.GetDateAssertedST : TFslDateTime;
begin
  if FDateAsserted = nil then
    result := TFslDateTime.makeNull
  else
    result := FDateAsserted.value;
end;

Procedure TFhirMedicationStatement.SetDateAssertedST(value : TFslDateTime);
begin
  if FDateAsserted = nil then
    FDateAsserted := TFhirDateTime.create;
  FDateAsserted.value := value
end;

Procedure TFhirMedicationStatement.SetInformationSource(value : TFhirReference{Resource});
begin
  FInformationSource.free;
  FInformationSource := value;
end;

Procedure TFhirMedicationStatement.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Function TFhirMedicationStatement.GetDerivedFromList : TFhirReferenceList{TFhirReference};
begin
  if FDerivedFromList = nil then
    FDerivedFromList := TFhirReferenceList{TFhirReference}.Create;
  result := FDerivedFromList;
end;

Function TFhirMedicationStatement.GetHasDerivedFromList : boolean;
begin
  result := (FDerivedFromList <> nil) and (FDerivedFromList.count > 0);
end;

Procedure TFhirMedicationStatement.SetTaken(value : TFhirEnum);
begin
  FTaken.free;
  FTaken := value;
end;

Function TFhirMedicationStatement.GetTakenST : TFhirMedicationStatementTakenEnum;
begin
  if FTaken = nil then
    result := TFhirMedicationStatementTakenEnum(0)
  else
    result := TFhirMedicationStatementTakenEnum(StringArrayIndexOfSensitive(CODES_TFhirMedicationStatementTakenEnum, FTaken.value));
end;

Procedure TFhirMedicationStatement.SetTakenST(value : TFhirMedicationStatementTakenEnum);
begin
  if ord(value) = 0 then
    TakenElement := nil
  else
    TakenElement := TFhirEnum.create(SYSTEMS_TFhirMedicationStatementTakenEnum[value], CODES_TFhirMedicationStatementTakenEnum[value]);
end;

Function TFhirMedicationStatement.GetReasonNotTakenList : TFhirCodeableConceptList;
begin
  if FReasonNotTakenList = nil then
    FReasonNotTakenList := TFhirCodeableConceptList.Create;
  result := FReasonNotTakenList;
end;

Function TFhirMedicationStatement.GetHasReasonNotTakenList : boolean;
begin
  result := (FReasonNotTakenList <> nil) and (FReasonNotTakenList.count > 0);
end;

Function TFhirMedicationStatement.GetReasonCodeList : TFhirCodeableConceptList;
begin
  if FReasonCodeList = nil then
    FReasonCodeList := TFhirCodeableConceptList.Create;
  result := FReasonCodeList;
end;

Function TFhirMedicationStatement.GetHasReasonCodeList : boolean;
begin
  result := (FReasonCodeList <> nil) and (FReasonCodeList.count > 0);
end;

Function TFhirMedicationStatement.GetReasonReferenceList : TFhirReferenceList{Resource};
begin
  if FReasonReferenceList = nil then
    FReasonReferenceList := TFhirReferenceList{Resource}.Create;
  result := FReasonReferenceList;
end;

Function TFhirMedicationStatement.GetHasReasonReferenceList : boolean;
begin
  result := (FReasonReferenceList <> nil) and (FReasonReferenceList.count > 0);
end;

Function TFhirMedicationStatement.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirMedicationStatement.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

Function TFhirMedicationStatement.GetDosageList : TFhirDosageList;
begin
  if FDosageList = nil then
    FDosageList := TFhirDosageList.Create;
  result := FDosageList;
end;

Function TFhirMedicationStatement.GetHasDosageList : boolean;
begin
  result := (FDosageList <> nil) and (FDosageList.count > 0);
end;

function TFhirMedicationStatement.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FbasedOnList.sizeInBytes);
  inc(result, FpartOfList.sizeInBytes);
  inc(result, FContext.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FMedication.sizeInBytes);
  inc(result, FEffective.sizeInBytes);
  inc(result, FDateAsserted.sizeInBytes);
  inc(result, FInformationSource.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FderivedFromList.sizeInBytes);
  inc(result, FTaken.sizeInBytes);
  inc(result, FreasonNotTakenList.sizeInBytes);
  inc(result, FreasonCodeList.sizeInBytes);
  inc(result, FreasonReferenceList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FdosageList.sizeInBytes);
end;

{ TFhirMedicationStatementListEnumerator }

Constructor TFhirMedicationStatementListEnumerator.Create(list : TFhirMedicationStatementList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationStatementListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationStatementListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationStatementListEnumerator.GetCurrent : TFhirMedicationStatement;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationStatementListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMedicationStatementList }
procedure TFhirMedicationStatementList.AddItem(value: TFhirMedicationStatement);
begin
  assert(value.ClassName = 'TFhirMedicationStatement', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationStatement');
  add(value);
end;

function TFhirMedicationStatementList.Append: TFhirMedicationStatement;
begin
  result := TFhirMedicationStatement.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationStatementList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationStatementList.GetEnumerator : TFhirMedicationStatementListEnumerator;
begin
  result := TFhirMedicationStatementListEnumerator.Create(self.link);
end;

function TFhirMedicationStatementList.Clone: TFhirMedicationStatementList;
begin
  result := TFhirMedicationStatementList(inherited Clone);
end;

function TFhirMedicationStatementList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationStatementList.GetItemN(index: Integer): TFhirMedicationStatement;
begin
  result := TFhirMedicationStatement(ObjectByIndex[index]);
end;

function TFhirMedicationStatementList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationStatement;
end;
function TFhirMedicationStatementList.IndexOf(value: TFhirMedicationStatement): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationStatementList.Insert(index: Integer): TFhirMedicationStatement;
begin
  result := TFhirMedicationStatement.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationStatementList.InsertItem(index: Integer; value: TFhirMedicationStatement);
begin
  assert(value is TFhirMedicationStatement);
  Inherited Insert(index, value);
end;

function TFhirMedicationStatementList.Item(index: Integer): TFhirMedicationStatement;
begin
  result := TFhirMedicationStatement(ObjectByIndex[index]);
end;

function TFhirMedicationStatementList.Link: TFhirMedicationStatementList;
begin
  result := TFhirMedicationStatementList(inherited Link);
end;

procedure TFhirMedicationStatementList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationStatementList.SetItemByIndex(index: Integer; value: TFhirMedicationStatement);
begin
  assert(value is TFhirMedicationStatement);
  FhirMedicationStatements[index] := value;
end;

procedure TFhirMedicationStatementList.SetItemN(index: Integer; value: TFhirMedicationStatement);
begin
  assert(value is TFhirMedicationStatement);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEDICATIONSTATEMENT}

{$IFDEF FHIR_NUTRITIONORDER}

{ TFhirNutritionOrderOralDiet }

constructor TFhirNutritionOrderOralDiet.Create;
begin
  inherited;
end;

destructor TFhirNutritionOrderOralDiet.Destroy;
begin
  FType_List.Free;
  FScheduleList.Free;
  FNutrientList.Free;
  FTextureList.Free;
  FFluidConsistencyTypeList.Free;
  FInstruction.free;
  inherited;
end;

procedure TFhirNutritionOrderOralDiet.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirNutritionOrderOralDiet(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirNutritionOrderOralDiet(oSource).FType_List);
  end;
  if (TFhirNutritionOrderOralDiet(oSource).FScheduleList = nil) then
  begin
    FScheduleList.free;
    FScheduleList := nil;
  end
  else
  begin
    if FScheduleList = nil then
      FScheduleList := TFhirTimingList.Create;
    FScheduleList.Assign(TFhirNutritionOrderOralDiet(oSource).FScheduleList);
  end;
  if (TFhirNutritionOrderOralDiet(oSource).FNutrientList = nil) then
  begin
    FNutrientList.free;
    FNutrientList := nil;
  end
  else
  begin
    if FNutrientList = nil then
      FNutrientList := TFhirNutritionOrderOralDietNutrientList.Create;
    FNutrientList.Assign(TFhirNutritionOrderOralDiet(oSource).FNutrientList);
  end;
  if (TFhirNutritionOrderOralDiet(oSource).FTextureList = nil) then
  begin
    FTextureList.free;
    FTextureList := nil;
  end
  else
  begin
    if FTextureList = nil then
      FTextureList := TFhirNutritionOrderOralDietTextureList.Create;
    FTextureList.Assign(TFhirNutritionOrderOralDiet(oSource).FTextureList);
  end;
  if (TFhirNutritionOrderOralDiet(oSource).FFluidConsistencyTypeList = nil) then
  begin
    FFluidConsistencyTypeList.free;
    FFluidConsistencyTypeList := nil;
  end
  else
  begin
    if FFluidConsistencyTypeList = nil then
      FFluidConsistencyTypeList := TFhirCodeableConceptList.Create;
    FFluidConsistencyTypeList.Assign(TFhirNutritionOrderOralDiet(oSource).FFluidConsistencyTypeList);
  end;
  instructionElement := TFhirNutritionOrderOralDiet(oSource).instructionElement.Clone;
end;

procedure TFhirNutritionOrderOralDiet.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'schedule') Then
    list.addAll(self, 'schedule', FScheduleList);
  if (child_name = 'nutrient') Then
    list.addAll(self, 'nutrient', FNutrientList);
  if (child_name = 'texture') Then
    list.addAll(self, 'texture', FTextureList);
  if (child_name = 'fluidConsistencyType') Then
    list.addAll(self, 'fluidConsistencyType', FFluidConsistencyTypeList);
  if (child_name = 'instruction') Then
     list.add(self.link, 'instruction', FInstruction.Link);
end;

procedure TFhirNutritionOrderOralDiet.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'schedule', 'Timing', true, TFhirTiming, FScheduleList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'nutrient', '', true, TFhirNutritionOrderOralDietNutrient, FNutrientList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'texture', '', true, TFhirNutritionOrderOralDietTexture, FTextureList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'fluidConsistencyType', 'CodeableConcept', true, TFhirCodeableConcept, FFluidConsistencyTypeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'instruction', 'string', false, TFhirString, FInstruction.Link));{2}
end;

function TFhirNutritionOrderOralDiet.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'schedule') then
  begin
    ScheduleList.add(propValue as TFhirTiming){2a};
    result := propValue;
  end
  else if (propName = 'nutrient') then
  begin
    NutrientList.add(propValue as TFhirNutritionOrderOralDietNutrient){2a};
    result := propValue;
  end
  else if (propName = 'texture') then
  begin
    TextureList.add(propValue as TFhirNutritionOrderOralDietTexture){2a};
    result := propValue;
  end
  else if (propName = 'fluidConsistencyType') then
  begin
    FluidConsistencyTypeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'instruction') then
  begin
    InstructionElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionOrderOralDiet.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'schedule') then ScheduleList.insertItem(index, propValue as TFhirTiming){2a}
  else if (propName = 'nutrient') then NutrientList.insertItem(index, propValue as TFhirNutritionOrderOralDietNutrient){2a}
  else if (propName = 'texture') then TextureList.insertItem(index, propValue as TFhirNutritionOrderOralDietTexture){2a}
  else if (propName = 'fluidConsistencyType') then FluidConsistencyTypeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirNutritionOrderOralDiet.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := Type_List.new(){2}
  else if (propName = 'schedule') then result := ScheduleList.new(){2}
  else if (propName = 'nutrient') then result := NutrientList.new(){2}
  else if (propName = 'texture') then result := TextureList.new(){2}
  else if (propName = 'fluidConsistencyType') then result := FluidConsistencyTypeList.new(){2}
  else if (propName = 'instruction') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionOrderOralDiet.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'schedule') then result := 'Timing'
  else if (propName = 'nutrient') then result := ''
  else if (propName = 'texture') then result := ''
  else if (propName = 'fluidConsistencyType') then result := 'CodeableConcept'
  else if (propName = 'instruction') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionOrderOralDiet.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then deletePropertyValue('type', Type_List, value) {2}
  else if (propName = 'schedule') then deletePropertyValue('schedule', ScheduleList, value) {2}
  else if (propName = 'nutrient') then deletePropertyValue('nutrient', NutrientList, value) {2}
  else if (propName = 'texture') then deletePropertyValue('texture', TextureList, value) {2}
  else if (propName = 'fluidConsistencyType') then deletePropertyValue('fluidConsistencyType', FluidConsistencyTypeList, value) {2}
  else if (propName = 'instruction') then InstructionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionOrderOralDiet.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new) {2}
  else if (propName = 'schedule') then replacePropertyValue('schedule', ScheduleList, existing, new) {2}
  else if (propName = 'nutrient') then replacePropertyValue('nutrient', NutrientList, existing, new) {2}
  else if (propName = 'texture') then replacePropertyValue('texture', TextureList, existing, new) {2}
  else if (propName = 'fluidConsistencyType') then replacePropertyValue('fluidConsistencyType', FluidConsistencyTypeList, existing, new) {2}
  else if (propName = 'instruction') then InstructionElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionOrderOralDiet.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'type') then Type_List.move(source, destination){2a}
  else if (propName = 'schedule') then ScheduleList.move(source, destination){2a}
  else if (propName = 'nutrient') then NutrientList.move(source, destination){2a}
  else if (propName = 'texture') then TextureList.move(source, destination){2a}
  else if (propName = 'fluidConsistencyType') then FluidConsistencyTypeList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionOrderOralDiet.fhirType : string;
begin
  result := 'oralDiet';
end;

function TFhirNutritionOrderOralDiet.Link : TFhirNutritionOrderOralDiet;
begin
  result := TFhirNutritionOrderOralDiet(inherited Link);
end;

function TFhirNutritionOrderOralDiet.Clone : TFhirNutritionOrderOralDiet;
begin
  result := TFhirNutritionOrderOralDiet(inherited Clone);
end;

function TFhirNutritionOrderOralDiet.equals(other : TObject) : boolean;
var
  o : TFhirNutritionOrderOralDiet;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionOrderOralDiet)) then
    result := false
  else
  begin
    o := TFhirNutritionOrderOralDiet(other);
    result := compareDeep(type_List, o.type_List, true) and compareDeep(scheduleList, o.scheduleList, true) and
      compareDeep(nutrientList, o.nutrientList, true) and compareDeep(textureList, o.textureList, true) and
      compareDeep(fluidConsistencyTypeList, o.fluidConsistencyTypeList, true) and compareDeep(instructionElement, o.instructionElement, true);
  end;
end;

function TFhirNutritionOrderOralDiet.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(Ftype_List) and isEmptyProp(FscheduleList) and isEmptyProp(FnutrientList) and isEmptyProp(FtextureList) and isEmptyProp(FfluidConsistencyTypeList) and isEmptyProp(FInstruction);
end;

procedure TFhirNutritionOrderOralDiet.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('schedule');
  fields.add('nutrient');
  fields.add('texture');
  fields.add('fluidConsistencyType');
  fields.add('instruction');
end;

{ TFhirNutritionOrderOralDiet }

Function TFhirNutritionOrderOralDiet.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

Function TFhirNutritionOrderOralDiet.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

Function TFhirNutritionOrderOralDiet.GetScheduleList : TFhirTimingList;
begin
  if FScheduleList = nil then
    FScheduleList := TFhirTimingList.Create;
  result := FScheduleList;
end;

Function TFhirNutritionOrderOralDiet.GetHasScheduleList : boolean;
begin
  result := (FScheduleList <> nil) and (FScheduleList.count > 0);
end;

Function TFhirNutritionOrderOralDiet.GetNutrientList : TFhirNutritionOrderOralDietNutrientList;
begin
  if FNutrientList = nil then
    FNutrientList := TFhirNutritionOrderOralDietNutrientList.Create;
  result := FNutrientList;
end;

Function TFhirNutritionOrderOralDiet.GetHasNutrientList : boolean;
begin
  result := (FNutrientList <> nil) and (FNutrientList.count > 0);
end;

Function TFhirNutritionOrderOralDiet.GetTextureList : TFhirNutritionOrderOralDietTextureList;
begin
  if FTextureList = nil then
    FTextureList := TFhirNutritionOrderOralDietTextureList.Create;
  result := FTextureList;
end;

Function TFhirNutritionOrderOralDiet.GetHasTextureList : boolean;
begin
  result := (FTextureList <> nil) and (FTextureList.count > 0);
end;

Function TFhirNutritionOrderOralDiet.GetFluidConsistencyTypeList : TFhirCodeableConceptList;
begin
  if FFluidConsistencyTypeList = nil then
    FFluidConsistencyTypeList := TFhirCodeableConceptList.Create;
  result := FFluidConsistencyTypeList;
end;

Function TFhirNutritionOrderOralDiet.GetHasFluidConsistencyTypeList : boolean;
begin
  result := (FFluidConsistencyTypeList <> nil) and (FFluidConsistencyTypeList.count > 0);
end;

Procedure TFhirNutritionOrderOralDiet.SetInstruction(value : TFhirString);
begin
  FInstruction.free;
  FInstruction := value;
end;

Function TFhirNutritionOrderOralDiet.GetInstructionST : String;
begin
  if FInstruction = nil then
    result := ''
  else
    result := FInstruction.value;
end;

Procedure TFhirNutritionOrderOralDiet.SetInstructionST(value : String);
begin
  if value <> '' then
  begin
    if FInstruction = nil then
      FInstruction := TFhirString.create;
    FInstruction.value := value
  end
  else if FInstruction <> nil then
    FInstruction.value := '';
end;

function TFhirNutritionOrderOralDiet.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, Ftype_List.sizeInBytes);
  inc(result, FscheduleList.sizeInBytes);
  inc(result, FnutrientList.sizeInBytes);
  inc(result, FtextureList.sizeInBytes);
  inc(result, FfluidConsistencyTypeList.sizeInBytes);
  inc(result, FInstruction.sizeInBytes);
end;

{ TFhirNutritionOrderOralDietListEnumerator }

Constructor TFhirNutritionOrderOralDietListEnumerator.Create(list : TFhirNutritionOrderOralDietList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionOrderOralDietListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionOrderOralDietListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionOrderOralDietListEnumerator.GetCurrent : TFhirNutritionOrderOralDiet;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionOrderOralDietListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirNutritionOrderOralDietList }
procedure TFhirNutritionOrderOralDietList.AddItem(value: TFhirNutritionOrderOralDiet);
begin
  assert(value.ClassName = 'TFhirNutritionOrderOralDiet', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionOrderOralDiet');
  add(value);
end;

function TFhirNutritionOrderOralDietList.Append: TFhirNutritionOrderOralDiet;
begin
  result := TFhirNutritionOrderOralDiet.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderOralDietList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionOrderOralDietList.GetEnumerator : TFhirNutritionOrderOralDietListEnumerator;
begin
  result := TFhirNutritionOrderOralDietListEnumerator.Create(self.link);
end;

function TFhirNutritionOrderOralDietList.Clone: TFhirNutritionOrderOralDietList;
begin
  result := TFhirNutritionOrderOralDietList(inherited Clone);
end;

function TFhirNutritionOrderOralDietList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionOrderOralDietList.GetItemN(index: Integer): TFhirNutritionOrderOralDiet;
begin
  result := TFhirNutritionOrderOralDiet(ObjectByIndex[index]);
end;

function TFhirNutritionOrderOralDietList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionOrderOralDiet;
end;
function TFhirNutritionOrderOralDietList.IndexOf(value: TFhirNutritionOrderOralDiet): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionOrderOralDietList.Insert(index: Integer): TFhirNutritionOrderOralDiet;
begin
  result := TFhirNutritionOrderOralDiet.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderOralDietList.InsertItem(index: Integer; value: TFhirNutritionOrderOralDiet);
begin
  assert(value is TFhirNutritionOrderOralDiet);
  Inherited Insert(index, value);
end;

function TFhirNutritionOrderOralDietList.Item(index: Integer): TFhirNutritionOrderOralDiet;
begin
  result := TFhirNutritionOrderOralDiet(ObjectByIndex[index]);
end;

function TFhirNutritionOrderOralDietList.Link: TFhirNutritionOrderOralDietList;
begin
  result := TFhirNutritionOrderOralDietList(inherited Link);
end;

procedure TFhirNutritionOrderOralDietList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionOrderOralDietList.SetItemByIndex(index: Integer; value: TFhirNutritionOrderOralDiet);
begin
  assert(value is TFhirNutritionOrderOralDiet);
  FhirNutritionOrderOralDiets[index] := value;
end;

procedure TFhirNutritionOrderOralDietList.SetItemN(index: Integer; value: TFhirNutritionOrderOralDiet);
begin
  assert(value is TFhirNutritionOrderOralDiet);
  ObjectByIndex[index] := value;
end;

{ TFhirNutritionOrderOralDietNutrient }

constructor TFhirNutritionOrderOralDietNutrient.Create;
begin
  inherited;
end;

destructor TFhirNutritionOrderOralDietNutrient.Destroy;
begin
  FModifier.free;
  FAmount.free;
  inherited;
end;

procedure TFhirNutritionOrderOralDietNutrient.Assign(oSource : TFslObject);
begin
  inherited;
  modifier := TFhirNutritionOrderOralDietNutrient(oSource).modifier.Clone;
  amount := TFhirNutritionOrderOralDietNutrient(oSource).amount.Clone;
end;

procedure TFhirNutritionOrderOralDietNutrient.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'modifier') Then
     list.add(self.link, 'modifier', FModifier.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
end;

procedure TFhirNutritionOrderOralDietNutrient.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', false, TFhirCodeableConcept, FModifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'amount', 'Quantity', false, TFhirQuantity, FAmount.Link));{2}
end;

function TFhirNutritionOrderOralDietNutrient.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'modifier') then
  begin
    Modifier := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionOrderOralDietNutrient.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirNutritionOrderOralDietNutrient.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'modifier') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'amount') then result := TFhirQuantity.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionOrderOralDietNutrient.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'amount') then result := 'Quantity'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionOrderOralDietNutrient.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'modifier') then ModifierElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionOrderOralDietNutrient.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'modifier') then ModifierElement := new as TFhirCodeableConcept{4}
  else if (propName = 'amount') then AmountElement := new as TFhirQuantity{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionOrderOralDietNutrient.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionOrderOralDietNutrient.fhirType : string;
begin
  result := 'nutrient';
end;

function TFhirNutritionOrderOralDietNutrient.Link : TFhirNutritionOrderOralDietNutrient;
begin
  result := TFhirNutritionOrderOralDietNutrient(inherited Link);
end;

function TFhirNutritionOrderOralDietNutrient.Clone : TFhirNutritionOrderOralDietNutrient;
begin
  result := TFhirNutritionOrderOralDietNutrient(inherited Clone);
end;

function TFhirNutritionOrderOralDietNutrient.equals(other : TObject) : boolean;
var
  o : TFhirNutritionOrderOralDietNutrient;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionOrderOralDietNutrient)) then
    result := false
  else
  begin
    o := TFhirNutritionOrderOralDietNutrient(other);
    result := compareDeep(modifierElement, o.modifierElement, true) and compareDeep(amountElement, o.amountElement, true);
  end;
end;

function TFhirNutritionOrderOralDietNutrient.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FModifier) and isEmptyProp(FAmount);
end;

procedure TFhirNutritionOrderOralDietNutrient.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('modifier');
  fields.add('amount');
end;

{ TFhirNutritionOrderOralDietNutrient }

Procedure TFhirNutritionOrderOralDietNutrient.SetModifier(value : TFhirCodeableConcept);
begin
  FModifier.free;
  FModifier := value;
end;

Procedure TFhirNutritionOrderOralDietNutrient.SetAmount(value : TFhirQuantity);
begin
  FAmount.free;
  FAmount := value;
end;

function TFhirNutritionOrderOralDietNutrient.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FModifier.sizeInBytes);
  inc(result, FAmount.sizeInBytes);
end;

{ TFhirNutritionOrderOralDietNutrientListEnumerator }

Constructor TFhirNutritionOrderOralDietNutrientListEnumerator.Create(list : TFhirNutritionOrderOralDietNutrientList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionOrderOralDietNutrientListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionOrderOralDietNutrientListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionOrderOralDietNutrientListEnumerator.GetCurrent : TFhirNutritionOrderOralDietNutrient;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionOrderOralDietNutrientListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirNutritionOrderOralDietNutrientList }
procedure TFhirNutritionOrderOralDietNutrientList.AddItem(value: TFhirNutritionOrderOralDietNutrient);
begin
  assert(value.ClassName = 'TFhirNutritionOrderOralDietNutrient', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionOrderOralDietNutrient');
  add(value);
end;

function TFhirNutritionOrderOralDietNutrientList.Append: TFhirNutritionOrderOralDietNutrient;
begin
  result := TFhirNutritionOrderOralDietNutrient.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderOralDietNutrientList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionOrderOralDietNutrientList.GetEnumerator : TFhirNutritionOrderOralDietNutrientListEnumerator;
begin
  result := TFhirNutritionOrderOralDietNutrientListEnumerator.Create(self.link);
end;

function TFhirNutritionOrderOralDietNutrientList.Clone: TFhirNutritionOrderOralDietNutrientList;
begin
  result := TFhirNutritionOrderOralDietNutrientList(inherited Clone);
end;

function TFhirNutritionOrderOralDietNutrientList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionOrderOralDietNutrientList.GetItemN(index: Integer): TFhirNutritionOrderOralDietNutrient;
begin
  result := TFhirNutritionOrderOralDietNutrient(ObjectByIndex[index]);
end;

function TFhirNutritionOrderOralDietNutrientList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionOrderOralDietNutrient;
end;
function TFhirNutritionOrderOralDietNutrientList.IndexOf(value: TFhirNutritionOrderOralDietNutrient): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionOrderOralDietNutrientList.Insert(index: Integer): TFhirNutritionOrderOralDietNutrient;
begin
  result := TFhirNutritionOrderOralDietNutrient.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderOralDietNutrientList.InsertItem(index: Integer; value: TFhirNutritionOrderOralDietNutrient);
begin
  assert(value is TFhirNutritionOrderOralDietNutrient);
  Inherited Insert(index, value);
end;

function TFhirNutritionOrderOralDietNutrientList.Item(index: Integer): TFhirNutritionOrderOralDietNutrient;
begin
  result := TFhirNutritionOrderOralDietNutrient(ObjectByIndex[index]);
end;

function TFhirNutritionOrderOralDietNutrientList.Link: TFhirNutritionOrderOralDietNutrientList;
begin
  result := TFhirNutritionOrderOralDietNutrientList(inherited Link);
end;

procedure TFhirNutritionOrderOralDietNutrientList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionOrderOralDietNutrientList.SetItemByIndex(index: Integer; value: TFhirNutritionOrderOralDietNutrient);
begin
  assert(value is TFhirNutritionOrderOralDietNutrient);
  FhirNutritionOrderOralDietNutrients[index] := value;
end;

procedure TFhirNutritionOrderOralDietNutrientList.SetItemN(index: Integer; value: TFhirNutritionOrderOralDietNutrient);
begin
  assert(value is TFhirNutritionOrderOralDietNutrient);
  ObjectByIndex[index] := value;
end;

{ TFhirNutritionOrderOralDietTexture }

constructor TFhirNutritionOrderOralDietTexture.Create;
begin
  inherited;
end;

destructor TFhirNutritionOrderOralDietTexture.Destroy;
begin
  FModifier.free;
  FFoodType.free;
  inherited;
end;

procedure TFhirNutritionOrderOralDietTexture.Assign(oSource : TFslObject);
begin
  inherited;
  modifier := TFhirNutritionOrderOralDietTexture(oSource).modifier.Clone;
  foodType := TFhirNutritionOrderOralDietTexture(oSource).foodType.Clone;
end;

procedure TFhirNutritionOrderOralDietTexture.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'modifier') Then
     list.add(self.link, 'modifier', FModifier.Link);
  if (child_name = 'foodType') Then
     list.add(self.link, 'foodType', FFoodType.Link);
end;

procedure TFhirNutritionOrderOralDietTexture.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', false, TFhirCodeableConcept, FModifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'foodType', 'CodeableConcept', false, TFhirCodeableConcept, FFoodType.Link));{2}
end;

function TFhirNutritionOrderOralDietTexture.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'modifier') then
  begin
    Modifier := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'foodType') then
  begin
    FoodType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionOrderOralDietTexture.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirNutritionOrderOralDietTexture.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'modifier') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'foodType') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionOrderOralDietTexture.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'foodType') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionOrderOralDietTexture.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'modifier') then ModifierElement := nil
  else if (propName = 'foodType') then FoodTypeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionOrderOralDietTexture.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'modifier') then ModifierElement := new as TFhirCodeableConcept{4}
  else if (propName = 'foodType') then FoodTypeElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionOrderOralDietTexture.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionOrderOralDietTexture.fhirType : string;
begin
  result := 'texture';
end;

function TFhirNutritionOrderOralDietTexture.Link : TFhirNutritionOrderOralDietTexture;
begin
  result := TFhirNutritionOrderOralDietTexture(inherited Link);
end;

function TFhirNutritionOrderOralDietTexture.Clone : TFhirNutritionOrderOralDietTexture;
begin
  result := TFhirNutritionOrderOralDietTexture(inherited Clone);
end;

function TFhirNutritionOrderOralDietTexture.equals(other : TObject) : boolean;
var
  o : TFhirNutritionOrderOralDietTexture;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionOrderOralDietTexture)) then
    result := false
  else
  begin
    o := TFhirNutritionOrderOralDietTexture(other);
    result := compareDeep(modifierElement, o.modifierElement, true) and compareDeep(foodTypeElement, o.foodTypeElement, true);
  end;
end;

function TFhirNutritionOrderOralDietTexture.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FModifier) and isEmptyProp(FFoodType);
end;

procedure TFhirNutritionOrderOralDietTexture.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('modifier');
  fields.add('foodType');
end;

{ TFhirNutritionOrderOralDietTexture }

Procedure TFhirNutritionOrderOralDietTexture.SetModifier(value : TFhirCodeableConcept);
begin
  FModifier.free;
  FModifier := value;
end;

Procedure TFhirNutritionOrderOralDietTexture.SetFoodType(value : TFhirCodeableConcept);
begin
  FFoodType.free;
  FFoodType := value;
end;

function TFhirNutritionOrderOralDietTexture.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FModifier.sizeInBytes);
  inc(result, FFoodType.sizeInBytes);
end;

{ TFhirNutritionOrderOralDietTextureListEnumerator }

Constructor TFhirNutritionOrderOralDietTextureListEnumerator.Create(list : TFhirNutritionOrderOralDietTextureList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionOrderOralDietTextureListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionOrderOralDietTextureListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionOrderOralDietTextureListEnumerator.GetCurrent : TFhirNutritionOrderOralDietTexture;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionOrderOralDietTextureListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirNutritionOrderOralDietTextureList }
procedure TFhirNutritionOrderOralDietTextureList.AddItem(value: TFhirNutritionOrderOralDietTexture);
begin
  assert(value.ClassName = 'TFhirNutritionOrderOralDietTexture', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionOrderOralDietTexture');
  add(value);
end;

function TFhirNutritionOrderOralDietTextureList.Append: TFhirNutritionOrderOralDietTexture;
begin
  result := TFhirNutritionOrderOralDietTexture.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderOralDietTextureList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionOrderOralDietTextureList.GetEnumerator : TFhirNutritionOrderOralDietTextureListEnumerator;
begin
  result := TFhirNutritionOrderOralDietTextureListEnumerator.Create(self.link);
end;

function TFhirNutritionOrderOralDietTextureList.Clone: TFhirNutritionOrderOralDietTextureList;
begin
  result := TFhirNutritionOrderOralDietTextureList(inherited Clone);
end;

function TFhirNutritionOrderOralDietTextureList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionOrderOralDietTextureList.GetItemN(index: Integer): TFhirNutritionOrderOralDietTexture;
begin
  result := TFhirNutritionOrderOralDietTexture(ObjectByIndex[index]);
end;

function TFhirNutritionOrderOralDietTextureList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionOrderOralDietTexture;
end;
function TFhirNutritionOrderOralDietTextureList.IndexOf(value: TFhirNutritionOrderOralDietTexture): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionOrderOralDietTextureList.Insert(index: Integer): TFhirNutritionOrderOralDietTexture;
begin
  result := TFhirNutritionOrderOralDietTexture.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderOralDietTextureList.InsertItem(index: Integer; value: TFhirNutritionOrderOralDietTexture);
begin
  assert(value is TFhirNutritionOrderOralDietTexture);
  Inherited Insert(index, value);
end;

function TFhirNutritionOrderOralDietTextureList.Item(index: Integer): TFhirNutritionOrderOralDietTexture;
begin
  result := TFhirNutritionOrderOralDietTexture(ObjectByIndex[index]);
end;

function TFhirNutritionOrderOralDietTextureList.Link: TFhirNutritionOrderOralDietTextureList;
begin
  result := TFhirNutritionOrderOralDietTextureList(inherited Link);
end;

procedure TFhirNutritionOrderOralDietTextureList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionOrderOralDietTextureList.SetItemByIndex(index: Integer; value: TFhirNutritionOrderOralDietTexture);
begin
  assert(value is TFhirNutritionOrderOralDietTexture);
  FhirNutritionOrderOralDietTextures[index] := value;
end;

procedure TFhirNutritionOrderOralDietTextureList.SetItemN(index: Integer; value: TFhirNutritionOrderOralDietTexture);
begin
  assert(value is TFhirNutritionOrderOralDietTexture);
  ObjectByIndex[index] := value;
end;

{ TFhirNutritionOrderSupplement }

constructor TFhirNutritionOrderSupplement.Create;
begin
  inherited;
end;

destructor TFhirNutritionOrderSupplement.Destroy;
begin
  FType_.free;
  FProductName.free;
  FScheduleList.Free;
  FQuantity.free;
  FInstruction.free;
  inherited;
end;

procedure TFhirNutritionOrderSupplement.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirNutritionOrderSupplement(oSource).type_.Clone;
  productNameElement := TFhirNutritionOrderSupplement(oSource).productNameElement.Clone;
  if (TFhirNutritionOrderSupplement(oSource).FScheduleList = nil) then
  begin
    FScheduleList.free;
    FScheduleList := nil;
  end
  else
  begin
    if FScheduleList = nil then
      FScheduleList := TFhirTimingList.Create;
    FScheduleList.Assign(TFhirNutritionOrderSupplement(oSource).FScheduleList);
  end;
  quantity := TFhirNutritionOrderSupplement(oSource).quantity.Clone;
  instructionElement := TFhirNutritionOrderSupplement(oSource).instructionElement.Clone;
end;

procedure TFhirNutritionOrderSupplement.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'productName') Then
     list.add(self.link, 'productName', FProductName.Link);
  if (child_name = 'schedule') Then
    list.addAll(self, 'schedule', FScheduleList);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'instruction') Then
     list.add(self.link, 'instruction', FInstruction.Link);
end;

procedure TFhirNutritionOrderSupplement.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'productName', 'string', false, TFhirString, FProductName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'schedule', 'Timing', true, TFhirTiming, FScheduleList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'instruction', 'string', false, TFhirString, FInstruction.Link));{2}
end;

function TFhirNutritionOrderSupplement.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'productName') then
  begin
    ProductNameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'schedule') then
  begin
    ScheduleList.add(propValue as TFhirTiming){2a};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'instruction') then
  begin
    InstructionElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionOrderSupplement.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'schedule') then ScheduleList.insertItem(index, propValue as TFhirTiming){2a}
  else inherited;
end;

function TFhirNutritionOrderSupplement.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'productName') then result := TFhirString.create() {5b}
  else if (propName = 'schedule') then result := ScheduleList.new(){2}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'instruction') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionOrderSupplement.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'productName') then result := 'string'
  else if (propName = 'schedule') then result := 'Timing'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'instruction') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionOrderSupplement.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'productName') then ProductNameElement := nil
  else if (propName = 'schedule') then deletePropertyValue('schedule', ScheduleList, value) {2}
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'instruction') then InstructionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionOrderSupplement.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'productName') then ProductNameElement := asString(new){5b}
  else if (propName = 'schedule') then replacePropertyValue('schedule', ScheduleList, existing, new) {2}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'instruction') then InstructionElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionOrderSupplement.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'schedule') then ScheduleList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionOrderSupplement.fhirType : string;
begin
  result := 'supplement';
end;

function TFhirNutritionOrderSupplement.Link : TFhirNutritionOrderSupplement;
begin
  result := TFhirNutritionOrderSupplement(inherited Link);
end;

function TFhirNutritionOrderSupplement.Clone : TFhirNutritionOrderSupplement;
begin
  result := TFhirNutritionOrderSupplement(inherited Clone);
end;

function TFhirNutritionOrderSupplement.equals(other : TObject) : boolean;
var
  o : TFhirNutritionOrderSupplement;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionOrderSupplement)) then
    result := false
  else
  begin
    o := TFhirNutritionOrderSupplement(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(productNameElement, o.productNameElement, true) and
      compareDeep(scheduleList, o.scheduleList, true) and compareDeep(quantityElement, o.quantityElement, true) and
      compareDeep(instructionElement, o.instructionElement, true);
  end;
end;

function TFhirNutritionOrderSupplement.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FProductName) and isEmptyProp(FscheduleList) and isEmptyProp(FQuantity) and isEmptyProp(FInstruction);
end;

procedure TFhirNutritionOrderSupplement.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('productName');
  fields.add('schedule');
  fields.add('quantity');
  fields.add('instruction');
end;

{ TFhirNutritionOrderSupplement }

Procedure TFhirNutritionOrderSupplement.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirNutritionOrderSupplement.SetProductName(value : TFhirString);
begin
  FProductName.free;
  FProductName := value;
end;

Function TFhirNutritionOrderSupplement.GetProductNameST : String;
begin
  if FProductName = nil then
    result := ''
  else
    result := FProductName.value;
end;

Procedure TFhirNutritionOrderSupplement.SetProductNameST(value : String);
begin
  if value <> '' then
  begin
    if FProductName = nil then
      FProductName := TFhirString.create;
    FProductName.value := value
  end
  else if FProductName <> nil then
    FProductName.value := '';
end;

Function TFhirNutritionOrderSupplement.GetScheduleList : TFhirTimingList;
begin
  if FScheduleList = nil then
    FScheduleList := TFhirTimingList.Create;
  result := FScheduleList;
end;

Function TFhirNutritionOrderSupplement.GetHasScheduleList : boolean;
begin
  result := (FScheduleList <> nil) and (FScheduleList.count > 0);
end;

Procedure TFhirNutritionOrderSupplement.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirNutritionOrderSupplement.SetInstruction(value : TFhirString);
begin
  FInstruction.free;
  FInstruction := value;
end;

Function TFhirNutritionOrderSupplement.GetInstructionST : String;
begin
  if FInstruction = nil then
    result := ''
  else
    result := FInstruction.value;
end;

Procedure TFhirNutritionOrderSupplement.SetInstructionST(value : String);
begin
  if value <> '' then
  begin
    if FInstruction = nil then
      FInstruction := TFhirString.create;
    FInstruction.value := value
  end
  else if FInstruction <> nil then
    FInstruction.value := '';
end;

function TFhirNutritionOrderSupplement.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FProductName.sizeInBytes);
  inc(result, FscheduleList.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FInstruction.sizeInBytes);
end;

{ TFhirNutritionOrderSupplementListEnumerator }

Constructor TFhirNutritionOrderSupplementListEnumerator.Create(list : TFhirNutritionOrderSupplementList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionOrderSupplementListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionOrderSupplementListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionOrderSupplementListEnumerator.GetCurrent : TFhirNutritionOrderSupplement;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionOrderSupplementListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirNutritionOrderSupplementList }
procedure TFhirNutritionOrderSupplementList.AddItem(value: TFhirNutritionOrderSupplement);
begin
  assert(value.ClassName = 'TFhirNutritionOrderSupplement', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionOrderSupplement');
  add(value);
end;

function TFhirNutritionOrderSupplementList.Append: TFhirNutritionOrderSupplement;
begin
  result := TFhirNutritionOrderSupplement.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderSupplementList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionOrderSupplementList.GetEnumerator : TFhirNutritionOrderSupplementListEnumerator;
begin
  result := TFhirNutritionOrderSupplementListEnumerator.Create(self.link);
end;

function TFhirNutritionOrderSupplementList.Clone: TFhirNutritionOrderSupplementList;
begin
  result := TFhirNutritionOrderSupplementList(inherited Clone);
end;

function TFhirNutritionOrderSupplementList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionOrderSupplementList.GetItemN(index: Integer): TFhirNutritionOrderSupplement;
begin
  result := TFhirNutritionOrderSupplement(ObjectByIndex[index]);
end;

function TFhirNutritionOrderSupplementList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionOrderSupplement;
end;
function TFhirNutritionOrderSupplementList.IndexOf(value: TFhirNutritionOrderSupplement): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionOrderSupplementList.Insert(index: Integer): TFhirNutritionOrderSupplement;
begin
  result := TFhirNutritionOrderSupplement.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderSupplementList.InsertItem(index: Integer; value: TFhirNutritionOrderSupplement);
begin
  assert(value is TFhirNutritionOrderSupplement);
  Inherited Insert(index, value);
end;

function TFhirNutritionOrderSupplementList.Item(index: Integer): TFhirNutritionOrderSupplement;
begin
  result := TFhirNutritionOrderSupplement(ObjectByIndex[index]);
end;

function TFhirNutritionOrderSupplementList.Link: TFhirNutritionOrderSupplementList;
begin
  result := TFhirNutritionOrderSupplementList(inherited Link);
end;

procedure TFhirNutritionOrderSupplementList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionOrderSupplementList.SetItemByIndex(index: Integer; value: TFhirNutritionOrderSupplement);
begin
  assert(value is TFhirNutritionOrderSupplement);
  FhirNutritionOrderSupplements[index] := value;
end;

procedure TFhirNutritionOrderSupplementList.SetItemN(index: Integer; value: TFhirNutritionOrderSupplement);
begin
  assert(value is TFhirNutritionOrderSupplement);
  ObjectByIndex[index] := value;
end;

{ TFhirNutritionOrderEnteralFormula }

constructor TFhirNutritionOrderEnteralFormula.Create;
begin
  inherited;
end;

destructor TFhirNutritionOrderEnteralFormula.Destroy;
begin
  FBaseFormulaType.free;
  FBaseFormulaProductName.free;
  FAdditiveType.free;
  FAdditiveProductName.free;
  FCaloricDensity.free;
  FRouteofAdministration.free;
  FAdministrationList.Free;
  FMaxVolumeToDeliver.free;
  FAdministrationInstruction.free;
  inherited;
end;

procedure TFhirNutritionOrderEnteralFormula.Assign(oSource : TFslObject);
begin
  inherited;
  baseFormulaType := TFhirNutritionOrderEnteralFormula(oSource).baseFormulaType.Clone;
  baseFormulaProductNameElement := TFhirNutritionOrderEnteralFormula(oSource).baseFormulaProductNameElement.Clone;
  additiveType := TFhirNutritionOrderEnteralFormula(oSource).additiveType.Clone;
  additiveProductNameElement := TFhirNutritionOrderEnteralFormula(oSource).additiveProductNameElement.Clone;
  caloricDensity := TFhirNutritionOrderEnteralFormula(oSource).caloricDensity.Clone;
  routeofAdministration := TFhirNutritionOrderEnteralFormula(oSource).routeofAdministration.Clone;
  if (TFhirNutritionOrderEnteralFormula(oSource).FAdministrationList = nil) then
  begin
    FAdministrationList.free;
    FAdministrationList := nil;
  end
  else
  begin
    if FAdministrationList = nil then
      FAdministrationList := TFhirNutritionOrderEnteralFormulaAdministrationList.Create;
    FAdministrationList.Assign(TFhirNutritionOrderEnteralFormula(oSource).FAdministrationList);
  end;
  maxVolumeToDeliver := TFhirNutritionOrderEnteralFormula(oSource).maxVolumeToDeliver.Clone;
  administrationInstructionElement := TFhirNutritionOrderEnteralFormula(oSource).administrationInstructionElement.Clone;
end;

procedure TFhirNutritionOrderEnteralFormula.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'baseFormulaType') Then
     list.add(self.link, 'baseFormulaType', FBaseFormulaType.Link);
  if (child_name = 'baseFormulaProductName') Then
     list.add(self.link, 'baseFormulaProductName', FBaseFormulaProductName.Link);
  if (child_name = 'additiveType') Then
     list.add(self.link, 'additiveType', FAdditiveType.Link);
  if (child_name = 'additiveProductName') Then
     list.add(self.link, 'additiveProductName', FAdditiveProductName.Link);
  if (child_name = 'caloricDensity') Then
     list.add(self.link, 'caloricDensity', FCaloricDensity.Link);
  if (child_name = 'routeofAdministration') Then
     list.add(self.link, 'routeofAdministration', FRouteofAdministration.Link);
  if (child_name = 'administration') Then
    list.addAll(self, 'administration', FAdministrationList);
  if (child_name = 'maxVolumeToDeliver') Then
     list.add(self.link, 'maxVolumeToDeliver', FMaxVolumeToDeliver.Link);
  if (child_name = 'administrationInstruction') Then
     list.add(self.link, 'administrationInstruction', FAdministrationInstruction.Link);
end;

procedure TFhirNutritionOrderEnteralFormula.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'baseFormulaType', 'CodeableConcept', false, TFhirCodeableConcept, FBaseFormulaType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'baseFormulaProductName', 'string', false, TFhirString, FBaseFormulaProductName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'additiveType', 'CodeableConcept', false, TFhirCodeableConcept, FAdditiveType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'additiveProductName', 'string', false, TFhirString, FAdditiveProductName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'caloricDensity', 'Quantity', false, TFhirQuantity, FCaloricDensity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'routeofAdministration', 'CodeableConcept', false, TFhirCodeableConcept, FRouteofAdministration.Link));{2}
  oList.add(TFHIRProperty.create(self, 'administration', '', true, TFhirNutritionOrderEnteralFormulaAdministration, FAdministrationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'maxVolumeToDeliver', 'Quantity', false, TFhirQuantity, FMaxVolumeToDeliver.Link));{2}
  oList.add(TFHIRProperty.create(self, 'administrationInstruction', 'string', false, TFhirString, FAdministrationInstruction.Link));{2}
end;

function TFhirNutritionOrderEnteralFormula.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'baseFormulaType') then
  begin
    BaseFormulaType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'baseFormulaProductName') then
  begin
    BaseFormulaProductNameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'additiveType') then
  begin
    AdditiveType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'additiveProductName') then
  begin
    AdditiveProductNameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'caloricDensity') then
  begin
    CaloricDensity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'routeofAdministration') then
  begin
    RouteofAdministration := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'administration') then
  begin
    AdministrationList.add(propValue as TFhirNutritionOrderEnteralFormulaAdministration){2a};
    result := propValue;
  end
  else if (propName = 'maxVolumeToDeliver') then
  begin
    MaxVolumeToDeliver := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'administrationInstruction') then
  begin
    AdministrationInstructionElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionOrderEnteralFormula.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'administration') then AdministrationList.insertItem(index, propValue as TFhirNutritionOrderEnteralFormulaAdministration){2a}
  else inherited;
end;

function TFhirNutritionOrderEnteralFormula.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'baseFormulaType') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'baseFormulaProductName') then result := TFhirString.create() {5b}
  else if (propName = 'additiveType') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'additiveProductName') then result := TFhirString.create() {5b}
  else if (propName = 'caloricDensity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'routeofAdministration') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'administration') then result := AdministrationList.new(){2}
  else if (propName = 'maxVolumeToDeliver') then result := TFhirQuantity.create(){4b}
  else if (propName = 'administrationInstruction') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionOrderEnteralFormula.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'baseFormulaType') then result := 'CodeableConcept'
  else if (propName = 'baseFormulaProductName') then result := 'string'
  else if (propName = 'additiveType') then result := 'CodeableConcept'
  else if (propName = 'additiveProductName') then result := 'string'
  else if (propName = 'caloricDensity') then result := 'Quantity'
  else if (propName = 'routeofAdministration') then result := 'CodeableConcept'
  else if (propName = 'administration') then result := ''
  else if (propName = 'maxVolumeToDeliver') then result := 'Quantity'
  else if (propName = 'administrationInstruction') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionOrderEnteralFormula.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'baseFormulaType') then BaseFormulaTypeElement := nil
  else if (propName = 'baseFormulaProductName') then BaseFormulaProductNameElement := nil
  else if (propName = 'additiveType') then AdditiveTypeElement := nil
  else if (propName = 'additiveProductName') then AdditiveProductNameElement := nil
  else if (propName = 'caloricDensity') then CaloricDensityElement := nil
  else if (propName = 'routeofAdministration') then RouteofAdministrationElement := nil
  else if (propName = 'administration') then deletePropertyValue('administration', AdministrationList, value) {2}
  else if (propName = 'maxVolumeToDeliver') then MaxVolumeToDeliverElement := nil
  else if (propName = 'administrationInstruction') then AdministrationInstructionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionOrderEnteralFormula.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'baseFormulaType') then BaseFormulaTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'baseFormulaProductName') then BaseFormulaProductNameElement := asString(new){5b}
  else if (propName = 'additiveType') then AdditiveTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'additiveProductName') then AdditiveProductNameElement := asString(new){5b}
  else if (propName = 'caloricDensity') then CaloricDensityElement := new as TFhirQuantity{4}
  else if (propName = 'routeofAdministration') then RouteofAdministrationElement := new as TFhirCodeableConcept{4}
  else if (propName = 'administration') then replacePropertyValue('administration', AdministrationList, existing, new) {2}
  else if (propName = 'maxVolumeToDeliver') then MaxVolumeToDeliverElement := new as TFhirQuantity{4}
  else if (propName = 'administrationInstruction') then AdministrationInstructionElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionOrderEnteralFormula.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'administration') then AdministrationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionOrderEnteralFormula.fhirType : string;
begin
  result := 'enteralFormula';
end;

function TFhirNutritionOrderEnteralFormula.Link : TFhirNutritionOrderEnteralFormula;
begin
  result := TFhirNutritionOrderEnteralFormula(inherited Link);
end;

function TFhirNutritionOrderEnteralFormula.Clone : TFhirNutritionOrderEnteralFormula;
begin
  result := TFhirNutritionOrderEnteralFormula(inherited Clone);
end;

function TFhirNutritionOrderEnteralFormula.equals(other : TObject) : boolean;
var
  o : TFhirNutritionOrderEnteralFormula;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionOrderEnteralFormula)) then
    result := false
  else
  begin
    o := TFhirNutritionOrderEnteralFormula(other);
    result := compareDeep(baseFormulaTypeElement, o.baseFormulaTypeElement, true) and
      compareDeep(baseFormulaProductNameElement, o.baseFormulaProductNameElement, true) and
      compareDeep(additiveTypeElement, o.additiveTypeElement, true) and compareDeep(additiveProductNameElement, o.additiveProductNameElement, true) and
      compareDeep(caloricDensityElement, o.caloricDensityElement, true) and compareDeep(routeofAdministrationElement, o.routeofAdministrationElement, true) and
      compareDeep(administrationList, o.administrationList, true) and compareDeep(maxVolumeToDeliverElement, o.maxVolumeToDeliverElement, true) and
      compareDeep(administrationInstructionElement, o.administrationInstructionElement, true);
  end;
end;

function TFhirNutritionOrderEnteralFormula.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FBaseFormulaType) and isEmptyProp(FBaseFormulaProductName) and isEmptyProp(FAdditiveType) and isEmptyProp(FAdditiveProductName) and isEmptyProp(FCaloricDensity) and isEmptyProp(FRouteofAdministration) and isEmptyProp(FadministrationList) and isEmptyProp(FMaxVolumeToDeliver) and isEmptyProp(FAdministrationInstruction);
end;

procedure TFhirNutritionOrderEnteralFormula.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('baseFormulaType');
  fields.add('baseFormulaProductName');
  fields.add('additiveType');
  fields.add('additiveProductName');
  fields.add('caloricDensity');
  fields.add('routeofAdministration');
  fields.add('administration');
  fields.add('maxVolumeToDeliver');
  fields.add('administrationInstruction');
end;

{ TFhirNutritionOrderEnteralFormula }

Procedure TFhirNutritionOrderEnteralFormula.SetBaseFormulaType(value : TFhirCodeableConcept);
begin
  FBaseFormulaType.free;
  FBaseFormulaType := value;
end;

Procedure TFhirNutritionOrderEnteralFormula.SetBaseFormulaProductName(value : TFhirString);
begin
  FBaseFormulaProductName.free;
  FBaseFormulaProductName := value;
end;

Function TFhirNutritionOrderEnteralFormula.GetBaseFormulaProductNameST : String;
begin
  if FBaseFormulaProductName = nil then
    result := ''
  else
    result := FBaseFormulaProductName.value;
end;

Procedure TFhirNutritionOrderEnteralFormula.SetBaseFormulaProductNameST(value : String);
begin
  if value <> '' then
  begin
    if FBaseFormulaProductName = nil then
      FBaseFormulaProductName := TFhirString.create;
    FBaseFormulaProductName.value := value
  end
  else if FBaseFormulaProductName <> nil then
    FBaseFormulaProductName.value := '';
end;

Procedure TFhirNutritionOrderEnteralFormula.SetAdditiveType(value : TFhirCodeableConcept);
begin
  FAdditiveType.free;
  FAdditiveType := value;
end;

Procedure TFhirNutritionOrderEnteralFormula.SetAdditiveProductName(value : TFhirString);
begin
  FAdditiveProductName.free;
  FAdditiveProductName := value;
end;

Function TFhirNutritionOrderEnteralFormula.GetAdditiveProductNameST : String;
begin
  if FAdditiveProductName = nil then
    result := ''
  else
    result := FAdditiveProductName.value;
end;

Procedure TFhirNutritionOrderEnteralFormula.SetAdditiveProductNameST(value : String);
begin
  if value <> '' then
  begin
    if FAdditiveProductName = nil then
      FAdditiveProductName := TFhirString.create;
    FAdditiveProductName.value := value
  end
  else if FAdditiveProductName <> nil then
    FAdditiveProductName.value := '';
end;

Procedure TFhirNutritionOrderEnteralFormula.SetCaloricDensity(value : TFhirQuantity);
begin
  FCaloricDensity.free;
  FCaloricDensity := value;
end;

Procedure TFhirNutritionOrderEnteralFormula.SetRouteofAdministration(value : TFhirCodeableConcept);
begin
  FRouteofAdministration.free;
  FRouteofAdministration := value;
end;

Function TFhirNutritionOrderEnteralFormula.GetAdministrationList : TFhirNutritionOrderEnteralFormulaAdministrationList;
begin
  if FAdministrationList = nil then
    FAdministrationList := TFhirNutritionOrderEnteralFormulaAdministrationList.Create;
  result := FAdministrationList;
end;

Function TFhirNutritionOrderEnteralFormula.GetHasAdministrationList : boolean;
begin
  result := (FAdministrationList <> nil) and (FAdministrationList.count > 0);
end;

Procedure TFhirNutritionOrderEnteralFormula.SetMaxVolumeToDeliver(value : TFhirQuantity);
begin
  FMaxVolumeToDeliver.free;
  FMaxVolumeToDeliver := value;
end;

Procedure TFhirNutritionOrderEnteralFormula.SetAdministrationInstruction(value : TFhirString);
begin
  FAdministrationInstruction.free;
  FAdministrationInstruction := value;
end;

Function TFhirNutritionOrderEnteralFormula.GetAdministrationInstructionST : String;
begin
  if FAdministrationInstruction = nil then
    result := ''
  else
    result := FAdministrationInstruction.value;
end;

Procedure TFhirNutritionOrderEnteralFormula.SetAdministrationInstructionST(value : String);
begin
  if value <> '' then
  begin
    if FAdministrationInstruction = nil then
      FAdministrationInstruction := TFhirString.create;
    FAdministrationInstruction.value := value
  end
  else if FAdministrationInstruction <> nil then
    FAdministrationInstruction.value := '';
end;

function TFhirNutritionOrderEnteralFormula.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FBaseFormulaType.sizeInBytes);
  inc(result, FBaseFormulaProductName.sizeInBytes);
  inc(result, FAdditiveType.sizeInBytes);
  inc(result, FAdditiveProductName.sizeInBytes);
  inc(result, FCaloricDensity.sizeInBytes);
  inc(result, FRouteofAdministration.sizeInBytes);
  inc(result, FadministrationList.sizeInBytes);
  inc(result, FMaxVolumeToDeliver.sizeInBytes);
  inc(result, FAdministrationInstruction.sizeInBytes);
end;

{ TFhirNutritionOrderEnteralFormulaListEnumerator }

Constructor TFhirNutritionOrderEnteralFormulaListEnumerator.Create(list : TFhirNutritionOrderEnteralFormulaList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionOrderEnteralFormulaListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionOrderEnteralFormulaListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionOrderEnteralFormulaListEnumerator.GetCurrent : TFhirNutritionOrderEnteralFormula;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionOrderEnteralFormulaListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirNutritionOrderEnteralFormulaList }
procedure TFhirNutritionOrderEnteralFormulaList.AddItem(value: TFhirNutritionOrderEnteralFormula);
begin
  assert(value.ClassName = 'TFhirNutritionOrderEnteralFormula', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionOrderEnteralFormula');
  add(value);
end;

function TFhirNutritionOrderEnteralFormulaList.Append: TFhirNutritionOrderEnteralFormula;
begin
  result := TFhirNutritionOrderEnteralFormula.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderEnteralFormulaList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionOrderEnteralFormulaList.GetEnumerator : TFhirNutritionOrderEnteralFormulaListEnumerator;
begin
  result := TFhirNutritionOrderEnteralFormulaListEnumerator.Create(self.link);
end;

function TFhirNutritionOrderEnteralFormulaList.Clone: TFhirNutritionOrderEnteralFormulaList;
begin
  result := TFhirNutritionOrderEnteralFormulaList(inherited Clone);
end;

function TFhirNutritionOrderEnteralFormulaList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionOrderEnteralFormulaList.GetItemN(index: Integer): TFhirNutritionOrderEnteralFormula;
begin
  result := TFhirNutritionOrderEnteralFormula(ObjectByIndex[index]);
end;

function TFhirNutritionOrderEnteralFormulaList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionOrderEnteralFormula;
end;
function TFhirNutritionOrderEnteralFormulaList.IndexOf(value: TFhirNutritionOrderEnteralFormula): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionOrderEnteralFormulaList.Insert(index: Integer): TFhirNutritionOrderEnteralFormula;
begin
  result := TFhirNutritionOrderEnteralFormula.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderEnteralFormulaList.InsertItem(index: Integer; value: TFhirNutritionOrderEnteralFormula);
begin
  assert(value is TFhirNutritionOrderEnteralFormula);
  Inherited Insert(index, value);
end;

function TFhirNutritionOrderEnteralFormulaList.Item(index: Integer): TFhirNutritionOrderEnteralFormula;
begin
  result := TFhirNutritionOrderEnteralFormula(ObjectByIndex[index]);
end;

function TFhirNutritionOrderEnteralFormulaList.Link: TFhirNutritionOrderEnteralFormulaList;
begin
  result := TFhirNutritionOrderEnteralFormulaList(inherited Link);
end;

procedure TFhirNutritionOrderEnteralFormulaList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionOrderEnteralFormulaList.SetItemByIndex(index: Integer; value: TFhirNutritionOrderEnteralFormula);
begin
  assert(value is TFhirNutritionOrderEnteralFormula);
  FhirNutritionOrderEnteralFormulas[index] := value;
end;

procedure TFhirNutritionOrderEnteralFormulaList.SetItemN(index: Integer; value: TFhirNutritionOrderEnteralFormula);
begin
  assert(value is TFhirNutritionOrderEnteralFormula);
  ObjectByIndex[index] := value;
end;

{ TFhirNutritionOrderEnteralFormulaAdministration }

constructor TFhirNutritionOrderEnteralFormulaAdministration.Create;
begin
  inherited;
end;

destructor TFhirNutritionOrderEnteralFormulaAdministration.Destroy;
begin
  FSchedule.free;
  FQuantity.free;
  FRate.free;
  inherited;
end;

procedure TFhirNutritionOrderEnteralFormulaAdministration.Assign(oSource : TFslObject);
begin
  inherited;
  schedule := TFhirNutritionOrderEnteralFormulaAdministration(oSource).schedule.Clone;
  quantity := TFhirNutritionOrderEnteralFormulaAdministration(oSource).quantity.Clone;
  rate := TFhirNutritionOrderEnteralFormulaAdministration(oSource).rate.Clone;
end;

procedure TFhirNutritionOrderEnteralFormulaAdministration.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'schedule') Then
     list.add(self.link, 'schedule', FSchedule.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'rate[x]') or (child_name = 'rate') Then
     list.add(self.link, 'rate[x]', FRate.Link);
end;

procedure TFhirNutritionOrderEnteralFormulaAdministration.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'schedule', 'Timing', false, TFhirTiming, FSchedule.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'rate[x]', 'Quantity|Ratio', false, TFhirType, FRate.Link));{2}
end;

function TFhirNutritionOrderEnteralFormulaAdministration.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'schedule') then
  begin
    Schedule := propValue as TFhirTiming{4b};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'rate', ['Quantity', 'Ratio'])) then
  begin
    Rate := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionOrderEnteralFormulaAdministration.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirNutritionOrderEnteralFormulaAdministration.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'schedule') then result := TFhirTiming.create(){4b}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (isMatchingName(propName, 'rate', ['Quantity', 'Ratio'])) then raise EFHIRException.create('Cannot make property Rate'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionOrderEnteralFormulaAdministration.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'schedule') then result := 'Timing'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'rate[x]') then result := 'Quantity|Ratio'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionOrderEnteralFormulaAdministration.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'schedule') then ScheduleElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (isMatchingName(propName, 'rate', ['Quantity', 'Ratio'])) then RateElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionOrderEnteralFormulaAdministration.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'schedule') then ScheduleElement := new as TFhirTiming{4}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (isMatchingName(propName, 'rate', ['Quantity', 'Ratio'])) then RateElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionOrderEnteralFormulaAdministration.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionOrderEnteralFormulaAdministration.fhirType : string;
begin
  result := 'administration';
end;

function TFhirNutritionOrderEnteralFormulaAdministration.Link : TFhirNutritionOrderEnteralFormulaAdministration;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministration(inherited Link);
end;

function TFhirNutritionOrderEnteralFormulaAdministration.Clone : TFhirNutritionOrderEnteralFormulaAdministration;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministration(inherited Clone);
end;

function TFhirNutritionOrderEnteralFormulaAdministration.equals(other : TObject) : boolean;
var
  o : TFhirNutritionOrderEnteralFormulaAdministration;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionOrderEnteralFormulaAdministration)) then
    result := false
  else
  begin
    o := TFhirNutritionOrderEnteralFormulaAdministration(other);
    result := compareDeep(scheduleElement, o.scheduleElement, true) and compareDeep(quantityElement, o.quantityElement, true) and
      compareDeep(rateElement, o.rateElement, true);
  end;
end;

function TFhirNutritionOrderEnteralFormulaAdministration.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSchedule) and isEmptyProp(FQuantity) and isEmptyProp(FRate);
end;

procedure TFhirNutritionOrderEnteralFormulaAdministration.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('schedule');
  fields.add('quantity');
  fields.add('rate[x]');
end;

{ TFhirNutritionOrderEnteralFormulaAdministration }

Procedure TFhirNutritionOrderEnteralFormulaAdministration.SetSchedule(value : TFhirTiming);
begin
  FSchedule.free;
  FSchedule := value;
end;

Procedure TFhirNutritionOrderEnteralFormulaAdministration.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirNutritionOrderEnteralFormulaAdministration.SetRate(value : TFhirType);
begin
  FRate.free;
  FRate := value;
end;

function TFhirNutritionOrderEnteralFormulaAdministration.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSchedule.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FRate.sizeInBytes);
end;

{ TFhirNutritionOrderEnteralFormulaAdministrationListEnumerator }

Constructor TFhirNutritionOrderEnteralFormulaAdministrationListEnumerator.Create(list : TFhirNutritionOrderEnteralFormulaAdministrationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionOrderEnteralFormulaAdministrationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionOrderEnteralFormulaAdministrationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionOrderEnteralFormulaAdministrationListEnumerator.GetCurrent : TFhirNutritionOrderEnteralFormulaAdministration;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionOrderEnteralFormulaAdministrationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirNutritionOrderEnteralFormulaAdministrationList }
procedure TFhirNutritionOrderEnteralFormulaAdministrationList.AddItem(value: TFhirNutritionOrderEnteralFormulaAdministration);
begin
  assert(value.ClassName = 'TFhirNutritionOrderEnteralFormulaAdministration', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionOrderEnteralFormulaAdministration');
  add(value);
end;

function TFhirNutritionOrderEnteralFormulaAdministrationList.Append: TFhirNutritionOrderEnteralFormulaAdministration;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministration.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderEnteralFormulaAdministrationList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionOrderEnteralFormulaAdministrationList.GetEnumerator : TFhirNutritionOrderEnteralFormulaAdministrationListEnumerator;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministrationListEnumerator.Create(self.link);
end;

function TFhirNutritionOrderEnteralFormulaAdministrationList.Clone: TFhirNutritionOrderEnteralFormulaAdministrationList;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministrationList(inherited Clone);
end;

function TFhirNutritionOrderEnteralFormulaAdministrationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionOrderEnteralFormulaAdministrationList.GetItemN(index: Integer): TFhirNutritionOrderEnteralFormulaAdministration;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministration(ObjectByIndex[index]);
end;

function TFhirNutritionOrderEnteralFormulaAdministrationList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministration;
end;
function TFhirNutritionOrderEnteralFormulaAdministrationList.IndexOf(value: TFhirNutritionOrderEnteralFormulaAdministration): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionOrderEnteralFormulaAdministrationList.Insert(index: Integer): TFhirNutritionOrderEnteralFormulaAdministration;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministration.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderEnteralFormulaAdministrationList.InsertItem(index: Integer; value: TFhirNutritionOrderEnteralFormulaAdministration);
begin
  assert(value is TFhirNutritionOrderEnteralFormulaAdministration);
  Inherited Insert(index, value);
end;

function TFhirNutritionOrderEnteralFormulaAdministrationList.Item(index: Integer): TFhirNutritionOrderEnteralFormulaAdministration;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministration(ObjectByIndex[index]);
end;

function TFhirNutritionOrderEnteralFormulaAdministrationList.Link: TFhirNutritionOrderEnteralFormulaAdministrationList;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministrationList(inherited Link);
end;

procedure TFhirNutritionOrderEnteralFormulaAdministrationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionOrderEnteralFormulaAdministrationList.SetItemByIndex(index: Integer; value: TFhirNutritionOrderEnteralFormulaAdministration);
begin
  assert(value is TFhirNutritionOrderEnteralFormulaAdministration);
  FhirNutritionOrderEnteralFormulaAdministrations[index] := value;
end;

procedure TFhirNutritionOrderEnteralFormulaAdministrationList.SetItemN(index: Integer; value: TFhirNutritionOrderEnteralFormulaAdministration);
begin
  assert(value is TFhirNutritionOrderEnteralFormulaAdministration);
  ObjectByIndex[index] := value;
end;

{ TFhirNutritionOrder }

constructor TFhirNutritionOrder.Create;
begin
  inherited;
end;

destructor TFhirNutritionOrder.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FPatient.free;
  FEncounter.free;
  FDateTime.free;
  FOrderer.free;
  FAllergyIntoleranceList.Free;
  FFoodPreferenceModifierList.Free;
  FExcludeFoodModifierList.Free;
  FOralDiet.free;
  FSupplementList.Free;
  FEnteralFormula.free;
  inherited;
end;

function TFhirNutritionOrder.GetResourceType : TFhirResourceType;
begin
  result := frtNutritionOrder;
end;

procedure TFhirNutritionOrder.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirNutritionOrder(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirNutritionOrder(oSource).FIdentifierList);
  end;
  FStatus := TFhirNutritionOrder(oSource).FStatus.Link;
  patient := TFhirNutritionOrder(oSource).patient.Clone;
  encounter := TFhirNutritionOrder(oSource).encounter.Clone;
  dateTimeElement := TFhirNutritionOrder(oSource).dateTimeElement.Clone;
  orderer := TFhirNutritionOrder(oSource).orderer.Clone;
  if (TFhirNutritionOrder(oSource).FAllergyIntoleranceList = nil) then
  begin
    FAllergyIntoleranceList.free;
    FAllergyIntoleranceList := nil;
  end
  else
  begin
    if FAllergyIntoleranceList = nil then
      FAllergyIntoleranceList := TFhirReferenceList{TFhirAllergyIntolerance}.Create;
    FAllergyIntoleranceList.Assign(TFhirNutritionOrder(oSource).FAllergyIntoleranceList);
  end;
  if (TFhirNutritionOrder(oSource).FFoodPreferenceModifierList = nil) then
  begin
    FFoodPreferenceModifierList.free;
    FFoodPreferenceModifierList := nil;
  end
  else
  begin
    if FFoodPreferenceModifierList = nil then
      FFoodPreferenceModifierList := TFhirCodeableConceptList.Create;
    FFoodPreferenceModifierList.Assign(TFhirNutritionOrder(oSource).FFoodPreferenceModifierList);
  end;
  if (TFhirNutritionOrder(oSource).FExcludeFoodModifierList = nil) then
  begin
    FExcludeFoodModifierList.free;
    FExcludeFoodModifierList := nil;
  end
  else
  begin
    if FExcludeFoodModifierList = nil then
      FExcludeFoodModifierList := TFhirCodeableConceptList.Create;
    FExcludeFoodModifierList.Assign(TFhirNutritionOrder(oSource).FExcludeFoodModifierList);
  end;
  oralDiet := TFhirNutritionOrder(oSource).oralDiet.Clone;
  if (TFhirNutritionOrder(oSource).FSupplementList = nil) then
  begin
    FSupplementList.free;
    FSupplementList := nil;
  end
  else
  begin
    if FSupplementList = nil then
      FSupplementList := TFhirNutritionOrderSupplementList.Create;
    FSupplementList.Assign(TFhirNutritionOrder(oSource).FSupplementList);
  end;
  enteralFormula := TFhirNutritionOrder(oSource).enteralFormula.Clone;
end;

procedure TFhirNutritionOrder.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'dateTime') Then
     list.add(self.link, 'dateTime', FDateTime.Link);
  if (child_name = 'orderer') Then
     list.add(self.link, 'orderer', FOrderer.Link);
  if (child_name = 'allergyIntolerance') Then
    list.addAll(self, 'allergyIntolerance', FAllergyIntoleranceList);
  if (child_name = 'foodPreferenceModifier') Then
    list.addAll(self, 'foodPreferenceModifier', FFoodPreferenceModifierList);
  if (child_name = 'excludeFoodModifier') Then
    list.addAll(self, 'excludeFoodModifier', FExcludeFoodModifierList);
  if (child_name = 'oralDiet') Then
     list.add(self.link, 'oralDiet', FOralDiet.Link);
  if (child_name = 'supplement') Then
    list.addAll(self, 'supplement', FSupplementList);
  if (child_name = 'enteralFormula') Then
     list.add(self.link, 'enteralFormula', FEnteralFormula.Link);
end;

procedure TFhirNutritionOrder.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference(Encounter)', false, TFhirReference{TFhirEncounter}, FEncounter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dateTime', 'dateTime', false, TFhirDateTime, FDateTime.Link));{2}
  oList.add(TFHIRProperty.create(self, 'orderer', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FOrderer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'allergyIntolerance', 'Reference(AllergyIntolerance)', true, TFhirReference{TFhirAllergyIntolerance}, FAllergyIntoleranceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'foodPreferenceModifier', 'CodeableConcept', true, TFhirCodeableConcept, FFoodPreferenceModifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'excludeFoodModifier', 'CodeableConcept', true, TFhirCodeableConcept, FExcludeFoodModifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'oralDiet', '', false, TFhirNutritionOrderOralDiet, FOralDiet.Link));{2}
  oList.add(TFHIRProperty.create(self, 'supplement', '', true, TFhirNutritionOrderSupplement, FSupplementList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'enteralFormula', '', false, TFhirNutritionOrderEnteralFormula, FEnteralFormula.Link));{2}
end;

function TFhirNutritionOrder.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirNutritionRequestStatusEnum, CODES_TFhirNutritionRequestStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference{TFhirEncounter}{4b};
    result := propValue;
  end
  else if (propName = 'dateTime') then
  begin
    DateTimeElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'orderer') then
  begin
    Orderer := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (propName = 'allergyIntolerance') then
  begin
    AllergyIntoleranceList.add(propValue as TFhirReference{TFhirAllergyIntolerance}){2a};
    result := propValue;
  end
  else if (propName = 'foodPreferenceModifier') then
  begin
    FoodPreferenceModifierList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'excludeFoodModifier') then
  begin
    ExcludeFoodModifierList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'oralDiet') then
  begin
    OralDiet := propValue as TFhirNutritionOrderOralDiet{4b};
    result := propValue;
  end
  else if (propName = 'supplement') then
  begin
    SupplementList.add(propValue as TFhirNutritionOrderSupplement){2a};
    result := propValue;
  end
  else if (propName = 'enteralFormula') then
  begin
    EnteralFormula := propValue as TFhirNutritionOrderEnteralFormula{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirNutritionOrder.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'allergyIntolerance') then AllergyIntoleranceList.insertItem(index, propValue as TFhirReference{TFhirAllergyIntolerance}){2a}
  else if (propName = 'foodPreferenceModifier') then FoodPreferenceModifierList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'excludeFoodModifier') then ExcludeFoodModifierList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'supplement') then SupplementList.insertItem(index, propValue as TFhirNutritionOrderSupplement){2a}
  else inherited;
end;

function TFhirNutritionOrder.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'encounter') then result := TFhirReference{TFhirEncounter}.create(){4b}
  else if (propName = 'dateTime') then result := TFhirDateTime.create() {5b}
  else if (propName = 'orderer') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (propName = 'allergyIntolerance') then result := AllergyIntoleranceList.new(){2}
  else if (propName = 'foodPreferenceModifier') then result := FoodPreferenceModifierList.new(){2}
  else if (propName = 'excludeFoodModifier') then result := ExcludeFoodModifierList.new(){2}
  else if (propName = 'oralDiet') then result := TFhirNutritionOrderOralDiet.create(){4b}
  else if (propName = 'supplement') then result := SupplementList.new(){2}
  else if (propName = 'enteralFormula') then result := TFhirNutritionOrderEnteralFormula.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionOrder.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'dateTime') then result := 'dateTime'
  else if (propName = 'orderer') then result := 'Reference'
  else if (propName = 'allergyIntolerance') then result := 'Reference'
  else if (propName = 'foodPreferenceModifier') then result := 'CodeableConcept'
  else if (propName = 'excludeFoodModifier') then result := 'CodeableConcept'
  else if (propName = 'oralDiet') then result := ''
  else if (propName = 'supplement') then result := ''
  else if (propName = 'enteralFormula') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionOrder.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'dateTime') then DateTimeElement := nil
  else if (propName = 'orderer') then OrdererElement := nil
  else if (propName = 'allergyIntolerance') then deletePropertyValue('allergyIntolerance', AllergyIntoleranceList, value) {2}
  else if (propName = 'foodPreferenceModifier') then deletePropertyValue('foodPreferenceModifier', FoodPreferenceModifierList, value) {2}
  else if (propName = 'excludeFoodModifier') then deletePropertyValue('excludeFoodModifier', ExcludeFoodModifierList, value) {2}
  else if (propName = 'oralDiet') then OralDietElement := nil
  else if (propName = 'supplement') then deletePropertyValue('supplement', SupplementList, value) {2}
  else if (propName = 'enteralFormula') then EnteralFormulaElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionOrder.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirNutritionRequestStatusEnum, CODES_TFhirNutritionRequestStatusEnum, new){4}
  else if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference{TFhirEncounter}{4}
  else if (propName = 'dateTime') then DateTimeElement := asDateTime(new){5b}
  else if (propName = 'orderer') then OrdererElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (propName = 'allergyIntolerance') then replacePropertyValue('allergyIntolerance', AllergyIntoleranceList, existing, new) {2}
  else if (propName = 'foodPreferenceModifier') then replacePropertyValue('foodPreferenceModifier', FoodPreferenceModifierList, existing, new) {2}
  else if (propName = 'excludeFoodModifier') then replacePropertyValue('excludeFoodModifier', ExcludeFoodModifierList, existing, new) {2}
  else if (propName = 'oralDiet') then OralDietElement := new as TFhirNutritionOrderOralDiet{4}
  else if (propName = 'supplement') then replacePropertyValue('supplement', SupplementList, existing, new) {2}
  else if (propName = 'enteralFormula') then EnteralFormulaElement := new as TFhirNutritionOrderEnteralFormula{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionOrder.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'allergyIntolerance') then AllergyIntoleranceList.move(source, destination){2a}
  else if (propName = 'foodPreferenceModifier') then FoodPreferenceModifierList.move(source, destination){2a}
  else if (propName = 'excludeFoodModifier') then ExcludeFoodModifierList.move(source, destination){2a}
  else if (propName = 'supplement') then SupplementList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionOrder.fhirType : string;
begin
  result := 'NutritionOrder';
end;

function TFhirNutritionOrder.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FPatient) and isEmptyProp(FEncounter) and isEmptyProp(FDateTime) and isEmptyProp(FOrderer) and isEmptyProp(FallergyIntoleranceList) and isEmptyProp(FfoodPreferenceModifierList) and isEmptyProp(FexcludeFoodModifierList) and isEmptyProp(FOralDiet) and isEmptyProp(FsupplementList) and isEmptyProp(FEnteralFormula);
end;

function TFhirNutritionOrder.equals(other : TObject) : boolean;
var
  o : TFhirNutritionOrder;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionOrder)) then
    result := false
  else
  begin
    o := TFhirNutritionOrder(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(patientElement, o.patientElement, true) and compareDeep(encounterElement, o.encounterElement, true) and
      compareDeep(dateTimeElement, o.dateTimeElement, true) and compareDeep(ordererElement, o.ordererElement, true) and
      compareDeep(allergyIntoleranceList, o.allergyIntoleranceList, true) and compareDeep(foodPreferenceModifierList, o.foodPreferenceModifierList, true) and
      compareDeep(excludeFoodModifierList, o.excludeFoodModifierList, true) and compareDeep(oralDietElement, o.oralDietElement, true) and
      compareDeep(supplementList, o.supplementList, true) and compareDeep(enteralFormulaElement, o.enteralFormulaElement, true);
  end;
end;

function TFhirNutritionOrder.Link : TFhirNutritionOrder;
begin
  result := TFhirNutritionOrder(inherited Link);
end;

function TFhirNutritionOrder.Clone : TFhirNutritionOrder;
begin
  result := TFhirNutritionOrder(inherited Clone);
end;

procedure TFhirNutritionOrder.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('patient');
  fields.add('encounter');
  fields.add('dateTime');
  fields.add('orderer');
  fields.add('allergyIntolerance');
  fields.add('foodPreferenceModifier');
  fields.add('excludeFoodModifier');
  fields.add('oralDiet');
  fields.add('supplement');
  fields.add('enteralFormula');
end;

{ TFhirNutritionOrder }

Function TFhirNutritionOrder.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirNutritionOrder.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirNutritionOrder.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirNutritionOrder.GetStatusST : TFhirNutritionRequestStatusEnum;
begin
  if FStatus = nil then
    result := TFhirNutritionRequestStatusEnum(0)
  else
    result := TFhirNutritionRequestStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirNutritionRequestStatusEnum, FStatus.value));
end;

Procedure TFhirNutritionOrder.SetStatusST(value : TFhirNutritionRequestStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirNutritionRequestStatusEnum[value], CODES_TFhirNutritionRequestStatusEnum[value]);
end;

Procedure TFhirNutritionOrder.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Procedure TFhirNutritionOrder.SetEncounter(value : TFhirReference{TFhirEncounter});
begin
  FEncounter.free;
  FEncounter := value;
end;

Procedure TFhirNutritionOrder.SetDateTime(value : TFhirDateTime);
begin
  FDateTime.free;
  FDateTime := value;
end;

Function TFhirNutritionOrder.GetDateTimeST : TFslDateTime;
begin
  if FDateTime = nil then
    result := TFslDateTime.makeNull
  else
    result := FDateTime.value;
end;

Procedure TFhirNutritionOrder.SetDateTimeST(value : TFslDateTime);
begin
  if FDateTime = nil then
    FDateTime := TFhirDateTime.create;
  FDateTime.value := value
end;

Procedure TFhirNutritionOrder.SetOrderer(value : TFhirReference{TFhirPractitioner});
begin
  FOrderer.free;
  FOrderer := value;
end;

Function TFhirNutritionOrder.GetAllergyIntoleranceList : TFhirReferenceList{TFhirAllergyIntolerance};
begin
  if FAllergyIntoleranceList = nil then
    FAllergyIntoleranceList := TFhirReferenceList{TFhirAllergyIntolerance}.Create;
  result := FAllergyIntoleranceList;
end;

Function TFhirNutritionOrder.GetHasAllergyIntoleranceList : boolean;
begin
  result := (FAllergyIntoleranceList <> nil) and (FAllergyIntoleranceList.count > 0);
end;

Function TFhirNutritionOrder.GetFoodPreferenceModifierList : TFhirCodeableConceptList;
begin
  if FFoodPreferenceModifierList = nil then
    FFoodPreferenceModifierList := TFhirCodeableConceptList.Create;
  result := FFoodPreferenceModifierList;
end;

Function TFhirNutritionOrder.GetHasFoodPreferenceModifierList : boolean;
begin
  result := (FFoodPreferenceModifierList <> nil) and (FFoodPreferenceModifierList.count > 0);
end;

Function TFhirNutritionOrder.GetExcludeFoodModifierList : TFhirCodeableConceptList;
begin
  if FExcludeFoodModifierList = nil then
    FExcludeFoodModifierList := TFhirCodeableConceptList.Create;
  result := FExcludeFoodModifierList;
end;

Function TFhirNutritionOrder.GetHasExcludeFoodModifierList : boolean;
begin
  result := (FExcludeFoodModifierList <> nil) and (FExcludeFoodModifierList.count > 0);
end;

Procedure TFhirNutritionOrder.SetOralDiet(value : TFhirNutritionOrderOralDiet);
begin
  FOralDiet.free;
  FOralDiet := value;
end;

Function TFhirNutritionOrder.GetSupplementList : TFhirNutritionOrderSupplementList;
begin
  if FSupplementList = nil then
    FSupplementList := TFhirNutritionOrderSupplementList.Create;
  result := FSupplementList;
end;

Function TFhirNutritionOrder.GetHasSupplementList : boolean;
begin
  result := (FSupplementList <> nil) and (FSupplementList.count > 0);
end;

Procedure TFhirNutritionOrder.SetEnteralFormula(value : TFhirNutritionOrderEnteralFormula);
begin
  FEnteralFormula.free;
  FEnteralFormula := value;
end;

function TFhirNutritionOrder.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FDateTime.sizeInBytes);
  inc(result, FOrderer.sizeInBytes);
  inc(result, FallergyIntoleranceList.sizeInBytes);
  inc(result, FfoodPreferenceModifierList.sizeInBytes);
  inc(result, FexcludeFoodModifierList.sizeInBytes);
  inc(result, FOralDiet.sizeInBytes);
  inc(result, FsupplementList.sizeInBytes);
  inc(result, FEnteralFormula.sizeInBytes);
end;

{ TFhirNutritionOrderListEnumerator }

Constructor TFhirNutritionOrderListEnumerator.Create(list : TFhirNutritionOrderList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionOrderListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionOrderListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionOrderListEnumerator.GetCurrent : TFhirNutritionOrder;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionOrderListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirNutritionOrderList }
procedure TFhirNutritionOrderList.AddItem(value: TFhirNutritionOrder);
begin
  assert(value.ClassName = 'TFhirNutritionOrder', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionOrder');
  add(value);
end;

function TFhirNutritionOrderList.Append: TFhirNutritionOrder;
begin
  result := TFhirNutritionOrder.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionOrderList.GetEnumerator : TFhirNutritionOrderListEnumerator;
begin
  result := TFhirNutritionOrderListEnumerator.Create(self.link);
end;

function TFhirNutritionOrderList.Clone: TFhirNutritionOrderList;
begin
  result := TFhirNutritionOrderList(inherited Clone);
end;

function TFhirNutritionOrderList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionOrderList.GetItemN(index: Integer): TFhirNutritionOrder;
begin
  result := TFhirNutritionOrder(ObjectByIndex[index]);
end;

function TFhirNutritionOrderList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionOrder;
end;
function TFhirNutritionOrderList.IndexOf(value: TFhirNutritionOrder): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionOrderList.Insert(index: Integer): TFhirNutritionOrder;
begin
  result := TFhirNutritionOrder.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderList.InsertItem(index: Integer; value: TFhirNutritionOrder);
begin
  assert(value is TFhirNutritionOrder);
  Inherited Insert(index, value);
end;

function TFhirNutritionOrderList.Item(index: Integer): TFhirNutritionOrder;
begin
  result := TFhirNutritionOrder(ObjectByIndex[index]);
end;

function TFhirNutritionOrderList.Link: TFhirNutritionOrderList;
begin
  result := TFhirNutritionOrderList(inherited Link);
end;

procedure TFhirNutritionOrderList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionOrderList.SetItemByIndex(index: Integer; value: TFhirNutritionOrder);
begin
  assert(value is TFhirNutritionOrder);
  FhirNutritionOrders[index] := value;
end;

procedure TFhirNutritionOrderList.SetItemN(index: Integer; value: TFhirNutritionOrder);
begin
  assert(value is TFhirNutritionOrder);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_NUTRITIONORDER}

{$IFDEF FHIR_OBSERVATION}

{ TFhirObservationReferenceRange }

constructor TFhirObservationReferenceRange.Create;
begin
  inherited;
end;

destructor TFhirObservationReferenceRange.Destroy;
begin
  FLow.free;
  FHigh.free;
  FType_.free;
  FAppliesToList.Free;
  FAge.free;
  FText.free;
  inherited;
end;

procedure TFhirObservationReferenceRange.Assign(oSource : TFslObject);
begin
  inherited;
  low := TFhirObservationReferenceRange(oSource).low.Clone;
  high := TFhirObservationReferenceRange(oSource).high.Clone;
  type_ := TFhirObservationReferenceRange(oSource).type_.Clone;
  if (TFhirObservationReferenceRange(oSource).FAppliesToList = nil) then
  begin
    FAppliesToList.free;
    FAppliesToList := nil;
  end
  else
  begin
    if FAppliesToList = nil then
      FAppliesToList := TFhirCodeableConceptList.Create;
    FAppliesToList.Assign(TFhirObservationReferenceRange(oSource).FAppliesToList);
  end;
  age := TFhirObservationReferenceRange(oSource).age.Clone;
  textElement := TFhirObservationReferenceRange(oSource).textElement.Clone;
end;

procedure TFhirObservationReferenceRange.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'low') Then
     list.add(self.link, 'low', FLow.Link);
  if (child_name = 'high') Then
     list.add(self.link, 'high', FHigh.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'appliesTo') Then
    list.addAll(self, 'appliesTo', FAppliesToList);
  if (child_name = 'age') Then
     list.add(self.link, 'age', FAge.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
end;

procedure TFhirObservationReferenceRange.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'low', 'Quantity', false, TFhirQuantity, FLow.Link));{2}
  oList.add(TFHIRProperty.create(self, 'high', 'Quantity', false, TFhirQuantity, FHigh.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'appliesTo', 'CodeableConcept', true, TFhirCodeableConcept, FAppliesToList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'age', 'Range', false, TFhirRange, FAge.Link));{2}
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));{2}
end;

function TFhirObservationReferenceRange.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'low') then
  begin
    Low := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'high') then
  begin
    High := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'appliesTo') then
  begin
    AppliesToList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'age') then
  begin
    Age := propValue as TFhirRange{4b};
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirObservationReferenceRange.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'appliesTo') then AppliesToList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirObservationReferenceRange.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'low') then result := TFhirQuantity.create(){4b}
  else if (propName = 'high') then result := TFhirQuantity.create(){4b}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'appliesTo') then result := AppliesToList.new(){2}
  else if (propName = 'age') then result := TFhirRange.create(){4b}
  else if (propName = 'text') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirObservationReferenceRange.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'low') then result := 'Quantity'
  else if (propName = 'high') then result := 'Quantity'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'appliesTo') then result := 'CodeableConcept'
  else if (propName = 'age') then result := 'Range'
  else if (propName = 'text') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirObservationReferenceRange.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'low') then LowElement := nil
  else if (propName = 'high') then HighElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'appliesTo') then deletePropertyValue('appliesTo', AppliesToList, value) {2}
  else if (propName = 'age') then AgeElement := nil
  else if (propName = 'text') then TextElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirObservationReferenceRange.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'low') then LowElement := new as TFhirQuantity{4}
  else if (propName = 'high') then HighElement := new as TFhirQuantity{4}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'appliesTo') then replacePropertyValue('appliesTo', AppliesToList, existing, new) {2}
  else if (propName = 'age') then AgeElement := new as TFhirRange{4}
  else if (propName = 'text') then TextElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirObservationReferenceRange.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'appliesTo') then AppliesToList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirObservationReferenceRange.fhirType : string;
begin
  result := 'referenceRange';
end;

function TFhirObservationReferenceRange.Link : TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange(inherited Link);
end;

function TFhirObservationReferenceRange.Clone : TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange(inherited Clone);
end;

function TFhirObservationReferenceRange.equals(other : TObject) : boolean;
var
  o : TFhirObservationReferenceRange;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirObservationReferenceRange)) then
    result := false
  else
  begin
    o := TFhirObservationReferenceRange(other);
    result := compareDeep(lowElement, o.lowElement, true) and compareDeep(highElement, o.highElement, true) and
      compareDeep(type_Element, o.type_Element, true) and compareDeep(appliesToList, o.appliesToList, true) and
      compareDeep(ageElement, o.ageElement, true) and compareDeep(textElement, o.textElement, true);
  end;
end;

function TFhirObservationReferenceRange.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLow) and isEmptyProp(FHigh) and isEmptyProp(FType_) and isEmptyProp(FappliesToList) and isEmptyProp(FAge) and isEmptyProp(FText);
end;

procedure TFhirObservationReferenceRange.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('low');
  fields.add('high');
  fields.add('type');
  fields.add('appliesTo');
  fields.add('age');
  fields.add('text');
end;

{ TFhirObservationReferenceRange }

Procedure TFhirObservationReferenceRange.SetLow(value : TFhirQuantity);
begin
  FLow.free;
  FLow := value;
end;

Procedure TFhirObservationReferenceRange.SetHigh(value : TFhirQuantity);
begin
  FHigh.free;
  FHigh := value;
end;

Procedure TFhirObservationReferenceRange.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirObservationReferenceRange.GetAppliesToList : TFhirCodeableConceptList;
begin
  if FAppliesToList = nil then
    FAppliesToList := TFhirCodeableConceptList.Create;
  result := FAppliesToList;
end;

Function TFhirObservationReferenceRange.GetHasAppliesToList : boolean;
begin
  result := (FAppliesToList <> nil) and (FAppliesToList.count > 0);
end;

Procedure TFhirObservationReferenceRange.SetAge(value : TFhirRange);
begin
  FAge.free;
  FAge := value;
end;

Procedure TFhirObservationReferenceRange.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

Function TFhirObservationReferenceRange.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

Procedure TFhirObservationReferenceRange.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

function TFhirObservationReferenceRange.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FLow.sizeInBytes);
  inc(result, FHigh.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FappliesToList.sizeInBytes);
  inc(result, FAge.sizeInBytes);
  inc(result, FText.sizeInBytes);
end;

{ TFhirObservationReferenceRangeListEnumerator }

Constructor TFhirObservationReferenceRangeListEnumerator.Create(list : TFhirObservationReferenceRangeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirObservationReferenceRangeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirObservationReferenceRangeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirObservationReferenceRangeListEnumerator.GetCurrent : TFhirObservationReferenceRange;
begin
  Result := FList[FIndex];
end;

function TFhirObservationReferenceRangeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirObservationReferenceRangeList }
procedure TFhirObservationReferenceRangeList.AddItem(value: TFhirObservationReferenceRange);
begin
  assert(value.ClassName = 'TFhirObservationReferenceRange', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirObservationReferenceRange');
  add(value);
end;

function TFhirObservationReferenceRangeList.Append: TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirObservationReferenceRangeList.ClearItems;
begin
  Clear;
end;

function TFhirObservationReferenceRangeList.GetEnumerator : TFhirObservationReferenceRangeListEnumerator;
begin
  result := TFhirObservationReferenceRangeListEnumerator.Create(self.link);
end;

function TFhirObservationReferenceRangeList.Clone: TFhirObservationReferenceRangeList;
begin
  result := TFhirObservationReferenceRangeList(inherited Clone);
end;

function TFhirObservationReferenceRangeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirObservationReferenceRangeList.GetItemN(index: Integer): TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange(ObjectByIndex[index]);
end;

function TFhirObservationReferenceRangeList.ItemClass: TFslObjectClass;
begin
  result := TFhirObservationReferenceRange;
end;
function TFhirObservationReferenceRangeList.IndexOf(value: TFhirObservationReferenceRange): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirObservationReferenceRangeList.Insert(index: Integer): TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirObservationReferenceRangeList.InsertItem(index: Integer; value: TFhirObservationReferenceRange);
begin
  assert(value is TFhirObservationReferenceRange);
  Inherited Insert(index, value);
end;

function TFhirObservationReferenceRangeList.Item(index: Integer): TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange(ObjectByIndex[index]);
end;

function TFhirObservationReferenceRangeList.Link: TFhirObservationReferenceRangeList;
begin
  result := TFhirObservationReferenceRangeList(inherited Link);
end;

procedure TFhirObservationReferenceRangeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirObservationReferenceRangeList.SetItemByIndex(index: Integer; value: TFhirObservationReferenceRange);
begin
  assert(value is TFhirObservationReferenceRange);
  FhirObservationReferenceRanges[index] := value;
end;

procedure TFhirObservationReferenceRangeList.SetItemN(index: Integer; value: TFhirObservationReferenceRange);
begin
  assert(value is TFhirObservationReferenceRange);
  ObjectByIndex[index] := value;
end;

{ TFhirObservationRelated }

constructor TFhirObservationRelated.Create;
begin
  inherited;
end;

destructor TFhirObservationRelated.Destroy;
begin
  FType_.free;
  FTarget.free;
  inherited;
end;

procedure TFhirObservationRelated.Assign(oSource : TFslObject);
begin
  inherited;
  FType_ := TFhirObservationRelated(oSource).FType_.Link;
  target := TFhirObservationRelated(oSource).target.Clone;
end;

procedure TFhirObservationRelated.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'target') Then
     list.add(self.link, 'target', FTarget.Link);
end;

procedure TFhirObservationRelated.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'target', 'Reference(Observation|QuestionnaireResponse|Sequence)', false, TFhirReference{Resource}, FTarget.Link));{2}
end;

function TFhirObservationRelated.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirObservationRelationshiptypesEnum, CODES_TFhirObservationRelationshiptypesEnum, propValue);
    result := propValue
  end
  else if (propName = 'target') then
  begin
    Target := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirObservationRelated.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirObservationRelated.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'target') then result := TFhirReference{Resource}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirObservationRelated.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'target') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirObservationRelated.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'target') then TargetElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirObservationRelated.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirObservationRelationshiptypesEnum, CODES_TFhirObservationRelationshiptypesEnum, new){4}
  else if (propName = 'target') then TargetElement := new as TFhirReference{Resource}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirObservationRelated.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirObservationRelated.fhirType : string;
begin
  result := 'related';
end;

function TFhirObservationRelated.Link : TFhirObservationRelated;
begin
  result := TFhirObservationRelated(inherited Link);
end;

function TFhirObservationRelated.Clone : TFhirObservationRelated;
begin
  result := TFhirObservationRelated(inherited Clone);
end;

function TFhirObservationRelated.equals(other : TObject) : boolean;
var
  o : TFhirObservationRelated;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirObservationRelated)) then
    result := false
  else
  begin
    o := TFhirObservationRelated(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(targetElement, o.targetElement, true);
  end;
end;

function TFhirObservationRelated.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FTarget);
end;

procedure TFhirObservationRelated.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('target');
end;

{ TFhirObservationRelated }

Procedure TFhirObservationRelated.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirObservationRelated.GetType_ST : TFhirObservationRelationshiptypesEnum;
begin
  if FType_ = nil then
    result := TFhirObservationRelationshiptypesEnum(0)
  else
    result := TFhirObservationRelationshiptypesEnum(StringArrayIndexOfSensitive(CODES_TFhirObservationRelationshiptypesEnum, FType_.value));
end;

Procedure TFhirObservationRelated.SetType_ST(value : TFhirObservationRelationshiptypesEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirObservationRelationshiptypesEnum[value], CODES_TFhirObservationRelationshiptypesEnum[value]);
end;

Procedure TFhirObservationRelated.SetTarget(value : TFhirReference{Resource});
begin
  FTarget.free;
  FTarget := value;
end;

function TFhirObservationRelated.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FTarget.sizeInBytes);
end;

{ TFhirObservationRelatedListEnumerator }

Constructor TFhirObservationRelatedListEnumerator.Create(list : TFhirObservationRelatedList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirObservationRelatedListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirObservationRelatedListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirObservationRelatedListEnumerator.GetCurrent : TFhirObservationRelated;
begin
  Result := FList[FIndex];
end;

function TFhirObservationRelatedListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirObservationRelatedList }
procedure TFhirObservationRelatedList.AddItem(value: TFhirObservationRelated);
begin
  assert(value.ClassName = 'TFhirObservationRelated', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirObservationRelated');
  add(value);
end;

function TFhirObservationRelatedList.Append: TFhirObservationRelated;
begin
  result := TFhirObservationRelated.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirObservationRelatedList.ClearItems;
begin
  Clear;
end;

function TFhirObservationRelatedList.GetEnumerator : TFhirObservationRelatedListEnumerator;
begin
  result := TFhirObservationRelatedListEnumerator.Create(self.link);
end;

function TFhirObservationRelatedList.Clone: TFhirObservationRelatedList;
begin
  result := TFhirObservationRelatedList(inherited Clone);
end;

function TFhirObservationRelatedList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirObservationRelatedList.GetItemN(index: Integer): TFhirObservationRelated;
begin
  result := TFhirObservationRelated(ObjectByIndex[index]);
end;

function TFhirObservationRelatedList.ItemClass: TFslObjectClass;
begin
  result := TFhirObservationRelated;
end;
function TFhirObservationRelatedList.IndexOf(value: TFhirObservationRelated): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirObservationRelatedList.Insert(index: Integer): TFhirObservationRelated;
begin
  result := TFhirObservationRelated.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirObservationRelatedList.InsertItem(index: Integer; value: TFhirObservationRelated);
begin
  assert(value is TFhirObservationRelated);
  Inherited Insert(index, value);
end;

function TFhirObservationRelatedList.Item(index: Integer): TFhirObservationRelated;
begin
  result := TFhirObservationRelated(ObjectByIndex[index]);
end;

function TFhirObservationRelatedList.Link: TFhirObservationRelatedList;
begin
  result := TFhirObservationRelatedList(inherited Link);
end;

procedure TFhirObservationRelatedList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirObservationRelatedList.SetItemByIndex(index: Integer; value: TFhirObservationRelated);
begin
  assert(value is TFhirObservationRelated);
  FhirObservationRelateds[index] := value;
end;

procedure TFhirObservationRelatedList.SetItemN(index: Integer; value: TFhirObservationRelated);
begin
  assert(value is TFhirObservationRelated);
  ObjectByIndex[index] := value;
end;

{ TFhirObservationComponent }

constructor TFhirObservationComponent.Create;
begin
  inherited;
end;

destructor TFhirObservationComponent.Destroy;
begin
  FCode.free;
  FValue.free;
  FDataAbsentReason.free;
  FInterpretation.free;
  FReferenceRangeList.Free;
  inherited;
end;

procedure TFhirObservationComponent.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirObservationComponent(oSource).code.Clone;
  value := TFhirObservationComponent(oSource).value.Clone;
  dataAbsentReason := TFhirObservationComponent(oSource).dataAbsentReason.Clone;
  interpretation := TFhirObservationComponent(oSource).interpretation.Clone;
  if (TFhirObservationComponent(oSource).FReferenceRangeList = nil) then
  begin
    FReferenceRangeList.free;
    FReferenceRangeList := nil;
  end
  else
  begin
    if FReferenceRangeList = nil then
      FReferenceRangeList := TFhirObservationReferenceRangeList.Create;
    FReferenceRangeList.Assign(TFhirObservationComponent(oSource).FReferenceRangeList);
  end;
end;

procedure TFhirObservationComponent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
  if (child_name = 'dataAbsentReason') Then
     list.add(self.link, 'dataAbsentReason', FDataAbsentReason.Link);
  if (child_name = 'interpretation') Then
     list.add(self.link, 'interpretation', FInterpretation.Link);
  if (child_name = 'referenceRange') Then
    list.addAll(self, 'referenceRange', FReferenceRangeList);
end;

procedure TFhirObservationComponent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value[x]', 'Quantity|CodeableConcept|string|Range|Ratio|SampledData|Attachment|time|dateTime|Period', false, TFhirType, FValue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dataAbsentReason', 'CodeableConcept', false, TFhirCodeableConcept, FDataAbsentReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'interpretation', 'CodeableConcept', false, TFhirCodeableConcept, FInterpretation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'referenceRange', '@Observation.referenceRange', true, TFhirObservationReferenceRange, FReferenceRangeList.Link)){3};
end;

function TFhirObservationComponent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Range', 'Ratio', 'SampledData', 'Attachment', 'Time', 'DateTime', 'Period'])) then
  begin
    Value := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'dataAbsentReason') then
  begin
    DataAbsentReason := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'interpretation') then
  begin
    Interpretation := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'referenceRange') then
  begin
    ReferenceRangeList.add(propValue as TFhirObservationReferenceRange){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirObservationComponent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'referenceRange') then ReferenceRangeList.insertItem(index, propValue as TFhirObservationReferenceRange){2a}
  else inherited;
end;

function TFhirObservationComponent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Range', 'Ratio', 'SampledData', 'Attachment', 'Time', 'DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Value'){4x}
  else if (propName = 'dataAbsentReason') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'interpretation') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'referenceRange') then result := ReferenceRangeList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirObservationComponent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'Quantity|CodeableConcept|string|Range|Ratio|SampledData|Attachment|time|dateTime|Period'
  else if (propName = 'dataAbsentReason') then result := 'CodeableConcept'
  else if (propName = 'interpretation') then result := 'CodeableConcept'
  else if (propName = 'referenceRange') then result := '@Observation.referenceRange'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirObservationComponent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Range', 'Ratio', 'SampledData', 'Attachment', 'Time', 'DateTime', 'Period'])) then ValueElement := nil{4x}
  else if (propName = 'dataAbsentReason') then DataAbsentReasonElement := nil
  else if (propName = 'interpretation') then InterpretationElement := nil
  else if (propName = 'referenceRange') then deletePropertyValue('referenceRange', ReferenceRangeList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirObservationComponent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Range', 'Ratio', 'SampledData', 'Attachment', 'Time', 'DateTime', 'Period'])) then ValueElement := new as TFhirType{4x}
  else if (propName = 'dataAbsentReason') then DataAbsentReasonElement := new as TFhirCodeableConcept{4}
  else if (propName = 'interpretation') then InterpretationElement := new as TFhirCodeableConcept{4}
  else if (propName = 'referenceRange') then replacePropertyValue('referenceRange', ReferenceRangeList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirObservationComponent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'referenceRange') then ReferenceRangeList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirObservationComponent.fhirType : string;
begin
  result := 'component';
end;

function TFhirObservationComponent.Link : TFhirObservationComponent;
begin
  result := TFhirObservationComponent(inherited Link);
end;

function TFhirObservationComponent.Clone : TFhirObservationComponent;
begin
  result := TFhirObservationComponent(inherited Clone);
end;

function TFhirObservationComponent.equals(other : TObject) : boolean;
var
  o : TFhirObservationComponent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirObservationComponent)) then
    result := false
  else
  begin
    o := TFhirObservationComponent(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(valueElement, o.valueElement, true) and
      compareDeep(dataAbsentReasonElement, o.dataAbsentReasonElement, true) and compareDeep(interpretationElement, o.interpretationElement, true) and
      compareDeep(referenceRangeList, o.referenceRangeList, true);
  end;
end;

function TFhirObservationComponent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FValue) and isEmptyProp(FDataAbsentReason) and isEmptyProp(FInterpretation) and isEmptyProp(FreferenceRangeList);
end;

procedure TFhirObservationComponent.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('value[x]');
  fields.add('dataAbsentReason');
  fields.add('interpretation');
  fields.add('referenceRange');
end;

{ TFhirObservationComponent }

Procedure TFhirObservationComponent.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirObservationComponent.SetValue(value : TFhirType);
begin
  FValue.free;
  FValue := value;
end;

Procedure TFhirObservationComponent.SetDataAbsentReason(value : TFhirCodeableConcept);
begin
  FDataAbsentReason.free;
  FDataAbsentReason := value;
end;

Procedure TFhirObservationComponent.SetInterpretation(value : TFhirCodeableConcept);
begin
  FInterpretation.free;
  FInterpretation := value;
end;

Function TFhirObservationComponent.GetReferenceRangeList : TFhirObservationReferenceRangeList;
begin
  if FReferenceRangeList = nil then
    FReferenceRangeList := TFhirObservationReferenceRangeList.Create;
  result := FReferenceRangeList;
end;

Function TFhirObservationComponent.GetHasReferenceRangeList : boolean;
begin
  result := (FReferenceRangeList <> nil) and (FReferenceRangeList.count > 0);
end;

function TFhirObservationComponent.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FValue.sizeInBytes);
  inc(result, FDataAbsentReason.sizeInBytes);
  inc(result, FInterpretation.sizeInBytes);
  inc(result, FreferenceRangeList.sizeInBytes);
end;

{ TFhirObservationComponentListEnumerator }

Constructor TFhirObservationComponentListEnumerator.Create(list : TFhirObservationComponentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirObservationComponentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirObservationComponentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirObservationComponentListEnumerator.GetCurrent : TFhirObservationComponent;
begin
  Result := FList[FIndex];
end;

function TFhirObservationComponentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirObservationComponentList }
procedure TFhirObservationComponentList.AddItem(value: TFhirObservationComponent);
begin
  assert(value.ClassName = 'TFhirObservationComponent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirObservationComponent');
  add(value);
end;

function TFhirObservationComponentList.Append: TFhirObservationComponent;
begin
  result := TFhirObservationComponent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirObservationComponentList.ClearItems;
begin
  Clear;
end;

function TFhirObservationComponentList.GetEnumerator : TFhirObservationComponentListEnumerator;
begin
  result := TFhirObservationComponentListEnumerator.Create(self.link);
end;

function TFhirObservationComponentList.Clone: TFhirObservationComponentList;
begin
  result := TFhirObservationComponentList(inherited Clone);
end;

function TFhirObservationComponentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirObservationComponentList.GetItemN(index: Integer): TFhirObservationComponent;
begin
  result := TFhirObservationComponent(ObjectByIndex[index]);
end;

function TFhirObservationComponentList.ItemClass: TFslObjectClass;
begin
  result := TFhirObservationComponent;
end;
function TFhirObservationComponentList.IndexOf(value: TFhirObservationComponent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirObservationComponentList.Insert(index: Integer): TFhirObservationComponent;
begin
  result := TFhirObservationComponent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirObservationComponentList.InsertItem(index: Integer; value: TFhirObservationComponent);
begin
  assert(value is TFhirObservationComponent);
  Inherited Insert(index, value);
end;

function TFhirObservationComponentList.Item(index: Integer): TFhirObservationComponent;
begin
  result := TFhirObservationComponent(ObjectByIndex[index]);
end;

function TFhirObservationComponentList.Link: TFhirObservationComponentList;
begin
  result := TFhirObservationComponentList(inherited Link);
end;

procedure TFhirObservationComponentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirObservationComponentList.SetItemByIndex(index: Integer; value: TFhirObservationComponent);
begin
  assert(value is TFhirObservationComponent);
  FhirObservationComponents[index] := value;
end;

procedure TFhirObservationComponentList.SetItemN(index: Integer; value: TFhirObservationComponent);
begin
  assert(value is TFhirObservationComponent);
  ObjectByIndex[index] := value;
end;

{ TFhirObservation }

constructor TFhirObservation.Create;
begin
  inherited;
end;

destructor TFhirObservation.Destroy;
begin
  FIdentifierList.Free;
  FBasedOnList.Free;
  FStatus.free;
  FCategoryList.Free;
  FCode.free;
  FSubject.free;
  FContext.free;
  FEffective.free;
  FIssued.free;
  FPerformerList.Free;
  FValue.free;
  FDataAbsentReason.free;
  FInterpretation.free;
  FComment.free;
  FBodySite.free;
  FMethod.free;
  FSpecimen.free;
  FDevice.free;
  FReferenceRangeList.Free;
  FRelatedList.Free;
  FComponentList.Free;
  inherited;
end;

function TFhirObservation.GetResourceType : TFhirResourceType;
begin
  result := frtObservation;
end;

procedure TFhirObservation.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirObservation(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirObservation(oSource).FIdentifierList);
  end;
  if (TFhirObservation(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList{Resource}.Create;
    FBasedOnList.Assign(TFhirObservation(oSource).FBasedOnList);
  end;
  FStatus := TFhirObservation(oSource).FStatus.Link;
  if (TFhirObservation(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirObservation(oSource).FCategoryList);
  end;
  code := TFhirObservation(oSource).code.Clone;
  subject := TFhirObservation(oSource).subject.Clone;
  context := TFhirObservation(oSource).context.Clone;
  effective := TFhirObservation(oSource).effective.Clone;
  issuedElement := TFhirObservation(oSource).issuedElement.Clone;
  if (TFhirObservation(oSource).FPerformerList = nil) then
  begin
    FPerformerList.free;
    FPerformerList := nil;
  end
  else
  begin
    if FPerformerList = nil then
      FPerformerList := TFhirReferenceList{Resource}.Create;
    FPerformerList.Assign(TFhirObservation(oSource).FPerformerList);
  end;
  value := TFhirObservation(oSource).value.Clone;
  dataAbsentReason := TFhirObservation(oSource).dataAbsentReason.Clone;
  interpretation := TFhirObservation(oSource).interpretation.Clone;
  commentElement := TFhirObservation(oSource).commentElement.Clone;
  bodySite := TFhirObservation(oSource).bodySite.Clone;
  method := TFhirObservation(oSource).method.Clone;
  specimen := TFhirObservation(oSource).specimen.Clone;
  device := TFhirObservation(oSource).device.Clone;
  if (TFhirObservation(oSource).FReferenceRangeList = nil) then
  begin
    FReferenceRangeList.free;
    FReferenceRangeList := nil;
  end
  else
  begin
    if FReferenceRangeList = nil then
      FReferenceRangeList := TFhirObservationReferenceRangeList.Create;
    FReferenceRangeList.Assign(TFhirObservation(oSource).FReferenceRangeList);
  end;
  if (TFhirObservation(oSource).FRelatedList = nil) then
  begin
    FRelatedList.free;
    FRelatedList := nil;
  end
  else
  begin
    if FRelatedList = nil then
      FRelatedList := TFhirObservationRelatedList.Create;
    FRelatedList.Assign(TFhirObservation(oSource).FRelatedList);
  end;
  if (TFhirObservation(oSource).FComponentList = nil) then
  begin
    FComponentList.free;
    FComponentList := nil;
  end
  else
  begin
    if FComponentList = nil then
      FComponentList := TFhirObservationComponentList.Create;
    FComponentList.Assign(TFhirObservation(oSource).FComponentList);
  end;
end;

procedure TFhirObservation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
  if (child_name = 'effective[x]') or (child_name = 'effective') Then
     list.add(self.link, 'effective[x]', FEffective.Link);
  if (child_name = 'issued') Then
     list.add(self.link, 'issued', FIssued.Link);
  if (child_name = 'performer') Then
    list.addAll(self, 'performer', FPerformerList);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
  if (child_name = 'dataAbsentReason') Then
     list.add(self.link, 'dataAbsentReason', FDataAbsentReason.Link);
  if (child_name = 'interpretation') Then
     list.add(self.link, 'interpretation', FInterpretation.Link);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
  if (child_name = 'bodySite') Then
     list.add(self.link, 'bodySite', FBodySite.Link);
  if (child_name = 'method') Then
     list.add(self.link, 'method', FMethod.Link);
  if (child_name = 'specimen') Then
     list.add(self.link, 'specimen', FSpecimen.Link);
  if (child_name = 'device') Then
     list.add(self.link, 'device', FDevice.Link);
  if (child_name = 'referenceRange') Then
    list.addAll(self, 'referenceRange', FReferenceRangeList);
  if (child_name = 'related') Then
    list.addAll(self, 'related', FRelatedList);
  if (child_name = 'component') Then
    list.addAll(self, 'component', FComponentList);
end;

procedure TFhirObservation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference(CarePlan|DeviceRequest|ImmunizationRecommendation|MedicationRequest|NutritionOrder|ProcedureRequest|ReferralRequest)', true, TFhirReference{Resource}, FBasedOnList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Group|Device|Location)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'context', 'Reference(Encounter|EpisodeOfCare)', false, TFhirReference{Resource}, FContext.Link));{2}
  oList.add(TFHIRProperty.create(self, 'effective[x]', 'dateTime|Period', false, TFhirType, FEffective.Link));{2}
  oList.add(TFHIRProperty.create(self, 'issued', 'instant', false, TFhirInstant, FIssued.Link));{2}
  oList.add(TFHIRProperty.create(self, 'performer', 'Reference(Practitioner|Organization|Patient|RelatedPerson)', true, TFhirReference{Resource}, FPerformerList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'value[x]', 'Quantity|CodeableConcept|string|boolean|Range|Ratio|SampledData|Attachment|time|dateTime|Period', false, TFhirType, FValue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dataAbsentReason', 'CodeableConcept', false, TFhirCodeableConcept, FDataAbsentReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'interpretation', 'CodeableConcept', false, TFhirCodeableConcept, FInterpretation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'comment', 'string', false, TFhirString, FComment.Link));{2}
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', false, TFhirCodeableConcept, FBodySite.Link));{2}
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', false, TFhirCodeableConcept, FMethod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'specimen', 'Reference(Specimen)', false, TFhirReference{TFhirSpecimen}, FSpecimen.Link));{2}
  oList.add(TFHIRProperty.create(self, 'device', 'Reference(Device|DeviceMetric)', false, TFhirReference{Resource}, FDevice.Link));{2}
  oList.add(TFHIRProperty.create(self, 'referenceRange', '', true, TFhirObservationReferenceRange, FReferenceRangeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'related', '', true, TFhirObservationRelated, FRelatedList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'component', '', true, TFhirObservationComponent, FComponentList.Link)){3};
end;

function TFhirObservation.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirObservationStatusEnum, CODES_TFhirObservationStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'context') then
  begin
    Context := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then
  begin
    Effective := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'issued') then
  begin
    IssuedElement := asInstant(propValue){5a};
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    PerformerList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Boolean', 'Range', 'Ratio', 'SampledData', 'Attachment', 'Time', 'DateTime', 'Period'])) then
  begin
    Value := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'dataAbsentReason') then
  begin
    DataAbsentReason := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'interpretation') then
  begin
    Interpretation := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySite := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'method') then
  begin
    Method := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'specimen') then
  begin
    Specimen := propValue as TFhirReference{TFhirSpecimen}{4b};
    result := propValue;
  end
  else if (propName = 'device') then
  begin
    Device := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'referenceRange') then
  begin
    ReferenceRangeList.add(propValue as TFhirObservationReferenceRange){2a};
    result := propValue;
  end
  else if (propName = 'related') then
  begin
    RelatedList.add(propValue as TFhirObservationRelated){2a};
    result := propValue;
  end
  else if (propName = 'component') then
  begin
    ComponentList.add(propValue as TFhirObservationComponent){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirObservation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'performer') then PerformerList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'referenceRange') then ReferenceRangeList.insertItem(index, propValue as TFhirObservationReferenceRange){2a}
  else if (propName = 'related') then RelatedList.insertItem(index, propValue as TFhirObservationRelated){2a}
  else if (propName = 'component') then ComponentList.insertItem(index, propValue as TFhirObservationComponent){2a}
  else inherited;
end;

function TFhirObservation.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'basedOn') then result := BasedOnList.new(){2}
  else if (propName = 'category') then result := CategoryList.new(){2}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'context') then result := TFhirReference{Resource}.create(){4b}
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Effective'){4x}
  else if (propName = 'issued') then result := TFhirInstant.create() {5b}
  else if (propName = 'performer') then result := PerformerList.new(){2}
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Boolean', 'Range', 'Ratio', 'SampledData', 'Attachment', 'Time', 'DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Value'){4x}
  else if (propName = 'dataAbsentReason') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'interpretation') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'comment') then result := TFhirString.create() {5b}
  else if (propName = 'bodySite') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'method') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'specimen') then result := TFhirReference{TFhirSpecimen}.create(){4b}
  else if (propName = 'device') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'referenceRange') then result := ReferenceRangeList.new(){2}
  else if (propName = 'related') then result := RelatedList.new(){2}
  else if (propName = 'component') then result := ComponentList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirObservation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'context') then result := 'Reference'
  else if (propName = 'effective[x]') then result := 'dateTime|Period'
  else if (propName = 'issued') then result := 'instant'
  else if (propName = 'performer') then result := 'Reference'
  else if (propName = 'value[x]') then result := 'Quantity|CodeableConcept|string|boolean|Range|Ratio|SampledData|Attachment|time|dateTime|Period'
  else if (propName = 'dataAbsentReason') then result := 'CodeableConcept'
  else if (propName = 'interpretation') then result := 'CodeableConcept'
  else if (propName = 'comment') then result := 'string'
  else if (propName = 'bodySite') then result := 'CodeableConcept'
  else if (propName = 'method') then result := 'CodeableConcept'
  else if (propName = 'specimen') then result := 'Reference'
  else if (propName = 'device') then result := 'Reference'
  else if (propName = 'referenceRange') then result := ''
  else if (propName = 'related') then result := ''
  else if (propName = 'component') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirObservation.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value) {2}
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'context') then ContextElement := nil
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then EffectiveElement := nil{4x}
  else if (propName = 'issued') then IssuedElement := nil
  else if (propName = 'performer') then deletePropertyValue('performer', PerformerList, value) {2}
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Boolean', 'Range', 'Ratio', 'SampledData', 'Attachment', 'Time', 'DateTime', 'Period'])) then ValueElement := nil{4x}
  else if (propName = 'dataAbsentReason') then DataAbsentReasonElement := nil
  else if (propName = 'interpretation') then InterpretationElement := nil
  else if (propName = 'comment') then CommentElement := nil
  else if (propName = 'bodySite') then BodySiteElement := nil
  else if (propName = 'method') then MethodElement := nil
  else if (propName = 'specimen') then SpecimenElement := nil
  else if (propName = 'device') then DeviceElement := nil
  else if (propName = 'referenceRange') then deletePropertyValue('referenceRange', ReferenceRangeList, value) {2}
  else if (propName = 'related') then deletePropertyValue('related', RelatedList, value) {2}
  else if (propName = 'component') then deletePropertyValue('component', ComponentList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirObservation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirObservationStatusEnum, CODES_TFhirObservationStatusEnum, new){4}
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new) {2}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'context') then ContextElement := new as TFhirReference{Resource}{4}
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then EffectiveElement := new as TFhirType{4x}
  else if (propName = 'issued') then IssuedElement := asInstant(new){5b}
  else if (propName = 'performer') then replacePropertyValue('performer', PerformerList, existing, new) {2}
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Boolean', 'Range', 'Ratio', 'SampledData', 'Attachment', 'Time', 'DateTime', 'Period'])) then ValueElement := new as TFhirType{4x}
  else if (propName = 'dataAbsentReason') then DataAbsentReasonElement := new as TFhirCodeableConcept{4}
  else if (propName = 'interpretation') then InterpretationElement := new as TFhirCodeableConcept{4}
  else if (propName = 'comment') then CommentElement := asString(new){5b}
  else if (propName = 'bodySite') then BodySiteElement := new as TFhirCodeableConcept{4}
  else if (propName = 'method') then MethodElement := new as TFhirCodeableConcept{4}
  else if (propName = 'specimen') then SpecimenElement := new as TFhirReference{TFhirSpecimen}{4}
  else if (propName = 'device') then DeviceElement := new as TFhirReference{Resource}{4}
  else if (propName = 'referenceRange') then replacePropertyValue('referenceRange', ReferenceRangeList, existing, new) {2}
  else if (propName = 'related') then replacePropertyValue('related', RelatedList, existing, new) {2}
  else if (propName = 'component') then replacePropertyValue('component', ComponentList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirObservation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'basedOn') then BasedOnList.move(source, destination){2a}
  else if (propName = 'category') then CategoryList.move(source, destination){2a}
  else if (propName = 'performer') then PerformerList.move(source, destination){2a}
  else if (propName = 'referenceRange') then ReferenceRangeList.move(source, destination){2a}
  else if (propName = 'related') then RelatedList.move(source, destination){2a}
  else if (propName = 'component') then ComponentList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirObservation.fhirType : string;
begin
  result := 'Observation';
end;

function TFhirObservation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FbasedOnList) and isEmptyProp(FStatus) and isEmptyProp(FcategoryList) and isEmptyProp(FCode) and isEmptyProp(FSubject) and isEmptyProp(FContext) and isEmptyProp(FEffective) and isEmptyProp(FIssued) and isEmptyProp(FperformerList) and isEmptyProp(FValue) and isEmptyProp(FDataAbsentReason) and isEmptyProp(FInterpretation) and isEmptyProp(FComment) and isEmptyProp(FBodySite) and isEmptyProp(FMethod) and isEmptyProp(FSpecimen) and isEmptyProp(FDevice) and isEmptyProp(FreferenceRangeList) and isEmptyProp(FrelatedList) and isEmptyProp(FcomponentList);
end;

function TFhirObservation.equals(other : TObject) : boolean;
var
  o : TFhirObservation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirObservation)) then
    result := false
  else
  begin
    o := TFhirObservation(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(basedOnList, o.basedOnList, true) and
      compareDeep(statusElement, o.statusElement, true) and compareDeep(categoryList, o.categoryList, true) and
      compareDeep(codeElement, o.codeElement, true) and compareDeep(subjectElement, o.subjectElement, true) and
      compareDeep(contextElement, o.contextElement, true) and compareDeep(effectiveElement, o.effectiveElement, true) and
      compareDeep(issuedElement, o.issuedElement, true) and compareDeep(performerList, o.performerList, true) and
      compareDeep(valueElement, o.valueElement, true) and compareDeep(dataAbsentReasonElement, o.dataAbsentReasonElement, true) and
      compareDeep(interpretationElement, o.interpretationElement, true) and compareDeep(commentElement, o.commentElement, true) and
      compareDeep(bodySiteElement, o.bodySiteElement, true) and compareDeep(methodElement, o.methodElement, true) and
      compareDeep(specimenElement, o.specimenElement, true) and compareDeep(deviceElement, o.deviceElement, true) and
      compareDeep(referenceRangeList, o.referenceRangeList, true) and compareDeep(relatedList, o.relatedList, true) and
      compareDeep(componentList, o.componentList, true);
  end;
end;

function TFhirObservation.Link : TFhirObservation;
begin
  result := TFhirObservation(inherited Link);
end;

function TFhirObservation.Clone : TFhirObservation;
begin
  result := TFhirObservation(inherited Clone);
end;

procedure TFhirObservation.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('basedOn');
  fields.add('status');
  fields.add('category');
  fields.add('code');
  fields.add('subject');
  fields.add('context');
  fields.add('effective[x]');
  fields.add('issued');
  fields.add('performer');
  fields.add('value[x]');
  fields.add('dataAbsentReason');
  fields.add('interpretation');
  fields.add('comment');
  fields.add('bodySite');
  fields.add('method');
  fields.add('specimen');
  fields.add('device');
  fields.add('referenceRange');
  fields.add('related');
  fields.add('component');
end;

{ TFhirObservation }

Function TFhirObservation.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirObservation.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Function TFhirObservation.GetBasedOnList : TFhirReferenceList{Resource};
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList{Resource}.Create;
  result := FBasedOnList;
end;

Function TFhirObservation.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

Procedure TFhirObservation.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirObservation.GetStatusST : TFhirObservationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirObservationStatusEnum(0)
  else
    result := TFhirObservationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirObservationStatusEnum, FStatus.value));
end;

Procedure TFhirObservation.SetStatusST(value : TFhirObservationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirObservationStatusEnum[value], CODES_TFhirObservationStatusEnum[value]);
end;

Function TFhirObservation.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

Function TFhirObservation.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

Procedure TFhirObservation.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirObservation.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirObservation.SetContext(value : TFhirReference{Resource});
begin
  FContext.free;
  FContext := value;
end;

Procedure TFhirObservation.SetEffective(value : TFhirType);
begin
  FEffective.free;
  FEffective := value;
end;

Procedure TFhirObservation.SetIssued(value : TFhirInstant);
begin
  FIssued.free;
  FIssued := value;
end;

Function TFhirObservation.GetIssuedST : TFslDateTime;
begin
  if FIssued = nil then
    result := TFslDateTime.makeNull
  else
    result := FIssued.value;
end;

Procedure TFhirObservation.SetIssuedST(value : TFslDateTime);
begin
  if FIssued = nil then
    FIssued := TFhirInstant.create;
  FIssued.value := value
end;

Function TFhirObservation.GetPerformerList : TFhirReferenceList{Resource};
begin
  if FPerformerList = nil then
    FPerformerList := TFhirReferenceList{Resource}.Create;
  result := FPerformerList;
end;

Function TFhirObservation.GetHasPerformerList : boolean;
begin
  result := (FPerformerList <> nil) and (FPerformerList.count > 0);
end;

Procedure TFhirObservation.SetValue(value : TFhirType);
begin
  FValue.free;
  FValue := value;
end;

Procedure TFhirObservation.SetDataAbsentReason(value : TFhirCodeableConcept);
begin
  FDataAbsentReason.free;
  FDataAbsentReason := value;
end;

Procedure TFhirObservation.SetInterpretation(value : TFhirCodeableConcept);
begin
  FInterpretation.free;
  FInterpretation := value;
end;

Procedure TFhirObservation.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value;
end;

Function TFhirObservation.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

Procedure TFhirObservation.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

Procedure TFhirObservation.SetBodySite(value : TFhirCodeableConcept);
begin
  FBodySite.free;
  FBodySite := value;
end;

Procedure TFhirObservation.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value;
end;

Procedure TFhirObservation.SetSpecimen(value : TFhirReference{TFhirSpecimen});
begin
  FSpecimen.free;
  FSpecimen := value;
end;

Procedure TFhirObservation.SetDevice(value : TFhirReference{Resource});
begin
  FDevice.free;
  FDevice := value;
end;

Function TFhirObservation.GetReferenceRangeList : TFhirObservationReferenceRangeList;
begin
  if FReferenceRangeList = nil then
    FReferenceRangeList := TFhirObservationReferenceRangeList.Create;
  result := FReferenceRangeList;
end;

Function TFhirObservation.GetHasReferenceRangeList : boolean;
begin
  result := (FReferenceRangeList <> nil) and (FReferenceRangeList.count > 0);
end;

Function TFhirObservation.GetRelatedList : TFhirObservationRelatedList;
begin
  if FRelatedList = nil then
    FRelatedList := TFhirObservationRelatedList.Create;
  result := FRelatedList;
end;

Function TFhirObservation.GetHasRelatedList : boolean;
begin
  result := (FRelatedList <> nil) and (FRelatedList.count > 0);
end;

Function TFhirObservation.GetComponentList : TFhirObservationComponentList;
begin
  if FComponentList = nil then
    FComponentList := TFhirObservationComponentList.Create;
  result := FComponentList;
end;

Function TFhirObservation.GetHasComponentList : boolean;
begin
  result := (FComponentList <> nil) and (FComponentList.count > 0);
end;

function TFhirObservation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FbasedOnList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FcategoryList.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FContext.sizeInBytes);
  inc(result, FEffective.sizeInBytes);
  inc(result, FIssued.sizeInBytes);
  inc(result, FperformerList.sizeInBytes);
  inc(result, FValue.sizeInBytes);
  inc(result, FDataAbsentReason.sizeInBytes);
  inc(result, FInterpretation.sizeInBytes);
  inc(result, FComment.sizeInBytes);
  inc(result, FBodySite.sizeInBytes);
  inc(result, FMethod.sizeInBytes);
  inc(result, FSpecimen.sizeInBytes);
  inc(result, FDevice.sizeInBytes);
  inc(result, FreferenceRangeList.sizeInBytes);
  inc(result, FrelatedList.sizeInBytes);
  inc(result, FcomponentList.sizeInBytes);
end;

{ TFhirObservationListEnumerator }

Constructor TFhirObservationListEnumerator.Create(list : TFhirObservationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirObservationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirObservationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirObservationListEnumerator.GetCurrent : TFhirObservation;
begin
  Result := FList[FIndex];
end;

function TFhirObservationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirObservationList }
procedure TFhirObservationList.AddItem(value: TFhirObservation);
begin
  assert(value.ClassName = 'TFhirObservation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirObservation');
  add(value);
end;

function TFhirObservationList.Append: TFhirObservation;
begin
  result := TFhirObservation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirObservationList.ClearItems;
begin
  Clear;
end;

function TFhirObservationList.GetEnumerator : TFhirObservationListEnumerator;
begin
  result := TFhirObservationListEnumerator.Create(self.link);
end;

function TFhirObservationList.Clone: TFhirObservationList;
begin
  result := TFhirObservationList(inherited Clone);
end;

function TFhirObservationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirObservationList.GetItemN(index: Integer): TFhirObservation;
begin
  result := TFhirObservation(ObjectByIndex[index]);
end;

function TFhirObservationList.ItemClass: TFslObjectClass;
begin
  result := TFhirObservation;
end;
function TFhirObservationList.IndexOf(value: TFhirObservation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirObservationList.Insert(index: Integer): TFhirObservation;
begin
  result := TFhirObservation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirObservationList.InsertItem(index: Integer; value: TFhirObservation);
begin
  assert(value is TFhirObservation);
  Inherited Insert(index, value);
end;

function TFhirObservationList.Item(index: Integer): TFhirObservation;
begin
  result := TFhirObservation(ObjectByIndex[index]);
end;

function TFhirObservationList.Link: TFhirObservationList;
begin
  result := TFhirObservationList(inherited Link);
end;

procedure TFhirObservationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirObservationList.SetItemByIndex(index: Integer; value: TFhirObservation);
begin
  assert(value is TFhirObservation);
  FhirObservations[index] := value;
end;

procedure TFhirObservationList.SetItemN(index: Integer; value: TFhirObservation);
begin
  assert(value is TFhirObservation);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_OBSERVATION}

{$IFDEF FHIR_PROCEDURE}

{ TFhirProcedurePerformer }

constructor TFhirProcedurePerformer.Create;
begin
  inherited;
end;

destructor TFhirProcedurePerformer.Destroy;
begin
  FRole.free;
  FActor.free;
  FOnBehalfOf.free;
  inherited;
end;

procedure TFhirProcedurePerformer.Assign(oSource : TFslObject);
begin
  inherited;
  role := TFhirProcedurePerformer(oSource).role.Clone;
  actor := TFhirProcedurePerformer(oSource).actor.Clone;
  onBehalfOf := TFhirProcedurePerformer(oSource).onBehalfOf.Clone;
end;

procedure TFhirProcedurePerformer.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'actor') Then
     list.add(self.link, 'actor', FActor.Link);
  if (child_name = 'onBehalfOf') Then
     list.add(self.link, 'onBehalfOf', FOnBehalfOf.Link);
end;

procedure TFhirProcedurePerformer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));{2}
  oList.add(TFHIRProperty.create(self, 'actor', 'Reference(Practitioner|Organization|Patient|RelatedPerson|Device)', false, TFhirReference{Resource}, FActor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'onBehalfOf', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FOnBehalfOf.Link));{2}
end;

function TFhirProcedurePerformer.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    Actor := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'onBehalfOf') then
  begin
    OnBehalfOf := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirProcedurePerformer.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirProcedurePerformer.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'role') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'actor') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'onBehalfOf') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirProcedurePerformer.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'actor') then result := 'Reference'
  else if (propName = 'onBehalfOf') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirProcedurePerformer.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := nil
  else if (propName = 'actor') then ActorElement := nil
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirProcedurePerformer.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := new as TFhirCodeableConcept{4}
  else if (propName = 'actor') then ActorElement := new as TFhirReference{Resource}{4}
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := new as TFhirReference{TFhirOrganization}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirProcedurePerformer.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirProcedurePerformer.fhirType : string;
begin
  result := 'performer';
end;

function TFhirProcedurePerformer.Link : TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer(inherited Link);
end;

function TFhirProcedurePerformer.Clone : TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer(inherited Clone);
end;

function TFhirProcedurePerformer.equals(other : TObject) : boolean;
var
  o : TFhirProcedurePerformer;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirProcedurePerformer)) then
    result := false
  else
  begin
    o := TFhirProcedurePerformer(other);
    result := compareDeep(roleElement, o.roleElement, true) and compareDeep(actorElement, o.actorElement, true) and
      compareDeep(onBehalfOfElement, o.onBehalfOfElement, true);
  end;
end;

function TFhirProcedurePerformer.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRole) and isEmptyProp(FActor) and isEmptyProp(FOnBehalfOf);
end;

procedure TFhirProcedurePerformer.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('role');
  fields.add('actor');
  fields.add('onBehalfOf');
end;

{ TFhirProcedurePerformer }

Procedure TFhirProcedurePerformer.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

Procedure TFhirProcedurePerformer.SetActor(value : TFhirReference{Resource});
begin
  FActor.free;
  FActor := value;
end;

Procedure TFhirProcedurePerformer.SetOnBehalfOf(value : TFhirReference{TFhirOrganization});
begin
  FOnBehalfOf.free;
  FOnBehalfOf := value;
end;

function TFhirProcedurePerformer.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FRole.sizeInBytes);
  inc(result, FActor.sizeInBytes);
  inc(result, FOnBehalfOf.sizeInBytes);
end;

{ TFhirProcedurePerformerListEnumerator }

Constructor TFhirProcedurePerformerListEnumerator.Create(list : TFhirProcedurePerformerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirProcedurePerformerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProcedurePerformerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirProcedurePerformerListEnumerator.GetCurrent : TFhirProcedurePerformer;
begin
  Result := FList[FIndex];
end;

function TFhirProcedurePerformerListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirProcedurePerformerList }
procedure TFhirProcedurePerformerList.AddItem(value: TFhirProcedurePerformer);
begin
  assert(value.ClassName = 'TFhirProcedurePerformer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProcedurePerformer');
  add(value);
end;

function TFhirProcedurePerformerList.Append: TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcedurePerformerList.ClearItems;
begin
  Clear;
end;

function TFhirProcedurePerformerList.GetEnumerator : TFhirProcedurePerformerListEnumerator;
begin
  result := TFhirProcedurePerformerListEnumerator.Create(self.link);
end;

function TFhirProcedurePerformerList.Clone: TFhirProcedurePerformerList;
begin
  result := TFhirProcedurePerformerList(inherited Clone);
end;

function TFhirProcedurePerformerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProcedurePerformerList.GetItemN(index: Integer): TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer(ObjectByIndex[index]);
end;

function TFhirProcedurePerformerList.ItemClass: TFslObjectClass;
begin
  result := TFhirProcedurePerformer;
end;
function TFhirProcedurePerformerList.IndexOf(value: TFhirProcedurePerformer): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirProcedurePerformerList.Insert(index: Integer): TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcedurePerformerList.InsertItem(index: Integer; value: TFhirProcedurePerformer);
begin
  assert(value is TFhirProcedurePerformer);
  Inherited Insert(index, value);
end;

function TFhirProcedurePerformerList.Item(index: Integer): TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer(ObjectByIndex[index]);
end;

function TFhirProcedurePerformerList.Link: TFhirProcedurePerformerList;
begin
  result := TFhirProcedurePerformerList(inherited Link);
end;

procedure TFhirProcedurePerformerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProcedurePerformerList.SetItemByIndex(index: Integer; value: TFhirProcedurePerformer);
begin
  assert(value is TFhirProcedurePerformer);
  FhirProcedurePerformers[index] := value;
end;

procedure TFhirProcedurePerformerList.SetItemN(index: Integer; value: TFhirProcedurePerformer);
begin
  assert(value is TFhirProcedurePerformer);
  ObjectByIndex[index] := value;
end;

{ TFhirProcedureFocalDevice }

constructor TFhirProcedureFocalDevice.Create;
begin
  inherited;
end;

destructor TFhirProcedureFocalDevice.Destroy;
begin
  FAction.free;
  FManipulated.free;
  inherited;
end;

procedure TFhirProcedureFocalDevice.Assign(oSource : TFslObject);
begin
  inherited;
  action := TFhirProcedureFocalDevice(oSource).action.Clone;
  manipulated := TFhirProcedureFocalDevice(oSource).manipulated.Clone;
end;

procedure TFhirProcedureFocalDevice.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'action') Then
     list.add(self.link, 'action', FAction.Link);
  if (child_name = 'manipulated') Then
     list.add(self.link, 'manipulated', FManipulated.Link);
end;

procedure TFhirProcedureFocalDevice.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'action', 'CodeableConcept', false, TFhirCodeableConcept, FAction.Link));{2}
  oList.add(TFHIRProperty.create(self, 'manipulated', 'Reference(Device)', false, TFhirReference{TFhirDevice}, FManipulated.Link));{2}
end;

function TFhirProcedureFocalDevice.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'action') then
  begin
    Action := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'manipulated') then
  begin
    Manipulated := propValue as TFhirReference{TFhirDevice}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirProcedureFocalDevice.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirProcedureFocalDevice.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'action') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'manipulated') then result := TFhirReference{TFhirDevice}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirProcedureFocalDevice.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'action') then result := 'CodeableConcept'
  else if (propName = 'manipulated') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirProcedureFocalDevice.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'action') then ActionElement := nil
  else if (propName = 'manipulated') then ManipulatedElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirProcedureFocalDevice.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'action') then ActionElement := new as TFhirCodeableConcept{4}
  else if (propName = 'manipulated') then ManipulatedElement := new as TFhirReference{TFhirDevice}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirProcedureFocalDevice.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirProcedureFocalDevice.fhirType : string;
begin
  result := 'focalDevice';
end;

function TFhirProcedureFocalDevice.Link : TFhirProcedureFocalDevice;
begin
  result := TFhirProcedureFocalDevice(inherited Link);
end;

function TFhirProcedureFocalDevice.Clone : TFhirProcedureFocalDevice;
begin
  result := TFhirProcedureFocalDevice(inherited Clone);
end;

function TFhirProcedureFocalDevice.equals(other : TObject) : boolean;
var
  o : TFhirProcedureFocalDevice;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirProcedureFocalDevice)) then
    result := false
  else
  begin
    o := TFhirProcedureFocalDevice(other);
    result := compareDeep(actionElement, o.actionElement, true) and compareDeep(manipulatedElement, o.manipulatedElement, true);
  end;
end;

function TFhirProcedureFocalDevice.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAction) and isEmptyProp(FManipulated);
end;

procedure TFhirProcedureFocalDevice.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('action');
  fields.add('manipulated');
end;

{ TFhirProcedureFocalDevice }

Procedure TFhirProcedureFocalDevice.SetAction(value : TFhirCodeableConcept);
begin
  FAction.free;
  FAction := value;
end;

Procedure TFhirProcedureFocalDevice.SetManipulated(value : TFhirReference{TFhirDevice});
begin
  FManipulated.free;
  FManipulated := value;
end;

function TFhirProcedureFocalDevice.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FAction.sizeInBytes);
  inc(result, FManipulated.sizeInBytes);
end;

{ TFhirProcedureFocalDeviceListEnumerator }

Constructor TFhirProcedureFocalDeviceListEnumerator.Create(list : TFhirProcedureFocalDeviceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirProcedureFocalDeviceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProcedureFocalDeviceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirProcedureFocalDeviceListEnumerator.GetCurrent : TFhirProcedureFocalDevice;
begin
  Result := FList[FIndex];
end;

function TFhirProcedureFocalDeviceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirProcedureFocalDeviceList }
procedure TFhirProcedureFocalDeviceList.AddItem(value: TFhirProcedureFocalDevice);
begin
  assert(value.ClassName = 'TFhirProcedureFocalDevice', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProcedureFocalDevice');
  add(value);
end;

function TFhirProcedureFocalDeviceList.Append: TFhirProcedureFocalDevice;
begin
  result := TFhirProcedureFocalDevice.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcedureFocalDeviceList.ClearItems;
begin
  Clear;
end;

function TFhirProcedureFocalDeviceList.GetEnumerator : TFhirProcedureFocalDeviceListEnumerator;
begin
  result := TFhirProcedureFocalDeviceListEnumerator.Create(self.link);
end;

function TFhirProcedureFocalDeviceList.Clone: TFhirProcedureFocalDeviceList;
begin
  result := TFhirProcedureFocalDeviceList(inherited Clone);
end;

function TFhirProcedureFocalDeviceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProcedureFocalDeviceList.GetItemN(index: Integer): TFhirProcedureFocalDevice;
begin
  result := TFhirProcedureFocalDevice(ObjectByIndex[index]);
end;

function TFhirProcedureFocalDeviceList.ItemClass: TFslObjectClass;
begin
  result := TFhirProcedureFocalDevice;
end;
function TFhirProcedureFocalDeviceList.IndexOf(value: TFhirProcedureFocalDevice): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirProcedureFocalDeviceList.Insert(index: Integer): TFhirProcedureFocalDevice;
begin
  result := TFhirProcedureFocalDevice.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcedureFocalDeviceList.InsertItem(index: Integer; value: TFhirProcedureFocalDevice);
begin
  assert(value is TFhirProcedureFocalDevice);
  Inherited Insert(index, value);
end;

function TFhirProcedureFocalDeviceList.Item(index: Integer): TFhirProcedureFocalDevice;
begin
  result := TFhirProcedureFocalDevice(ObjectByIndex[index]);
end;

function TFhirProcedureFocalDeviceList.Link: TFhirProcedureFocalDeviceList;
begin
  result := TFhirProcedureFocalDeviceList(inherited Link);
end;

procedure TFhirProcedureFocalDeviceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProcedureFocalDeviceList.SetItemByIndex(index: Integer; value: TFhirProcedureFocalDevice);
begin
  assert(value is TFhirProcedureFocalDevice);
  FhirProcedureFocalDevices[index] := value;
end;

procedure TFhirProcedureFocalDeviceList.SetItemN(index: Integer; value: TFhirProcedureFocalDevice);
begin
  assert(value is TFhirProcedureFocalDevice);
  ObjectByIndex[index] := value;
end;

{ TFhirProcedure }

constructor TFhirProcedure.Create;
begin
  inherited;
end;

destructor TFhirProcedure.Destroy;
begin
  FIdentifierList.Free;
  FDefinitionList.Free;
  FBasedOnList.Free;
  FPartOfList.Free;
  FStatus.free;
  FNotDone.free;
  FNotDoneReason.free;
  FCategory.free;
  FCode.free;
  FSubject.free;
  FContext.free;
  FPerformed.free;
  FPerformerList.Free;
  FLocation.free;
  FReasonCodeList.Free;
  FReasonReferenceList.Free;
  FBodySiteList.Free;
  FOutcome.free;
  FReportList.Free;
  FComplicationList.Free;
  FComplicationDetailList.Free;
  FFollowUpList.Free;
  FNoteList.Free;
  FFocalDeviceList.Free;
  FUsedReferenceList.Free;
  FUsedCodeList.Free;
  inherited;
end;

function TFhirProcedure.GetResourceType : TFhirResourceType;
begin
  result := frtProcedure;
end;

procedure TFhirProcedure.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirProcedure(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirProcedure(oSource).FIdentifierList);
  end;
  if (TFhirProcedure(oSource).FDefinitionList = nil) then
  begin
    FDefinitionList.free;
    FDefinitionList := nil;
  end
  else
  begin
    if FDefinitionList = nil then
      FDefinitionList := TFhirReferenceList{Resource}.Create;
    FDefinitionList.Assign(TFhirProcedure(oSource).FDefinitionList);
  end;
  if (TFhirProcedure(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList{Resource}.Create;
    FBasedOnList.Assign(TFhirProcedure(oSource).FBasedOnList);
  end;
  if (TFhirProcedure(oSource).FPartOfList = nil) then
  begin
    FPartOfList.free;
    FPartOfList := nil;
  end
  else
  begin
    if FPartOfList = nil then
      FPartOfList := TFhirReferenceList{Resource}.Create;
    FPartOfList.Assign(TFhirProcedure(oSource).FPartOfList);
  end;
  FStatus := TFhirProcedure(oSource).FStatus.Link;
  notDoneElement := TFhirProcedure(oSource).notDoneElement.Clone;
  notDoneReason := TFhirProcedure(oSource).notDoneReason.Clone;
  category := TFhirProcedure(oSource).category.Clone;
  code := TFhirProcedure(oSource).code.Clone;
  subject := TFhirProcedure(oSource).subject.Clone;
  context := TFhirProcedure(oSource).context.Clone;
  performed := TFhirProcedure(oSource).performed.Clone;
  if (TFhirProcedure(oSource).FPerformerList = nil) then
  begin
    FPerformerList.free;
    FPerformerList := nil;
  end
  else
  begin
    if FPerformerList = nil then
      FPerformerList := TFhirProcedurePerformerList.Create;
    FPerformerList.Assign(TFhirProcedure(oSource).FPerformerList);
  end;
  location := TFhirProcedure(oSource).location.Clone;
  if (TFhirProcedure(oSource).FReasonCodeList = nil) then
  begin
    FReasonCodeList.free;
    FReasonCodeList := nil;
  end
  else
  begin
    if FReasonCodeList = nil then
      FReasonCodeList := TFhirCodeableConceptList.Create;
    FReasonCodeList.Assign(TFhirProcedure(oSource).FReasonCodeList);
  end;
  if (TFhirProcedure(oSource).FReasonReferenceList = nil) then
  begin
    FReasonReferenceList.free;
    FReasonReferenceList := nil;
  end
  else
  begin
    if FReasonReferenceList = nil then
      FReasonReferenceList := TFhirReferenceList{Resource}.Create;
    FReasonReferenceList.Assign(TFhirProcedure(oSource).FReasonReferenceList);
  end;
  if (TFhirProcedure(oSource).FBodySiteList = nil) then
  begin
    FBodySiteList.free;
    FBodySiteList := nil;
  end
  else
  begin
    if FBodySiteList = nil then
      FBodySiteList := TFhirCodeableConceptList.Create;
    FBodySiteList.Assign(TFhirProcedure(oSource).FBodySiteList);
  end;
  outcome := TFhirProcedure(oSource).outcome.Clone;
  if (TFhirProcedure(oSource).FReportList = nil) then
  begin
    FReportList.free;
    FReportList := nil;
  end
  else
  begin
    if FReportList = nil then
      FReportList := TFhirReferenceList{TFhirDiagnosticReport}.Create;
    FReportList.Assign(TFhirProcedure(oSource).FReportList);
  end;
  if (TFhirProcedure(oSource).FComplicationList = nil) then
  begin
    FComplicationList.free;
    FComplicationList := nil;
  end
  else
  begin
    if FComplicationList = nil then
      FComplicationList := TFhirCodeableConceptList.Create;
    FComplicationList.Assign(TFhirProcedure(oSource).FComplicationList);
  end;
  if (TFhirProcedure(oSource).FComplicationDetailList = nil) then
  begin
    FComplicationDetailList.free;
    FComplicationDetailList := nil;
  end
  else
  begin
    if FComplicationDetailList = nil then
      FComplicationDetailList := TFhirReferenceList{TFhirCondition}.Create;
    FComplicationDetailList.Assign(TFhirProcedure(oSource).FComplicationDetailList);
  end;
  if (TFhirProcedure(oSource).FFollowUpList = nil) then
  begin
    FFollowUpList.free;
    FFollowUpList := nil;
  end
  else
  begin
    if FFollowUpList = nil then
      FFollowUpList := TFhirCodeableConceptList.Create;
    FFollowUpList.Assign(TFhirProcedure(oSource).FFollowUpList);
  end;
  if (TFhirProcedure(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirProcedure(oSource).FNoteList);
  end;
  if (TFhirProcedure(oSource).FFocalDeviceList = nil) then
  begin
    FFocalDeviceList.free;
    FFocalDeviceList := nil;
  end
  else
  begin
    if FFocalDeviceList = nil then
      FFocalDeviceList := TFhirProcedureFocalDeviceList.Create;
    FFocalDeviceList.Assign(TFhirProcedure(oSource).FFocalDeviceList);
  end;
  if (TFhirProcedure(oSource).FUsedReferenceList = nil) then
  begin
    FUsedReferenceList.free;
    FUsedReferenceList := nil;
  end
  else
  begin
    if FUsedReferenceList = nil then
      FUsedReferenceList := TFhirReferenceList{Resource}.Create;
    FUsedReferenceList.Assign(TFhirProcedure(oSource).FUsedReferenceList);
  end;
  if (TFhirProcedure(oSource).FUsedCodeList = nil) then
  begin
    FUsedCodeList.free;
    FUsedCodeList := nil;
  end
  else
  begin
    if FUsedCodeList = nil then
      FUsedCodeList := TFhirCodeableConceptList.Create;
    FUsedCodeList.Assign(TFhirProcedure(oSource).FUsedCodeList);
  end;
end;

procedure TFhirProcedure.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'definition') Then
    list.addAll(self, 'definition', FDefinitionList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'partOf') Then
    list.addAll(self, 'partOf', FPartOfList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'notDone') Then
     list.add(self.link, 'notDone', FNotDone.Link);
  if (child_name = 'notDoneReason') Then
     list.add(self.link, 'notDoneReason', FNotDoneReason.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
  if (child_name = 'performed[x]') or (child_name = 'performed') Then
     list.add(self.link, 'performed[x]', FPerformed.Link);
  if (child_name = 'performer') Then
    list.addAll(self, 'performer', FPerformerList);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'reasonCode') Then
    list.addAll(self, 'reasonCode', FReasonCodeList);
  if (child_name = 'reasonReference') Then
    list.addAll(self, 'reasonReference', FReasonReferenceList);
  if (child_name = 'bodySite') Then
    list.addAll(self, 'bodySite', FBodySiteList);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'report') Then
    list.addAll(self, 'report', FReportList);
  if (child_name = 'complication') Then
    list.addAll(self, 'complication', FComplicationList);
  if (child_name = 'complicationDetail') Then
    list.addAll(self, 'complicationDetail', FComplicationDetailList);
  if (child_name = 'followUp') Then
    list.addAll(self, 'followUp', FFollowUpList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'focalDevice') Then
    list.addAll(self, 'focalDevice', FFocalDeviceList);
  if (child_name = 'usedReference') Then
    list.addAll(self, 'usedReference', FUsedReferenceList);
  if (child_name = 'usedCode') Then
    list.addAll(self, 'usedCode', FUsedCodeList);
end;

procedure TFhirProcedure.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'definition', 'Reference(PlanDefinition|ActivityDefinition|HealthcareService)', true, TFhirReference{Resource}, FDefinitionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference(CarePlan|ProcedureRequest|ReferralRequest)', true, TFhirReference{Resource}, FBasedOnList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference(Procedure|Observation|MedicationAdministration)', true, TFhirReference{Resource}, FPartOfList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'notDone', 'boolean', false, TFhirBoolean, FNotDone.Link));{2}
  oList.add(TFHIRProperty.create(self, 'notDoneReason', 'CodeableConcept', false, TFhirCodeableConcept, FNotDoneReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Group)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'context', 'Reference(Encounter|EpisodeOfCare)', false, TFhirReference{Resource}, FContext.Link));{2}
  oList.add(TFHIRProperty.create(self, 'performed[x]', 'dateTime|Period', false, TFhirType, FPerformed.Link));{2}
  oList.add(TFHIRProperty.create(self, 'performer', '', true, TFhirProcedurePerformer, FPerformerList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'location', 'Reference(Location)', false, TFhirReference{TFhirLocation}, FLocation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reasonCode', 'CodeableConcept', true, TFhirCodeableConcept, FReasonCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reasonReference', 'Reference(Condition|Observation)', true, TFhirReference{Resource}, FReasonReferenceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', true, TFhirCodeableConcept, FBodySiteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'outcome', 'CodeableConcept', false, TFhirCodeableConcept, FOutcome.Link));{2}
  oList.add(TFHIRProperty.create(self, 'report', 'Reference(DiagnosticReport)', true, TFhirReference{TFhirDiagnosticReport}, FReportList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'complication', 'CodeableConcept', true, TFhirCodeableConcept, FComplicationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'complicationDetail', 'Reference(Condition)', true, TFhirReference{TFhirCondition}, FComplicationDetailList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'followUp', 'CodeableConcept', true, TFhirCodeableConcept, FFollowUpList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'focalDevice', '', true, TFhirProcedureFocalDevice, FFocalDeviceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'usedReference', 'Reference(Device|Medication|Substance)', true, TFhirReference{Resource}, FUsedReferenceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'usedCode', 'CodeableConcept', true, TFhirCodeableConcept, FUsedCodeList.Link)){3};
end;

function TFhirProcedure.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'definition') then
  begin
    DefinitionList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOfList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirEventStatusEnum, CODES_TFhirEventStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'notDone') then
  begin
    NotDoneElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'notDoneReason') then
  begin
    NotDoneReason := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'context') then
  begin
    Context := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'performed', ['DateTime', 'Period'])) then
  begin
    Performed := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    PerformerList.add(propValue as TFhirProcedurePerformer){2a};
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirReference{TFhirLocation}{4b};
    result := propValue;
  end
  else if (propName = 'reasonCode') then
  begin
    ReasonCodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'reasonReference') then
  begin
    ReasonReferenceList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySiteList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    Outcome := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'report') then
  begin
    ReportList.add(propValue as TFhirReference{TFhirDiagnosticReport}){2a};
    result := propValue;
  end
  else if (propName = 'complication') then
  begin
    ComplicationList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'complicationDetail') then
  begin
    ComplicationDetailList.add(propValue as TFhirReference{TFhirCondition}){2a};
    result := propValue;
  end
  else if (propName = 'followUp') then
  begin
    FollowUpList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else if (propName = 'focalDevice') then
  begin
    FocalDeviceList.add(propValue as TFhirProcedureFocalDevice){2a};
    result := propValue;
  end
  else if (propName = 'usedReference') then
  begin
    UsedReferenceList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'usedCode') then
  begin
    UsedCodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirProcedure.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'definition') then DefinitionList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'partOf') then PartOfList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'performer') then PerformerList.insertItem(index, propValue as TFhirProcedurePerformer){2a}
  else if (propName = 'reasonCode') then ReasonCodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'reasonReference') then ReasonReferenceList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'bodySite') then BodySiteList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'report') then ReportList.insertItem(index, propValue as TFhirReference{TFhirDiagnosticReport}){2a}
  else if (propName = 'complication') then ComplicationList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'complicationDetail') then ComplicationDetailList.insertItem(index, propValue as TFhirReference{TFhirCondition}){2a}
  else if (propName = 'followUp') then FollowUpList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else if (propName = 'focalDevice') then FocalDeviceList.insertItem(index, propValue as TFhirProcedureFocalDevice){2a}
  else if (propName = 'usedReference') then UsedReferenceList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'usedCode') then UsedCodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirProcedure.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'definition') then result := DefinitionList.new(){2}
  else if (propName = 'basedOn') then result := BasedOnList.new(){2}
  else if (propName = 'partOf') then result := PartOfList.new(){2}
  else if (propName = 'notDone') then result := TFhirBoolean.create() {5b}
  else if (propName = 'notDoneReason') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'context') then result := TFhirReference{Resource}.create(){4b}
  else if (isMatchingName(propName, 'performed', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Performed'){4x}
  else if (propName = 'performer') then result := PerformerList.new(){2}
  else if (propName = 'location') then result := TFhirReference{TFhirLocation}.create(){4b}
  else if (propName = 'reasonCode') then result := ReasonCodeList.new(){2}
  else if (propName = 'reasonReference') then result := ReasonReferenceList.new(){2}
  else if (propName = 'bodySite') then result := BodySiteList.new(){2}
  else if (propName = 'outcome') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'report') then result := ReportList.new(){2}
  else if (propName = 'complication') then result := ComplicationList.new(){2}
  else if (propName = 'complicationDetail') then result := ComplicationDetailList.new(){2}
  else if (propName = 'followUp') then result := FollowUpList.new(){2}
  else if (propName = 'note') then result := NoteList.new(){2}
  else if (propName = 'focalDevice') then result := FocalDeviceList.new(){2}
  else if (propName = 'usedReference') then result := UsedReferenceList.new(){2}
  else if (propName = 'usedCode') then result := UsedCodeList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirProcedure.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'definition') then result := 'Reference'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'notDone') then result := 'boolean'
  else if (propName = 'notDoneReason') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'context') then result := 'Reference'
  else if (propName = 'performed[x]') then result := 'dateTime|Period'
  else if (propName = 'performer') then result := ''
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'reasonCode') then result := 'CodeableConcept'
  else if (propName = 'reasonReference') then result := 'Reference'
  else if (propName = 'bodySite') then result := 'CodeableConcept'
  else if (propName = 'outcome') then result := 'CodeableConcept'
  else if (propName = 'report') then result := 'Reference'
  else if (propName = 'complication') then result := 'CodeableConcept'
  else if (propName = 'complicationDetail') then result := 'Reference'
  else if (propName = 'followUp') then result := 'CodeableConcept'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'focalDevice') then result := ''
  else if (propName = 'usedReference') then result := 'Reference'
  else if (propName = 'usedCode') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirProcedure.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'definition') then deletePropertyValue('definition', DefinitionList, value) {2}
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value) {2}
  else if (propName = 'partOf') then deletePropertyValue('partOf', PartOfList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'notDone') then NotDoneElement := nil
  else if (propName = 'notDoneReason') then NotDoneReasonElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'context') then ContextElement := nil
  else if (isMatchingName(propName, 'performed', ['DateTime', 'Period'])) then PerformedElement := nil{4x}
  else if (propName = 'performer') then deletePropertyValue('performer', PerformerList, value) {2}
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'reasonCode') then deletePropertyValue('reasonCode', ReasonCodeList, value) {2}
  else if (propName = 'reasonReference') then deletePropertyValue('reasonReference', ReasonReferenceList, value) {2}
  else if (propName = 'bodySite') then deletePropertyValue('bodySite', BodySiteList, value) {2}
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'report') then deletePropertyValue('report', ReportList, value) {2}
  else if (propName = 'complication') then deletePropertyValue('complication', ComplicationList, value) {2}
  else if (propName = 'complicationDetail') then deletePropertyValue('complicationDetail', ComplicationDetailList, value) {2}
  else if (propName = 'followUp') then deletePropertyValue('followUp', FollowUpList, value) {2}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else if (propName = 'focalDevice') then deletePropertyValue('focalDevice', FocalDeviceList, value) {2}
  else if (propName = 'usedReference') then deletePropertyValue('usedReference', UsedReferenceList, value) {2}
  else if (propName = 'usedCode') then deletePropertyValue('usedCode', UsedCodeList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirProcedure.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'definition') then replacePropertyValue('definition', DefinitionList, existing, new) {2}
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new) {2}
  else if (propName = 'partOf') then replacePropertyValue('partOf', PartOfList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirEventStatusEnum, CODES_TFhirEventStatusEnum, new){4}
  else if (propName = 'notDone') then NotDoneElement := asBoolean(new){5b}
  else if (propName = 'notDoneReason') then NotDoneReasonElement := new as TFhirCodeableConcept{4}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'context') then ContextElement := new as TFhirReference{Resource}{4}
  else if (isMatchingName(propName, 'performed', ['DateTime', 'Period'])) then PerformedElement := new as TFhirType{4x}
  else if (propName = 'performer') then replacePropertyValue('performer', PerformerList, existing, new) {2}
  else if (propName = 'location') then LocationElement := new as TFhirReference{TFhirLocation}{4}
  else if (propName = 'reasonCode') then replacePropertyValue('reasonCode', ReasonCodeList, existing, new) {2}
  else if (propName = 'reasonReference') then replacePropertyValue('reasonReference', ReasonReferenceList, existing, new) {2}
  else if (propName = 'bodySite') then replacePropertyValue('bodySite', BodySiteList, existing, new) {2}
  else if (propName = 'outcome') then OutcomeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'report') then replacePropertyValue('report', ReportList, existing, new) {2}
  else if (propName = 'complication') then replacePropertyValue('complication', ComplicationList, existing, new) {2}
  else if (propName = 'complicationDetail') then replacePropertyValue('complicationDetail', ComplicationDetailList, existing, new) {2}
  else if (propName = 'followUp') then replacePropertyValue('followUp', FollowUpList, existing, new) {2}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else if (propName = 'focalDevice') then replacePropertyValue('focalDevice', FocalDeviceList, existing, new) {2}
  else if (propName = 'usedReference') then replacePropertyValue('usedReference', UsedReferenceList, existing, new) {2}
  else if (propName = 'usedCode') then replacePropertyValue('usedCode', UsedCodeList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirProcedure.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'definition') then DefinitionList.move(source, destination){2a}
  else if (propName = 'basedOn') then BasedOnList.move(source, destination){2a}
  else if (propName = 'partOf') then PartOfList.move(source, destination){2a}
  else if (propName = 'performer') then PerformerList.move(source, destination){2a}
  else if (propName = 'reasonCode') then ReasonCodeList.move(source, destination){2a}
  else if (propName = 'reasonReference') then ReasonReferenceList.move(source, destination){2a}
  else if (propName = 'bodySite') then BodySiteList.move(source, destination){2a}
  else if (propName = 'report') then ReportList.move(source, destination){2a}
  else if (propName = 'complication') then ComplicationList.move(source, destination){2a}
  else if (propName = 'complicationDetail') then ComplicationDetailList.move(source, destination){2a}
  else if (propName = 'followUp') then FollowUpList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else if (propName = 'focalDevice') then FocalDeviceList.move(source, destination){2a}
  else if (propName = 'usedReference') then UsedReferenceList.move(source, destination){2a}
  else if (propName = 'usedCode') then UsedCodeList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirProcedure.fhirType : string;
begin
  result := 'Procedure';
end;

function TFhirProcedure.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FdefinitionList) and isEmptyProp(FbasedOnList) and isEmptyProp(FpartOfList) and isEmptyProp(FStatus) and isEmptyProp(FNotDone) and isEmptyProp(FNotDoneReason) and isEmptyProp(FCategory) and isEmptyProp(FCode) and isEmptyProp(FSubject) and isEmptyProp(FContext) and isEmptyProp(FPerformed) and isEmptyProp(FperformerList) and isEmptyProp(FLocation) and isEmptyProp(FreasonCodeList) and isEmptyProp(FreasonReferenceList) and isEmptyProp(FbodySiteList) and isEmptyProp(FOutcome) and isEmptyProp(FreportList) and isEmptyProp(FcomplicationList) and isEmptyProp(FcomplicationDetailList) and isEmptyProp(FfollowUpList) and isEmptyProp(FnoteList) and isEmptyProp(FfocalDeviceList) and isEmptyProp(FusedReferenceList) and isEmptyProp(FusedCodeList);
end;

function TFhirProcedure.equals(other : TObject) : boolean;
var
  o : TFhirProcedure;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirProcedure)) then
    result := false
  else
  begin
    o := TFhirProcedure(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(definitionList, o.definitionList, true) and
      compareDeep(basedOnList, o.basedOnList, true) and compareDeep(partOfList, o.partOfList, true) and
      compareDeep(statusElement, o.statusElement, true) and compareDeep(notDoneElement, o.notDoneElement, true) and
      compareDeep(notDoneReasonElement, o.notDoneReasonElement, true) and compareDeep(categoryElement, o.categoryElement, true) and
      compareDeep(codeElement, o.codeElement, true) and compareDeep(subjectElement, o.subjectElement, true) and
      compareDeep(contextElement, o.contextElement, true) and compareDeep(performedElement, o.performedElement, true) and
      compareDeep(performerList, o.performerList, true) and compareDeep(locationElement, o.locationElement, true) and
      compareDeep(reasonCodeList, o.reasonCodeList, true) and compareDeep(reasonReferenceList, o.reasonReferenceList, true) and
      compareDeep(bodySiteList, o.bodySiteList, true) and compareDeep(outcomeElement, o.outcomeElement, true) and
      compareDeep(reportList, o.reportList, true) and compareDeep(complicationList, o.complicationList, true) and
      compareDeep(complicationDetailList, o.complicationDetailList, true) and compareDeep(followUpList, o.followUpList, true) and
      compareDeep(noteList, o.noteList, true) and compareDeep(focalDeviceList, o.focalDeviceList, true) and
      compareDeep(usedReferenceList, o.usedReferenceList, true) and compareDeep(usedCodeList, o.usedCodeList, true);
  end;
end;

function TFhirProcedure.Link : TFhirProcedure;
begin
  result := TFhirProcedure(inherited Link);
end;

function TFhirProcedure.Clone : TFhirProcedure;
begin
  result := TFhirProcedure(inherited Clone);
end;

procedure TFhirProcedure.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('definition');
  fields.add('basedOn');
  fields.add('partOf');
  fields.add('status');
  fields.add('notDone');
  fields.add('notDoneReason');
  fields.add('category');
  fields.add('code');
  fields.add('subject');
  fields.add('context');
  fields.add('performed[x]');
  fields.add('performer');
  fields.add('location');
  fields.add('reasonCode');
  fields.add('reasonReference');
  fields.add('bodySite');
  fields.add('outcome');
  fields.add('report');
  fields.add('complication');
  fields.add('complicationDetail');
  fields.add('followUp');
  fields.add('note');
  fields.add('focalDevice');
  fields.add('usedReference');
  fields.add('usedCode');
end;

{ TFhirProcedure }

Function TFhirProcedure.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirProcedure.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Function TFhirProcedure.GetDefinitionList : TFhirReferenceList{Resource};
begin
  if FDefinitionList = nil then
    FDefinitionList := TFhirReferenceList{Resource}.Create;
  result := FDefinitionList;
end;

Function TFhirProcedure.GetHasDefinitionList : boolean;
begin
  result := (FDefinitionList <> nil) and (FDefinitionList.count > 0);
end;

Function TFhirProcedure.GetBasedOnList : TFhirReferenceList{Resource};
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList{Resource}.Create;
  result := FBasedOnList;
end;

Function TFhirProcedure.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

Function TFhirProcedure.GetPartOfList : TFhirReferenceList{Resource};
begin
  if FPartOfList = nil then
    FPartOfList := TFhirReferenceList{Resource}.Create;
  result := FPartOfList;
end;

Function TFhirProcedure.GetHasPartOfList : boolean;
begin
  result := (FPartOfList <> nil) and (FPartOfList.count > 0);
end;

Procedure TFhirProcedure.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirProcedure.GetStatusST : TFhirEventStatusEnum;
begin
  if FStatus = nil then
    result := TFhirEventStatusEnum(0)
  else
    result := TFhirEventStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirEventStatusEnum, FStatus.value));
end;

Procedure TFhirProcedure.SetStatusST(value : TFhirEventStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirEventStatusEnum[value], CODES_TFhirEventStatusEnum[value]);
end;

Procedure TFhirProcedure.SetNotDone(value : TFhirBoolean);
begin
  FNotDone.free;
  FNotDone := value;
end;

Function TFhirProcedure.GetNotDoneST : Boolean;
begin
  if FNotDone = nil then
    result := false
  else
    result := FNotDone.value;
end;

Procedure TFhirProcedure.SetNotDoneST(value : Boolean);
begin
  if FNotDone = nil then
    FNotDone := TFhirBoolean.create;
  FNotDone.value := value
end;

Procedure TFhirProcedure.SetNotDoneReason(value : TFhirCodeableConcept);
begin
  FNotDoneReason.free;
  FNotDoneReason := value;
end;

Procedure TFhirProcedure.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirProcedure.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirProcedure.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirProcedure.SetContext(value : TFhirReference{Resource});
begin
  FContext.free;
  FContext := value;
end;

Procedure TFhirProcedure.SetPerformed(value : TFhirType);
begin
  FPerformed.free;
  FPerformed := value;
end;

Function TFhirProcedure.GetPerformerList : TFhirProcedurePerformerList;
begin
  if FPerformerList = nil then
    FPerformerList := TFhirProcedurePerformerList.Create;
  result := FPerformerList;
end;

Function TFhirProcedure.GetHasPerformerList : boolean;
begin
  result := (FPerformerList <> nil) and (FPerformerList.count > 0);
end;

Procedure TFhirProcedure.SetLocation(value : TFhirReference{TFhirLocation});
begin
  FLocation.free;
  FLocation := value;
end;

Function TFhirProcedure.GetReasonCodeList : TFhirCodeableConceptList;
begin
  if FReasonCodeList = nil then
    FReasonCodeList := TFhirCodeableConceptList.Create;
  result := FReasonCodeList;
end;

Function TFhirProcedure.GetHasReasonCodeList : boolean;
begin
  result := (FReasonCodeList <> nil) and (FReasonCodeList.count > 0);
end;

Function TFhirProcedure.GetReasonReferenceList : TFhirReferenceList{Resource};
begin
  if FReasonReferenceList = nil then
    FReasonReferenceList := TFhirReferenceList{Resource}.Create;
  result := FReasonReferenceList;
end;

Function TFhirProcedure.GetHasReasonReferenceList : boolean;
begin
  result := (FReasonReferenceList <> nil) and (FReasonReferenceList.count > 0);
end;

Function TFhirProcedure.GetBodySiteList : TFhirCodeableConceptList;
begin
  if FBodySiteList = nil then
    FBodySiteList := TFhirCodeableConceptList.Create;
  result := FBodySiteList;
end;

Function TFhirProcedure.GetHasBodySiteList : boolean;
begin
  result := (FBodySiteList <> nil) and (FBodySiteList.count > 0);
end;

Procedure TFhirProcedure.SetOutcome(value : TFhirCodeableConcept);
begin
  FOutcome.free;
  FOutcome := value;
end;

Function TFhirProcedure.GetReportList : TFhirReferenceList{TFhirDiagnosticReport};
begin
  if FReportList = nil then
    FReportList := TFhirReferenceList{TFhirDiagnosticReport}.Create;
  result := FReportList;
end;

Function TFhirProcedure.GetHasReportList : boolean;
begin
  result := (FReportList <> nil) and (FReportList.count > 0);
end;

Function TFhirProcedure.GetComplicationList : TFhirCodeableConceptList;
begin
  if FComplicationList = nil then
    FComplicationList := TFhirCodeableConceptList.Create;
  result := FComplicationList;
end;

Function TFhirProcedure.GetHasComplicationList : boolean;
begin
  result := (FComplicationList <> nil) and (FComplicationList.count > 0);
end;

Function TFhirProcedure.GetComplicationDetailList : TFhirReferenceList{TFhirCondition};
begin
  if FComplicationDetailList = nil then
    FComplicationDetailList := TFhirReferenceList{TFhirCondition}.Create;
  result := FComplicationDetailList;
end;

Function TFhirProcedure.GetHasComplicationDetailList : boolean;
begin
  result := (FComplicationDetailList <> nil) and (FComplicationDetailList.count > 0);
end;

Function TFhirProcedure.GetFollowUpList : TFhirCodeableConceptList;
begin
  if FFollowUpList = nil then
    FFollowUpList := TFhirCodeableConceptList.Create;
  result := FFollowUpList;
end;

Function TFhirProcedure.GetHasFollowUpList : boolean;
begin
  result := (FFollowUpList <> nil) and (FFollowUpList.count > 0);
end;

Function TFhirProcedure.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirProcedure.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

Function TFhirProcedure.GetFocalDeviceList : TFhirProcedureFocalDeviceList;
begin
  if FFocalDeviceList = nil then
    FFocalDeviceList := TFhirProcedureFocalDeviceList.Create;
  result := FFocalDeviceList;
end;

Function TFhirProcedure.GetHasFocalDeviceList : boolean;
begin
  result := (FFocalDeviceList <> nil) and (FFocalDeviceList.count > 0);
end;

Function TFhirProcedure.GetUsedReferenceList : TFhirReferenceList{Resource};
begin
  if FUsedReferenceList = nil then
    FUsedReferenceList := TFhirReferenceList{Resource}.Create;
  result := FUsedReferenceList;
end;

Function TFhirProcedure.GetHasUsedReferenceList : boolean;
begin
  result := (FUsedReferenceList <> nil) and (FUsedReferenceList.count > 0);
end;

Function TFhirProcedure.GetUsedCodeList : TFhirCodeableConceptList;
begin
  if FUsedCodeList = nil then
    FUsedCodeList := TFhirCodeableConceptList.Create;
  result := FUsedCodeList;
end;

Function TFhirProcedure.GetHasUsedCodeList : boolean;
begin
  result := (FUsedCodeList <> nil) and (FUsedCodeList.count > 0);
end;

function TFhirProcedure.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FdefinitionList.sizeInBytes);
  inc(result, FbasedOnList.sizeInBytes);
  inc(result, FpartOfList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FNotDone.sizeInBytes);
  inc(result, FNotDoneReason.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FContext.sizeInBytes);
  inc(result, FPerformed.sizeInBytes);
  inc(result, FperformerList.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
  inc(result, FreasonCodeList.sizeInBytes);
  inc(result, FreasonReferenceList.sizeInBytes);
  inc(result, FbodySiteList.sizeInBytes);
  inc(result, FOutcome.sizeInBytes);
  inc(result, FreportList.sizeInBytes);
  inc(result, FcomplicationList.sizeInBytes);
  inc(result, FcomplicationDetailList.sizeInBytes);
  inc(result, FfollowUpList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FfocalDeviceList.sizeInBytes);
  inc(result, FusedReferenceList.sizeInBytes);
  inc(result, FusedCodeList.sizeInBytes);
end;

{ TFhirProcedureListEnumerator }

Constructor TFhirProcedureListEnumerator.Create(list : TFhirProcedureList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirProcedureListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProcedureListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirProcedureListEnumerator.GetCurrent : TFhirProcedure;
begin
  Result := FList[FIndex];
end;

function TFhirProcedureListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirProcedureList }
procedure TFhirProcedureList.AddItem(value: TFhirProcedure);
begin
  assert(value.ClassName = 'TFhirProcedure', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProcedure');
  add(value);
end;

function TFhirProcedureList.Append: TFhirProcedure;
begin
  result := TFhirProcedure.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcedureList.ClearItems;
begin
  Clear;
end;

function TFhirProcedureList.GetEnumerator : TFhirProcedureListEnumerator;
begin
  result := TFhirProcedureListEnumerator.Create(self.link);
end;

function TFhirProcedureList.Clone: TFhirProcedureList;
begin
  result := TFhirProcedureList(inherited Clone);
end;

function TFhirProcedureList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProcedureList.GetItemN(index: Integer): TFhirProcedure;
begin
  result := TFhirProcedure(ObjectByIndex[index]);
end;

function TFhirProcedureList.ItemClass: TFslObjectClass;
begin
  result := TFhirProcedure;
end;
function TFhirProcedureList.IndexOf(value: TFhirProcedure): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirProcedureList.Insert(index: Integer): TFhirProcedure;
begin
  result := TFhirProcedure.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcedureList.InsertItem(index: Integer; value: TFhirProcedure);
begin
  assert(value is TFhirProcedure);
  Inherited Insert(index, value);
end;

function TFhirProcedureList.Item(index: Integer): TFhirProcedure;
begin
  result := TFhirProcedure(ObjectByIndex[index]);
end;

function TFhirProcedureList.Link: TFhirProcedureList;
begin
  result := TFhirProcedureList(inherited Link);
end;

procedure TFhirProcedureList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProcedureList.SetItemByIndex(index: Integer; value: TFhirProcedure);
begin
  assert(value is TFhirProcedure);
  FhirProcedures[index] := value;
end;

procedure TFhirProcedureList.SetItemN(index: Integer; value: TFhirProcedure);
begin
  assert(value is TFhirProcedure);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PROCEDURE}

{$IFDEF FHIR_PROCEDUREREQUEST}

{ TFhirProcedureRequestRequester }

constructor TFhirProcedureRequestRequester.Create;
begin
  inherited;
end;

destructor TFhirProcedureRequestRequester.Destroy;
begin
  FAgent.free;
  FOnBehalfOf.free;
  inherited;
end;

procedure TFhirProcedureRequestRequester.Assign(oSource : TFslObject);
begin
  inherited;
  agent := TFhirProcedureRequestRequester(oSource).agent.Clone;
  onBehalfOf := TFhirProcedureRequestRequester(oSource).onBehalfOf.Clone;
end;

procedure TFhirProcedureRequestRequester.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'agent') Then
     list.add(self.link, 'agent', FAgent.Link);
  if (child_name = 'onBehalfOf') Then
     list.add(self.link, 'onBehalfOf', FOnBehalfOf.Link);
end;

procedure TFhirProcedureRequestRequester.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'agent', 'Reference(Device|Practitioner|Organization)', false, TFhirReference{Resource}, FAgent.Link));{2}
  oList.add(TFHIRProperty.create(self, 'onBehalfOf', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FOnBehalfOf.Link));{2}
end;

function TFhirProcedureRequestRequester.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'agent') then
  begin
    Agent := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'onBehalfOf') then
  begin
    OnBehalfOf := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirProcedureRequestRequester.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirProcedureRequestRequester.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'agent') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'onBehalfOf') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirProcedureRequestRequester.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'agent') then result := 'Reference'
  else if (propName = 'onBehalfOf') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirProcedureRequestRequester.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'agent') then AgentElement := nil
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirProcedureRequestRequester.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'agent') then AgentElement := new as TFhirReference{Resource}{4}
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := new as TFhirReference{TFhirOrganization}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirProcedureRequestRequester.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirProcedureRequestRequester.fhirType : string;
begin
  result := 'requester';
end;

function TFhirProcedureRequestRequester.Link : TFhirProcedureRequestRequester;
begin
  result := TFhirProcedureRequestRequester(inherited Link);
end;

function TFhirProcedureRequestRequester.Clone : TFhirProcedureRequestRequester;
begin
  result := TFhirProcedureRequestRequester(inherited Clone);
end;

function TFhirProcedureRequestRequester.equals(other : TObject) : boolean;
var
  o : TFhirProcedureRequestRequester;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirProcedureRequestRequester)) then
    result := false
  else
  begin
    o := TFhirProcedureRequestRequester(other);
    result := compareDeep(agentElement, o.agentElement, true) and compareDeep(onBehalfOfElement, o.onBehalfOfElement, true);
  end;
end;

function TFhirProcedureRequestRequester.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAgent) and isEmptyProp(FOnBehalfOf);
end;

procedure TFhirProcedureRequestRequester.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('agent');
  fields.add('onBehalfOf');
end;

{ TFhirProcedureRequestRequester }

Procedure TFhirProcedureRequestRequester.SetAgent(value : TFhirReference{Resource});
begin
  FAgent.free;
  FAgent := value;
end;

Procedure TFhirProcedureRequestRequester.SetOnBehalfOf(value : TFhirReference{TFhirOrganization});
begin
  FOnBehalfOf.free;
  FOnBehalfOf := value;
end;

function TFhirProcedureRequestRequester.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FAgent.sizeInBytes);
  inc(result, FOnBehalfOf.sizeInBytes);
end;

{ TFhirProcedureRequestRequesterListEnumerator }

Constructor TFhirProcedureRequestRequesterListEnumerator.Create(list : TFhirProcedureRequestRequesterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirProcedureRequestRequesterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProcedureRequestRequesterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirProcedureRequestRequesterListEnumerator.GetCurrent : TFhirProcedureRequestRequester;
begin
  Result := FList[FIndex];
end;

function TFhirProcedureRequestRequesterListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirProcedureRequestRequesterList }
procedure TFhirProcedureRequestRequesterList.AddItem(value: TFhirProcedureRequestRequester);
begin
  assert(value.ClassName = 'TFhirProcedureRequestRequester', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProcedureRequestRequester');
  add(value);
end;

function TFhirProcedureRequestRequesterList.Append: TFhirProcedureRequestRequester;
begin
  result := TFhirProcedureRequestRequester.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcedureRequestRequesterList.ClearItems;
begin
  Clear;
end;

function TFhirProcedureRequestRequesterList.GetEnumerator : TFhirProcedureRequestRequesterListEnumerator;
begin
  result := TFhirProcedureRequestRequesterListEnumerator.Create(self.link);
end;

function TFhirProcedureRequestRequesterList.Clone: TFhirProcedureRequestRequesterList;
begin
  result := TFhirProcedureRequestRequesterList(inherited Clone);
end;

function TFhirProcedureRequestRequesterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProcedureRequestRequesterList.GetItemN(index: Integer): TFhirProcedureRequestRequester;
begin
  result := TFhirProcedureRequestRequester(ObjectByIndex[index]);
end;

function TFhirProcedureRequestRequesterList.ItemClass: TFslObjectClass;
begin
  result := TFhirProcedureRequestRequester;
end;
function TFhirProcedureRequestRequesterList.IndexOf(value: TFhirProcedureRequestRequester): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirProcedureRequestRequesterList.Insert(index: Integer): TFhirProcedureRequestRequester;
begin
  result := TFhirProcedureRequestRequester.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcedureRequestRequesterList.InsertItem(index: Integer; value: TFhirProcedureRequestRequester);
begin
  assert(value is TFhirProcedureRequestRequester);
  Inherited Insert(index, value);
end;

function TFhirProcedureRequestRequesterList.Item(index: Integer): TFhirProcedureRequestRequester;
begin
  result := TFhirProcedureRequestRequester(ObjectByIndex[index]);
end;

function TFhirProcedureRequestRequesterList.Link: TFhirProcedureRequestRequesterList;
begin
  result := TFhirProcedureRequestRequesterList(inherited Link);
end;

procedure TFhirProcedureRequestRequesterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProcedureRequestRequesterList.SetItemByIndex(index: Integer; value: TFhirProcedureRequestRequester);
begin
  assert(value is TFhirProcedureRequestRequester);
  FhirProcedureRequestRequesters[index] := value;
end;

procedure TFhirProcedureRequestRequesterList.SetItemN(index: Integer; value: TFhirProcedureRequestRequester);
begin
  assert(value is TFhirProcedureRequestRequester);
  ObjectByIndex[index] := value;
end;

{ TFhirProcedureRequest }

constructor TFhirProcedureRequest.Create;
begin
  inherited;
end;

destructor TFhirProcedureRequest.Destroy;
begin
  FIdentifierList.Free;
  FDefinitionList.Free;
  FBasedOnList.Free;
  FReplacesList.Free;
  FRequisition.free;
  FStatus.free;
  FIntent.free;
  FPriority.free;
  FDoNotPerform.free;
  FCategoryList.Free;
  FCode.free;
  FSubject.free;
  FContext.free;
  FOccurrence.free;
  FAsNeeded.free;
  FAuthoredOn.free;
  FRequester.free;
  FPerformerType.free;
  FPerformer.free;
  FReasonCodeList.Free;
  FReasonReferenceList.Free;
  FSupportingInfoList.Free;
  FSpecimenList.Free;
  FBodySiteList.Free;
  FNoteList.Free;
  FRelevantHistoryList.Free;
  inherited;
end;

function TFhirProcedureRequest.GetResourceType : TFhirResourceType;
begin
  result := frtProcedureRequest;
end;

procedure TFhirProcedureRequest.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirProcedureRequest(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirProcedureRequest(oSource).FIdentifierList);
  end;
  if (TFhirProcedureRequest(oSource).FDefinitionList = nil) then
  begin
    FDefinitionList.free;
    FDefinitionList := nil;
  end
  else
  begin
    if FDefinitionList = nil then
      FDefinitionList := TFhirReferenceList{Resource}.Create;
    FDefinitionList.Assign(TFhirProcedureRequest(oSource).FDefinitionList);
  end;
  if (TFhirProcedureRequest(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList{TFhirReference}.Create;
    FBasedOnList.Assign(TFhirProcedureRequest(oSource).FBasedOnList);
  end;
  if (TFhirProcedureRequest(oSource).FReplacesList = nil) then
  begin
    FReplacesList.free;
    FReplacesList := nil;
  end
  else
  begin
    if FReplacesList = nil then
      FReplacesList := TFhirReferenceList{TFhirReference}.Create;
    FReplacesList.Assign(TFhirProcedureRequest(oSource).FReplacesList);
  end;
  requisition := TFhirProcedureRequest(oSource).requisition.Clone;
  FStatus := TFhirProcedureRequest(oSource).FStatus.Link;
  FIntent := TFhirProcedureRequest(oSource).FIntent.Link;
  FPriority := TFhirProcedureRequest(oSource).FPriority.Link;
  doNotPerformElement := TFhirProcedureRequest(oSource).doNotPerformElement.Clone;
  if (TFhirProcedureRequest(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirProcedureRequest(oSource).FCategoryList);
  end;
  code := TFhirProcedureRequest(oSource).code.Clone;
  subject := TFhirProcedureRequest(oSource).subject.Clone;
  context := TFhirProcedureRequest(oSource).context.Clone;
  occurrence := TFhirProcedureRequest(oSource).occurrence.Clone;
  asNeeded := TFhirProcedureRequest(oSource).asNeeded.Clone;
  authoredOnElement := TFhirProcedureRequest(oSource).authoredOnElement.Clone;
  requester := TFhirProcedureRequest(oSource).requester.Clone;
  performerType := TFhirProcedureRequest(oSource).performerType.Clone;
  performer := TFhirProcedureRequest(oSource).performer.Clone;
  if (TFhirProcedureRequest(oSource).FReasonCodeList = nil) then
  begin
    FReasonCodeList.free;
    FReasonCodeList := nil;
  end
  else
  begin
    if FReasonCodeList = nil then
      FReasonCodeList := TFhirCodeableConceptList.Create;
    FReasonCodeList.Assign(TFhirProcedureRequest(oSource).FReasonCodeList);
  end;
  if (TFhirProcedureRequest(oSource).FReasonReferenceList = nil) then
  begin
    FReasonReferenceList.free;
    FReasonReferenceList := nil;
  end
  else
  begin
    if FReasonReferenceList = nil then
      FReasonReferenceList := TFhirReferenceList{Resource}.Create;
    FReasonReferenceList.Assign(TFhirProcedureRequest(oSource).FReasonReferenceList);
  end;
  if (TFhirProcedureRequest(oSource).FSupportingInfoList = nil) then
  begin
    FSupportingInfoList.free;
    FSupportingInfoList := nil;
  end
  else
  begin
    if FSupportingInfoList = nil then
      FSupportingInfoList := TFhirReferenceList{TFhirReference}.Create;
    FSupportingInfoList.Assign(TFhirProcedureRequest(oSource).FSupportingInfoList);
  end;
  if (TFhirProcedureRequest(oSource).FSpecimenList = nil) then
  begin
    FSpecimenList.free;
    FSpecimenList := nil;
  end
  else
  begin
    if FSpecimenList = nil then
      FSpecimenList := TFhirReferenceList{TFhirSpecimen}.Create;
    FSpecimenList.Assign(TFhirProcedureRequest(oSource).FSpecimenList);
  end;
  if (TFhirProcedureRequest(oSource).FBodySiteList = nil) then
  begin
    FBodySiteList.free;
    FBodySiteList := nil;
  end
  else
  begin
    if FBodySiteList = nil then
      FBodySiteList := TFhirCodeableConceptList.Create;
    FBodySiteList.Assign(TFhirProcedureRequest(oSource).FBodySiteList);
  end;
  if (TFhirProcedureRequest(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirProcedureRequest(oSource).FNoteList);
  end;
  if (TFhirProcedureRequest(oSource).FRelevantHistoryList = nil) then
  begin
    FRelevantHistoryList.free;
    FRelevantHistoryList := nil;
  end
  else
  begin
    if FRelevantHistoryList = nil then
      FRelevantHistoryList := TFhirReferenceList{TFhirProvenance}.Create;
    FRelevantHistoryList.Assign(TFhirProcedureRequest(oSource).FRelevantHistoryList);
  end;
end;

procedure TFhirProcedureRequest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'definition') Then
    list.addAll(self, 'definition', FDefinitionList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'replaces') Then
    list.addAll(self, 'replaces', FReplacesList);
  if (child_name = 'requisition') Then
     list.add(self.link, 'requisition', FRequisition.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'intent') Then
     list.add(self.link, 'intent', FIntent.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'doNotPerform') Then
     list.add(self.link, 'doNotPerform', FDoNotPerform.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
  if (child_name = 'occurrence[x]') or (child_name = 'occurrence') Then
     list.add(self.link, 'occurrence[x]', FOccurrence.Link);
  if (child_name = 'asNeeded[x]') or (child_name = 'asNeeded') Then
     list.add(self.link, 'asNeeded[x]', FAsNeeded.Link);
  if (child_name = 'authoredOn') Then
     list.add(self.link, 'authoredOn', FAuthoredOn.Link);
  if (child_name = 'requester') Then
     list.add(self.link, 'requester', FRequester.Link);
  if (child_name = 'performerType') Then
     list.add(self.link, 'performerType', FPerformerType.Link);
  if (child_name = 'performer') Then
     list.add(self.link, 'performer', FPerformer.Link);
  if (child_name = 'reasonCode') Then
    list.addAll(self, 'reasonCode', FReasonCodeList);
  if (child_name = 'reasonReference') Then
    list.addAll(self, 'reasonReference', FReasonReferenceList);
  if (child_name = 'supportingInfo') Then
    list.addAll(self, 'supportingInfo', FSupportingInfoList);
  if (child_name = 'specimen') Then
    list.addAll(self, 'specimen', FSpecimenList);
  if (child_name = 'bodySite') Then
    list.addAll(self, 'bodySite', FBodySiteList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'relevantHistory') Then
    list.addAll(self, 'relevantHistory', FRelevantHistoryList);
end;

procedure TFhirProcedureRequest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'definition', 'Reference(ActivityDefinition|PlanDefinition)', true, TFhirReference{Resource}, FDefinitionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference(Any)', true, TFhirReference{TFhirReference}, FBasedOnList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'replaces', 'Reference(Any)', true, TFhirReference{TFhirReference}, FReplacesList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'requisition', 'Identifier', false, TFhirIdentifier, FRequisition.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'intent', 'code', false, TFHIREnum, FIntent.Link));{1}
  oList.add(TFHIRProperty.create(self, 'priority', 'code', false, TFHIREnum, FPriority.Link));{1}
  oList.add(TFHIRProperty.create(self, 'doNotPerform', 'boolean', false, TFhirBoolean, FDoNotPerform.Link));{2}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Group|Location|Device)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'context', 'Reference(Encounter|EpisodeOfCare)', false, TFhirReference{Resource}, FContext.Link));{2}
  oList.add(TFHIRProperty.create(self, 'occurrence[x]', 'dateTime|Period|Timing', false, TFhirType, FOccurrence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'asNeeded[x]', 'boolean|CodeableConcept', false, TFhirType, FAsNeeded.Link));{2}
  oList.add(TFHIRProperty.create(self, 'authoredOn', 'dateTime', false, TFhirDateTime, FAuthoredOn.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requester', '', false, TFhirProcedureRequestRequester, FRequester.Link));{2}
  oList.add(TFHIRProperty.create(self, 'performerType', 'CodeableConcept', false, TFhirCodeableConcept, FPerformerType.Link));{2}
  oList.add(TFHIRProperty.create(self, 'performer', 'Reference(Practitioner|Organization|Patient|Device|RelatedPerson|HealthcareService)', false, TFhirReference{Resource}, FPerformer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reasonCode', 'CodeableConcept', true, TFhirCodeableConcept, FReasonCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reasonReference', 'Reference(Condition|Observation)', true, TFhirReference{Resource}, FReasonReferenceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'supportingInfo', 'Reference(Any)', true, TFhirReference{TFhirReference}, FSupportingInfoList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'specimen', 'Reference(Specimen)', true, TFhirReference{TFhirSpecimen}, FSpecimenList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', true, TFhirCodeableConcept, FBodySiteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'relevantHistory', 'Reference(Provenance)', true, TFhirReference{TFhirProvenance}, FRelevantHistoryList.Link)){3};
end;

function TFhirProcedureRequest.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'definition') then
  begin
    DefinitionList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'replaces') then
  begin
    ReplacesList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'requisition') then
  begin
    Requisition := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirRequestStatusEnum, CODES_TFhirRequestStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'intent') then
  begin
    IntentElement := asEnum(SYSTEMS_TFhirRequestIntentEnum, CODES_TFhirRequestIntentEnum, propValue);
    result := propValue
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, propValue);
    result := propValue
  end
  else if (propName = 'doNotPerform') then
  begin
    DoNotPerformElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'context') then
  begin
    Context := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then
  begin
    Occurrence := propValue as TFhirType{4};
    result := propValue;
  end
  else if (isMatchingName(propName, 'asNeeded', ['Boolean', 'CodeableConcept'])) then
  begin
    AsNeeded := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'authoredOn') then
  begin
    AuthoredOnElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'requester') then
  begin
    Requester := propValue as TFhirProcedureRequestRequester{4b};
    result := propValue;
  end
  else if (propName = 'performerType') then
  begin
    PerformerType := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    Performer := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'reasonCode') then
  begin
    ReasonCodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'reasonReference') then
  begin
    ReasonReferenceList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'supportingInfo') then
  begin
    SupportingInfoList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'specimen') then
  begin
    SpecimenList.add(propValue as TFhirReference{TFhirSpecimen}){2a};
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySiteList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else if (propName = 'relevantHistory') then
  begin
    RelevantHistoryList.add(propValue as TFhirReference{TFhirProvenance}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirProcedureRequest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'definition') then DefinitionList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'replaces') then ReplacesList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'reasonCode') then ReasonCodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'reasonReference') then ReasonReferenceList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'supportingInfo') then SupportingInfoList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'specimen') then SpecimenList.insertItem(index, propValue as TFhirReference{TFhirSpecimen}){2a}
  else if (propName = 'bodySite') then BodySiteList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else if (propName = 'relevantHistory') then RelevantHistoryList.insertItem(index, propValue as TFhirReference{TFhirProvenance}){2a}
  else inherited;
end;

function TFhirProcedureRequest.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'definition') then result := DefinitionList.new(){2}
  else if (propName = 'basedOn') then result := BasedOnList.new(){2}
  else if (propName = 'replaces') then result := ReplacesList.new(){2}
  else if (propName = 'requisition') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'doNotPerform') then result := TFhirBoolean.create() {5b}
  else if (propName = 'category') then result := CategoryList.new(){2}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'context') then result := TFhirReference{Resource}.create(){4b}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then raise EFHIRException.create('Cannot make property Occurrence'){4x}
  else if (isMatchingName(propName, 'asNeeded', ['Boolean', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property AsNeeded'){4x}
  else if (propName = 'authoredOn') then result := TFhirDateTime.create() {5b}
  else if (propName = 'requester') then result := TFhirProcedureRequestRequester.create(){4b}
  else if (propName = 'performerType') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'performer') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'reasonCode') then result := ReasonCodeList.new(){2}
  else if (propName = 'reasonReference') then result := ReasonReferenceList.new(){2}
  else if (propName = 'supportingInfo') then result := SupportingInfoList.new(){2}
  else if (propName = 'specimen') then result := SpecimenList.new(){2}
  else if (propName = 'bodySite') then result := BodySiteList.new(){2}
  else if (propName = 'note') then result := NoteList.new(){2}
  else if (propName = 'relevantHistory') then result := RelevantHistoryList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirProcedureRequest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'definition') then result := 'Reference'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'replaces') then result := 'Reference'
  else if (propName = 'requisition') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'intent') then result := 'code'
  else if (propName = 'priority') then result := 'code'
  else if (propName = 'doNotPerform') then result := 'boolean'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'context') then result := 'Reference'
  else if (propName = 'occurrence[x]') then result := 'dateTime|Period|Timing'
  else if (propName = 'asNeeded[x]') then result := 'boolean|CodeableConcept'
  else if (propName = 'authoredOn') then result := 'dateTime'
  else if (propName = 'requester') then result := ''
  else if (propName = 'performerType') then result := 'CodeableConcept'
  else if (propName = 'performer') then result := 'Reference'
  else if (propName = 'reasonCode') then result := 'CodeableConcept'
  else if (propName = 'reasonReference') then result := 'Reference'
  else if (propName = 'supportingInfo') then result := 'Reference'
  else if (propName = 'specimen') then result := 'Reference'
  else if (propName = 'bodySite') then result := 'CodeableConcept'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'relevantHistory') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirProcedureRequest.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'definition') then deletePropertyValue('definition', DefinitionList, value) {2}
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value) {2}
  else if (propName = 'replaces') then deletePropertyValue('replaces', ReplacesList, value) {2}
  else if (propName = 'requisition') then RequisitionElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'intent') then IntentElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'doNotPerform') then DoNotPerformElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value) {2}
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'context') then ContextElement := nil
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then OccurrenceElement := nil{4x}
  else if (isMatchingName(propName, 'asNeeded', ['Boolean', 'CodeableConcept'])) then AsNeededElement := nil{4x}
  else if (propName = 'authoredOn') then AuthoredOnElement := nil
  else if (propName = 'requester') then RequesterElement := nil
  else if (propName = 'performerType') then PerformerTypeElement := nil
  else if (propName = 'performer') then PerformerElement := nil
  else if (propName = 'reasonCode') then deletePropertyValue('reasonCode', ReasonCodeList, value) {2}
  else if (propName = 'reasonReference') then deletePropertyValue('reasonReference', ReasonReferenceList, value) {2}
  else if (propName = 'supportingInfo') then deletePropertyValue('supportingInfo', SupportingInfoList, value) {2}
  else if (propName = 'specimen') then deletePropertyValue('specimen', SpecimenList, value) {2}
  else if (propName = 'bodySite') then deletePropertyValue('bodySite', BodySiteList, value) {2}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else if (propName = 'relevantHistory') then deletePropertyValue('relevantHistory', RelevantHistoryList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirProcedureRequest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'definition') then replacePropertyValue('definition', DefinitionList, existing, new) {2}
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new) {2}
  else if (propName = 'replaces') then replacePropertyValue('replaces', ReplacesList, existing, new) {2}
  else if (propName = 'requisition') then RequisitionElement := new as TFhirIdentifier{4}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirRequestStatusEnum, CODES_TFhirRequestStatusEnum, new){4}
  else if (propName = 'intent') then IntentElement := asEnum(SYSTEMS_TFhirRequestIntentEnum, CODES_TFhirRequestIntentEnum, new){4}
  else if (propName = 'priority') then PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, new){4}
  else if (propName = 'doNotPerform') then DoNotPerformElement := asBoolean(new){5b}
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new) {2}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'context') then ContextElement := new as TFhirReference{Resource}{4}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then OccurrenceElement := new as TFhirType{4x}
  else if (isMatchingName(propName, 'asNeeded', ['Boolean', 'CodeableConcept'])) then AsNeededElement := new as TFhirType{4x}
  else if (propName = 'authoredOn') then AuthoredOnElement := asDateTime(new){5b}
  else if (propName = 'requester') then RequesterElement := new as TFhirProcedureRequestRequester{4}
  else if (propName = 'performerType') then PerformerTypeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'performer') then PerformerElement := new as TFhirReference{Resource}{4}
  else if (propName = 'reasonCode') then replacePropertyValue('reasonCode', ReasonCodeList, existing, new) {2}
  else if (propName = 'reasonReference') then replacePropertyValue('reasonReference', ReasonReferenceList, existing, new) {2}
  else if (propName = 'supportingInfo') then replacePropertyValue('supportingInfo', SupportingInfoList, existing, new) {2}
  else if (propName = 'specimen') then replacePropertyValue('specimen', SpecimenList, existing, new) {2}
  else if (propName = 'bodySite') then replacePropertyValue('bodySite', BodySiteList, existing, new) {2}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else if (propName = 'relevantHistory') then replacePropertyValue('relevantHistory', RelevantHistoryList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirProcedureRequest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'definition') then DefinitionList.move(source, destination){2a}
  else if (propName = 'basedOn') then BasedOnList.move(source, destination){2a}
  else if (propName = 'replaces') then ReplacesList.move(source, destination){2a}
  else if (propName = 'category') then CategoryList.move(source, destination){2a}
  else if (propName = 'reasonCode') then ReasonCodeList.move(source, destination){2a}
  else if (propName = 'reasonReference') then ReasonReferenceList.move(source, destination){2a}
  else if (propName = 'supportingInfo') then SupportingInfoList.move(source, destination){2a}
  else if (propName = 'specimen') then SpecimenList.move(source, destination){2a}
  else if (propName = 'bodySite') then BodySiteList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else if (propName = 'relevantHistory') then RelevantHistoryList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirProcedureRequest.fhirType : string;
begin
  result := 'ProcedureRequest';
end;

function TFhirProcedureRequest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FdefinitionList) and isEmptyProp(FbasedOnList) and isEmptyProp(FreplacesList) and isEmptyProp(FRequisition) and isEmptyProp(FStatus) and isEmptyProp(FIntent) and isEmptyProp(FPriority) and isEmptyProp(FDoNotPerform) and isEmptyProp(FcategoryList) and isEmptyProp(FCode) and isEmptyProp(FSubject) and isEmptyProp(FContext) and isEmptyProp(FOccurrence) and isEmptyProp(FAsNeeded) and isEmptyProp(FAuthoredOn) and isEmptyProp(FRequester) and isEmptyProp(FPerformerType) and isEmptyProp(FPerformer) and isEmptyProp(FreasonCodeList) and isEmptyProp(FreasonReferenceList) and isEmptyProp(FsupportingInfoList) and isEmptyProp(FspecimenList) and isEmptyProp(FbodySiteList) and isEmptyProp(FnoteList) and isEmptyProp(FrelevantHistoryList);
end;

function TFhirProcedureRequest.equals(other : TObject) : boolean;
var
  o : TFhirProcedureRequest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirProcedureRequest)) then
    result := false
  else
  begin
    o := TFhirProcedureRequest(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(definitionList, o.definitionList, true) and
      compareDeep(basedOnList, o.basedOnList, true) and compareDeep(replacesList, o.replacesList, true) and
      compareDeep(requisitionElement, o.requisitionElement, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(intentElement, o.intentElement, true) and compareDeep(priorityElement, o.priorityElement, true) and
      compareDeep(doNotPerformElement, o.doNotPerformElement, true) and compareDeep(categoryList, o.categoryList, true) and
      compareDeep(codeElement, o.codeElement, true) and compareDeep(subjectElement, o.subjectElement, true) and
      compareDeep(contextElement, o.contextElement, true) and compareDeep(occurrenceElement, o.occurrenceElement, true) and
      compareDeep(asNeededElement, o.asNeededElement, true) and compareDeep(authoredOnElement, o.authoredOnElement, true) and
      compareDeep(requesterElement, o.requesterElement, true) and compareDeep(performerTypeElement, o.performerTypeElement, true) and
      compareDeep(performerElement, o.performerElement, true) and compareDeep(reasonCodeList, o.reasonCodeList, true) and
      compareDeep(reasonReferenceList, o.reasonReferenceList, true) and compareDeep(supportingInfoList, o.supportingInfoList, true) and
      compareDeep(specimenList, o.specimenList, true) and compareDeep(bodySiteList, o.bodySiteList, true) and
      compareDeep(noteList, o.noteList, true) and compareDeep(relevantHistoryList, o.relevantHistoryList, true);
  end;
end;

function TFhirProcedureRequest.Link : TFhirProcedureRequest;
begin
  result := TFhirProcedureRequest(inherited Link);
end;

function TFhirProcedureRequest.Clone : TFhirProcedureRequest;
begin
  result := TFhirProcedureRequest(inherited Clone);
end;

procedure TFhirProcedureRequest.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('definition');
  fields.add('basedOn');
  fields.add('replaces');
  fields.add('requisition');
  fields.add('status');
  fields.add('intent');
  fields.add('priority');
  fields.add('doNotPerform');
  fields.add('category');
  fields.add('code');
  fields.add('subject');
  fields.add('context');
  fields.add('occurrence[x]');
  fields.add('asNeeded[x]');
  fields.add('authoredOn');
  fields.add('requester');
  fields.add('performerType');
  fields.add('performer');
  fields.add('reasonCode');
  fields.add('reasonReference');
  fields.add('supportingInfo');
  fields.add('specimen');
  fields.add('bodySite');
  fields.add('note');
  fields.add('relevantHistory');
end;

{ TFhirProcedureRequest }

Function TFhirProcedureRequest.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirProcedureRequest.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Function TFhirProcedureRequest.GetDefinitionList : TFhirReferenceList{Resource};
begin
  if FDefinitionList = nil then
    FDefinitionList := TFhirReferenceList{Resource}.Create;
  result := FDefinitionList;
end;

Function TFhirProcedureRequest.GetHasDefinitionList : boolean;
begin
  result := (FDefinitionList <> nil) and (FDefinitionList.count > 0);
end;

Function TFhirProcedureRequest.GetBasedOnList : TFhirReferenceList{TFhirReference};
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList{TFhirReference}.Create;
  result := FBasedOnList;
end;

Function TFhirProcedureRequest.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

Function TFhirProcedureRequest.GetReplacesList : TFhirReferenceList{TFhirReference};
begin
  if FReplacesList = nil then
    FReplacesList := TFhirReferenceList{TFhirReference}.Create;
  result := FReplacesList;
end;

Function TFhirProcedureRequest.GetHasReplacesList : boolean;
begin
  result := (FReplacesList <> nil) and (FReplacesList.count > 0);
end;

Procedure TFhirProcedureRequest.SetRequisition(value : TFhirIdentifier);
begin
  FRequisition.free;
  FRequisition := value;
end;

Procedure TFhirProcedureRequest.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirProcedureRequest.GetStatusST : TFhirRequestStatusEnum;
begin
  if FStatus = nil then
    result := TFhirRequestStatusEnum(0)
  else
    result := TFhirRequestStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestStatusEnum, FStatus.value));
end;

Procedure TFhirProcedureRequest.SetStatusST(value : TFhirRequestStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirRequestStatusEnum[value], CODES_TFhirRequestStatusEnum[value]);
end;

Procedure TFhirProcedureRequest.SetIntent(value : TFhirEnum);
begin
  FIntent.free;
  FIntent := value;
end;

Function TFhirProcedureRequest.GetIntentST : TFhirRequestIntentEnum;
begin
  if FIntent = nil then
    result := TFhirRequestIntentEnum(0)
  else
    result := TFhirRequestIntentEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestIntentEnum, FIntent.value));
end;

Procedure TFhirProcedureRequest.SetIntentST(value : TFhirRequestIntentEnum);
begin
  if ord(value) = 0 then
    IntentElement := nil
  else
    IntentElement := TFhirEnum.create(SYSTEMS_TFhirRequestIntentEnum[value], CODES_TFhirRequestIntentEnum[value]);
end;

Procedure TFhirProcedureRequest.SetPriority(value : TFhirEnum);
begin
  FPriority.free;
  FPriority := value;
end;

Function TFhirProcedureRequest.GetPriorityST : TFhirRequestPriorityEnum;
begin
  if FPriority = nil then
    result := TFhirRequestPriorityEnum(0)
  else
    result := TFhirRequestPriorityEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestPriorityEnum, FPriority.value));
end;

Procedure TFhirProcedureRequest.SetPriorityST(value : TFhirRequestPriorityEnum);
begin
  if ord(value) = 0 then
    PriorityElement := nil
  else
    PriorityElement := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[value], CODES_TFhirRequestPriorityEnum[value]);
end;

Procedure TFhirProcedureRequest.SetDoNotPerform(value : TFhirBoolean);
begin
  FDoNotPerform.free;
  FDoNotPerform := value;
end;

Function TFhirProcedureRequest.GetDoNotPerformST : Boolean;
begin
  if FDoNotPerform = nil then
    result := false
  else
    result := FDoNotPerform.value;
end;

Procedure TFhirProcedureRequest.SetDoNotPerformST(value : Boolean);
begin
  if FDoNotPerform = nil then
    FDoNotPerform := TFhirBoolean.create;
  FDoNotPerform.value := value
end;

Function TFhirProcedureRequest.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

Function TFhirProcedureRequest.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

Procedure TFhirProcedureRequest.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirProcedureRequest.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirProcedureRequest.SetContext(value : TFhirReference{Resource});
begin
  FContext.free;
  FContext := value;
end;

Procedure TFhirProcedureRequest.SetOccurrence(value : TFhirType);
begin
  FOccurrence.free;
  FOccurrence := value;
end;

Procedure TFhirProcedureRequest.SetAsNeeded(value : TFhirType);
begin
  FAsNeeded.free;
  FAsNeeded := value;
end;

Procedure TFhirProcedureRequest.SetAuthoredOn(value : TFhirDateTime);
begin
  FAuthoredOn.free;
  FAuthoredOn := value;
end;

Function TFhirProcedureRequest.GetAuthoredOnST : TFslDateTime;
begin
  if FAuthoredOn = nil then
    result := TFslDateTime.makeNull
  else
    result := FAuthoredOn.value;
end;

Procedure TFhirProcedureRequest.SetAuthoredOnST(value : TFslDateTime);
begin
  if FAuthoredOn = nil then
    FAuthoredOn := TFhirDateTime.create;
  FAuthoredOn.value := value
end;

Procedure TFhirProcedureRequest.SetRequester(value : TFhirProcedureRequestRequester);
begin
  FRequester.free;
  FRequester := value;
end;

Procedure TFhirProcedureRequest.SetPerformerType(value : TFhirCodeableConcept);
begin
  FPerformerType.free;
  FPerformerType := value;
end;

Procedure TFhirProcedureRequest.SetPerformer(value : TFhirReference{Resource});
begin
  FPerformer.free;
  FPerformer := value;
end;

Function TFhirProcedureRequest.GetReasonCodeList : TFhirCodeableConceptList;
begin
  if FReasonCodeList = nil then
    FReasonCodeList := TFhirCodeableConceptList.Create;
  result := FReasonCodeList;
end;

Function TFhirProcedureRequest.GetHasReasonCodeList : boolean;
begin
  result := (FReasonCodeList <> nil) and (FReasonCodeList.count > 0);
end;

Function TFhirProcedureRequest.GetReasonReferenceList : TFhirReferenceList{Resource};
begin
  if FReasonReferenceList = nil then
    FReasonReferenceList := TFhirReferenceList{Resource}.Create;
  result := FReasonReferenceList;
end;

Function TFhirProcedureRequest.GetHasReasonReferenceList : boolean;
begin
  result := (FReasonReferenceList <> nil) and (FReasonReferenceList.count > 0);
end;

Function TFhirProcedureRequest.GetSupportingInfoList : TFhirReferenceList{TFhirReference};
begin
  if FSupportingInfoList = nil then
    FSupportingInfoList := TFhirReferenceList{TFhirReference}.Create;
  result := FSupportingInfoList;
end;

Function TFhirProcedureRequest.GetHasSupportingInfoList : boolean;
begin
  result := (FSupportingInfoList <> nil) and (FSupportingInfoList.count > 0);
end;

Function TFhirProcedureRequest.GetSpecimenList : TFhirReferenceList{TFhirSpecimen};
begin
  if FSpecimenList = nil then
    FSpecimenList := TFhirReferenceList{TFhirSpecimen}.Create;
  result := FSpecimenList;
end;

Function TFhirProcedureRequest.GetHasSpecimenList : boolean;
begin
  result := (FSpecimenList <> nil) and (FSpecimenList.count > 0);
end;

Function TFhirProcedureRequest.GetBodySiteList : TFhirCodeableConceptList;
begin
  if FBodySiteList = nil then
    FBodySiteList := TFhirCodeableConceptList.Create;
  result := FBodySiteList;
end;

Function TFhirProcedureRequest.GetHasBodySiteList : boolean;
begin
  result := (FBodySiteList <> nil) and (FBodySiteList.count > 0);
end;

Function TFhirProcedureRequest.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirProcedureRequest.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

Function TFhirProcedureRequest.GetRelevantHistoryList : TFhirReferenceList{TFhirProvenance};
begin
  if FRelevantHistoryList = nil then
    FRelevantHistoryList := TFhirReferenceList{TFhirProvenance}.Create;
  result := FRelevantHistoryList;
end;

Function TFhirProcedureRequest.GetHasRelevantHistoryList : boolean;
begin
  result := (FRelevantHistoryList <> nil) and (FRelevantHistoryList.count > 0);
end;

function TFhirProcedureRequest.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FdefinitionList.sizeInBytes);
  inc(result, FbasedOnList.sizeInBytes);
  inc(result, FreplacesList.sizeInBytes);
  inc(result, FRequisition.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FIntent.sizeInBytes);
  inc(result, FPriority.sizeInBytes);
  inc(result, FDoNotPerform.sizeInBytes);
  inc(result, FcategoryList.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FContext.sizeInBytes);
  inc(result, FOccurrence.sizeInBytes);
  inc(result, FAsNeeded.sizeInBytes);
  inc(result, FAuthoredOn.sizeInBytes);
  inc(result, FRequester.sizeInBytes);
  inc(result, FPerformerType.sizeInBytes);
  inc(result, FPerformer.sizeInBytes);
  inc(result, FreasonCodeList.sizeInBytes);
  inc(result, FreasonReferenceList.sizeInBytes);
  inc(result, FsupportingInfoList.sizeInBytes);
  inc(result, FspecimenList.sizeInBytes);
  inc(result, FbodySiteList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FrelevantHistoryList.sizeInBytes);
end;

{ TFhirProcedureRequestListEnumerator }

Constructor TFhirProcedureRequestListEnumerator.Create(list : TFhirProcedureRequestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirProcedureRequestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProcedureRequestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirProcedureRequestListEnumerator.GetCurrent : TFhirProcedureRequest;
begin
  Result := FList[FIndex];
end;

function TFhirProcedureRequestListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirProcedureRequestList }
procedure TFhirProcedureRequestList.AddItem(value: TFhirProcedureRequest);
begin
  assert(value.ClassName = 'TFhirProcedureRequest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProcedureRequest');
  add(value);
end;

function TFhirProcedureRequestList.Append: TFhirProcedureRequest;
begin
  result := TFhirProcedureRequest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcedureRequestList.ClearItems;
begin
  Clear;
end;

function TFhirProcedureRequestList.GetEnumerator : TFhirProcedureRequestListEnumerator;
begin
  result := TFhirProcedureRequestListEnumerator.Create(self.link);
end;

function TFhirProcedureRequestList.Clone: TFhirProcedureRequestList;
begin
  result := TFhirProcedureRequestList(inherited Clone);
end;

function TFhirProcedureRequestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProcedureRequestList.GetItemN(index: Integer): TFhirProcedureRequest;
begin
  result := TFhirProcedureRequest(ObjectByIndex[index]);
end;

function TFhirProcedureRequestList.ItemClass: TFslObjectClass;
begin
  result := TFhirProcedureRequest;
end;
function TFhirProcedureRequestList.IndexOf(value: TFhirProcedureRequest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirProcedureRequestList.Insert(index: Integer): TFhirProcedureRequest;
begin
  result := TFhirProcedureRequest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcedureRequestList.InsertItem(index: Integer; value: TFhirProcedureRequest);
begin
  assert(value is TFhirProcedureRequest);
  Inherited Insert(index, value);
end;

function TFhirProcedureRequestList.Item(index: Integer): TFhirProcedureRequest;
begin
  result := TFhirProcedureRequest(ObjectByIndex[index]);
end;

function TFhirProcedureRequestList.Link: TFhirProcedureRequestList;
begin
  result := TFhirProcedureRequestList(inherited Link);
end;

procedure TFhirProcedureRequestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProcedureRequestList.SetItemByIndex(index: Integer; value: TFhirProcedureRequest);
begin
  assert(value is TFhirProcedureRequest);
  FhirProcedureRequests[index] := value;
end;

procedure TFhirProcedureRequestList.SetItemN(index: Integer; value: TFhirProcedureRequest);
begin
  assert(value is TFhirProcedureRequest);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PROCEDUREREQUEST}

{$IFDEF FHIR_QUESTIONNAIRERESPONSE}

{ TFhirQuestionnaireResponseItem }

constructor TFhirQuestionnaireResponseItem.Create;
begin
  inherited;
end;

destructor TFhirQuestionnaireResponseItem.Destroy;
begin
  FLinkId.free;
  FDefinition.free;
  FText.free;
  FSubject.free;
  FAnswerList.Free;
  FItemList.Free;
  inherited;
end;

procedure TFhirQuestionnaireResponseItem.Assign(oSource : TFslObject);
begin
  inherited;
  linkIdElement := TFhirQuestionnaireResponseItem(oSource).linkIdElement.Clone;
  definitionElement := TFhirQuestionnaireResponseItem(oSource).definitionElement.Clone;
  textElement := TFhirQuestionnaireResponseItem(oSource).textElement.Clone;
  subject := TFhirQuestionnaireResponseItem(oSource).subject.Clone;
  if (TFhirQuestionnaireResponseItem(oSource).FAnswerList = nil) then
  begin
    FAnswerList.free;
    FAnswerList := nil;
  end
  else
  begin
    if FAnswerList = nil then
      FAnswerList := TFhirQuestionnaireResponseItemAnswerList.Create;
    FAnswerList.Assign(TFhirQuestionnaireResponseItem(oSource).FAnswerList);
  end;
  if (TFhirQuestionnaireResponseItem(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirQuestionnaireResponseItemList.Create;
    FItemList.Assign(TFhirQuestionnaireResponseItem(oSource).FItemList);
  end;
end;

procedure TFhirQuestionnaireResponseItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'linkId') Then
     list.add(self.link, 'linkId', FLinkId.Link);
  if (child_name = 'definition') Then
     list.add(self.link, 'definition', FDefinition.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'answer') Then
    list.addAll(self, 'answer', FAnswerList);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
end;

procedure TFhirQuestionnaireResponseItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'linkId', 'string', false, TFhirString, FLinkId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'definition', 'uri', false, TFhirUri, FDefinition.Link));{2}
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Any)', false, TFhirReference{TFhirReference}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'answer', '', true, TFhirQuestionnaireResponseItemAnswer, FAnswerList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'item', '@QuestionnaireResponse.item', true, TFhirQuestionnaireResponseItem, FItemList.Link)){3};
end;

function TFhirQuestionnaireResponseItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'linkId') then
  begin
    LinkIdElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'definition') then
  begin
    DefinitionElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'answer') then
  begin
    AnswerList.add(propValue as TFhirQuestionnaireResponseItemAnswer){2a};
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirQuestionnaireResponseItem){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirQuestionnaireResponseItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'answer') then AnswerList.insertItem(index, propValue as TFhirQuestionnaireResponseItemAnswer){2a}
  else if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirQuestionnaireResponseItem){2a}
  else inherited;
end;

function TFhirQuestionnaireResponseItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'linkId') then result := TFhirString.create() {5b}
  else if (propName = 'definition') then result := TFhirUri.create() {5b}
  else if (propName = 'text') then result := TFhirString.create() {5b}
  else if (propName = 'subject') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'answer') then result := AnswerList.new(){2}
  else if (propName = 'item') then result := ItemList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirQuestionnaireResponseItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'linkId') then result := 'string'
  else if (propName = 'definition') then result := 'uri'
  else if (propName = 'text') then result := 'string'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'answer') then result := ''
  else if (propName = 'item') then result := '@QuestionnaireResponse.item'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirQuestionnaireResponseItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'linkId') then LinkIdElement := nil
  else if (propName = 'definition') then DefinitionElement := nil
  else if (propName = 'text') then TextElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'answer') then deletePropertyValue('answer', AnswerList, value) {2}
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirQuestionnaireResponseItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'linkId') then LinkIdElement := asString(new){5b}
  else if (propName = 'definition') then DefinitionElement := asUri(new){5b}
  else if (propName = 'text') then TextElement := asString(new){5b}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'answer') then replacePropertyValue('answer', AnswerList, existing, new) {2}
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirQuestionnaireResponseItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'answer') then AnswerList.move(source, destination){2a}
  else if (propName = 'item') then ItemList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirQuestionnaireResponseItem.fhirType : string;
begin
  result := 'item';
end;

function TFhirQuestionnaireResponseItem.Link : TFhirQuestionnaireResponseItem;
begin
  result := TFhirQuestionnaireResponseItem(inherited Link);
end;

function TFhirQuestionnaireResponseItem.Clone : TFhirQuestionnaireResponseItem;
begin
  result := TFhirQuestionnaireResponseItem(inherited Clone);
end;

function TFhirQuestionnaireResponseItem.equals(other : TObject) : boolean;
var
  o : TFhirQuestionnaireResponseItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirQuestionnaireResponseItem)) then
    result := false
  else
  begin
    o := TFhirQuestionnaireResponseItem(other);
    result := compareDeep(linkIdElement, o.linkIdElement, true) and compareDeep(definitionElement, o.definitionElement, true) and
      compareDeep(textElement, o.textElement, true) and compareDeep(subjectElement, o.subjectElement, true) and
      compareDeep(answerList, o.answerList, true) and compareDeep(itemList, o.itemList, true);
  end;
end;

function TFhirQuestionnaireResponseItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLinkId) and isEmptyProp(FDefinition) and isEmptyProp(FText) and isEmptyProp(FSubject) and isEmptyProp(FanswerList) and isEmptyProp(FitemList);
end;

procedure TFhirQuestionnaireResponseItem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('linkId');
  fields.add('definition');
  fields.add('text');
  fields.add('subject');
  fields.add('answer');
  fields.add('item');
end;

{ TFhirQuestionnaireResponseItem }

Procedure TFhirQuestionnaireResponseItem.SetLinkId(value : TFhirString);
begin
  FLinkId.free;
  FLinkId := value;
end;

Function TFhirQuestionnaireResponseItem.GetLinkIdST : String;
begin
  if FLinkId = nil then
    result := ''
  else
    result := FLinkId.value;
end;

Procedure TFhirQuestionnaireResponseItem.SetLinkIdST(value : String);
begin
  if value <> '' then
  begin
    if FLinkId = nil then
      FLinkId := TFhirString.create;
    FLinkId.value := value
  end
  else if FLinkId <> nil then
    FLinkId.value := '';
end;

Procedure TFhirQuestionnaireResponseItem.SetDefinition(value : TFhirUri);
begin
  FDefinition.free;
  FDefinition := value;
end;

Function TFhirQuestionnaireResponseItem.GetDefinitionST : String;
begin
  if FDefinition = nil then
    result := ''
  else
    result := FDefinition.value;
end;

Procedure TFhirQuestionnaireResponseItem.SetDefinitionST(value : String);
begin
  if value <> '' then
  begin
    if FDefinition = nil then
      FDefinition := TFhirUri.create;
    FDefinition.value := value
  end
  else if FDefinition <> nil then
    FDefinition.value := '';
end;

Procedure TFhirQuestionnaireResponseItem.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

Function TFhirQuestionnaireResponseItem.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

Procedure TFhirQuestionnaireResponseItem.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

Procedure TFhirQuestionnaireResponseItem.SetSubject(value : TFhirReference{TFhirReference});
begin
  FSubject.free;
  FSubject := value;
end;

Function TFhirQuestionnaireResponseItem.GetAnswerList : TFhirQuestionnaireResponseItemAnswerList;
begin
  if FAnswerList = nil then
    FAnswerList := TFhirQuestionnaireResponseItemAnswerList.Create;
  result := FAnswerList;
end;

Function TFhirQuestionnaireResponseItem.GetHasAnswerList : boolean;
begin
  result := (FAnswerList <> nil) and (FAnswerList.count > 0);
end;

Function TFhirQuestionnaireResponseItem.GetItemList : TFhirQuestionnaireResponseItemList;
begin
  if FItemList = nil then
    FItemList := TFhirQuestionnaireResponseItemList.Create;
  result := FItemList;
end;

Function TFhirQuestionnaireResponseItem.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

function TFhirQuestionnaireResponseItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FLinkId.sizeInBytes);
  inc(result, FDefinition.sizeInBytes);
  inc(result, FText.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FanswerList.sizeInBytes);
  inc(result, FitemList.sizeInBytes);
end;

{ TFhirQuestionnaireResponseItemListEnumerator }

Constructor TFhirQuestionnaireResponseItemListEnumerator.Create(list : TFhirQuestionnaireResponseItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirQuestionnaireResponseItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirQuestionnaireResponseItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirQuestionnaireResponseItemListEnumerator.GetCurrent : TFhirQuestionnaireResponseItem;
begin
  Result := FList[FIndex];
end;

function TFhirQuestionnaireResponseItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirQuestionnaireResponseItemList }
procedure TFhirQuestionnaireResponseItemList.AddItem(value: TFhirQuestionnaireResponseItem);
begin
  assert(value.ClassName = 'TFhirQuestionnaireResponseItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirQuestionnaireResponseItem');
  add(value);
end;

function TFhirQuestionnaireResponseItemList.Append: TFhirQuestionnaireResponseItem;
begin
  result := TFhirQuestionnaireResponseItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireResponseItemList.ClearItems;
begin
  Clear;
end;

function TFhirQuestionnaireResponseItemList.GetEnumerator : TFhirQuestionnaireResponseItemListEnumerator;
begin
  result := TFhirQuestionnaireResponseItemListEnumerator.Create(self.link);
end;

function TFhirQuestionnaireResponseItemList.Clone: TFhirQuestionnaireResponseItemList;
begin
  result := TFhirQuestionnaireResponseItemList(inherited Clone);
end;

function TFhirQuestionnaireResponseItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirQuestionnaireResponseItemList.GetItemN(index: Integer): TFhirQuestionnaireResponseItem;
begin
  result := TFhirQuestionnaireResponseItem(ObjectByIndex[index]);
end;

function TFhirQuestionnaireResponseItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirQuestionnaireResponseItem;
end;
function TFhirQuestionnaireResponseItemList.IndexOf(value: TFhirQuestionnaireResponseItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirQuestionnaireResponseItemList.Insert(index: Integer): TFhirQuestionnaireResponseItem;
begin
  result := TFhirQuestionnaireResponseItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireResponseItemList.InsertItem(index: Integer; value: TFhirQuestionnaireResponseItem);
begin
  assert(value is TFhirQuestionnaireResponseItem);
  Inherited Insert(index, value);
end;

function TFhirQuestionnaireResponseItemList.Item(index: Integer): TFhirQuestionnaireResponseItem;
begin
  result := TFhirQuestionnaireResponseItem(ObjectByIndex[index]);
end;

function TFhirQuestionnaireResponseItemList.Link: TFhirQuestionnaireResponseItemList;
begin
  result := TFhirQuestionnaireResponseItemList(inherited Link);
end;

procedure TFhirQuestionnaireResponseItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirQuestionnaireResponseItemList.SetItemByIndex(index: Integer; value: TFhirQuestionnaireResponseItem);
begin
  assert(value is TFhirQuestionnaireResponseItem);
  FhirQuestionnaireResponseItems[index] := value;
end;

procedure TFhirQuestionnaireResponseItemList.SetItemN(index: Integer; value: TFhirQuestionnaireResponseItem);
begin
  assert(value is TFhirQuestionnaireResponseItem);
  ObjectByIndex[index] := value;
end;

{ TFhirQuestionnaireResponseItemAnswer }

constructor TFhirQuestionnaireResponseItemAnswer.Create;
begin
  inherited;
end;

destructor TFhirQuestionnaireResponseItemAnswer.Destroy;
begin
  FValue.free;
  FItemList.Free;
  inherited;
end;

procedure TFhirQuestionnaireResponseItemAnswer.Assign(oSource : TFslObject);
begin
  inherited;
  value := TFhirQuestionnaireResponseItemAnswer(oSource).value.Clone;
  if (TFhirQuestionnaireResponseItemAnswer(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirQuestionnaireResponseItemList.Create;
    FItemList.Assign(TFhirQuestionnaireResponseItemAnswer(oSource).FItemList);
  end;
end;

procedure TFhirQuestionnaireResponseItemAnswer.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
end;

procedure TFhirQuestionnaireResponseItemAnswer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'value[x]', 'boolean|decimal|integer|date|dateTime|time|string|uri|Attachment|Coding|Quantity|Reference(Any)', false, TFhirType, FValue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'item', '@QuestionnaireResponse.item', true, TFhirQuestionnaireResponseItem, FItemList.Link)){3};
end;

function TFhirQuestionnaireResponseItemAnswer.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'value', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Time', 'String', 'Uri', 'Attachment', 'Coding', 'Quantity', 'Reference'])) then
  begin
    Value := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirQuestionnaireResponseItem){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirQuestionnaireResponseItemAnswer.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirQuestionnaireResponseItem){2a}
  else inherited;
end;

function TFhirQuestionnaireResponseItemAnswer.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'value', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Time', 'String', 'Uri', 'Attachment', 'Coding', 'Quantity', 'Reference'])) then raise EFHIRException.create('Cannot make property Value'){4x}
  else if (propName = 'item') then result := ItemList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirQuestionnaireResponseItemAnswer.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'value[x]') then result := 'boolean|decimal|integer|date|dateTime|time|string|uri|Attachment|Coding|Quantity|Reference'
  else if (propName = 'item') then result := '@QuestionnaireResponse.item'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirQuestionnaireResponseItemAnswer.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'value', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Time', 'String', 'Uri', 'Attachment', 'Coding', 'Quantity', 'Reference'])) then ValueElement := nil{4x}
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirQuestionnaireResponseItemAnswer.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'value', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Time', 'String', 'Uri', 'Attachment', 'Coding', 'Quantity', 'Reference'])) then ValueElement := new as TFhirType{4x}
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirQuestionnaireResponseItemAnswer.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'item') then ItemList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirQuestionnaireResponseItemAnswer.fhirType : string;
begin
  result := 'answer';
end;

function TFhirQuestionnaireResponseItemAnswer.Link : TFhirQuestionnaireResponseItemAnswer;
begin
  result := TFhirQuestionnaireResponseItemAnswer(inherited Link);
end;

function TFhirQuestionnaireResponseItemAnswer.Clone : TFhirQuestionnaireResponseItemAnswer;
begin
  result := TFhirQuestionnaireResponseItemAnswer(inherited Clone);
end;

function TFhirQuestionnaireResponseItemAnswer.equals(other : TObject) : boolean;
var
  o : TFhirQuestionnaireResponseItemAnswer;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirQuestionnaireResponseItemAnswer)) then
    result := false
  else
  begin
    o := TFhirQuestionnaireResponseItemAnswer(other);
    result := compareDeep(valueElement, o.valueElement, true) and compareDeep(itemList, o.itemList, true);
  end;
end;

function TFhirQuestionnaireResponseItemAnswer.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FValue) and isEmptyProp(FitemList);
end;

procedure TFhirQuestionnaireResponseItemAnswer.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('value[x]');
  fields.add('item');
end;

{ TFhirQuestionnaireResponseItemAnswer }

Procedure TFhirQuestionnaireResponseItemAnswer.SetValue(value : TFhirType);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirQuestionnaireResponseItemAnswer.GetItemList : TFhirQuestionnaireResponseItemList;
begin
  if FItemList = nil then
    FItemList := TFhirQuestionnaireResponseItemList.Create;
  result := FItemList;
end;

Function TFhirQuestionnaireResponseItemAnswer.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

function TFhirQuestionnaireResponseItemAnswer.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FValue.sizeInBytes);
  inc(result, FitemList.sizeInBytes);
end;

{ TFhirQuestionnaireResponseItemAnswerListEnumerator }

Constructor TFhirQuestionnaireResponseItemAnswerListEnumerator.Create(list : TFhirQuestionnaireResponseItemAnswerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirQuestionnaireResponseItemAnswerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirQuestionnaireResponseItemAnswerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirQuestionnaireResponseItemAnswerListEnumerator.GetCurrent : TFhirQuestionnaireResponseItemAnswer;
begin
  Result := FList[FIndex];
end;

function TFhirQuestionnaireResponseItemAnswerListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirQuestionnaireResponseItemAnswerList }
procedure TFhirQuestionnaireResponseItemAnswerList.AddItem(value: TFhirQuestionnaireResponseItemAnswer);
begin
  assert(value.ClassName = 'TFhirQuestionnaireResponseItemAnswer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirQuestionnaireResponseItemAnswer');
  add(value);
end;

function TFhirQuestionnaireResponseItemAnswerList.Append: TFhirQuestionnaireResponseItemAnswer;
begin
  result := TFhirQuestionnaireResponseItemAnswer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireResponseItemAnswerList.ClearItems;
begin
  Clear;
end;

function TFhirQuestionnaireResponseItemAnswerList.GetEnumerator : TFhirQuestionnaireResponseItemAnswerListEnumerator;
begin
  result := TFhirQuestionnaireResponseItemAnswerListEnumerator.Create(self.link);
end;

function TFhirQuestionnaireResponseItemAnswerList.Clone: TFhirQuestionnaireResponseItemAnswerList;
begin
  result := TFhirQuestionnaireResponseItemAnswerList(inherited Clone);
end;

function TFhirQuestionnaireResponseItemAnswerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirQuestionnaireResponseItemAnswerList.GetItemN(index: Integer): TFhirQuestionnaireResponseItemAnswer;
begin
  result := TFhirQuestionnaireResponseItemAnswer(ObjectByIndex[index]);
end;

function TFhirQuestionnaireResponseItemAnswerList.ItemClass: TFslObjectClass;
begin
  result := TFhirQuestionnaireResponseItemAnswer;
end;
function TFhirQuestionnaireResponseItemAnswerList.IndexOf(value: TFhirQuestionnaireResponseItemAnswer): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirQuestionnaireResponseItemAnswerList.Insert(index: Integer): TFhirQuestionnaireResponseItemAnswer;
begin
  result := TFhirQuestionnaireResponseItemAnswer.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireResponseItemAnswerList.InsertItem(index: Integer; value: TFhirQuestionnaireResponseItemAnswer);
begin
  assert(value is TFhirQuestionnaireResponseItemAnswer);
  Inherited Insert(index, value);
end;

function TFhirQuestionnaireResponseItemAnswerList.Item(index: Integer): TFhirQuestionnaireResponseItemAnswer;
begin
  result := TFhirQuestionnaireResponseItemAnswer(ObjectByIndex[index]);
end;

function TFhirQuestionnaireResponseItemAnswerList.Link: TFhirQuestionnaireResponseItemAnswerList;
begin
  result := TFhirQuestionnaireResponseItemAnswerList(inherited Link);
end;

procedure TFhirQuestionnaireResponseItemAnswerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirQuestionnaireResponseItemAnswerList.SetItemByIndex(index: Integer; value: TFhirQuestionnaireResponseItemAnswer);
begin
  assert(value is TFhirQuestionnaireResponseItemAnswer);
  FhirQuestionnaireResponseItemAnswers[index] := value;
end;

procedure TFhirQuestionnaireResponseItemAnswerList.SetItemN(index: Integer; value: TFhirQuestionnaireResponseItemAnswer);
begin
  assert(value is TFhirQuestionnaireResponseItemAnswer);
  ObjectByIndex[index] := value;
end;

{ TFhirQuestionnaireResponse }

constructor TFhirQuestionnaireResponse.Create;
begin
  inherited;
end;

destructor TFhirQuestionnaireResponse.Destroy;
begin
  FIdentifier.free;
  FBasedOnList.Free;
  FParentList.Free;
  FQuestionnaire.free;
  FStatus.free;
  FSubject.free;
  FContext.free;
  FAuthored.free;
  FAuthor.free;
  FSource.free;
  FItemList.Free;
  inherited;
end;

function TFhirQuestionnaireResponse.GetResourceType : TFhirResourceType;
begin
  result := frtQuestionnaireResponse;
end;

procedure TFhirQuestionnaireResponse.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirQuestionnaireResponse(oSource).identifier.Clone;
  if (TFhirQuestionnaireResponse(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList{Resource}.Create;
    FBasedOnList.Assign(TFhirQuestionnaireResponse(oSource).FBasedOnList);
  end;
  if (TFhirQuestionnaireResponse(oSource).FParentList = nil) then
  begin
    FParentList.free;
    FParentList := nil;
  end
  else
  begin
    if FParentList = nil then
      FParentList := TFhirReferenceList{Resource}.Create;
    FParentList.Assign(TFhirQuestionnaireResponse(oSource).FParentList);
  end;
  questionnaire := TFhirQuestionnaireResponse(oSource).questionnaire.Clone;
  FStatus := TFhirQuestionnaireResponse(oSource).FStatus.Link;
  subject := TFhirQuestionnaireResponse(oSource).subject.Clone;
  context := TFhirQuestionnaireResponse(oSource).context.Clone;
  authoredElement := TFhirQuestionnaireResponse(oSource).authoredElement.Clone;
  author := TFhirQuestionnaireResponse(oSource).author.Clone;
  source := TFhirQuestionnaireResponse(oSource).source.Clone;
  if (TFhirQuestionnaireResponse(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirQuestionnaireResponseItemList.Create;
    FItemList.Assign(TFhirQuestionnaireResponse(oSource).FItemList);
  end;
end;

procedure TFhirQuestionnaireResponse.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'parent') Then
    list.addAll(self, 'parent', FParentList);
  if (child_name = 'questionnaire') Then
     list.add(self.link, 'questionnaire', FQuestionnaire.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
  if (child_name = 'authored') Then
     list.add(self.link, 'authored', FAuthored.Link);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
end;

procedure TFhirQuestionnaireResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference(ReferralRequest|CarePlan|ProcedureRequest)', true, TFhirReference{Resource}, FBasedOnList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'parent', 'Reference(Observation|Procedure)', true, TFhirReference{Resource}, FParentList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'questionnaire', 'Reference(Questionnaire)', false, TFhirReference{TFhirQuestionnaire}, FQuestionnaire.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Any)', false, TFhirReference{TFhirReference}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'context', 'Reference(Encounter|EpisodeOfCare)', false, TFhirReference{Resource}, FContext.Link));{2}
  oList.add(TFHIRProperty.create(self, 'authored', 'dateTime', false, TFhirDateTime, FAuthored.Link));{2}
  oList.add(TFHIRProperty.create(self, 'author', 'Reference(Device|Practitioner|Patient|RelatedPerson)', false, TFhirReference{Resource}, FAuthor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'source', 'Reference(Patient|Practitioner|RelatedPerson)', false, TFhirReference{Resource}, FSource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'item', '', true, TFhirQuestionnaireResponseItem, FItemList.Link)){3};
end;

function TFhirQuestionnaireResponse.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'parent') then
  begin
    ParentList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'questionnaire') then
  begin
    Questionnaire := propValue as TFhirReference{TFhirQuestionnaire}{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirQuestionnaireAnswersStatusEnum, CODES_TFhirQuestionnaireAnswersStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'context') then
  begin
    Context := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'authored') then
  begin
    AuthoredElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    Source := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirQuestionnaireResponseItem){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirQuestionnaireResponse.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'parent') then ParentList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirQuestionnaireResponseItem){2a}
  else inherited;
end;

function TFhirQuestionnaireResponse.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'basedOn') then result := BasedOnList.new(){2}
  else if (propName = 'parent') then result := ParentList.new(){2}
  else if (propName = 'questionnaire') then result := TFhirReference{TFhirQuestionnaire}.create(){4b}
  else if (propName = 'subject') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'context') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'authored') then result := TFhirDateTime.create() {5b}
  else if (propName = 'author') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'source') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'item') then result := ItemList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirQuestionnaireResponse.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'parent') then result := 'Reference'
  else if (propName = 'questionnaire') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'context') then result := 'Reference'
  else if (propName = 'authored') then result := 'dateTime'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'source') then result := 'Reference'
  else if (propName = 'item') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirQuestionnaireResponse.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value) {2}
  else if (propName = 'parent') then deletePropertyValue('parent', ParentList, value) {2}
  else if (propName = 'questionnaire') then QuestionnaireElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'context') then ContextElement := nil
  else if (propName = 'authored') then AuthoredElement := nil
  else if (propName = 'author') then AuthorElement := nil
  else if (propName = 'source') then SourceElement := nil
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirQuestionnaireResponse.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new) {2}
  else if (propName = 'parent') then replacePropertyValue('parent', ParentList, existing, new) {2}
  else if (propName = 'questionnaire') then QuestionnaireElement := new as TFhirReference{TFhirQuestionnaire}{4}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirQuestionnaireAnswersStatusEnum, CODES_TFhirQuestionnaireAnswersStatusEnum, new){4}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'context') then ContextElement := new as TFhirReference{Resource}{4}
  else if (propName = 'authored') then AuthoredElement := asDateTime(new){5b}
  else if (propName = 'author') then AuthorElement := new as TFhirReference{Resource}{4}
  else if (propName = 'source') then SourceElement := new as TFhirReference{Resource}{4}
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirQuestionnaireResponse.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'basedOn') then BasedOnList.move(source, destination){2a}
  else if (propName = 'parent') then ParentList.move(source, destination){2a}
  else if (propName = 'item') then ItemList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirQuestionnaireResponse.fhirType : string;
begin
  result := 'QuestionnaireResponse';
end;

function TFhirQuestionnaireResponse.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FbasedOnList) and isEmptyProp(FparentList) and isEmptyProp(FQuestionnaire) and isEmptyProp(FStatus) and isEmptyProp(FSubject) and isEmptyProp(FContext) and isEmptyProp(FAuthored) and isEmptyProp(FAuthor) and isEmptyProp(FSource) and isEmptyProp(FitemList);
end;

function TFhirQuestionnaireResponse.equals(other : TObject) : boolean;
var
  o : TFhirQuestionnaireResponse;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirQuestionnaireResponse)) then
    result := false
  else
  begin
    o := TFhirQuestionnaireResponse(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(basedOnList, o.basedOnList, true) and
      compareDeep(parentList, o.parentList, true) and compareDeep(questionnaireElement, o.questionnaireElement, true) and
      compareDeep(statusElement, o.statusElement, true) and compareDeep(subjectElement, o.subjectElement, true) and
      compareDeep(contextElement, o.contextElement, true) and compareDeep(authoredElement, o.authoredElement, true) and
      compareDeep(authorElement, o.authorElement, true) and compareDeep(sourceElement, o.sourceElement, true) and
      compareDeep(itemList, o.itemList, true);
  end;
end;

function TFhirQuestionnaireResponse.Link : TFhirQuestionnaireResponse;
begin
  result := TFhirQuestionnaireResponse(inherited Link);
end;

function TFhirQuestionnaireResponse.Clone : TFhirQuestionnaireResponse;
begin
  result := TFhirQuestionnaireResponse(inherited Clone);
end;

procedure TFhirQuestionnaireResponse.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('basedOn');
  fields.add('parent');
  fields.add('questionnaire');
  fields.add('status');
  fields.add('subject');
  fields.add('context');
  fields.add('authored');
  fields.add('author');
  fields.add('source');
  fields.add('item');
end;

{ TFhirQuestionnaireResponse }

Procedure TFhirQuestionnaireResponse.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Function TFhirQuestionnaireResponse.GetBasedOnList : TFhirReferenceList{Resource};
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList{Resource}.Create;
  result := FBasedOnList;
end;

Function TFhirQuestionnaireResponse.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

Function TFhirQuestionnaireResponse.GetParentList : TFhirReferenceList{Resource};
begin
  if FParentList = nil then
    FParentList := TFhirReferenceList{Resource}.Create;
  result := FParentList;
end;

Function TFhirQuestionnaireResponse.GetHasParentList : boolean;
begin
  result := (FParentList <> nil) and (FParentList.count > 0);
end;

Procedure TFhirQuestionnaireResponse.SetQuestionnaire(value : TFhirReference{TFhirQuestionnaire});
begin
  FQuestionnaire.free;
  FQuestionnaire := value;
end;

Procedure TFhirQuestionnaireResponse.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirQuestionnaireResponse.GetStatusST : TFhirQuestionnaireAnswersStatusEnum;
begin
  if FStatus = nil then
    result := TFhirQuestionnaireAnswersStatusEnum(0)
  else
    result := TFhirQuestionnaireAnswersStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirQuestionnaireAnswersStatusEnum, FStatus.value));
end;

Procedure TFhirQuestionnaireResponse.SetStatusST(value : TFhirQuestionnaireAnswersStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirQuestionnaireAnswersStatusEnum[value], CODES_TFhirQuestionnaireAnswersStatusEnum[value]);
end;

Procedure TFhirQuestionnaireResponse.SetSubject(value : TFhirReference{TFhirReference});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirQuestionnaireResponse.SetContext(value : TFhirReference{Resource});
begin
  FContext.free;
  FContext := value;
end;

Procedure TFhirQuestionnaireResponse.SetAuthored(value : TFhirDateTime);
begin
  FAuthored.free;
  FAuthored := value;
end;

Function TFhirQuestionnaireResponse.GetAuthoredST : TFslDateTime;
begin
  if FAuthored = nil then
    result := TFslDateTime.makeNull
  else
    result := FAuthored.value;
end;

Procedure TFhirQuestionnaireResponse.SetAuthoredST(value : TFslDateTime);
begin
  if FAuthored = nil then
    FAuthored := TFhirDateTime.create;
  FAuthored.value := value
end;

Procedure TFhirQuestionnaireResponse.SetAuthor(value : TFhirReference{Resource});
begin
  FAuthor.free;
  FAuthor := value;
end;

Procedure TFhirQuestionnaireResponse.SetSource(value : TFhirReference{Resource});
begin
  FSource.free;
  FSource := value;
end;

Function TFhirQuestionnaireResponse.GetItemList : TFhirQuestionnaireResponseItemList;
begin
  if FItemList = nil then
    FItemList := TFhirQuestionnaireResponseItemList.Create;
  result := FItemList;
end;

Function TFhirQuestionnaireResponse.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

function TFhirQuestionnaireResponse.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FbasedOnList.sizeInBytes);
  inc(result, FparentList.sizeInBytes);
  inc(result, FQuestionnaire.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FContext.sizeInBytes);
  inc(result, FAuthored.sizeInBytes);
  inc(result, FAuthor.sizeInBytes);
  inc(result, FSource.sizeInBytes);
  inc(result, FitemList.sizeInBytes);
end;

{ TFhirQuestionnaireResponseListEnumerator }

Constructor TFhirQuestionnaireResponseListEnumerator.Create(list : TFhirQuestionnaireResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirQuestionnaireResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirQuestionnaireResponseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirQuestionnaireResponseListEnumerator.GetCurrent : TFhirQuestionnaireResponse;
begin
  Result := FList[FIndex];
end;

function TFhirQuestionnaireResponseListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirQuestionnaireResponseList }
procedure TFhirQuestionnaireResponseList.AddItem(value: TFhirQuestionnaireResponse);
begin
  assert(value.ClassName = 'TFhirQuestionnaireResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirQuestionnaireResponse');
  add(value);
end;

function TFhirQuestionnaireResponseList.Append: TFhirQuestionnaireResponse;
begin
  result := TFhirQuestionnaireResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireResponseList.ClearItems;
begin
  Clear;
end;

function TFhirQuestionnaireResponseList.GetEnumerator : TFhirQuestionnaireResponseListEnumerator;
begin
  result := TFhirQuestionnaireResponseListEnumerator.Create(self.link);
end;

function TFhirQuestionnaireResponseList.Clone: TFhirQuestionnaireResponseList;
begin
  result := TFhirQuestionnaireResponseList(inherited Clone);
end;

function TFhirQuestionnaireResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirQuestionnaireResponseList.GetItemN(index: Integer): TFhirQuestionnaireResponse;
begin
  result := TFhirQuestionnaireResponse(ObjectByIndex[index]);
end;

function TFhirQuestionnaireResponseList.ItemClass: TFslObjectClass;
begin
  result := TFhirQuestionnaireResponse;
end;
function TFhirQuestionnaireResponseList.IndexOf(value: TFhirQuestionnaireResponse): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirQuestionnaireResponseList.Insert(index: Integer): TFhirQuestionnaireResponse;
begin
  result := TFhirQuestionnaireResponse.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireResponseList.InsertItem(index: Integer; value: TFhirQuestionnaireResponse);
begin
  assert(value is TFhirQuestionnaireResponse);
  Inherited Insert(index, value);
end;

function TFhirQuestionnaireResponseList.Item(index: Integer): TFhirQuestionnaireResponse;
begin
  result := TFhirQuestionnaireResponse(ObjectByIndex[index]);
end;

function TFhirQuestionnaireResponseList.Link: TFhirQuestionnaireResponseList;
begin
  result := TFhirQuestionnaireResponseList(inherited Link);
end;

procedure TFhirQuestionnaireResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirQuestionnaireResponseList.SetItemByIndex(index: Integer; value: TFhirQuestionnaireResponse);
begin
  assert(value is TFhirQuestionnaireResponse);
  FhirQuestionnaireResponses[index] := value;
end;

procedure TFhirQuestionnaireResponseList.SetItemN(index: Integer; value: TFhirQuestionnaireResponse);
begin
  assert(value is TFhirQuestionnaireResponse);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_QUESTIONNAIRERESPONSE}

{$IFDEF FHIR_REFERRALREQUEST}

{ TFhirReferralRequestRequester }

constructor TFhirReferralRequestRequester.Create;
begin
  inherited;
end;

destructor TFhirReferralRequestRequester.Destroy;
begin
  FAgent.free;
  FOnBehalfOf.free;
  inherited;
end;

procedure TFhirReferralRequestRequester.Assign(oSource : TFslObject);
begin
  inherited;
  agent := TFhirReferralRequestRequester(oSource).agent.Clone;
  onBehalfOf := TFhirReferralRequestRequester(oSource).onBehalfOf.Clone;
end;

procedure TFhirReferralRequestRequester.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'agent') Then
     list.add(self.link, 'agent', FAgent.Link);
  if (child_name = 'onBehalfOf') Then
     list.add(self.link, 'onBehalfOf', FOnBehalfOf.Link);
end;

procedure TFhirReferralRequestRequester.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'agent', 'Reference(Practitioner|Organization|Patient|RelatedPerson|Device)', false, TFhirReference{Resource}, FAgent.Link));{2}
  oList.add(TFHIRProperty.create(self, 'onBehalfOf', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FOnBehalfOf.Link));{2}
end;

function TFhirReferralRequestRequester.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'agent') then
  begin
    Agent := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'onBehalfOf') then
  begin
    OnBehalfOf := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirReferralRequestRequester.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirReferralRequestRequester.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'agent') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'onBehalfOf') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirReferralRequestRequester.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'agent') then result := 'Reference'
  else if (propName = 'onBehalfOf') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirReferralRequestRequester.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'agent') then AgentElement := nil
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirReferralRequestRequester.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'agent') then AgentElement := new as TFhirReference{Resource}{4}
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := new as TFhirReference{TFhirOrganization}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirReferralRequestRequester.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirReferralRequestRequester.fhirType : string;
begin
  result := 'requester';
end;

function TFhirReferralRequestRequester.Link : TFhirReferralRequestRequester;
begin
  result := TFhirReferralRequestRequester(inherited Link);
end;

function TFhirReferralRequestRequester.Clone : TFhirReferralRequestRequester;
begin
  result := TFhirReferralRequestRequester(inherited Clone);
end;

function TFhirReferralRequestRequester.equals(other : TObject) : boolean;
var
  o : TFhirReferralRequestRequester;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirReferralRequestRequester)) then
    result := false
  else
  begin
    o := TFhirReferralRequestRequester(other);
    result := compareDeep(agentElement, o.agentElement, true) and compareDeep(onBehalfOfElement, o.onBehalfOfElement, true);
  end;
end;

function TFhirReferralRequestRequester.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAgent) and isEmptyProp(FOnBehalfOf);
end;

procedure TFhirReferralRequestRequester.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('agent');
  fields.add('onBehalfOf');
end;

{ TFhirReferralRequestRequester }

Procedure TFhirReferralRequestRequester.SetAgent(value : TFhirReference{Resource});
begin
  FAgent.free;
  FAgent := value;
end;

Procedure TFhirReferralRequestRequester.SetOnBehalfOf(value : TFhirReference{TFhirOrganization});
begin
  FOnBehalfOf.free;
  FOnBehalfOf := value;
end;

function TFhirReferralRequestRequester.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FAgent.sizeInBytes);
  inc(result, FOnBehalfOf.sizeInBytes);
end;

{ TFhirReferralRequestRequesterListEnumerator }

Constructor TFhirReferralRequestRequesterListEnumerator.Create(list : TFhirReferralRequestRequesterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirReferralRequestRequesterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirReferralRequestRequesterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirReferralRequestRequesterListEnumerator.GetCurrent : TFhirReferralRequestRequester;
begin
  Result := FList[FIndex];
end;

function TFhirReferralRequestRequesterListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirReferralRequestRequesterList }
procedure TFhirReferralRequestRequesterList.AddItem(value: TFhirReferralRequestRequester);
begin
  assert(value.ClassName = 'TFhirReferralRequestRequester', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirReferralRequestRequester');
  add(value);
end;

function TFhirReferralRequestRequesterList.Append: TFhirReferralRequestRequester;
begin
  result := TFhirReferralRequestRequester.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirReferralRequestRequesterList.ClearItems;
begin
  Clear;
end;

function TFhirReferralRequestRequesterList.GetEnumerator : TFhirReferralRequestRequesterListEnumerator;
begin
  result := TFhirReferralRequestRequesterListEnumerator.Create(self.link);
end;

function TFhirReferralRequestRequesterList.Clone: TFhirReferralRequestRequesterList;
begin
  result := TFhirReferralRequestRequesterList(inherited Clone);
end;

function TFhirReferralRequestRequesterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirReferralRequestRequesterList.GetItemN(index: Integer): TFhirReferralRequestRequester;
begin
  result := TFhirReferralRequestRequester(ObjectByIndex[index]);
end;

function TFhirReferralRequestRequesterList.ItemClass: TFslObjectClass;
begin
  result := TFhirReferralRequestRequester;
end;
function TFhirReferralRequestRequesterList.IndexOf(value: TFhirReferralRequestRequester): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirReferralRequestRequesterList.Insert(index: Integer): TFhirReferralRequestRequester;
begin
  result := TFhirReferralRequestRequester.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirReferralRequestRequesterList.InsertItem(index: Integer; value: TFhirReferralRequestRequester);
begin
  assert(value is TFhirReferralRequestRequester);
  Inherited Insert(index, value);
end;

function TFhirReferralRequestRequesterList.Item(index: Integer): TFhirReferralRequestRequester;
begin
  result := TFhirReferralRequestRequester(ObjectByIndex[index]);
end;

function TFhirReferralRequestRequesterList.Link: TFhirReferralRequestRequesterList;
begin
  result := TFhirReferralRequestRequesterList(inherited Link);
end;

procedure TFhirReferralRequestRequesterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirReferralRequestRequesterList.SetItemByIndex(index: Integer; value: TFhirReferralRequestRequester);
begin
  assert(value is TFhirReferralRequestRequester);
  FhirReferralRequestRequesters[index] := value;
end;

procedure TFhirReferralRequestRequesterList.SetItemN(index: Integer; value: TFhirReferralRequestRequester);
begin
  assert(value is TFhirReferralRequestRequester);
  ObjectByIndex[index] := value;
end;

{ TFhirReferralRequest }

constructor TFhirReferralRequest.Create;
begin
  inherited;
end;

destructor TFhirReferralRequest.Destroy;
begin
  FIdentifierList.Free;
  FDefinitionList.Free;
  FBasedOnList.Free;
  FReplacesList.Free;
  FGroupIdentifier.free;
  FStatus.free;
  FIntent.free;
  FType_.free;
  FPriority.free;
  FServiceRequestedList.Free;
  FSubject.free;
  FContext.free;
  FOccurrence.free;
  FAuthoredOn.free;
  FRequester.free;
  FSpecialty.free;
  FRecipientList.Free;
  FReasonCodeList.Free;
  FReasonReferenceList.Free;
  FDescription.free;
  FSupportingInfoList.Free;
  FNoteList.Free;
  FRelevantHistoryList.Free;
  inherited;
end;

function TFhirReferralRequest.GetResourceType : TFhirResourceType;
begin
  result := frtReferralRequest;
end;

procedure TFhirReferralRequest.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirReferralRequest(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirReferralRequest(oSource).FIdentifierList);
  end;
  if (TFhirReferralRequest(oSource).FDefinitionList = nil) then
  begin
    FDefinitionList.free;
    FDefinitionList := nil;
  end
  else
  begin
    if FDefinitionList = nil then
      FDefinitionList := TFhirReferenceList{Resource}.Create;
    FDefinitionList.Assign(TFhirReferralRequest(oSource).FDefinitionList);
  end;
  if (TFhirReferralRequest(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList{Resource}.Create;
    FBasedOnList.Assign(TFhirReferralRequest(oSource).FBasedOnList);
  end;
  if (TFhirReferralRequest(oSource).FReplacesList = nil) then
  begin
    FReplacesList.free;
    FReplacesList := nil;
  end
  else
  begin
    if FReplacesList = nil then
      FReplacesList := TFhirReferenceList{TFhirReferralRequest}.Create;
    FReplacesList.Assign(TFhirReferralRequest(oSource).FReplacesList);
  end;
  groupIdentifier := TFhirReferralRequest(oSource).groupIdentifier.Clone;
  FStatus := TFhirReferralRequest(oSource).FStatus.Link;
  FIntent := TFhirReferralRequest(oSource).FIntent.Link;
  type_ := TFhirReferralRequest(oSource).type_.Clone;
  FPriority := TFhirReferralRequest(oSource).FPriority.Link;
  if (TFhirReferralRequest(oSource).FServiceRequestedList = nil) then
  begin
    FServiceRequestedList.free;
    FServiceRequestedList := nil;
  end
  else
  begin
    if FServiceRequestedList = nil then
      FServiceRequestedList := TFhirCodeableConceptList.Create;
    FServiceRequestedList.Assign(TFhirReferralRequest(oSource).FServiceRequestedList);
  end;
  subject := TFhirReferralRequest(oSource).subject.Clone;
  context := TFhirReferralRequest(oSource).context.Clone;
  occurrence := TFhirReferralRequest(oSource).occurrence.Clone;
  authoredOnElement := TFhirReferralRequest(oSource).authoredOnElement.Clone;
  requester := TFhirReferralRequest(oSource).requester.Clone;
  specialty := TFhirReferralRequest(oSource).specialty.Clone;
  if (TFhirReferralRequest(oSource).FRecipientList = nil) then
  begin
    FRecipientList.free;
    FRecipientList := nil;
  end
  else
  begin
    if FRecipientList = nil then
      FRecipientList := TFhirReferenceList{Resource}.Create;
    FRecipientList.Assign(TFhirReferralRequest(oSource).FRecipientList);
  end;
  if (TFhirReferralRequest(oSource).FReasonCodeList = nil) then
  begin
    FReasonCodeList.free;
    FReasonCodeList := nil;
  end
  else
  begin
    if FReasonCodeList = nil then
      FReasonCodeList := TFhirCodeableConceptList.Create;
    FReasonCodeList.Assign(TFhirReferralRequest(oSource).FReasonCodeList);
  end;
  if (TFhirReferralRequest(oSource).FReasonReferenceList = nil) then
  begin
    FReasonReferenceList.free;
    FReasonReferenceList := nil;
  end
  else
  begin
    if FReasonReferenceList = nil then
      FReasonReferenceList := TFhirReferenceList{Resource}.Create;
    FReasonReferenceList.Assign(TFhirReferralRequest(oSource).FReasonReferenceList);
  end;
  descriptionElement := TFhirReferralRequest(oSource).descriptionElement.Clone;
  if (TFhirReferralRequest(oSource).FSupportingInfoList = nil) then
  begin
    FSupportingInfoList.free;
    FSupportingInfoList := nil;
  end
  else
  begin
    if FSupportingInfoList = nil then
      FSupportingInfoList := TFhirReferenceList{TFhirReference}.Create;
    FSupportingInfoList.Assign(TFhirReferralRequest(oSource).FSupportingInfoList);
  end;
  if (TFhirReferralRequest(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirReferralRequest(oSource).FNoteList);
  end;
  if (TFhirReferralRequest(oSource).FRelevantHistoryList = nil) then
  begin
    FRelevantHistoryList.free;
    FRelevantHistoryList := nil;
  end
  else
  begin
    if FRelevantHistoryList = nil then
      FRelevantHistoryList := TFhirReferenceList{TFhirProvenance}.Create;
    FRelevantHistoryList.Assign(TFhirReferralRequest(oSource).FRelevantHistoryList);
  end;
end;

procedure TFhirReferralRequest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'definition') Then
    list.addAll(self, 'definition', FDefinitionList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'replaces') Then
    list.addAll(self, 'replaces', FReplacesList);
  if (child_name = 'groupIdentifier') Then
     list.add(self.link, 'groupIdentifier', FGroupIdentifier.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'intent') Then
     list.add(self.link, 'intent', FIntent.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'serviceRequested') Then
    list.addAll(self, 'serviceRequested', FServiceRequestedList);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
  if (child_name = 'occurrence[x]') or (child_name = 'occurrence') Then
     list.add(self.link, 'occurrence[x]', FOccurrence.Link);
  if (child_name = 'authoredOn') Then
     list.add(self.link, 'authoredOn', FAuthoredOn.Link);
  if (child_name = 'requester') Then
     list.add(self.link, 'requester', FRequester.Link);
  if (child_name = 'specialty') Then
     list.add(self.link, 'specialty', FSpecialty.Link);
  if (child_name = 'recipient') Then
    list.addAll(self, 'recipient', FRecipientList);
  if (child_name = 'reasonCode') Then
    list.addAll(self, 'reasonCode', FReasonCodeList);
  if (child_name = 'reasonReference') Then
    list.addAll(self, 'reasonReference', FReasonReferenceList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'supportingInfo') Then
    list.addAll(self, 'supportingInfo', FSupportingInfoList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'relevantHistory') Then
    list.addAll(self, 'relevantHistory', FRelevantHistoryList);
end;

procedure TFhirReferralRequest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'definition', 'Reference(ActivityDefinition|PlanDefinition)', true, TFhirReference{Resource}, FDefinitionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference(ReferralRequest|CarePlan|ProcedureRequest)', true, TFhirReference{Resource}, FBasedOnList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'replaces', 'Reference(ReferralRequest)', true, TFhirReference{TFhirReferralRequest}, FReplacesList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'groupIdentifier', 'Identifier', false, TFhirIdentifier, FGroupIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'intent', 'code', false, TFHIREnum, FIntent.Link));{1}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'priority', 'code', false, TFHIREnum, FPriority.Link));{1}
  oList.add(TFHIRProperty.create(self, 'serviceRequested', 'CodeableConcept', true, TFhirCodeableConcept, FServiceRequestedList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Group)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'context', 'Reference(Encounter|EpisodeOfCare)', false, TFhirReference{Resource}, FContext.Link));{2}
  oList.add(TFHIRProperty.create(self, 'occurrence[x]', 'dateTime|Period', false, TFhirType, FOccurrence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'authoredOn', 'dateTime', false, TFhirDateTime, FAuthoredOn.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requester', '', false, TFhirReferralRequestRequester, FRequester.Link));{2}
  oList.add(TFHIRProperty.create(self, 'specialty', 'CodeableConcept', false, TFhirCodeableConcept, FSpecialty.Link));{2}
  oList.add(TFHIRProperty.create(self, 'recipient', 'Reference(Practitioner|Organization|HealthcareService)', true, TFhirReference{Resource}, FRecipientList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reasonCode', 'CodeableConcept', true, TFhirCodeableConcept, FReasonCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reasonReference', 'Reference(Condition|Observation)', true, TFhirReference{Resource}, FReasonReferenceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'supportingInfo', 'Reference(Any)', true, TFhirReference{TFhirReference}, FSupportingInfoList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'relevantHistory', 'Reference(Provenance)', true, TFhirReference{TFhirProvenance}, FRelevantHistoryList.Link)){3};
end;

function TFhirReferralRequest.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'definition') then
  begin
    DefinitionList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'replaces') then
  begin
    ReplacesList.add(propValue as TFhirReference{TFhirReferralRequest}){2a};
    result := propValue;
  end
  else if (propName = 'groupIdentifier') then
  begin
    GroupIdentifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirRequestStatusEnum, CODES_TFhirRequestStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'intent') then
  begin
    IntentElement := asEnum(SYSTEMS_TFhirRequestIntentEnum, CODES_TFhirRequestIntentEnum, propValue);
    result := propValue
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, propValue);
    result := propValue
  end
  else if (propName = 'serviceRequested') then
  begin
    ServiceRequestedList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'context') then
  begin
    Context := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period'])) then
  begin
    Occurrence := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'authoredOn') then
  begin
    AuthoredOnElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'requester') then
  begin
    Requester := propValue as TFhirReferralRequestRequester{4b};
    result := propValue;
  end
  else if (propName = 'specialty') then
  begin
    Specialty := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'recipient') then
  begin
    RecipientList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'reasonCode') then
  begin
    ReasonCodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'reasonReference') then
  begin
    ReasonReferenceList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'supportingInfo') then
  begin
    SupportingInfoList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else if (propName = 'relevantHistory') then
  begin
    RelevantHistoryList.add(propValue as TFhirReference{TFhirProvenance}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirReferralRequest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'definition') then DefinitionList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'replaces') then ReplacesList.insertItem(index, propValue as TFhirReference{TFhirReferralRequest}){2a}
  else if (propName = 'serviceRequested') then ServiceRequestedList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'recipient') then RecipientList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'reasonCode') then ReasonCodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'reasonReference') then ReasonReferenceList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'supportingInfo') then SupportingInfoList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else if (propName = 'relevantHistory') then RelevantHistoryList.insertItem(index, propValue as TFhirReference{TFhirProvenance}){2a}
  else inherited;
end;

function TFhirReferralRequest.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'definition') then result := DefinitionList.new(){2}
  else if (propName = 'basedOn') then result := BasedOnList.new(){2}
  else if (propName = 'replaces') then result := ReplacesList.new(){2}
  else if (propName = 'groupIdentifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'serviceRequested') then result := ServiceRequestedList.new(){2}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'context') then result := TFhirReference{Resource}.create(){4b}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Occurrence'){4x}
  else if (propName = 'authoredOn') then result := TFhirDateTime.create() {5b}
  else if (propName = 'requester') then result := TFhirReferralRequestRequester.create(){4b}
  else if (propName = 'specialty') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'recipient') then result := RecipientList.new(){2}
  else if (propName = 'reasonCode') then result := ReasonCodeList.new(){2}
  else if (propName = 'reasonReference') then result := ReasonReferenceList.new(){2}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'supportingInfo') then result := SupportingInfoList.new(){2}
  else if (propName = 'note') then result := NoteList.new(){2}
  else if (propName = 'relevantHistory') then result := RelevantHistoryList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirReferralRequest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'definition') then result := 'Reference'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'replaces') then result := 'Reference'
  else if (propName = 'groupIdentifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'intent') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'priority') then result := 'code'
  else if (propName = 'serviceRequested') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'context') then result := 'Reference'
  else if (propName = 'occurrence[x]') then result := 'dateTime|Period'
  else if (propName = 'authoredOn') then result := 'dateTime'
  else if (propName = 'requester') then result := ''
  else if (propName = 'specialty') then result := 'CodeableConcept'
  else if (propName = 'recipient') then result := 'Reference'
  else if (propName = 'reasonCode') then result := 'CodeableConcept'
  else if (propName = 'reasonReference') then result := 'Reference'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'supportingInfo') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'relevantHistory') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirReferralRequest.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'definition') then deletePropertyValue('definition', DefinitionList, value) {2}
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value) {2}
  else if (propName = 'replaces') then deletePropertyValue('replaces', ReplacesList, value) {2}
  else if (propName = 'groupIdentifier') then GroupIdentifierElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'intent') then IntentElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'serviceRequested') then deletePropertyValue('serviceRequested', ServiceRequestedList, value) {2}
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'context') then ContextElement := nil
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period'])) then OccurrenceElement := nil{4x}
  else if (propName = 'authoredOn') then AuthoredOnElement := nil
  else if (propName = 'requester') then RequesterElement := nil
  else if (propName = 'specialty') then SpecialtyElement := nil
  else if (propName = 'recipient') then deletePropertyValue('recipient', RecipientList, value) {2}
  else if (propName = 'reasonCode') then deletePropertyValue('reasonCode', ReasonCodeList, value) {2}
  else if (propName = 'reasonReference') then deletePropertyValue('reasonReference', ReasonReferenceList, value) {2}
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'supportingInfo') then deletePropertyValue('supportingInfo', SupportingInfoList, value) {2}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else if (propName = 'relevantHistory') then deletePropertyValue('relevantHistory', RelevantHistoryList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirReferralRequest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'definition') then replacePropertyValue('definition', DefinitionList, existing, new) {2}
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new) {2}
  else if (propName = 'replaces') then replacePropertyValue('replaces', ReplacesList, existing, new) {2}
  else if (propName = 'groupIdentifier') then GroupIdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirRequestStatusEnum, CODES_TFhirRequestStatusEnum, new){4}
  else if (propName = 'intent') then IntentElement := asEnum(SYSTEMS_TFhirRequestIntentEnum, CODES_TFhirRequestIntentEnum, new){4}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'priority') then PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, new){4}
  else if (propName = 'serviceRequested') then replacePropertyValue('serviceRequested', ServiceRequestedList, existing, new) {2}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'context') then ContextElement := new as TFhirReference{Resource}{4}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period'])) then OccurrenceElement := new as TFhirType{4x}
  else if (propName = 'authoredOn') then AuthoredOnElement := asDateTime(new){5b}
  else if (propName = 'requester') then RequesterElement := new as TFhirReferralRequestRequester{4}
  else if (propName = 'specialty') then SpecialtyElement := new as TFhirCodeableConcept{4}
  else if (propName = 'recipient') then replacePropertyValue('recipient', RecipientList, existing, new) {2}
  else if (propName = 'reasonCode') then replacePropertyValue('reasonCode', ReasonCodeList, existing, new) {2}
  else if (propName = 'reasonReference') then replacePropertyValue('reasonReference', ReasonReferenceList, existing, new) {2}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'supportingInfo') then replacePropertyValue('supportingInfo', SupportingInfoList, existing, new) {2}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else if (propName = 'relevantHistory') then replacePropertyValue('relevantHistory', RelevantHistoryList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirReferralRequest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'definition') then DefinitionList.move(source, destination){2a}
  else if (propName = 'basedOn') then BasedOnList.move(source, destination){2a}
  else if (propName = 'replaces') then ReplacesList.move(source, destination){2a}
  else if (propName = 'serviceRequested') then ServiceRequestedList.move(source, destination){2a}
  else if (propName = 'recipient') then RecipientList.move(source, destination){2a}
  else if (propName = 'reasonCode') then ReasonCodeList.move(source, destination){2a}
  else if (propName = 'reasonReference') then ReasonReferenceList.move(source, destination){2a}
  else if (propName = 'supportingInfo') then SupportingInfoList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else if (propName = 'relevantHistory') then RelevantHistoryList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirReferralRequest.fhirType : string;
begin
  result := 'ReferralRequest';
end;

function TFhirReferralRequest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FdefinitionList) and isEmptyProp(FbasedOnList) and isEmptyProp(FreplacesList) and isEmptyProp(FGroupIdentifier) and isEmptyProp(FStatus) and isEmptyProp(FIntent) and isEmptyProp(FType_) and isEmptyProp(FPriority) and isEmptyProp(FserviceRequestedList) and isEmptyProp(FSubject) and isEmptyProp(FContext) and isEmptyProp(FOccurrence) and isEmptyProp(FAuthoredOn) and isEmptyProp(FRequester) and isEmptyProp(FSpecialty) and isEmptyProp(FrecipientList) and isEmptyProp(FreasonCodeList) and isEmptyProp(FreasonReferenceList) and isEmptyProp(FDescription) and isEmptyProp(FsupportingInfoList) and isEmptyProp(FnoteList) and isEmptyProp(FrelevantHistoryList);
end;

function TFhirReferralRequest.equals(other : TObject) : boolean;
var
  o : TFhirReferralRequest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirReferralRequest)) then
    result := false
  else
  begin
    o := TFhirReferralRequest(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(definitionList, o.definitionList, true) and
      compareDeep(basedOnList, o.basedOnList, true) and compareDeep(replacesList, o.replacesList, true) and
      compareDeep(groupIdentifierElement, o.groupIdentifierElement, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(intentElement, o.intentElement, true) and compareDeep(type_Element, o.type_Element, true) and
      compareDeep(priorityElement, o.priorityElement, true) and compareDeep(serviceRequestedList, o.serviceRequestedList, true) and
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(contextElement, o.contextElement, true) and
      compareDeep(occurrenceElement, o.occurrenceElement, true) and compareDeep(authoredOnElement, o.authoredOnElement, true) and
      compareDeep(requesterElement, o.requesterElement, true) and compareDeep(specialtyElement, o.specialtyElement, true) and
      compareDeep(recipientList, o.recipientList, true) and compareDeep(reasonCodeList, o.reasonCodeList, true) and
      compareDeep(reasonReferenceList, o.reasonReferenceList, true) and compareDeep(descriptionElement, o.descriptionElement, true) and
      compareDeep(supportingInfoList, o.supportingInfoList, true) and compareDeep(noteList, o.noteList, true) and
      compareDeep(relevantHistoryList, o.relevantHistoryList, true);
  end;
end;

function TFhirReferralRequest.Link : TFhirReferralRequest;
begin
  result := TFhirReferralRequest(inherited Link);
end;

function TFhirReferralRequest.Clone : TFhirReferralRequest;
begin
  result := TFhirReferralRequest(inherited Clone);
end;

procedure TFhirReferralRequest.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('definition');
  fields.add('basedOn');
  fields.add('replaces');
  fields.add('groupIdentifier');
  fields.add('status');
  fields.add('intent');
  fields.add('type');
  fields.add('priority');
  fields.add('serviceRequested');
  fields.add('subject');
  fields.add('context');
  fields.add('occurrence[x]');
  fields.add('authoredOn');
  fields.add('requester');
  fields.add('specialty');
  fields.add('recipient');
  fields.add('reasonCode');
  fields.add('reasonReference');
  fields.add('description');
  fields.add('supportingInfo');
  fields.add('note');
  fields.add('relevantHistory');
end;

{ TFhirReferralRequest }

Function TFhirReferralRequest.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirReferralRequest.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Function TFhirReferralRequest.GetDefinitionList : TFhirReferenceList{Resource};
begin
  if FDefinitionList = nil then
    FDefinitionList := TFhirReferenceList{Resource}.Create;
  result := FDefinitionList;
end;

Function TFhirReferralRequest.GetHasDefinitionList : boolean;
begin
  result := (FDefinitionList <> nil) and (FDefinitionList.count > 0);
end;

Function TFhirReferralRequest.GetBasedOnList : TFhirReferenceList{Resource};
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList{Resource}.Create;
  result := FBasedOnList;
end;

Function TFhirReferralRequest.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

Function TFhirReferralRequest.GetReplacesList : TFhirReferenceList{TFhirReferralRequest};
begin
  if FReplacesList = nil then
    FReplacesList := TFhirReferenceList{TFhirReferralRequest}.Create;
  result := FReplacesList;
end;

Function TFhirReferralRequest.GetHasReplacesList : boolean;
begin
  result := (FReplacesList <> nil) and (FReplacesList.count > 0);
end;

Procedure TFhirReferralRequest.SetGroupIdentifier(value : TFhirIdentifier);
begin
  FGroupIdentifier.free;
  FGroupIdentifier := value;
end;

Procedure TFhirReferralRequest.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirReferralRequest.GetStatusST : TFhirRequestStatusEnum;
begin
  if FStatus = nil then
    result := TFhirRequestStatusEnum(0)
  else
    result := TFhirRequestStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestStatusEnum, FStatus.value));
end;

Procedure TFhirReferralRequest.SetStatusST(value : TFhirRequestStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirRequestStatusEnum[value], CODES_TFhirRequestStatusEnum[value]);
end;

Procedure TFhirReferralRequest.SetIntent(value : TFhirEnum);
begin
  FIntent.free;
  FIntent := value;
end;

Function TFhirReferralRequest.GetIntentST : TFhirRequestIntentEnum;
begin
  if FIntent = nil then
    result := TFhirRequestIntentEnum(0)
  else
    result := TFhirRequestIntentEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestIntentEnum, FIntent.value));
end;

Procedure TFhirReferralRequest.SetIntentST(value : TFhirRequestIntentEnum);
begin
  if ord(value) = 0 then
    IntentElement := nil
  else
    IntentElement := TFhirEnum.create(SYSTEMS_TFhirRequestIntentEnum[value], CODES_TFhirRequestIntentEnum[value]);
end;

Procedure TFhirReferralRequest.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirReferralRequest.SetPriority(value : TFhirEnum);
begin
  FPriority.free;
  FPriority := value;
end;

Function TFhirReferralRequest.GetPriorityST : TFhirRequestPriorityEnum;
begin
  if FPriority = nil then
    result := TFhirRequestPriorityEnum(0)
  else
    result := TFhirRequestPriorityEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestPriorityEnum, FPriority.value));
end;

Procedure TFhirReferralRequest.SetPriorityST(value : TFhirRequestPriorityEnum);
begin
  if ord(value) = 0 then
    PriorityElement := nil
  else
    PriorityElement := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[value], CODES_TFhirRequestPriorityEnum[value]);
end;

Function TFhirReferralRequest.GetServiceRequestedList : TFhirCodeableConceptList;
begin
  if FServiceRequestedList = nil then
    FServiceRequestedList := TFhirCodeableConceptList.Create;
  result := FServiceRequestedList;
end;

Function TFhirReferralRequest.GetHasServiceRequestedList : boolean;
begin
  result := (FServiceRequestedList <> nil) and (FServiceRequestedList.count > 0);
end;

Procedure TFhirReferralRequest.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirReferralRequest.SetContext(value : TFhirReference{Resource});
begin
  FContext.free;
  FContext := value;
end;

Procedure TFhirReferralRequest.SetOccurrence(value : TFhirType);
begin
  FOccurrence.free;
  FOccurrence := value;
end;

Procedure TFhirReferralRequest.SetAuthoredOn(value : TFhirDateTime);
begin
  FAuthoredOn.free;
  FAuthoredOn := value;
end;

Function TFhirReferralRequest.GetAuthoredOnST : TFslDateTime;
begin
  if FAuthoredOn = nil then
    result := TFslDateTime.makeNull
  else
    result := FAuthoredOn.value;
end;

Procedure TFhirReferralRequest.SetAuthoredOnST(value : TFslDateTime);
begin
  if FAuthoredOn = nil then
    FAuthoredOn := TFhirDateTime.create;
  FAuthoredOn.value := value
end;

Procedure TFhirReferralRequest.SetRequester(value : TFhirReferralRequestRequester);
begin
  FRequester.free;
  FRequester := value;
end;

Procedure TFhirReferralRequest.SetSpecialty(value : TFhirCodeableConcept);
begin
  FSpecialty.free;
  FSpecialty := value;
end;

Function TFhirReferralRequest.GetRecipientList : TFhirReferenceList{Resource};
begin
  if FRecipientList = nil then
    FRecipientList := TFhirReferenceList{Resource}.Create;
  result := FRecipientList;
end;

Function TFhirReferralRequest.GetHasRecipientList : boolean;
begin
  result := (FRecipientList <> nil) and (FRecipientList.count > 0);
end;

Function TFhirReferralRequest.GetReasonCodeList : TFhirCodeableConceptList;
begin
  if FReasonCodeList = nil then
    FReasonCodeList := TFhirCodeableConceptList.Create;
  result := FReasonCodeList;
end;

Function TFhirReferralRequest.GetHasReasonCodeList : boolean;
begin
  result := (FReasonCodeList <> nil) and (FReasonCodeList.count > 0);
end;

Function TFhirReferralRequest.GetReasonReferenceList : TFhirReferenceList{Resource};
begin
  if FReasonReferenceList = nil then
    FReasonReferenceList := TFhirReferenceList{Resource}.Create;
  result := FReasonReferenceList;
end;

Function TFhirReferralRequest.GetHasReasonReferenceList : boolean;
begin
  result := (FReasonReferenceList <> nil) and (FReasonReferenceList.count > 0);
end;

Procedure TFhirReferralRequest.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirReferralRequest.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirReferralRequest.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Function TFhirReferralRequest.GetSupportingInfoList : TFhirReferenceList{TFhirReference};
begin
  if FSupportingInfoList = nil then
    FSupportingInfoList := TFhirReferenceList{TFhirReference}.Create;
  result := FSupportingInfoList;
end;

Function TFhirReferralRequest.GetHasSupportingInfoList : boolean;
begin
  result := (FSupportingInfoList <> nil) and (FSupportingInfoList.count > 0);
end;

Function TFhirReferralRequest.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirReferralRequest.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

Function TFhirReferralRequest.GetRelevantHistoryList : TFhirReferenceList{TFhirProvenance};
begin
  if FRelevantHistoryList = nil then
    FRelevantHistoryList := TFhirReferenceList{TFhirProvenance}.Create;
  result := FRelevantHistoryList;
end;

Function TFhirReferralRequest.GetHasRelevantHistoryList : boolean;
begin
  result := (FRelevantHistoryList <> nil) and (FRelevantHistoryList.count > 0);
end;

function TFhirReferralRequest.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FdefinitionList.sizeInBytes);
  inc(result, FbasedOnList.sizeInBytes);
  inc(result, FreplacesList.sizeInBytes);
  inc(result, FGroupIdentifier.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FIntent.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FPriority.sizeInBytes);
  inc(result, FserviceRequestedList.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FContext.sizeInBytes);
  inc(result, FOccurrence.sizeInBytes);
  inc(result, FAuthoredOn.sizeInBytes);
  inc(result, FRequester.sizeInBytes);
  inc(result, FSpecialty.sizeInBytes);
  inc(result, FrecipientList.sizeInBytes);
  inc(result, FreasonCodeList.sizeInBytes);
  inc(result, FreasonReferenceList.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FsupportingInfoList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FrelevantHistoryList.sizeInBytes);
end;

{ TFhirReferralRequestListEnumerator }

Constructor TFhirReferralRequestListEnumerator.Create(list : TFhirReferralRequestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirReferralRequestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirReferralRequestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirReferralRequestListEnumerator.GetCurrent : TFhirReferralRequest;
begin
  Result := FList[FIndex];
end;

function TFhirReferralRequestListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirReferralRequestList }
procedure TFhirReferralRequestList.AddItem(value: TFhirReferralRequest);
begin
  assert(value.ClassName = 'TFhirReferralRequest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirReferralRequest');
  add(value);
end;

function TFhirReferralRequestList.Append: TFhirReferralRequest;
begin
  result := TFhirReferralRequest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirReferralRequestList.ClearItems;
begin
  Clear;
end;

function TFhirReferralRequestList.GetEnumerator : TFhirReferralRequestListEnumerator;
begin
  result := TFhirReferralRequestListEnumerator.Create(self.link);
end;

function TFhirReferralRequestList.Clone: TFhirReferralRequestList;
begin
  result := TFhirReferralRequestList(inherited Clone);
end;

function TFhirReferralRequestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirReferralRequestList.GetItemN(index: Integer): TFhirReferralRequest;
begin
  result := TFhirReferralRequest(ObjectByIndex[index]);
end;

function TFhirReferralRequestList.ItemClass: TFslObjectClass;
begin
  result := TFhirReferralRequest;
end;
function TFhirReferralRequestList.IndexOf(value: TFhirReferralRequest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirReferralRequestList.Insert(index: Integer): TFhirReferralRequest;
begin
  result := TFhirReferralRequest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirReferralRequestList.InsertItem(index: Integer; value: TFhirReferralRequest);
begin
  assert(value is TFhirReferralRequest);
  Inherited Insert(index, value);
end;

function TFhirReferralRequestList.Item(index: Integer): TFhirReferralRequest;
begin
  result := TFhirReferralRequest(ObjectByIndex[index]);
end;

function TFhirReferralRequestList.Link: TFhirReferralRequestList;
begin
  result := TFhirReferralRequestList(inherited Link);
end;

procedure TFhirReferralRequestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirReferralRequestList.SetItemByIndex(index: Integer; value: TFhirReferralRequest);
begin
  assert(value is TFhirReferralRequest);
  FhirReferralRequests[index] := value;
end;

procedure TFhirReferralRequestList.SetItemN(index: Integer; value: TFhirReferralRequest);
begin
  assert(value is TFhirReferralRequest);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_REFERRALREQUEST}

{$IFDEF FHIR_RISKASSESSMENT}

{ TFhirRiskAssessmentPrediction }

constructor TFhirRiskAssessmentPrediction.Create;
begin
  inherited;
end;

destructor TFhirRiskAssessmentPrediction.Destroy;
begin
  FOutcome.free;
  FProbability.free;
  FQualitativeRisk.free;
  FRelativeRisk.free;
  FWhen.free;
  FRationale.free;
  inherited;
end;

procedure TFhirRiskAssessmentPrediction.Assign(oSource : TFslObject);
begin
  inherited;
  outcome := TFhirRiskAssessmentPrediction(oSource).outcome.Clone;
  probability := TFhirRiskAssessmentPrediction(oSource).probability.Clone;
  qualitativeRisk := TFhirRiskAssessmentPrediction(oSource).qualitativeRisk.Clone;
  relativeRiskElement := TFhirRiskAssessmentPrediction(oSource).relativeRiskElement.Clone;
  when := TFhirRiskAssessmentPrediction(oSource).when.Clone;
  rationaleElement := TFhirRiskAssessmentPrediction(oSource).rationaleElement.Clone;
end;

procedure TFhirRiskAssessmentPrediction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'probability[x]') or (child_name = 'probability') Then
     list.add(self.link, 'probability[x]', FProbability.Link);
  if (child_name = 'qualitativeRisk') Then
     list.add(self.link, 'qualitativeRisk', FQualitativeRisk.Link);
  if (child_name = 'relativeRisk') Then
     list.add(self.link, 'relativeRisk', FRelativeRisk.Link);
  if (child_name = 'when[x]') or (child_name = 'when') Then
     list.add(self.link, 'when[x]', FWhen.Link);
  if (child_name = 'rationale') Then
     list.add(self.link, 'rationale', FRationale.Link);
end;

procedure TFhirRiskAssessmentPrediction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'outcome', 'CodeableConcept', false, TFhirCodeableConcept, FOutcome.Link));{2}
  oList.add(TFHIRProperty.create(self, 'probability[x]', 'decimal|Range', false, TFhirType, FProbability.Link));{2}
  oList.add(TFHIRProperty.create(self, 'qualitativeRisk', 'CodeableConcept', false, TFhirCodeableConcept, FQualitativeRisk.Link));{2}
  oList.add(TFHIRProperty.create(self, 'relativeRisk', 'decimal', false, TFhirDecimal, FRelativeRisk.Link));{2}
  oList.add(TFHIRProperty.create(self, 'when[x]', 'Period|Range', false, TFhirType, FWhen.Link));{2}
  oList.add(TFHIRProperty.create(self, 'rationale', 'string', false, TFhirString, FRationale.Link));{2}
end;

function TFhirRiskAssessmentPrediction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'outcome') then
  begin
    Outcome := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'probability', ['Decimal', 'Range'])) then
  begin
    Probability := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'qualitativeRisk') then
  begin
    QualitativeRisk := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'relativeRisk') then
  begin
    RelativeRiskElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'when', ['Period', 'Range'])) then
  begin
    When := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'rationale') then
  begin
    RationaleElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRiskAssessmentPrediction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirRiskAssessmentPrediction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'outcome') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'probability', ['Decimal', 'Range'])) then raise EFHIRException.create('Cannot make property Probability'){4x}
  else if (propName = 'qualitativeRisk') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'relativeRisk') then result := TFhirDecimal.create() {5b}
  else if (isMatchingName(propName, 'when', ['Period', 'Range'])) then raise EFHIRException.create('Cannot make property When'){4x}
  else if (propName = 'rationale') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirRiskAssessmentPrediction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'outcome') then result := 'CodeableConcept'
  else if (propName = 'probability[x]') then result := 'decimal|Range'
  else if (propName = 'qualitativeRisk') then result := 'CodeableConcept'
  else if (propName = 'relativeRisk') then result := 'decimal'
  else if (propName = 'when[x]') then result := 'Period|Range'
  else if (propName = 'rationale') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRiskAssessmentPrediction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'outcome') then OutcomeElement := nil
  else if (isMatchingName(propName, 'probability', ['Decimal', 'Range'])) then ProbabilityElement := nil{4x}
  else if (propName = 'qualitativeRisk') then QualitativeRiskElement := nil
  else if (propName = 'relativeRisk') then RelativeRiskElement := nil
  else if (isMatchingName(propName, 'when', ['Period', 'Range'])) then WhenElement := nil{4x}
  else if (propName = 'rationale') then RationaleElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRiskAssessmentPrediction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'outcome') then OutcomeElement := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'probability', ['Decimal', 'Range'])) then ProbabilityElement := new as TFhirType{4x}
  else if (propName = 'qualitativeRisk') then QualitativeRiskElement := new as TFhirCodeableConcept{4}
  else if (propName = 'relativeRisk') then RelativeRiskElement := asDecimal(new){5b}
  else if (isMatchingName(propName, 'when', ['Period', 'Range'])) then WhenElement := new as TFhirType{4x}
  else if (propName = 'rationale') then RationaleElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRiskAssessmentPrediction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirRiskAssessmentPrediction.fhirType : string;
begin
  result := 'prediction';
end;

function TFhirRiskAssessmentPrediction.Link : TFhirRiskAssessmentPrediction;
begin
  result := TFhirRiskAssessmentPrediction(inherited Link);
end;

function TFhirRiskAssessmentPrediction.Clone : TFhirRiskAssessmentPrediction;
begin
  result := TFhirRiskAssessmentPrediction(inherited Clone);
end;

function TFhirRiskAssessmentPrediction.equals(other : TObject) : boolean;
var
  o : TFhirRiskAssessmentPrediction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRiskAssessmentPrediction)) then
    result := false
  else
  begin
    o := TFhirRiskAssessmentPrediction(other);
    result := compareDeep(outcomeElement, o.outcomeElement, true) and compareDeep(probabilityElement, o.probabilityElement, true) and
      compareDeep(qualitativeRiskElement, o.qualitativeRiskElement, true) and compareDeep(relativeRiskElement, o.relativeRiskElement, true) and
      compareDeep(whenElement, o.whenElement, true) and compareDeep(rationaleElement, o.rationaleElement, true);
  end;
end;

function TFhirRiskAssessmentPrediction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FOutcome) and isEmptyProp(FProbability) and isEmptyProp(FQualitativeRisk) and isEmptyProp(FRelativeRisk) and isEmptyProp(FWhen) and isEmptyProp(FRationale);
end;

procedure TFhirRiskAssessmentPrediction.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('outcome');
  fields.add('probability[x]');
  fields.add('qualitativeRisk');
  fields.add('relativeRisk');
  fields.add('when[x]');
  fields.add('rationale');
end;

{ TFhirRiskAssessmentPrediction }

Procedure TFhirRiskAssessmentPrediction.SetOutcome(value : TFhirCodeableConcept);
begin
  FOutcome.free;
  FOutcome := value;
end;

Procedure TFhirRiskAssessmentPrediction.SetProbability(value : TFhirType);
begin
  FProbability.free;
  FProbability := value;
end;

Procedure TFhirRiskAssessmentPrediction.SetQualitativeRisk(value : TFhirCodeableConcept);
begin
  FQualitativeRisk.free;
  FQualitativeRisk := value;
end;

Procedure TFhirRiskAssessmentPrediction.SetRelativeRisk(value : TFhirDecimal);
begin
  FRelativeRisk.free;
  FRelativeRisk := value;
end;

Function TFhirRiskAssessmentPrediction.GetRelativeRiskST : String;
begin
  if FRelativeRisk = nil then
    result := ''
  else
    result := FRelativeRisk.value;
end;

Procedure TFhirRiskAssessmentPrediction.SetRelativeRiskST(value : String);
begin
  if value <> '' then
  begin
    if FRelativeRisk = nil then
      FRelativeRisk := TFhirDecimal.create;
    FRelativeRisk.value := value
  end
  else if FRelativeRisk <> nil then
    FRelativeRisk.value := '';
end;

Procedure TFhirRiskAssessmentPrediction.SetWhen(value : TFhirType);
begin
  FWhen.free;
  FWhen := value;
end;

Procedure TFhirRiskAssessmentPrediction.SetRationale(value : TFhirString);
begin
  FRationale.free;
  FRationale := value;
end;

Function TFhirRiskAssessmentPrediction.GetRationaleST : String;
begin
  if FRationale = nil then
    result := ''
  else
    result := FRationale.value;
end;

Procedure TFhirRiskAssessmentPrediction.SetRationaleST(value : String);
begin
  if value <> '' then
  begin
    if FRationale = nil then
      FRationale := TFhirString.create;
    FRationale.value := value
  end
  else if FRationale <> nil then
    FRationale.value := '';
end;

function TFhirRiskAssessmentPrediction.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FOutcome.sizeInBytes);
  inc(result, FProbability.sizeInBytes);
  inc(result, FQualitativeRisk.sizeInBytes);
  inc(result, FRelativeRisk.sizeInBytes);
  inc(result, FWhen.sizeInBytes);
  inc(result, FRationale.sizeInBytes);
end;

{ TFhirRiskAssessmentPredictionListEnumerator }

Constructor TFhirRiskAssessmentPredictionListEnumerator.Create(list : TFhirRiskAssessmentPredictionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRiskAssessmentPredictionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRiskAssessmentPredictionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRiskAssessmentPredictionListEnumerator.GetCurrent : TFhirRiskAssessmentPrediction;
begin
  Result := FList[FIndex];
end;

function TFhirRiskAssessmentPredictionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirRiskAssessmentPredictionList }
procedure TFhirRiskAssessmentPredictionList.AddItem(value: TFhirRiskAssessmentPrediction);
begin
  assert(value.ClassName = 'TFhirRiskAssessmentPrediction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRiskAssessmentPrediction');
  add(value);
end;

function TFhirRiskAssessmentPredictionList.Append: TFhirRiskAssessmentPrediction;
begin
  result := TFhirRiskAssessmentPrediction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRiskAssessmentPredictionList.ClearItems;
begin
  Clear;
end;

function TFhirRiskAssessmentPredictionList.GetEnumerator : TFhirRiskAssessmentPredictionListEnumerator;
begin
  result := TFhirRiskAssessmentPredictionListEnumerator.Create(self.link);
end;

function TFhirRiskAssessmentPredictionList.Clone: TFhirRiskAssessmentPredictionList;
begin
  result := TFhirRiskAssessmentPredictionList(inherited Clone);
end;

function TFhirRiskAssessmentPredictionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRiskAssessmentPredictionList.GetItemN(index: Integer): TFhirRiskAssessmentPrediction;
begin
  result := TFhirRiskAssessmentPrediction(ObjectByIndex[index]);
end;

function TFhirRiskAssessmentPredictionList.ItemClass: TFslObjectClass;
begin
  result := TFhirRiskAssessmentPrediction;
end;
function TFhirRiskAssessmentPredictionList.IndexOf(value: TFhirRiskAssessmentPrediction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRiskAssessmentPredictionList.Insert(index: Integer): TFhirRiskAssessmentPrediction;
begin
  result := TFhirRiskAssessmentPrediction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRiskAssessmentPredictionList.InsertItem(index: Integer; value: TFhirRiskAssessmentPrediction);
begin
  assert(value is TFhirRiskAssessmentPrediction);
  Inherited Insert(index, value);
end;

function TFhirRiskAssessmentPredictionList.Item(index: Integer): TFhirRiskAssessmentPrediction;
begin
  result := TFhirRiskAssessmentPrediction(ObjectByIndex[index]);
end;

function TFhirRiskAssessmentPredictionList.Link: TFhirRiskAssessmentPredictionList;
begin
  result := TFhirRiskAssessmentPredictionList(inherited Link);
end;

procedure TFhirRiskAssessmentPredictionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRiskAssessmentPredictionList.SetItemByIndex(index: Integer; value: TFhirRiskAssessmentPrediction);
begin
  assert(value is TFhirRiskAssessmentPrediction);
  FhirRiskAssessmentPredictions[index] := value;
end;

procedure TFhirRiskAssessmentPredictionList.SetItemN(index: Integer; value: TFhirRiskAssessmentPrediction);
begin
  assert(value is TFhirRiskAssessmentPrediction);
  ObjectByIndex[index] := value;
end;

{ TFhirRiskAssessment }

constructor TFhirRiskAssessment.Create;
begin
  inherited;
end;

destructor TFhirRiskAssessment.Destroy;
begin
  FIdentifier.free;
  FBasedOn.free;
  FParent.free;
  FStatus.free;
  FMethod.free;
  FCode.free;
  FSubject.free;
  FContext.free;
  FOccurrence.free;
  FCondition.free;
  FPerformer.free;
  FReason.free;
  FBasisList.Free;
  FPredictionList.Free;
  FMitigation.free;
  FComment.free;
  inherited;
end;

function TFhirRiskAssessment.GetResourceType : TFhirResourceType;
begin
  result := frtRiskAssessment;
end;

procedure TFhirRiskAssessment.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirRiskAssessment(oSource).identifier.Clone;
  basedOn := TFhirRiskAssessment(oSource).basedOn.Clone;
  parent := TFhirRiskAssessment(oSource).parent.Clone;
  FStatus := TFhirRiskAssessment(oSource).FStatus.Link;
  method := TFhirRiskAssessment(oSource).method.Clone;
  code := TFhirRiskAssessment(oSource).code.Clone;
  subject := TFhirRiskAssessment(oSource).subject.Clone;
  context := TFhirRiskAssessment(oSource).context.Clone;
  occurrence := TFhirRiskAssessment(oSource).occurrence.Clone;
  condition := TFhirRiskAssessment(oSource).condition.Clone;
  performer := TFhirRiskAssessment(oSource).performer.Clone;
  reason := TFhirRiskAssessment(oSource).reason.Clone;
  if (TFhirRiskAssessment(oSource).FBasisList = nil) then
  begin
    FBasisList.free;
    FBasisList := nil;
  end
  else
  begin
    if FBasisList = nil then
      FBasisList := TFhirReferenceList{TFhirReference}.Create;
    FBasisList.Assign(TFhirRiskAssessment(oSource).FBasisList);
  end;
  if (TFhirRiskAssessment(oSource).FPredictionList = nil) then
  begin
    FPredictionList.free;
    FPredictionList := nil;
  end
  else
  begin
    if FPredictionList = nil then
      FPredictionList := TFhirRiskAssessmentPredictionList.Create;
    FPredictionList.Assign(TFhirRiskAssessment(oSource).FPredictionList);
  end;
  mitigationElement := TFhirRiskAssessment(oSource).mitigationElement.Clone;
  commentElement := TFhirRiskAssessment(oSource).commentElement.Clone;
end;

procedure TFhirRiskAssessment.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'basedOn') Then
     list.add(self.link, 'basedOn', FBasedOn.Link);
  if (child_name = 'parent') Then
     list.add(self.link, 'parent', FParent.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'method') Then
     list.add(self.link, 'method', FMethod.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
  if (child_name = 'occurrence[x]') or (child_name = 'occurrence') Then
     list.add(self.link, 'occurrence[x]', FOccurrence.Link);
  if (child_name = 'condition') Then
     list.add(self.link, 'condition', FCondition.Link);
  if (child_name = 'performer') Then
     list.add(self.link, 'performer', FPerformer.Link);
  if (child_name = 'reason[x]') or (child_name = 'reason') Then
     list.add(self.link, 'reason[x]', FReason.Link);
  if (child_name = 'basis') Then
    list.addAll(self, 'basis', FBasisList);
  if (child_name = 'prediction') Then
    list.addAll(self, 'prediction', FPredictionList);
  if (child_name = 'mitigation') Then
     list.add(self.link, 'mitigation', FMitigation.Link);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
end;

procedure TFhirRiskAssessment.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference(Any)', false, TFhirReference{TFhirReference}, FBasedOn.Link));{2}
  oList.add(TFHIRProperty.create(self, 'parent', 'Reference(Any)', false, TFhirReference{TFhirReference}, FParent.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', false, TFhirCodeableConcept, FMethod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Group)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'context', 'Reference(Encounter|EpisodeOfCare)', false, TFhirReference{Resource}, FContext.Link));{2}
  oList.add(TFHIRProperty.create(self, 'occurrence[x]', 'dateTime|Period', false, TFhirType, FOccurrence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'condition', 'Reference(Condition)', false, TFhirReference{TFhirCondition}, FCondition.Link));{2}
  oList.add(TFHIRProperty.create(self, 'performer', 'Reference(Practitioner|Device)', false, TFhirReference{Resource}, FPerformer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason[x]', 'CodeableConcept|Reference(Any)', false, TFhirType, FReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'basis', 'Reference(Any)', true, TFhirReference{TFhirReference}, FBasisList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'prediction', '', true, TFhirRiskAssessmentPrediction, FPredictionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'mitigation', 'string', false, TFhirString, FMitigation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'comment', 'string', false, TFhirString, FComment.Link));{2}
end;

function TFhirRiskAssessment.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOn := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'parent') then
  begin
    Parent := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirObservationStatusEnum, CODES_TFhirObservationStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'method') then
  begin
    Method := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'context') then
  begin
    Context := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period'])) then
  begin
    Occurrence := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'condition') then
  begin
    Condition := propValue as TFhirReference{TFhirCondition}{4b};
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    Performer := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then
  begin
    Reason := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'basis') then
  begin
    BasisList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'prediction') then
  begin
    PredictionList.add(propValue as TFhirRiskAssessmentPrediction){2a};
    result := propValue;
  end
  else if (propName = 'mitigation') then
  begin
    MitigationElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirRiskAssessment.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'basis') then BasisList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'prediction') then PredictionList.insertItem(index, propValue as TFhirRiskAssessmentPrediction){2a}
  else inherited;
end;

function TFhirRiskAssessment.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'basedOn') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'parent') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'method') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'context') then result := TFhirReference{Resource}.create(){4b}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Occurrence'){4x}
  else if (propName = 'condition') then result := TFhirReference{TFhirCondition}.create(){4b}
  else if (propName = 'performer') then result := TFhirReference{Resource}.create(){4b}
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Reason'){4x}
  else if (propName = 'basis') then result := BasisList.new(){2}
  else if (propName = 'prediction') then result := PredictionList.new(){2}
  else if (propName = 'mitigation') then result := TFhirString.create() {5b}
  else if (propName = 'comment') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirRiskAssessment.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'parent') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'method') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'context') then result := 'Reference'
  else if (propName = 'occurrence[x]') then result := 'dateTime|Period'
  else if (propName = 'condition') then result := 'Reference'
  else if (propName = 'performer') then result := 'Reference'
  else if (propName = 'reason[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'basis') then result := 'Reference'
  else if (propName = 'prediction') then result := ''
  else if (propName = 'mitigation') then result := 'string'
  else if (propName = 'comment') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRiskAssessment.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'basedOn') then BasedOnElement := nil
  else if (propName = 'parent') then ParentElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'method') then MethodElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'context') then ContextElement := nil
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period'])) then OccurrenceElement := nil{4x}
  else if (propName = 'condition') then ConditionElement := nil
  else if (propName = 'performer') then PerformerElement := nil
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then ReasonElement := nil{4x}
  else if (propName = 'basis') then deletePropertyValue('basis', BasisList, value) {2}
  else if (propName = 'prediction') then deletePropertyValue('prediction', PredictionList, value) {2}
  else if (propName = 'mitigation') then MitigationElement := nil
  else if (propName = 'comment') then CommentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRiskAssessment.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'basedOn') then BasedOnElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'parent') then ParentElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirObservationStatusEnum, CODES_TFhirObservationStatusEnum, new){4}
  else if (propName = 'method') then MethodElement := new as TFhirCodeableConcept{4}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'context') then ContextElement := new as TFhirReference{Resource}{4}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period'])) then OccurrenceElement := new as TFhirType{4x}
  else if (propName = 'condition') then ConditionElement := new as TFhirReference{TFhirCondition}{4}
  else if (propName = 'performer') then PerformerElement := new as TFhirReference{Resource}{4}
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then ReasonElement := new as TFhirType{4x}
  else if (propName = 'basis') then replacePropertyValue('basis', BasisList, existing, new) {2}
  else if (propName = 'prediction') then replacePropertyValue('prediction', PredictionList, existing, new) {2}
  else if (propName = 'mitigation') then MitigationElement := asString(new){5b}
  else if (propName = 'comment') then CommentElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRiskAssessment.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'basis') then BasisList.move(source, destination){2a}
  else if (propName = 'prediction') then PredictionList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirRiskAssessment.fhirType : string;
begin
  result := 'RiskAssessment';
end;

function TFhirRiskAssessment.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FBasedOn) and isEmptyProp(FParent) and isEmptyProp(FStatus) and isEmptyProp(FMethod) and isEmptyProp(FCode) and isEmptyProp(FSubject) and isEmptyProp(FContext) and isEmptyProp(FOccurrence) and isEmptyProp(FCondition) and isEmptyProp(FPerformer) and isEmptyProp(FReason) and isEmptyProp(FbasisList) and isEmptyProp(FpredictionList) and isEmptyProp(FMitigation) and isEmptyProp(FComment);
end;

function TFhirRiskAssessment.equals(other : TObject) : boolean;
var
  o : TFhirRiskAssessment;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRiskAssessment)) then
    result := false
  else
  begin
    o := TFhirRiskAssessment(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(basedOnElement, o.basedOnElement, true) and
      compareDeep(parentElement, o.parentElement, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(methodElement, o.methodElement, true) and compareDeep(codeElement, o.codeElement, true) and
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(contextElement, o.contextElement, true) and
      compareDeep(occurrenceElement, o.occurrenceElement, true) and compareDeep(conditionElement, o.conditionElement, true) and
      compareDeep(performerElement, o.performerElement, true) and compareDeep(reasonElement, o.reasonElement, true) and
      compareDeep(basisList, o.basisList, true) and compareDeep(predictionList, o.predictionList, true) and
      compareDeep(mitigationElement, o.mitigationElement, true) and compareDeep(commentElement, o.commentElement, true);
  end;
end;

function TFhirRiskAssessment.Link : TFhirRiskAssessment;
begin
  result := TFhirRiskAssessment(inherited Link);
end;

function TFhirRiskAssessment.Clone : TFhirRiskAssessment;
begin
  result := TFhirRiskAssessment(inherited Clone);
end;

procedure TFhirRiskAssessment.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('basedOn');
  fields.add('parent');
  fields.add('status');
  fields.add('method');
  fields.add('code');
  fields.add('subject');
  fields.add('context');
  fields.add('occurrence[x]');
  fields.add('condition');
  fields.add('performer');
  fields.add('reason[x]');
  fields.add('basis');
  fields.add('prediction');
  fields.add('mitigation');
  fields.add('comment');
end;

{ TFhirRiskAssessment }

Procedure TFhirRiskAssessment.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirRiskAssessment.SetBasedOn(value : TFhirReference{TFhirReference});
begin
  FBasedOn.free;
  FBasedOn := value;
end;

Procedure TFhirRiskAssessment.SetParent(value : TFhirReference{TFhirReference});
begin
  FParent.free;
  FParent := value;
end;

Procedure TFhirRiskAssessment.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirRiskAssessment.GetStatusST : TFhirObservationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirObservationStatusEnum(0)
  else
    result := TFhirObservationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirObservationStatusEnum, FStatus.value));
end;

Procedure TFhirRiskAssessment.SetStatusST(value : TFhirObservationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirObservationStatusEnum[value], CODES_TFhirObservationStatusEnum[value]);
end;

Procedure TFhirRiskAssessment.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value;
end;

Procedure TFhirRiskAssessment.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirRiskAssessment.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirRiskAssessment.SetContext(value : TFhirReference{Resource});
begin
  FContext.free;
  FContext := value;
end;

Procedure TFhirRiskAssessment.SetOccurrence(value : TFhirType);
begin
  FOccurrence.free;
  FOccurrence := value;
end;

Procedure TFhirRiskAssessment.SetCondition(value : TFhirReference{TFhirCondition});
begin
  FCondition.free;
  FCondition := value;
end;

Procedure TFhirRiskAssessment.SetPerformer(value : TFhirReference{Resource});
begin
  FPerformer.free;
  FPerformer := value;
end;

Procedure TFhirRiskAssessment.SetReason(value : TFhirType);
begin
  FReason.free;
  FReason := value;
end;

Function TFhirRiskAssessment.GetBasisList : TFhirReferenceList{TFhirReference};
begin
  if FBasisList = nil then
    FBasisList := TFhirReferenceList{TFhirReference}.Create;
  result := FBasisList;
end;

Function TFhirRiskAssessment.GetHasBasisList : boolean;
begin
  result := (FBasisList <> nil) and (FBasisList.count > 0);
end;

Function TFhirRiskAssessment.GetPredictionList : TFhirRiskAssessmentPredictionList;
begin
  if FPredictionList = nil then
    FPredictionList := TFhirRiskAssessmentPredictionList.Create;
  result := FPredictionList;
end;

Function TFhirRiskAssessment.GetHasPredictionList : boolean;
begin
  result := (FPredictionList <> nil) and (FPredictionList.count > 0);
end;

Procedure TFhirRiskAssessment.SetMitigation(value : TFhirString);
begin
  FMitigation.free;
  FMitigation := value;
end;

Function TFhirRiskAssessment.GetMitigationST : String;
begin
  if FMitigation = nil then
    result := ''
  else
    result := FMitigation.value;
end;

Procedure TFhirRiskAssessment.SetMitigationST(value : String);
begin
  if value <> '' then
  begin
    if FMitigation = nil then
      FMitigation := TFhirString.create;
    FMitigation.value := value
  end
  else if FMitigation <> nil then
    FMitigation.value := '';
end;

Procedure TFhirRiskAssessment.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value;
end;

Function TFhirRiskAssessment.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

Procedure TFhirRiskAssessment.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

function TFhirRiskAssessment.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FBasedOn.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FMethod.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FContext.sizeInBytes);
  inc(result, FOccurrence.sizeInBytes);
  inc(result, FCondition.sizeInBytes);
  inc(result, FPerformer.sizeInBytes);
  inc(result, FReason.sizeInBytes);
  inc(result, FbasisList.sizeInBytes);
  inc(result, FpredictionList.sizeInBytes);
  inc(result, FMitigation.sizeInBytes);
  inc(result, FComment.sizeInBytes);
end;

{ TFhirRiskAssessmentListEnumerator }

Constructor TFhirRiskAssessmentListEnumerator.Create(list : TFhirRiskAssessmentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRiskAssessmentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRiskAssessmentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRiskAssessmentListEnumerator.GetCurrent : TFhirRiskAssessment;
begin
  Result := FList[FIndex];
end;

function TFhirRiskAssessmentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirRiskAssessmentList }
procedure TFhirRiskAssessmentList.AddItem(value: TFhirRiskAssessment);
begin
  assert(value.ClassName = 'TFhirRiskAssessment', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRiskAssessment');
  add(value);
end;

function TFhirRiskAssessmentList.Append: TFhirRiskAssessment;
begin
  result := TFhirRiskAssessment.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRiskAssessmentList.ClearItems;
begin
  Clear;
end;

function TFhirRiskAssessmentList.GetEnumerator : TFhirRiskAssessmentListEnumerator;
begin
  result := TFhirRiskAssessmentListEnumerator.Create(self.link);
end;

function TFhirRiskAssessmentList.Clone: TFhirRiskAssessmentList;
begin
  result := TFhirRiskAssessmentList(inherited Clone);
end;

function TFhirRiskAssessmentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRiskAssessmentList.GetItemN(index: Integer): TFhirRiskAssessment;
begin
  result := TFhirRiskAssessment(ObjectByIndex[index]);
end;

function TFhirRiskAssessmentList.ItemClass: TFslObjectClass;
begin
  result := TFhirRiskAssessment;
end;
function TFhirRiskAssessmentList.IndexOf(value: TFhirRiskAssessment): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRiskAssessmentList.Insert(index: Integer): TFhirRiskAssessment;
begin
  result := TFhirRiskAssessment.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRiskAssessmentList.InsertItem(index: Integer; value: TFhirRiskAssessment);
begin
  assert(value is TFhirRiskAssessment);
  Inherited Insert(index, value);
end;

function TFhirRiskAssessmentList.Item(index: Integer): TFhirRiskAssessment;
begin
  result := TFhirRiskAssessment(ObjectByIndex[index]);
end;

function TFhirRiskAssessmentList.Link: TFhirRiskAssessmentList;
begin
  result := TFhirRiskAssessmentList(inherited Link);
end;

procedure TFhirRiskAssessmentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRiskAssessmentList.SetItemByIndex(index: Integer; value: TFhirRiskAssessment);
begin
  assert(value is TFhirRiskAssessment);
  FhirRiskAssessments[index] := value;
end;

procedure TFhirRiskAssessmentList.SetItemN(index: Integer; value: TFhirRiskAssessment);
begin
  assert(value is TFhirRiskAssessment);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_RISKASSESSMENT}

{$IFDEF FHIR_SEQUENCE}

{ TFhirSequenceReferenceSeq }

constructor TFhirSequenceReferenceSeq.Create;
begin
  inherited;
end;

destructor TFhirSequenceReferenceSeq.Destroy;
begin
  FChromosome.free;
  FGenomeBuild.free;
  FReferenceSeqId.free;
  FReferenceSeqPointer.free;
  FReferenceSeqString.free;
  FStrand.free;
  FWindowStart.free;
  FWindowEnd.free;
  inherited;
end;

procedure TFhirSequenceReferenceSeq.Assign(oSource : TFslObject);
begin
  inherited;
  chromosome := TFhirSequenceReferenceSeq(oSource).chromosome.Clone;
  genomeBuildElement := TFhirSequenceReferenceSeq(oSource).genomeBuildElement.Clone;
  referenceSeqId := TFhirSequenceReferenceSeq(oSource).referenceSeqId.Clone;
  referenceSeqPointer := TFhirSequenceReferenceSeq(oSource).referenceSeqPointer.Clone;
  referenceSeqStringElement := TFhirSequenceReferenceSeq(oSource).referenceSeqStringElement.Clone;
  strandElement := TFhirSequenceReferenceSeq(oSource).strandElement.Clone;
  windowStartElement := TFhirSequenceReferenceSeq(oSource).windowStartElement.Clone;
  windowEndElement := TFhirSequenceReferenceSeq(oSource).windowEndElement.Clone;
end;

procedure TFhirSequenceReferenceSeq.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'chromosome') Then
     list.add(self.link, 'chromosome', FChromosome.Link);
  if (child_name = 'genomeBuild') Then
     list.add(self.link, 'genomeBuild', FGenomeBuild.Link);
  if (child_name = 'referenceSeqId') Then
     list.add(self.link, 'referenceSeqId', FReferenceSeqId.Link);
  if (child_name = 'referenceSeqPointer') Then
     list.add(self.link, 'referenceSeqPointer', FReferenceSeqPointer.Link);
  if (child_name = 'referenceSeqString') Then
     list.add(self.link, 'referenceSeqString', FReferenceSeqString.Link);
  if (child_name = 'strand') Then
     list.add(self.link, 'strand', FStrand.Link);
  if (child_name = 'windowStart') Then
     list.add(self.link, 'windowStart', FWindowStart.Link);
  if (child_name = 'windowEnd') Then
     list.add(self.link, 'windowEnd', FWindowEnd.Link);
end;

procedure TFhirSequenceReferenceSeq.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'chromosome', 'CodeableConcept', false, TFhirCodeableConcept, FChromosome.Link));{2}
  oList.add(TFHIRProperty.create(self, 'genomeBuild', 'string', false, TFhirString, FGenomeBuild.Link));{2}
  oList.add(TFHIRProperty.create(self, 'referenceSeqId', 'CodeableConcept', false, TFhirCodeableConcept, FReferenceSeqId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'referenceSeqPointer', 'Reference(Sequence)', false, TFhirReference{TFhirSequence}, FReferenceSeqPointer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'referenceSeqString', 'string', false, TFhirString, FReferenceSeqString.Link));{2}
  oList.add(TFHIRProperty.create(self, 'strand', 'integer', false, TFhirInteger, FStrand.Link));{2}
  oList.add(TFHIRProperty.create(self, 'windowStart', 'integer', false, TFhirInteger, FWindowStart.Link));{2}
  oList.add(TFHIRProperty.create(self, 'windowEnd', 'integer', false, TFhirInteger, FWindowEnd.Link));{2}
end;

function TFhirSequenceReferenceSeq.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'chromosome') then
  begin
    Chromosome := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'genomeBuild') then
  begin
    GenomeBuildElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'referenceSeqId') then
  begin
    ReferenceSeqId := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'referenceSeqPointer') then
  begin
    ReferenceSeqPointer := propValue as TFhirReference{TFhirSequence}{4b};
    result := propValue;
  end
  else if (propName = 'referenceSeqString') then
  begin
    ReferenceSeqStringElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'strand') then
  begin
    StrandElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'windowStart') then
  begin
    WindowStartElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'windowEnd') then
  begin
    WindowEndElement := asInteger(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSequenceReferenceSeq.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSequenceReferenceSeq.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'chromosome') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'genomeBuild') then result := TFhirString.create() {5b}
  else if (propName = 'referenceSeqId') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'referenceSeqPointer') then result := TFhirReference{TFhirSequence}.create(){4b}
  else if (propName = 'referenceSeqString') then result := TFhirString.create() {5b}
  else if (propName = 'strand') then result := TFhirInteger.create() {5b}
  else if (propName = 'windowStart') then result := TFhirInteger.create() {5b}
  else if (propName = 'windowEnd') then result := TFhirInteger.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSequenceReferenceSeq.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'chromosome') then result := 'CodeableConcept'
  else if (propName = 'genomeBuild') then result := 'string'
  else if (propName = 'referenceSeqId') then result := 'CodeableConcept'
  else if (propName = 'referenceSeqPointer') then result := 'Reference'
  else if (propName = 'referenceSeqString') then result := 'string'
  else if (propName = 'strand') then result := 'integer'
  else if (propName = 'windowStart') then result := 'integer'
  else if (propName = 'windowEnd') then result := 'integer'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSequenceReferenceSeq.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'chromosome') then ChromosomeElement := nil
  else if (propName = 'genomeBuild') then GenomeBuildElement := nil
  else if (propName = 'referenceSeqId') then ReferenceSeqIdElement := nil
  else if (propName = 'referenceSeqPointer') then ReferenceSeqPointerElement := nil
  else if (propName = 'referenceSeqString') then ReferenceSeqStringElement := nil
  else if (propName = 'strand') then StrandElement := nil
  else if (propName = 'windowStart') then WindowStartElement := nil
  else if (propName = 'windowEnd') then WindowEndElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSequenceReferenceSeq.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'chromosome') then ChromosomeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'genomeBuild') then GenomeBuildElement := asString(new){5b}
  else if (propName = 'referenceSeqId') then ReferenceSeqIdElement := new as TFhirCodeableConcept{4}
  else if (propName = 'referenceSeqPointer') then ReferenceSeqPointerElement := new as TFhirReference{TFhirSequence}{4}
  else if (propName = 'referenceSeqString') then ReferenceSeqStringElement := asString(new){5b}
  else if (propName = 'strand') then StrandElement := asInteger(new){5b}
  else if (propName = 'windowStart') then WindowStartElement := asInteger(new){5b}
  else if (propName = 'windowEnd') then WindowEndElement := asInteger(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSequenceReferenceSeq.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSequenceReferenceSeq.fhirType : string;
begin
  result := 'referenceSeq';
end;

function TFhirSequenceReferenceSeq.Link : TFhirSequenceReferenceSeq;
begin
  result := TFhirSequenceReferenceSeq(inherited Link);
end;

function TFhirSequenceReferenceSeq.Clone : TFhirSequenceReferenceSeq;
begin
  result := TFhirSequenceReferenceSeq(inherited Clone);
end;

function TFhirSequenceReferenceSeq.equals(other : TObject) : boolean;
var
  o : TFhirSequenceReferenceSeq;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSequenceReferenceSeq)) then
    result := false
  else
  begin
    o := TFhirSequenceReferenceSeq(other);
    result := compareDeep(chromosomeElement, o.chromosomeElement, true) and compareDeep(genomeBuildElement, o.genomeBuildElement, true) and
      compareDeep(referenceSeqIdElement, o.referenceSeqIdElement, true) and compareDeep(referenceSeqPointerElement, o.referenceSeqPointerElement, true) and
      compareDeep(referenceSeqStringElement, o.referenceSeqStringElement, true) and
      compareDeep(strandElement, o.strandElement, true) and compareDeep(windowStartElement, o.windowStartElement, true) and
      compareDeep(windowEndElement, o.windowEndElement, true);
  end;
end;

function TFhirSequenceReferenceSeq.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FChromosome) and isEmptyProp(FGenomeBuild) and isEmptyProp(FReferenceSeqId) and isEmptyProp(FReferenceSeqPointer) and isEmptyProp(FReferenceSeqString) and isEmptyProp(FStrand) and isEmptyProp(FWindowStart) and isEmptyProp(FWindowEnd);
end;

procedure TFhirSequenceReferenceSeq.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('chromosome');
  fields.add('genomeBuild');
  fields.add('referenceSeqId');
  fields.add('referenceSeqPointer');
  fields.add('referenceSeqString');
  fields.add('strand');
  fields.add('windowStart');
  fields.add('windowEnd');
end;

{ TFhirSequenceReferenceSeq }

Procedure TFhirSequenceReferenceSeq.SetChromosome(value : TFhirCodeableConcept);
begin
  FChromosome.free;
  FChromosome := value;
end;

Procedure TFhirSequenceReferenceSeq.SetGenomeBuild(value : TFhirString);
begin
  FGenomeBuild.free;
  FGenomeBuild := value;
end;

Function TFhirSequenceReferenceSeq.GetGenomeBuildST : String;
begin
  if FGenomeBuild = nil then
    result := ''
  else
    result := FGenomeBuild.value;
end;

Procedure TFhirSequenceReferenceSeq.SetGenomeBuildST(value : String);
begin
  if value <> '' then
  begin
    if FGenomeBuild = nil then
      FGenomeBuild := TFhirString.create;
    FGenomeBuild.value := value
  end
  else if FGenomeBuild <> nil then
    FGenomeBuild.value := '';
end;

Procedure TFhirSequenceReferenceSeq.SetReferenceSeqId(value : TFhirCodeableConcept);
begin
  FReferenceSeqId.free;
  FReferenceSeqId := value;
end;

Procedure TFhirSequenceReferenceSeq.SetReferenceSeqPointer(value : TFhirReference{TFhirSequence});
begin
  FReferenceSeqPointer.free;
  FReferenceSeqPointer := value;
end;

Procedure TFhirSequenceReferenceSeq.SetReferenceSeqString(value : TFhirString);
begin
  FReferenceSeqString.free;
  FReferenceSeqString := value;
end;

Function TFhirSequenceReferenceSeq.GetReferenceSeqStringST : String;
begin
  if FReferenceSeqString = nil then
    result := ''
  else
    result := FReferenceSeqString.value;
end;

Procedure TFhirSequenceReferenceSeq.SetReferenceSeqStringST(value : String);
begin
  if value <> '' then
  begin
    if FReferenceSeqString = nil then
      FReferenceSeqString := TFhirString.create;
    FReferenceSeqString.value := value
  end
  else if FReferenceSeqString <> nil then
    FReferenceSeqString.value := '';
end;

Procedure TFhirSequenceReferenceSeq.SetStrand(value : TFhirInteger);
begin
  FStrand.free;
  FStrand := value;
end;

Function TFhirSequenceReferenceSeq.GetStrandST : String;
begin
  if FStrand = nil then
    result := ''
  else
    result := FStrand.value;
end;

Procedure TFhirSequenceReferenceSeq.SetStrandST(value : String);
begin
  if value <> '' then
  begin
    if FStrand = nil then
      FStrand := TFhirInteger.create;
    FStrand.value := value
  end
  else if FStrand <> nil then
    FStrand.value := '';
end;

Procedure TFhirSequenceReferenceSeq.SetWindowStart(value : TFhirInteger);
begin
  FWindowStart.free;
  FWindowStart := value;
end;

Function TFhirSequenceReferenceSeq.GetWindowStartST : String;
begin
  if FWindowStart = nil then
    result := ''
  else
    result := FWindowStart.value;
end;

Procedure TFhirSequenceReferenceSeq.SetWindowStartST(value : String);
begin
  if value <> '' then
  begin
    if FWindowStart = nil then
      FWindowStart := TFhirInteger.create;
    FWindowStart.value := value
  end
  else if FWindowStart <> nil then
    FWindowStart.value := '';
end;

Procedure TFhirSequenceReferenceSeq.SetWindowEnd(value : TFhirInteger);
begin
  FWindowEnd.free;
  FWindowEnd := value;
end;

Function TFhirSequenceReferenceSeq.GetWindowEndST : String;
begin
  if FWindowEnd = nil then
    result := ''
  else
    result := FWindowEnd.value;
end;

Procedure TFhirSequenceReferenceSeq.SetWindowEndST(value : String);
begin
  if value <> '' then
  begin
    if FWindowEnd = nil then
      FWindowEnd := TFhirInteger.create;
    FWindowEnd.value := value
  end
  else if FWindowEnd <> nil then
    FWindowEnd.value := '';
end;

function TFhirSequenceReferenceSeq.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FChromosome.sizeInBytes);
  inc(result, FGenomeBuild.sizeInBytes);
  inc(result, FReferenceSeqId.sizeInBytes);
  inc(result, FReferenceSeqPointer.sizeInBytes);
  inc(result, FReferenceSeqString.sizeInBytes);
  inc(result, FStrand.sizeInBytes);
  inc(result, FWindowStart.sizeInBytes);
  inc(result, FWindowEnd.sizeInBytes);
end;

{ TFhirSequenceReferenceSeqListEnumerator }

Constructor TFhirSequenceReferenceSeqListEnumerator.Create(list : TFhirSequenceReferenceSeqList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSequenceReferenceSeqListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSequenceReferenceSeqListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSequenceReferenceSeqListEnumerator.GetCurrent : TFhirSequenceReferenceSeq;
begin
  Result := FList[FIndex];
end;

function TFhirSequenceReferenceSeqListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSequenceReferenceSeqList }
procedure TFhirSequenceReferenceSeqList.AddItem(value: TFhirSequenceReferenceSeq);
begin
  assert(value.ClassName = 'TFhirSequenceReferenceSeq', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSequenceReferenceSeq');
  add(value);
end;

function TFhirSequenceReferenceSeqList.Append: TFhirSequenceReferenceSeq;
begin
  result := TFhirSequenceReferenceSeq.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSequenceReferenceSeqList.ClearItems;
begin
  Clear;
end;

function TFhirSequenceReferenceSeqList.GetEnumerator : TFhirSequenceReferenceSeqListEnumerator;
begin
  result := TFhirSequenceReferenceSeqListEnumerator.Create(self.link);
end;

function TFhirSequenceReferenceSeqList.Clone: TFhirSequenceReferenceSeqList;
begin
  result := TFhirSequenceReferenceSeqList(inherited Clone);
end;

function TFhirSequenceReferenceSeqList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSequenceReferenceSeqList.GetItemN(index: Integer): TFhirSequenceReferenceSeq;
begin
  result := TFhirSequenceReferenceSeq(ObjectByIndex[index]);
end;

function TFhirSequenceReferenceSeqList.ItemClass: TFslObjectClass;
begin
  result := TFhirSequenceReferenceSeq;
end;
function TFhirSequenceReferenceSeqList.IndexOf(value: TFhirSequenceReferenceSeq): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSequenceReferenceSeqList.Insert(index: Integer): TFhirSequenceReferenceSeq;
begin
  result := TFhirSequenceReferenceSeq.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSequenceReferenceSeqList.InsertItem(index: Integer; value: TFhirSequenceReferenceSeq);
begin
  assert(value is TFhirSequenceReferenceSeq);
  Inherited Insert(index, value);
end;

function TFhirSequenceReferenceSeqList.Item(index: Integer): TFhirSequenceReferenceSeq;
begin
  result := TFhirSequenceReferenceSeq(ObjectByIndex[index]);
end;

function TFhirSequenceReferenceSeqList.Link: TFhirSequenceReferenceSeqList;
begin
  result := TFhirSequenceReferenceSeqList(inherited Link);
end;

procedure TFhirSequenceReferenceSeqList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSequenceReferenceSeqList.SetItemByIndex(index: Integer; value: TFhirSequenceReferenceSeq);
begin
  assert(value is TFhirSequenceReferenceSeq);
  FhirSequenceReferenceSeqs[index] := value;
end;

procedure TFhirSequenceReferenceSeqList.SetItemN(index: Integer; value: TFhirSequenceReferenceSeq);
begin
  assert(value is TFhirSequenceReferenceSeq);
  ObjectByIndex[index] := value;
end;

{ TFhirSequenceVariant }

constructor TFhirSequenceVariant.Create;
begin
  inherited;
end;

destructor TFhirSequenceVariant.Destroy;
begin
  FStart.free;
  FEnd_.free;
  FObservedAllele.free;
  FReferenceAllele.free;
  FCigar.free;
  FVariantPointer.free;
  inherited;
end;

procedure TFhirSequenceVariant.Assign(oSource : TFslObject);
begin
  inherited;
  startElement := TFhirSequenceVariant(oSource).startElement.Clone;
  end_Element := TFhirSequenceVariant(oSource).end_Element.Clone;
  observedAlleleElement := TFhirSequenceVariant(oSource).observedAlleleElement.Clone;
  referenceAlleleElement := TFhirSequenceVariant(oSource).referenceAlleleElement.Clone;
  cigarElement := TFhirSequenceVariant(oSource).cigarElement.Clone;
  variantPointer := TFhirSequenceVariant(oSource).variantPointer.Clone;
end;

procedure TFhirSequenceVariant.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'start') Then
     list.add(self.link, 'start', FStart.Link);
  if (child_name = 'end') Then
     list.add(self.link, 'end', FEnd_.Link);
  if (child_name = 'observedAllele') Then
     list.add(self.link, 'observedAllele', FObservedAllele.Link);
  if (child_name = 'referenceAllele') Then
     list.add(self.link, 'referenceAllele', FReferenceAllele.Link);
  if (child_name = 'cigar') Then
     list.add(self.link, 'cigar', FCigar.Link);
  if (child_name = 'variantPointer') Then
     list.add(self.link, 'variantPointer', FVariantPointer.Link);
end;

procedure TFhirSequenceVariant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'start', 'integer', false, TFhirInteger, FStart.Link));{2}
  oList.add(TFHIRProperty.create(self, 'end', 'integer', false, TFhirInteger, FEnd_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'observedAllele', 'string', false, TFhirString, FObservedAllele.Link));{2}
  oList.add(TFHIRProperty.create(self, 'referenceAllele', 'string', false, TFhirString, FReferenceAllele.Link));{2}
  oList.add(TFHIRProperty.create(self, 'cigar', 'string', false, TFhirString, FCigar.Link));{2}
  oList.add(TFHIRProperty.create(self, 'variantPointer', 'Reference(Observation)', false, TFhirReference{TFhirObservation}, FVariantPointer.Link));{2}
end;

function TFhirSequenceVariant.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'start') then
  begin
    StartElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'end') then
  begin
    End_Element := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'observedAllele') then
  begin
    ObservedAlleleElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'referenceAllele') then
  begin
    ReferenceAlleleElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'cigar') then
  begin
    CigarElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'variantPointer') then
  begin
    VariantPointer := propValue as TFhirReference{TFhirObservation}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSequenceVariant.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSequenceVariant.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'start') then result := TFhirInteger.create() {5b}
  else if (propName = 'end') then result := TFhirInteger.create() {5b}
  else if (propName = 'observedAllele') then result := TFhirString.create() {5b}
  else if (propName = 'referenceAllele') then result := TFhirString.create() {5b}
  else if (propName = 'cigar') then result := TFhirString.create() {5b}
  else if (propName = 'variantPointer') then result := TFhirReference{TFhirObservation}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSequenceVariant.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'start') then result := 'integer'
  else if (propName = 'end') then result := 'integer'
  else if (propName = 'observedAllele') then result := 'string'
  else if (propName = 'referenceAllele') then result := 'string'
  else if (propName = 'cigar') then result := 'string'
  else if (propName = 'variantPointer') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSequenceVariant.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'start') then StartElement := nil
  else if (propName = 'end') then End_Element := nil
  else if (propName = 'observedAllele') then ObservedAlleleElement := nil
  else if (propName = 'referenceAllele') then ReferenceAlleleElement := nil
  else if (propName = 'cigar') then CigarElement := nil
  else if (propName = 'variantPointer') then VariantPointerElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSequenceVariant.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'start') then StartElement := asInteger(new){5b}
  else if (propName = 'end') then End_Element := asInteger(new){5b}
  else if (propName = 'observedAllele') then ObservedAlleleElement := asString(new){5b}
  else if (propName = 'referenceAllele') then ReferenceAlleleElement := asString(new){5b}
  else if (propName = 'cigar') then CigarElement := asString(new){5b}
  else if (propName = 'variantPointer') then VariantPointerElement := new as TFhirReference{TFhirObservation}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSequenceVariant.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSequenceVariant.fhirType : string;
begin
  result := 'variant';
end;

function TFhirSequenceVariant.Link : TFhirSequenceVariant;
begin
  result := TFhirSequenceVariant(inherited Link);
end;

function TFhirSequenceVariant.Clone : TFhirSequenceVariant;
begin
  result := TFhirSequenceVariant(inherited Clone);
end;

function TFhirSequenceVariant.equals(other : TObject) : boolean;
var
  o : TFhirSequenceVariant;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSequenceVariant)) then
    result := false
  else
  begin
    o := TFhirSequenceVariant(other);
    result := compareDeep(startElement, o.startElement, true) and compareDeep(end_Element, o.end_Element, true) and
      compareDeep(observedAlleleElement, o.observedAlleleElement, true) and compareDeep(referenceAlleleElement, o.referenceAlleleElement, true) and
      compareDeep(cigarElement, o.cigarElement, true) and compareDeep(variantPointerElement, o.variantPointerElement, true);
  end;
end;

function TFhirSequenceVariant.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStart) and isEmptyProp(FEnd_) and isEmptyProp(FObservedAllele) and isEmptyProp(FReferenceAllele) and isEmptyProp(FCigar) and isEmptyProp(FVariantPointer);
end;

procedure TFhirSequenceVariant.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('start');
  fields.add('end');
  fields.add('observedAllele');
  fields.add('referenceAllele');
  fields.add('cigar');
  fields.add('variantPointer');
end;

{ TFhirSequenceVariant }

Procedure TFhirSequenceVariant.SetStart(value : TFhirInteger);
begin
  FStart.free;
  FStart := value;
end;

Function TFhirSequenceVariant.GetStartST : String;
begin
  if FStart = nil then
    result := ''
  else
    result := FStart.value;
end;

Procedure TFhirSequenceVariant.SetStartST(value : String);
begin
  if value <> '' then
  begin
    if FStart = nil then
      FStart := TFhirInteger.create;
    FStart.value := value
  end
  else if FStart <> nil then
    FStart.value := '';
end;

Procedure TFhirSequenceVariant.SetEnd_(value : TFhirInteger);
begin
  FEnd_.free;
  FEnd_ := value;
end;

Function TFhirSequenceVariant.GetEnd_ST : String;
begin
  if FEnd_ = nil then
    result := ''
  else
    result := FEnd_.value;
end;

Procedure TFhirSequenceVariant.SetEnd_ST(value : String);
begin
  if value <> '' then
  begin
    if FEnd_ = nil then
      FEnd_ := TFhirInteger.create;
    FEnd_.value := value
  end
  else if FEnd_ <> nil then
    FEnd_.value := '';
end;

Procedure TFhirSequenceVariant.SetObservedAllele(value : TFhirString);
begin
  FObservedAllele.free;
  FObservedAllele := value;
end;

Function TFhirSequenceVariant.GetObservedAlleleST : String;
begin
  if FObservedAllele = nil then
    result := ''
  else
    result := FObservedAllele.value;
end;

Procedure TFhirSequenceVariant.SetObservedAlleleST(value : String);
begin
  if value <> '' then
  begin
    if FObservedAllele = nil then
      FObservedAllele := TFhirString.create;
    FObservedAllele.value := value
  end
  else if FObservedAllele <> nil then
    FObservedAllele.value := '';
end;

Procedure TFhirSequenceVariant.SetReferenceAllele(value : TFhirString);
begin
  FReferenceAllele.free;
  FReferenceAllele := value;
end;

Function TFhirSequenceVariant.GetReferenceAlleleST : String;
begin
  if FReferenceAllele = nil then
    result := ''
  else
    result := FReferenceAllele.value;
end;

Procedure TFhirSequenceVariant.SetReferenceAlleleST(value : String);
begin
  if value <> '' then
  begin
    if FReferenceAllele = nil then
      FReferenceAllele := TFhirString.create;
    FReferenceAllele.value := value
  end
  else if FReferenceAllele <> nil then
    FReferenceAllele.value := '';
end;

Procedure TFhirSequenceVariant.SetCigar(value : TFhirString);
begin
  FCigar.free;
  FCigar := value;
end;

Function TFhirSequenceVariant.GetCigarST : String;
begin
  if FCigar = nil then
    result := ''
  else
    result := FCigar.value;
end;

Procedure TFhirSequenceVariant.SetCigarST(value : String);
begin
  if value <> '' then
  begin
    if FCigar = nil then
      FCigar := TFhirString.create;
    FCigar.value := value
  end
  else if FCigar <> nil then
    FCigar.value := '';
end;

Procedure TFhirSequenceVariant.SetVariantPointer(value : TFhirReference{TFhirObservation});
begin
  FVariantPointer.free;
  FVariantPointer := value;
end;

function TFhirSequenceVariant.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FStart.sizeInBytes);
  inc(result, FEnd_.sizeInBytes);
  inc(result, FObservedAllele.sizeInBytes);
  inc(result, FReferenceAllele.sizeInBytes);
  inc(result, FCigar.sizeInBytes);
  inc(result, FVariantPointer.sizeInBytes);
end;

{ TFhirSequenceVariantListEnumerator }

Constructor TFhirSequenceVariantListEnumerator.Create(list : TFhirSequenceVariantList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSequenceVariantListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSequenceVariantListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSequenceVariantListEnumerator.GetCurrent : TFhirSequenceVariant;
begin
  Result := FList[FIndex];
end;

function TFhirSequenceVariantListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSequenceVariantList }
procedure TFhirSequenceVariantList.AddItem(value: TFhirSequenceVariant);
begin
  assert(value.ClassName = 'TFhirSequenceVariant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSequenceVariant');
  add(value);
end;

function TFhirSequenceVariantList.Append: TFhirSequenceVariant;
begin
  result := TFhirSequenceVariant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSequenceVariantList.ClearItems;
begin
  Clear;
end;

function TFhirSequenceVariantList.GetEnumerator : TFhirSequenceVariantListEnumerator;
begin
  result := TFhirSequenceVariantListEnumerator.Create(self.link);
end;

function TFhirSequenceVariantList.Clone: TFhirSequenceVariantList;
begin
  result := TFhirSequenceVariantList(inherited Clone);
end;

function TFhirSequenceVariantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSequenceVariantList.GetItemN(index: Integer): TFhirSequenceVariant;
begin
  result := TFhirSequenceVariant(ObjectByIndex[index]);
end;

function TFhirSequenceVariantList.ItemClass: TFslObjectClass;
begin
  result := TFhirSequenceVariant;
end;
function TFhirSequenceVariantList.IndexOf(value: TFhirSequenceVariant): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSequenceVariantList.Insert(index: Integer): TFhirSequenceVariant;
begin
  result := TFhirSequenceVariant.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSequenceVariantList.InsertItem(index: Integer; value: TFhirSequenceVariant);
begin
  assert(value is TFhirSequenceVariant);
  Inherited Insert(index, value);
end;

function TFhirSequenceVariantList.Item(index: Integer): TFhirSequenceVariant;
begin
  result := TFhirSequenceVariant(ObjectByIndex[index]);
end;

function TFhirSequenceVariantList.Link: TFhirSequenceVariantList;
begin
  result := TFhirSequenceVariantList(inherited Link);
end;

procedure TFhirSequenceVariantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSequenceVariantList.SetItemByIndex(index: Integer; value: TFhirSequenceVariant);
begin
  assert(value is TFhirSequenceVariant);
  FhirSequenceVariants[index] := value;
end;

procedure TFhirSequenceVariantList.SetItemN(index: Integer; value: TFhirSequenceVariant);
begin
  assert(value is TFhirSequenceVariant);
  ObjectByIndex[index] := value;
end;

{ TFhirSequenceQuality }

constructor TFhirSequenceQuality.Create;
begin
  inherited;
end;

destructor TFhirSequenceQuality.Destroy;
begin
  FType_.free;
  FStandardSequence.free;
  FStart.free;
  FEnd_.free;
  FScore.free;
  FMethod.free;
  FTruthTP.free;
  FQueryTP.free;
  FTruthFN.free;
  FQueryFP.free;
  FGtFP.free;
  FPrecision.free;
  FRecall.free;
  FFScore_.free;
  inherited;
end;

procedure TFhirSequenceQuality.Assign(oSource : TFslObject);
begin
  inherited;
  FType_ := TFhirSequenceQuality(oSource).FType_.Link;
  standardSequence := TFhirSequenceQuality(oSource).standardSequence.Clone;
  startElement := TFhirSequenceQuality(oSource).startElement.Clone;
  end_Element := TFhirSequenceQuality(oSource).end_Element.Clone;
  score := TFhirSequenceQuality(oSource).score.Clone;
  method := TFhirSequenceQuality(oSource).method.Clone;
  truthTPElement := TFhirSequenceQuality(oSource).truthTPElement.Clone;
  queryTPElement := TFhirSequenceQuality(oSource).queryTPElement.Clone;
  truthFNElement := TFhirSequenceQuality(oSource).truthFNElement.Clone;
  queryFPElement := TFhirSequenceQuality(oSource).queryFPElement.Clone;
  gtFPElement := TFhirSequenceQuality(oSource).gtFPElement.Clone;
  precisionElement := TFhirSequenceQuality(oSource).precisionElement.Clone;
  recallElement := TFhirSequenceQuality(oSource).recallElement.Clone;
  fScore_Element := TFhirSequenceQuality(oSource).fScore_Element.Clone;
end;

procedure TFhirSequenceQuality.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'standardSequence') Then
     list.add(self.link, 'standardSequence', FStandardSequence.Link);
  if (child_name = 'start') Then
     list.add(self.link, 'start', FStart.Link);
  if (child_name = 'end') Then
     list.add(self.link, 'end', FEnd_.Link);
  if (child_name = 'score') Then
     list.add(self.link, 'score', FScore.Link);
  if (child_name = 'method') Then
     list.add(self.link, 'method', FMethod.Link);
  if (child_name = 'truthTP') Then
     list.add(self.link, 'truthTP', FTruthTP.Link);
  if (child_name = 'queryTP') Then
     list.add(self.link, 'queryTP', FQueryTP.Link);
  if (child_name = 'truthFN') Then
     list.add(self.link, 'truthFN', FTruthFN.Link);
  if (child_name = 'queryFP') Then
     list.add(self.link, 'queryFP', FQueryFP.Link);
  if (child_name = 'gtFP') Then
     list.add(self.link, 'gtFP', FGtFP.Link);
  if (child_name = 'precision') Then
     list.add(self.link, 'precision', FPrecision.Link);
  if (child_name = 'recall') Then
     list.add(self.link, 'recall', FRecall.Link);
  if (child_name = 'fScore') Then
     list.add(self.link, 'fScore', FFScore_.Link);
end;

procedure TFhirSequenceQuality.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'standardSequence', 'CodeableConcept', false, TFhirCodeableConcept, FStandardSequence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'start', 'integer', false, TFhirInteger, FStart.Link));{2}
  oList.add(TFHIRProperty.create(self, 'end', 'integer', false, TFhirInteger, FEnd_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'score', 'Quantity', false, TFhirQuantity, FScore.Link));{2}
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', false, TFhirCodeableConcept, FMethod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'truthTP', 'decimal', false, TFhirDecimal, FTruthTP.Link));{2}
  oList.add(TFHIRProperty.create(self, 'queryTP', 'decimal', false, TFhirDecimal, FQueryTP.Link));{2}
  oList.add(TFHIRProperty.create(self, 'truthFN', 'decimal', false, TFhirDecimal, FTruthFN.Link));{2}
  oList.add(TFHIRProperty.create(self, 'queryFP', 'decimal', false, TFhirDecimal, FQueryFP.Link));{2}
  oList.add(TFHIRProperty.create(self, 'gtFP', 'decimal', false, TFhirDecimal, FGtFP.Link));{2}
  oList.add(TFHIRProperty.create(self, 'precision', 'decimal', false, TFhirDecimal, FPrecision.Link));{2}
  oList.add(TFHIRProperty.create(self, 'recall', 'decimal', false, TFhirDecimal, FRecall.Link));{2}
  oList.add(TFHIRProperty.create(self, 'fScore', 'decimal', false, TFhirDecimal, FFScore_.Link));{2}
end;

function TFhirSequenceQuality.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirQualityTypeEnum, CODES_TFhirQualityTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'standardSequence') then
  begin
    StandardSequence := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'start') then
  begin
    StartElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'end') then
  begin
    End_Element := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'score') then
  begin
    Score := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'method') then
  begin
    Method := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'truthTP') then
  begin
    TruthTPElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'queryTP') then
  begin
    QueryTPElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'truthFN') then
  begin
    TruthFNElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'queryFP') then
  begin
    QueryFPElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'gtFP') then
  begin
    GtFPElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'precision') then
  begin
    PrecisionElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'recall') then
  begin
    RecallElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'fScore') then
  begin
    FScore_Element := asDecimal(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSequenceQuality.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSequenceQuality.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'standardSequence') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'start') then result := TFhirInteger.create() {5b}
  else if (propName = 'end') then result := TFhirInteger.create() {5b}
  else if (propName = 'score') then result := TFhirQuantity.create(){4b}
  else if (propName = 'method') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'truthTP') then result := TFhirDecimal.create() {5b}
  else if (propName = 'queryTP') then result := TFhirDecimal.create() {5b}
  else if (propName = 'truthFN') then result := TFhirDecimal.create() {5b}
  else if (propName = 'queryFP') then result := TFhirDecimal.create() {5b}
  else if (propName = 'gtFP') then result := TFhirDecimal.create() {5b}
  else if (propName = 'precision') then result := TFhirDecimal.create() {5b}
  else if (propName = 'recall') then result := TFhirDecimal.create() {5b}
  else if (propName = 'fScore') then result := TFhirDecimal.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSequenceQuality.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'standardSequence') then result := 'CodeableConcept'
  else if (propName = 'start') then result := 'integer'
  else if (propName = 'end') then result := 'integer'
  else if (propName = 'score') then result := 'Quantity'
  else if (propName = 'method') then result := 'CodeableConcept'
  else if (propName = 'truthTP') then result := 'decimal'
  else if (propName = 'queryTP') then result := 'decimal'
  else if (propName = 'truthFN') then result := 'decimal'
  else if (propName = 'queryFP') then result := 'decimal'
  else if (propName = 'gtFP') then result := 'decimal'
  else if (propName = 'precision') then result := 'decimal'
  else if (propName = 'recall') then result := 'decimal'
  else if (propName = 'fScore') then result := 'decimal'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSequenceQuality.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'standardSequence') then StandardSequenceElement := nil
  else if (propName = 'start') then StartElement := nil
  else if (propName = 'end') then End_Element := nil
  else if (propName = 'score') then ScoreElement := nil
  else if (propName = 'method') then MethodElement := nil
  else if (propName = 'truthTP') then TruthTPElement := nil
  else if (propName = 'queryTP') then QueryTPElement := nil
  else if (propName = 'truthFN') then TruthFNElement := nil
  else if (propName = 'queryFP') then QueryFPElement := nil
  else if (propName = 'gtFP') then GtFPElement := nil
  else if (propName = 'precision') then PrecisionElement := nil
  else if (propName = 'recall') then RecallElement := nil
  else if (propName = 'fScore') then FScore_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSequenceQuality.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirQualityTypeEnum, CODES_TFhirQualityTypeEnum, new){4}
  else if (propName = 'standardSequence') then StandardSequenceElement := new as TFhirCodeableConcept{4}
  else if (propName = 'start') then StartElement := asInteger(new){5b}
  else if (propName = 'end') then End_Element := asInteger(new){5b}
  else if (propName = 'score') then ScoreElement := new as TFhirQuantity{4}
  else if (propName = 'method') then MethodElement := new as TFhirCodeableConcept{4}
  else if (propName = 'truthTP') then TruthTPElement := asDecimal(new){5b}
  else if (propName = 'queryTP') then QueryTPElement := asDecimal(new){5b}
  else if (propName = 'truthFN') then TruthFNElement := asDecimal(new){5b}
  else if (propName = 'queryFP') then QueryFPElement := asDecimal(new){5b}
  else if (propName = 'gtFP') then GtFPElement := asDecimal(new){5b}
  else if (propName = 'precision') then PrecisionElement := asDecimal(new){5b}
  else if (propName = 'recall') then RecallElement := asDecimal(new){5b}
  else if (propName = 'fScore') then FScore_Element := asDecimal(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSequenceQuality.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSequenceQuality.fhirType : string;
begin
  result := 'quality';
end;

function TFhirSequenceQuality.Link : TFhirSequenceQuality;
begin
  result := TFhirSequenceQuality(inherited Link);
end;

function TFhirSequenceQuality.Clone : TFhirSequenceQuality;
begin
  result := TFhirSequenceQuality(inherited Clone);
end;

function TFhirSequenceQuality.equals(other : TObject) : boolean;
var
  o : TFhirSequenceQuality;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSequenceQuality)) then
    result := false
  else
  begin
    o := TFhirSequenceQuality(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(standardSequenceElement, o.standardSequenceElement, true) and
      compareDeep(startElement, o.startElement, true) and compareDeep(end_Element, o.end_Element, true) and
      compareDeep(scoreElement, o.scoreElement, true) and compareDeep(methodElement, o.methodElement, true) and
      compareDeep(truthTPElement, o.truthTPElement, true) and compareDeep(queryTPElement, o.queryTPElement, true) and
      compareDeep(truthFNElement, o.truthFNElement, true) and compareDeep(queryFPElement, o.queryFPElement, true) and
      compareDeep(gtFPElement, o.gtFPElement, true) and compareDeep(precisionElement, o.precisionElement, true) and
      compareDeep(recallElement, o.recallElement, true) and compareDeep(fScore_Element, o.fScore_Element, true);
  end;
end;

function TFhirSequenceQuality.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FStandardSequence) and isEmptyProp(FStart) and isEmptyProp(FEnd_) and isEmptyProp(FScore) and isEmptyProp(FMethod) and isEmptyProp(FTruthTP) and isEmptyProp(FQueryTP) and isEmptyProp(FTruthFN) and isEmptyProp(FQueryFP) and isEmptyProp(FGtFP) and isEmptyProp(FPrecision) and isEmptyProp(FRecall) and isEmptyProp(FFScore_);
end;

procedure TFhirSequenceQuality.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('standardSequence');
  fields.add('start');
  fields.add('end');
  fields.add('score');
  fields.add('method');
  fields.add('truthTP');
  fields.add('queryTP');
  fields.add('truthFN');
  fields.add('queryFP');
  fields.add('gtFP');
  fields.add('precision');
  fields.add('recall');
  fields.add('fScore');
end;

{ TFhirSequenceQuality }

Procedure TFhirSequenceQuality.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirSequenceQuality.GetType_ST : TFhirQualityTypeEnum;
begin
  if FType_ = nil then
    result := TFhirQualityTypeEnum(0)
  else
    result := TFhirQualityTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirQualityTypeEnum, FType_.value));
end;

Procedure TFhirSequenceQuality.SetType_ST(value : TFhirQualityTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirQualityTypeEnum[value], CODES_TFhirQualityTypeEnum[value]);
end;

Procedure TFhirSequenceQuality.SetStandardSequence(value : TFhirCodeableConcept);
begin
  FStandardSequence.free;
  FStandardSequence := value;
end;

Procedure TFhirSequenceQuality.SetStart(value : TFhirInteger);
begin
  FStart.free;
  FStart := value;
end;

Function TFhirSequenceQuality.GetStartST : String;
begin
  if FStart = nil then
    result := ''
  else
    result := FStart.value;
end;

Procedure TFhirSequenceQuality.SetStartST(value : String);
begin
  if value <> '' then
  begin
    if FStart = nil then
      FStart := TFhirInteger.create;
    FStart.value := value
  end
  else if FStart <> nil then
    FStart.value := '';
end;

Procedure TFhirSequenceQuality.SetEnd_(value : TFhirInteger);
begin
  FEnd_.free;
  FEnd_ := value;
end;

Function TFhirSequenceQuality.GetEnd_ST : String;
begin
  if FEnd_ = nil then
    result := ''
  else
    result := FEnd_.value;
end;

Procedure TFhirSequenceQuality.SetEnd_ST(value : String);
begin
  if value <> '' then
  begin
    if FEnd_ = nil then
      FEnd_ := TFhirInteger.create;
    FEnd_.value := value
  end
  else if FEnd_ <> nil then
    FEnd_.value := '';
end;

Procedure TFhirSequenceQuality.SetScore(value : TFhirQuantity);
begin
  FScore.free;
  FScore := value;
end;

Procedure TFhirSequenceQuality.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value;
end;

Procedure TFhirSequenceQuality.SetTruthTP(value : TFhirDecimal);
begin
  FTruthTP.free;
  FTruthTP := value;
end;

Function TFhirSequenceQuality.GetTruthTPST : String;
begin
  if FTruthTP = nil then
    result := ''
  else
    result := FTruthTP.value;
end;

Procedure TFhirSequenceQuality.SetTruthTPST(value : String);
begin
  if value <> '' then
  begin
    if FTruthTP = nil then
      FTruthTP := TFhirDecimal.create;
    FTruthTP.value := value
  end
  else if FTruthTP <> nil then
    FTruthTP.value := '';
end;

Procedure TFhirSequenceQuality.SetQueryTP(value : TFhirDecimal);
begin
  FQueryTP.free;
  FQueryTP := value;
end;

Function TFhirSequenceQuality.GetQueryTPST : String;
begin
  if FQueryTP = nil then
    result := ''
  else
    result := FQueryTP.value;
end;

Procedure TFhirSequenceQuality.SetQueryTPST(value : String);
begin
  if value <> '' then
  begin
    if FQueryTP = nil then
      FQueryTP := TFhirDecimal.create;
    FQueryTP.value := value
  end
  else if FQueryTP <> nil then
    FQueryTP.value := '';
end;

Procedure TFhirSequenceQuality.SetTruthFN(value : TFhirDecimal);
begin
  FTruthFN.free;
  FTruthFN := value;
end;

Function TFhirSequenceQuality.GetTruthFNST : String;
begin
  if FTruthFN = nil then
    result := ''
  else
    result := FTruthFN.value;
end;

Procedure TFhirSequenceQuality.SetTruthFNST(value : String);
begin
  if value <> '' then
  begin
    if FTruthFN = nil then
      FTruthFN := TFhirDecimal.create;
    FTruthFN.value := value
  end
  else if FTruthFN <> nil then
    FTruthFN.value := '';
end;

Procedure TFhirSequenceQuality.SetQueryFP(value : TFhirDecimal);
begin
  FQueryFP.free;
  FQueryFP := value;
end;

Function TFhirSequenceQuality.GetQueryFPST : String;
begin
  if FQueryFP = nil then
    result := ''
  else
    result := FQueryFP.value;
end;

Procedure TFhirSequenceQuality.SetQueryFPST(value : String);
begin
  if value <> '' then
  begin
    if FQueryFP = nil then
      FQueryFP := TFhirDecimal.create;
    FQueryFP.value := value
  end
  else if FQueryFP <> nil then
    FQueryFP.value := '';
end;

Procedure TFhirSequenceQuality.SetGtFP(value : TFhirDecimal);
begin
  FGtFP.free;
  FGtFP := value;
end;

Function TFhirSequenceQuality.GetGtFPST : String;
begin
  if FGtFP = nil then
    result := ''
  else
    result := FGtFP.value;
end;

Procedure TFhirSequenceQuality.SetGtFPST(value : String);
begin
  if value <> '' then
  begin
    if FGtFP = nil then
      FGtFP := TFhirDecimal.create;
    FGtFP.value := value
  end
  else if FGtFP <> nil then
    FGtFP.value := '';
end;

Procedure TFhirSequenceQuality.SetPrecision(value : TFhirDecimal);
begin
  FPrecision.free;
  FPrecision := value;
end;

Function TFhirSequenceQuality.GetPrecisionST : String;
begin
  if FPrecision = nil then
    result := ''
  else
    result := FPrecision.value;
end;

Procedure TFhirSequenceQuality.SetPrecisionST(value : String);
begin
  if value <> '' then
  begin
    if FPrecision = nil then
      FPrecision := TFhirDecimal.create;
    FPrecision.value := value
  end
  else if FPrecision <> nil then
    FPrecision.value := '';
end;

Procedure TFhirSequenceQuality.SetRecall(value : TFhirDecimal);
begin
  FRecall.free;
  FRecall := value;
end;

Function TFhirSequenceQuality.GetRecallST : String;
begin
  if FRecall = nil then
    result := ''
  else
    result := FRecall.value;
end;

Procedure TFhirSequenceQuality.SetRecallST(value : String);
begin
  if value <> '' then
  begin
    if FRecall = nil then
      FRecall := TFhirDecimal.create;
    FRecall.value := value
  end
  else if FRecall <> nil then
    FRecall.value := '';
end;

Procedure TFhirSequenceQuality.SetFScore_(value : TFhirDecimal);
begin
  FFScore_.free;
  FFScore_ := value;
end;

Function TFhirSequenceQuality.GetFScore_ST : String;
begin
  if FFScore_ = nil then
    result := ''
  else
    result := FFScore_.value;
end;

Procedure TFhirSequenceQuality.SetFScore_ST(value : String);
begin
  if value <> '' then
  begin
    if FFScore_ = nil then
      FFScore_ := TFhirDecimal.create;
    FFScore_.value := value
  end
  else if FFScore_ <> nil then
    FFScore_.value := '';
end;

function TFhirSequenceQuality.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FStandardSequence.sizeInBytes);
  inc(result, FStart.sizeInBytes);
  inc(result, FEnd_.sizeInBytes);
  inc(result, FScore.sizeInBytes);
  inc(result, FMethod.sizeInBytes);
  inc(result, FTruthTP.sizeInBytes);
  inc(result, FQueryTP.sizeInBytes);
  inc(result, FTruthFN.sizeInBytes);
  inc(result, FQueryFP.sizeInBytes);
  inc(result, FGtFP.sizeInBytes);
  inc(result, FPrecision.sizeInBytes);
  inc(result, FRecall.sizeInBytes);
  inc(result, FFScore_.sizeInBytes);
end;

{ TFhirSequenceQualityListEnumerator }

Constructor TFhirSequenceQualityListEnumerator.Create(list : TFhirSequenceQualityList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSequenceQualityListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSequenceQualityListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSequenceQualityListEnumerator.GetCurrent : TFhirSequenceQuality;
begin
  Result := FList[FIndex];
end;

function TFhirSequenceQualityListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSequenceQualityList }
procedure TFhirSequenceQualityList.AddItem(value: TFhirSequenceQuality);
begin
  assert(value.ClassName = 'TFhirSequenceQuality', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSequenceQuality');
  add(value);
end;

function TFhirSequenceQualityList.Append: TFhirSequenceQuality;
begin
  result := TFhirSequenceQuality.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSequenceQualityList.ClearItems;
begin
  Clear;
end;

function TFhirSequenceQualityList.GetEnumerator : TFhirSequenceQualityListEnumerator;
begin
  result := TFhirSequenceQualityListEnumerator.Create(self.link);
end;

function TFhirSequenceQualityList.Clone: TFhirSequenceQualityList;
begin
  result := TFhirSequenceQualityList(inherited Clone);
end;

function TFhirSequenceQualityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSequenceQualityList.GetItemN(index: Integer): TFhirSequenceQuality;
begin
  result := TFhirSequenceQuality(ObjectByIndex[index]);
end;

function TFhirSequenceQualityList.ItemClass: TFslObjectClass;
begin
  result := TFhirSequenceQuality;
end;
function TFhirSequenceQualityList.IndexOf(value: TFhirSequenceQuality): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSequenceQualityList.Insert(index: Integer): TFhirSequenceQuality;
begin
  result := TFhirSequenceQuality.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSequenceQualityList.InsertItem(index: Integer; value: TFhirSequenceQuality);
begin
  assert(value is TFhirSequenceQuality);
  Inherited Insert(index, value);
end;

function TFhirSequenceQualityList.Item(index: Integer): TFhirSequenceQuality;
begin
  result := TFhirSequenceQuality(ObjectByIndex[index]);
end;

function TFhirSequenceQualityList.Link: TFhirSequenceQualityList;
begin
  result := TFhirSequenceQualityList(inherited Link);
end;

procedure TFhirSequenceQualityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSequenceQualityList.SetItemByIndex(index: Integer; value: TFhirSequenceQuality);
begin
  assert(value is TFhirSequenceQuality);
  FhirSequenceQualities[index] := value;
end;

procedure TFhirSequenceQualityList.SetItemN(index: Integer; value: TFhirSequenceQuality);
begin
  assert(value is TFhirSequenceQuality);
  ObjectByIndex[index] := value;
end;

{ TFhirSequenceRepository }

constructor TFhirSequenceRepository.Create;
begin
  inherited;
end;

destructor TFhirSequenceRepository.Destroy;
begin
  FType_.free;
  FUrl.free;
  FName.free;
  FDatasetId.free;
  FVariantsetId.free;
  FReadsetId.free;
  inherited;
end;

procedure TFhirSequenceRepository.Assign(oSource : TFslObject);
begin
  inherited;
  FType_ := TFhirSequenceRepository(oSource).FType_.Link;
  urlElement := TFhirSequenceRepository(oSource).urlElement.Clone;
  nameElement := TFhirSequenceRepository(oSource).nameElement.Clone;
  datasetIdElement := TFhirSequenceRepository(oSource).datasetIdElement.Clone;
  variantsetIdElement := TFhirSequenceRepository(oSource).variantsetIdElement.Clone;
  readsetIdElement := TFhirSequenceRepository(oSource).readsetIdElement.Clone;
end;

procedure TFhirSequenceRepository.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'datasetId') Then
     list.add(self.link, 'datasetId', FDatasetId.Link);
  if (child_name = 'variantsetId') Then
     list.add(self.link, 'variantsetId', FVariantsetId.Link);
  if (child_name = 'readsetId') Then
     list.add(self.link, 'readsetId', FReadsetId.Link);
end;

procedure TFhirSequenceRepository.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'datasetId', 'string', false, TFhirString, FDatasetId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'variantsetId', 'string', false, TFhirString, FVariantsetId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'readsetId', 'string', false, TFhirString, FReadsetId.Link));{2}
end;

function TFhirSequenceRepository.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirRepositoryTypeEnum, CODES_TFhirRepositoryTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'url') then
  begin
    UrlElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'datasetId') then
  begin
    DatasetIdElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'variantsetId') then
  begin
    VariantsetIdElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'readsetId') then
  begin
    ReadsetIdElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSequenceRepository.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSequenceRepository.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create() {5b}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'datasetId') then result := TFhirString.create() {5b}
  else if (propName = 'variantsetId') then result := TFhirString.create() {5b}
  else if (propName = 'readsetId') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSequenceRepository.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'url') then result := 'uri'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'datasetId') then result := 'string'
  else if (propName = 'variantsetId') then result := 'string'
  else if (propName = 'readsetId') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSequenceRepository.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'url') then UrlElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'datasetId') then DatasetIdElement := nil
  else if (propName = 'variantsetId') then VariantsetIdElement := nil
  else if (propName = 'readsetId') then ReadsetIdElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSequenceRepository.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirRepositoryTypeEnum, CODES_TFhirRepositoryTypeEnum, new){4}
  else if (propName = 'url') then UrlElement := asUri(new){5b}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'datasetId') then DatasetIdElement := asString(new){5b}
  else if (propName = 'variantsetId') then VariantsetIdElement := asString(new){5b}
  else if (propName = 'readsetId') then ReadsetIdElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSequenceRepository.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSequenceRepository.fhirType : string;
begin
  result := 'repository';
end;

function TFhirSequenceRepository.Link : TFhirSequenceRepository;
begin
  result := TFhirSequenceRepository(inherited Link);
end;

function TFhirSequenceRepository.Clone : TFhirSequenceRepository;
begin
  result := TFhirSequenceRepository(inherited Clone);
end;

function TFhirSequenceRepository.equals(other : TObject) : boolean;
var
  o : TFhirSequenceRepository;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSequenceRepository)) then
    result := false
  else
  begin
    o := TFhirSequenceRepository(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(urlElement, o.urlElement, true) and
      compareDeep(nameElement, o.nameElement, true) and compareDeep(datasetIdElement, o.datasetIdElement, true) and
      compareDeep(variantsetIdElement, o.variantsetIdElement, true) and compareDeep(readsetIdElement, o.readsetIdElement, true);
  end;
end;

function TFhirSequenceRepository.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FUrl) and isEmptyProp(FName) and isEmptyProp(FDatasetId) and isEmptyProp(FVariantsetId) and isEmptyProp(FReadsetId);
end;

procedure TFhirSequenceRepository.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('url');
  fields.add('name');
  fields.add('datasetId');
  fields.add('variantsetId');
  fields.add('readsetId');
end;

{ TFhirSequenceRepository }

Procedure TFhirSequenceRepository.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirSequenceRepository.GetType_ST : TFhirRepositoryTypeEnum;
begin
  if FType_ = nil then
    result := TFhirRepositoryTypeEnum(0)
  else
    result := TFhirRepositoryTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirRepositoryTypeEnum, FType_.value));
end;

Procedure TFhirSequenceRepository.SetType_ST(value : TFhirRepositoryTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirRepositoryTypeEnum[value], CODES_TFhirRepositoryTypeEnum[value]);
end;

Procedure TFhirSequenceRepository.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirSequenceRepository.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

Procedure TFhirSequenceRepository.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

Procedure TFhirSequenceRepository.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirSequenceRepository.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirSequenceRepository.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirSequenceRepository.SetDatasetId(value : TFhirString);
begin
  FDatasetId.free;
  FDatasetId := value;
end;

Function TFhirSequenceRepository.GetDatasetIdST : String;
begin
  if FDatasetId = nil then
    result := ''
  else
    result := FDatasetId.value;
end;

Procedure TFhirSequenceRepository.SetDatasetIdST(value : String);
begin
  if value <> '' then
  begin
    if FDatasetId = nil then
      FDatasetId := TFhirString.create;
    FDatasetId.value := value
  end
  else if FDatasetId <> nil then
    FDatasetId.value := '';
end;

Procedure TFhirSequenceRepository.SetVariantsetId(value : TFhirString);
begin
  FVariantsetId.free;
  FVariantsetId := value;
end;

Function TFhirSequenceRepository.GetVariantsetIdST : String;
begin
  if FVariantsetId = nil then
    result := ''
  else
    result := FVariantsetId.value;
end;

Procedure TFhirSequenceRepository.SetVariantsetIdST(value : String);
begin
  if value <> '' then
  begin
    if FVariantsetId = nil then
      FVariantsetId := TFhirString.create;
    FVariantsetId.value := value
  end
  else if FVariantsetId <> nil then
    FVariantsetId.value := '';
end;

Procedure TFhirSequenceRepository.SetReadsetId(value : TFhirString);
begin
  FReadsetId.free;
  FReadsetId := value;
end;

Function TFhirSequenceRepository.GetReadsetIdST : String;
begin
  if FReadsetId = nil then
    result := ''
  else
    result := FReadsetId.value;
end;

Procedure TFhirSequenceRepository.SetReadsetIdST(value : String);
begin
  if value <> '' then
  begin
    if FReadsetId = nil then
      FReadsetId := TFhirString.create;
    FReadsetId.value := value
  end
  else if FReadsetId <> nil then
    FReadsetId.value := '';
end;

function TFhirSequenceRepository.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FUrl.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FDatasetId.sizeInBytes);
  inc(result, FVariantsetId.sizeInBytes);
  inc(result, FReadsetId.sizeInBytes);
end;

{ TFhirSequenceRepositoryListEnumerator }

Constructor TFhirSequenceRepositoryListEnumerator.Create(list : TFhirSequenceRepositoryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSequenceRepositoryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSequenceRepositoryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSequenceRepositoryListEnumerator.GetCurrent : TFhirSequenceRepository;
begin
  Result := FList[FIndex];
end;

function TFhirSequenceRepositoryListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSequenceRepositoryList }
procedure TFhirSequenceRepositoryList.AddItem(value: TFhirSequenceRepository);
begin
  assert(value.ClassName = 'TFhirSequenceRepository', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSequenceRepository');
  add(value);
end;

function TFhirSequenceRepositoryList.Append: TFhirSequenceRepository;
begin
  result := TFhirSequenceRepository.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSequenceRepositoryList.ClearItems;
begin
  Clear;
end;

function TFhirSequenceRepositoryList.GetEnumerator : TFhirSequenceRepositoryListEnumerator;
begin
  result := TFhirSequenceRepositoryListEnumerator.Create(self.link);
end;

function TFhirSequenceRepositoryList.Clone: TFhirSequenceRepositoryList;
begin
  result := TFhirSequenceRepositoryList(inherited Clone);
end;

function TFhirSequenceRepositoryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSequenceRepositoryList.GetItemN(index: Integer): TFhirSequenceRepository;
begin
  result := TFhirSequenceRepository(ObjectByIndex[index]);
end;

function TFhirSequenceRepositoryList.ItemClass: TFslObjectClass;
begin
  result := TFhirSequenceRepository;
end;
function TFhirSequenceRepositoryList.IndexOf(value: TFhirSequenceRepository): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSequenceRepositoryList.Insert(index: Integer): TFhirSequenceRepository;
begin
  result := TFhirSequenceRepository.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSequenceRepositoryList.InsertItem(index: Integer; value: TFhirSequenceRepository);
begin
  assert(value is TFhirSequenceRepository);
  Inherited Insert(index, value);
end;

function TFhirSequenceRepositoryList.Item(index: Integer): TFhirSequenceRepository;
begin
  result := TFhirSequenceRepository(ObjectByIndex[index]);
end;

function TFhirSequenceRepositoryList.Link: TFhirSequenceRepositoryList;
begin
  result := TFhirSequenceRepositoryList(inherited Link);
end;

procedure TFhirSequenceRepositoryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSequenceRepositoryList.SetItemByIndex(index: Integer; value: TFhirSequenceRepository);
begin
  assert(value is TFhirSequenceRepository);
  FhirSequenceRepositories[index] := value;
end;

procedure TFhirSequenceRepositoryList.SetItemN(index: Integer; value: TFhirSequenceRepository);
begin
  assert(value is TFhirSequenceRepository);
  ObjectByIndex[index] := value;
end;

{ TFhirSequence }

constructor TFhirSequence.Create;
begin
  inherited;
end;

destructor TFhirSequence.Destroy;
begin
  FIdentifierList.Free;
  FType_.free;
  FCoordinateSystem.free;
  FPatient.free;
  FSpecimen.free;
  FDevice.free;
  FPerformer.free;
  FQuantity.free;
  FReferenceSeq.free;
  FVariantList.Free;
  FObservedSeq.free;
  FQualityList.Free;
  FReadCoverage.free;
  FRepositoryList.Free;
  FPointerList.Free;
  inherited;
end;

function TFhirSequence.GetResourceType : TFhirResourceType;
begin
  result := frtSequence;
end;

procedure TFhirSequence.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirSequence(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirSequence(oSource).FIdentifierList);
  end;
  type_Element := TFhirSequence(oSource).type_Element.Clone;
  coordinateSystemElement := TFhirSequence(oSource).coordinateSystemElement.Clone;
  patient := TFhirSequence(oSource).patient.Clone;
  specimen := TFhirSequence(oSource).specimen.Clone;
  device := TFhirSequence(oSource).device.Clone;
  performer := TFhirSequence(oSource).performer.Clone;
  quantity := TFhirSequence(oSource).quantity.Clone;
  referenceSeq := TFhirSequence(oSource).referenceSeq.Clone;
  if (TFhirSequence(oSource).FVariantList = nil) then
  begin
    FVariantList.free;
    FVariantList := nil;
  end
  else
  begin
    if FVariantList = nil then
      FVariantList := TFhirSequenceVariantList.Create;
    FVariantList.Assign(TFhirSequence(oSource).FVariantList);
  end;
  observedSeqElement := TFhirSequence(oSource).observedSeqElement.Clone;
  if (TFhirSequence(oSource).FQualityList = nil) then
  begin
    FQualityList.free;
    FQualityList := nil;
  end
  else
  begin
    if FQualityList = nil then
      FQualityList := TFhirSequenceQualityList.Create;
    FQualityList.Assign(TFhirSequence(oSource).FQualityList);
  end;
  readCoverageElement := TFhirSequence(oSource).readCoverageElement.Clone;
  if (TFhirSequence(oSource).FRepositoryList = nil) then
  begin
    FRepositoryList.free;
    FRepositoryList := nil;
  end
  else
  begin
    if FRepositoryList = nil then
      FRepositoryList := TFhirSequenceRepositoryList.Create;
    FRepositoryList.Assign(TFhirSequence(oSource).FRepositoryList);
  end;
  if (TFhirSequence(oSource).FPointerList = nil) then
  begin
    FPointerList.free;
    FPointerList := nil;
  end
  else
  begin
    if FPointerList = nil then
      FPointerList := TFhirReferenceList{TFhirSequence}.Create;
    FPointerList.Assign(TFhirSequence(oSource).FPointerList);
  end;
end;

procedure TFhirSequence.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'coordinateSystem') Then
     list.add(self.link, 'coordinateSystem', FCoordinateSystem.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'specimen') Then
     list.add(self.link, 'specimen', FSpecimen.Link);
  if (child_name = 'device') Then
     list.add(self.link, 'device', FDevice.Link);
  if (child_name = 'performer') Then
     list.add(self.link, 'performer', FPerformer.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'referenceSeq') Then
     list.add(self.link, 'referenceSeq', FReferenceSeq.Link);
  if (child_name = 'variant') Then
    list.addAll(self, 'variant', FVariantList);
  if (child_name = 'observedSeq') Then
     list.add(self.link, 'observedSeq', FObservedSeq.Link);
  if (child_name = 'quality') Then
    list.addAll(self, 'quality', FQualityList);
  if (child_name = 'readCoverage') Then
     list.add(self.link, 'readCoverage', FReadCoverage.Link);
  if (child_name = 'repository') Then
    list.addAll(self, 'repository', FRepositoryList);
  if (child_name = 'pointer') Then
    list.addAll(self, 'pointer', FPointerList);
end;

procedure TFhirSequence.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirCode, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'coordinateSystem', 'integer', false, TFhirInteger, FCoordinateSystem.Link));{2}
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'specimen', 'Reference(Specimen)', false, TFhirReference{TFhirSpecimen}, FSpecimen.Link));{2}
  oList.add(TFHIRProperty.create(self, 'device', 'Reference(Device)', false, TFhirReference{TFhirDevice}, FDevice.Link));{2}
  oList.add(TFHIRProperty.create(self, 'performer', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FPerformer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'referenceSeq', '', false, TFhirSequenceReferenceSeq, FReferenceSeq.Link));{2}
  oList.add(TFHIRProperty.create(self, 'variant', '', true, TFhirSequenceVariant, FVariantList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'observedSeq', 'string', false, TFhirString, FObservedSeq.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quality', '', true, TFhirSequenceQuality, FQualityList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'readCoverage', 'integer', false, TFhirInteger, FReadCoverage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'repository', '', true, TFhirSequenceRepository, FRepositoryList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'pointer', 'Reference(Sequence)', true, TFhirReference{TFhirSequence}, FPointerList.Link)){3};
end;

function TFhirSequence.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'coordinateSystem') then
  begin
    CoordinateSystemElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'specimen') then
  begin
    Specimen := propValue as TFhirReference{TFhirSpecimen}{4b};
    result := propValue;
  end
  else if (propName = 'device') then
  begin
    Device := propValue as TFhirReference{TFhirDevice}{4b};
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    Performer := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'referenceSeq') then
  begin
    ReferenceSeq := propValue as TFhirSequenceReferenceSeq{4b};
    result := propValue;
  end
  else if (propName = 'variant') then
  begin
    VariantList.add(propValue as TFhirSequenceVariant){2a};
    result := propValue;
  end
  else if (propName = 'observedSeq') then
  begin
    ObservedSeqElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'quality') then
  begin
    QualityList.add(propValue as TFhirSequenceQuality){2a};
    result := propValue;
  end
  else if (propName = 'readCoverage') then
  begin
    ReadCoverageElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'repository') then
  begin
    RepositoryList.add(propValue as TFhirSequenceRepository){2a};
    result := propValue;
  end
  else if (propName = 'pointer') then
  begin
    PointerList.add(propValue as TFhirReference{TFhirSequence}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirSequence.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'variant') then VariantList.insertItem(index, propValue as TFhirSequenceVariant){2a}
  else if (propName = 'quality') then QualityList.insertItem(index, propValue as TFhirSequenceQuality){2a}
  else if (propName = 'repository') then RepositoryList.insertItem(index, propValue as TFhirSequenceRepository){2a}
  else if (propName = 'pointer') then PointerList.insertItem(index, propValue as TFhirReference{TFhirSequence}){2a}
  else inherited;
end;

function TFhirSequence.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'type') then result := TFhirCode.create() {5b}
  else if (propName = 'coordinateSystem') then result := TFhirInteger.create() {5b}
  else if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'specimen') then result := TFhirReference{TFhirSpecimen}.create(){4b}
  else if (propName = 'device') then result := TFhirReference{TFhirDevice}.create(){4b}
  else if (propName = 'performer') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'referenceSeq') then result := TFhirSequenceReferenceSeq.create(){4b}
  else if (propName = 'variant') then result := VariantList.new(){2}
  else if (propName = 'observedSeq') then result := TFhirString.create() {5b}
  else if (propName = 'quality') then result := QualityList.new(){2}
  else if (propName = 'readCoverage') then result := TFhirInteger.create() {5b}
  else if (propName = 'repository') then result := RepositoryList.new(){2}
  else if (propName = 'pointer') then result := PointerList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSequence.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'coordinateSystem') then result := 'integer'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'specimen') then result := 'Reference'
  else if (propName = 'device') then result := 'Reference'
  else if (propName = 'performer') then result := 'Reference'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'referenceSeq') then result := ''
  else if (propName = 'variant') then result := ''
  else if (propName = 'observedSeq') then result := 'string'
  else if (propName = 'quality') then result := ''
  else if (propName = 'readCoverage') then result := 'integer'
  else if (propName = 'repository') then result := ''
  else if (propName = 'pointer') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSequence.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'coordinateSystem') then CoordinateSystemElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'specimen') then SpecimenElement := nil
  else if (propName = 'device') then DeviceElement := nil
  else if (propName = 'performer') then PerformerElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'referenceSeq') then ReferenceSeqElement := nil
  else if (propName = 'variant') then deletePropertyValue('variant', VariantList, value) {2}
  else if (propName = 'observedSeq') then ObservedSeqElement := nil
  else if (propName = 'quality') then deletePropertyValue('quality', QualityList, value) {2}
  else if (propName = 'readCoverage') then ReadCoverageElement := nil
  else if (propName = 'repository') then deletePropertyValue('repository', RepositoryList, value) {2}
  else if (propName = 'pointer') then deletePropertyValue('pointer', PointerList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSequence.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'type') then Type_Element := asCode(new){5b}
  else if (propName = 'coordinateSystem') then CoordinateSystemElement := asInteger(new){5b}
  else if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'specimen') then SpecimenElement := new as TFhirReference{TFhirSpecimen}{4}
  else if (propName = 'device') then DeviceElement := new as TFhirReference{TFhirDevice}{4}
  else if (propName = 'performer') then PerformerElement := new as TFhirReference{TFhirOrganization}{4}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'referenceSeq') then ReferenceSeqElement := new as TFhirSequenceReferenceSeq{4}
  else if (propName = 'variant') then replacePropertyValue('variant', VariantList, existing, new) {2}
  else if (propName = 'observedSeq') then ObservedSeqElement := asString(new){5b}
  else if (propName = 'quality') then replacePropertyValue('quality', QualityList, existing, new) {2}
  else if (propName = 'readCoverage') then ReadCoverageElement := asInteger(new){5b}
  else if (propName = 'repository') then replacePropertyValue('repository', RepositoryList, existing, new) {2}
  else if (propName = 'pointer') then replacePropertyValue('pointer', PointerList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSequence.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'variant') then VariantList.move(source, destination){2a}
  else if (propName = 'quality') then QualityList.move(source, destination){2a}
  else if (propName = 'repository') then RepositoryList.move(source, destination){2a}
  else if (propName = 'pointer') then PointerList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSequence.fhirType : string;
begin
  result := 'Sequence';
end;

function TFhirSequence.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FType_) and isEmptyProp(FCoordinateSystem) and isEmptyProp(FPatient) and isEmptyProp(FSpecimen) and isEmptyProp(FDevice) and isEmptyProp(FPerformer) and isEmptyProp(FQuantity) and isEmptyProp(FReferenceSeq) and isEmptyProp(FvariantList) and isEmptyProp(FObservedSeq) and isEmptyProp(FqualityList) and isEmptyProp(FReadCoverage) and isEmptyProp(FrepositoryList) and isEmptyProp(FpointerList);
end;

function TFhirSequence.equals(other : TObject) : boolean;
var
  o : TFhirSequence;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSequence)) then
    result := false
  else
  begin
    o := TFhirSequence(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(type_Element, o.type_Element, true) and
      compareDeep(coordinateSystemElement, o.coordinateSystemElement, true) and compareDeep(patientElement, o.patientElement, true) and
      compareDeep(specimenElement, o.specimenElement, true) and compareDeep(deviceElement, o.deviceElement, true) and
      compareDeep(performerElement, o.performerElement, true) and compareDeep(quantityElement, o.quantityElement, true) and
      compareDeep(referenceSeqElement, o.referenceSeqElement, true) and compareDeep(variantList, o.variantList, true) and
      compareDeep(observedSeqElement, o.observedSeqElement, true) and compareDeep(qualityList, o.qualityList, true) and
      compareDeep(readCoverageElement, o.readCoverageElement, true) and compareDeep(repositoryList, o.repositoryList, true) and
      compareDeep(pointerList, o.pointerList, true);
  end;
end;

function TFhirSequence.Link : TFhirSequence;
begin
  result := TFhirSequence(inherited Link);
end;

function TFhirSequence.Clone : TFhirSequence;
begin
  result := TFhirSequence(inherited Clone);
end;

procedure TFhirSequence.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('type');
  fields.add('coordinateSystem');
  fields.add('patient');
  fields.add('specimen');
  fields.add('device');
  fields.add('performer');
  fields.add('quantity');
  fields.add('referenceSeq');
  fields.add('variant');
  fields.add('observedSeq');
  fields.add('quality');
  fields.add('readCoverage');
  fields.add('repository');
  fields.add('pointer');
end;

{ TFhirSequence }

Function TFhirSequence.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirSequence.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirSequence.SetType_(value : TFhirCode);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirSequence.GetType_ST : String;
begin
  if FType_ = nil then
    result := ''
  else
    result := FType_.value;
end;

Procedure TFhirSequence.SetType_ST(value : String);
begin
  if value <> '' then
  begin
    if FType_ = nil then
      FType_ := TFhirCode.create;
    FType_.value := value
  end
  else if FType_ <> nil then
    FType_.value := '';
end;

Procedure TFhirSequence.SetCoordinateSystem(value : TFhirInteger);
begin
  FCoordinateSystem.free;
  FCoordinateSystem := value;
end;

Function TFhirSequence.GetCoordinateSystemST : String;
begin
  if FCoordinateSystem = nil then
    result := ''
  else
    result := FCoordinateSystem.value;
end;

Procedure TFhirSequence.SetCoordinateSystemST(value : String);
begin
  if value <> '' then
  begin
    if FCoordinateSystem = nil then
      FCoordinateSystem := TFhirInteger.create;
    FCoordinateSystem.value := value
  end
  else if FCoordinateSystem <> nil then
    FCoordinateSystem.value := '';
end;

Procedure TFhirSequence.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Procedure TFhirSequence.SetSpecimen(value : TFhirReference{TFhirSpecimen});
begin
  FSpecimen.free;
  FSpecimen := value;
end;

Procedure TFhirSequence.SetDevice(value : TFhirReference{TFhirDevice});
begin
  FDevice.free;
  FDevice := value;
end;

Procedure TFhirSequence.SetPerformer(value : TFhirReference{TFhirOrganization});
begin
  FPerformer.free;
  FPerformer := value;
end;

Procedure TFhirSequence.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirSequence.SetReferenceSeq(value : TFhirSequenceReferenceSeq);
begin
  FReferenceSeq.free;
  FReferenceSeq := value;
end;

Function TFhirSequence.GetVariantList : TFhirSequenceVariantList;
begin
  if FVariantList = nil then
    FVariantList := TFhirSequenceVariantList.Create;
  result := FVariantList;
end;

Function TFhirSequence.GetHasVariantList : boolean;
begin
  result := (FVariantList <> nil) and (FVariantList.count > 0);
end;

Procedure TFhirSequence.SetObservedSeq(value : TFhirString);
begin
  FObservedSeq.free;
  FObservedSeq := value;
end;

Function TFhirSequence.GetObservedSeqST : String;
begin
  if FObservedSeq = nil then
    result := ''
  else
    result := FObservedSeq.value;
end;

Procedure TFhirSequence.SetObservedSeqST(value : String);
begin
  if value <> '' then
  begin
    if FObservedSeq = nil then
      FObservedSeq := TFhirString.create;
    FObservedSeq.value := value
  end
  else if FObservedSeq <> nil then
    FObservedSeq.value := '';
end;

Function TFhirSequence.GetQualityList : TFhirSequenceQualityList;
begin
  if FQualityList = nil then
    FQualityList := TFhirSequenceQualityList.Create;
  result := FQualityList;
end;

Function TFhirSequence.GetHasQualityList : boolean;
begin
  result := (FQualityList <> nil) and (FQualityList.count > 0);
end;

Procedure TFhirSequence.SetReadCoverage(value : TFhirInteger);
begin
  FReadCoverage.free;
  FReadCoverage := value;
end;

Function TFhirSequence.GetReadCoverageST : String;
begin
  if FReadCoverage = nil then
    result := ''
  else
    result := FReadCoverage.value;
end;

Procedure TFhirSequence.SetReadCoverageST(value : String);
begin
  if value <> '' then
  begin
    if FReadCoverage = nil then
      FReadCoverage := TFhirInteger.create;
    FReadCoverage.value := value
  end
  else if FReadCoverage <> nil then
    FReadCoverage.value := '';
end;

Function TFhirSequence.GetRepositoryList : TFhirSequenceRepositoryList;
begin
  if FRepositoryList = nil then
    FRepositoryList := TFhirSequenceRepositoryList.Create;
  result := FRepositoryList;
end;

Function TFhirSequence.GetHasRepositoryList : boolean;
begin
  result := (FRepositoryList <> nil) and (FRepositoryList.count > 0);
end;

Function TFhirSequence.GetPointerList : TFhirReferenceList{TFhirSequence};
begin
  if FPointerList = nil then
    FPointerList := TFhirReferenceList{TFhirSequence}.Create;
  result := FPointerList;
end;

Function TFhirSequence.GetHasPointerList : boolean;
begin
  result := (FPointerList <> nil) and (FPointerList.count > 0);
end;

function TFhirSequence.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FCoordinateSystem.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FSpecimen.sizeInBytes);
  inc(result, FDevice.sizeInBytes);
  inc(result, FPerformer.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FReferenceSeq.sizeInBytes);
  inc(result, FvariantList.sizeInBytes);
  inc(result, FObservedSeq.sizeInBytes);
  inc(result, FqualityList.sizeInBytes);
  inc(result, FReadCoverage.sizeInBytes);
  inc(result, FrepositoryList.sizeInBytes);
  inc(result, FpointerList.sizeInBytes);
end;

{ TFhirSequenceListEnumerator }

Constructor TFhirSequenceListEnumerator.Create(list : TFhirSequenceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSequenceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSequenceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSequenceListEnumerator.GetCurrent : TFhirSequence;
begin
  Result := FList[FIndex];
end;

function TFhirSequenceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSequenceList }
procedure TFhirSequenceList.AddItem(value: TFhirSequence);
begin
  assert(value.ClassName = 'TFhirSequence', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSequence');
  add(value);
end;

function TFhirSequenceList.Append: TFhirSequence;
begin
  result := TFhirSequence.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSequenceList.ClearItems;
begin
  Clear;
end;

function TFhirSequenceList.GetEnumerator : TFhirSequenceListEnumerator;
begin
  result := TFhirSequenceListEnumerator.Create(self.link);
end;

function TFhirSequenceList.Clone: TFhirSequenceList;
begin
  result := TFhirSequenceList(inherited Clone);
end;

function TFhirSequenceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSequenceList.GetItemN(index: Integer): TFhirSequence;
begin
  result := TFhirSequence(ObjectByIndex[index]);
end;

function TFhirSequenceList.ItemClass: TFslObjectClass;
begin
  result := TFhirSequence;
end;
function TFhirSequenceList.IndexOf(value: TFhirSequence): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSequenceList.Insert(index: Integer): TFhirSequence;
begin
  result := TFhirSequence.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSequenceList.InsertItem(index: Integer; value: TFhirSequence);
begin
  assert(value is TFhirSequence);
  Inherited Insert(index, value);
end;

function TFhirSequenceList.Item(index: Integer): TFhirSequence;
begin
  result := TFhirSequence(ObjectByIndex[index]);
end;

function TFhirSequenceList.Link: TFhirSequenceList;
begin
  result := TFhirSequenceList(inherited Link);
end;

procedure TFhirSequenceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSequenceList.SetItemByIndex(index: Integer; value: TFhirSequence);
begin
  assert(value is TFhirSequence);
  FhirSequences[index] := value;
end;

procedure TFhirSequenceList.SetItemN(index: Integer; value: TFhirSequence);
begin
  assert(value is TFhirSequence);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SEQUENCE}

{$IFDEF FHIR_SPECIMEN}

{ TFhirSpecimenCollection }

constructor TFhirSpecimenCollection.Create;
begin
  inherited;
end;

destructor TFhirSpecimenCollection.Destroy;
begin
  FCollector.free;
  FCollected.free;
  FQuantity.free;
  FMethod.free;
  FBodySite.free;
  inherited;
end;

procedure TFhirSpecimenCollection.Assign(oSource : TFslObject);
begin
  inherited;
  collector := TFhirSpecimenCollection(oSource).collector.Clone;
  collected := TFhirSpecimenCollection(oSource).collected.Clone;
  quantity := TFhirSpecimenCollection(oSource).quantity.Clone;
  method := TFhirSpecimenCollection(oSource).method.Clone;
  bodySite := TFhirSpecimenCollection(oSource).bodySite.Clone;
end;

procedure TFhirSpecimenCollection.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'collector') Then
     list.add(self.link, 'collector', FCollector.Link);
  if (child_name = 'collected[x]') or (child_name = 'collected') Then
     list.add(self.link, 'collected[x]', FCollected.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'method') Then
     list.add(self.link, 'method', FMethod.Link);
  if (child_name = 'bodySite') Then
     list.add(self.link, 'bodySite', FBodySite.Link);
end;

procedure TFhirSpecimenCollection.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'collector', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FCollector.Link));{2}
  oList.add(TFHIRProperty.create(self, 'collected[x]', 'dateTime|Period', false, TFhirType, FCollected.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', false, TFhirCodeableConcept, FMethod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', false, TFhirCodeableConcept, FBodySite.Link));{2}
end;

function TFhirSpecimenCollection.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'collector') then
  begin
    Collector := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'collected', ['DateTime', 'Period'])) then
  begin
    Collected := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'method') then
  begin
    Method := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySite := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSpecimenCollection.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSpecimenCollection.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'collector') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (isMatchingName(propName, 'collected', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Collected'){4x}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'method') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'bodySite') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSpecimenCollection.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'collector') then result := 'Reference'
  else if (propName = 'collected[x]') then result := 'dateTime|Period'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'method') then result := 'CodeableConcept'
  else if (propName = 'bodySite') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSpecimenCollection.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'collector') then CollectorElement := nil
  else if (isMatchingName(propName, 'collected', ['DateTime', 'Period'])) then CollectedElement := nil{4x}
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'method') then MethodElement := nil
  else if (propName = 'bodySite') then BodySiteElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSpecimenCollection.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'collector') then CollectorElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (isMatchingName(propName, 'collected', ['DateTime', 'Period'])) then CollectedElement := new as TFhirType{4x}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'method') then MethodElement := new as TFhirCodeableConcept{4}
  else if (propName = 'bodySite') then BodySiteElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSpecimenCollection.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSpecimenCollection.fhirType : string;
begin
  result := 'collection';
end;

function TFhirSpecimenCollection.Link : TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection(inherited Link);
end;

function TFhirSpecimenCollection.Clone : TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection(inherited Clone);
end;

function TFhirSpecimenCollection.equals(other : TObject) : boolean;
var
  o : TFhirSpecimenCollection;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSpecimenCollection)) then
    result := false
  else
  begin
    o := TFhirSpecimenCollection(other);
    result := compareDeep(collectorElement, o.collectorElement, true) and compareDeep(collectedElement, o.collectedElement, true) and
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(methodElement, o.methodElement, true) and
      compareDeep(bodySiteElement, o.bodySiteElement, true);
  end;
end;

function TFhirSpecimenCollection.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCollector) and isEmptyProp(FCollected) and isEmptyProp(FQuantity) and isEmptyProp(FMethod) and isEmptyProp(FBodySite);
end;

procedure TFhirSpecimenCollection.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('collector');
  fields.add('collected[x]');
  fields.add('quantity');
  fields.add('method');
  fields.add('bodySite');
end;

{ TFhirSpecimenCollection }

Procedure TFhirSpecimenCollection.SetCollector(value : TFhirReference{TFhirPractitioner});
begin
  FCollector.free;
  FCollector := value;
end;

Procedure TFhirSpecimenCollection.SetCollected(value : TFhirType);
begin
  FCollected.free;
  FCollected := value;
end;

Procedure TFhirSpecimenCollection.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirSpecimenCollection.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value;
end;

Procedure TFhirSpecimenCollection.SetBodySite(value : TFhirCodeableConcept);
begin
  FBodySite.free;
  FBodySite := value;
end;

function TFhirSpecimenCollection.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCollector.sizeInBytes);
  inc(result, FCollected.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FMethod.sizeInBytes);
  inc(result, FBodySite.sizeInBytes);
end;

{ TFhirSpecimenCollectionListEnumerator }

Constructor TFhirSpecimenCollectionListEnumerator.Create(list : TFhirSpecimenCollectionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSpecimenCollectionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSpecimenCollectionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSpecimenCollectionListEnumerator.GetCurrent : TFhirSpecimenCollection;
begin
  Result := FList[FIndex];
end;

function TFhirSpecimenCollectionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSpecimenCollectionList }
procedure TFhirSpecimenCollectionList.AddItem(value: TFhirSpecimenCollection);
begin
  assert(value.ClassName = 'TFhirSpecimenCollection', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSpecimenCollection');
  add(value);
end;

function TFhirSpecimenCollectionList.Append: TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSpecimenCollectionList.ClearItems;
begin
  Clear;
end;

function TFhirSpecimenCollectionList.GetEnumerator : TFhirSpecimenCollectionListEnumerator;
begin
  result := TFhirSpecimenCollectionListEnumerator.Create(self.link);
end;

function TFhirSpecimenCollectionList.Clone: TFhirSpecimenCollectionList;
begin
  result := TFhirSpecimenCollectionList(inherited Clone);
end;

function TFhirSpecimenCollectionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSpecimenCollectionList.GetItemN(index: Integer): TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection(ObjectByIndex[index]);
end;

function TFhirSpecimenCollectionList.ItemClass: TFslObjectClass;
begin
  result := TFhirSpecimenCollection;
end;
function TFhirSpecimenCollectionList.IndexOf(value: TFhirSpecimenCollection): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSpecimenCollectionList.Insert(index: Integer): TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSpecimenCollectionList.InsertItem(index: Integer; value: TFhirSpecimenCollection);
begin
  assert(value is TFhirSpecimenCollection);
  Inherited Insert(index, value);
end;

function TFhirSpecimenCollectionList.Item(index: Integer): TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection(ObjectByIndex[index]);
end;

function TFhirSpecimenCollectionList.Link: TFhirSpecimenCollectionList;
begin
  result := TFhirSpecimenCollectionList(inherited Link);
end;

procedure TFhirSpecimenCollectionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSpecimenCollectionList.SetItemByIndex(index: Integer; value: TFhirSpecimenCollection);
begin
  assert(value is TFhirSpecimenCollection);
  FhirSpecimenCollections[index] := value;
end;

procedure TFhirSpecimenCollectionList.SetItemN(index: Integer; value: TFhirSpecimenCollection);
begin
  assert(value is TFhirSpecimenCollection);
  ObjectByIndex[index] := value;
end;

{ TFhirSpecimenProcessing }

constructor TFhirSpecimenProcessing.Create;
begin
  inherited;
end;

destructor TFhirSpecimenProcessing.Destroy;
begin
  FDescription.free;
  FProcedure_.free;
  FAdditiveList.Free;
  FTime.free;
  inherited;
end;

procedure TFhirSpecimenProcessing.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirSpecimenProcessing(oSource).descriptionElement.Clone;
  procedure_ := TFhirSpecimenProcessing(oSource).procedure_.Clone;
  if (TFhirSpecimenProcessing(oSource).FAdditiveList = nil) then
  begin
    FAdditiveList.free;
    FAdditiveList := nil;
  end
  else
  begin
    if FAdditiveList = nil then
      FAdditiveList := TFhirReferenceList{TFhirSubstance}.Create;
    FAdditiveList.Assign(TFhirSpecimenProcessing(oSource).FAdditiveList);
  end;
  time := TFhirSpecimenProcessing(oSource).time.Clone;
end;

procedure TFhirSpecimenProcessing.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'procedure') Then
     list.add(self.link, 'procedure', FProcedure_.Link);
  if (child_name = 'additive') Then
    list.addAll(self, 'additive', FAdditiveList);
  if (child_name = 'time[x]') or (child_name = 'time') Then
     list.add(self.link, 'time[x]', FTime.Link);
end;

procedure TFhirSpecimenProcessing.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'procedure', 'CodeableConcept', false, TFhirCodeableConcept, FProcedure_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'additive', 'Reference(Substance)', true, TFhirReference{TFhirSubstance}, FAdditiveList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'time[x]', 'dateTime|Period', false, TFhirType, FTime.Link));{2}
end;

function TFhirSpecimenProcessing.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'procedure') then
  begin
    Procedure_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'additive') then
  begin
    AdditiveList.add(propValue as TFhirReference{TFhirSubstance}){2a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'time', ['DateTime', 'Period'])) then
  begin
    Time := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSpecimenProcessing.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'additive') then AdditiveList.insertItem(index, propValue as TFhirReference{TFhirSubstance}){2a}
  else inherited;
end;

function TFhirSpecimenProcessing.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'procedure') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'additive') then result := AdditiveList.new(){2}
  else if (isMatchingName(propName, 'time', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Time'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSpecimenProcessing.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'procedure') then result := 'CodeableConcept'
  else if (propName = 'additive') then result := 'Reference'
  else if (propName = 'time[x]') then result := 'dateTime|Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSpecimenProcessing.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'procedure') then Procedure_Element := nil
  else if (propName = 'additive') then deletePropertyValue('additive', AdditiveList, value) {2}
  else if (isMatchingName(propName, 'time', ['DateTime', 'Period'])) then TimeElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSpecimenProcessing.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'procedure') then Procedure_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'additive') then replacePropertyValue('additive', AdditiveList, existing, new) {2}
  else if (isMatchingName(propName, 'time', ['DateTime', 'Period'])) then TimeElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSpecimenProcessing.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'additive') then AdditiveList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSpecimenProcessing.fhirType : string;
begin
  result := 'processing';
end;

function TFhirSpecimenProcessing.Link : TFhirSpecimenProcessing;
begin
  result := TFhirSpecimenProcessing(inherited Link);
end;

function TFhirSpecimenProcessing.Clone : TFhirSpecimenProcessing;
begin
  result := TFhirSpecimenProcessing(inherited Clone);
end;

function TFhirSpecimenProcessing.equals(other : TObject) : boolean;
var
  o : TFhirSpecimenProcessing;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSpecimenProcessing)) then
    result := false
  else
  begin
    o := TFhirSpecimenProcessing(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(procedure_Element, o.procedure_Element, true) and
      compareDeep(additiveList, o.additiveList, true) and compareDeep(timeElement, o.timeElement, true);
  end;
end;

function TFhirSpecimenProcessing.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FProcedure_) and isEmptyProp(FadditiveList) and isEmptyProp(FTime);
end;

procedure TFhirSpecimenProcessing.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('description');
  fields.add('procedure');
  fields.add('additive');
  fields.add('time[x]');
end;

{ TFhirSpecimenProcessing }

Procedure TFhirSpecimenProcessing.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirSpecimenProcessing.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirSpecimenProcessing.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirSpecimenProcessing.SetProcedure_(value : TFhirCodeableConcept);
begin
  FProcedure_.free;
  FProcedure_ := value;
end;

Function TFhirSpecimenProcessing.GetAdditiveList : TFhirReferenceList{TFhirSubstance};
begin
  if FAdditiveList = nil then
    FAdditiveList := TFhirReferenceList{TFhirSubstance}.Create;
  result := FAdditiveList;
end;

Function TFhirSpecimenProcessing.GetHasAdditiveList : boolean;
begin
  result := (FAdditiveList <> nil) and (FAdditiveList.count > 0);
end;

Procedure TFhirSpecimenProcessing.SetTime(value : TFhirType);
begin
  FTime.free;
  FTime := value;
end;

function TFhirSpecimenProcessing.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDescription.sizeInBytes);
  inc(result, FProcedure_.sizeInBytes);
  inc(result, FadditiveList.sizeInBytes);
  inc(result, FTime.sizeInBytes);
end;

{ TFhirSpecimenProcessingListEnumerator }

Constructor TFhirSpecimenProcessingListEnumerator.Create(list : TFhirSpecimenProcessingList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSpecimenProcessingListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSpecimenProcessingListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSpecimenProcessingListEnumerator.GetCurrent : TFhirSpecimenProcessing;
begin
  Result := FList[FIndex];
end;

function TFhirSpecimenProcessingListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSpecimenProcessingList }
procedure TFhirSpecimenProcessingList.AddItem(value: TFhirSpecimenProcessing);
begin
  assert(value.ClassName = 'TFhirSpecimenProcessing', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSpecimenProcessing');
  add(value);
end;

function TFhirSpecimenProcessingList.Append: TFhirSpecimenProcessing;
begin
  result := TFhirSpecimenProcessing.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSpecimenProcessingList.ClearItems;
begin
  Clear;
end;

function TFhirSpecimenProcessingList.GetEnumerator : TFhirSpecimenProcessingListEnumerator;
begin
  result := TFhirSpecimenProcessingListEnumerator.Create(self.link);
end;

function TFhirSpecimenProcessingList.Clone: TFhirSpecimenProcessingList;
begin
  result := TFhirSpecimenProcessingList(inherited Clone);
end;

function TFhirSpecimenProcessingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSpecimenProcessingList.GetItemN(index: Integer): TFhirSpecimenProcessing;
begin
  result := TFhirSpecimenProcessing(ObjectByIndex[index]);
end;

function TFhirSpecimenProcessingList.ItemClass: TFslObjectClass;
begin
  result := TFhirSpecimenProcessing;
end;
function TFhirSpecimenProcessingList.IndexOf(value: TFhirSpecimenProcessing): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSpecimenProcessingList.Insert(index: Integer): TFhirSpecimenProcessing;
begin
  result := TFhirSpecimenProcessing.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSpecimenProcessingList.InsertItem(index: Integer; value: TFhirSpecimenProcessing);
begin
  assert(value is TFhirSpecimenProcessing);
  Inherited Insert(index, value);
end;

function TFhirSpecimenProcessingList.Item(index: Integer): TFhirSpecimenProcessing;
begin
  result := TFhirSpecimenProcessing(ObjectByIndex[index]);
end;

function TFhirSpecimenProcessingList.Link: TFhirSpecimenProcessingList;
begin
  result := TFhirSpecimenProcessingList(inherited Link);
end;

procedure TFhirSpecimenProcessingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSpecimenProcessingList.SetItemByIndex(index: Integer; value: TFhirSpecimenProcessing);
begin
  assert(value is TFhirSpecimenProcessing);
  FhirSpecimenProcessings[index] := value;
end;

procedure TFhirSpecimenProcessingList.SetItemN(index: Integer; value: TFhirSpecimenProcessing);
begin
  assert(value is TFhirSpecimenProcessing);
  ObjectByIndex[index] := value;
end;

{ TFhirSpecimenContainer }

constructor TFhirSpecimenContainer.Create;
begin
  inherited;
end;

destructor TFhirSpecimenContainer.Destroy;
begin
  FIdentifierList.Free;
  FDescription.free;
  FType_.free;
  FCapacity.free;
  FSpecimenQuantity.free;
  FAdditive.free;
  inherited;
end;

procedure TFhirSpecimenContainer.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirSpecimenContainer(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirSpecimenContainer(oSource).FIdentifierList);
  end;
  descriptionElement := TFhirSpecimenContainer(oSource).descriptionElement.Clone;
  type_ := TFhirSpecimenContainer(oSource).type_.Clone;
  capacity := TFhirSpecimenContainer(oSource).capacity.Clone;
  specimenQuantity := TFhirSpecimenContainer(oSource).specimenQuantity.Clone;
  additive := TFhirSpecimenContainer(oSource).additive.Clone;
end;

procedure TFhirSpecimenContainer.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'capacity') Then
     list.add(self.link, 'capacity', FCapacity.Link);
  if (child_name = 'specimenQuantity') Then
     list.add(self.link, 'specimenQuantity', FSpecimenQuantity.Link);
  if (child_name = 'additive[x]') or (child_name = 'additive') Then
     list.add(self.link, 'additive[x]', FAdditive.Link);
end;

procedure TFhirSpecimenContainer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'capacity', 'Quantity', false, TFhirQuantity, FCapacity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'specimenQuantity', 'Quantity', false, TFhirQuantity, FSpecimenQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'additive[x]', 'CodeableConcept|Reference(Substance)', false, TFhirType, FAdditive.Link));{2}
end;

function TFhirSpecimenContainer.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'capacity') then
  begin
    Capacity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'specimenQuantity') then
  begin
    SpecimenQuantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'additive', ['CodeableConcept', 'Reference'])) then
  begin
    Additive := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSpecimenContainer.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else inherited;
end;

function TFhirSpecimenContainer.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'capacity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'specimenQuantity') then result := TFhirQuantity.create(){4b}
  else if (isMatchingName(propName, 'additive', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Additive'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSpecimenContainer.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'capacity') then result := 'Quantity'
  else if (propName = 'specimenQuantity') then result := 'Quantity'
  else if (propName = 'additive[x]') then result := 'CodeableConcept|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSpecimenContainer.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'capacity') then CapacityElement := nil
  else if (propName = 'specimenQuantity') then SpecimenQuantityElement := nil
  else if (isMatchingName(propName, 'additive', ['CodeableConcept', 'Reference'])) then AdditiveElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSpecimenContainer.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'capacity') then CapacityElement := new as TFhirQuantity{4}
  else if (propName = 'specimenQuantity') then SpecimenQuantityElement := new as TFhirQuantity{4}
  else if (isMatchingName(propName, 'additive', ['CodeableConcept', 'Reference'])) then AdditiveElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSpecimenContainer.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSpecimenContainer.fhirType : string;
begin
  result := 'container';
end;

function TFhirSpecimenContainer.Link : TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer(inherited Link);
end;

function TFhirSpecimenContainer.Clone : TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer(inherited Clone);
end;

function TFhirSpecimenContainer.equals(other : TObject) : boolean;
var
  o : TFhirSpecimenContainer;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSpecimenContainer)) then
    result := false
  else
  begin
    o := TFhirSpecimenContainer(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(descriptionElement, o.descriptionElement, true) and
      compareDeep(type_Element, o.type_Element, true) and compareDeep(capacityElement, o.capacityElement, true) and
      compareDeep(specimenQuantityElement, o.specimenQuantityElement, true) and compareDeep(additiveElement, o.additiveElement, true);
  end;
end;

function TFhirSpecimenContainer.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FDescription) and isEmptyProp(FType_) and isEmptyProp(FCapacity) and isEmptyProp(FSpecimenQuantity) and isEmptyProp(FAdditive);
end;

procedure TFhirSpecimenContainer.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('description');
  fields.add('type');
  fields.add('capacity');
  fields.add('specimenQuantity');
  fields.add('additive[x]');
end;

{ TFhirSpecimenContainer }

Function TFhirSpecimenContainer.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirSpecimenContainer.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirSpecimenContainer.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirSpecimenContainer.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirSpecimenContainer.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirSpecimenContainer.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirSpecimenContainer.SetCapacity(value : TFhirQuantity);
begin
  FCapacity.free;
  FCapacity := value;
end;

Procedure TFhirSpecimenContainer.SetSpecimenQuantity(value : TFhirQuantity);
begin
  FSpecimenQuantity.free;
  FSpecimenQuantity := value;
end;

Procedure TFhirSpecimenContainer.SetAdditive(value : TFhirType);
begin
  FAdditive.free;
  FAdditive := value;
end;

function TFhirSpecimenContainer.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FCapacity.sizeInBytes);
  inc(result, FSpecimenQuantity.sizeInBytes);
  inc(result, FAdditive.sizeInBytes);
end;

{ TFhirSpecimenContainerListEnumerator }

Constructor TFhirSpecimenContainerListEnumerator.Create(list : TFhirSpecimenContainerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSpecimenContainerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSpecimenContainerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSpecimenContainerListEnumerator.GetCurrent : TFhirSpecimenContainer;
begin
  Result := FList[FIndex];
end;

function TFhirSpecimenContainerListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSpecimenContainerList }
procedure TFhirSpecimenContainerList.AddItem(value: TFhirSpecimenContainer);
begin
  assert(value.ClassName = 'TFhirSpecimenContainer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSpecimenContainer');
  add(value);
end;

function TFhirSpecimenContainerList.Append: TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSpecimenContainerList.ClearItems;
begin
  Clear;
end;

function TFhirSpecimenContainerList.GetEnumerator : TFhirSpecimenContainerListEnumerator;
begin
  result := TFhirSpecimenContainerListEnumerator.Create(self.link);
end;

function TFhirSpecimenContainerList.Clone: TFhirSpecimenContainerList;
begin
  result := TFhirSpecimenContainerList(inherited Clone);
end;

function TFhirSpecimenContainerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSpecimenContainerList.GetItemN(index: Integer): TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer(ObjectByIndex[index]);
end;

function TFhirSpecimenContainerList.ItemClass: TFslObjectClass;
begin
  result := TFhirSpecimenContainer;
end;
function TFhirSpecimenContainerList.IndexOf(value: TFhirSpecimenContainer): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSpecimenContainerList.Insert(index: Integer): TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSpecimenContainerList.InsertItem(index: Integer; value: TFhirSpecimenContainer);
begin
  assert(value is TFhirSpecimenContainer);
  Inherited Insert(index, value);
end;

function TFhirSpecimenContainerList.Item(index: Integer): TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer(ObjectByIndex[index]);
end;

function TFhirSpecimenContainerList.Link: TFhirSpecimenContainerList;
begin
  result := TFhirSpecimenContainerList(inherited Link);
end;

procedure TFhirSpecimenContainerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSpecimenContainerList.SetItemByIndex(index: Integer; value: TFhirSpecimenContainer);
begin
  assert(value is TFhirSpecimenContainer);
  FhirSpecimenContainers[index] := value;
end;

procedure TFhirSpecimenContainerList.SetItemN(index: Integer; value: TFhirSpecimenContainer);
begin
  assert(value is TFhirSpecimenContainer);
  ObjectByIndex[index] := value;
end;

{ TFhirSpecimen }

constructor TFhirSpecimen.Create;
begin
  inherited;
end;

destructor TFhirSpecimen.Destroy;
begin
  FIdentifierList.Free;
  FAccessionIdentifier.free;
  FStatus.free;
  FType_.free;
  FSubject.free;
  FReceivedTime.free;
  FParentList.Free;
  FRequestList.Free;
  FCollection.free;
  FProcessingList.Free;
  FContainerList.Free;
  FNoteList.Free;
  inherited;
end;

function TFhirSpecimen.GetResourceType : TFhirResourceType;
begin
  result := frtSpecimen;
end;

procedure TFhirSpecimen.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirSpecimen(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirSpecimen(oSource).FIdentifierList);
  end;
  accessionIdentifier := TFhirSpecimen(oSource).accessionIdentifier.Clone;
  FStatus := TFhirSpecimen(oSource).FStatus.Link;
  type_ := TFhirSpecimen(oSource).type_.Clone;
  subject := TFhirSpecimen(oSource).subject.Clone;
  receivedTimeElement := TFhirSpecimen(oSource).receivedTimeElement.Clone;
  if (TFhirSpecimen(oSource).FParentList = nil) then
  begin
    FParentList.free;
    FParentList := nil;
  end
  else
  begin
    if FParentList = nil then
      FParentList := TFhirReferenceList{TFhirSpecimen}.Create;
    FParentList.Assign(TFhirSpecimen(oSource).FParentList);
  end;
  if (TFhirSpecimen(oSource).FRequestList = nil) then
  begin
    FRequestList.free;
    FRequestList := nil;
  end
  else
  begin
    if FRequestList = nil then
      FRequestList := TFhirReferenceList{TFhirProcedureRequest}.Create;
    FRequestList.Assign(TFhirSpecimen(oSource).FRequestList);
  end;
  collection := TFhirSpecimen(oSource).collection.Clone;
  if (TFhirSpecimen(oSource).FProcessingList = nil) then
  begin
    FProcessingList.free;
    FProcessingList := nil;
  end
  else
  begin
    if FProcessingList = nil then
      FProcessingList := TFhirSpecimenProcessingList.Create;
    FProcessingList.Assign(TFhirSpecimen(oSource).FProcessingList);
  end;
  if (TFhirSpecimen(oSource).FContainerList = nil) then
  begin
    FContainerList.free;
    FContainerList := nil;
  end
  else
  begin
    if FContainerList = nil then
      FContainerList := TFhirSpecimenContainerList.Create;
    FContainerList.Assign(TFhirSpecimen(oSource).FContainerList);
  end;
  if (TFhirSpecimen(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirSpecimen(oSource).FNoteList);
  end;
end;

procedure TFhirSpecimen.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'accessionIdentifier') Then
     list.add(self.link, 'accessionIdentifier', FAccessionIdentifier.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'receivedTime') Then
     list.add(self.link, 'receivedTime', FReceivedTime.Link);
  if (child_name = 'parent') Then
    list.addAll(self, 'parent', FParentList);
  if (child_name = 'request') Then
    list.addAll(self, 'request', FRequestList);
  if (child_name = 'collection') Then
     list.add(self.link, 'collection', FCollection.Link);
  if (child_name = 'processing') Then
    list.addAll(self, 'processing', FProcessingList);
  if (child_name = 'container') Then
    list.addAll(self, 'container', FContainerList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirSpecimen.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'accessionIdentifier', 'Identifier', false, TFhirIdentifier, FAccessionIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Group|Device|Substance)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'receivedTime', 'dateTime', false, TFhirDateTime, FReceivedTime.Link));{2}
  oList.add(TFHIRProperty.create(self, 'parent', 'Reference(Specimen)', true, TFhirReference{TFhirSpecimen}, FParentList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'request', 'Reference(ProcedureRequest)', true, TFhirReference{TFhirProcedureRequest}, FRequestList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'collection', '', false, TFhirSpecimenCollection, FCollection.Link));{2}
  oList.add(TFHIRProperty.create(self, 'processing', '', true, TFhirSpecimenProcessing, FProcessingList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'container', '', true, TFhirSpecimenContainer, FContainerList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
end;

function TFhirSpecimen.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'accessionIdentifier') then
  begin
    AccessionIdentifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirSpecimenStatusEnum, CODES_TFhirSpecimenStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'receivedTime') then
  begin
    ReceivedTimeElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'parent') then
  begin
    ParentList.add(propValue as TFhirReference{TFhirSpecimen}){2a};
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    RequestList.add(propValue as TFhirReference{TFhirProcedureRequest}){2a};
    result := propValue;
  end
  else if (propName = 'collection') then
  begin
    Collection := propValue as TFhirSpecimenCollection{4b};
    result := propValue;
  end
  else if (propName = 'processing') then
  begin
    ProcessingList.add(propValue as TFhirSpecimenProcessing){2a};
    result := propValue;
  end
  else if (propName = 'container') then
  begin
    ContainerList.add(propValue as TFhirSpecimenContainer){2a};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirSpecimen.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'parent') then ParentList.insertItem(index, propValue as TFhirReference{TFhirSpecimen}){2a}
  else if (propName = 'request') then RequestList.insertItem(index, propValue as TFhirReference{TFhirProcedureRequest}){2a}
  else if (propName = 'processing') then ProcessingList.insertItem(index, propValue as TFhirSpecimenProcessing){2a}
  else if (propName = 'container') then ContainerList.insertItem(index, propValue as TFhirSpecimenContainer){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else inherited;
end;

function TFhirSpecimen.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'accessionIdentifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'receivedTime') then result := TFhirDateTime.create() {5b}
  else if (propName = 'parent') then result := ParentList.new(){2}
  else if (propName = 'request') then result := RequestList.new(){2}
  else if (propName = 'collection') then result := TFhirSpecimenCollection.create(){4b}
  else if (propName = 'processing') then result := ProcessingList.new(){2}
  else if (propName = 'container') then result := ContainerList.new(){2}
  else if (propName = 'note') then result := NoteList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSpecimen.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'accessionIdentifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'receivedTime') then result := 'dateTime'
  else if (propName = 'parent') then result := 'Reference'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'collection') then result := ''
  else if (propName = 'processing') then result := ''
  else if (propName = 'container') then result := ''
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSpecimen.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'accessionIdentifier') then AccessionIdentifierElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'receivedTime') then ReceivedTimeElement := nil
  else if (propName = 'parent') then deletePropertyValue('parent', ParentList, value) {2}
  else if (propName = 'request') then deletePropertyValue('request', RequestList, value) {2}
  else if (propName = 'collection') then CollectionElement := nil
  else if (propName = 'processing') then deletePropertyValue('processing', ProcessingList, value) {2}
  else if (propName = 'container') then deletePropertyValue('container', ContainerList, value) {2}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSpecimen.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'accessionIdentifier') then AccessionIdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirSpecimenStatusEnum, CODES_TFhirSpecimenStatusEnum, new){4}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'receivedTime') then ReceivedTimeElement := asDateTime(new){5b}
  else if (propName = 'parent') then replacePropertyValue('parent', ParentList, existing, new) {2}
  else if (propName = 'request') then replacePropertyValue('request', RequestList, existing, new) {2}
  else if (propName = 'collection') then CollectionElement := new as TFhirSpecimenCollection{4}
  else if (propName = 'processing') then replacePropertyValue('processing', ProcessingList, existing, new) {2}
  else if (propName = 'container') then replacePropertyValue('container', ContainerList, existing, new) {2}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSpecimen.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'parent') then ParentList.move(source, destination){2a}
  else if (propName = 'request') then RequestList.move(source, destination){2a}
  else if (propName = 'processing') then ProcessingList.move(source, destination){2a}
  else if (propName = 'container') then ContainerList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSpecimen.fhirType : string;
begin
  result := 'Specimen';
end;

function TFhirSpecimen.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FAccessionIdentifier) and isEmptyProp(FStatus) and isEmptyProp(FType_) and isEmptyProp(FSubject) and isEmptyProp(FReceivedTime) and isEmptyProp(FparentList) and isEmptyProp(FrequestList) and isEmptyProp(FCollection) and isEmptyProp(FprocessingList) and isEmptyProp(FcontainerList) and isEmptyProp(FnoteList);
end;

function TFhirSpecimen.equals(other : TObject) : boolean;
var
  o : TFhirSpecimen;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSpecimen)) then
    result := false
  else
  begin
    o := TFhirSpecimen(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(accessionIdentifierElement, o.accessionIdentifierElement, true) and
      compareDeep(statusElement, o.statusElement, true) and compareDeep(type_Element, o.type_Element, true) and
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(receivedTimeElement, o.receivedTimeElement, true) and
      compareDeep(parentList, o.parentList, true) and compareDeep(requestList, o.requestList, true) and
      compareDeep(collectionElement, o.collectionElement, true) and compareDeep(processingList, o.processingList, true) and
      compareDeep(containerList, o.containerList, true) and compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirSpecimen.Link : TFhirSpecimen;
begin
  result := TFhirSpecimen(inherited Link);
end;

function TFhirSpecimen.Clone : TFhirSpecimen;
begin
  result := TFhirSpecimen(inherited Clone);
end;

procedure TFhirSpecimen.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('accessionIdentifier');
  fields.add('status');
  fields.add('type');
  fields.add('subject');
  fields.add('receivedTime');
  fields.add('parent');
  fields.add('request');
  fields.add('collection');
  fields.add('processing');
  fields.add('container');
  fields.add('note');
end;

{ TFhirSpecimen }

Function TFhirSpecimen.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirSpecimen.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirSpecimen.SetAccessionIdentifier(value : TFhirIdentifier);
begin
  FAccessionIdentifier.free;
  FAccessionIdentifier := value;
end;

Procedure TFhirSpecimen.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirSpecimen.GetStatusST : TFhirSpecimenStatusEnum;
begin
  if FStatus = nil then
    result := TFhirSpecimenStatusEnum(0)
  else
    result := TFhirSpecimenStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirSpecimenStatusEnum, FStatus.value));
end;

Procedure TFhirSpecimen.SetStatusST(value : TFhirSpecimenStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirSpecimenStatusEnum[value], CODES_TFhirSpecimenStatusEnum[value]);
end;

Procedure TFhirSpecimen.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirSpecimen.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirSpecimen.SetReceivedTime(value : TFhirDateTime);
begin
  FReceivedTime.free;
  FReceivedTime := value;
end;

Function TFhirSpecimen.GetReceivedTimeST : TFslDateTime;
begin
  if FReceivedTime = nil then
    result := TFslDateTime.makeNull
  else
    result := FReceivedTime.value;
end;

Procedure TFhirSpecimen.SetReceivedTimeST(value : TFslDateTime);
begin
  if FReceivedTime = nil then
    FReceivedTime := TFhirDateTime.create;
  FReceivedTime.value := value
end;

Function TFhirSpecimen.GetParentList : TFhirReferenceList{TFhirSpecimen};
begin
  if FParentList = nil then
    FParentList := TFhirReferenceList{TFhirSpecimen}.Create;
  result := FParentList;
end;

Function TFhirSpecimen.GetHasParentList : boolean;
begin
  result := (FParentList <> nil) and (FParentList.count > 0);
end;

Function TFhirSpecimen.GetRequestList : TFhirReferenceList{TFhirProcedureRequest};
begin
  if FRequestList = nil then
    FRequestList := TFhirReferenceList{TFhirProcedureRequest}.Create;
  result := FRequestList;
end;

Function TFhirSpecimen.GetHasRequestList : boolean;
begin
  result := (FRequestList <> nil) and (FRequestList.count > 0);
end;

Procedure TFhirSpecimen.SetCollection(value : TFhirSpecimenCollection);
begin
  FCollection.free;
  FCollection := value;
end;

Function TFhirSpecimen.GetProcessingList : TFhirSpecimenProcessingList;
begin
  if FProcessingList = nil then
    FProcessingList := TFhirSpecimenProcessingList.Create;
  result := FProcessingList;
end;

Function TFhirSpecimen.GetHasProcessingList : boolean;
begin
  result := (FProcessingList <> nil) and (FProcessingList.count > 0);
end;

Function TFhirSpecimen.GetContainerList : TFhirSpecimenContainerList;
begin
  if FContainerList = nil then
    FContainerList := TFhirSpecimenContainerList.Create;
  result := FContainerList;
end;

Function TFhirSpecimen.GetHasContainerList : boolean;
begin
  result := (FContainerList <> nil) and (FContainerList.count > 0);
end;

Function TFhirSpecimen.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirSpecimen.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirSpecimen.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FAccessionIdentifier.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FReceivedTime.sizeInBytes);
  inc(result, FparentList.sizeInBytes);
  inc(result, FrequestList.sizeInBytes);
  inc(result, FCollection.sizeInBytes);
  inc(result, FprocessingList.sizeInBytes);
  inc(result, FcontainerList.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
end;

{ TFhirSpecimenListEnumerator }

Constructor TFhirSpecimenListEnumerator.Create(list : TFhirSpecimenList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSpecimenListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSpecimenListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSpecimenListEnumerator.GetCurrent : TFhirSpecimen;
begin
  Result := FList[FIndex];
end;

function TFhirSpecimenListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSpecimenList }
procedure TFhirSpecimenList.AddItem(value: TFhirSpecimen);
begin
  assert(value.ClassName = 'TFhirSpecimen', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSpecimen');
  add(value);
end;

function TFhirSpecimenList.Append: TFhirSpecimen;
begin
  result := TFhirSpecimen.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSpecimenList.ClearItems;
begin
  Clear;
end;

function TFhirSpecimenList.GetEnumerator : TFhirSpecimenListEnumerator;
begin
  result := TFhirSpecimenListEnumerator.Create(self.link);
end;

function TFhirSpecimenList.Clone: TFhirSpecimenList;
begin
  result := TFhirSpecimenList(inherited Clone);
end;

function TFhirSpecimenList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSpecimenList.GetItemN(index: Integer): TFhirSpecimen;
begin
  result := TFhirSpecimen(ObjectByIndex[index]);
end;

function TFhirSpecimenList.ItemClass: TFslObjectClass;
begin
  result := TFhirSpecimen;
end;
function TFhirSpecimenList.IndexOf(value: TFhirSpecimen): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSpecimenList.Insert(index: Integer): TFhirSpecimen;
begin
  result := TFhirSpecimen.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSpecimenList.InsertItem(index: Integer; value: TFhirSpecimen);
begin
  assert(value is TFhirSpecimen);
  Inherited Insert(index, value);
end;

function TFhirSpecimenList.Item(index: Integer): TFhirSpecimen;
begin
  result := TFhirSpecimen(ObjectByIndex[index]);
end;

function TFhirSpecimenList.Link: TFhirSpecimenList;
begin
  result := TFhirSpecimenList(inherited Link);
end;

procedure TFhirSpecimenList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSpecimenList.SetItemByIndex(index: Integer; value: TFhirSpecimen);
begin
  assert(value is TFhirSpecimen);
  FhirSpecimen[index] := value;
end;

procedure TFhirSpecimenList.SetItemN(index: Integer; value: TFhirSpecimen);
begin
  assert(value is TFhirSpecimen);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SPECIMEN}

{$IFDEF FHIR_SUPPLYDELIVERY}

{ TFhirSupplyDeliverySuppliedItem }

constructor TFhirSupplyDeliverySuppliedItem.Create;
begin
  inherited;
end;

destructor TFhirSupplyDeliverySuppliedItem.Destroy;
begin
  FQuantity.free;
  FItem.free;
  inherited;
end;

procedure TFhirSupplyDeliverySuppliedItem.Assign(oSource : TFslObject);
begin
  inherited;
  quantity := TFhirSupplyDeliverySuppliedItem(oSource).quantity.Clone;
  item := TFhirSupplyDeliverySuppliedItem(oSource).item.Clone;
end;

procedure TFhirSupplyDeliverySuppliedItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'item[x]') or (child_name = 'item') Then
     list.add(self.link, 'item[x]', FItem.Link);
end;

procedure TFhirSupplyDeliverySuppliedItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'item[x]', 'CodeableConcept|Reference(Medication|Substance|Device)', false, TFhirType, FItem.Link));{2}
end;

function TFhirSupplyDeliverySuppliedItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then
  begin
    Item := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSupplyDeliverySuppliedItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSupplyDeliverySuppliedItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Item'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSupplyDeliverySuppliedItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'item[x]') then result := 'CodeableConcept|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSupplyDeliverySuppliedItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'quantity') then QuantityElement := nil
  else if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then ItemElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSupplyDeliverySuppliedItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then ItemElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSupplyDeliverySuppliedItem.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSupplyDeliverySuppliedItem.fhirType : string;
begin
  result := 'suppliedItem';
end;

function TFhirSupplyDeliverySuppliedItem.Link : TFhirSupplyDeliverySuppliedItem;
begin
  result := TFhirSupplyDeliverySuppliedItem(inherited Link);
end;

function TFhirSupplyDeliverySuppliedItem.Clone : TFhirSupplyDeliverySuppliedItem;
begin
  result := TFhirSupplyDeliverySuppliedItem(inherited Clone);
end;

function TFhirSupplyDeliverySuppliedItem.equals(other : TObject) : boolean;
var
  o : TFhirSupplyDeliverySuppliedItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSupplyDeliverySuppliedItem)) then
    result := false
  else
  begin
    o := TFhirSupplyDeliverySuppliedItem(other);
    result := compareDeep(quantityElement, o.quantityElement, true) and compareDeep(itemElement, o.itemElement, true);
  end;
end;

function TFhirSupplyDeliverySuppliedItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FQuantity) and isEmptyProp(FItem);
end;

procedure TFhirSupplyDeliverySuppliedItem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('quantity');
  fields.add('item[x]');
end;

{ TFhirSupplyDeliverySuppliedItem }

Procedure TFhirSupplyDeliverySuppliedItem.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirSupplyDeliverySuppliedItem.SetItem(value : TFhirType);
begin
  FItem.free;
  FItem := value;
end;

function TFhirSupplyDeliverySuppliedItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FQuantity.sizeInBytes);
  inc(result, FItem.sizeInBytes);
end;

{ TFhirSupplyDeliverySuppliedItemListEnumerator }

Constructor TFhirSupplyDeliverySuppliedItemListEnumerator.Create(list : TFhirSupplyDeliverySuppliedItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSupplyDeliverySuppliedItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSupplyDeliverySuppliedItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSupplyDeliverySuppliedItemListEnumerator.GetCurrent : TFhirSupplyDeliverySuppliedItem;
begin
  Result := FList[FIndex];
end;

function TFhirSupplyDeliverySuppliedItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSupplyDeliverySuppliedItemList }
procedure TFhirSupplyDeliverySuppliedItemList.AddItem(value: TFhirSupplyDeliverySuppliedItem);
begin
  assert(value.ClassName = 'TFhirSupplyDeliverySuppliedItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSupplyDeliverySuppliedItem');
  add(value);
end;

function TFhirSupplyDeliverySuppliedItemList.Append: TFhirSupplyDeliverySuppliedItem;
begin
  result := TFhirSupplyDeliverySuppliedItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSupplyDeliverySuppliedItemList.ClearItems;
begin
  Clear;
end;

function TFhirSupplyDeliverySuppliedItemList.GetEnumerator : TFhirSupplyDeliverySuppliedItemListEnumerator;
begin
  result := TFhirSupplyDeliverySuppliedItemListEnumerator.Create(self.link);
end;

function TFhirSupplyDeliverySuppliedItemList.Clone: TFhirSupplyDeliverySuppliedItemList;
begin
  result := TFhirSupplyDeliverySuppliedItemList(inherited Clone);
end;

function TFhirSupplyDeliverySuppliedItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSupplyDeliverySuppliedItemList.GetItemN(index: Integer): TFhirSupplyDeliverySuppliedItem;
begin
  result := TFhirSupplyDeliverySuppliedItem(ObjectByIndex[index]);
end;

function TFhirSupplyDeliverySuppliedItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirSupplyDeliverySuppliedItem;
end;
function TFhirSupplyDeliverySuppliedItemList.IndexOf(value: TFhirSupplyDeliverySuppliedItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSupplyDeliverySuppliedItemList.Insert(index: Integer): TFhirSupplyDeliverySuppliedItem;
begin
  result := TFhirSupplyDeliverySuppliedItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSupplyDeliverySuppliedItemList.InsertItem(index: Integer; value: TFhirSupplyDeliverySuppliedItem);
begin
  assert(value is TFhirSupplyDeliverySuppliedItem);
  Inherited Insert(index, value);
end;

function TFhirSupplyDeliverySuppliedItemList.Item(index: Integer): TFhirSupplyDeliverySuppliedItem;
begin
  result := TFhirSupplyDeliverySuppliedItem(ObjectByIndex[index]);
end;

function TFhirSupplyDeliverySuppliedItemList.Link: TFhirSupplyDeliverySuppliedItemList;
begin
  result := TFhirSupplyDeliverySuppliedItemList(inherited Link);
end;

procedure TFhirSupplyDeliverySuppliedItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSupplyDeliverySuppliedItemList.SetItemByIndex(index: Integer; value: TFhirSupplyDeliverySuppliedItem);
begin
  assert(value is TFhirSupplyDeliverySuppliedItem);
  FhirSupplyDeliverySuppliedItems[index] := value;
end;

procedure TFhirSupplyDeliverySuppliedItemList.SetItemN(index: Integer; value: TFhirSupplyDeliverySuppliedItem);
begin
  assert(value is TFhirSupplyDeliverySuppliedItem);
  ObjectByIndex[index] := value;
end;

{ TFhirSupplyDelivery }

constructor TFhirSupplyDelivery.Create;
begin
  inherited;
end;

destructor TFhirSupplyDelivery.Destroy;
begin
  FIdentifier.free;
  FBasedOnList.Free;
  FPartOfList.Free;
  FStatus.free;
  FPatient.free;
  FType_.free;
  FSuppliedItem.free;
  FOccurrence.free;
  FSupplier.free;
  FDestination.free;
  FReceiverList.Free;
  inherited;
end;

function TFhirSupplyDelivery.GetResourceType : TFhirResourceType;
begin
  result := frtSupplyDelivery;
end;

procedure TFhirSupplyDelivery.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirSupplyDelivery(oSource).identifier.Clone;
  if (TFhirSupplyDelivery(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList{TFhirSupplyRequest}.Create;
    FBasedOnList.Assign(TFhirSupplyDelivery(oSource).FBasedOnList);
  end;
  if (TFhirSupplyDelivery(oSource).FPartOfList = nil) then
  begin
    FPartOfList.free;
    FPartOfList := nil;
  end
  else
  begin
    if FPartOfList = nil then
      FPartOfList := TFhirReferenceList{Resource}.Create;
    FPartOfList.Assign(TFhirSupplyDelivery(oSource).FPartOfList);
  end;
  FStatus := TFhirSupplyDelivery(oSource).FStatus.Link;
  patient := TFhirSupplyDelivery(oSource).patient.Clone;
  type_ := TFhirSupplyDelivery(oSource).type_.Clone;
  suppliedItem := TFhirSupplyDelivery(oSource).suppliedItem.Clone;
  occurrence := TFhirSupplyDelivery(oSource).occurrence.Clone;
  supplier := TFhirSupplyDelivery(oSource).supplier.Clone;
  destination := TFhirSupplyDelivery(oSource).destination.Clone;
  if (TFhirSupplyDelivery(oSource).FReceiverList = nil) then
  begin
    FReceiverList.free;
    FReceiverList := nil;
  end
  else
  begin
    if FReceiverList = nil then
      FReceiverList := TFhirReferenceList{TFhirPractitioner}.Create;
    FReceiverList.Assign(TFhirSupplyDelivery(oSource).FReceiverList);
  end;
end;

procedure TFhirSupplyDelivery.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'partOf') Then
    list.addAll(self, 'partOf', FPartOfList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'suppliedItem') Then
     list.add(self.link, 'suppliedItem', FSuppliedItem.Link);
  if (child_name = 'occurrence[x]') or (child_name = 'occurrence') Then
     list.add(self.link, 'occurrence[x]', FOccurrence.Link);
  if (child_name = 'supplier') Then
     list.add(self.link, 'supplier', FSupplier.Link);
  if (child_name = 'destination') Then
     list.add(self.link, 'destination', FDestination.Link);
  if (child_name = 'receiver') Then
    list.addAll(self, 'receiver', FReceiverList);
end;

procedure TFhirSupplyDelivery.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference(SupplyRequest)', true, TFhirReference{TFhirSupplyRequest}, FBasedOnList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference(SupplyDelivery|Contract)', true, TFhirReference{Resource}, FPartOfList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'suppliedItem', '', false, TFhirSupplyDeliverySuppliedItem, FSuppliedItem.Link));{2}
  oList.add(TFHIRProperty.create(self, 'occurrence[x]', 'dateTime|Period|Timing', false, TFhirType, FOccurrence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'supplier', 'Reference(Practitioner|Organization)', false, TFhirReference{Resource}, FSupplier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'destination', 'Reference(Location)', false, TFhirReference{TFhirLocation}, FDestination.Link));{2}
  oList.add(TFHIRProperty.create(self, 'receiver', 'Reference(Practitioner)', true, TFhirReference{TFhirPractitioner}, FReceiverList.Link)){3};
end;

function TFhirSupplyDelivery.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference{TFhirSupplyRequest}){2a};
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOfList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirSupplydeliveryStatusEnum, CODES_TFhirSupplydeliveryStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'suppliedItem') then
  begin
    SuppliedItem := propValue as TFhirSupplyDeliverySuppliedItem{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then
  begin
    Occurrence := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'supplier') then
  begin
    Supplier := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'destination') then
  begin
    Destination := propValue as TFhirReference{TFhirLocation}{4b};
    result := propValue;
  end
  else if (propName = 'receiver') then
  begin
    ReceiverList.add(propValue as TFhirReference{TFhirPractitioner}){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirSupplyDelivery.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference{TFhirSupplyRequest}){2a}
  else if (propName = 'partOf') then PartOfList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'receiver') then ReceiverList.insertItem(index, propValue as TFhirReference{TFhirPractitioner}){2a}
  else inherited;
end;

function TFhirSupplyDelivery.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'basedOn') then result := BasedOnList.new(){2}
  else if (propName = 'partOf') then result := PartOfList.new(){2}
  else if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'suppliedItem') then result := TFhirSupplyDeliverySuppliedItem.create(){4b}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then raise EFHIRException.create('Cannot make property Occurrence'){4x}
  else if (propName = 'supplier') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'destination') then result := TFhirReference{TFhirLocation}.create(){4b}
  else if (propName = 'receiver') then result := ReceiverList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSupplyDelivery.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'suppliedItem') then result := ''
  else if (propName = 'occurrence[x]') then result := 'dateTime|Period|Timing'
  else if (propName = 'supplier') then result := 'Reference'
  else if (propName = 'destination') then result := 'Reference'
  else if (propName = 'receiver') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSupplyDelivery.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value) {2}
  else if (propName = 'partOf') then deletePropertyValue('partOf', PartOfList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'suppliedItem') then SuppliedItemElement := nil
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then OccurrenceElement := nil{4x}
  else if (propName = 'supplier') then SupplierElement := nil
  else if (propName = 'destination') then DestinationElement := nil
  else if (propName = 'receiver') then deletePropertyValue('receiver', ReceiverList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSupplyDelivery.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new) {2}
  else if (propName = 'partOf') then replacePropertyValue('partOf', PartOfList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirSupplydeliveryStatusEnum, CODES_TFhirSupplydeliveryStatusEnum, new){4}
  else if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'suppliedItem') then SuppliedItemElement := new as TFhirSupplyDeliverySuppliedItem{4}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then OccurrenceElement := new as TFhirType{4x}
  else if (propName = 'supplier') then SupplierElement := new as TFhirReference{Resource}{4}
  else if (propName = 'destination') then DestinationElement := new as TFhirReference{TFhirLocation}{4}
  else if (propName = 'receiver') then replacePropertyValue('receiver', ReceiverList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSupplyDelivery.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'basedOn') then BasedOnList.move(source, destination){2a}
  else if (propName = 'partOf') then PartOfList.move(source, destination){2a}
  else if (propName = 'receiver') then ReceiverList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSupplyDelivery.fhirType : string;
begin
  result := 'SupplyDelivery';
end;

function TFhirSupplyDelivery.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FbasedOnList) and isEmptyProp(FpartOfList) and isEmptyProp(FStatus) and isEmptyProp(FPatient) and isEmptyProp(FType_) and isEmptyProp(FSuppliedItem) and isEmptyProp(FOccurrence) and isEmptyProp(FSupplier) and isEmptyProp(FDestination) and isEmptyProp(FreceiverList);
end;

function TFhirSupplyDelivery.equals(other : TObject) : boolean;
var
  o : TFhirSupplyDelivery;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSupplyDelivery)) then
    result := false
  else
  begin
    o := TFhirSupplyDelivery(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(basedOnList, o.basedOnList, true) and
      compareDeep(partOfList, o.partOfList, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(patientElement, o.patientElement, true) and compareDeep(type_Element, o.type_Element, true) and
      compareDeep(suppliedItemElement, o.suppliedItemElement, true) and compareDeep(occurrenceElement, o.occurrenceElement, true) and
      compareDeep(supplierElement, o.supplierElement, true) and compareDeep(destinationElement, o.destinationElement, true) and
      compareDeep(receiverList, o.receiverList, true);
  end;
end;

function TFhirSupplyDelivery.Link : TFhirSupplyDelivery;
begin
  result := TFhirSupplyDelivery(inherited Link);
end;

function TFhirSupplyDelivery.Clone : TFhirSupplyDelivery;
begin
  result := TFhirSupplyDelivery(inherited Clone);
end;

procedure TFhirSupplyDelivery.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('basedOn');
  fields.add('partOf');
  fields.add('status');
  fields.add('patient');
  fields.add('type');
  fields.add('suppliedItem');
  fields.add('occurrence[x]');
  fields.add('supplier');
  fields.add('destination');
  fields.add('receiver');
end;

{ TFhirSupplyDelivery }

Procedure TFhirSupplyDelivery.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Function TFhirSupplyDelivery.GetBasedOnList : TFhirReferenceList{TFhirSupplyRequest};
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList{TFhirSupplyRequest}.Create;
  result := FBasedOnList;
end;

Function TFhirSupplyDelivery.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

Function TFhirSupplyDelivery.GetPartOfList : TFhirReferenceList{Resource};
begin
  if FPartOfList = nil then
    FPartOfList := TFhirReferenceList{Resource}.Create;
  result := FPartOfList;
end;

Function TFhirSupplyDelivery.GetHasPartOfList : boolean;
begin
  result := (FPartOfList <> nil) and (FPartOfList.count > 0);
end;

Procedure TFhirSupplyDelivery.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirSupplyDelivery.GetStatusST : TFhirSupplydeliveryStatusEnum;
begin
  if FStatus = nil then
    result := TFhirSupplydeliveryStatusEnum(0)
  else
    result := TFhirSupplydeliveryStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirSupplydeliveryStatusEnum, FStatus.value));
end;

Procedure TFhirSupplyDelivery.SetStatusST(value : TFhirSupplydeliveryStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirSupplydeliveryStatusEnum[value], CODES_TFhirSupplydeliveryStatusEnum[value]);
end;

Procedure TFhirSupplyDelivery.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Procedure TFhirSupplyDelivery.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirSupplyDelivery.SetSuppliedItem(value : TFhirSupplyDeliverySuppliedItem);
begin
  FSuppliedItem.free;
  FSuppliedItem := value;
end;

Procedure TFhirSupplyDelivery.SetOccurrence(value : TFhirType);
begin
  FOccurrence.free;
  FOccurrence := value;
end;

Procedure TFhirSupplyDelivery.SetSupplier(value : TFhirReference{Resource});
begin
  FSupplier.free;
  FSupplier := value;
end;

Procedure TFhirSupplyDelivery.SetDestination(value : TFhirReference{TFhirLocation});
begin
  FDestination.free;
  FDestination := value;
end;

Function TFhirSupplyDelivery.GetReceiverList : TFhirReferenceList{TFhirPractitioner};
begin
  if FReceiverList = nil then
    FReceiverList := TFhirReferenceList{TFhirPractitioner}.Create;
  result := FReceiverList;
end;

Function TFhirSupplyDelivery.GetHasReceiverList : boolean;
begin
  result := (FReceiverList <> nil) and (FReceiverList.count > 0);
end;

function TFhirSupplyDelivery.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FbasedOnList.sizeInBytes);
  inc(result, FpartOfList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FSuppliedItem.sizeInBytes);
  inc(result, FOccurrence.sizeInBytes);
  inc(result, FSupplier.sizeInBytes);
  inc(result, FDestination.sizeInBytes);
  inc(result, FreceiverList.sizeInBytes);
end;

{ TFhirSupplyDeliveryListEnumerator }

Constructor TFhirSupplyDeliveryListEnumerator.Create(list : TFhirSupplyDeliveryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSupplyDeliveryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSupplyDeliveryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSupplyDeliveryListEnumerator.GetCurrent : TFhirSupplyDelivery;
begin
  Result := FList[FIndex];
end;

function TFhirSupplyDeliveryListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSupplyDeliveryList }
procedure TFhirSupplyDeliveryList.AddItem(value: TFhirSupplyDelivery);
begin
  assert(value.ClassName = 'TFhirSupplyDelivery', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSupplyDelivery');
  add(value);
end;

function TFhirSupplyDeliveryList.Append: TFhirSupplyDelivery;
begin
  result := TFhirSupplyDelivery.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSupplyDeliveryList.ClearItems;
begin
  Clear;
end;

function TFhirSupplyDeliveryList.GetEnumerator : TFhirSupplyDeliveryListEnumerator;
begin
  result := TFhirSupplyDeliveryListEnumerator.Create(self.link);
end;

function TFhirSupplyDeliveryList.Clone: TFhirSupplyDeliveryList;
begin
  result := TFhirSupplyDeliveryList(inherited Clone);
end;

function TFhirSupplyDeliveryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSupplyDeliveryList.GetItemN(index: Integer): TFhirSupplyDelivery;
begin
  result := TFhirSupplyDelivery(ObjectByIndex[index]);
end;

function TFhirSupplyDeliveryList.ItemClass: TFslObjectClass;
begin
  result := TFhirSupplyDelivery;
end;
function TFhirSupplyDeliveryList.IndexOf(value: TFhirSupplyDelivery): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSupplyDeliveryList.Insert(index: Integer): TFhirSupplyDelivery;
begin
  result := TFhirSupplyDelivery.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSupplyDeliveryList.InsertItem(index: Integer; value: TFhirSupplyDelivery);
begin
  assert(value is TFhirSupplyDelivery);
  Inherited Insert(index, value);
end;

function TFhirSupplyDeliveryList.Item(index: Integer): TFhirSupplyDelivery;
begin
  result := TFhirSupplyDelivery(ObjectByIndex[index]);
end;

function TFhirSupplyDeliveryList.Link: TFhirSupplyDeliveryList;
begin
  result := TFhirSupplyDeliveryList(inherited Link);
end;

procedure TFhirSupplyDeliveryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSupplyDeliveryList.SetItemByIndex(index: Integer; value: TFhirSupplyDelivery);
begin
  assert(value is TFhirSupplyDelivery);
  FhirSupplyDeliveries[index] := value;
end;

procedure TFhirSupplyDeliveryList.SetItemN(index: Integer; value: TFhirSupplyDelivery);
begin
  assert(value is TFhirSupplyDelivery);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SUPPLYDELIVERY}

{$IFDEF FHIR_SUPPLYREQUEST}

{ TFhirSupplyRequestOrderedItem }

constructor TFhirSupplyRequestOrderedItem.Create;
begin
  inherited;
end;

destructor TFhirSupplyRequestOrderedItem.Destroy;
begin
  FQuantity.free;
  FItem.free;
  inherited;
end;

procedure TFhirSupplyRequestOrderedItem.Assign(oSource : TFslObject);
begin
  inherited;
  quantity := TFhirSupplyRequestOrderedItem(oSource).quantity.Clone;
  item := TFhirSupplyRequestOrderedItem(oSource).item.Clone;
end;

procedure TFhirSupplyRequestOrderedItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'item[x]') or (child_name = 'item') Then
     list.add(self.link, 'item[x]', FItem.Link);
end;

procedure TFhirSupplyRequestOrderedItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'item[x]', 'CodeableConcept|Reference(Medication|Substance|Device)', false, TFhirType, FItem.Link));{2}
end;

function TFhirSupplyRequestOrderedItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then
  begin
    Item := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSupplyRequestOrderedItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSupplyRequestOrderedItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Item'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSupplyRequestOrderedItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'item[x]') then result := 'CodeableConcept|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSupplyRequestOrderedItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'quantity') then QuantityElement := nil
  else if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then ItemElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSupplyRequestOrderedItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then ItemElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSupplyRequestOrderedItem.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSupplyRequestOrderedItem.fhirType : string;
begin
  result := 'orderedItem';
end;

function TFhirSupplyRequestOrderedItem.Link : TFhirSupplyRequestOrderedItem;
begin
  result := TFhirSupplyRequestOrderedItem(inherited Link);
end;

function TFhirSupplyRequestOrderedItem.Clone : TFhirSupplyRequestOrderedItem;
begin
  result := TFhirSupplyRequestOrderedItem(inherited Clone);
end;

function TFhirSupplyRequestOrderedItem.equals(other : TObject) : boolean;
var
  o : TFhirSupplyRequestOrderedItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSupplyRequestOrderedItem)) then
    result := false
  else
  begin
    o := TFhirSupplyRequestOrderedItem(other);
    result := compareDeep(quantityElement, o.quantityElement, true) and compareDeep(itemElement, o.itemElement, true);
  end;
end;

function TFhirSupplyRequestOrderedItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FQuantity) and isEmptyProp(FItem);
end;

procedure TFhirSupplyRequestOrderedItem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('quantity');
  fields.add('item[x]');
end;

{ TFhirSupplyRequestOrderedItem }

Procedure TFhirSupplyRequestOrderedItem.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Procedure TFhirSupplyRequestOrderedItem.SetItem(value : TFhirType);
begin
  FItem.free;
  FItem := value;
end;

function TFhirSupplyRequestOrderedItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FQuantity.sizeInBytes);
  inc(result, FItem.sizeInBytes);
end;

{ TFhirSupplyRequestOrderedItemListEnumerator }

Constructor TFhirSupplyRequestOrderedItemListEnumerator.Create(list : TFhirSupplyRequestOrderedItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSupplyRequestOrderedItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSupplyRequestOrderedItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSupplyRequestOrderedItemListEnumerator.GetCurrent : TFhirSupplyRequestOrderedItem;
begin
  Result := FList[FIndex];
end;

function TFhirSupplyRequestOrderedItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSupplyRequestOrderedItemList }
procedure TFhirSupplyRequestOrderedItemList.AddItem(value: TFhirSupplyRequestOrderedItem);
begin
  assert(value.ClassName = 'TFhirSupplyRequestOrderedItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSupplyRequestOrderedItem');
  add(value);
end;

function TFhirSupplyRequestOrderedItemList.Append: TFhirSupplyRequestOrderedItem;
begin
  result := TFhirSupplyRequestOrderedItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSupplyRequestOrderedItemList.ClearItems;
begin
  Clear;
end;

function TFhirSupplyRequestOrderedItemList.GetEnumerator : TFhirSupplyRequestOrderedItemListEnumerator;
begin
  result := TFhirSupplyRequestOrderedItemListEnumerator.Create(self.link);
end;

function TFhirSupplyRequestOrderedItemList.Clone: TFhirSupplyRequestOrderedItemList;
begin
  result := TFhirSupplyRequestOrderedItemList(inherited Clone);
end;

function TFhirSupplyRequestOrderedItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSupplyRequestOrderedItemList.GetItemN(index: Integer): TFhirSupplyRequestOrderedItem;
begin
  result := TFhirSupplyRequestOrderedItem(ObjectByIndex[index]);
end;

function TFhirSupplyRequestOrderedItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirSupplyRequestOrderedItem;
end;
function TFhirSupplyRequestOrderedItemList.IndexOf(value: TFhirSupplyRequestOrderedItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSupplyRequestOrderedItemList.Insert(index: Integer): TFhirSupplyRequestOrderedItem;
begin
  result := TFhirSupplyRequestOrderedItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSupplyRequestOrderedItemList.InsertItem(index: Integer; value: TFhirSupplyRequestOrderedItem);
begin
  assert(value is TFhirSupplyRequestOrderedItem);
  Inherited Insert(index, value);
end;

function TFhirSupplyRequestOrderedItemList.Item(index: Integer): TFhirSupplyRequestOrderedItem;
begin
  result := TFhirSupplyRequestOrderedItem(ObjectByIndex[index]);
end;

function TFhirSupplyRequestOrderedItemList.Link: TFhirSupplyRequestOrderedItemList;
begin
  result := TFhirSupplyRequestOrderedItemList(inherited Link);
end;

procedure TFhirSupplyRequestOrderedItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSupplyRequestOrderedItemList.SetItemByIndex(index: Integer; value: TFhirSupplyRequestOrderedItem);
begin
  assert(value is TFhirSupplyRequestOrderedItem);
  FhirSupplyRequestOrderedItems[index] := value;
end;

procedure TFhirSupplyRequestOrderedItemList.SetItemN(index: Integer; value: TFhirSupplyRequestOrderedItem);
begin
  assert(value is TFhirSupplyRequestOrderedItem);
  ObjectByIndex[index] := value;
end;

{ TFhirSupplyRequestRequester }

constructor TFhirSupplyRequestRequester.Create;
begin
  inherited;
end;

destructor TFhirSupplyRequestRequester.Destroy;
begin
  FAgent.free;
  FOnBehalfOf.free;
  inherited;
end;

procedure TFhirSupplyRequestRequester.Assign(oSource : TFslObject);
begin
  inherited;
  agent := TFhirSupplyRequestRequester(oSource).agent.Clone;
  onBehalfOf := TFhirSupplyRequestRequester(oSource).onBehalfOf.Clone;
end;

procedure TFhirSupplyRequestRequester.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'agent') Then
     list.add(self.link, 'agent', FAgent.Link);
  if (child_name = 'onBehalfOf') Then
     list.add(self.link, 'onBehalfOf', FOnBehalfOf.Link);
end;

procedure TFhirSupplyRequestRequester.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'agent', 'Reference(Practitioner|Organization|Patient|RelatedPerson|Device)', false, TFhirReference{Resource}, FAgent.Link));{2}
  oList.add(TFHIRProperty.create(self, 'onBehalfOf', 'Reference(Organization)', false, TFhirReference{TFhirOrganization}, FOnBehalfOf.Link));{2}
end;

function TFhirSupplyRequestRequester.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'agent') then
  begin
    Agent := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'onBehalfOf') then
  begin
    OnBehalfOf := propValue as TFhirReference{TFhirOrganization}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSupplyRequestRequester.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSupplyRequestRequester.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'agent') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'onBehalfOf') then result := TFhirReference{TFhirOrganization}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSupplyRequestRequester.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'agent') then result := 'Reference'
  else if (propName = 'onBehalfOf') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSupplyRequestRequester.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'agent') then AgentElement := nil
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSupplyRequestRequester.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'agent') then AgentElement := new as TFhirReference{Resource}{4}
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := new as TFhirReference{TFhirOrganization}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSupplyRequestRequester.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSupplyRequestRequester.fhirType : string;
begin
  result := 'requester';
end;

function TFhirSupplyRequestRequester.Link : TFhirSupplyRequestRequester;
begin
  result := TFhirSupplyRequestRequester(inherited Link);
end;

function TFhirSupplyRequestRequester.Clone : TFhirSupplyRequestRequester;
begin
  result := TFhirSupplyRequestRequester(inherited Clone);
end;

function TFhirSupplyRequestRequester.equals(other : TObject) : boolean;
var
  o : TFhirSupplyRequestRequester;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSupplyRequestRequester)) then
    result := false
  else
  begin
    o := TFhirSupplyRequestRequester(other);
    result := compareDeep(agentElement, o.agentElement, true) and compareDeep(onBehalfOfElement, o.onBehalfOfElement, true);
  end;
end;

function TFhirSupplyRequestRequester.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAgent) and isEmptyProp(FOnBehalfOf);
end;

procedure TFhirSupplyRequestRequester.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('agent');
  fields.add('onBehalfOf');
end;

{ TFhirSupplyRequestRequester }

Procedure TFhirSupplyRequestRequester.SetAgent(value : TFhirReference{Resource});
begin
  FAgent.free;
  FAgent := value;
end;

Procedure TFhirSupplyRequestRequester.SetOnBehalfOf(value : TFhirReference{TFhirOrganization});
begin
  FOnBehalfOf.free;
  FOnBehalfOf := value;
end;

function TFhirSupplyRequestRequester.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FAgent.sizeInBytes);
  inc(result, FOnBehalfOf.sizeInBytes);
end;

{ TFhirSupplyRequestRequesterListEnumerator }

Constructor TFhirSupplyRequestRequesterListEnumerator.Create(list : TFhirSupplyRequestRequesterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSupplyRequestRequesterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSupplyRequestRequesterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSupplyRequestRequesterListEnumerator.GetCurrent : TFhirSupplyRequestRequester;
begin
  Result := FList[FIndex];
end;

function TFhirSupplyRequestRequesterListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSupplyRequestRequesterList }
procedure TFhirSupplyRequestRequesterList.AddItem(value: TFhirSupplyRequestRequester);
begin
  assert(value.ClassName = 'TFhirSupplyRequestRequester', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSupplyRequestRequester');
  add(value);
end;

function TFhirSupplyRequestRequesterList.Append: TFhirSupplyRequestRequester;
begin
  result := TFhirSupplyRequestRequester.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSupplyRequestRequesterList.ClearItems;
begin
  Clear;
end;

function TFhirSupplyRequestRequesterList.GetEnumerator : TFhirSupplyRequestRequesterListEnumerator;
begin
  result := TFhirSupplyRequestRequesterListEnumerator.Create(self.link);
end;

function TFhirSupplyRequestRequesterList.Clone: TFhirSupplyRequestRequesterList;
begin
  result := TFhirSupplyRequestRequesterList(inherited Clone);
end;

function TFhirSupplyRequestRequesterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSupplyRequestRequesterList.GetItemN(index: Integer): TFhirSupplyRequestRequester;
begin
  result := TFhirSupplyRequestRequester(ObjectByIndex[index]);
end;

function TFhirSupplyRequestRequesterList.ItemClass: TFslObjectClass;
begin
  result := TFhirSupplyRequestRequester;
end;
function TFhirSupplyRequestRequesterList.IndexOf(value: TFhirSupplyRequestRequester): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSupplyRequestRequesterList.Insert(index: Integer): TFhirSupplyRequestRequester;
begin
  result := TFhirSupplyRequestRequester.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSupplyRequestRequesterList.InsertItem(index: Integer; value: TFhirSupplyRequestRequester);
begin
  assert(value is TFhirSupplyRequestRequester);
  Inherited Insert(index, value);
end;

function TFhirSupplyRequestRequesterList.Item(index: Integer): TFhirSupplyRequestRequester;
begin
  result := TFhirSupplyRequestRequester(ObjectByIndex[index]);
end;

function TFhirSupplyRequestRequesterList.Link: TFhirSupplyRequestRequesterList;
begin
  result := TFhirSupplyRequestRequesterList(inherited Link);
end;

procedure TFhirSupplyRequestRequesterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSupplyRequestRequesterList.SetItemByIndex(index: Integer; value: TFhirSupplyRequestRequester);
begin
  assert(value is TFhirSupplyRequestRequester);
  FhirSupplyRequestRequesters[index] := value;
end;

procedure TFhirSupplyRequestRequesterList.SetItemN(index: Integer; value: TFhirSupplyRequestRequester);
begin
  assert(value is TFhirSupplyRequestRequester);
  ObjectByIndex[index] := value;
end;

{ TFhirSupplyRequest }

constructor TFhirSupplyRequest.Create;
begin
  inherited;
end;

destructor TFhirSupplyRequest.Destroy;
begin
  FIdentifier.free;
  FStatus.free;
  FCategory.free;
  FPriority.free;
  FOrderedItem.free;
  FOccurrence.free;
  FAuthoredOn.free;
  FRequester.free;
  FSupplierList.Free;
  FReason.free;
  FDeliverFrom.free;
  FDeliverTo.free;
  inherited;
end;

function TFhirSupplyRequest.GetResourceType : TFhirResourceType;
begin
  result := frtSupplyRequest;
end;

procedure TFhirSupplyRequest.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirSupplyRequest(oSource).identifier.Clone;
  FStatus := TFhirSupplyRequest(oSource).FStatus.Link;
  category := TFhirSupplyRequest(oSource).category.Clone;
  FPriority := TFhirSupplyRequest(oSource).FPriority.Link;
  orderedItem := TFhirSupplyRequest(oSource).orderedItem.Clone;
  occurrence := TFhirSupplyRequest(oSource).occurrence.Clone;
  authoredOnElement := TFhirSupplyRequest(oSource).authoredOnElement.Clone;
  requester := TFhirSupplyRequest(oSource).requester.Clone;
  if (TFhirSupplyRequest(oSource).FSupplierList = nil) then
  begin
    FSupplierList.free;
    FSupplierList := nil;
  end
  else
  begin
    if FSupplierList = nil then
      FSupplierList := TFhirReferenceList{TFhirOrganization}.Create;
    FSupplierList.Assign(TFhirSupplyRequest(oSource).FSupplierList);
  end;
  reason := TFhirSupplyRequest(oSource).reason.Clone;
  deliverFrom := TFhirSupplyRequest(oSource).deliverFrom.Clone;
  deliverTo := TFhirSupplyRequest(oSource).deliverTo.Clone;
end;

procedure TFhirSupplyRequest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'orderedItem') Then
     list.add(self.link, 'orderedItem', FOrderedItem.Link);
  if (child_name = 'occurrence[x]') or (child_name = 'occurrence') Then
     list.add(self.link, 'occurrence[x]', FOccurrence.Link);
  if (child_name = 'authoredOn') Then
     list.add(self.link, 'authoredOn', FAuthoredOn.Link);
  if (child_name = 'requester') Then
     list.add(self.link, 'requester', FRequester.Link);
  if (child_name = 'supplier') Then
    list.addAll(self, 'supplier', FSupplierList);
  if (child_name = 'reason[x]') or (child_name = 'reason') Then
     list.add(self.link, 'reason[x]', FReason.Link);
  if (child_name = 'deliverFrom') Then
     list.add(self.link, 'deliverFrom', FDeliverFrom.Link);
  if (child_name = 'deliverTo') Then
     list.add(self.link, 'deliverTo', FDeliverTo.Link);
end;

procedure TFhirSupplyRequest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'priority', 'code', false, TFHIREnum, FPriority.Link));{1}
  oList.add(TFHIRProperty.create(self, 'orderedItem', '', false, TFhirSupplyRequestOrderedItem, FOrderedItem.Link));{2}
  oList.add(TFHIRProperty.create(self, 'occurrence[x]', 'dateTime|Period|Timing', false, TFhirType, FOccurrence.Link));{2}
  oList.add(TFHIRProperty.create(self, 'authoredOn', 'dateTime', false, TFhirDateTime, FAuthoredOn.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requester', '', false, TFhirSupplyRequestRequester, FRequester.Link));{2}
  oList.add(TFHIRProperty.create(self, 'supplier', 'Reference(Organization)', true, TFhirReference{TFhirOrganization}, FSupplierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reason[x]', 'CodeableConcept|Reference(Any)', false, TFhirType, FReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'deliverFrom', 'Reference(Organization|Location)', false, TFhirReference{Resource}, FDeliverFrom.Link));{2}
  oList.add(TFHIRProperty.create(self, 'deliverTo', 'Reference(Organization|Location|Patient)', false, TFhirReference{Resource}, FDeliverTo.Link));{2}
end;

function TFhirSupplyRequest.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirSupplyrequestStatusEnum, CODES_TFhirSupplyrequestStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, propValue);
    result := propValue
  end
  else if (propName = 'orderedItem') then
  begin
    OrderedItem := propValue as TFhirSupplyRequestOrderedItem{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then
  begin
    Occurrence := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'authoredOn') then
  begin
    AuthoredOnElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'requester') then
  begin
    Requester := propValue as TFhirSupplyRequestRequester{4b};
    result := propValue;
  end
  else if (propName = 'supplier') then
  begin
    SupplierList.add(propValue as TFhirReference{TFhirOrganization}){2a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then
  begin
    Reason := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'deliverFrom') then
  begin
    DeliverFrom := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'deliverTo') then
  begin
    DeliverTo := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirSupplyRequest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'supplier') then SupplierList.insertItem(index, propValue as TFhirReference{TFhirOrganization}){2a}
  else inherited;
end;

function TFhirSupplyRequest.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'orderedItem') then result := TFhirSupplyRequestOrderedItem.create(){4b}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then raise EFHIRException.create('Cannot make property Occurrence'){4x}
  else if (propName = 'authoredOn') then result := TFhirDateTime.create() {5b}
  else if (propName = 'requester') then result := TFhirSupplyRequestRequester.create(){4b}
  else if (propName = 'supplier') then result := SupplierList.new(){2}
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Reason'){4x}
  else if (propName = 'deliverFrom') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'deliverTo') then result := TFhirReference{Resource}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSupplyRequest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'priority') then result := 'code'
  else if (propName = 'orderedItem') then result := ''
  else if (propName = 'occurrence[x]') then result := 'dateTime|Period|Timing'
  else if (propName = 'authoredOn') then result := 'dateTime'
  else if (propName = 'requester') then result := ''
  else if (propName = 'supplier') then result := 'Reference'
  else if (propName = 'reason[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'deliverFrom') then result := 'Reference'
  else if (propName = 'deliverTo') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSupplyRequest.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'orderedItem') then OrderedItemElement := nil
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then OccurrenceElement := nil{4x}
  else if (propName = 'authoredOn') then AuthoredOnElement := nil
  else if (propName = 'requester') then RequesterElement := nil
  else if (propName = 'supplier') then deletePropertyValue('supplier', SupplierList, value) {2}
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then ReasonElement := nil{4x}
  else if (propName = 'deliverFrom') then DeliverFromElement := nil
  else if (propName = 'deliverTo') then DeliverToElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSupplyRequest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirSupplyrequestStatusEnum, CODES_TFhirSupplyrequestStatusEnum, new){4}
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'priority') then PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, new){4}
  else if (propName = 'orderedItem') then OrderedItemElement := new as TFhirSupplyRequestOrderedItem{4}
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then OccurrenceElement := new as TFhirType{4x}
  else if (propName = 'authoredOn') then AuthoredOnElement := asDateTime(new){5b}
  else if (propName = 'requester') then RequesterElement := new as TFhirSupplyRequestRequester{4}
  else if (propName = 'supplier') then replacePropertyValue('supplier', SupplierList, existing, new) {2}
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then ReasonElement := new as TFhirType{4x}
  else if (propName = 'deliverFrom') then DeliverFromElement := new as TFhirReference{Resource}{4}
  else if (propName = 'deliverTo') then DeliverToElement := new as TFhirReference{Resource}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSupplyRequest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'supplier') then SupplierList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSupplyRequest.fhirType : string;
begin
  result := 'SupplyRequest';
end;

function TFhirSupplyRequest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FStatus) and isEmptyProp(FCategory) and isEmptyProp(FPriority) and isEmptyProp(FOrderedItem) and isEmptyProp(FOccurrence) and isEmptyProp(FAuthoredOn) and isEmptyProp(FRequester) and isEmptyProp(FsupplierList) and isEmptyProp(FReason) and isEmptyProp(FDeliverFrom) and isEmptyProp(FDeliverTo);
end;

function TFhirSupplyRequest.equals(other : TObject) : boolean;
var
  o : TFhirSupplyRequest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSupplyRequest)) then
    result := false
  else
  begin
    o := TFhirSupplyRequest(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(categoryElement, o.categoryElement, true) and compareDeep(priorityElement, o.priorityElement, true) and
      compareDeep(orderedItemElement, o.orderedItemElement, true) and compareDeep(occurrenceElement, o.occurrenceElement, true) and
      compareDeep(authoredOnElement, o.authoredOnElement, true) and compareDeep(requesterElement, o.requesterElement, true) and
      compareDeep(supplierList, o.supplierList, true) and compareDeep(reasonElement, o.reasonElement, true) and
      compareDeep(deliverFromElement, o.deliverFromElement, true) and compareDeep(deliverToElement, o.deliverToElement, true);
  end;
end;

function TFhirSupplyRequest.Link : TFhirSupplyRequest;
begin
  result := TFhirSupplyRequest(inherited Link);
end;

function TFhirSupplyRequest.Clone : TFhirSupplyRequest;
begin
  result := TFhirSupplyRequest(inherited Clone);
end;

procedure TFhirSupplyRequest.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('category');
  fields.add('priority');
  fields.add('orderedItem');
  fields.add('occurrence[x]');
  fields.add('authoredOn');
  fields.add('requester');
  fields.add('supplier');
  fields.add('reason[x]');
  fields.add('deliverFrom');
  fields.add('deliverTo');
end;

{ TFhirSupplyRequest }

Procedure TFhirSupplyRequest.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirSupplyRequest.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirSupplyRequest.GetStatusST : TFhirSupplyrequestStatusEnum;
begin
  if FStatus = nil then
    result := TFhirSupplyrequestStatusEnum(0)
  else
    result := TFhirSupplyrequestStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirSupplyrequestStatusEnum, FStatus.value));
end;

Procedure TFhirSupplyRequest.SetStatusST(value : TFhirSupplyrequestStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirSupplyrequestStatusEnum[value], CODES_TFhirSupplyrequestStatusEnum[value]);
end;

Procedure TFhirSupplyRequest.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirSupplyRequest.SetPriority(value : TFhirEnum);
begin
  FPriority.free;
  FPriority := value;
end;

Function TFhirSupplyRequest.GetPriorityST : TFhirRequestPriorityEnum;
begin
  if FPriority = nil then
    result := TFhirRequestPriorityEnum(0)
  else
    result := TFhirRequestPriorityEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestPriorityEnum, FPriority.value));
end;

Procedure TFhirSupplyRequest.SetPriorityST(value : TFhirRequestPriorityEnum);
begin
  if ord(value) = 0 then
    PriorityElement := nil
  else
    PriorityElement := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[value], CODES_TFhirRequestPriorityEnum[value]);
end;

Procedure TFhirSupplyRequest.SetOrderedItem(value : TFhirSupplyRequestOrderedItem);
begin
  FOrderedItem.free;
  FOrderedItem := value;
end;

Procedure TFhirSupplyRequest.SetOccurrence(value : TFhirType);
begin
  FOccurrence.free;
  FOccurrence := value;
end;

Procedure TFhirSupplyRequest.SetAuthoredOn(value : TFhirDateTime);
begin
  FAuthoredOn.free;
  FAuthoredOn := value;
end;

Function TFhirSupplyRequest.GetAuthoredOnST : TFslDateTime;
begin
  if FAuthoredOn = nil then
    result := TFslDateTime.makeNull
  else
    result := FAuthoredOn.value;
end;

Procedure TFhirSupplyRequest.SetAuthoredOnST(value : TFslDateTime);
begin
  if FAuthoredOn = nil then
    FAuthoredOn := TFhirDateTime.create;
  FAuthoredOn.value := value
end;

Procedure TFhirSupplyRequest.SetRequester(value : TFhirSupplyRequestRequester);
begin
  FRequester.free;
  FRequester := value;
end;

Function TFhirSupplyRequest.GetSupplierList : TFhirReferenceList{TFhirOrganization};
begin
  if FSupplierList = nil then
    FSupplierList := TFhirReferenceList{TFhirOrganization}.Create;
  result := FSupplierList;
end;

Function TFhirSupplyRequest.GetHasSupplierList : boolean;
begin
  result := (FSupplierList <> nil) and (FSupplierList.count > 0);
end;

Procedure TFhirSupplyRequest.SetReason(value : TFhirType);
begin
  FReason.free;
  FReason := value;
end;

Procedure TFhirSupplyRequest.SetDeliverFrom(value : TFhirReference{Resource});
begin
  FDeliverFrom.free;
  FDeliverFrom := value;
end;

Procedure TFhirSupplyRequest.SetDeliverTo(value : TFhirReference{Resource});
begin
  FDeliverTo.free;
  FDeliverTo := value;
end;

function TFhirSupplyRequest.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FPriority.sizeInBytes);
  inc(result, FOrderedItem.sizeInBytes);
  inc(result, FOccurrence.sizeInBytes);
  inc(result, FAuthoredOn.sizeInBytes);
  inc(result, FRequester.sizeInBytes);
  inc(result, FsupplierList.sizeInBytes);
  inc(result, FReason.sizeInBytes);
  inc(result, FDeliverFrom.sizeInBytes);
  inc(result, FDeliverTo.sizeInBytes);
end;

{ TFhirSupplyRequestListEnumerator }

Constructor TFhirSupplyRequestListEnumerator.Create(list : TFhirSupplyRequestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSupplyRequestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSupplyRequestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSupplyRequestListEnumerator.GetCurrent : TFhirSupplyRequest;
begin
  Result := FList[FIndex];
end;

function TFhirSupplyRequestListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSupplyRequestList }
procedure TFhirSupplyRequestList.AddItem(value: TFhirSupplyRequest);
begin
  assert(value.ClassName = 'TFhirSupplyRequest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSupplyRequest');
  add(value);
end;

function TFhirSupplyRequestList.Append: TFhirSupplyRequest;
begin
  result := TFhirSupplyRequest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSupplyRequestList.ClearItems;
begin
  Clear;
end;

function TFhirSupplyRequestList.GetEnumerator : TFhirSupplyRequestListEnumerator;
begin
  result := TFhirSupplyRequestListEnumerator.Create(self.link);
end;

function TFhirSupplyRequestList.Clone: TFhirSupplyRequestList;
begin
  result := TFhirSupplyRequestList(inherited Clone);
end;

function TFhirSupplyRequestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSupplyRequestList.GetItemN(index: Integer): TFhirSupplyRequest;
begin
  result := TFhirSupplyRequest(ObjectByIndex[index]);
end;

function TFhirSupplyRequestList.ItemClass: TFslObjectClass;
begin
  result := TFhirSupplyRequest;
end;
function TFhirSupplyRequestList.IndexOf(value: TFhirSupplyRequest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSupplyRequestList.Insert(index: Integer): TFhirSupplyRequest;
begin
  result := TFhirSupplyRequest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSupplyRequestList.InsertItem(index: Integer; value: TFhirSupplyRequest);
begin
  assert(value is TFhirSupplyRequest);
  Inherited Insert(index, value);
end;

function TFhirSupplyRequestList.Item(index: Integer): TFhirSupplyRequest;
begin
  result := TFhirSupplyRequest(ObjectByIndex[index]);
end;

function TFhirSupplyRequestList.Link: TFhirSupplyRequestList;
begin
  result := TFhirSupplyRequestList(inherited Link);
end;

procedure TFhirSupplyRequestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSupplyRequestList.SetItemByIndex(index: Integer; value: TFhirSupplyRequest);
begin
  assert(value is TFhirSupplyRequest);
  FhirSupplyRequests[index] := value;
end;

procedure TFhirSupplyRequestList.SetItemN(index: Integer; value: TFhirSupplyRequest);
begin
  assert(value is TFhirSupplyRequest);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SUPPLYREQUEST}

{$IFDEF FHIR_VISIONPRESCRIPTION}

{ TFhirVisionPrescriptionDispense }

constructor TFhirVisionPrescriptionDispense.Create;
begin
  inherited;
end;

destructor TFhirVisionPrescriptionDispense.Destroy;
begin
  FProduct.free;
  FEye.free;
  FSphere.free;
  FCylinder.free;
  FAxis.free;
  FPrism.free;
  FBase.free;
  FAdd.free;
  FPower.free;
  FBackCurve.free;
  FDiameter.free;
  FDuration.free;
  FColor.free;
  FBrand.free;
  FNoteList.Free;
  inherited;
end;

procedure TFhirVisionPrescriptionDispense.Assign(oSource : TFslObject);
begin
  inherited;
  product := TFhirVisionPrescriptionDispense(oSource).product.Clone;
  FEye := TFhirVisionPrescriptionDispense(oSource).FEye.Link;
  sphereElement := TFhirVisionPrescriptionDispense(oSource).sphereElement.Clone;
  cylinderElement := TFhirVisionPrescriptionDispense(oSource).cylinderElement.Clone;
  axisElement := TFhirVisionPrescriptionDispense(oSource).axisElement.Clone;
  prismElement := TFhirVisionPrescriptionDispense(oSource).prismElement.Clone;
  FBase := TFhirVisionPrescriptionDispense(oSource).FBase.Link;
  addElement := TFhirVisionPrescriptionDispense(oSource).addElement.Clone;
  powerElement := TFhirVisionPrescriptionDispense(oSource).powerElement.Clone;
  backCurveElement := TFhirVisionPrescriptionDispense(oSource).backCurveElement.Clone;
  diameterElement := TFhirVisionPrescriptionDispense(oSource).diameterElement.Clone;
  duration := TFhirVisionPrescriptionDispense(oSource).duration.Clone;
  colorElement := TFhirVisionPrescriptionDispense(oSource).colorElement.Clone;
  brandElement := TFhirVisionPrescriptionDispense(oSource).brandElement.Clone;
  if (TFhirVisionPrescriptionDispense(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirVisionPrescriptionDispense(oSource).FNoteList);
  end;
end;

procedure TFhirVisionPrescriptionDispense.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'product') Then
     list.add(self.link, 'product', FProduct.Link);
  if (child_name = 'eye') Then
     list.add(self.link, 'eye', FEye.Link);
  if (child_name = 'sphere') Then
     list.add(self.link, 'sphere', FSphere.Link);
  if (child_name = 'cylinder') Then
     list.add(self.link, 'cylinder', FCylinder.Link);
  if (child_name = 'axis') Then
     list.add(self.link, 'axis', FAxis.Link);
  if (child_name = 'prism') Then
     list.add(self.link, 'prism', FPrism.Link);
  if (child_name = 'base') Then
     list.add(self.link, 'base', FBase.Link);
  if (child_name = 'add') Then
     list.add(self.link, 'add', FAdd.Link);
  if (child_name = 'power') Then
     list.add(self.link, 'power', FPower.Link);
  if (child_name = 'backCurve') Then
     list.add(self.link, 'backCurve', FBackCurve.Link);
  if (child_name = 'diameter') Then
     list.add(self.link, 'diameter', FDiameter.Link);
  if (child_name = 'duration') Then
     list.add(self.link, 'duration', FDuration.Link);
  if (child_name = 'color') Then
     list.add(self.link, 'color', FColor.Link);
  if (child_name = 'brand') Then
     list.add(self.link, 'brand', FBrand.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirVisionPrescriptionDispense.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'product', 'CodeableConcept', false, TFhirCodeableConcept, FProduct.Link));{2}
  oList.add(TFHIRProperty.create(self, 'eye', 'code', false, TFHIREnum, FEye.Link));{1}
  oList.add(TFHIRProperty.create(self, 'sphere', 'decimal', false, TFhirDecimal, FSphere.Link));{2}
  oList.add(TFHIRProperty.create(self, 'cylinder', 'decimal', false, TFhirDecimal, FCylinder.Link));{2}
  oList.add(TFHIRProperty.create(self, 'axis', 'integer', false, TFhirInteger, FAxis.Link));{2}
  oList.add(TFHIRProperty.create(self, 'prism', 'decimal', false, TFhirDecimal, FPrism.Link));{2}
  oList.add(TFHIRProperty.create(self, 'base', 'code', false, TFHIREnum, FBase.Link));{1}
  oList.add(TFHIRProperty.create(self, 'add', 'decimal', false, TFhirDecimal, FAdd.Link));{2}
  oList.add(TFHIRProperty.create(self, 'power', 'decimal', false, TFhirDecimal, FPower.Link));{2}
  oList.add(TFHIRProperty.create(self, 'backCurve', 'decimal', false, TFhirDecimal, FBackCurve.Link));{2}
  oList.add(TFHIRProperty.create(self, 'diameter', 'decimal', false, TFhirDecimal, FDiameter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'duration', 'Quantity', false, TFhirQuantity, FDuration.Link));{2}
  oList.add(TFHIRProperty.create(self, 'color', 'string', false, TFhirString, FColor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'brand', 'string', false, TFhirString, FBrand.Link));{2}
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
end;

function TFhirVisionPrescriptionDispense.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'product') then
  begin
    Product := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'eye') then
  begin
    EyeElement := asEnum(SYSTEMS_TFhirVisionEyeCodesEnum, CODES_TFhirVisionEyeCodesEnum, propValue);
    result := propValue
  end
  else if (propName = 'sphere') then
  begin
    SphereElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'cylinder') then
  begin
    CylinderElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'axis') then
  begin
    AxisElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'prism') then
  begin
    PrismElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'base') then
  begin
    BaseElement := asEnum(SYSTEMS_TFhirVisionBaseCodesEnum, CODES_TFhirVisionBaseCodesEnum, propValue);
    result := propValue
  end
  else if (propName = 'add') then
  begin
    AddElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'power') then
  begin
    PowerElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'backCurve') then
  begin
    BackCurveElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'diameter') then
  begin
    DiameterElement := asDecimal(propValue){5a};
    result := propValue;
  end
  else if (propName = 'duration') then
  begin
    Duration := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'color') then
  begin
    ColorElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'brand') then
  begin
    BrandElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirVisionPrescriptionDispense.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else inherited;
end;

function TFhirVisionPrescriptionDispense.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'product') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'sphere') then result := TFhirDecimal.create() {5b}
  else if (propName = 'cylinder') then result := TFhirDecimal.create() {5b}
  else if (propName = 'axis') then result := TFhirInteger.create() {5b}
  else if (propName = 'prism') then result := TFhirDecimal.create() {5b}
  else if (propName = 'add') then result := TFhirDecimal.create() {5b}
  else if (propName = 'power') then result := TFhirDecimal.create() {5b}
  else if (propName = 'backCurve') then result := TFhirDecimal.create() {5b}
  else if (propName = 'diameter') then result := TFhirDecimal.create() {5b}
  else if (propName = 'duration') then result := TFhirQuantity.create(){4b}
  else if (propName = 'color') then result := TFhirString.create() {5b}
  else if (propName = 'brand') then result := TFhirString.create() {5b}
  else if (propName = 'note') then result := NoteList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirVisionPrescriptionDispense.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'product') then result := 'CodeableConcept'
  else if (propName = 'eye') then result := 'code'
  else if (propName = 'sphere') then result := 'decimal'
  else if (propName = 'cylinder') then result := 'decimal'
  else if (propName = 'axis') then result := 'integer'
  else if (propName = 'prism') then result := 'decimal'
  else if (propName = 'base') then result := 'code'
  else if (propName = 'add') then result := 'decimal'
  else if (propName = 'power') then result := 'decimal'
  else if (propName = 'backCurve') then result := 'decimal'
  else if (propName = 'diameter') then result := 'decimal'
  else if (propName = 'duration') then result := 'Quantity'
  else if (propName = 'color') then result := 'string'
  else if (propName = 'brand') then result := 'string'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirVisionPrescriptionDispense.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'product') then ProductElement := nil
  else if (propName = 'eye') then EyeElement := nil
  else if (propName = 'sphere') then SphereElement := nil
  else if (propName = 'cylinder') then CylinderElement := nil
  else if (propName = 'axis') then AxisElement := nil
  else if (propName = 'prism') then PrismElement := nil
  else if (propName = 'base') then BaseElement := nil
  else if (propName = 'add') then AddElement := nil
  else if (propName = 'power') then PowerElement := nil
  else if (propName = 'backCurve') then BackCurveElement := nil
  else if (propName = 'diameter') then DiameterElement := nil
  else if (propName = 'duration') then DurationElement := nil
  else if (propName = 'color') then ColorElement := nil
  else if (propName = 'brand') then BrandElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirVisionPrescriptionDispense.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'product') then ProductElement := new as TFhirCodeableConcept{4}
  else if (propName = 'eye') then EyeElement := asEnum(SYSTEMS_TFhirVisionEyeCodesEnum, CODES_TFhirVisionEyeCodesEnum, new){4}
  else if (propName = 'sphere') then SphereElement := asDecimal(new){5b}
  else if (propName = 'cylinder') then CylinderElement := asDecimal(new){5b}
  else if (propName = 'axis') then AxisElement := asInteger(new){5b}
  else if (propName = 'prism') then PrismElement := asDecimal(new){5b}
  else if (propName = 'base') then BaseElement := asEnum(SYSTEMS_TFhirVisionBaseCodesEnum, CODES_TFhirVisionBaseCodesEnum, new){4}
  else if (propName = 'add') then AddElement := asDecimal(new){5b}
  else if (propName = 'power') then PowerElement := asDecimal(new){5b}
  else if (propName = 'backCurve') then BackCurveElement := asDecimal(new){5b}
  else if (propName = 'diameter') then DiameterElement := asDecimal(new){5b}
  else if (propName = 'duration') then DurationElement := new as TFhirQuantity{4}
  else if (propName = 'color') then ColorElement := asString(new){5b}
  else if (propName = 'brand') then BrandElement := asString(new){5b}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirVisionPrescriptionDispense.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'note') then NoteList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirVisionPrescriptionDispense.fhirType : string;
begin
  result := 'dispense';
end;

function TFhirVisionPrescriptionDispense.Link : TFhirVisionPrescriptionDispense;
begin
  result := TFhirVisionPrescriptionDispense(inherited Link);
end;

function TFhirVisionPrescriptionDispense.Clone : TFhirVisionPrescriptionDispense;
begin
  result := TFhirVisionPrescriptionDispense(inherited Clone);
end;

function TFhirVisionPrescriptionDispense.equals(other : TObject) : boolean;
var
  o : TFhirVisionPrescriptionDispense;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirVisionPrescriptionDispense)) then
    result := false
  else
  begin
    o := TFhirVisionPrescriptionDispense(other);
    result := compareDeep(productElement, o.productElement, true) and compareDeep(eyeElement, o.eyeElement, true) and
      compareDeep(sphereElement, o.sphereElement, true) and compareDeep(cylinderElement, o.cylinderElement, true) and
      compareDeep(axisElement, o.axisElement, true) and compareDeep(prismElement, o.prismElement, true) and
      compareDeep(baseElement, o.baseElement, true) and compareDeep(addElement, o.addElement, true) and
      compareDeep(powerElement, o.powerElement, true) and compareDeep(backCurveElement, o.backCurveElement, true) and
      compareDeep(diameterElement, o.diameterElement, true) and compareDeep(durationElement, o.durationElement, true) and
      compareDeep(colorElement, o.colorElement, true) and compareDeep(brandElement, o.brandElement, true) and
      compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirVisionPrescriptionDispense.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FProduct) and isEmptyProp(FEye) and isEmptyProp(FSphere) and isEmptyProp(FCylinder) and isEmptyProp(FAxis) and isEmptyProp(FPrism) and isEmptyProp(FBase) and isEmptyProp(FAdd) and isEmptyProp(FPower) and isEmptyProp(FBackCurve) and isEmptyProp(FDiameter) and isEmptyProp(FDuration) and isEmptyProp(FColor) and isEmptyProp(FBrand) and isEmptyProp(FnoteList);
end;

procedure TFhirVisionPrescriptionDispense.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('product');
  fields.add('eye');
  fields.add('sphere');
  fields.add('cylinder');
  fields.add('axis');
  fields.add('prism');
  fields.add('base');
  fields.add('add');
  fields.add('power');
  fields.add('backCurve');
  fields.add('diameter');
  fields.add('duration');
  fields.add('color');
  fields.add('brand');
  fields.add('note');
end;

{ TFhirVisionPrescriptionDispense }

Procedure TFhirVisionPrescriptionDispense.SetProduct(value : TFhirCodeableConcept);
begin
  FProduct.free;
  FProduct := value;
end;

Procedure TFhirVisionPrescriptionDispense.SetEye(value : TFhirEnum);
begin
  FEye.free;
  FEye := value;
end;

Function TFhirVisionPrescriptionDispense.GetEyeST : TFhirVisionEyeCodesEnum;
begin
  if FEye = nil then
    result := TFhirVisionEyeCodesEnum(0)
  else
    result := TFhirVisionEyeCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirVisionEyeCodesEnum, FEye.value));
end;

Procedure TFhirVisionPrescriptionDispense.SetEyeST(value : TFhirVisionEyeCodesEnum);
begin
  if ord(value) = 0 then
    EyeElement := nil
  else
    EyeElement := TFhirEnum.create(SYSTEMS_TFhirVisionEyeCodesEnum[value], CODES_TFhirVisionEyeCodesEnum[value]);
end;

Procedure TFhirVisionPrescriptionDispense.SetSphere(value : TFhirDecimal);
begin
  FSphere.free;
  FSphere := value;
end;

Function TFhirVisionPrescriptionDispense.GetSphereST : String;
begin
  if FSphere = nil then
    result := ''
  else
    result := FSphere.value;
end;

Procedure TFhirVisionPrescriptionDispense.SetSphereST(value : String);
begin
  if value <> '' then
  begin
    if FSphere = nil then
      FSphere := TFhirDecimal.create;
    FSphere.value := value
  end
  else if FSphere <> nil then
    FSphere.value := '';
end;

Procedure TFhirVisionPrescriptionDispense.SetCylinder(value : TFhirDecimal);
begin
  FCylinder.free;
  FCylinder := value;
end;

Function TFhirVisionPrescriptionDispense.GetCylinderST : String;
begin
  if FCylinder = nil then
    result := ''
  else
    result := FCylinder.value;
end;

Procedure TFhirVisionPrescriptionDispense.SetCylinderST(value : String);
begin
  if value <> '' then
  begin
    if FCylinder = nil then
      FCylinder := TFhirDecimal.create;
    FCylinder.value := value
  end
  else if FCylinder <> nil then
    FCylinder.value := '';
end;

Procedure TFhirVisionPrescriptionDispense.SetAxis(value : TFhirInteger);
begin
  FAxis.free;
  FAxis := value;
end;

Function TFhirVisionPrescriptionDispense.GetAxisST : String;
begin
  if FAxis = nil then
    result := ''
  else
    result := FAxis.value;
end;

Procedure TFhirVisionPrescriptionDispense.SetAxisST(value : String);
begin
  if value <> '' then
  begin
    if FAxis = nil then
      FAxis := TFhirInteger.create;
    FAxis.value := value
  end
  else if FAxis <> nil then
    FAxis.value := '';
end;

Procedure TFhirVisionPrescriptionDispense.SetPrism(value : TFhirDecimal);
begin
  FPrism.free;
  FPrism := value;
end;

Function TFhirVisionPrescriptionDispense.GetPrismST : String;
begin
  if FPrism = nil then
    result := ''
  else
    result := FPrism.value;
end;

Procedure TFhirVisionPrescriptionDispense.SetPrismST(value : String);
begin
  if value <> '' then
  begin
    if FPrism = nil then
      FPrism := TFhirDecimal.create;
    FPrism.value := value
  end
  else if FPrism <> nil then
    FPrism.value := '';
end;

Procedure TFhirVisionPrescriptionDispense.SetBase(value : TFhirEnum);
begin
  FBase.free;
  FBase := value;
end;

Function TFhirVisionPrescriptionDispense.GetBaseST : TFhirVisionBaseCodesEnum;
begin
  if FBase = nil then
    result := TFhirVisionBaseCodesEnum(0)
  else
    result := TFhirVisionBaseCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirVisionBaseCodesEnum, FBase.value));
end;

Procedure TFhirVisionPrescriptionDispense.SetBaseST(value : TFhirVisionBaseCodesEnum);
begin
  if ord(value) = 0 then
    BaseElement := nil
  else
    BaseElement := TFhirEnum.create(SYSTEMS_TFhirVisionBaseCodesEnum[value], CODES_TFhirVisionBaseCodesEnum[value]);
end;

Procedure TFhirVisionPrescriptionDispense.SetAdd(value : TFhirDecimal);
begin
  FAdd.free;
  FAdd := value;
end;

Function TFhirVisionPrescriptionDispense.GetAddST : String;
begin
  if FAdd = nil then
    result := ''
  else
    result := FAdd.value;
end;

Procedure TFhirVisionPrescriptionDispense.SetAddST(value : String);
begin
  if value <> '' then
  begin
    if FAdd = nil then
      FAdd := TFhirDecimal.create;
    FAdd.value := value
  end
  else if FAdd <> nil then
    FAdd.value := '';
end;

Procedure TFhirVisionPrescriptionDispense.SetPower(value : TFhirDecimal);
begin
  FPower.free;
  FPower := value;
end;

Function TFhirVisionPrescriptionDispense.GetPowerST : String;
begin
  if FPower = nil then
    result := ''
  else
    result := FPower.value;
end;

Procedure TFhirVisionPrescriptionDispense.SetPowerST(value : String);
begin
  if value <> '' then
  begin
    if FPower = nil then
      FPower := TFhirDecimal.create;
    FPower.value := value
  end
  else if FPower <> nil then
    FPower.value := '';
end;

Procedure TFhirVisionPrescriptionDispense.SetBackCurve(value : TFhirDecimal);
begin
  FBackCurve.free;
  FBackCurve := value;
end;

Function TFhirVisionPrescriptionDispense.GetBackCurveST : String;
begin
  if FBackCurve = nil then
    result := ''
  else
    result := FBackCurve.value;
end;

Procedure TFhirVisionPrescriptionDispense.SetBackCurveST(value : String);
begin
  if value <> '' then
  begin
    if FBackCurve = nil then
      FBackCurve := TFhirDecimal.create;
    FBackCurve.value := value
  end
  else if FBackCurve <> nil then
    FBackCurve.value := '';
end;

Procedure TFhirVisionPrescriptionDispense.SetDiameter(value : TFhirDecimal);
begin
  FDiameter.free;
  FDiameter := value;
end;

Function TFhirVisionPrescriptionDispense.GetDiameterST : String;
begin
  if FDiameter = nil then
    result := ''
  else
    result := FDiameter.value;
end;

Procedure TFhirVisionPrescriptionDispense.SetDiameterST(value : String);
begin
  if value <> '' then
  begin
    if FDiameter = nil then
      FDiameter := TFhirDecimal.create;
    FDiameter.value := value
  end
  else if FDiameter <> nil then
    FDiameter.value := '';
end;

Procedure TFhirVisionPrescriptionDispense.SetDuration(value : TFhirQuantity);
begin
  FDuration.free;
  FDuration := value;
end;

Procedure TFhirVisionPrescriptionDispense.SetColor(value : TFhirString);
begin
  FColor.free;
  FColor := value;
end;

Function TFhirVisionPrescriptionDispense.GetColorST : String;
begin
  if FColor = nil then
    result := ''
  else
    result := FColor.value;
end;

Procedure TFhirVisionPrescriptionDispense.SetColorST(value : String);
begin
  if value <> '' then
  begin
    if FColor = nil then
      FColor := TFhirString.create;
    FColor.value := value
  end
  else if FColor <> nil then
    FColor.value := '';
end;

Procedure TFhirVisionPrescriptionDispense.SetBrand(value : TFhirString);
begin
  FBrand.free;
  FBrand := value;
end;

Function TFhirVisionPrescriptionDispense.GetBrandST : String;
begin
  if FBrand = nil then
    result := ''
  else
    result := FBrand.value;
end;

Procedure TFhirVisionPrescriptionDispense.SetBrandST(value : String);
begin
  if value <> '' then
  begin
    if FBrand = nil then
      FBrand := TFhirString.create;
    FBrand.value := value
  end
  else if FBrand <> nil then
    FBrand.value := '';
end;

Function TFhirVisionPrescriptionDispense.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirVisionPrescriptionDispense.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirVisionPrescriptionDispense.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FProduct.sizeInBytes);
  inc(result, FEye.sizeInBytes);
  inc(result, FSphere.sizeInBytes);
  inc(result, FCylinder.sizeInBytes);
  inc(result, FAxis.sizeInBytes);
  inc(result, FPrism.sizeInBytes);
  inc(result, FBase.sizeInBytes);
  inc(result, FAdd.sizeInBytes);
  inc(result, FPower.sizeInBytes);
  inc(result, FBackCurve.sizeInBytes);
  inc(result, FDiameter.sizeInBytes);
  inc(result, FDuration.sizeInBytes);
  inc(result, FColor.sizeInBytes);
  inc(result, FBrand.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
end;

{ TFhirVisionPrescriptionDispenseListEnumerator }

Constructor TFhirVisionPrescriptionDispenseListEnumerator.Create(list : TFhirVisionPrescriptionDispenseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirVisionPrescriptionDispenseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirVisionPrescriptionDispenseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirVisionPrescriptionDispenseListEnumerator.GetCurrent : TFhirVisionPrescriptionDispense;
begin
  Result := FList[FIndex];
end;

function TFhirVisionPrescriptionDispenseListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirVisionPrescriptionDispenseList }
procedure TFhirVisionPrescriptionDispenseList.AddItem(value: TFhirVisionPrescriptionDispense);
begin
  assert(value.ClassName = 'TFhirVisionPrescriptionDispense', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirVisionPrescriptionDispense');
  add(value);
end;

function TFhirVisionPrescriptionDispenseList.Append: TFhirVisionPrescriptionDispense;
begin
  result := TFhirVisionPrescriptionDispense.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVisionPrescriptionDispenseList.ClearItems;
begin
  Clear;
end;

function TFhirVisionPrescriptionDispenseList.GetEnumerator : TFhirVisionPrescriptionDispenseListEnumerator;
begin
  result := TFhirVisionPrescriptionDispenseListEnumerator.Create(self.link);
end;

function TFhirVisionPrescriptionDispenseList.Clone: TFhirVisionPrescriptionDispenseList;
begin
  result := TFhirVisionPrescriptionDispenseList(inherited Clone);
end;

function TFhirVisionPrescriptionDispenseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirVisionPrescriptionDispenseList.GetItemN(index: Integer): TFhirVisionPrescriptionDispense;
begin
  result := TFhirVisionPrescriptionDispense(ObjectByIndex[index]);
end;

function TFhirVisionPrescriptionDispenseList.ItemClass: TFslObjectClass;
begin
  result := TFhirVisionPrescriptionDispense;
end;
function TFhirVisionPrescriptionDispenseList.IndexOf(value: TFhirVisionPrescriptionDispense): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirVisionPrescriptionDispenseList.Insert(index: Integer): TFhirVisionPrescriptionDispense;
begin
  result := TFhirVisionPrescriptionDispense.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVisionPrescriptionDispenseList.InsertItem(index: Integer; value: TFhirVisionPrescriptionDispense);
begin
  assert(value is TFhirVisionPrescriptionDispense);
  Inherited Insert(index, value);
end;

function TFhirVisionPrescriptionDispenseList.Item(index: Integer): TFhirVisionPrescriptionDispense;
begin
  result := TFhirVisionPrescriptionDispense(ObjectByIndex[index]);
end;

function TFhirVisionPrescriptionDispenseList.Link: TFhirVisionPrescriptionDispenseList;
begin
  result := TFhirVisionPrescriptionDispenseList(inherited Link);
end;

procedure TFhirVisionPrescriptionDispenseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirVisionPrescriptionDispenseList.SetItemByIndex(index: Integer; value: TFhirVisionPrescriptionDispense);
begin
  assert(value is TFhirVisionPrescriptionDispense);
  FhirVisionPrescriptionDispenses[index] := value;
end;

procedure TFhirVisionPrescriptionDispenseList.SetItemN(index: Integer; value: TFhirVisionPrescriptionDispense);
begin
  assert(value is TFhirVisionPrescriptionDispense);
  ObjectByIndex[index] := value;
end;

{ TFhirVisionPrescription }

constructor TFhirVisionPrescription.Create;
begin
  inherited;
end;

destructor TFhirVisionPrescription.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FPatient.free;
  FEncounter.free;
  FDateWritten.free;
  FPrescriber.free;
  FReason.free;
  FDispenseList.Free;
  inherited;
end;

function TFhirVisionPrescription.GetResourceType : TFhirResourceType;
begin
  result := frtVisionPrescription;
end;

procedure TFhirVisionPrescription.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirVisionPrescription(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirVisionPrescription(oSource).FIdentifierList);
  end;
  FStatus := TFhirVisionPrescription(oSource).FStatus.Link;
  patient := TFhirVisionPrescription(oSource).patient.Clone;
  encounter := TFhirVisionPrescription(oSource).encounter.Clone;
  dateWrittenElement := TFhirVisionPrescription(oSource).dateWrittenElement.Clone;
  prescriber := TFhirVisionPrescription(oSource).prescriber.Clone;
  reason := TFhirVisionPrescription(oSource).reason.Clone;
  if (TFhirVisionPrescription(oSource).FDispenseList = nil) then
  begin
    FDispenseList.free;
    FDispenseList := nil;
  end
  else
  begin
    if FDispenseList = nil then
      FDispenseList := TFhirVisionPrescriptionDispenseList.Create;
    FDispenseList.Assign(TFhirVisionPrescription(oSource).FDispenseList);
  end;
end;

procedure TFhirVisionPrescription.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'dateWritten') Then
     list.add(self.link, 'dateWritten', FDateWritten.Link);
  if (child_name = 'prescriber') Then
     list.add(self.link, 'prescriber', FPrescriber.Link);
  if (child_name = 'reason[x]') or (child_name = 'reason') Then
     list.add(self.link, 'reason[x]', FReason.Link);
  if (child_name = 'dispense') Then
    list.addAll(self, 'dispense', FDispenseList);
end;

procedure TFhirVisionPrescription.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference(Patient)', false, TFhirReference{TFhirPatient}, FPatient.Link));{2}
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference(Encounter)', false, TFhirReference{TFhirEncounter}, FEncounter.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dateWritten', 'dateTime', false, TFhirDateTime, FDateWritten.Link));{2}
  oList.add(TFHIRProperty.create(self, 'prescriber', 'Reference(Practitioner)', false, TFhirReference{TFhirPractitioner}, FPrescriber.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason[x]', 'CodeableConcept|Reference(Condition)', false, TFhirType, FReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dispense', '', true, TFhirVisionPrescriptionDispense, FDispenseList.Link)){3};
end;

function TFhirVisionPrescription.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFmStatusEnum, CODES_TFhirFmStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference{TFhirPatient}{4b};
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference{TFhirEncounter}{4b};
    result := propValue;
  end
  else if (propName = 'dateWritten') then
  begin
    DateWrittenElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'prescriber') then
  begin
    Prescriber := propValue as TFhirReference{TFhirPractitioner}{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then
  begin
    Reason := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'dispense') then
  begin
    DispenseList.add(propValue as TFhirVisionPrescriptionDispense){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirVisionPrescription.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'dispense') then DispenseList.insertItem(index, propValue as TFhirVisionPrescriptionDispense){2a}
  else inherited;
end;

function TFhirVisionPrescription.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'patient') then result := TFhirReference{TFhirPatient}.create(){4b}
  else if (propName = 'encounter') then result := TFhirReference{TFhirEncounter}.create(){4b}
  else if (propName = 'dateWritten') then result := TFhirDateTime.create() {5b}
  else if (propName = 'prescriber') then result := TFhirReference{TFhirPractitioner}.create(){4b}
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Reason'){4x}
  else if (propName = 'dispense') then result := DispenseList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirVisionPrescription.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'dateWritten') then result := 'dateTime'
  else if (propName = 'prescriber') then result := 'Reference'
  else if (propName = 'reason[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'dispense') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirVisionPrescription.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'dateWritten') then DateWrittenElement := nil
  else if (propName = 'prescriber') then PrescriberElement := nil
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then ReasonElement := nil{4x}
  else if (propName = 'dispense') then deletePropertyValue('dispense', DispenseList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirVisionPrescription.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFmStatusEnum, CODES_TFhirFmStatusEnum, new){4}
  else if (propName = 'patient') then PatientElement := new as TFhirReference{TFhirPatient}{4}
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference{TFhirEncounter}{4}
  else if (propName = 'dateWritten') then DateWrittenElement := asDateTime(new){5b}
  else if (propName = 'prescriber') then PrescriberElement := new as TFhirReference{TFhirPractitioner}{4}
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then ReasonElement := new as TFhirType{4x}
  else if (propName = 'dispense') then replacePropertyValue('dispense', DispenseList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirVisionPrescription.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'dispense') then DispenseList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirVisionPrescription.fhirType : string;
begin
  result := 'VisionPrescription';
end;

function TFhirVisionPrescription.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FPatient) and isEmptyProp(FEncounter) and isEmptyProp(FDateWritten) and isEmptyProp(FPrescriber) and isEmptyProp(FReason) and isEmptyProp(FdispenseList);
end;

function TFhirVisionPrescription.equals(other : TObject) : boolean;
var
  o : TFhirVisionPrescription;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirVisionPrescription)) then
    result := false
  else
  begin
    o := TFhirVisionPrescription(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(patientElement, o.patientElement, true) and compareDeep(encounterElement, o.encounterElement, true) and
      compareDeep(dateWrittenElement, o.dateWrittenElement, true) and compareDeep(prescriberElement, o.prescriberElement, true) and
      compareDeep(reasonElement, o.reasonElement, true) and compareDeep(dispenseList, o.dispenseList, true);
  end;
end;

function TFhirVisionPrescription.Link : TFhirVisionPrescription;
begin
  result := TFhirVisionPrescription(inherited Link);
end;

function TFhirVisionPrescription.Clone : TFhirVisionPrescription;
begin
  result := TFhirVisionPrescription(inherited Clone);
end;

procedure TFhirVisionPrescription.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('patient');
  fields.add('encounter');
  fields.add('dateWritten');
  fields.add('prescriber');
  fields.add('reason[x]');
  fields.add('dispense');
end;

{ TFhirVisionPrescription }

Function TFhirVisionPrescription.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirVisionPrescription.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirVisionPrescription.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirVisionPrescription.GetStatusST : TFhirFmStatusEnum;
begin
  if FStatus = nil then
    result := TFhirFmStatusEnum(0)
  else
    result := TFhirFmStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirFmStatusEnum, FStatus.value));
end;

Procedure TFhirVisionPrescription.SetStatusST(value : TFhirFmStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFmStatusEnum[value], CODES_TFhirFmStatusEnum[value]);
end;

Procedure TFhirVisionPrescription.SetPatient(value : TFhirReference{TFhirPatient});
begin
  FPatient.free;
  FPatient := value;
end;

Procedure TFhirVisionPrescription.SetEncounter(value : TFhirReference{TFhirEncounter});
begin
  FEncounter.free;
  FEncounter := value;
end;

Procedure TFhirVisionPrescription.SetDateWritten(value : TFhirDateTime);
begin
  FDateWritten.free;
  FDateWritten := value;
end;

Function TFhirVisionPrescription.GetDateWrittenST : TFslDateTime;
begin
  if FDateWritten = nil then
    result := TFslDateTime.makeNull
  else
    result := FDateWritten.value;
end;

Procedure TFhirVisionPrescription.SetDateWrittenST(value : TFslDateTime);
begin
  if FDateWritten = nil then
    FDateWritten := TFhirDateTime.create;
  FDateWritten.value := value
end;

Procedure TFhirVisionPrescription.SetPrescriber(value : TFhirReference{TFhirPractitioner});
begin
  FPrescriber.free;
  FPrescriber := value;
end;

Procedure TFhirVisionPrescription.SetReason(value : TFhirType);
begin
  FReason.free;
  FReason := value;
end;

Function TFhirVisionPrescription.GetDispenseList : TFhirVisionPrescriptionDispenseList;
begin
  if FDispenseList = nil then
    FDispenseList := TFhirVisionPrescriptionDispenseList.Create;
  result := FDispenseList;
end;

Function TFhirVisionPrescription.GetHasDispenseList : boolean;
begin
  result := (FDispenseList <> nil) and (FDispenseList.count > 0);
end;

function TFhirVisionPrescription.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FPatient.sizeInBytes);
  inc(result, FEncounter.sizeInBytes);
  inc(result, FDateWritten.sizeInBytes);
  inc(result, FPrescriber.sizeInBytes);
  inc(result, FReason.sizeInBytes);
  inc(result, FdispenseList.sizeInBytes);
end;

{ TFhirVisionPrescriptionListEnumerator }

Constructor TFhirVisionPrescriptionListEnumerator.Create(list : TFhirVisionPrescriptionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirVisionPrescriptionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirVisionPrescriptionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirVisionPrescriptionListEnumerator.GetCurrent : TFhirVisionPrescription;
begin
  Result := FList[FIndex];
end;

function TFhirVisionPrescriptionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirVisionPrescriptionList }
procedure TFhirVisionPrescriptionList.AddItem(value: TFhirVisionPrescription);
begin
  assert(value.ClassName = 'TFhirVisionPrescription', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirVisionPrescription');
  add(value);
end;

function TFhirVisionPrescriptionList.Append: TFhirVisionPrescription;
begin
  result := TFhirVisionPrescription.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVisionPrescriptionList.ClearItems;
begin
  Clear;
end;

function TFhirVisionPrescriptionList.GetEnumerator : TFhirVisionPrescriptionListEnumerator;
begin
  result := TFhirVisionPrescriptionListEnumerator.Create(self.link);
end;

function TFhirVisionPrescriptionList.Clone: TFhirVisionPrescriptionList;
begin
  result := TFhirVisionPrescriptionList(inherited Clone);
end;

function TFhirVisionPrescriptionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirVisionPrescriptionList.GetItemN(index: Integer): TFhirVisionPrescription;
begin
  result := TFhirVisionPrescription(ObjectByIndex[index]);
end;

function TFhirVisionPrescriptionList.ItemClass: TFslObjectClass;
begin
  result := TFhirVisionPrescription;
end;
function TFhirVisionPrescriptionList.IndexOf(value: TFhirVisionPrescription): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirVisionPrescriptionList.Insert(index: Integer): TFhirVisionPrescription;
begin
  result := TFhirVisionPrescription.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVisionPrescriptionList.InsertItem(index: Integer; value: TFhirVisionPrescription);
begin
  assert(value is TFhirVisionPrescription);
  Inherited Insert(index, value);
end;

function TFhirVisionPrescriptionList.Item(index: Integer): TFhirVisionPrescription;
begin
  result := TFhirVisionPrescription(ObjectByIndex[index]);
end;

function TFhirVisionPrescriptionList.Link: TFhirVisionPrescriptionList;
begin
  result := TFhirVisionPrescriptionList(inherited Link);
end;

procedure TFhirVisionPrescriptionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirVisionPrescriptionList.SetItemByIndex(index: Integer; value: TFhirVisionPrescription);
begin
  assert(value is TFhirVisionPrescription);
  FhirVisionPrescriptions[index] := value;
end;

procedure TFhirVisionPrescriptionList.SetItemN(index: Integer; value: TFhirVisionPrescription);
begin
  assert(value is TFhirVisionPrescription);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_VISIONPRESCRIPTION}

end.

