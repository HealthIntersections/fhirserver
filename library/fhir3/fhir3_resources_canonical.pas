unit fhir3_resources_canonical;

{
  Copyright (c) 2011+, HL7 and Health Intersections Pty Ltd (http://www.healthintersections.com.au)
  All rights reserved.

  Redistribution and use in source and binary forms, with or without modification,
  are permitted provided that the following conditions are met:

   * Redistributions of source code must retain the above copyright notice, this
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice,
     this list of conditions and the following disclaimer in the documentation
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to
     endorse or promote products derived from this software without specific
     prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.

}

{$I fhir.inc}
{$I fhir3.inc}

interface

// FHIR v3.0.1 generated 2018-06-12T19:15:59+10:00

uses
  SysUtils, Classes,
  fsl_base, fsl_utilities, fsl_stream,
  fhir_objects, fhir_utilities, 
  fhir3_base, fhir3_types, fhir3_resources_base;

type
  TFhirMetadataResourceList = class;
  TFhirMetadataResource = class;
{$IFDEF FHIR_ACTIVITYDEFINITION}
  TFhirActivityDefinitionParticipant = class;
  TFhirActivityDefinitionParticipantList = class;
  TFhirActivityDefinitionDynamicValue = class;
  TFhirActivityDefinitionDynamicValueList = class;
  TFhirActivityDefinition = class;
  TFhirActivityDefinitionList = class;
{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_CAPABILITYSTATEMENT}
  TFhirCapabilityStatementSoftware = class;
  TFhirCapabilityStatementSoftwareList = class;
  TFhirCapabilityStatementImplementation = class;
  TFhirCapabilityStatementImplementationList = class;
  TFhirCapabilityStatementRest = class;
  TFhirCapabilityStatementRestList = class;
  TFhirCapabilityStatementRestSecurity = class;
  TFhirCapabilityStatementRestSecurityList = class;
  TFhirCapabilityStatementRestSecurityCertificate = class;
  TFhirCapabilityStatementRestSecurityCertificateList = class;
  TFhirCapabilityStatementRestResource = class;
  TFhirCapabilityStatementRestResourceList = class;
  TFhirCapabilityStatementRestResourceInteraction = class;
  TFhirCapabilityStatementRestResourceInteractionList = class;
  TFhirCapabilityStatementRestResourceSearchParam = class;
  TFhirCapabilityStatementRestResourceSearchParamList = class;
  TFhirCapabilityStatementRestInteraction = class;
  TFhirCapabilityStatementRestInteractionList = class;
  TFhirCapabilityStatementRestOperation = class;
  TFhirCapabilityStatementRestOperationList = class;
  TFhirCapabilityStatementMessaging = class;
  TFhirCapabilityStatementMessagingList = class;
  TFhirCapabilityStatementMessagingEndpoint = class;
  TFhirCapabilityStatementMessagingEndpointList = class;
  TFhirCapabilityStatementMessagingSupportedMessage = class;
  TFhirCapabilityStatementMessagingSupportedMessageList = class;
  TFhirCapabilityStatementMessagingEvent = class;
  TFhirCapabilityStatementMessagingEventList = class;
  TFhirCapabilityStatementDocument = class;
  TFhirCapabilityStatementDocumentList = class;
  TFhirCapabilityStatement = class;
  TFhirCapabilityStatementList = class;
{$ENDIF FHIR_CAPABILITYSTATEMENT}
{$IFDEF FHIR_CODESYSTEM}
  TFhirCodeSystemFilter = class;
  TFhirCodeSystemFilterList = class;
  TFhirCodeSystemProperty = class;
  TFhirCodeSystemPropertyList = class;
  TFhirCodeSystemConcept = class;
  TFhirCodeSystemConceptList = class;
  TFhirCodeSystemConceptDesignation = class;
  TFhirCodeSystemConceptDesignationList = class;
  TFhirCodeSystemConceptProperty = class;
  TFhirCodeSystemConceptPropertyList = class;
  TFhirCodeSystem = class;
  TFhirCodeSystemList = class;
{$ENDIF FHIR_CODESYSTEM}
{$IFDEF FHIR_COMPARTMENTDEFINITION}
  TFhirCompartmentDefinitionResource = class;
  TFhirCompartmentDefinitionResourceList = class;
  TFhirCompartmentDefinition = class;
  TFhirCompartmentDefinitionList = class;
{$ENDIF FHIR_COMPARTMENTDEFINITION}
{$IFDEF FHIR_CONCEPTMAP}
  TFhirConceptMapGroup = class;
  TFhirConceptMapGroupList = class;
  TFhirConceptMapGroupElement = class;
  TFhirConceptMapGroupElementList = class;
  TFhirConceptMapGroupElementTarget = class;
  TFhirConceptMapGroupElementTargetList = class;
  TFhirConceptMapGroupElementTargetDependsOn = class;
  TFhirConceptMapGroupElementTargetDependsOnList = class;
  TFhirConceptMapGroupUnmapped = class;
  TFhirConceptMapGroupUnmappedList = class;
  TFhirConceptMap = class;
  TFhirConceptMapList = class;
{$ENDIF FHIR_CONCEPTMAP}
{$IFDEF FHIR_DATAELEMENT}
  TFhirDataElementMapping = class;
  TFhirDataElementMappingList = class;
  TFhirDataElement = class;
  TFhirDataElementList = class;
{$ENDIF FHIR_DATAELEMENT}
{$IFDEF FHIR_EXPANSIONPROFILE}
  TFhirExpansionProfileFixedVersion = class;
  TFhirExpansionProfileFixedVersionList = class;
  TFhirExpansionProfileExcludedSystem = class;
  TFhirExpansionProfileExcludedSystemList = class;
  TFhirExpansionProfileDesignation = class;
  TFhirExpansionProfileDesignationList = class;
  TFhirExpansionProfileDesignationInclude = class;
  TFhirExpansionProfileDesignationIncludeList = class;
  TFhirExpansionProfileDesignationIncludeDesignation = class;
  TFhirExpansionProfileDesignationIncludeDesignationList = class;
  TFhirExpansionProfileDesignationExclude = class;
  TFhirExpansionProfileDesignationExcludeList = class;
  TFhirExpansionProfileDesignationExcludeDesignation = class;
  TFhirExpansionProfileDesignationExcludeDesignationList = class;
  TFhirExpansionProfile = class;
  TFhirExpansionProfileList = class;
{$ENDIF FHIR_EXPANSIONPROFILE}
{$IFDEF FHIR_GRAPHDEFINITION}
  TFhirGraphDefinitionLink = class;
  TFhirGraphDefinitionLinkList = class;
  TFhirGraphDefinitionLinkTarget = class;
  TFhirGraphDefinitionLinkTargetList = class;
  TFhirGraphDefinitionLinkTargetCompartment = class;
  TFhirGraphDefinitionLinkTargetCompartmentList = class;
  TFhirGraphDefinition = class;
  TFhirGraphDefinitionList = class;
{$ENDIF FHIR_GRAPHDEFINITION}
{$IFDEF FHIR_IMPLEMENTATIONGUIDE}
  TFhirImplementationGuideDependency = class;
  TFhirImplementationGuideDependencyList = class;
  TFhirImplementationGuidePackage = class;
  TFhirImplementationGuidePackageList = class;
  TFhirImplementationGuidePackageResource = class;
  TFhirImplementationGuidePackageResourceList = class;
  TFhirImplementationGuideGlobal = class;
  TFhirImplementationGuideGlobalList = class;
  TFhirImplementationGuidePage = class;
  TFhirImplementationGuidePageList = class;
  TFhirImplementationGuide = class;
  TFhirImplementationGuideList = class;
{$ENDIF FHIR_IMPLEMENTATIONGUIDE}
{$IFDEF FHIR_LIBRARY}
  TFhirLibrary = class;
  TFhirLibraryList = class;
{$ENDIF FHIR_LIBRARY}
{$IFDEF FHIR_MEASURE}
  TFhirMeasureGroup = class;
  TFhirMeasureGroupList = class;
  TFhirMeasureGroupPopulation = class;
  TFhirMeasureGroupPopulationList = class;
  TFhirMeasureGroupStratifier = class;
  TFhirMeasureGroupStratifierList = class;
  TFhirMeasureSupplementalData = class;
  TFhirMeasureSupplementalDataList = class;
  TFhirMeasure = class;
  TFhirMeasureList = class;
{$ENDIF FHIR_MEASURE}
{$IFDEF FHIR_MESSAGEDEFINITION}
  TFhirMessageDefinitionFocus = class;
  TFhirMessageDefinitionFocusList = class;
  TFhirMessageDefinitionAllowedResponse = class;
  TFhirMessageDefinitionAllowedResponseList = class;
  TFhirMessageDefinition = class;
  TFhirMessageDefinitionList = class;
{$ENDIF FHIR_MESSAGEDEFINITION}
{$IFDEF FHIR_NAMINGSYSTEM}
  TFhirNamingSystemUniqueId = class;
  TFhirNamingSystemUniqueIdList = class;
  TFhirNamingSystem = class;
  TFhirNamingSystemList = class;
{$ENDIF FHIR_NAMINGSYSTEM}
{$IFDEF FHIR_OPERATIONDEFINITION}
  TFhirOperationDefinitionParameter = class;
  TFhirOperationDefinitionParameterList = class;
  TFhirOperationDefinitionParameterBinding = class;
  TFhirOperationDefinitionParameterBindingList = class;
  TFhirOperationDefinitionOverload = class;
  TFhirOperationDefinitionOverloadList = class;
  TFhirOperationDefinition = class;
  TFhirOperationDefinitionList = class;
{$ENDIF FHIR_OPERATIONDEFINITION}
{$IFDEF FHIR_PLANDEFINITION}
  TFhirPlanDefinitionGoal = class;
  TFhirPlanDefinitionGoalList = class;
  TFhirPlanDefinitionGoalTarget = class;
  TFhirPlanDefinitionGoalTargetList = class;
  TFhirPlanDefinitionAction = class;
  TFhirPlanDefinitionActionList = class;
  TFhirPlanDefinitionActionCondition = class;
  TFhirPlanDefinitionActionConditionList = class;
  TFhirPlanDefinitionActionRelatedAction = class;
  TFhirPlanDefinitionActionRelatedActionList = class;
  TFhirPlanDefinitionActionParticipant = class;
  TFhirPlanDefinitionActionParticipantList = class;
  TFhirPlanDefinitionActionDynamicValue = class;
  TFhirPlanDefinitionActionDynamicValueList = class;
  TFhirPlanDefinition = class;
  TFhirPlanDefinitionList = class;
{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_QUESTIONNAIRE}
  TFhirQuestionnaireItem = class;
  TFhirQuestionnaireItemList = class;
  TFhirQuestionnaireItemEnableWhen = class;
  TFhirQuestionnaireItemEnableWhenList = class;
  TFhirQuestionnaireItemOption = class;
  TFhirQuestionnaireItemOptionList = class;
  TFhirQuestionnaire = class;
  TFhirQuestionnaireList = class;
{$ENDIF FHIR_QUESTIONNAIRE}
{$IFDEF FHIR_REQUESTGROUP}
  TFhirRequestGroupAction = class;
  TFhirRequestGroupActionList = class;
  TFhirRequestGroupActionCondition = class;
  TFhirRequestGroupActionConditionList = class;
  TFhirRequestGroupActionRelatedAction = class;
  TFhirRequestGroupActionRelatedActionList = class;
  TFhirRequestGroup = class;
  TFhirRequestGroupList = class;
{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_SEARCHPARAMETER}
  TFhirSearchParameterComponent = class;
  TFhirSearchParameterComponentList = class;
  TFhirSearchParameter = class;
  TFhirSearchParameterList = class;
{$ENDIF FHIR_SEARCHPARAMETER}
{$IFDEF FHIR_SERVICEDEFINITION}
  TFhirServiceDefinition = class;
  TFhirServiceDefinitionList = class;
{$ENDIF FHIR_SERVICEDEFINITION}
{$IFDEF FHIR_STRUCTUREDEFINITION}
  TFhirStructureDefinitionMapping = class;
  TFhirStructureDefinitionMappingList = class;
  TFhirStructureDefinitionSnapshot = class;
  TFhirStructureDefinitionSnapshotList = class;
  TFhirStructureDefinitionDifferential = class;
  TFhirStructureDefinitionDifferentialList = class;
  TFhirStructureDefinition = class;
  TFhirStructureDefinitionList = class;
{$ENDIF FHIR_STRUCTUREDEFINITION}
{$IFDEF FHIR_STRUCTUREMAP}
  TFhirStructureMapStructure = class;
  TFhirStructureMapStructureList = class;
  TFhirStructureMapGroup = class;
  TFhirStructureMapGroupList = class;
  TFhirStructureMapGroupInput = class;
  TFhirStructureMapGroupInputList = class;
  TFhirStructureMapGroupRule = class;
  TFhirStructureMapGroupRuleList = class;
  TFhirStructureMapGroupRuleSource = class;
  TFhirStructureMapGroupRuleSourceList = class;
  TFhirStructureMapGroupRuleTarget = class;
  TFhirStructureMapGroupRuleTargetList = class;
  TFhirStructureMapGroupRuleTargetParameter = class;
  TFhirStructureMapGroupRuleTargetParameterList = class;
  TFhirStructureMapGroupRuleDependent = class;
  TFhirStructureMapGroupRuleDependentList = class;
  TFhirStructureMap = class;
  TFhirStructureMapList = class;
{$ENDIF FHIR_STRUCTUREMAP}
{$IFDEF FHIR_TESTSCRIPT}
  TFhirTestScriptOrigin = class;
  TFhirTestScriptOriginList = class;
  TFhirTestScriptDestination = class;
  TFhirTestScriptDestinationList = class;
  TFhirTestScriptMetadata = class;
  TFhirTestScriptMetadataList = class;
  TFhirTestScriptMetadataLink = class;
  TFhirTestScriptMetadataLinkList = class;
  TFhirTestScriptMetadataCapability = class;
  TFhirTestScriptMetadataCapabilityList = class;
  TFhirTestScriptFixture = class;
  TFhirTestScriptFixtureList = class;
  TFhirTestScriptVariable = class;
  TFhirTestScriptVariableList = class;
  TFhirTestScriptRule = class;
  TFhirTestScriptRuleList = class;
  TFhirTestScriptRuleParam = class;
  TFhirTestScriptRuleParamList = class;
  TFhirTestScriptRuleset = class;
  TFhirTestScriptRulesetList = class;
  TFhirTestScriptRulesetRule = class;
  TFhirTestScriptRulesetRuleList = class;
  TFhirTestScriptRulesetRuleParam = class;
  TFhirTestScriptRulesetRuleParamList = class;
  TFhirTestScriptSetup = class;
  TFhirTestScriptSetupList = class;
  TFhirTestScriptSetupAction = class;
  TFhirTestScriptSetupActionList = class;
  TFhirTestScriptSetupActionOperation = class;
  TFhirTestScriptSetupActionOperationList = class;
  TFhirTestScriptSetupActionOperationRequestHeader = class;
  TFhirTestScriptSetupActionOperationRequestHeaderList = class;
  TFhirTestScriptSetupActionAssert = class;
  TFhirTestScriptSetupActionAssertList = class;
  TFhirTestScriptSetupActionAssertRule = class;
  TFhirTestScriptSetupActionAssertRuleList = class;
  TFhirTestScriptSetupActionAssertRuleParam = class;
  TFhirTestScriptSetupActionAssertRuleParamList = class;
  TFhirTestScriptSetupActionAssertRuleset = class;
  TFhirTestScriptSetupActionAssertRulesetList = class;
  TFhirTestScriptSetupActionAssertRulesetRule = class;
  TFhirTestScriptSetupActionAssertRulesetRuleList = class;
  TFhirTestScriptSetupActionAssertRulesetRuleParam = class;
  TFhirTestScriptSetupActionAssertRulesetRuleParamList = class;
  TFhirTestScriptTest = class;
  TFhirTestScriptTestList = class;
  TFhirTestScriptTestAction = class;
  TFhirTestScriptTestActionList = class;
  TFhirTestScriptTeardown = class;
  TFhirTestScriptTeardownList = class;
  TFhirTestScriptTeardownAction = class;
  TFhirTestScriptTeardownActionList = class;
  TFhirTestScript = class;
  TFhirTestScriptList = class;
{$ENDIF FHIR_TESTSCRIPT}
{$IFDEF FHIR_VALUESET}
  TFhirValueSetCompose = class;
  TFhirValueSetComposeList = class;
  TFhirValueSetComposeInclude = class;
  TFhirValueSetComposeIncludeList = class;
  TFhirValueSetComposeIncludeConcept = class;
  TFhirValueSetComposeIncludeConceptList = class;
  TFhirValueSetComposeIncludeConceptDesignation = class;
  TFhirValueSetComposeIncludeConceptDesignationList = class;
  TFhirValueSetComposeIncludeFilter = class;
  TFhirValueSetComposeIncludeFilterList = class;
  TFhirValueSetExpansion = class;
  TFhirValueSetExpansionList = class;
  TFhirValueSetExpansionParameter = class;
  TFhirValueSetExpansionParameterList = class;
  TFhirValueSetExpansionContains = class;
  TFhirValueSetExpansionContainsList = class;
  TFhirValueSet = class;
  TFhirValueSetList = class;
{$ENDIF FHIR_VALUESET}

  // Common Ancestor declaration for conformance and knowledge artifact resources.
  TFhirMetadataResource = class abstract (TFhirDomainResource)
  protected
    FUrl : TFhirUri;
    FVersion : TFhirString;
    FName : TFhirString;
    FTitle : TFhirString;
    FStatus : TFhirEnum;
    FExperimental : TFhirBoolean;
    FDate : TFhirDateTime;
    FPublisher : TFhirString;
    FcontactList : TFhirContactDetailList;
    FuseContextList : TFhirUsageContextList;
    FjurisdictionList : TFhirCodeableConceptList;
    FDescription : TFhirMarkdown;
    Procedure SetUrl(value : TFhirUri);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);
    Procedure SetVersion(value : TFhirString);
    Function GetVersionST : String;
    Procedure SetVersionST(value : String);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetTitle(value : TFhirString);
    Function GetTitleST : String;
    Procedure SetTitleST(value : String);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirPublicationStatusEnum;
    Procedure SetStatusST(value : TFhirPublicationStatusEnum);
    Procedure SetExperimental(value : TFhirBoolean);
    Function GetExperimentalST : Boolean;
    Procedure SetExperimentalST(value : Boolean);
    Procedure SetDate(value : TFhirDateTime);
    Function GetDateST : TFslDateTime;
    Procedure SetDateST(value : TFslDateTime);
    Procedure SetPublisher(value : TFhirString);
    Function GetPublisherST : String;
    Procedure SetPublisherST(value : String);
    function GetContactList : TFhirContactDetailList;
    function GetHasContactList : Boolean;
    function GetUseContextList : TFhirUsageContextList;
    function GetHasUseContextList : Boolean;
    function GetJurisdictionList : TFhirCodeableConceptList;
    function GetHasJurisdictionList : Boolean;
    Procedure SetDescription(value : TFhirMarkdown);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMetadataResource; overload;
    function Clone : TFhirMetadataResource; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this metadata resource when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this metadata resource is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the metadata resource. For more information see [Technical and Business Versions](resource.html#versions).
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this metadata resource when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this metadata resource is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the metadata resource. For more information see [Technical and Business Versions](resource.html#versions).
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to The identifier that is used to identify this version of the metadata resource when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the metadata resource author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the metadata resource when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the metadata resource author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the metadata resource. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the metadata resource. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the metadata resource.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the metadata resource.
    property titleElement : TFhirString read FTitle write SetTitle;

    // The status of this metadata resource. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A boolean value to indicate that this metadata resource is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A boolean value to indicate that this metadata resource is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The date  (and optionally time) when the metadata resource was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the metadata resource changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the metadata resource was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the metadata resource changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the metadata resource.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the metadata resource.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These terms may be used to assist with indexing and searching for appropriate metadata resource instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the metadata resource is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to A free text natural language description of the metadata resource from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the metadata resource from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

  end;

  TFhirMetadataResourceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMetadataResourceList;
    function GetCurrent : TFhirMetadataResource;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMetadataResourceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMetadataResource read GetCurrent;
  end;

  TFhirMetadataResourceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMetadataResource;
    procedure SetItemN(index : Integer; value : TFhirMetadataResource);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMetadataResourceList; Overload;
    function Clone : TFhirMetadataResourceList; Overload;
    function GetEnumerator : TFhirMetadataResourceListEnumerator;

    // Add an already existing FhirMetadataResource to the end of the list.
    procedure AddItem(value : TFhirMetadataResource); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMetadataResource) : Integer;

    // Insert an existing FhirMetadataResource before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMetadataResource);

    // Get the iIndexth FhirMetadataResource. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMetadataResource);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMetadataResource;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMetadataResources[index : Integer] : TFhirMetadataResource read GetItemN write SetItemN; default;
  End;

{$IFDEF FHIR_ACTIVITYDEFINITION}

  // Indicates who should participate in performing the action described.
  TFhirActivityDefinitionParticipant = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FRole : TFhirCodeableConcept;
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirActionParticipantTypeEnum;
    Procedure SetType_ST(value : TFhirActionParticipantTypeEnum);
    Procedure SetRole(value : TFhirCodeableConcept);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirActivityDefinitionParticipant; overload;
    function Clone : TFhirActivityDefinitionParticipant; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The type of participant in the action.
    property type_ : TFhirActionParticipantTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The role the participant should play in performing the described action. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // The role the participant should play in performing the described action.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

  end;

  TFhirActivityDefinitionParticipantListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirActivityDefinitionParticipantList;
    function GetCurrent : TFhirActivityDefinitionParticipant;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirActivityDefinitionParticipantList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirActivityDefinitionParticipant read GetCurrent;
  end;

  TFhirActivityDefinitionParticipantList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirActivityDefinitionParticipant;
    procedure SetItemN(index : Integer; value : TFhirActivityDefinitionParticipant);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirActivityDefinitionParticipantList; Overload;
    function Clone : TFhirActivityDefinitionParticipantList; Overload;
    function GetEnumerator : TFhirActivityDefinitionParticipantListEnumerator;

    //  Add a FhirActivityDefinitionParticipant to the end of the list.
    function Append : TFhirActivityDefinitionParticipant;

    // Add an already existing FhirActivityDefinitionParticipant to the end of the list.
    procedure AddItem(value : TFhirActivityDefinitionParticipant); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirActivityDefinitionParticipant) : Integer;

    // Insert FhirActivityDefinitionParticipant before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirActivityDefinitionParticipant;

    // Insert an existing FhirActivityDefinitionParticipant before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirActivityDefinitionParticipant);

    // Get the iIndexth FhirActivityDefinitionParticipant. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirActivityDefinitionParticipant);

    // The number of items in the collection
    function Item(index : Integer) : TFhirActivityDefinitionParticipant;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirActivityDefinitionParticipants[index : Integer] : TFhirActivityDefinitionParticipant read GetItemN write SetItemN; default;
  End;

  // Dynamic values that will be evaluated to produce values for elements of the resulting resource. For example, if the dosage of a medication must be computed based on the patient's weight, a dynamic value would be used to specify an expression that calculated the weight, and the path on the intent resource that would contain the result.
  TFhirActivityDefinitionDynamicValue = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FPath : TFhirString;
    FLanguage : TFhirString;
    FExpression : TFhirString;
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetPath(value : TFhirString);
    Function GetPathST : String;
    Procedure SetPathST(value : String);
    Procedure SetLanguage(value : TFhirString);
    Function GetLanguageST : String;
    Procedure SetLanguageST(value : String);
    Procedure SetExpression(value : TFhirString);
    Function GetExpressionST : String;
    Procedure SetExpressionST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirActivityDefinitionDynamicValue; overload;
    function Clone : TFhirActivityDefinitionDynamicValue; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A brief, natural language description of the intended semantics of the dynamic value.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A brief, natural language description of the intended semantics of the dynamic value.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to The path to the element to be customized. This is the path on the resource that will hold the result of the calculation defined by the expression.
    property path : String read GetPathST write SetPathST;
    // The path to the element to be customized. This is the path on the resource that will hold the result of the calculation defined by the expression.
    property pathElement : TFhirString read FPath write SetPath;

    // Typed access to The media type of the language for the expression.
    property language : String read GetLanguageST write SetLanguageST;
    // The media type of the language for the expression.
    property languageElement : TFhirString read FLanguage write SetLanguage;

    // Typed access to An expression specifying the value of the customized element.
    property expression : String read GetExpressionST write SetExpressionST;
    // An expression specifying the value of the customized element.
    property expressionElement : TFhirString read FExpression write SetExpression;

  end;

  TFhirActivityDefinitionDynamicValueListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirActivityDefinitionDynamicValueList;
    function GetCurrent : TFhirActivityDefinitionDynamicValue;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirActivityDefinitionDynamicValueList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirActivityDefinitionDynamicValue read GetCurrent;
  end;

  TFhirActivityDefinitionDynamicValueList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirActivityDefinitionDynamicValue;
    procedure SetItemN(index : Integer; value : TFhirActivityDefinitionDynamicValue);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirActivityDefinitionDynamicValueList; Overload;
    function Clone : TFhirActivityDefinitionDynamicValueList; Overload;
    function GetEnumerator : TFhirActivityDefinitionDynamicValueListEnumerator;

    //  Add a FhirActivityDefinitionDynamicValue to the end of the list.
    function Append : TFhirActivityDefinitionDynamicValue;

    // Add an already existing FhirActivityDefinitionDynamicValue to the end of the list.
    procedure AddItem(value : TFhirActivityDefinitionDynamicValue); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirActivityDefinitionDynamicValue) : Integer;

    // Insert FhirActivityDefinitionDynamicValue before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirActivityDefinitionDynamicValue;

    // Insert an existing FhirActivityDefinitionDynamicValue before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirActivityDefinitionDynamicValue);

    // Get the iIndexth FhirActivityDefinitionDynamicValue. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirActivityDefinitionDynamicValue);

    // The number of items in the collection
    function Item(index : Integer) : TFhirActivityDefinitionDynamicValue;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirActivityDefinitionDynamicValues[index : Integer] : TFhirActivityDefinitionDynamicValue read GetItemN write SetItemN; default;
  End;

  // This resource allows for the definition of some activity to be performed, independent of a particular patient, practitioner, or other performance context.
  TFhirActivityDefinition = class (TFhirMetadataResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FPurpose : TFhirMarkdown;
    FUsage : TFhirString;
    FApprovalDate : TFhirDate;
    FLastReviewDate : TFhirDate;
    FEffectivePeriod : TFhirPeriod;
    FtopicList : TFhirCodeableConceptList;
    FcontributorList : TFhirContributorList;
    FCopyright : TFhirMarkdown;
    FrelatedArtifactList : TFhirRelatedArtifactList;
    Flibrary_List : TFhirReferenceList{TFhirLibrary};
    FKind : TFhirEnum;
    FCode : TFhirCodeableConcept;
    FTiming : TFhirType;
    FLocation : TFhirReference{TFhirLocation};
    FparticipantList : TFhirActivityDefinitionParticipantList;
    FProduct : TFhirType;
    FQuantity : TFhirQuantity;
    FdosageList : TFhirDosageList;
    FbodySiteList : TFhirCodeableConceptList;
    FTransform : TFhirReference{TFhirStructureMap};
    FdynamicValueList : TFhirActivityDefinitionDynamicValueList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetPurpose(value : TFhirMarkdown);
    Function GetPurposeST : String;
    Procedure SetPurposeST(value : String);
    Procedure SetUsage(value : TFhirString);
    Function GetUsageST : String;
    Procedure SetUsageST(value : String);
    Procedure SetApprovalDate(value : TFhirDate);
    Function GetApprovalDateST : TFslDateTime;
    Procedure SetApprovalDateST(value : TFslDateTime);
    Procedure SetLastReviewDate(value : TFhirDate);
    Function GetLastReviewDateST : TFslDateTime;
    Procedure SetLastReviewDateST(value : TFslDateTime);
    Procedure SetEffectivePeriod(value : TFhirPeriod);
    function GetTopicList : TFhirCodeableConceptList;
    function GetHasTopicList : Boolean;
    function GetContributorList : TFhirContributorList;
    function GetHasContributorList : Boolean;
    Procedure SetCopyright(value : TFhirMarkdown);
    Function GetCopyrightST : String;
    Procedure SetCopyrightST(value : String);
    function GetRelatedArtifactList : TFhirRelatedArtifactList;
    function GetHasRelatedArtifactList : Boolean;
    function GetLibrary_List : TFhirReferenceList{TFhirLibrary};
    function GetHasLibrary_List : Boolean;
    Procedure SetKind(value : TFhirEnum);
    Function GetKindST : TFhirResourceTypesEnum;
    Procedure SetKindST(value : TFhirResourceTypesEnum);
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetTiming(value : TFhirType);
    Procedure SetLocation(value : TFhirReference{TFhirLocation});
    function GetParticipantList : TFhirActivityDefinitionParticipantList;
    function GetHasParticipantList : Boolean;
    Procedure SetProduct(value : TFhirType);
    Procedure SetQuantity(value : TFhirQuantity);
    function GetDosageList : TFhirDosageList;
    function GetHasDosageList : Boolean;
    function GetBodySiteList : TFhirCodeableConceptList;
    function GetHasBodySiteList : Boolean;
    Procedure SetTransform(value : TFhirReference{TFhirStructureMap});
    function GetDynamicValueList : TFhirActivityDefinitionDynamicValueList;
    function GetHasDynamicValueList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirActivityDefinition; overload;
    function Clone : TFhirActivityDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this activity definition when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this activity definition is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the activity definition. For more information see [Technical and Business Versions](resource.html#versions).
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this activity definition when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this activity definition is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the activity definition. For more information see [Technical and Business Versions](resource.html#versions).
    property urlElement : TFhirUri read FUrl write SetUrl;

    // A formal identifier that is used to identify this activity definition when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the activity definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the activity definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. To provide a version consistent with the Decision Support Service specification, use the format Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge assets, refer to the Decision Support Service specification. Note that a version is required for non-experimental active assets.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the activity definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the activity definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. To provide a version consistent with the Decision Support Service specification, use the format Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge assets, refer to the Decision Support Service specification. Note that a version is required for non-experimental active assets.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the activity definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the activity definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the activity definition.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the activity definition.
    property titleElement : TFhirString read FTitle write SetTitle;

    // The status of this activity definition. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A boolean value to indicate that this activity definition is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A boolean value to indicate that this activity definition is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The date  (and optionally time) when the activity definition was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the activity definition changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the activity definition was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the activity definition changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the activity definition.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the activity definition.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Typed access to A free text natural language description of the activity definition from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the activity definition from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // Typed access to Explaination of why this activity definition is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explaination of why this activity definition is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Typed access to A detailed description of how the asset is used from a clinical perspective.
    property usage : String read GetUsageST write SetUsageST;
    // A detailed description of how the asset is used from a clinical perspective.
    property usageElement : TFhirString read FUsage write SetUsage;

    // Typed access to The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDate : TFslDateTime read GetApprovalDateST write SetApprovalDateST;
    // The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDateElement : TFhirDate read FApprovalDate write SetApprovalDate;

    // Typed access to The date on which the resource content was last reviewed. Review happens periodically after approval, but doesn't change the original approval date.
    property lastReviewDate : TFslDateTime read GetLastReviewDateST write SetLastReviewDateST;
    // The date on which the resource content was last reviewed. Review happens periodically after approval, but doesn't change the original approval date.
    property lastReviewDateElement : TFhirDate read FLastReviewDate write SetLastReviewDate;

    // Typed access to The period during which the activity definition content was or is planned to be in active use. (defined for API consistency)
    property effectivePeriod : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;
    // The period during which the activity definition content was or is planned to be in active use.
    property effectivePeriodElement : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These terms may be used to assist with indexing and searching for appropriate activity definition instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the activity definition is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Descriptive topics related to the content of the activity. Topics provide a high-level categorization of the activity that can be useful for filtering and searching.
    property topicList : TFhirCodeableConceptList read GetTopicList;
    property hasTopicList : boolean read GetHasTopicList;

    // A contributor to the content of the asset, including authors, editors, reviewers, and endorsers.
    property contributorList : TFhirContributorList read GetContributorList;
    property hasContributorList : boolean read GetHasContributorList;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A copyright statement relating to the activity definition and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the activity definition.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the activity definition and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the activity definition.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // Related artifacts such as additional documentation, justification, or bibliographic references.
    property relatedArtifactList : TFhirRelatedArtifactList read GetRelatedArtifactList;
    property hasRelatedArtifactList : boolean read GetHasRelatedArtifactList;

    // A reference to a Library resource containing any formal logic used by the asset.
    property library_List : TFhirReferenceList{TFhirLibrary} read GetLibrary_List;
    property hasLibrary_List : boolean read GetHasLibrary_List;

    // A description of the kind of resource the activity definition is representing. For example, a MedicationRequest, a ProcedureRequest, or a CommunicationRequest. Typically, but not always, this is a Request resource.
    property kind : TFhirResourceTypesEnum read GetKindST write SetKindST;
    property kindElement : TFhirEnum read FKind write SetKind;

    // Typed access to Detailed description of the type of activity; e.g. What lab test, what procedure, what kind of encounter. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Detailed description of the type of activity; e.g. What lab test, what procedure, what kind of encounter.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The period, timing or frequency upon which the described activity is to occur. (defined for API consistency)
    property timing : TFhirType read FTiming write SetTiming;
    // The period, timing or frequency upon which the described activity is to occur.
    property timingElement : TFhirType read FTiming write SetTiming;

    // Typed access to Identifies the facility where the activity will occur; e.g. home, hospital, specific clinic, etc. (defined for API consistency)
    property location : TFhirReference{TFhirLocation} read FLocation write SetLocation;
    // Identifies the facility where the activity will occur; e.g. home, hospital, specific clinic, etc.
    property locationElement : TFhirReference{TFhirLocation} read FLocation write SetLocation;

    // Indicates who should participate in performing the action described.
    property participantList : TFhirActivityDefinitionParticipantList read GetParticipantList;
    property hasParticipantList : boolean read GetHasParticipantList;

    // Typed access to Identifies the food, drug or other product being consumed or supplied in the activity. (defined for API consistency)
    property product : TFhirType read FProduct write SetProduct;
    // Identifies the food, drug or other product being consumed or supplied in the activity.
    property productElement : TFhirType read FProduct write SetProduct;

    // Typed access to Identifies the quantity expected to be consumed at once (per dose, per meal, etc.). (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // Identifies the quantity expected to be consumed at once (per dose, per meal, etc.).
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Provides detailed dosage instructions in the same way that they are described for MedicationRequest resources.
    property dosageList : TFhirDosageList read GetDosageList;
    property hasDosageList : boolean read GetHasDosageList;

    // Indicates the sites on the subject's body where the procedure should be performed (I.e. the target sites).
    property bodySiteList : TFhirCodeableConceptList read GetBodySiteList;
    property hasBodySiteList : boolean read GetHasBodySiteList;

    // Typed access to A reference to a StructureMap resource that defines a transform that can be executed to produce the intent resource using the ActivityDefinition instance as the input. (defined for API consistency)
    property transform : TFhirReference{TFhirStructureMap} read FTransform write SetTransform;
    // A reference to a StructureMap resource that defines a transform that can be executed to produce the intent resource using the ActivityDefinition instance as the input.
    property transformElement : TFhirReference{TFhirStructureMap} read FTransform write SetTransform;

    // Dynamic values that will be evaluated to produce values for elements of the resulting resource. For example, if the dosage of a medication must be computed based on the patient's weight, a dynamic value would be used to specify an expression that calculated the weight, and the path on the intent resource that would contain the result.
    property dynamicValueList : TFhirActivityDefinitionDynamicValueList read GetDynamicValueList;
    property hasDynamicValueList : boolean read GetHasDynamicValueList;

  end;

  TFhirActivityDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirActivityDefinitionList;
    function GetCurrent : TFhirActivityDefinition;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirActivityDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirActivityDefinition read GetCurrent;
  end;

  TFhirActivityDefinitionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirActivityDefinition;
    procedure SetItemN(index : Integer; value : TFhirActivityDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirActivityDefinitionList; Overload;
    function Clone : TFhirActivityDefinitionList; Overload;
    function GetEnumerator : TFhirActivityDefinitionListEnumerator;

    //  Add a FhirActivityDefinition to the end of the list.
    function Append : TFhirActivityDefinition;

    // Add an already existing FhirActivityDefinition to the end of the list.
    procedure AddItem(value : TFhirActivityDefinition); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirActivityDefinition) : Integer;

    // Insert FhirActivityDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirActivityDefinition;

    // Insert an existing FhirActivityDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirActivityDefinition);

    // Get the iIndexth FhirActivityDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirActivityDefinition);

    // The number of items in the collection
    function Item(index : Integer) : TFhirActivityDefinition;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirActivityDefinitions[index : Integer] : TFhirActivityDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ACTIVITYDEFINITION}

{$IFDEF FHIR_CAPABILITYSTATEMENT}

  // Software that is covered by this capability statement.  It is used when the capability statement describes the capabilities of a particular software version, independent of an installation.
  TFhirCapabilityStatementSoftware = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FVersion : TFhirString;
    FReleaseDate : TFhirDateTime;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetVersion(value : TFhirString);
    Function GetVersionST : String;
    Procedure SetVersionST(value : String);
    Procedure SetReleaseDate(value : TFhirDateTime);
    Function GetReleaseDateST : TFslDateTime;
    Procedure SetReleaseDateST(value : TFslDateTime);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCapabilityStatementSoftware; overload;
    function Clone : TFhirCapabilityStatementSoftware; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Name software is known by.
    property name : String read GetNameST write SetNameST;
    // Name software is known by.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to The version identifier for the software covered by this statement.
    property version : String read GetVersionST write SetVersionST;
    // The version identifier for the software covered by this statement.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to Date this version of the software was released.
    property releaseDate : TFslDateTime read GetReleaseDateST write SetReleaseDateST;
    // Date this version of the software was released.
    property releaseDateElement : TFhirDateTime read FReleaseDate write SetReleaseDate;

  end;

  TFhirCapabilityStatementSoftwareListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCapabilityStatementSoftwareList;
    function GetCurrent : TFhirCapabilityStatementSoftware;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCapabilityStatementSoftwareList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCapabilityStatementSoftware read GetCurrent;
  end;

  TFhirCapabilityStatementSoftwareList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCapabilityStatementSoftware;
    procedure SetItemN(index : Integer; value : TFhirCapabilityStatementSoftware);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCapabilityStatementSoftwareList; Overload;
    function Clone : TFhirCapabilityStatementSoftwareList; Overload;
    function GetEnumerator : TFhirCapabilityStatementSoftwareListEnumerator;

    //  Add a FhirCapabilityStatementSoftware to the end of the list.
    function Append : TFhirCapabilityStatementSoftware;

    // Add an already existing FhirCapabilityStatementSoftware to the end of the list.
    procedure AddItem(value : TFhirCapabilityStatementSoftware); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCapabilityStatementSoftware) : Integer;

    // Insert FhirCapabilityStatementSoftware before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCapabilityStatementSoftware;

    // Insert an existing FhirCapabilityStatementSoftware before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCapabilityStatementSoftware);

    // Get the iIndexth FhirCapabilityStatementSoftware. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCapabilityStatementSoftware);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCapabilityStatementSoftware;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCapabilityStatementSoftwares[index : Integer] : TFhirCapabilityStatementSoftware read GetItemN write SetItemN; default;
  End;

  // Identifies a specific implementation instance that is described by the capability statement - i.e. a particular installation, rather than the capabilities of a software program.
  TFhirCapabilityStatementImplementation = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FUrl : TFhirUri;
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetUrl(value : TFhirUri);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCapabilityStatementImplementation; overload;
    function Clone : TFhirCapabilityStatementImplementation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Information about the specific installation that this capability statement relates to.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Information about the specific installation that this capability statement relates to.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to An absolute base URL for the implementation.  This forms the base for REST interfaces as well as the mailbox and document interfaces.
    property url : String read GetUrlST write SetUrlST;
    // An absolute base URL for the implementation.  This forms the base for REST interfaces as well as the mailbox and document interfaces.
    property urlElement : TFhirUri read FUrl write SetUrl;

  end;

  TFhirCapabilityStatementImplementationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCapabilityStatementImplementationList;
    function GetCurrent : TFhirCapabilityStatementImplementation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCapabilityStatementImplementationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCapabilityStatementImplementation read GetCurrent;
  end;

  TFhirCapabilityStatementImplementationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCapabilityStatementImplementation;
    procedure SetItemN(index : Integer; value : TFhirCapabilityStatementImplementation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCapabilityStatementImplementationList; Overload;
    function Clone : TFhirCapabilityStatementImplementationList; Overload;
    function GetEnumerator : TFhirCapabilityStatementImplementationListEnumerator;

    //  Add a FhirCapabilityStatementImplementation to the end of the list.
    function Append : TFhirCapabilityStatementImplementation;

    // Add an already existing FhirCapabilityStatementImplementation to the end of the list.
    procedure AddItem(value : TFhirCapabilityStatementImplementation); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCapabilityStatementImplementation) : Integer;

    // Insert FhirCapabilityStatementImplementation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCapabilityStatementImplementation;

    // Insert an existing FhirCapabilityStatementImplementation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCapabilityStatementImplementation);

    // Get the iIndexth FhirCapabilityStatementImplementation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCapabilityStatementImplementation);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCapabilityStatementImplementation;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCapabilityStatementImplementations[index : Integer] : TFhirCapabilityStatementImplementation read GetItemN write SetItemN; default;
  End;

  // A definition of the restful capabilities of the solution, if any.
  TFhirCapabilityStatementRest = class (TFhirBackboneElement)
  protected
    FMode : TFhirEnum;
    FDocumentation : TFhirString;
    FSecurity : TFhirCapabilityStatementRestSecurity;
    FresourceList : TFhirCapabilityStatementRestResourceList;
    FinteractionList : TFhirCapabilityStatementRestInteractionList;
    FsearchParamList : TFhirCapabilityStatementRestResourceSearchParamList;
    FoperationList : TFhirCapabilityStatementRestOperationList;
    FcompartmentList : TFhirUriList;
    Procedure SetMode(value : TFhirEnum);
    Function GetModeST : TFhirRestfulCapabilityModeEnum;
    Procedure SetModeST(value : TFhirRestfulCapabilityModeEnum);
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);
    Procedure SetSecurity(value : TFhirCapabilityStatementRestSecurity);
    function GetResourceList : TFhirCapabilityStatementRestResourceList;
    function GetHasResourceList : Boolean;
    function GetInteractionList : TFhirCapabilityStatementRestInteractionList;
    function GetHasInteractionList : Boolean;
    function GetSearchParamList : TFhirCapabilityStatementRestResourceSearchParamList;
    function GetHasSearchParamList : Boolean;
    function GetOperationList : TFhirCapabilityStatementRestOperationList;
    function GetHasOperationList : Boolean;
    function GetCompartmentList : TFhirUriList;
    function GetHasCompartmentList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCapabilityStatementRest; overload;
    function Clone : TFhirCapabilityStatementRest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Identifies whether this portion of the statement is describing the ability to initiate or receive restful operations.
    property mode : TFhirRestfulCapabilityModeEnum read GetModeST write SetModeST;
    property modeElement : TFhirEnum read FMode write SetMode;

    // Typed access to Information about the system's restful capabilities that apply across all applications, such as security.
    property documentation : String read GetDocumentationST write SetDocumentationST;
    // Information about the system's restful capabilities that apply across all applications, such as security.
    property documentationElement : TFhirString read FDocumentation write SetDocumentation;

    // Typed access to Information about security implementation from an interface perspective - what a client needs to know. (defined for API consistency)
    property security : TFhirCapabilityStatementRestSecurity read FSecurity write SetSecurity;
    // Information about security implementation from an interface perspective - what a client needs to know.
    property securityElement : TFhirCapabilityStatementRestSecurity read FSecurity write SetSecurity;

    // A specification of the restful capabilities of the solution for a specific resource type.
    property resourceList : TFhirCapabilityStatementRestResourceList read GetResourceList;
    property hasResourceList : boolean read GetHasResourceList;

    // A specification of restful operations supported by the system.
    property interactionList : TFhirCapabilityStatementRestInteractionList read GetInteractionList;
    property hasInteractionList : boolean read GetHasInteractionList;

    // Search parameters that are supported for searching all resources for implementations to support and/or make use of - either references to ones defined in the specification, or additional ones defined for/by the implementation.
    property searchParamList : TFhirCapabilityStatementRestResourceSearchParamList read GetSearchParamList;
    property hasSearchParamList : boolean read GetHasSearchParamList;

    // Definition of an operation or a named query together with its parameters and their meaning and type.
    property operationList : TFhirCapabilityStatementRestOperationList read GetOperationList;
    property hasOperationList : boolean read GetHasOperationList;

    // An absolute URI which is a reference to the definition of a compartment that the system supports. The reference is to a CompartmentDefinition resource by its canonical URL .
    property compartmentList : TFhirUriList read GetCompartmentList;
    property hasCompartmentList : boolean read GetHasCompartmentList;

  end;

  TFhirCapabilityStatementRestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCapabilityStatementRestList;
    function GetCurrent : TFhirCapabilityStatementRest;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCapabilityStatementRestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCapabilityStatementRest read GetCurrent;
  end;

  TFhirCapabilityStatementRestList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCapabilityStatementRest;
    procedure SetItemN(index : Integer; value : TFhirCapabilityStatementRest);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCapabilityStatementRestList; Overload;
    function Clone : TFhirCapabilityStatementRestList; Overload;
    function GetEnumerator : TFhirCapabilityStatementRestListEnumerator;

    //  Add a FhirCapabilityStatementRest to the end of the list.
    function Append : TFhirCapabilityStatementRest;

    // Add an already existing FhirCapabilityStatementRest to the end of the list.
    procedure AddItem(value : TFhirCapabilityStatementRest); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCapabilityStatementRest) : Integer;

    // Insert FhirCapabilityStatementRest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCapabilityStatementRest;

    // Insert an existing FhirCapabilityStatementRest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCapabilityStatementRest);

    // Get the iIndexth FhirCapabilityStatementRest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCapabilityStatementRest);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCapabilityStatementRest;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCapabilityStatementRests[index : Integer] : TFhirCapabilityStatementRest read GetItemN write SetItemN; default;
  End;

  // Information about security implementation from an interface perspective - what a client needs to know.
  TFhirCapabilityStatementRestSecurity = class (TFhirBackboneElement)
  protected
    FCors : TFhirBoolean;
    FserviceList : TFhirCodeableConceptList;
    FDescription : TFhirString;
    FcertificateList : TFhirCapabilityStatementRestSecurityCertificateList;
    Procedure SetCors(value : TFhirBoolean);
    Function GetCorsST : Boolean;
    Procedure SetCorsST(value : Boolean);
    function GetServiceList : TFhirCodeableConceptList;
    function GetHasServiceList : Boolean;
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    function GetCertificateList : TFhirCapabilityStatementRestSecurityCertificateList;
    function GetHasCertificateList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCapabilityStatementRestSecurity; overload;
    function Clone : TFhirCapabilityStatementRestSecurity; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Server adds CORS headers when responding to requests - this enables javascript applications to use the server.
    property cors : Boolean read GetCorsST write SetCorsST;
    // Server adds CORS headers when responding to requests - this enables javascript applications to use the server.
    property corsElement : TFhirBoolean read FCors write SetCors;

    // Types of security services that are supported/required by the system.
    property serviceList : TFhirCodeableConceptList read GetServiceList;
    property hasServiceList : boolean read GetHasServiceList;

    // Typed access to General description of how security works.
    property description : String read GetDescriptionST write SetDescriptionST;
    // General description of how security works.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Certificates associated with security profiles.
    property certificateList : TFhirCapabilityStatementRestSecurityCertificateList read GetCertificateList;
    property hasCertificateList : boolean read GetHasCertificateList;

  end;

  TFhirCapabilityStatementRestSecurityListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCapabilityStatementRestSecurityList;
    function GetCurrent : TFhirCapabilityStatementRestSecurity;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCapabilityStatementRestSecurityList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCapabilityStatementRestSecurity read GetCurrent;
  end;

  TFhirCapabilityStatementRestSecurityList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCapabilityStatementRestSecurity;
    procedure SetItemN(index : Integer; value : TFhirCapabilityStatementRestSecurity);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCapabilityStatementRestSecurityList; Overload;
    function Clone : TFhirCapabilityStatementRestSecurityList; Overload;
    function GetEnumerator : TFhirCapabilityStatementRestSecurityListEnumerator;

    //  Add a FhirCapabilityStatementRestSecurity to the end of the list.
    function Append : TFhirCapabilityStatementRestSecurity;

    // Add an already existing FhirCapabilityStatementRestSecurity to the end of the list.
    procedure AddItem(value : TFhirCapabilityStatementRestSecurity); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCapabilityStatementRestSecurity) : Integer;

    // Insert FhirCapabilityStatementRestSecurity before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCapabilityStatementRestSecurity;

    // Insert an existing FhirCapabilityStatementRestSecurity before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCapabilityStatementRestSecurity);

    // Get the iIndexth FhirCapabilityStatementRestSecurity. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCapabilityStatementRestSecurity);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCapabilityStatementRestSecurity;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCapabilityStatementRestSecurities[index : Integer] : TFhirCapabilityStatementRestSecurity read GetItemN write SetItemN; default;
  End;

  // Certificates associated with security profiles.
  TFhirCapabilityStatementRestSecurityCertificate = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCode;
    FBlob : TFhirBase64Binary;
    Procedure SetType_(value : TFhirCode);
    Function GetType_ST : String;
    Procedure SetType_ST(value : String);
    Procedure SetBlob(value : TFhirBase64Binary);
    Function GetBlobST : TBytes;
    Procedure SetBlobST(value : TBytes);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCapabilityStatementRestSecurityCertificate; overload;
    function Clone : TFhirCapabilityStatementRestSecurityCertificate; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Mime type for a certificate.
    property type_ : String read GetType_ST write SetType_ST;
    // Mime type for a certificate.
    property type_Element : TFhirCode read FType_ write SetType_;

    // Typed access to Actual certificate.
    property blob : TBytes read GetBlobST write SetBlobST;
    // Actual certificate.
    property blobElement : TFhirBase64Binary read FBlob write SetBlob;

  end;

  TFhirCapabilityStatementRestSecurityCertificateListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCapabilityStatementRestSecurityCertificateList;
    function GetCurrent : TFhirCapabilityStatementRestSecurityCertificate;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCapabilityStatementRestSecurityCertificateList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCapabilityStatementRestSecurityCertificate read GetCurrent;
  end;

  TFhirCapabilityStatementRestSecurityCertificateList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCapabilityStatementRestSecurityCertificate;
    procedure SetItemN(index : Integer; value : TFhirCapabilityStatementRestSecurityCertificate);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCapabilityStatementRestSecurityCertificateList; Overload;
    function Clone : TFhirCapabilityStatementRestSecurityCertificateList; Overload;
    function GetEnumerator : TFhirCapabilityStatementRestSecurityCertificateListEnumerator;

    //  Add a FhirCapabilityStatementRestSecurityCertificate to the end of the list.
    function Append : TFhirCapabilityStatementRestSecurityCertificate;

    // Add an already existing FhirCapabilityStatementRestSecurityCertificate to the end of the list.
    procedure AddItem(value : TFhirCapabilityStatementRestSecurityCertificate); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCapabilityStatementRestSecurityCertificate) : Integer;

    // Insert FhirCapabilityStatementRestSecurityCertificate before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCapabilityStatementRestSecurityCertificate;

    // Insert an existing FhirCapabilityStatementRestSecurityCertificate before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCapabilityStatementRestSecurityCertificate);

    // Get the iIndexth FhirCapabilityStatementRestSecurityCertificate. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCapabilityStatementRestSecurityCertificate);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCapabilityStatementRestSecurityCertificate;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCapabilityStatementRestSecurityCertificates[index : Integer] : TFhirCapabilityStatementRestSecurityCertificate read GetItemN write SetItemN; default;
  End;

  // A specification of the restful capabilities of the solution for a specific resource type.
  TFhirCapabilityStatementRestResource = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FProfile : TFhirReference{TFhirStructureDefinition};
    FDocumentation : TFhirMarkdown;
    FinteractionList : TFhirCapabilityStatementRestResourceInteractionList;
    FVersioning : TFhirEnum;
    FReadHistory : TFhirBoolean;
    FUpdateCreate : TFhirBoolean;
    FConditionalCreate : TFhirBoolean;
    FConditionalRead : TFhirEnum;
    FConditionalUpdate : TFhirBoolean;
    FConditionalDelete : TFhirEnum;
    FReferencePolicy : TFhirEnumList;
    FsearchIncludeList : TFhirStringList;
    FsearchRevIncludeList : TFhirStringList;
    FsearchParamList : TFhirCapabilityStatementRestResourceSearchParamList;
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirResourceTypesEnum;
    Procedure SetType_ST(value : TFhirResourceTypesEnum);
    Procedure SetProfile(value : TFhirReference{TFhirStructureDefinition});
    Procedure SetDocumentation(value : TFhirMarkdown);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);
    function GetInteractionList : TFhirCapabilityStatementRestResourceInteractionList;
    function GetHasInteractionList : Boolean;
    Procedure SetVersioning(value : TFhirEnum);
    Function GetVersioningST : TFhirVersioningPolicyEnum;
    Procedure SetVersioningST(value : TFhirVersioningPolicyEnum);
    Procedure SetReadHistory(value : TFhirBoolean);
    Function GetReadHistoryST : Boolean;
    Procedure SetReadHistoryST(value : Boolean);
    Procedure SetUpdateCreate(value : TFhirBoolean);
    Function GetUpdateCreateST : Boolean;
    Procedure SetUpdateCreateST(value : Boolean);
    Procedure SetConditionalCreate(value : TFhirBoolean);
    Function GetConditionalCreateST : Boolean;
    Procedure SetConditionalCreateST(value : Boolean);
    Procedure SetConditionalRead(value : TFhirEnum);
    Function GetConditionalReadST : TFhirConditionalReadStatusEnum;
    Procedure SetConditionalReadST(value : TFhirConditionalReadStatusEnum);
    Procedure SetConditionalUpdate(value : TFhirBoolean);
    Function GetConditionalUpdateST : Boolean;
    Procedure SetConditionalUpdateST(value : Boolean);
    Procedure SetConditionalDelete(value : TFhirEnum);
    Function GetConditionalDeleteST : TFhirConditionalDeleteStatusEnum;
    Procedure SetConditionalDeleteST(value : TFhirConditionalDeleteStatusEnum);
    function GetReferencePolicy : TFhirEnumList;
    function GetHasReferencePolicy : Boolean;
    Function GetReferencePolicyST : TFhirReferenceHandlingPolicyEnumList;
    Procedure SetReferencePolicyST(value : TFhirReferenceHandlingPolicyEnumList);
    function GetSearchIncludeList : TFhirStringList;
    function GetHasSearchIncludeList : Boolean;
    function GetSearchRevIncludeList : TFhirStringList;
    function GetHasSearchRevIncludeList : Boolean;
    function GetSearchParamList : TFhirCapabilityStatementRestResourceSearchParamList;
    function GetHasSearchParamList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCapabilityStatementRestResource; overload;
    function Clone : TFhirCapabilityStatementRestResource; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // A type of resource exposed via the restful interface.
    property type_ : TFhirResourceTypesEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to A specification of the profile that describes the solution's overall support for the resource, including any constraints on cardinality, bindings, lengths or other limitations. See further discussion in [Using Profiles](profiling.html#profile-uses). (defined for API consistency)
    property profile : TFhirReference{TFhirStructureDefinition} read FProfile write SetProfile;
    // A specification of the profile that describes the solution's overall support for the resource, including any constraints on cardinality, bindings, lengths or other limitations. See further discussion in [Using Profiles](profiling.html#profile-uses).
    property profileElement : TFhirReference{TFhirStructureDefinition} read FProfile write SetProfile;

    // Typed access to Additional information about the resource type used by the system.
    property documentation : String read GetDocumentationST write SetDocumentationST;
    // Additional information about the resource type used by the system.
    property documentationElement : TFhirMarkdown read FDocumentation write SetDocumentation;

    // Identifies a restful operation supported by the solution.
    property interactionList : TFhirCapabilityStatementRestResourceInteractionList read GetInteractionList;
    property hasInteractionList : boolean read GetHasInteractionList;

    // This field is set to no-version to specify that the system does not support (server) or use (client) versioning for this resource type. If this has some other value, the server must at least correctly track and populate the versionId meta-property on resources. If the value is 'versioned-update', then the server supports all the versioning features, including using e-tags for version integrity in the API.
    property versioning : TFhirVersioningPolicyEnum read GetVersioningST write SetVersioningST;
    property versioningElement : TFhirEnum read FVersioning write SetVersioning;

    // Typed access to A flag for whether the server is able to return past versions as part of the vRead operation.
    property readHistory : Boolean read GetReadHistoryST write SetReadHistoryST;
    // A flag for whether the server is able to return past versions as part of the vRead operation.
    property readHistoryElement : TFhirBoolean read FReadHistory write SetReadHistory;

    // Typed access to A flag to indicate that the server allows or needs to allow the client to create new identities on the server (e.g. that is, the client PUTs to a location where there is no existing resource). Allowing this operation means that the server allows the client to create new identities on the server.
    property updateCreate : Boolean read GetUpdateCreateST write SetUpdateCreateST;
    // A flag to indicate that the server allows or needs to allow the client to create new identities on the server (e.g. that is, the client PUTs to a location where there is no existing resource). Allowing this operation means that the server allows the client to create new identities on the server.
    property updateCreateElement : TFhirBoolean read FUpdateCreate write SetUpdateCreate;

    // Typed access to A flag that indicates that the server supports conditional create.
    property conditionalCreate : Boolean read GetConditionalCreateST write SetConditionalCreateST;
    // A flag that indicates that the server supports conditional create.
    property conditionalCreateElement : TFhirBoolean read FConditionalCreate write SetConditionalCreate;

    // A code that indicates how the server supports conditional read.
    property conditionalRead : TFhirConditionalReadStatusEnum read GetConditionalReadST write SetConditionalReadST;
    property conditionalReadElement : TFhirEnum read FConditionalRead write SetConditionalRead;

    // Typed access to A flag that indicates that the server supports conditional update.
    property conditionalUpdate : Boolean read GetConditionalUpdateST write SetConditionalUpdateST;
    // A flag that indicates that the server supports conditional update.
    property conditionalUpdateElement : TFhirBoolean read FConditionalUpdate write SetConditionalUpdate;

    // A code that indicates how the server supports conditional delete.
    property conditionalDelete : TFhirConditionalDeleteStatusEnum read GetConditionalDeleteST write SetConditionalDeleteST;
    property conditionalDeleteElement : TFhirEnum read FConditionalDelete write SetConditionalDelete;

    // A set of flags that defines how references are supported.
    property referencePolicy : TFhirReferenceHandlingPolicyEnumList read GetReferencePolicyST write SetReferencePolicyST;
    property referencePolicyList : TFhirEnumList read GetReferencePolicy;
    property hasReferencePolicy : boolean read GetHasReferencePolicy;
    // A list of _include values supported by the server.
    property searchIncludeList : TFhirStringList read GetSearchIncludeList;
    property hasSearchIncludeList : boolean read GetHasSearchIncludeList;

    // A list of _revinclude (reverse include) values supported by the server.
    property searchRevIncludeList : TFhirStringList read GetSearchRevIncludeList;
    property hasSearchRevIncludeList : boolean read GetHasSearchRevIncludeList;

    // Search parameters for implementations to support and/or make use of - either references to ones defined in the specification, or additional ones defined for/by the implementation.
    property searchParamList : TFhirCapabilityStatementRestResourceSearchParamList read GetSearchParamList;
    property hasSearchParamList : boolean read GetHasSearchParamList;

  end;

  TFhirCapabilityStatementRestResourceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCapabilityStatementRestResourceList;
    function GetCurrent : TFhirCapabilityStatementRestResource;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCapabilityStatementRestResourceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCapabilityStatementRestResource read GetCurrent;
  end;

  TFhirCapabilityStatementRestResourceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCapabilityStatementRestResource;
    procedure SetItemN(index : Integer; value : TFhirCapabilityStatementRestResource);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCapabilityStatementRestResourceList; Overload;
    function Clone : TFhirCapabilityStatementRestResourceList; Overload;
    function GetEnumerator : TFhirCapabilityStatementRestResourceListEnumerator;

    //  Add a FhirCapabilityStatementRestResource to the end of the list.
    function Append : TFhirCapabilityStatementRestResource;

    // Add an already existing FhirCapabilityStatementRestResource to the end of the list.
    procedure AddItem(value : TFhirCapabilityStatementRestResource); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCapabilityStatementRestResource) : Integer;

    // Insert FhirCapabilityStatementRestResource before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCapabilityStatementRestResource;

    // Insert an existing FhirCapabilityStatementRestResource before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCapabilityStatementRestResource);

    // Get the iIndexth FhirCapabilityStatementRestResource. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCapabilityStatementRestResource);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCapabilityStatementRestResource;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCapabilityStatementRestResources[index : Integer] : TFhirCapabilityStatementRestResource read GetItemN write SetItemN; default;
  End;

  // Identifies a restful operation supported by the solution.
  TFhirCapabilityStatementRestResourceInteraction = class (TFhirBackboneElement)
  protected
    FCode : TFhirEnum;
    FDocumentation : TFhirString;
    Procedure SetCode(value : TFhirEnum);
    Function GetCodeST : TFhirTypeRestfulInteractionEnum;
    Procedure SetCodeST(value : TFhirTypeRestfulInteractionEnum);
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCapabilityStatementRestResourceInteraction; overload;
    function Clone : TFhirCapabilityStatementRestResourceInteraction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Coded identifier of the operation, supported by the system resource.
    property code : TFhirTypeRestfulInteractionEnum read GetCodeST write SetCodeST;
    property codeElement : TFhirEnum read FCode write SetCode;

    // Typed access to Guidance specific to the implementation of this operation, such as 'delete is a logical delete' or 'updates are only allowed with version id' or 'creates permitted from pre-authorized certificates only'.
    property documentation : String read GetDocumentationST write SetDocumentationST;
    // Guidance specific to the implementation of this operation, such as 'delete is a logical delete' or 'updates are only allowed with version id' or 'creates permitted from pre-authorized certificates only'.
    property documentationElement : TFhirString read FDocumentation write SetDocumentation;

  end;

  TFhirCapabilityStatementRestResourceInteractionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCapabilityStatementRestResourceInteractionList;
    function GetCurrent : TFhirCapabilityStatementRestResourceInteraction;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCapabilityStatementRestResourceInteractionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCapabilityStatementRestResourceInteraction read GetCurrent;
  end;

  TFhirCapabilityStatementRestResourceInteractionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCapabilityStatementRestResourceInteraction;
    procedure SetItemN(index : Integer; value : TFhirCapabilityStatementRestResourceInteraction);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCapabilityStatementRestResourceInteractionList; Overload;
    function Clone : TFhirCapabilityStatementRestResourceInteractionList; Overload;
    function GetEnumerator : TFhirCapabilityStatementRestResourceInteractionListEnumerator;

    //  Add a FhirCapabilityStatementRestResourceInteraction to the end of the list.
    function Append : TFhirCapabilityStatementRestResourceInteraction;

    // Add an already existing FhirCapabilityStatementRestResourceInteraction to the end of the list.
    procedure AddItem(value : TFhirCapabilityStatementRestResourceInteraction); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCapabilityStatementRestResourceInteraction) : Integer;

    // Insert FhirCapabilityStatementRestResourceInteraction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCapabilityStatementRestResourceInteraction;

    // Insert an existing FhirCapabilityStatementRestResourceInteraction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCapabilityStatementRestResourceInteraction);

    // Get the iIndexth FhirCapabilityStatementRestResourceInteraction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCapabilityStatementRestResourceInteraction);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCapabilityStatementRestResourceInteraction;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCapabilityStatementRestResourceInteractions[index : Integer] : TFhirCapabilityStatementRestResourceInteraction read GetItemN write SetItemN; default;
  End;

  // Search parameters for implementations to support and/or make use of - either references to ones defined in the specification, or additional ones defined for/by the implementation.
  TFhirCapabilityStatementRestResourceSearchParam = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FDefinition : TFhirUri;
    FType_ : TFhirEnum;
    FDocumentation : TFhirString;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetDefinition(value : TFhirUri);
    Function GetDefinitionST : String;
    Procedure SetDefinitionST(value : String);
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirSearchParamTypeEnum;
    Procedure SetType_ST(value : TFhirSearchParamTypeEnum);
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCapabilityStatementRestResourceSearchParam; overload;
    function Clone : TFhirCapabilityStatementRestResourceSearchParam; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The name of the search parameter used in the interface.
    property name : String read GetNameST write SetNameST;
    // The name of the search parameter used in the interface.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to An absolute URI that is a formal reference to where this parameter was first defined, so that a client can be confident of the meaning of the search parameter (a reference to [SearchParameter.url]()).
    property definition : String read GetDefinitionST write SetDefinitionST;
    // An absolute URI that is a formal reference to where this parameter was first defined, so that a client can be confident of the meaning of the search parameter (a reference to [SearchParameter.url]()).
    property definitionElement : TFhirUri read FDefinition write SetDefinition;

    // The type of value a search parameter refers to, and how the content is interpreted.
    property type_ : TFhirSearchParamTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to This allows documentation of any distinct behaviors about how the search parameter is used.  For example, text matching algorithms.
    property documentation : String read GetDocumentationST write SetDocumentationST;
    // This allows documentation of any distinct behaviors about how the search parameter is used.  For example, text matching algorithms.
    property documentationElement : TFhirString read FDocumentation write SetDocumentation;

  end;

  TFhirCapabilityStatementRestResourceSearchParamListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCapabilityStatementRestResourceSearchParamList;
    function GetCurrent : TFhirCapabilityStatementRestResourceSearchParam;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCapabilityStatementRestResourceSearchParamList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCapabilityStatementRestResourceSearchParam read GetCurrent;
  end;

  TFhirCapabilityStatementRestResourceSearchParamList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCapabilityStatementRestResourceSearchParam;
    procedure SetItemN(index : Integer; value : TFhirCapabilityStatementRestResourceSearchParam);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCapabilityStatementRestResourceSearchParamList; Overload;
    function Clone : TFhirCapabilityStatementRestResourceSearchParamList; Overload;
    function GetEnumerator : TFhirCapabilityStatementRestResourceSearchParamListEnumerator;

    //  Add a FhirCapabilityStatementRestResourceSearchParam to the end of the list.
    function Append : TFhirCapabilityStatementRestResourceSearchParam;

    // Add an already existing FhirCapabilityStatementRestResourceSearchParam to the end of the list.
    procedure AddItem(value : TFhirCapabilityStatementRestResourceSearchParam); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCapabilityStatementRestResourceSearchParam) : Integer;

    // Insert FhirCapabilityStatementRestResourceSearchParam before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCapabilityStatementRestResourceSearchParam;

    // Insert an existing FhirCapabilityStatementRestResourceSearchParam before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCapabilityStatementRestResourceSearchParam);

    // Get the iIndexth FhirCapabilityStatementRestResourceSearchParam. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCapabilityStatementRestResourceSearchParam);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCapabilityStatementRestResourceSearchParam;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCapabilityStatementRestResourceSearchParams[index : Integer] : TFhirCapabilityStatementRestResourceSearchParam read GetItemN write SetItemN; default;
  End;

  // A specification of restful operations supported by the system.
  TFhirCapabilityStatementRestInteraction = class (TFhirBackboneElement)
  protected
    FCode : TFhirEnum;
    FDocumentation : TFhirString;
    Procedure SetCode(value : TFhirEnum);
    Function GetCodeST : TFhirSystemRestfulInteractionEnum;
    Procedure SetCodeST(value : TFhirSystemRestfulInteractionEnum);
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCapabilityStatementRestInteraction; overload;
    function Clone : TFhirCapabilityStatementRestInteraction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // A coded identifier of the operation, supported by the system.
    property code : TFhirSystemRestfulInteractionEnum read GetCodeST write SetCodeST;
    property codeElement : TFhirEnum read FCode write SetCode;

    // Typed access to Guidance specific to the implementation of this operation, such as limitations on the kind of transactions allowed, or information about system wide search is implemented.
    property documentation : String read GetDocumentationST write SetDocumentationST;
    // Guidance specific to the implementation of this operation, such as limitations on the kind of transactions allowed, or information about system wide search is implemented.
    property documentationElement : TFhirString read FDocumentation write SetDocumentation;

  end;

  TFhirCapabilityStatementRestInteractionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCapabilityStatementRestInteractionList;
    function GetCurrent : TFhirCapabilityStatementRestInteraction;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCapabilityStatementRestInteractionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCapabilityStatementRestInteraction read GetCurrent;
  end;

  TFhirCapabilityStatementRestInteractionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCapabilityStatementRestInteraction;
    procedure SetItemN(index : Integer; value : TFhirCapabilityStatementRestInteraction);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCapabilityStatementRestInteractionList; Overload;
    function Clone : TFhirCapabilityStatementRestInteractionList; Overload;
    function GetEnumerator : TFhirCapabilityStatementRestInteractionListEnumerator;

    //  Add a FhirCapabilityStatementRestInteraction to the end of the list.
    function Append : TFhirCapabilityStatementRestInteraction;

    // Add an already existing FhirCapabilityStatementRestInteraction to the end of the list.
    procedure AddItem(value : TFhirCapabilityStatementRestInteraction); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCapabilityStatementRestInteraction) : Integer;

    // Insert FhirCapabilityStatementRestInteraction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCapabilityStatementRestInteraction;

    // Insert an existing FhirCapabilityStatementRestInteraction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCapabilityStatementRestInteraction);

    // Get the iIndexth FhirCapabilityStatementRestInteraction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCapabilityStatementRestInteraction);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCapabilityStatementRestInteraction;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCapabilityStatementRestInteractions[index : Integer] : TFhirCapabilityStatementRestInteraction read GetItemN write SetItemN; default;
  End;

  // Definition of an operation or a named query together with its parameters and their meaning and type.
  TFhirCapabilityStatementRestOperation = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FDefinition : TFhirReference{TFhirOperationDefinition};
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetDefinition(value : TFhirReference{TFhirOperationDefinition});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCapabilityStatementRestOperation; overload;
    function Clone : TFhirCapabilityStatementRestOperation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The name of the operation or query. For an operation, this is the name  prefixed with $ and used in the URL. For a query, this is the name used in the _query parameter when the query is called.
    property name : String read GetNameST write SetNameST;
    // The name of the operation or query. For an operation, this is the name  prefixed with $ and used in the URL. For a query, this is the name used in the _query parameter when the query is called.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Where the formal definition can be found. (defined for API consistency)
    property definition : TFhirReference{TFhirOperationDefinition} read FDefinition write SetDefinition;
    // Where the formal definition can be found.
    property definitionElement : TFhirReference{TFhirOperationDefinition} read FDefinition write SetDefinition;

  end;

  TFhirCapabilityStatementRestOperationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCapabilityStatementRestOperationList;
    function GetCurrent : TFhirCapabilityStatementRestOperation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCapabilityStatementRestOperationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCapabilityStatementRestOperation read GetCurrent;
  end;

  TFhirCapabilityStatementRestOperationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCapabilityStatementRestOperation;
    procedure SetItemN(index : Integer; value : TFhirCapabilityStatementRestOperation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCapabilityStatementRestOperationList; Overload;
    function Clone : TFhirCapabilityStatementRestOperationList; Overload;
    function GetEnumerator : TFhirCapabilityStatementRestOperationListEnumerator;

    //  Add a FhirCapabilityStatementRestOperation to the end of the list.
    function Append : TFhirCapabilityStatementRestOperation;

    // Add an already existing FhirCapabilityStatementRestOperation to the end of the list.
    procedure AddItem(value : TFhirCapabilityStatementRestOperation); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCapabilityStatementRestOperation) : Integer;

    // Insert FhirCapabilityStatementRestOperation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCapabilityStatementRestOperation;

    // Insert an existing FhirCapabilityStatementRestOperation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCapabilityStatementRestOperation);

    // Get the iIndexth FhirCapabilityStatementRestOperation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCapabilityStatementRestOperation);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCapabilityStatementRestOperation;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCapabilityStatementRestOperations[index : Integer] : TFhirCapabilityStatementRestOperation read GetItemN write SetItemN; default;
  End;

  // A description of the messaging capabilities of the solution.
  TFhirCapabilityStatementMessaging = class (TFhirBackboneElement)
  protected
    FendpointList : TFhirCapabilityStatementMessagingEndpointList;
    FReliableCache : TFhirUnsignedInt;
    FDocumentation : TFhirString;
    FsupportedMessageList : TFhirCapabilityStatementMessagingSupportedMessageList;
    FeventList : TFhirCapabilityStatementMessagingEventList;
    function GetEndpointList : TFhirCapabilityStatementMessagingEndpointList;
    function GetHasEndpointList : Boolean;
    Procedure SetReliableCache(value : TFhirUnsignedInt);
    Function GetReliableCacheST : String;
    Procedure SetReliableCacheST(value : String);
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);
    function GetSupportedMessageList : TFhirCapabilityStatementMessagingSupportedMessageList;
    function GetHasSupportedMessageList : Boolean;
    function GetEventList : TFhirCapabilityStatementMessagingEventList;
    function GetHasEventList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCapabilityStatementMessaging; overload;
    function Clone : TFhirCapabilityStatementMessaging; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // An endpoint (network accessible address) to which messages and/or replies are to be sent.
    property endpointList : TFhirCapabilityStatementMessagingEndpointList read GetEndpointList;
    property hasEndpointList : boolean read GetHasEndpointList;

    // Typed access to Length if the receiver's reliable messaging cache in minutes (if a receiver) or how long the cache length on the receiver should be (if a sender).
    property reliableCache : String read GetReliableCacheST write SetReliableCacheST;
    // Length if the receiver's reliable messaging cache in minutes (if a receiver) or how long the cache length on the receiver should be (if a sender).
    property reliableCacheElement : TFhirUnsignedInt read FReliableCache write SetReliableCache;

    // Typed access to Documentation about the system's messaging capabilities for this endpoint not otherwise documented by the capability statement.  For example, the process for becoming an authorized messaging exchange partner.
    property documentation : String read GetDocumentationST write SetDocumentationST;
    // Documentation about the system's messaging capabilities for this endpoint not otherwise documented by the capability statement.  For example, the process for becoming an authorized messaging exchange partner.
    property documentationElement : TFhirString read FDocumentation write SetDocumentation;

    // References to message definitions for messages this system can send or receive.
    property supportedMessageList : TFhirCapabilityStatementMessagingSupportedMessageList read GetSupportedMessageList;
    property hasSupportedMessageList : boolean read GetHasSupportedMessageList;

    // A description of the solution's support for an event at this end-point.
    property eventList : TFhirCapabilityStatementMessagingEventList read GetEventList;
    property hasEventList : boolean read GetHasEventList;

  end;

  TFhirCapabilityStatementMessagingListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCapabilityStatementMessagingList;
    function GetCurrent : TFhirCapabilityStatementMessaging;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCapabilityStatementMessagingList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCapabilityStatementMessaging read GetCurrent;
  end;

  TFhirCapabilityStatementMessagingList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCapabilityStatementMessaging;
    procedure SetItemN(index : Integer; value : TFhirCapabilityStatementMessaging);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCapabilityStatementMessagingList; Overload;
    function Clone : TFhirCapabilityStatementMessagingList; Overload;
    function GetEnumerator : TFhirCapabilityStatementMessagingListEnumerator;

    //  Add a FhirCapabilityStatementMessaging to the end of the list.
    function Append : TFhirCapabilityStatementMessaging;

    // Add an already existing FhirCapabilityStatementMessaging to the end of the list.
    procedure AddItem(value : TFhirCapabilityStatementMessaging); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCapabilityStatementMessaging) : Integer;

    // Insert FhirCapabilityStatementMessaging before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCapabilityStatementMessaging;

    // Insert an existing FhirCapabilityStatementMessaging before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCapabilityStatementMessaging);

    // Get the iIndexth FhirCapabilityStatementMessaging. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCapabilityStatementMessaging);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCapabilityStatementMessaging;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCapabilityStatementMessagings[index : Integer] : TFhirCapabilityStatementMessaging read GetItemN write SetItemN; default;
  End;

  // An endpoint (network accessible address) to which messages and/or replies are to be sent.
  TFhirCapabilityStatementMessagingEndpoint = class (TFhirBackboneElement)
  protected
    FProtocol : TFhirCoding;
    FAddress : TFhirUri;
    Procedure SetProtocol(value : TFhirCoding);
    Procedure SetAddress(value : TFhirUri);
    Function GetAddressST : String;
    Procedure SetAddressST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCapabilityStatementMessagingEndpoint; overload;
    function Clone : TFhirCapabilityStatementMessagingEndpoint; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A list of the messaging transport protocol(s) identifiers, supported by this endpoint. (defined for API consistency)
    property protocol : TFhirCoding read FProtocol write SetProtocol;
    // A list of the messaging transport protocol(s) identifiers, supported by this endpoint.
    property protocolElement : TFhirCoding read FProtocol write SetProtocol;

    // Typed access to The network address of the end-point. For solutions that do not use network addresses for routing, it can be just an identifier.
    property address : String read GetAddressST write SetAddressST;
    // The network address of the end-point. For solutions that do not use network addresses for routing, it can be just an identifier.
    property addressElement : TFhirUri read FAddress write SetAddress;

  end;

  TFhirCapabilityStatementMessagingEndpointListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCapabilityStatementMessagingEndpointList;
    function GetCurrent : TFhirCapabilityStatementMessagingEndpoint;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCapabilityStatementMessagingEndpointList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCapabilityStatementMessagingEndpoint read GetCurrent;
  end;

  TFhirCapabilityStatementMessagingEndpointList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCapabilityStatementMessagingEndpoint;
    procedure SetItemN(index : Integer; value : TFhirCapabilityStatementMessagingEndpoint);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCapabilityStatementMessagingEndpointList; Overload;
    function Clone : TFhirCapabilityStatementMessagingEndpointList; Overload;
    function GetEnumerator : TFhirCapabilityStatementMessagingEndpointListEnumerator;

    //  Add a FhirCapabilityStatementMessagingEndpoint to the end of the list.
    function Append : TFhirCapabilityStatementMessagingEndpoint;

    // Add an already existing FhirCapabilityStatementMessagingEndpoint to the end of the list.
    procedure AddItem(value : TFhirCapabilityStatementMessagingEndpoint); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCapabilityStatementMessagingEndpoint) : Integer;

    // Insert FhirCapabilityStatementMessagingEndpoint before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCapabilityStatementMessagingEndpoint;

    // Insert an existing FhirCapabilityStatementMessagingEndpoint before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCapabilityStatementMessagingEndpoint);

    // Get the iIndexth FhirCapabilityStatementMessagingEndpoint. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCapabilityStatementMessagingEndpoint);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCapabilityStatementMessagingEndpoint;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCapabilityStatementMessagingEndpoints[index : Integer] : TFhirCapabilityStatementMessagingEndpoint read GetItemN write SetItemN; default;
  End;

  // References to message definitions for messages this system can send or receive.
  TFhirCapabilityStatementMessagingSupportedMessage = class (TFhirBackboneElement)
  protected
    FMode : TFhirEnum;
    FDefinition : TFhirReference{TFhirMessageDefinition};
    Procedure SetMode(value : TFhirEnum);
    Function GetModeST : TFhirEventCapabilityModeEnum;
    Procedure SetModeST(value : TFhirEventCapabilityModeEnum);
    Procedure SetDefinition(value : TFhirReference{TFhirMessageDefinition});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCapabilityStatementMessagingSupportedMessage; overload;
    function Clone : TFhirCapabilityStatementMessagingSupportedMessage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The mode of this event declaration - whether application is sender or receiver.
    property mode : TFhirEventCapabilityModeEnum read GetModeST write SetModeST;
    property modeElement : TFhirEnum read FMode write SetMode;

    // Typed access to Points to a message definition that identifies the messaging event, message structure, allowed responses, etc. (defined for API consistency)
    property definition : TFhirReference{TFhirMessageDefinition} read FDefinition write SetDefinition;
    // Points to a message definition that identifies the messaging event, message structure, allowed responses, etc.
    property definitionElement : TFhirReference{TFhirMessageDefinition} read FDefinition write SetDefinition;

  end;

  TFhirCapabilityStatementMessagingSupportedMessageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCapabilityStatementMessagingSupportedMessageList;
    function GetCurrent : TFhirCapabilityStatementMessagingSupportedMessage;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCapabilityStatementMessagingSupportedMessageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCapabilityStatementMessagingSupportedMessage read GetCurrent;
  end;

  TFhirCapabilityStatementMessagingSupportedMessageList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCapabilityStatementMessagingSupportedMessage;
    procedure SetItemN(index : Integer; value : TFhirCapabilityStatementMessagingSupportedMessage);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCapabilityStatementMessagingSupportedMessageList; Overload;
    function Clone : TFhirCapabilityStatementMessagingSupportedMessageList; Overload;
    function GetEnumerator : TFhirCapabilityStatementMessagingSupportedMessageListEnumerator;

    //  Add a FhirCapabilityStatementMessagingSupportedMessage to the end of the list.
    function Append : TFhirCapabilityStatementMessagingSupportedMessage;

    // Add an already existing FhirCapabilityStatementMessagingSupportedMessage to the end of the list.
    procedure AddItem(value : TFhirCapabilityStatementMessagingSupportedMessage); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCapabilityStatementMessagingSupportedMessage) : Integer;

    // Insert FhirCapabilityStatementMessagingSupportedMessage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCapabilityStatementMessagingSupportedMessage;

    // Insert an existing FhirCapabilityStatementMessagingSupportedMessage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCapabilityStatementMessagingSupportedMessage);

    // Get the iIndexth FhirCapabilityStatementMessagingSupportedMessage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCapabilityStatementMessagingSupportedMessage);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCapabilityStatementMessagingSupportedMessage;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCapabilityStatementMessagingSupportedMessages[index : Integer] : TFhirCapabilityStatementMessagingSupportedMessage read GetItemN write SetItemN; default;
  End;

  // A description of the solution's support for an event at this end-point.
  TFhirCapabilityStatementMessagingEvent = class (TFhirBackboneElement)
  protected
    FCode : TFhirCoding;
    FCategory : TFhirEnum;
    FMode : TFhirEnum;
    FFocus : TFhirEnum;
    FRequest : TFhirReference{TFhirStructureDefinition};
    FResponse : TFhirReference{TFhirStructureDefinition};
    FDocumentation : TFhirString;
    Procedure SetCode(value : TFhirCoding);
    Procedure SetCategory(value : TFhirEnum);
    Function GetCategoryST : TFhirMessageSignificanceCategoryEnum;
    Procedure SetCategoryST(value : TFhirMessageSignificanceCategoryEnum);
    Procedure SetMode(value : TFhirEnum);
    Function GetModeST : TFhirEventCapabilityModeEnum;
    Procedure SetModeST(value : TFhirEventCapabilityModeEnum);
    Procedure SetFocus(value : TFhirEnum);
    Function GetFocusST : TFhirResourceTypesEnum;
    Procedure SetFocusST(value : TFhirResourceTypesEnum);
    Procedure SetRequest(value : TFhirReference{TFhirStructureDefinition});
    Procedure SetResponse(value : TFhirReference{TFhirStructureDefinition});
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCapabilityStatementMessagingEvent; overload;
    function Clone : TFhirCapabilityStatementMessagingEvent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A coded identifier of a supported messaging event. (defined for API consistency)
    property code : TFhirCoding read FCode write SetCode;
    // A coded identifier of a supported messaging event.
    property codeElement : TFhirCoding read FCode write SetCode;

    // The impact of the content of the message.
    property category : TFhirMessageSignificanceCategoryEnum read GetCategoryST write SetCategoryST;
    property categoryElement : TFhirEnum read FCategory write SetCategory;

    // The mode of this event declaration - whether an application is a sender or receiver.
    property mode : TFhirEventCapabilityModeEnum read GetModeST write SetModeST;
    property modeElement : TFhirEnum read FMode write SetMode;

    // A resource associated with the event.  This is the resource that defines the event.
    property focus : TFhirResourceTypesEnum read GetFocusST write SetFocusST;
    property focusElement : TFhirEnum read FFocus write SetFocus;

    // Typed access to Information about the request for this event. (defined for API consistency)
    property request : TFhirReference{TFhirStructureDefinition} read FRequest write SetRequest;
    // Information about the request for this event.
    property requestElement : TFhirReference{TFhirStructureDefinition} read FRequest write SetRequest;

    // Typed access to Information about the response for this event. (defined for API consistency)
    property response : TFhirReference{TFhirStructureDefinition} read FResponse write SetResponse;
    // Information about the response for this event.
    property responseElement : TFhirReference{TFhirStructureDefinition} read FResponse write SetResponse;

    // Typed access to Guidance on how this event is handled, such as internal system trigger points, business rules, etc.
    property documentation : String read GetDocumentationST write SetDocumentationST;
    // Guidance on how this event is handled, such as internal system trigger points, business rules, etc.
    property documentationElement : TFhirString read FDocumentation write SetDocumentation;

  end;

  TFhirCapabilityStatementMessagingEventListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCapabilityStatementMessagingEventList;
    function GetCurrent : TFhirCapabilityStatementMessagingEvent;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCapabilityStatementMessagingEventList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCapabilityStatementMessagingEvent read GetCurrent;
  end;

  TFhirCapabilityStatementMessagingEventList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCapabilityStatementMessagingEvent;
    procedure SetItemN(index : Integer; value : TFhirCapabilityStatementMessagingEvent);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCapabilityStatementMessagingEventList; Overload;
    function Clone : TFhirCapabilityStatementMessagingEventList; Overload;
    function GetEnumerator : TFhirCapabilityStatementMessagingEventListEnumerator;

    //  Add a FhirCapabilityStatementMessagingEvent to the end of the list.
    function Append : TFhirCapabilityStatementMessagingEvent;

    // Add an already existing FhirCapabilityStatementMessagingEvent to the end of the list.
    procedure AddItem(value : TFhirCapabilityStatementMessagingEvent); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCapabilityStatementMessagingEvent) : Integer;

    // Insert FhirCapabilityStatementMessagingEvent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCapabilityStatementMessagingEvent;

    // Insert an existing FhirCapabilityStatementMessagingEvent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCapabilityStatementMessagingEvent);

    // Get the iIndexth FhirCapabilityStatementMessagingEvent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCapabilityStatementMessagingEvent);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCapabilityStatementMessagingEvent;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCapabilityStatementMessagingEvents[index : Integer] : TFhirCapabilityStatementMessagingEvent read GetItemN write SetItemN; default;
  End;

  // A document definition.
  TFhirCapabilityStatementDocument = class (TFhirBackboneElement)
  protected
    FMode : TFhirEnum;
    FDocumentation : TFhirString;
    FProfile : TFhirReference{TFhirStructureDefinition};
    Procedure SetMode(value : TFhirEnum);
    Function GetModeST : TFhirDocumentModeEnum;
    Procedure SetModeST(value : TFhirDocumentModeEnum);
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);
    Procedure SetProfile(value : TFhirReference{TFhirStructureDefinition});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCapabilityStatementDocument; overload;
    function Clone : TFhirCapabilityStatementDocument; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Mode of this document declaration - whether an application is a producer or consumer.
    property mode : TFhirDocumentModeEnum read GetModeST write SetModeST;
    property modeElement : TFhirEnum read FMode write SetMode;

    // Typed access to A description of how the application supports or uses the specified document profile.  For example, when documents are created, what action is taken with consumed documents, etc.
    property documentation : String read GetDocumentationST write SetDocumentationST;
    // A description of how the application supports or uses the specified document profile.  For example, when documents are created, what action is taken with consumed documents, etc.
    property documentationElement : TFhirString read FDocumentation write SetDocumentation;

    // Typed access to A constraint on a resource used in the document. (defined for API consistency)
    property profile : TFhirReference{TFhirStructureDefinition} read FProfile write SetProfile;
    // A constraint on a resource used in the document.
    property profileElement : TFhirReference{TFhirStructureDefinition} read FProfile write SetProfile;

  end;

  TFhirCapabilityStatementDocumentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCapabilityStatementDocumentList;
    function GetCurrent : TFhirCapabilityStatementDocument;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCapabilityStatementDocumentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCapabilityStatementDocument read GetCurrent;
  end;

  TFhirCapabilityStatementDocumentList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCapabilityStatementDocument;
    procedure SetItemN(index : Integer; value : TFhirCapabilityStatementDocument);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCapabilityStatementDocumentList; Overload;
    function Clone : TFhirCapabilityStatementDocumentList; Overload;
    function GetEnumerator : TFhirCapabilityStatementDocumentListEnumerator;

    //  Add a FhirCapabilityStatementDocument to the end of the list.
    function Append : TFhirCapabilityStatementDocument;

    // Add an already existing FhirCapabilityStatementDocument to the end of the list.
    procedure AddItem(value : TFhirCapabilityStatementDocument); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCapabilityStatementDocument) : Integer;

    // Insert FhirCapabilityStatementDocument before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCapabilityStatementDocument;

    // Insert an existing FhirCapabilityStatementDocument before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCapabilityStatementDocument);

    // Get the iIndexth FhirCapabilityStatementDocument. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCapabilityStatementDocument);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCapabilityStatementDocument;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCapabilityStatementDocuments[index : Integer] : TFhirCapabilityStatementDocument read GetItemN write SetItemN; default;
  End;

  // A Capability Statement documents a set of capabilities (behaviors) of a FHIR Server that may be used as a statement of actual server functionality or a statement of required or desired server implementation.
  TFhirCapabilityStatement = class (TFhirMetadataResource)
  protected
    FPurpose : TFhirMarkdown;
    FCopyright : TFhirMarkdown;
    FKind : TFhirEnum;
    FinstantiatesList : TFhirUriList;
    FSoftware : TFhirCapabilityStatementSoftware;
    FImplementation_ : TFhirCapabilityStatementImplementation;
    FFhirVersion : TFhirId;
    FAcceptUnknown : TFhirEnum;
    FformatList : TFhirCodeList;
    FpatchFormatList : TFhirCodeList;
    FimplementationGuideList : TFhirUriList;
    FprofileList : TFhirReferenceList{TFhirStructureDefinition};
    FrestList : TFhirCapabilityStatementRestList;
    FmessagingList : TFhirCapabilityStatementMessagingList;
    FdocumentList : TFhirCapabilityStatementDocumentList;
    Procedure SetPurpose(value : TFhirMarkdown);
    Function GetPurposeST : String;
    Procedure SetPurposeST(value : String);
    Procedure SetCopyright(value : TFhirMarkdown);
    Function GetCopyrightST : String;
    Procedure SetCopyrightST(value : String);
    Procedure SetKind(value : TFhirEnum);
    Function GetKindST : TFhirCapabilityStatementKindEnum;
    Procedure SetKindST(value : TFhirCapabilityStatementKindEnum);
    function GetInstantiatesList : TFhirUriList;
    function GetHasInstantiatesList : Boolean;
    Procedure SetSoftware(value : TFhirCapabilityStatementSoftware);
    Procedure SetImplementation_(value : TFhirCapabilityStatementImplementation);
    Procedure SetFhirVersion(value : TFhirId);
    Function GetFhirVersionST : String;
    Procedure SetFhirVersionST(value : String);
    Procedure SetAcceptUnknown(value : TFhirEnum);
    Function GetAcceptUnknownST : TFhirUnknownContentCodeEnum;
    Procedure SetAcceptUnknownST(value : TFhirUnknownContentCodeEnum);
    function GetFormatList : TFhirCodeList;
    function GetHasFormatList : Boolean;
    function GetPatchFormatList : TFhirCodeList;
    function GetHasPatchFormatList : Boolean;
    function GetImplementationGuideList : TFhirUriList;
    function GetHasImplementationGuideList : Boolean;
    function GetProfileList : TFhirReferenceList{TFhirStructureDefinition};
    function GetHasProfileList : Boolean;
    function GetRestList : TFhirCapabilityStatementRestList;
    function GetHasRestList : Boolean;
    function GetMessagingList : TFhirCapabilityStatementMessagingList;
    function GetHasMessagingList : Boolean;
    function GetDocumentList : TFhirCapabilityStatementDocumentList;
    function GetHasDocumentList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCapabilityStatement; overload;
    function Clone : TFhirCapabilityStatement; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this capability statement when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this capability statement is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the capability statement. For more information see [Technical and Business Versions](resource.html#versions).
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this capability statement when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this capability statement is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the capability statement. For more information see [Technical and Business Versions](resource.html#versions).
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to The identifier that is used to identify this version of the capability statement when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the capability statement author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the capability statement when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the capability statement author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the capability statement. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the capability statement. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the capability statement.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the capability statement.
    property titleElement : TFhirString read FTitle write SetTitle;

    // The status of this capability statement. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A boolean value to indicate that this capability statement is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A boolean value to indicate that this capability statement is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The date  (and optionally time) when the capability statement was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the capability statement changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the capability statement was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the capability statement changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the capability statement.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the capability statement.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the capability statement from a consumer's perspective. Typically, this is used when the capability statement describes a desired rather than an actual solution, for example as a formal expression of requirements as part of an RFP.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the capability statement from a consumer's perspective. Typically, this is used when the capability statement describes a desired rather than an actual solution, for example as a formal expression of requirements as part of an RFP.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These terms may be used to assist with indexing and searching for appropriate capability statement instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the capability statement is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to Explaination of why this capability statement is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explaination of why this capability statement is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Typed access to A copyright statement relating to the capability statement and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the capability statement.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the capability statement and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the capability statement.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // The way that this statement is intended to be used, to describe an actual running instance of software, a particular product (kind not instance of software) or a class of implementation (e.g. a desired purchase).
    property kind : TFhirCapabilityStatementKindEnum read GetKindST write SetKindST;
    property kindElement : TFhirEnum read FKind write SetKind;

    // Reference to a canonical URL of another CapabilityStatement that this software implements or uses. This capability statement is a {$IFNDEF FPC}Published{$ENDIF} API description that corresponds to a business service. The rest of the capability statement does not need to repeat the details of the referenced resource, but can do so.
    property instantiatesList : TFhirUriList read GetInstantiatesList;
    property hasInstantiatesList : boolean read GetHasInstantiatesList;

    // Typed access to Software that is covered by this capability statement.  It is used when the capability statement describes the capabilities of a particular software version, independent of an installation. (defined for API consistency)
    property software : TFhirCapabilityStatementSoftware read FSoftware write SetSoftware;
    // Software that is covered by this capability statement.  It is used when the capability statement describes the capabilities of a particular software version, independent of an installation.
    property softwareElement : TFhirCapabilityStatementSoftware read FSoftware write SetSoftware;

    // Typed access to Identifies a specific implementation instance that is described by the capability statement - i.e. a particular installation, rather than the capabilities of a software program. (defined for API consistency)
    property implementation_ : TFhirCapabilityStatementImplementation read FImplementation_ write SetImplementation_;
    // Identifies a specific implementation instance that is described by the capability statement - i.e. a particular installation, rather than the capabilities of a software program.
    property implementation_Element : TFhirCapabilityStatementImplementation read FImplementation_ write SetImplementation_;

    // Typed access to The version of the FHIR specification on which this capability statement is based.
    property fhirVersion : String read GetFhirVersionST write SetFhirVersionST;
    // The version of the FHIR specification on which this capability statement is based.
    property fhirVersionElement : TFhirId read FFhirVersion write SetFhirVersion;

    // A code that indicates whether the application accepts unknown elements or extensions when reading resources.
    property acceptUnknown : TFhirUnknownContentCodeEnum read GetAcceptUnknownST write SetAcceptUnknownST;
    property acceptUnknownElement : TFhirEnum read FAcceptUnknown write SetAcceptUnknown;

    // A list of the formats supported by this implementation using their content types.
    property formatList : TFhirCodeList read GetFormatList;
    property hasFormatList : boolean read GetHasFormatList;

    // A list of the patch formats supported by this implementation using their content types.
    property patchFormatList : TFhirCodeList read GetPatchFormatList;
    property hasPatchFormatList : boolean read GetHasPatchFormatList;

    // A list of implementation guides that the server does (or should) support in their entirety.
    property implementationGuideList : TFhirUriList read GetImplementationGuideList;
    property hasImplementationGuideList : boolean read GetHasImplementationGuideList;

    // A list of profiles that represent different use cases supported by the system. For a server, "supported by the system" means the system hosts/produces a set of resources that are conformant to a particular profile, and allows clients that use its services to search using this profile and to find appropriate data. For a client, it means the system will search by this profile and process data according to the guidance implicit in the profile. See further discussion in [Using Profiles](profiling.html#profile-uses).
    property profileList : TFhirReferenceList{TFhirStructureDefinition} read GetProfileList;
    property hasProfileList : boolean read GetHasProfileList;

    // A definition of the restful capabilities of the solution, if any.
    property restList : TFhirCapabilityStatementRestList read GetRestList;
    property hasRestList : boolean read GetHasRestList;

    // A description of the messaging capabilities of the solution.
    property messagingList : TFhirCapabilityStatementMessagingList read GetMessagingList;
    property hasMessagingList : boolean read GetHasMessagingList;

    // A document definition.
    property documentList : TFhirCapabilityStatementDocumentList read GetDocumentList;
    property hasDocumentList : boolean read GetHasDocumentList;

  end;

  TFhirCapabilityStatementListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCapabilityStatementList;
    function GetCurrent : TFhirCapabilityStatement;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCapabilityStatementList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCapabilityStatement read GetCurrent;
  end;

  TFhirCapabilityStatementList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCapabilityStatement;
    procedure SetItemN(index : Integer; value : TFhirCapabilityStatement);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCapabilityStatementList; Overload;
    function Clone : TFhirCapabilityStatementList; Overload;
    function GetEnumerator : TFhirCapabilityStatementListEnumerator;

    //  Add a FhirCapabilityStatement to the end of the list.
    function Append : TFhirCapabilityStatement;

    // Add an already existing FhirCapabilityStatement to the end of the list.
    procedure AddItem(value : TFhirCapabilityStatement); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCapabilityStatement) : Integer;

    // Insert FhirCapabilityStatement before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCapabilityStatement;

    // Insert an existing FhirCapabilityStatement before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCapabilityStatement);

    // Get the iIndexth FhirCapabilityStatement. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCapabilityStatement);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCapabilityStatement;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCapabilityStatements[index : Integer] : TFhirCapabilityStatement read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CAPABILITYSTATEMENT}

{$IFDEF FHIR_CODESYSTEM}

  // A filter that can be used in a value set compose statement when selecting concepts using a filter.
  TFhirCodeSystemFilter = class (TFhirBackboneElement)
  protected
    FCode : TFhirCode;
    FDescription : TFhirString;
    FOperator : TFhirEnumList;
    FValue : TFhirString;
    Procedure SetCode(value : TFhirCode);
    Function GetCodeST : String;
    Procedure SetCodeST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    function GetOperator : TFhirEnumList;
    function GetHasOperator : Boolean;
    Function GetOperatorST : TFhirFilterOperatorEnumList;
    Procedure SetOperatorST(value : TFhirFilterOperatorEnumList);
    Procedure SetValue(value : TFhirString);
    Function GetValueST : String;
    Procedure SetValueST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCodeSystemFilter; overload;
    function Clone : TFhirCodeSystemFilter; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The code that identifies this filter when it is used in the instance.
    property code : String read GetCodeST write SetCodeST;
    // The code that identifies this filter when it is used in the instance.
    property codeElement : TFhirCode read FCode write SetCode;

    // Typed access to A description of how or why the filter is used.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A description of how or why the filter is used.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // A list of operators that can be used with the filter.
    property operator : TFhirFilterOperatorEnumList read GetOperatorST write SetOperatorST;
    property operatorList : TFhirEnumList read GetOperator;
    property hasOperator : boolean read GetHasOperator;
    // Typed access to A description of what the value for the filter should be.
    property value : String read GetValueST write SetValueST;
    // A description of what the value for the filter should be.
    property valueElement : TFhirString read FValue write SetValue;

  end;

  TFhirCodeSystemFilterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCodeSystemFilterList;
    function GetCurrent : TFhirCodeSystemFilter;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCodeSystemFilterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCodeSystemFilter read GetCurrent;
  end;

  TFhirCodeSystemFilterList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCodeSystemFilter;
    procedure SetItemN(index : Integer; value : TFhirCodeSystemFilter);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCodeSystemFilterList; Overload;
    function Clone : TFhirCodeSystemFilterList; Overload;
    function GetEnumerator : TFhirCodeSystemFilterListEnumerator;

    //  Add a FhirCodeSystemFilter to the end of the list.
    function Append : TFhirCodeSystemFilter;

    // Add an already existing FhirCodeSystemFilter to the end of the list.
    procedure AddItem(value : TFhirCodeSystemFilter); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCodeSystemFilter) : Integer;

    // Insert FhirCodeSystemFilter before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCodeSystemFilter;

    // Insert an existing FhirCodeSystemFilter before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCodeSystemFilter);

    // Get the iIndexth FhirCodeSystemFilter. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCodeSystemFilter);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCodeSystemFilter;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCodeSystemFilters[index : Integer] : TFhirCodeSystemFilter read GetItemN write SetItemN; default;
  End;

  // A property defines an additional slot through which additional information can be provided about a concept.
  TFhirCodeSystemProperty = class (TFhirBackboneElement)
  protected
    FCode : TFhirCode;
    FUri : TFhirUri;
    FDescription : TFhirString;
    FType_ : TFhirEnum;
    Procedure SetCode(value : TFhirCode);
    Function GetCodeST : String;
    Procedure SetCodeST(value : String);
    Procedure SetUri(value : TFhirUri);
    Function GetUriST : String;
    Procedure SetUriST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirConceptPropertyTypeEnum;
    Procedure SetType_ST(value : TFhirConceptPropertyTypeEnum);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCodeSystemProperty; overload;
    function Clone : TFhirCodeSystemProperty; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A code that is used to identify the property. The code is used internally (in CodeSystem.concept.property.code) and also externally, such as in property filters.
    property code : String read GetCodeST write SetCodeST;
    // A code that is used to identify the property. The code is used internally (in CodeSystem.concept.property.code) and also externally, such as in property filters.
    property codeElement : TFhirCode read FCode write SetCode;

    // Typed access to Reference to the formal meaning of the property. One possible source of meaning is the [Concept Properties](codesystem-concept-properties.html) code system.
    property uri : String read GetUriST write SetUriST;
    // Reference to the formal meaning of the property. One possible source of meaning is the [Concept Properties](codesystem-concept-properties.html) code system.
    property uriElement : TFhirUri read FUri write SetUri;

    // Typed access to A description of the property- why it is defined, and how its value might be used.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A description of the property- why it is defined, and how its value might be used.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // The type of the property value. Properties of type "code" contain a code defined by the code system (e.g. a reference to anotherr defined concept).
    property type_ : TFhirConceptPropertyTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

  end;

  TFhirCodeSystemPropertyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCodeSystemPropertyList;
    function GetCurrent : TFhirCodeSystemProperty;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCodeSystemPropertyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCodeSystemProperty read GetCurrent;
  end;

  TFhirCodeSystemPropertyList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCodeSystemProperty;
    procedure SetItemN(index : Integer; value : TFhirCodeSystemProperty);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCodeSystemPropertyList; Overload;
    function Clone : TFhirCodeSystemPropertyList; Overload;
    function GetEnumerator : TFhirCodeSystemPropertyListEnumerator;

    //  Add a FhirCodeSystemProperty to the end of the list.
    function Append : TFhirCodeSystemProperty;

    // Add an already existing FhirCodeSystemProperty to the end of the list.
    procedure AddItem(value : TFhirCodeSystemProperty); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCodeSystemProperty) : Integer;

    // Insert FhirCodeSystemProperty before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCodeSystemProperty;

    // Insert an existing FhirCodeSystemProperty before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCodeSystemProperty);

    // Get the iIndexth FhirCodeSystemProperty. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCodeSystemProperty);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCodeSystemProperty;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCodeSystemProperties[index : Integer] : TFhirCodeSystemProperty read GetItemN write SetItemN; default;
  End;

  // Concepts that are in the code system. The concept definitions are inherently hierarchical, but the definitions must be consulted to determine what the meaning of the hierarchical relationships are.
  TFhirCodeSystemConcept = class (TFhirBackboneElement)
  protected
    FCode : TFhirCode;
    FDisplay : TFhirString;
    FDefinition : TFhirString;
    FdesignationList : TFhirCodeSystemConceptDesignationList;
    Fproperty_List : TFhirCodeSystemConceptPropertyList;
    FconceptList : TFhirCodeSystemConceptList;
    Procedure SetCode(value : TFhirCode);
    Function GetCodeST : String;
    Procedure SetCodeST(value : String);
    Procedure SetDisplay(value : TFhirString);
    Function GetDisplayST : String;
    Procedure SetDisplayST(value : String);
    Procedure SetDefinition(value : TFhirString);
    Function GetDefinitionST : String;
    Procedure SetDefinitionST(value : String);
    function GetDesignationList : TFhirCodeSystemConceptDesignationList;
    function GetHasDesignationList : Boolean;
    function GetProperty_List : TFhirCodeSystemConceptPropertyList;
    function GetHasProperty_List : Boolean;
    function GetConceptList : TFhirCodeSystemConceptList;
    function GetHasConceptList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCodeSystemConcept; overload;
    function Clone : TFhirCodeSystemConcept; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A code - a text symbol - that uniquely identifies the concept within the code system.
    property code : String read GetCodeST write SetCodeST;
    // A code - a text symbol - that uniquely identifies the concept within the code system.
    property codeElement : TFhirCode read FCode write SetCode;

    // Typed access to A human readable string that is the recommended default way to present this concept to a user.
    property display : String read GetDisplayST write SetDisplayST;
    // A human readable string that is the recommended default way to present this concept to a user.
    property displayElement : TFhirString read FDisplay write SetDisplay;

    // Typed access to The formal definition of the concept. The code system resource does not make formal definitions required, because of the prevalence of legacy systems. However, they are highly recommended, as without them there is no formal meaning associated with the concept.
    property definition : String read GetDefinitionST write SetDefinitionST;
    // The formal definition of the concept. The code system resource does not make formal definitions required, because of the prevalence of legacy systems. However, they are highly recommended, as without them there is no formal meaning associated with the concept.
    property definitionElement : TFhirString read FDefinition write SetDefinition;

    // Additional representations for the concept - other languages, aliases, specialized purposes, used for particular purposes, etc.
    property designationList : TFhirCodeSystemConceptDesignationList read GetDesignationList;
    property hasDesignationList : boolean read GetHasDesignationList;

    // A property value for this concept.
    property property_List : TFhirCodeSystemConceptPropertyList read GetProperty_List;
    property hasProperty_List : boolean read GetHasProperty_List;

    // Defines children of a concept to produce a hierarchy of concepts. The nature of the relationships is variable (is-a/contains/categorizes) - see hierarchyMeaning.
    property conceptList : TFhirCodeSystemConceptList read GetConceptList;
    property hasConceptList : boolean read GetHasConceptList;

  end;

  TFhirCodeSystemConceptListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCodeSystemConceptList;
    function GetCurrent : TFhirCodeSystemConcept;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCodeSystemConceptList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCodeSystemConcept read GetCurrent;
  end;

  TFhirCodeSystemConceptList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCodeSystemConcept;
    procedure SetItemN(index : Integer; value : TFhirCodeSystemConcept);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCodeSystemConceptList; Overload;
    function Clone : TFhirCodeSystemConceptList; Overload;
    function GetEnumerator : TFhirCodeSystemConceptListEnumerator;

    //  Add a FhirCodeSystemConcept to the end of the list.
    function Append : TFhirCodeSystemConcept;

    // Add an already existing FhirCodeSystemConcept to the end of the list.
    procedure AddItem(value : TFhirCodeSystemConcept); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCodeSystemConcept) : Integer;

    // Insert FhirCodeSystemConcept before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCodeSystemConcept;

    // Insert an existing FhirCodeSystemConcept before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCodeSystemConcept);

    // Get the iIndexth FhirCodeSystemConcept. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCodeSystemConcept);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCodeSystemConcept;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCodeSystemConcepts[index : Integer] : TFhirCodeSystemConcept read GetItemN write SetItemN; default;
  End;

  // Additional representations for the concept - other languages, aliases, specialized purposes, used for particular purposes, etc.
  TFhirCodeSystemConceptDesignation = class (TFhirBackboneElement)
  protected
    FLanguage : TFhirCode;
    FUse : TFhirCoding;
    FValue : TFhirString;
    Procedure SetLanguage(value : TFhirCode);
    Function GetLanguageST : String;
    Procedure SetLanguageST(value : String);
    Procedure SetUse(value : TFhirCoding);
    Procedure SetValue(value : TFhirString);
    Function GetValueST : String;
    Procedure SetValueST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCodeSystemConceptDesignation; overload;
    function Clone : TFhirCodeSystemConceptDesignation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The language this designation is defined for.
    property language : String read GetLanguageST write SetLanguageST;
    // The language this designation is defined for.
    property languageElement : TFhirCode read FLanguage write SetLanguage;

    // Typed access to A code that details how this designation would be used. (defined for API consistency)
    property use : TFhirCoding read FUse write SetUse;
    // A code that details how this designation would be used.
    property useElement : TFhirCoding read FUse write SetUse;

    // Typed access to The text value for this designation.
    property value : String read GetValueST write SetValueST;
    // The text value for this designation.
    property valueElement : TFhirString read FValue write SetValue;

  end;

  TFhirCodeSystemConceptDesignationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCodeSystemConceptDesignationList;
    function GetCurrent : TFhirCodeSystemConceptDesignation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCodeSystemConceptDesignationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCodeSystemConceptDesignation read GetCurrent;
  end;

  TFhirCodeSystemConceptDesignationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCodeSystemConceptDesignation;
    procedure SetItemN(index : Integer; value : TFhirCodeSystemConceptDesignation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCodeSystemConceptDesignationList; Overload;
    function Clone : TFhirCodeSystemConceptDesignationList; Overload;
    function GetEnumerator : TFhirCodeSystemConceptDesignationListEnumerator;

    //  Add a FhirCodeSystemConceptDesignation to the end of the list.
    function Append : TFhirCodeSystemConceptDesignation;

    // Add an already existing FhirCodeSystemConceptDesignation to the end of the list.
    procedure AddItem(value : TFhirCodeSystemConceptDesignation); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCodeSystemConceptDesignation) : Integer;

    // Insert FhirCodeSystemConceptDesignation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCodeSystemConceptDesignation;

    // Insert an existing FhirCodeSystemConceptDesignation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCodeSystemConceptDesignation);

    // Get the iIndexth FhirCodeSystemConceptDesignation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCodeSystemConceptDesignation);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCodeSystemConceptDesignation;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCodeSystemConceptDesignations[index : Integer] : TFhirCodeSystemConceptDesignation read GetItemN write SetItemN; default;
  End;

  // A property value for this concept.
  TFhirCodeSystemConceptProperty = class (TFhirBackboneElement)
  protected
    FCode : TFhirCode;
    FValue : TFhirType;
    Procedure SetCode(value : TFhirCode);
    Function GetCodeST : String;
    Procedure SetCodeST(value : String);
    Procedure SetValue(value : TFhirType);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCodeSystemConceptProperty; overload;
    function Clone : TFhirCodeSystemConceptProperty; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A code that is a reference to CodeSystem.property.code.
    property code : String read GetCodeST write SetCodeST;
    // A code that is a reference to CodeSystem.property.code.
    property codeElement : TFhirCode read FCode write SetCode;

    // Typed access to The value of this property. (defined for API consistency)
    property value : TFhirType read FValue write SetValue;
    // The value of this property.
    property valueElement : TFhirType read FValue write SetValue;

  end;

  TFhirCodeSystemConceptPropertyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCodeSystemConceptPropertyList;
    function GetCurrent : TFhirCodeSystemConceptProperty;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCodeSystemConceptPropertyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCodeSystemConceptProperty read GetCurrent;
  end;

  TFhirCodeSystemConceptPropertyList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCodeSystemConceptProperty;
    procedure SetItemN(index : Integer; value : TFhirCodeSystemConceptProperty);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCodeSystemConceptPropertyList; Overload;
    function Clone : TFhirCodeSystemConceptPropertyList; Overload;
    function GetEnumerator : TFhirCodeSystemConceptPropertyListEnumerator;

    //  Add a FhirCodeSystemConceptProperty to the end of the list.
    function Append : TFhirCodeSystemConceptProperty;

    // Add an already existing FhirCodeSystemConceptProperty to the end of the list.
    procedure AddItem(value : TFhirCodeSystemConceptProperty); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCodeSystemConceptProperty) : Integer;

    // Insert FhirCodeSystemConceptProperty before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCodeSystemConceptProperty;

    // Insert an existing FhirCodeSystemConceptProperty before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCodeSystemConceptProperty);

    // Get the iIndexth FhirCodeSystemConceptProperty. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCodeSystemConceptProperty);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCodeSystemConceptProperty;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCodeSystemConceptProperties[index : Integer] : TFhirCodeSystemConceptProperty read GetItemN write SetItemN; default;
  End;

  // A code system resource specifies a set of codes drawn from one or more code systems.
  TFhirCodeSystem = class (TFhirMetadataResource)
  protected
    FIdentifier : TFhirIdentifier;
    FPurpose : TFhirMarkdown;
    FCopyright : TFhirMarkdown;
    FCaseSensitive : TFhirBoolean;
    FValueSet : TFhirUri;
    FHierarchyMeaning : TFhirEnum;
    FCompositional : TFhirBoolean;
    FVersionNeeded : TFhirBoolean;
    FContent : TFhirEnum;
    FCount : TFhirUnsignedInt;
    FfilterList : TFhirCodeSystemFilterList;
    Fproperty_List : TFhirCodeSystemPropertyList;
    FconceptList : TFhirCodeSystemConceptList;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetPurpose(value : TFhirMarkdown);
    Function GetPurposeST : String;
    Procedure SetPurposeST(value : String);
    Procedure SetCopyright(value : TFhirMarkdown);
    Function GetCopyrightST : String;
    Procedure SetCopyrightST(value : String);
    Procedure SetCaseSensitive(value : TFhirBoolean);
    Function GetCaseSensitiveST : Boolean;
    Procedure SetCaseSensitiveST(value : Boolean);
    Procedure SetValueSet(value : TFhirUri);
    Function GetValueSetST : String;
    Procedure SetValueSetST(value : String);
    Procedure SetHierarchyMeaning(value : TFhirEnum);
    Function GetHierarchyMeaningST : TFhirCodesystemHierarchyMeaningEnum;
    Procedure SetHierarchyMeaningST(value : TFhirCodesystemHierarchyMeaningEnum);
    Procedure SetCompositional(value : TFhirBoolean);
    Function GetCompositionalST : Boolean;
    Procedure SetCompositionalST(value : Boolean);
    Procedure SetVersionNeeded(value : TFhirBoolean);
    Function GetVersionNeededST : Boolean;
    Procedure SetVersionNeededST(value : Boolean);
    Procedure SetContent(value : TFhirEnum);
    Function GetContentST : TFhirCodesystemContentModeEnum;
    Procedure SetContentST(value : TFhirCodesystemContentModeEnum);
    Procedure SetCount(value : TFhirUnsignedInt);
    Function GetCountST : String;
    Procedure SetCountST(value : String);
    function GetFilterList : TFhirCodeSystemFilterList;
    function GetHasFilterList : Boolean;
    function GetProperty_List : TFhirCodeSystemPropertyList;
    function GetHasProperty_List : Boolean;
    function GetConceptList : TFhirCodeSystemConceptList;
    function GetHasConceptList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCodeSystem; overload;
    function Clone : TFhirCodeSystem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this code system when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this code system is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the code system. For more information see [Technical and Business Versions](resource.html#versions). This is used in [Coding].system.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this code system when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this code system is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the code system. For more information see [Technical and Business Versions](resource.html#versions). This is used in [Coding].system.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to A formal identifier that is used to identify this code system when it is represented in other formats, or referenced in a specification, model, design or an instance. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // A formal identifier that is used to identify this code system when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to The identifier that is used to identify this version of the code system when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the code system author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. This is used in [Coding].version.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the code system when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the code system author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. This is used in [Coding].version.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the code system. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the code system. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the code system.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the code system.
    property titleElement : TFhirString read FTitle write SetTitle;

    // The status of this code system. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A boolean value to indicate that this code system is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A boolean value to indicate that this code system is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The date  (and optionally time) when the code system was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the code system changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the code system was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the code system changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the code system.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the code system.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the code system from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the code system from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These terms may be used to assist with indexing and searching for appropriate code system instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the code system is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to Explaination of why this code system is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explaination of why this code system is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Typed access to A copyright statement relating to the code system and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the code system.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the code system and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the code system.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // Typed access to If code comparison is case sensitive when codes within this system are compared to each other.
    property caseSensitive : Boolean read GetCaseSensitiveST write SetCaseSensitiveST;
    // If code comparison is case sensitive when codes within this system are compared to each other.
    property caseSensitiveElement : TFhirBoolean read FCaseSensitive write SetCaseSensitive;

    // Typed access to Canonical URL of value set that contains the entire code system.
    property valueSet : String read GetValueSetST write SetValueSetST;
    // Canonical URL of value set that contains the entire code system.
    property valueSetElement : TFhirUri read FValueSet write SetValueSet;

    // The meaning of the hierarchy of concepts.
    property hierarchyMeaning : TFhirCodesystemHierarchyMeaningEnum read GetHierarchyMeaningST write SetHierarchyMeaningST;
    property hierarchyMeaningElement : TFhirEnum read FHierarchyMeaning write SetHierarchyMeaning;

    // Typed access to True If code system defines a post-composition grammar.
    property compositional : Boolean read GetCompositionalST write SetCompositionalST;
    // True If code system defines a post-composition grammar.
    property compositionalElement : TFhirBoolean read FCompositional write SetCompositional;

    // Typed access to This flag is used to signify that the code system has not (or does not) maintain the definitions, and a version must be specified when referencing this code system.
    property versionNeeded : Boolean read GetVersionNeededST write SetVersionNeededST;
    // This flag is used to signify that the code system has not (or does not) maintain the definitions, and a version must be specified when referencing this code system.
    property versionNeededElement : TFhirBoolean read FVersionNeeded write SetVersionNeeded;

    // How much of the content of the code system - the concepts and codes it defines - are represented in this resource.
    property content : TFhirCodesystemContentModeEnum read GetContentST write SetContentST;
    property contentElement : TFhirEnum read FContent write SetContent;

    // Typed access to The total number of concepts defined by the code system. Where the code system has a compositional grammar, the count refers to the number of base (primitive) concepts.
    property count : String read GetCountST write SetCountST;
    // The total number of concepts defined by the code system. Where the code system has a compositional grammar, the count refers to the number of base (primitive) concepts.
    property countElement : TFhirUnsignedInt read FCount write SetCount;

    // A filter that can be used in a value set compose statement when selecting concepts using a filter.
    property filterList : TFhirCodeSystemFilterList read GetFilterList;
    property hasFilterList : boolean read GetHasFilterList;

    // A property defines an additional slot through which additional information can be provided about a concept.
    property property_List : TFhirCodeSystemPropertyList read GetProperty_List;
    property hasProperty_List : boolean read GetHasProperty_List;

    // Concepts that are in the code system. The concept definitions are inherently hierarchical, but the definitions must be consulted to determine what the meaning of the hierarchical relationships are.
    property conceptList : TFhirCodeSystemConceptList read GetConceptList;
    property hasConceptList : boolean read GetHasConceptList;

  end;

  TFhirCodeSystemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCodeSystemList;
    function GetCurrent : TFhirCodeSystem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCodeSystemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCodeSystem read GetCurrent;
  end;

  TFhirCodeSystemList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCodeSystem;
    procedure SetItemN(index : Integer; value : TFhirCodeSystem);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCodeSystemList; Overload;
    function Clone : TFhirCodeSystemList; Overload;
    function GetEnumerator : TFhirCodeSystemListEnumerator;

    //  Add a FhirCodeSystem to the end of the list.
    function Append : TFhirCodeSystem;

    // Add an already existing FhirCodeSystem to the end of the list.
    procedure AddItem(value : TFhirCodeSystem); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCodeSystem) : Integer;

    // Insert FhirCodeSystem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCodeSystem;

    // Insert an existing FhirCodeSystem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCodeSystem);

    // Get the iIndexth FhirCodeSystem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCodeSystem);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCodeSystem;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCodeSystems[index : Integer] : TFhirCodeSystem read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CODESYSTEM}

{$IFDEF FHIR_COMPARTMENTDEFINITION}

  // Information about how a resource is related to the compartment.
  TFhirCompartmentDefinitionResource = class (TFhirBackboneElement)
  protected
    FCode : TFhirEnum;
    FparamList : TFhirStringList;
    FDocumentation : TFhirString;
    Procedure SetCode(value : TFhirEnum);
    Function GetCodeST : TFhirResourceTypesEnum;
    Procedure SetCodeST(value : TFhirResourceTypesEnum);
    function GetParamList : TFhirStringList;
    function GetHasParamList : Boolean;
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCompartmentDefinitionResource; overload;
    function Clone : TFhirCompartmentDefinitionResource; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The name of a resource supported by the server.
    property code : TFhirResourceTypesEnum read GetCodeST write SetCodeST;
    property codeElement : TFhirEnum read FCode write SetCode;

    // The name of a search parameter that represents the link to the compartment. More than one may be listed because a resource may be linked to a compartment in more than one way,.
    property paramList : TFhirStringList read GetParamList;
    property hasParamList : boolean read GetHasParamList;

    // Typed access to Additional documentation about the resource and compartment.
    property documentation : String read GetDocumentationST write SetDocumentationST;
    // Additional documentation about the resource and compartment.
    property documentationElement : TFhirString read FDocumentation write SetDocumentation;

  end;

  TFhirCompartmentDefinitionResourceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCompartmentDefinitionResourceList;
    function GetCurrent : TFhirCompartmentDefinitionResource;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCompartmentDefinitionResourceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCompartmentDefinitionResource read GetCurrent;
  end;

  TFhirCompartmentDefinitionResourceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCompartmentDefinitionResource;
    procedure SetItemN(index : Integer; value : TFhirCompartmentDefinitionResource);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCompartmentDefinitionResourceList; Overload;
    function Clone : TFhirCompartmentDefinitionResourceList; Overload;
    function GetEnumerator : TFhirCompartmentDefinitionResourceListEnumerator;

    //  Add a FhirCompartmentDefinitionResource to the end of the list.
    function Append : TFhirCompartmentDefinitionResource;

    // Add an already existing FhirCompartmentDefinitionResource to the end of the list.
    procedure AddItem(value : TFhirCompartmentDefinitionResource); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCompartmentDefinitionResource) : Integer;

    // Insert FhirCompartmentDefinitionResource before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCompartmentDefinitionResource;

    // Insert an existing FhirCompartmentDefinitionResource before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCompartmentDefinitionResource);

    // Get the iIndexth FhirCompartmentDefinitionResource. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCompartmentDefinitionResource);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCompartmentDefinitionResource;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCompartmentDefinitionResources[index : Integer] : TFhirCompartmentDefinitionResource read GetItemN write SetItemN; default;
  End;

  // A compartment definition that defines how resources are accessed on a server.
  TFhirCompartmentDefinition = class (TFhirMetadataResource)
  protected
    FPurpose : TFhirMarkdown;
    FCode : TFhirEnum;
    FSearch : TFhirBoolean;
    FresourceList : TFhirCompartmentDefinitionResourceList;
    Procedure SetPurpose(value : TFhirMarkdown);
    Function GetPurposeST : String;
    Procedure SetPurposeST(value : String);
    Procedure SetCode(value : TFhirEnum);
    Function GetCodeST : TFhirCompartmentTypeEnum;
    Procedure SetCodeST(value : TFhirCompartmentTypeEnum);
    Procedure SetSearch(value : TFhirBoolean);
    Function GetSearchST : Boolean;
    Procedure SetSearchST(value : Boolean);
    function GetResourceList : TFhirCompartmentDefinitionResourceList;
    function GetHasResourceList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCompartmentDefinition; overload;
    function Clone : TFhirCompartmentDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this compartment definition when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this compartment definition is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the compartment definition. For more information see [Technical and Business Versions](resource.html#versions).
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this compartment definition when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this compartment definition is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the compartment definition. For more information see [Technical and Business Versions](resource.html#versions).
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to A natural language name identifying the compartment definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the compartment definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the compartment definition.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the compartment definition.
    property titleElement : TFhirString read FTitle write SetTitle;

    // The status of this compartment definition. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A boolean value to indicate that this compartment definition is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A boolean value to indicate that this compartment definition is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The date  (and optionally time) when the compartment definition was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the compartment definition changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the compartment definition was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the compartment definition changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the compartment definition.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the compartment definition.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the compartment definition from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the compartment definition from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // Typed access to Explaination of why this compartment definition is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explaination of why this compartment definition is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These terms may be used to assist with indexing and searching for appropriate compartment definition instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the compartment definition is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Which compartment this definition describes.
    property code : TFhirCompartmentTypeEnum read GetCodeST write SetCodeST;
    property codeElement : TFhirEnum read FCode write SetCode;

    // Typed access to Whether the search syntax is supported,.
    property search : Boolean read GetSearchST write SetSearchST;
    // Whether the search syntax is supported,.
    property searchElement : TFhirBoolean read FSearch write SetSearch;

    // Information about how a resource is related to the compartment.
    property resourceList : TFhirCompartmentDefinitionResourceList read GetResourceList;
    property hasResourceList : boolean read GetHasResourceList;

  end;

  TFhirCompartmentDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCompartmentDefinitionList;
    function GetCurrent : TFhirCompartmentDefinition;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirCompartmentDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCompartmentDefinition read GetCurrent;
  end;

  TFhirCompartmentDefinitionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirCompartmentDefinition;
    procedure SetItemN(index : Integer; value : TFhirCompartmentDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirCompartmentDefinitionList; Overload;
    function Clone : TFhirCompartmentDefinitionList; Overload;
    function GetEnumerator : TFhirCompartmentDefinitionListEnumerator;

    //  Add a FhirCompartmentDefinition to the end of the list.
    function Append : TFhirCompartmentDefinition;

    // Add an already existing FhirCompartmentDefinition to the end of the list.
    procedure AddItem(value : TFhirCompartmentDefinition); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCompartmentDefinition) : Integer;

    // Insert FhirCompartmentDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCompartmentDefinition;

    // Insert an existing FhirCompartmentDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCompartmentDefinition);

    // Get the iIndexth FhirCompartmentDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCompartmentDefinition);

    // The number of items in the collection
    function Item(index : Integer) : TFhirCompartmentDefinition;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirCompartmentDefinitions[index : Integer] : TFhirCompartmentDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_COMPARTMENTDEFINITION}

{$IFDEF FHIR_CONCEPTMAP}

  // A group of mappings that all have the same source and target system.
  TFhirConceptMapGroup = class (TFhirBackboneElement)
  protected
    FSource : TFhirUri;
    FSourceVersion : TFhirString;
    FTarget : TFhirUri;
    FTargetVersion : TFhirString;
    FelementList : TFhirConceptMapGroupElementList;
    FUnmapped : TFhirConceptMapGroupUnmapped;
    Procedure SetSource(value : TFhirUri);
    Function GetSourceST : String;
    Procedure SetSourceST(value : String);
    Procedure SetSourceVersion(value : TFhirString);
    Function GetSourceVersionST : String;
    Procedure SetSourceVersionST(value : String);
    Procedure SetTarget(value : TFhirUri);
    Function GetTargetST : String;
    Procedure SetTargetST(value : String);
    Procedure SetTargetVersion(value : TFhirString);
    Function GetTargetVersionST : String;
    Procedure SetTargetVersionST(value : String);
    function GetElementList : TFhirConceptMapGroupElementList;
    function GetHasElementList : Boolean;
    Procedure SetUnmapped(value : TFhirConceptMapGroupUnmapped);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConceptMapGroup; overload;
    function Clone : TFhirConceptMapGroup; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An absolute URI that identifies the Code System (if the source is a value set that crosses more than one code system).
    property source : String read GetSourceST write SetSourceST;
    // An absolute URI that identifies the Code System (if the source is a value set that crosses more than one code system).
    property sourceElement : TFhirUri read FSource write SetSource;

    // Typed access to The specific version of the code system, as determined by the code system authority.
    property sourceVersion : String read GetSourceVersionST write SetSourceVersionST;
    // The specific version of the code system, as determined by the code system authority.
    property sourceVersionElement : TFhirString read FSourceVersion write SetSourceVersion;

    // Typed access to An absolute URI that identifies the code system of the target code (if the target is a value set that cross code systems).
    property target : String read GetTargetST write SetTargetST;
    // An absolute URI that identifies the code system of the target code (if the target is a value set that cross code systems).
    property targetElement : TFhirUri read FTarget write SetTarget;

    // Typed access to The specific version of the code system, as determined by the code system authority.
    property targetVersion : String read GetTargetVersionST write SetTargetVersionST;
    // The specific version of the code system, as determined by the code system authority.
    property targetVersionElement : TFhirString read FTargetVersion write SetTargetVersion;

    // Mappings for an individual concept in the source to one or more concepts in the target.
    property elementList : TFhirConceptMapGroupElementList read GetElementList;
    property hasElementList : boolean read GetHasElementList;

    // Typed access to What to do when there is no match in the mappings in the group. (defined for API consistency)
    property unmapped : TFhirConceptMapGroupUnmapped read FUnmapped write SetUnmapped;
    // What to do when there is no match in the mappings in the group.
    property unmappedElement : TFhirConceptMapGroupUnmapped read FUnmapped write SetUnmapped;

  end;

  TFhirConceptMapGroupListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConceptMapGroupList;
    function GetCurrent : TFhirConceptMapGroup;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConceptMapGroupList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConceptMapGroup read GetCurrent;
  end;

  TFhirConceptMapGroupList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConceptMapGroup;
    procedure SetItemN(index : Integer; value : TFhirConceptMapGroup);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConceptMapGroupList; Overload;
    function Clone : TFhirConceptMapGroupList; Overload;
    function GetEnumerator : TFhirConceptMapGroupListEnumerator;

    //  Add a FhirConceptMapGroup to the end of the list.
    function Append : TFhirConceptMapGroup;

    // Add an already existing FhirConceptMapGroup to the end of the list.
    procedure AddItem(value : TFhirConceptMapGroup); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConceptMapGroup) : Integer;

    // Insert FhirConceptMapGroup before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConceptMapGroup;

    // Insert an existing FhirConceptMapGroup before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConceptMapGroup);

    // Get the iIndexth FhirConceptMapGroup. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConceptMapGroup);

    // The number of items in the collection
    function Item(index : Integer) : TFhirConceptMapGroup;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirConceptMapGroups[index : Integer] : TFhirConceptMapGroup read GetItemN write SetItemN; default;
  End;

  // Mappings for an individual concept in the source to one or more concepts in the target.
  TFhirConceptMapGroupElement = class (TFhirBackboneElement)
  protected
    FCode : TFhirCode;
    FDisplay : TFhirString;
    FtargetList : TFhirConceptMapGroupElementTargetList;
    Procedure SetCode(value : TFhirCode);
    Function GetCodeST : String;
    Procedure SetCodeST(value : String);
    Procedure SetDisplay(value : TFhirString);
    Function GetDisplayST : String;
    Procedure SetDisplayST(value : String);
    function GetTargetList : TFhirConceptMapGroupElementTargetList;
    function GetHasTargetList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConceptMapGroupElement; overload;
    function Clone : TFhirConceptMapGroupElement; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Identity (code or path) or the element/item being mapped.
    property code : String read GetCodeST write SetCodeST;
    // Identity (code or path) or the element/item being mapped.
    property codeElement : TFhirCode read FCode write SetCode;

    // Typed access to The display for the code. The display is only provided to help editors when editing the concept map.
    property display : String read GetDisplayST write SetDisplayST;
    // The display for the code. The display is only provided to help editors when editing the concept map.
    property displayElement : TFhirString read FDisplay write SetDisplay;

    // A concept from the target value set that this concept maps to.
    property targetList : TFhirConceptMapGroupElementTargetList read GetTargetList;
    property hasTargetList : boolean read GetHasTargetList;

  end;

  TFhirConceptMapGroupElementListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConceptMapGroupElementList;
    function GetCurrent : TFhirConceptMapGroupElement;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConceptMapGroupElementList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConceptMapGroupElement read GetCurrent;
  end;

  TFhirConceptMapGroupElementList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConceptMapGroupElement;
    procedure SetItemN(index : Integer; value : TFhirConceptMapGroupElement);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConceptMapGroupElementList; Overload;
    function Clone : TFhirConceptMapGroupElementList; Overload;
    function GetEnumerator : TFhirConceptMapGroupElementListEnumerator;

    //  Add a FhirConceptMapGroupElement to the end of the list.
    function Append : TFhirConceptMapGroupElement;

    // Add an already existing FhirConceptMapGroupElement to the end of the list.
    procedure AddItem(value : TFhirConceptMapGroupElement); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConceptMapGroupElement) : Integer;

    // Insert FhirConceptMapGroupElement before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConceptMapGroupElement;

    // Insert an existing FhirConceptMapGroupElement before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConceptMapGroupElement);

    // Get the iIndexth FhirConceptMapGroupElement. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConceptMapGroupElement);

    // The number of items in the collection
    function Item(index : Integer) : TFhirConceptMapGroupElement;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirConceptMapGroupElements[index : Integer] : TFhirConceptMapGroupElement read GetItemN write SetItemN; default;
  End;

  // A concept from the target value set that this concept maps to.
  TFhirConceptMapGroupElementTarget = class (TFhirBackboneElement)
  protected
    FCode : TFhirCode;
    FDisplay : TFhirString;
    FEquivalence : TFhirEnum;
    FComment : TFhirString;
    FdependsOnList : TFhirConceptMapGroupElementTargetDependsOnList;
    FproductList : TFhirConceptMapGroupElementTargetDependsOnList;
    Procedure SetCode(value : TFhirCode);
    Function GetCodeST : String;
    Procedure SetCodeST(value : String);
    Procedure SetDisplay(value : TFhirString);
    Function GetDisplayST : String;
    Procedure SetDisplayST(value : String);
    Procedure SetEquivalence(value : TFhirEnum);
    Function GetEquivalenceST : TFhirConceptMapEquivalenceEnum;
    Procedure SetEquivalenceST(value : TFhirConceptMapEquivalenceEnum);
    Procedure SetComment(value : TFhirString);
    Function GetCommentST : String;
    Procedure SetCommentST(value : String);
    function GetDependsOnList : TFhirConceptMapGroupElementTargetDependsOnList;
    function GetHasDependsOnList : Boolean;
    function GetProductList : TFhirConceptMapGroupElementTargetDependsOnList;
    function GetHasProductList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConceptMapGroupElementTarget; overload;
    function Clone : TFhirConceptMapGroupElementTarget; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Identity (code or path) or the element/item that the map refers to.
    property code : String read GetCodeST write SetCodeST;
    // Identity (code or path) or the element/item that the map refers to.
    property codeElement : TFhirCode read FCode write SetCode;

    // Typed access to The display for the code. The display is only provided to help editors when editing the concept map.
    property display : String read GetDisplayST write SetDisplayST;
    // The display for the code. The display is only provided to help editors when editing the concept map.
    property displayElement : TFhirString read FDisplay write SetDisplay;

    // The equivalence between the source and target concepts (counting for the dependencies and products). The equivalence is read from target to source (e.g. the target is 'wider' than the source).
    property equivalence : TFhirConceptMapEquivalenceEnum read GetEquivalenceST write SetEquivalenceST;
    property equivalenceElement : TFhirEnum read FEquivalence write SetEquivalence;

    // Typed access to A description of status/issues in mapping that conveys additional information not represented in  the structured data.
    property comment : String read GetCommentST write SetCommentST;
    // A description of status/issues in mapping that conveys additional information not represented in  the structured data.
    property commentElement : TFhirString read FComment write SetComment;

    // A set of additional dependencies for this mapping to hold. This mapping is only applicable if the specified element can be resolved, and it has the specified value.
    property dependsOnList : TFhirConceptMapGroupElementTargetDependsOnList read GetDependsOnList;
    property hasDependsOnList : boolean read GetHasDependsOnList;

    // A set of additional outcomes from this mapping to other elements. To properly execute this mapping, the specified element must be mapped to some data element or source that is in context. The mapping may still be useful without a place for the additional data elements, but the equivalence cannot be relied on.
    property productList : TFhirConceptMapGroupElementTargetDependsOnList read GetProductList;
    property hasProductList : boolean read GetHasProductList;

  end;

  TFhirConceptMapGroupElementTargetListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConceptMapGroupElementTargetList;
    function GetCurrent : TFhirConceptMapGroupElementTarget;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConceptMapGroupElementTargetList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConceptMapGroupElementTarget read GetCurrent;
  end;

  TFhirConceptMapGroupElementTargetList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConceptMapGroupElementTarget;
    procedure SetItemN(index : Integer; value : TFhirConceptMapGroupElementTarget);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConceptMapGroupElementTargetList; Overload;
    function Clone : TFhirConceptMapGroupElementTargetList; Overload;
    function GetEnumerator : TFhirConceptMapGroupElementTargetListEnumerator;

    //  Add a FhirConceptMapGroupElementTarget to the end of the list.
    function Append : TFhirConceptMapGroupElementTarget;

    // Add an already existing FhirConceptMapGroupElementTarget to the end of the list.
    procedure AddItem(value : TFhirConceptMapGroupElementTarget); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConceptMapGroupElementTarget) : Integer;

    // Insert FhirConceptMapGroupElementTarget before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConceptMapGroupElementTarget;

    // Insert an existing FhirConceptMapGroupElementTarget before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConceptMapGroupElementTarget);

    // Get the iIndexth FhirConceptMapGroupElementTarget. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConceptMapGroupElementTarget);

    // The number of items in the collection
    function Item(index : Integer) : TFhirConceptMapGroupElementTarget;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirConceptMapGroupElementTargets[index : Integer] : TFhirConceptMapGroupElementTarget read GetItemN write SetItemN; default;
  End;

  // A set of additional dependencies for this mapping to hold. This mapping is only applicable if the specified element can be resolved, and it has the specified value.
  TFhirConceptMapGroupElementTargetDependsOn = class (TFhirBackboneElement)
  protected
    FProperty_ : TFhirUri;
    FSystem : TFhirUri;
    FCode : TFhirString;
    FDisplay : TFhirString;
    Procedure SetProperty_(value : TFhirUri);
    Function GetProperty_ST : String;
    Procedure SetProperty_ST(value : String);
    Procedure SetSystem(value : TFhirUri);
    Function GetSystemST : String;
    Procedure SetSystemST(value : String);
    Procedure SetCode(value : TFhirString);
    Function GetCodeST : String;
    Procedure SetCodeST(value : String);
    Procedure SetDisplay(value : TFhirString);
    Function GetDisplayST : String;
    Procedure SetDisplayST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConceptMapGroupElementTargetDependsOn; overload;
    function Clone : TFhirConceptMapGroupElementTargetDependsOn; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A reference to an element that holds a coded value that corresponds to a code system property. The idea is that the information model carries an element somwhere that is labeled to correspond with a code system property.
    property property_ : String read GetProperty_ST write SetProperty_ST;
    // A reference to an element that holds a coded value that corresponds to a code system property. The idea is that the information model carries an element somwhere that is labeled to correspond with a code system property.
    property property_Element : TFhirUri read FProperty_ write SetProperty_;

    // Typed access to An absolute URI that identifies the code system of the dependency code (if the source/dependency is a value set that crosses code systems).
    property system : String read GetSystemST write SetSystemST;
    // An absolute URI that identifies the code system of the dependency code (if the source/dependency is a value set that crosses code systems).
    property systemElement : TFhirUri read FSystem write SetSystem;

    // Typed access to Identity (code or path) or the element/item/ValueSet that the map depends on / refers to.
    property code : String read GetCodeST write SetCodeST;
    // Identity (code or path) or the element/item/ValueSet that the map depends on / refers to.
    property codeElement : TFhirString read FCode write SetCode;

    // Typed access to The display for the code. The display is only provided to help editors when editing the concept map.
    property display : String read GetDisplayST write SetDisplayST;
    // The display for the code. The display is only provided to help editors when editing the concept map.
    property displayElement : TFhirString read FDisplay write SetDisplay;

  end;

  TFhirConceptMapGroupElementTargetDependsOnListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConceptMapGroupElementTargetDependsOnList;
    function GetCurrent : TFhirConceptMapGroupElementTargetDependsOn;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConceptMapGroupElementTargetDependsOnList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConceptMapGroupElementTargetDependsOn read GetCurrent;
  end;

  TFhirConceptMapGroupElementTargetDependsOnList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConceptMapGroupElementTargetDependsOn;
    procedure SetItemN(index : Integer; value : TFhirConceptMapGroupElementTargetDependsOn);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConceptMapGroupElementTargetDependsOnList; Overload;
    function Clone : TFhirConceptMapGroupElementTargetDependsOnList; Overload;
    function GetEnumerator : TFhirConceptMapGroupElementTargetDependsOnListEnumerator;

    //  Add a FhirConceptMapGroupElementTargetDependsOn to the end of the list.
    function Append : TFhirConceptMapGroupElementTargetDependsOn;

    // Add an already existing FhirConceptMapGroupElementTargetDependsOn to the end of the list.
    procedure AddItem(value : TFhirConceptMapGroupElementTargetDependsOn); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConceptMapGroupElementTargetDependsOn) : Integer;

    // Insert FhirConceptMapGroupElementTargetDependsOn before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConceptMapGroupElementTargetDependsOn;

    // Insert an existing FhirConceptMapGroupElementTargetDependsOn before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConceptMapGroupElementTargetDependsOn);

    // Get the iIndexth FhirConceptMapGroupElementTargetDependsOn. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConceptMapGroupElementTargetDependsOn);

    // The number of items in the collection
    function Item(index : Integer) : TFhirConceptMapGroupElementTargetDependsOn;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirConceptMapGroupElementTargetDependsOns[index : Integer] : TFhirConceptMapGroupElementTargetDependsOn read GetItemN write SetItemN; default;
  End;

  // What to do when there is no match in the mappings in the group.
  TFhirConceptMapGroupUnmapped = class (TFhirBackboneElement)
  protected
    FMode : TFhirEnum;
    FCode : TFhirCode;
    FDisplay : TFhirString;
    FUrl : TFhirUri;
    Procedure SetMode(value : TFhirEnum);
    Function GetModeST : TFhirConceptmapUnmappedModeEnum;
    Procedure SetModeST(value : TFhirConceptmapUnmappedModeEnum);
    Procedure SetCode(value : TFhirCode);
    Function GetCodeST : String;
    Procedure SetCodeST(value : String);
    Procedure SetDisplay(value : TFhirString);
    Function GetDisplayST : String;
    Procedure SetDisplayST(value : String);
    Procedure SetUrl(value : TFhirUri);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConceptMapGroupUnmapped; overload;
    function Clone : TFhirConceptMapGroupUnmapped; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Defines which action to take if there is no match in the group. One of 3 actions is possible: use the unmapped code (this is useful when doing a mapping between versions, and only a few codes have changed), use a fixed code (a default code), or alternatively, a reference to a different concept map can be provided (by canonical URL).
    property mode : TFhirConceptmapUnmappedModeEnum read GetModeST write SetModeST;
    property modeElement : TFhirEnum read FMode write SetMode;

    // Typed access to The fixed code to use when the mode = 'fixed'  - all unmapped codes are mapped to a single fixed code.
    property code : String read GetCodeST write SetCodeST;
    // The fixed code to use when the mode = 'fixed'  - all unmapped codes are mapped to a single fixed code.
    property codeElement : TFhirCode read FCode write SetCode;

    // Typed access to The display for the code. The display is only provided to help editors when editing the concept map.
    property display : String read GetDisplayST write SetDisplayST;
    // The display for the code. The display is only provided to help editors when editing the concept map.
    property displayElement : TFhirString read FDisplay write SetDisplay;

    // Typed access to The canonical URL of the map to use if this map contains no mapping.
    property url : String read GetUrlST write SetUrlST;
    // The canonical URL of the map to use if this map contains no mapping.
    property urlElement : TFhirUri read FUrl write SetUrl;

  end;

  TFhirConceptMapGroupUnmappedListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConceptMapGroupUnmappedList;
    function GetCurrent : TFhirConceptMapGroupUnmapped;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConceptMapGroupUnmappedList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConceptMapGroupUnmapped read GetCurrent;
  end;

  TFhirConceptMapGroupUnmappedList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConceptMapGroupUnmapped;
    procedure SetItemN(index : Integer; value : TFhirConceptMapGroupUnmapped);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConceptMapGroupUnmappedList; Overload;
    function Clone : TFhirConceptMapGroupUnmappedList; Overload;
    function GetEnumerator : TFhirConceptMapGroupUnmappedListEnumerator;

    //  Add a FhirConceptMapGroupUnmapped to the end of the list.
    function Append : TFhirConceptMapGroupUnmapped;

    // Add an already existing FhirConceptMapGroupUnmapped to the end of the list.
    procedure AddItem(value : TFhirConceptMapGroupUnmapped); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConceptMapGroupUnmapped) : Integer;

    // Insert FhirConceptMapGroupUnmapped before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConceptMapGroupUnmapped;

    // Insert an existing FhirConceptMapGroupUnmapped before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConceptMapGroupUnmapped);

    // Get the iIndexth FhirConceptMapGroupUnmapped. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConceptMapGroupUnmapped);

    // The number of items in the collection
    function Item(index : Integer) : TFhirConceptMapGroupUnmapped;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirConceptMapGroupUnmappeds[index : Integer] : TFhirConceptMapGroupUnmapped read GetItemN write SetItemN; default;
  End;

  // A statement of relationships from one set of concepts to one or more other concepts - either code systems or data elements, or classes in class models.
  TFhirConceptMap = class (TFhirMetadataResource)
  protected
    FIdentifier : TFhirIdentifier;
    FPurpose : TFhirMarkdown;
    FCopyright : TFhirMarkdown;
    FSource : TFhirType;
    FTarget : TFhirType;
    FgroupList : TFhirConceptMapGroupList;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetPurpose(value : TFhirMarkdown);
    Function GetPurposeST : String;
    Procedure SetPurposeST(value : String);
    Procedure SetCopyright(value : TFhirMarkdown);
    Function GetCopyrightST : String;
    Procedure SetCopyrightST(value : String);
    Procedure SetSource(value : TFhirType);
    Procedure SetTarget(value : TFhirType);
    function GetGroupList : TFhirConceptMapGroupList;
    function GetHasGroupList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConceptMap; overload;
    function Clone : TFhirConceptMap; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this concept map when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this concept map is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the concept map. For more information see [Technical and Business Versions](resource.html#versions).
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this concept map when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this concept map is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the concept map. For more information see [Technical and Business Versions](resource.html#versions).
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to A formal identifier that is used to identify this concept map when it is represented in other formats, or referenced in a specification, model, design or an instance. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // A formal identifier that is used to identify this concept map when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to The identifier that is used to identify this version of the concept map when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the concept map author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the concept map when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the concept map author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the concept map. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the concept map. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the concept map.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the concept map.
    property titleElement : TFhirString read FTitle write SetTitle;

    // The status of this concept map. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A boolean value to indicate that this concept map is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A boolean value to indicate that this concept map is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The date  (and optionally time) when the concept map was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the concept map changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the concept map was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the concept map changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the concept map.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the concept map.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the concept map from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the concept map from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These terms may be used to assist with indexing and searching for appropriate concept map instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the concept map is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to Explaination of why this concept map is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explaination of why this concept map is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Typed access to A copyright statement relating to the concept map and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the concept map.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the concept map and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the concept map.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // Typed access to The source value set that specifies the concepts that are being mapped. (defined for API consistency)
    property source : TFhirType read FSource write SetSource;
    // The source value set that specifies the concepts that are being mapped.
    property sourceElement : TFhirType read FSource write SetSource;

    // Typed access to The target value set provides context to the mappings. Note that the mapping is made between concepts, not between value sets, but the value set provides important context about how the concept mapping choices are made. (defined for API consistency)
    property target : TFhirType read FTarget write SetTarget;
    // The target value set provides context to the mappings. Note that the mapping is made between concepts, not between value sets, but the value set provides important context about how the concept mapping choices are made.
    property targetElement : TFhirType read FTarget write SetTarget;

    // A group of mappings that all have the same source and target system.
    property groupList : TFhirConceptMapGroupList read GetGroupList;
    property hasGroupList : boolean read GetHasGroupList;

  end;

  TFhirConceptMapListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConceptMapList;
    function GetCurrent : TFhirConceptMap;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirConceptMapList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConceptMap read GetCurrent;
  end;

  TFhirConceptMapList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirConceptMap;
    procedure SetItemN(index : Integer; value : TFhirConceptMap);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirConceptMapList; Overload;
    function Clone : TFhirConceptMapList; Overload;
    function GetEnumerator : TFhirConceptMapListEnumerator;

    //  Add a FhirConceptMap to the end of the list.
    function Append : TFhirConceptMap;

    // Add an already existing FhirConceptMap to the end of the list.
    procedure AddItem(value : TFhirConceptMap); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConceptMap) : Integer;

    // Insert FhirConceptMap before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConceptMap;

    // Insert an existing FhirConceptMap before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConceptMap);

    // Get the iIndexth FhirConceptMap. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConceptMap);

    // The number of items in the collection
    function Item(index : Integer) : TFhirConceptMap;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirConceptMaps[index : Integer] : TFhirConceptMap read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CONCEPTMAP}

{$IFDEF FHIR_DATAELEMENT}

  // Identifies a specification (other than a terminology) that the elements which make up the DataElement have some correspondence with.
  TFhirDataElementMapping = class (TFhirBackboneElement)
  protected
    FIdentity : TFhirId;
    FUri : TFhirUri;
    FName : TFhirString;
    FComment : TFhirString;
    Procedure SetIdentity(value : TFhirId);
    Function GetIdentityST : String;
    Procedure SetIdentityST(value : String);
    Procedure SetUri(value : TFhirUri);
    Function GetUriST : String;
    Procedure SetUriST(value : String);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetComment(value : TFhirString);
    Function GetCommentST : String;
    Procedure SetCommentST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDataElementMapping; overload;
    function Clone : TFhirDataElementMapping; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An internal id that is used to identify this mapping set when specific mappings are made on a per-element basis.
    property identity : String read GetIdentityST write SetIdentityST;
    // An internal id that is used to identify this mapping set when specific mappings are made on a per-element basis.
    property identityElement : TFhirId read FIdentity write SetIdentity;

    // Typed access to An absolute URI that identifies the specification that this mapping is expressed to.
    property uri : String read GetUriST write SetUriST;
    // An absolute URI that identifies the specification that this mapping is expressed to.
    property uriElement : TFhirUri read FUri write SetUri;

    // Typed access to A name for the specification that is being mapped to.
    property name : String read GetNameST write SetNameST;
    // A name for the specification that is being mapped to.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Comments about this mapping, including version notes, issues, scope limitations, and other important notes for usage.
    property comment : String read GetCommentST write SetCommentST;
    // Comments about this mapping, including version notes, issues, scope limitations, and other important notes for usage.
    property commentElement : TFhirString read FComment write SetComment;

  end;

  TFhirDataElementMappingListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDataElementMappingList;
    function GetCurrent : TFhirDataElementMapping;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDataElementMappingList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDataElementMapping read GetCurrent;
  end;

  TFhirDataElementMappingList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDataElementMapping;
    procedure SetItemN(index : Integer; value : TFhirDataElementMapping);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDataElementMappingList; Overload;
    function Clone : TFhirDataElementMappingList; Overload;
    function GetEnumerator : TFhirDataElementMappingListEnumerator;

    //  Add a FhirDataElementMapping to the end of the list.
    function Append : TFhirDataElementMapping;

    // Add an already existing FhirDataElementMapping to the end of the list.
    procedure AddItem(value : TFhirDataElementMapping); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDataElementMapping) : Integer;

    // Insert FhirDataElementMapping before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDataElementMapping;

    // Insert an existing FhirDataElementMapping before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDataElementMapping);

    // Get the iIndexth FhirDataElementMapping. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDataElementMapping);

    // The number of items in the collection
    function Item(index : Integer) : TFhirDataElementMapping;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirDataElementMappings[index : Integer] : TFhirDataElementMapping read GetItemN write SetItemN; default;
  End;

  // The formal description of a single piece of information that can be gathered and reported.
  TFhirDataElement = class (TFhirMetadataResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FCopyright : TFhirMarkdown;
    FStringency : TFhirEnum;
    FmappingList : TFhirDataElementMappingList;
    FelementList : TFhirElementDefinitionList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetCopyright(value : TFhirMarkdown);
    Function GetCopyrightST : String;
    Procedure SetCopyrightST(value : String);
    Procedure SetStringency(value : TFhirEnum);
    Function GetStringencyST : TFhirDataelementStringencyEnum;
    Procedure SetStringencyST(value : TFhirDataelementStringencyEnum);
    function GetMappingList : TFhirDataElementMappingList;
    function GetHasMappingList : Boolean;
    function GetElementList : TFhirElementDefinitionList;
    function GetHasElementList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDataElement; overload;
    function Clone : TFhirDataElement; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this data element when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this data element is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the data element. For more information see [Technical and Business Versions](resource.html#versions).
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this data element when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this data element is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the data element. For more information see [Technical and Business Versions](resource.html#versions).
    property urlElement : TFhirUri read FUrl write SetUrl;

    // A formal identifier that is used to identify this data element when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the data element when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the data element author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the data element when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the data element author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property versionElement : TFhirString read FVersion write SetVersion;

    // The status of this data element. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A boolean value to indicate that this data element is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A boolean value to indicate that this data element is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The date  (and optionally time) when the data element was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the data element changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the data element was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the data element changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the data element.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the data element.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Typed access to A natural language name identifying the data element. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the data element. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the data element.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the data element.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These terms may be used to assist with indexing and searching for appropriate data element instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the data element is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to A copyright statement relating to the data element and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the data element.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the data element and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the data element.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // Identifies how precise the data element is in its definition.
    property stringency : TFhirDataelementStringencyEnum read GetStringencyST write SetStringencyST;
    property stringencyElement : TFhirEnum read FStringency write SetStringency;

    // Identifies a specification (other than a terminology) that the elements which make up the DataElement have some correspondence with.
    property mappingList : TFhirDataElementMappingList read GetMappingList;
    property hasMappingList : boolean read GetHasMappingList;

    // Defines the structure, type, allowed values and other constraining characteristics of the data element.
    property elementList : TFhirElementDefinitionList read GetElementList;
    property hasElementList : boolean read GetHasElementList;

  end;

  TFhirDataElementListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDataElementList;
    function GetCurrent : TFhirDataElement;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirDataElementList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDataElement read GetCurrent;
  end;

  TFhirDataElementList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirDataElement;
    procedure SetItemN(index : Integer; value : TFhirDataElement);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirDataElementList; Overload;
    function Clone : TFhirDataElementList; Overload;
    function GetEnumerator : TFhirDataElementListEnumerator;

    //  Add a FhirDataElement to the end of the list.
    function Append : TFhirDataElement;

    // Add an already existing FhirDataElement to the end of the list.
    procedure AddItem(value : TFhirDataElement); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDataElement) : Integer;

    // Insert FhirDataElement before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDataElement;

    // Insert an existing FhirDataElement before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDataElement);

    // Get the iIndexth FhirDataElement. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDataElement);

    // The number of items in the collection
    function Item(index : Integer) : TFhirDataElement;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirDataElements[index : Integer] : TFhirDataElement read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_DATAELEMENT}

{$IFDEF FHIR_EXPANSIONPROFILE}

  // Fix use of a particular code system to a particular version.
  TFhirExpansionProfileFixedVersion = class (TFhirBackboneElement)
  protected
    FSystem : TFhirUri;
    FVersion : TFhirString;
    FMode : TFhirEnum;
    Procedure SetSystem(value : TFhirUri);
    Function GetSystemST : String;
    Procedure SetSystemST(value : String);
    Procedure SetVersion(value : TFhirString);
    Function GetVersionST : String;
    Procedure SetVersionST(value : String);
    Procedure SetMode(value : TFhirEnum);
    Function GetModeST : TFhirSystemVersionProcessingModeEnum;
    Procedure SetModeST(value : TFhirSystemVersionProcessingModeEnum);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExpansionProfileFixedVersion; overload;
    function Clone : TFhirExpansionProfileFixedVersion; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The specific system for which to fix the version.
    property system : String read GetSystemST write SetSystemST;
    // The specific system for which to fix the version.
    property systemElement : TFhirUri read FSystem write SetSystem;

    // Typed access to The version of the code system from which codes in the expansion should be included.
    property version : String read GetVersionST write SetVersionST;
    // The version of the code system from which codes in the expansion should be included.
    property versionElement : TFhirString read FVersion write SetVersion;

    // How to manage the intersection between a fixed version in a value set, and this fixed version of the system in the expansion profile.
    property mode : TFhirSystemVersionProcessingModeEnum read GetModeST write SetModeST;
    property modeElement : TFhirEnum read FMode write SetMode;

  end;

  TFhirExpansionProfileFixedVersionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExpansionProfileFixedVersionList;
    function GetCurrent : TFhirExpansionProfileFixedVersion;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExpansionProfileFixedVersionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExpansionProfileFixedVersion read GetCurrent;
  end;

  TFhirExpansionProfileFixedVersionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExpansionProfileFixedVersion;
    procedure SetItemN(index : Integer; value : TFhirExpansionProfileFixedVersion);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExpansionProfileFixedVersionList; Overload;
    function Clone : TFhirExpansionProfileFixedVersionList; Overload;
    function GetEnumerator : TFhirExpansionProfileFixedVersionListEnumerator;

    //  Add a FhirExpansionProfileFixedVersion to the end of the list.
    function Append : TFhirExpansionProfileFixedVersion;

    // Add an already existing FhirExpansionProfileFixedVersion to the end of the list.
    procedure AddItem(value : TFhirExpansionProfileFixedVersion); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExpansionProfileFixedVersion) : Integer;

    // Insert FhirExpansionProfileFixedVersion before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExpansionProfileFixedVersion;

    // Insert an existing FhirExpansionProfileFixedVersion before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExpansionProfileFixedVersion);

    // Get the iIndexth FhirExpansionProfileFixedVersion. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExpansionProfileFixedVersion);

    // The number of items in the collection
    function Item(index : Integer) : TFhirExpansionProfileFixedVersion;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirExpansionProfileFixedVersions[index : Integer] : TFhirExpansionProfileFixedVersion read GetItemN write SetItemN; default;
  End;

  // Code system, or a particular version of a code system to be excluded from value set expansions.
  TFhirExpansionProfileExcludedSystem = class (TFhirBackboneElement)
  protected
    FSystem : TFhirUri;
    FVersion : TFhirString;
    Procedure SetSystem(value : TFhirUri);
    Function GetSystemST : String;
    Procedure SetSystemST(value : String);
    Procedure SetVersion(value : TFhirString);
    Function GetVersionST : String;
    Procedure SetVersionST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExpansionProfileExcludedSystem; overload;
    function Clone : TFhirExpansionProfileExcludedSystem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An absolute URI which is the code system to be excluded.
    property system : String read GetSystemST write SetSystemST;
    // An absolute URI which is the code system to be excluded.
    property systemElement : TFhirUri read FSystem write SetSystem;

    // Typed access to The version of the code system from which codes in the expansion should be excluded.
    property version : String read GetVersionST write SetVersionST;
    // The version of the code system from which codes in the expansion should be excluded.
    property versionElement : TFhirString read FVersion write SetVersion;

  end;

  TFhirExpansionProfileExcludedSystemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExpansionProfileExcludedSystemList;
    function GetCurrent : TFhirExpansionProfileExcludedSystem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExpansionProfileExcludedSystemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExpansionProfileExcludedSystem read GetCurrent;
  end;

  TFhirExpansionProfileExcludedSystemList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExpansionProfileExcludedSystem;
    procedure SetItemN(index : Integer; value : TFhirExpansionProfileExcludedSystem);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExpansionProfileExcludedSystemList; Overload;
    function Clone : TFhirExpansionProfileExcludedSystemList; Overload;
    function GetEnumerator : TFhirExpansionProfileExcludedSystemListEnumerator;

    //  Add a FhirExpansionProfileExcludedSystem to the end of the list.
    function Append : TFhirExpansionProfileExcludedSystem;

    // Add an already existing FhirExpansionProfileExcludedSystem to the end of the list.
    procedure AddItem(value : TFhirExpansionProfileExcludedSystem); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExpansionProfileExcludedSystem) : Integer;

    // Insert FhirExpansionProfileExcludedSystem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExpansionProfileExcludedSystem;

    // Insert an existing FhirExpansionProfileExcludedSystem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExpansionProfileExcludedSystem);

    // Get the iIndexth FhirExpansionProfileExcludedSystem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExpansionProfileExcludedSystem);

    // The number of items in the collection
    function Item(index : Integer) : TFhirExpansionProfileExcludedSystem;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirExpansionProfileExcludedSystems[index : Integer] : TFhirExpansionProfileExcludedSystem read GetItemN write SetItemN; default;
  End;

  // A set of criteria that provide the constraints imposed on the value set expansion by including or excluding designations.
  TFhirExpansionProfileDesignation = class (TFhirBackboneElement)
  protected
    FInclude : TFhirExpansionProfileDesignationInclude;
    FExclude : TFhirExpansionProfileDesignationExclude;
    Procedure SetInclude(value : TFhirExpansionProfileDesignationInclude);
    Procedure SetExclude(value : TFhirExpansionProfileDesignationExclude);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExpansionProfileDesignation; overload;
    function Clone : TFhirExpansionProfileDesignation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Designations to be included. (defined for API consistency)
    property include : TFhirExpansionProfileDesignationInclude read FInclude write SetInclude;
    // Designations to be included.
    property includeElement : TFhirExpansionProfileDesignationInclude read FInclude write SetInclude;

    // Typed access to Designations to be excluded. (defined for API consistency)
    property exclude : TFhirExpansionProfileDesignationExclude read FExclude write SetExclude;
    // Designations to be excluded.
    property excludeElement : TFhirExpansionProfileDesignationExclude read FExclude write SetExclude;

  end;

  TFhirExpansionProfileDesignationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExpansionProfileDesignationList;
    function GetCurrent : TFhirExpansionProfileDesignation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExpansionProfileDesignationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExpansionProfileDesignation read GetCurrent;
  end;

  TFhirExpansionProfileDesignationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExpansionProfileDesignation;
    procedure SetItemN(index : Integer; value : TFhirExpansionProfileDesignation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExpansionProfileDesignationList; Overload;
    function Clone : TFhirExpansionProfileDesignationList; Overload;
    function GetEnumerator : TFhirExpansionProfileDesignationListEnumerator;

    //  Add a FhirExpansionProfileDesignation to the end of the list.
    function Append : TFhirExpansionProfileDesignation;

    // Add an already existing FhirExpansionProfileDesignation to the end of the list.
    procedure AddItem(value : TFhirExpansionProfileDesignation); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExpansionProfileDesignation) : Integer;

    // Insert FhirExpansionProfileDesignation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExpansionProfileDesignation;

    // Insert an existing FhirExpansionProfileDesignation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExpansionProfileDesignation);

    // Get the iIndexth FhirExpansionProfileDesignation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExpansionProfileDesignation);

    // The number of items in the collection
    function Item(index : Integer) : TFhirExpansionProfileDesignation;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirExpansionProfileDesignations[index : Integer] : TFhirExpansionProfileDesignation read GetItemN write SetItemN; default;
  End;

  // Designations to be included.
  TFhirExpansionProfileDesignationInclude = class (TFhirBackboneElement)
  protected
    FdesignationList : TFhirExpansionProfileDesignationIncludeDesignationList;
    function GetDesignationList : TFhirExpansionProfileDesignationIncludeDesignationList;
    function GetHasDesignationList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExpansionProfileDesignationInclude; overload;
    function Clone : TFhirExpansionProfileDesignationInclude; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // A data group for each designation to be included.
    property designationList : TFhirExpansionProfileDesignationIncludeDesignationList read GetDesignationList;
    property hasDesignationList : boolean read GetHasDesignationList;

  end;

  TFhirExpansionProfileDesignationIncludeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExpansionProfileDesignationIncludeList;
    function GetCurrent : TFhirExpansionProfileDesignationInclude;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExpansionProfileDesignationIncludeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExpansionProfileDesignationInclude read GetCurrent;
  end;

  TFhirExpansionProfileDesignationIncludeList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExpansionProfileDesignationInclude;
    procedure SetItemN(index : Integer; value : TFhirExpansionProfileDesignationInclude);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExpansionProfileDesignationIncludeList; Overload;
    function Clone : TFhirExpansionProfileDesignationIncludeList; Overload;
    function GetEnumerator : TFhirExpansionProfileDesignationIncludeListEnumerator;

    //  Add a FhirExpansionProfileDesignationInclude to the end of the list.
    function Append : TFhirExpansionProfileDesignationInclude;

    // Add an already existing FhirExpansionProfileDesignationInclude to the end of the list.
    procedure AddItem(value : TFhirExpansionProfileDesignationInclude); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExpansionProfileDesignationInclude) : Integer;

    // Insert FhirExpansionProfileDesignationInclude before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExpansionProfileDesignationInclude;

    // Insert an existing FhirExpansionProfileDesignationInclude before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExpansionProfileDesignationInclude);

    // Get the iIndexth FhirExpansionProfileDesignationInclude. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExpansionProfileDesignationInclude);

    // The number of items in the collection
    function Item(index : Integer) : TFhirExpansionProfileDesignationInclude;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirExpansionProfileDesignationIncludes[index : Integer] : TFhirExpansionProfileDesignationInclude read GetItemN write SetItemN; default;
  End;

  // A data group for each designation to be included.
  TFhirExpansionProfileDesignationIncludeDesignation = class (TFhirBackboneElement)
  protected
    FLanguage : TFhirCode;
    FUse : TFhirCoding;
    Procedure SetLanguage(value : TFhirCode);
    Function GetLanguageST : String;
    Procedure SetLanguageST(value : String);
    Procedure SetUse(value : TFhirCoding);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExpansionProfileDesignationIncludeDesignation; overload;
    function Clone : TFhirExpansionProfileDesignationIncludeDesignation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The language this designation is defined for.
    property language : String read GetLanguageST write SetLanguageST;
    // The language this designation is defined for.
    property languageElement : TFhirCode read FLanguage write SetLanguage;

    // Typed access to Which kinds of designation to include in the expansion. (defined for API consistency)
    property use : TFhirCoding read FUse write SetUse;
    // Which kinds of designation to include in the expansion.
    property useElement : TFhirCoding read FUse write SetUse;

  end;

  TFhirExpansionProfileDesignationIncludeDesignationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExpansionProfileDesignationIncludeDesignationList;
    function GetCurrent : TFhirExpansionProfileDesignationIncludeDesignation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExpansionProfileDesignationIncludeDesignationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExpansionProfileDesignationIncludeDesignation read GetCurrent;
  end;

  TFhirExpansionProfileDesignationIncludeDesignationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExpansionProfileDesignationIncludeDesignation;
    procedure SetItemN(index : Integer; value : TFhirExpansionProfileDesignationIncludeDesignation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExpansionProfileDesignationIncludeDesignationList; Overload;
    function Clone : TFhirExpansionProfileDesignationIncludeDesignationList; Overload;
    function GetEnumerator : TFhirExpansionProfileDesignationIncludeDesignationListEnumerator;

    //  Add a FhirExpansionProfileDesignationIncludeDesignation to the end of the list.
    function Append : TFhirExpansionProfileDesignationIncludeDesignation;

    // Add an already existing FhirExpansionProfileDesignationIncludeDesignation to the end of the list.
    procedure AddItem(value : TFhirExpansionProfileDesignationIncludeDesignation); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExpansionProfileDesignationIncludeDesignation) : Integer;

    // Insert FhirExpansionProfileDesignationIncludeDesignation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExpansionProfileDesignationIncludeDesignation;

    // Insert an existing FhirExpansionProfileDesignationIncludeDesignation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExpansionProfileDesignationIncludeDesignation);

    // Get the iIndexth FhirExpansionProfileDesignationIncludeDesignation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExpansionProfileDesignationIncludeDesignation);

    // The number of items in the collection
    function Item(index : Integer) : TFhirExpansionProfileDesignationIncludeDesignation;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirExpansionProfileDesignationIncludeDesignations[index : Integer] : TFhirExpansionProfileDesignationIncludeDesignation read GetItemN write SetItemN; default;
  End;

  // Designations to be excluded.
  TFhirExpansionProfileDesignationExclude = class (TFhirBackboneElement)
  protected
    FdesignationList : TFhirExpansionProfileDesignationExcludeDesignationList;
    function GetDesignationList : TFhirExpansionProfileDesignationExcludeDesignationList;
    function GetHasDesignationList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExpansionProfileDesignationExclude; overload;
    function Clone : TFhirExpansionProfileDesignationExclude; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // A data group for each designation to be excluded.
    property designationList : TFhirExpansionProfileDesignationExcludeDesignationList read GetDesignationList;
    property hasDesignationList : boolean read GetHasDesignationList;

  end;

  TFhirExpansionProfileDesignationExcludeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExpansionProfileDesignationExcludeList;
    function GetCurrent : TFhirExpansionProfileDesignationExclude;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExpansionProfileDesignationExcludeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExpansionProfileDesignationExclude read GetCurrent;
  end;

  TFhirExpansionProfileDesignationExcludeList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExpansionProfileDesignationExclude;
    procedure SetItemN(index : Integer; value : TFhirExpansionProfileDesignationExclude);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExpansionProfileDesignationExcludeList; Overload;
    function Clone : TFhirExpansionProfileDesignationExcludeList; Overload;
    function GetEnumerator : TFhirExpansionProfileDesignationExcludeListEnumerator;

    //  Add a FhirExpansionProfileDesignationExclude to the end of the list.
    function Append : TFhirExpansionProfileDesignationExclude;

    // Add an already existing FhirExpansionProfileDesignationExclude to the end of the list.
    procedure AddItem(value : TFhirExpansionProfileDesignationExclude); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExpansionProfileDesignationExclude) : Integer;

    // Insert FhirExpansionProfileDesignationExclude before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExpansionProfileDesignationExclude;

    // Insert an existing FhirExpansionProfileDesignationExclude before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExpansionProfileDesignationExclude);

    // Get the iIndexth FhirExpansionProfileDesignationExclude. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExpansionProfileDesignationExclude);

    // The number of items in the collection
    function Item(index : Integer) : TFhirExpansionProfileDesignationExclude;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirExpansionProfileDesignationExcludes[index : Integer] : TFhirExpansionProfileDesignationExclude read GetItemN write SetItemN; default;
  End;

  // A data group for each designation to be excluded.
  TFhirExpansionProfileDesignationExcludeDesignation = class (TFhirBackboneElement)
  protected
    FLanguage : TFhirCode;
    FUse : TFhirCoding;
    Procedure SetLanguage(value : TFhirCode);
    Function GetLanguageST : String;
    Procedure SetLanguageST(value : String);
    Procedure SetUse(value : TFhirCoding);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExpansionProfileDesignationExcludeDesignation; overload;
    function Clone : TFhirExpansionProfileDesignationExcludeDesignation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The language this designation is defined for.
    property language : String read GetLanguageST write SetLanguageST;
    // The language this designation is defined for.
    property languageElement : TFhirCode read FLanguage write SetLanguage;

    // Typed access to Which kinds of designation to exclude from the expansion. (defined for API consistency)
    property use : TFhirCoding read FUse write SetUse;
    // Which kinds of designation to exclude from the expansion.
    property useElement : TFhirCoding read FUse write SetUse;

  end;

  TFhirExpansionProfileDesignationExcludeDesignationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExpansionProfileDesignationExcludeDesignationList;
    function GetCurrent : TFhirExpansionProfileDesignationExcludeDesignation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExpansionProfileDesignationExcludeDesignationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExpansionProfileDesignationExcludeDesignation read GetCurrent;
  end;

  TFhirExpansionProfileDesignationExcludeDesignationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExpansionProfileDesignationExcludeDesignation;
    procedure SetItemN(index : Integer; value : TFhirExpansionProfileDesignationExcludeDesignation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExpansionProfileDesignationExcludeDesignationList; Overload;
    function Clone : TFhirExpansionProfileDesignationExcludeDesignationList; Overload;
    function GetEnumerator : TFhirExpansionProfileDesignationExcludeDesignationListEnumerator;

    //  Add a FhirExpansionProfileDesignationExcludeDesignation to the end of the list.
    function Append : TFhirExpansionProfileDesignationExcludeDesignation;

    // Add an already existing FhirExpansionProfileDesignationExcludeDesignation to the end of the list.
    procedure AddItem(value : TFhirExpansionProfileDesignationExcludeDesignation); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExpansionProfileDesignationExcludeDesignation) : Integer;

    // Insert FhirExpansionProfileDesignationExcludeDesignation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExpansionProfileDesignationExcludeDesignation;

    // Insert an existing FhirExpansionProfileDesignationExcludeDesignation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExpansionProfileDesignationExcludeDesignation);

    // Get the iIndexth FhirExpansionProfileDesignationExcludeDesignation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExpansionProfileDesignationExcludeDesignation);

    // The number of items in the collection
    function Item(index : Integer) : TFhirExpansionProfileDesignationExcludeDesignation;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirExpansionProfileDesignationExcludeDesignations[index : Integer] : TFhirExpansionProfileDesignationExcludeDesignation read GetItemN write SetItemN; default;
  End;

  // Resource to define constraints on the Expansion of a FHIR ValueSet.
  TFhirExpansionProfile = class (TFhirMetadataResource)
  protected
    FIdentifier : TFhirIdentifier;
    FfixedVersionList : TFhirExpansionProfileFixedVersionList;
    FExcludedSystem : TFhirExpansionProfileExcludedSystem;
    FIncludeDesignations : TFhirBoolean;
    FDesignation : TFhirExpansionProfileDesignation;
    FIncludeDefinition : TFhirBoolean;
    FActiveOnly : TFhirBoolean;
    FExcludeNested : TFhirBoolean;
    FExcludeNotForUI : TFhirBoolean;
    FExcludePostCoordinated : TFhirBoolean;
    FDisplayLanguage : TFhirCode;
    FLimitedExpansion : TFhirBoolean;
    Procedure SetIdentifier(value : TFhirIdentifier);
    function GetFixedVersionList : TFhirExpansionProfileFixedVersionList;
    function GetHasFixedVersionList : Boolean;
    Procedure SetExcludedSystem(value : TFhirExpansionProfileExcludedSystem);
    Procedure SetIncludeDesignations(value : TFhirBoolean);
    Function GetIncludeDesignationsST : Boolean;
    Procedure SetIncludeDesignationsST(value : Boolean);
    Procedure SetDesignation(value : TFhirExpansionProfileDesignation);
    Procedure SetIncludeDefinition(value : TFhirBoolean);
    Function GetIncludeDefinitionST : Boolean;
    Procedure SetIncludeDefinitionST(value : Boolean);
    Procedure SetActiveOnly(value : TFhirBoolean);
    Function GetActiveOnlyST : Boolean;
    Procedure SetActiveOnlyST(value : Boolean);
    Procedure SetExcludeNested(value : TFhirBoolean);
    Function GetExcludeNestedST : Boolean;
    Procedure SetExcludeNestedST(value : Boolean);
    Procedure SetExcludeNotForUI(value : TFhirBoolean);
    Function GetExcludeNotForUIST : Boolean;
    Procedure SetExcludeNotForUIST(value : Boolean);
    Procedure SetExcludePostCoordinated(value : TFhirBoolean);
    Function GetExcludePostCoordinatedST : Boolean;
    Procedure SetExcludePostCoordinatedST(value : Boolean);
    Procedure SetDisplayLanguage(value : TFhirCode);
    Function GetDisplayLanguageST : String;
    Procedure SetDisplayLanguageST(value : String);
    Procedure SetLimitedExpansion(value : TFhirBoolean);
    Function GetLimitedExpansionST : Boolean;
    Procedure SetLimitedExpansionST(value : Boolean);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirExpansionProfile; overload;
    function Clone : TFhirExpansionProfile; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this expansion profile when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this expansion profile is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the expansion profile. For more information see [Technical and Business Versions](resource.html#versions).
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this expansion profile when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this expansion profile is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the expansion profile. For more information see [Technical and Business Versions](resource.html#versions).
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to A formal identifier that is used to identify this expansion profile when it is represented in other formats, or referenced in a specification, model, design or an instance. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // A formal identifier that is used to identify this expansion profile when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to The identifier that is used to identify this version of the expansion profile when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the expansion profile author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the expansion profile when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the expansion profile author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the expansion profile. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the expansion profile. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // The status of this expansion profile. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A boolean value to indicate that this expansion profile is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A boolean value to indicate that this expansion profile is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The date  (and optionally time) when the expansion profile was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the expansion profile changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the expansion profile was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the expansion profile changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the expansion profile.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the expansion profile.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the expansion profile from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the expansion profile from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These terms may be used to assist with indexing and searching for appropriate expansion profile instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the expansion profile is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Fix use of a particular code system to a particular version.
    property fixedVersionList : TFhirExpansionProfileFixedVersionList read GetFixedVersionList;
    property hasFixedVersionList : boolean read GetHasFixedVersionList;

    // Typed access to Code system, or a particular version of a code system to be excluded from value set expansions. (defined for API consistency)
    property excludedSystem : TFhirExpansionProfileExcludedSystem read FExcludedSystem write SetExcludedSystem;
    // Code system, or a particular version of a code system to be excluded from value set expansions.
    property excludedSystemElement : TFhirExpansionProfileExcludedSystem read FExcludedSystem write SetExcludedSystem;

    // Typed access to Controls whether concept designations are to be included or excluded in value set expansions.
    property includeDesignations : Boolean read GetIncludeDesignationsST write SetIncludeDesignationsST;
    // Controls whether concept designations are to be included or excluded in value set expansions.
    property includeDesignationsElement : TFhirBoolean read FIncludeDesignations write SetIncludeDesignations;

    // Typed access to A set of criteria that provide the constraints imposed on the value set expansion by including or excluding designations. (defined for API consistency)
    property designation : TFhirExpansionProfileDesignation read FDesignation write SetDesignation;
    // A set of criteria that provide the constraints imposed on the value set expansion by including or excluding designations.
    property designationElement : TFhirExpansionProfileDesignation read FDesignation write SetDesignation;

    // Typed access to Controls whether the value set definition is included or excluded in value set expansions.
    property includeDefinition : Boolean read GetIncludeDefinitionST write SetIncludeDefinitionST;
    // Controls whether the value set definition is included or excluded in value set expansions.
    property includeDefinitionElement : TFhirBoolean read FIncludeDefinition write SetIncludeDefinition;

    // Typed access to Controls whether inactive concepts are included or excluded in value set expansions.
    property activeOnly : Boolean read GetActiveOnlyST write SetActiveOnlyST;
    // Controls whether inactive concepts are included or excluded in value set expansions.
    property activeOnlyElement : TFhirBoolean read FActiveOnly write SetActiveOnly;

    // Typed access to Controls whether or not the value set expansion nests codes or not (i.e. ValueSet.expansion.contains.contains).
    property excludeNested : Boolean read GetExcludeNestedST write SetExcludeNestedST;
    // Controls whether or not the value set expansion nests codes or not (i.e. ValueSet.expansion.contains.contains).
    property excludeNestedElement : TFhirBoolean read FExcludeNested write SetExcludeNested;

    // Typed access to Controls whether or not the value set expansion includes codes which cannot be displayed in user interfaces.
    property excludeNotForUI : Boolean read GetExcludeNotForUIST write SetExcludeNotForUIST;
    // Controls whether or not the value set expansion includes codes which cannot be displayed in user interfaces.
    property excludeNotForUIElement : TFhirBoolean read FExcludeNotForUI write SetExcludeNotForUI;

    // Typed access to Controls whether or not the value set expansion includes post coordinated codes.
    property excludePostCoordinated : Boolean read GetExcludePostCoordinatedST write SetExcludePostCoordinatedST;
    // Controls whether or not the value set expansion includes post coordinated codes.
    property excludePostCoordinatedElement : TFhirBoolean read FExcludePostCoordinated write SetExcludePostCoordinated;

    // Typed access to Specifies the language to be used for description in the expansions i.e. the language to be used for ValueSet.expansion.contains.display.
    property displayLanguage : String read GetDisplayLanguageST write SetDisplayLanguageST;
    // Specifies the language to be used for description in the expansions i.e. the language to be used for ValueSet.expansion.contains.display.
    property displayLanguageElement : TFhirCode read FDisplayLanguage write SetDisplayLanguage;

    // Typed access to If the value set being expanded is incomplete (because it is too big to expand), return a limited expansion (a subset) with an indicator that expansion is incomplete, using the extension [http://hl7.org/fhir/StructureDefinition/valueset-toocostly](extension-valueset-toocostly.html).
    property limitedExpansion : Boolean read GetLimitedExpansionST write SetLimitedExpansionST;
    // If the value set being expanded is incomplete (because it is too big to expand), return a limited expansion (a subset) with an indicator that expansion is incomplete, using the extension [http://hl7.org/fhir/StructureDefinition/valueset-toocostly](extension-valueset-toocostly.html).
    property limitedExpansionElement : TFhirBoolean read FLimitedExpansion write SetLimitedExpansion;

  end;

  TFhirExpansionProfileListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirExpansionProfileList;
    function GetCurrent : TFhirExpansionProfile;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirExpansionProfileList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirExpansionProfile read GetCurrent;
  end;

  TFhirExpansionProfileList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirExpansionProfile;
    procedure SetItemN(index : Integer; value : TFhirExpansionProfile);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirExpansionProfileList; Overload;
    function Clone : TFhirExpansionProfileList; Overload;
    function GetEnumerator : TFhirExpansionProfileListEnumerator;

    //  Add a FhirExpansionProfile to the end of the list.
    function Append : TFhirExpansionProfile;

    // Add an already existing FhirExpansionProfile to the end of the list.
    procedure AddItem(value : TFhirExpansionProfile); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirExpansionProfile) : Integer;

    // Insert FhirExpansionProfile before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirExpansionProfile;

    // Insert an existing FhirExpansionProfile before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirExpansionProfile);

    // Get the iIndexth FhirExpansionProfile. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirExpansionProfile);

    // The number of items in the collection
    function Item(index : Integer) : TFhirExpansionProfile;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirExpansionProfiles[index : Integer] : TFhirExpansionProfile read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_EXPANSIONPROFILE}

{$IFDEF FHIR_GRAPHDEFINITION}

  // Links this graph makes rules about.
  TFhirGraphDefinitionLink = class (TFhirBackboneElement)
  protected
    FPath : TFhirString;
    FSliceName : TFhirString;
    FMin : TFhirInteger;
    FMax : TFhirString;
    FDescription : TFhirString;
    FtargetList : TFhirGraphDefinitionLinkTargetList;
    Procedure SetPath(value : TFhirString);
    Function GetPathST : String;
    Procedure SetPathST(value : String);
    Procedure SetSliceName(value : TFhirString);
    Function GetSliceNameST : String;
    Procedure SetSliceNameST(value : String);
    Procedure SetMin(value : TFhirInteger);
    Function GetMinST : String;
    Procedure SetMinST(value : String);
    Procedure SetMax(value : TFhirString);
    Function GetMaxST : String;
    Procedure SetMaxST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    function GetTargetList : TFhirGraphDefinitionLinkTargetList;
    function GetHasTargetList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirGraphDefinitionLink; overload;
    function Clone : TFhirGraphDefinitionLink; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Path in the resource that contains the link.
    property path : String read GetPathST write SetPathST;
    // Path in the resource that contains the link.
    property pathElement : TFhirString read FPath write SetPath;

    // Typed access to Which slice (if profiled).
    property sliceName : String read GetSliceNameST write SetSliceNameST;
    // Which slice (if profiled).
    property sliceNameElement : TFhirString read FSliceName write SetSliceName;

    // Typed access to Minimum occurrences for this link.
    property min : String read GetMinST write SetMinST;
    // Minimum occurrences for this link.
    property minElement : TFhirInteger read FMin write SetMin;

    // Typed access to Maximum occurrences for this link.
    property max : String read GetMaxST write SetMaxST;
    // Maximum occurrences for this link.
    property maxElement : TFhirString read FMax write SetMax;

    // Typed access to Information about why this link is of interest in this graph definition.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Information about why this link is of interest in this graph definition.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Potential target for the link.
    property targetList : TFhirGraphDefinitionLinkTargetList read GetTargetList;
    property hasTargetList : boolean read GetHasTargetList;

  end;

  TFhirGraphDefinitionLinkListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirGraphDefinitionLinkList;
    function GetCurrent : TFhirGraphDefinitionLink;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirGraphDefinitionLinkList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirGraphDefinitionLink read GetCurrent;
  end;

  TFhirGraphDefinitionLinkList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirGraphDefinitionLink;
    procedure SetItemN(index : Integer; value : TFhirGraphDefinitionLink);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirGraphDefinitionLinkList; Overload;
    function Clone : TFhirGraphDefinitionLinkList; Overload;
    function GetEnumerator : TFhirGraphDefinitionLinkListEnumerator;

    //  Add a FhirGraphDefinitionLink to the end of the list.
    function Append : TFhirGraphDefinitionLink;

    // Add an already existing FhirGraphDefinitionLink to the end of the list.
    procedure AddItem(value : TFhirGraphDefinitionLink); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirGraphDefinitionLink) : Integer;

    // Insert FhirGraphDefinitionLink before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirGraphDefinitionLink;

    // Insert an existing FhirGraphDefinitionLink before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirGraphDefinitionLink);

    // Get the iIndexth FhirGraphDefinitionLink. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirGraphDefinitionLink);

    // The number of items in the collection
    function Item(index : Integer) : TFhirGraphDefinitionLink;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirGraphDefinitionLinks[index : Integer] : TFhirGraphDefinitionLink read GetItemN write SetItemN; default;
  End;

  // Potential target for the link.
  TFhirGraphDefinitionLinkTarget = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FProfile : TFhirUri;
    FcompartmentList : TFhirGraphDefinitionLinkTargetCompartmentList;
    Flink_List : TFhirGraphDefinitionLinkList;
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirResourceTypesEnum;
    Procedure SetType_ST(value : TFhirResourceTypesEnum);
    Procedure SetProfile(value : TFhirUri);
    Function GetProfileST : String;
    Procedure SetProfileST(value : String);
    function GetCompartmentList : TFhirGraphDefinitionLinkTargetCompartmentList;
    function GetHasCompartmentList : Boolean;
    function GetLink_List : TFhirGraphDefinitionLinkList;
    function GetHasLink_List : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirGraphDefinitionLinkTarget; overload;
    function Clone : TFhirGraphDefinitionLinkTarget; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Type of resource this link refers to.
    property type_ : TFhirResourceTypesEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to Profile for the target resource.
    property profile : String read GetProfileST write SetProfileST;
    // Profile for the target resource.
    property profileElement : TFhirUri read FProfile write SetProfile;

    // Compartment Consistency Rules.
    property compartmentList : TFhirGraphDefinitionLinkTargetCompartmentList read GetCompartmentList;
    property hasCompartmentList : boolean read GetHasCompartmentList;

    // Additional links from target resource.
    property link_List : TFhirGraphDefinitionLinkList read GetLink_List;
    property hasLink_List : boolean read GetHasLink_List;

  end;

  TFhirGraphDefinitionLinkTargetListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirGraphDefinitionLinkTargetList;
    function GetCurrent : TFhirGraphDefinitionLinkTarget;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirGraphDefinitionLinkTargetList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirGraphDefinitionLinkTarget read GetCurrent;
  end;

  TFhirGraphDefinitionLinkTargetList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirGraphDefinitionLinkTarget;
    procedure SetItemN(index : Integer; value : TFhirGraphDefinitionLinkTarget);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirGraphDefinitionLinkTargetList; Overload;
    function Clone : TFhirGraphDefinitionLinkTargetList; Overload;
    function GetEnumerator : TFhirGraphDefinitionLinkTargetListEnumerator;

    //  Add a FhirGraphDefinitionLinkTarget to the end of the list.
    function Append : TFhirGraphDefinitionLinkTarget;

    // Add an already existing FhirGraphDefinitionLinkTarget to the end of the list.
    procedure AddItem(value : TFhirGraphDefinitionLinkTarget); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirGraphDefinitionLinkTarget) : Integer;

    // Insert FhirGraphDefinitionLinkTarget before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirGraphDefinitionLinkTarget;

    // Insert an existing FhirGraphDefinitionLinkTarget before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirGraphDefinitionLinkTarget);

    // Get the iIndexth FhirGraphDefinitionLinkTarget. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirGraphDefinitionLinkTarget);

    // The number of items in the collection
    function Item(index : Integer) : TFhirGraphDefinitionLinkTarget;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirGraphDefinitionLinkTargets[index : Integer] : TFhirGraphDefinitionLinkTarget read GetItemN write SetItemN; default;
  End;

  // Compartment Consistency Rules.
  TFhirGraphDefinitionLinkTargetCompartment = class (TFhirBackboneElement)
  protected
    FCode : TFhirEnum;
    FRule : TFhirEnum;
    FExpression : TFhirString;
    FDescription : TFhirString;
    Procedure SetCode(value : TFhirEnum);
    Function GetCodeST : TFhirCompartmentTypeEnum;
    Procedure SetCodeST(value : TFhirCompartmentTypeEnum);
    Procedure SetRule(value : TFhirEnum);
    Function GetRuleST : TFhirGraphCompartmentRuleEnum;
    Procedure SetRuleST(value : TFhirGraphCompartmentRuleEnum);
    Procedure SetExpression(value : TFhirString);
    Function GetExpressionST : String;
    Procedure SetExpressionST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirGraphDefinitionLinkTargetCompartment; overload;
    function Clone : TFhirGraphDefinitionLinkTargetCompartment; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Identifies the compartment.
    property code : TFhirCompartmentTypeEnum read GetCodeST write SetCodeST;
    property codeElement : TFhirEnum read FCode write SetCode;

    // identical | matching | different | no-rule | custom.
    property rule : TFhirGraphCompartmentRuleEnum read GetRuleST write SetRuleST;
    property ruleElement : TFhirEnum read FRule write SetRule;

    // Typed access to Custom rule, as a FHIRPath expression.
    property expression : String read GetExpressionST write SetExpressionST;
    // Custom rule, as a FHIRPath expression.
    property expressionElement : TFhirString read FExpression write SetExpression;

    // Typed access to Documentation for FHIRPath expression.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Documentation for FHIRPath expression.
    property descriptionElement : TFhirString read FDescription write SetDescription;

  end;

  TFhirGraphDefinitionLinkTargetCompartmentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirGraphDefinitionLinkTargetCompartmentList;
    function GetCurrent : TFhirGraphDefinitionLinkTargetCompartment;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirGraphDefinitionLinkTargetCompartmentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirGraphDefinitionLinkTargetCompartment read GetCurrent;
  end;

  TFhirGraphDefinitionLinkTargetCompartmentList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirGraphDefinitionLinkTargetCompartment;
    procedure SetItemN(index : Integer; value : TFhirGraphDefinitionLinkTargetCompartment);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirGraphDefinitionLinkTargetCompartmentList; Overload;
    function Clone : TFhirGraphDefinitionLinkTargetCompartmentList; Overload;
    function GetEnumerator : TFhirGraphDefinitionLinkTargetCompartmentListEnumerator;

    //  Add a FhirGraphDefinitionLinkTargetCompartment to the end of the list.
    function Append : TFhirGraphDefinitionLinkTargetCompartment;

    // Add an already existing FhirGraphDefinitionLinkTargetCompartment to the end of the list.
    procedure AddItem(value : TFhirGraphDefinitionLinkTargetCompartment); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirGraphDefinitionLinkTargetCompartment) : Integer;

    // Insert FhirGraphDefinitionLinkTargetCompartment before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirGraphDefinitionLinkTargetCompartment;

    // Insert an existing FhirGraphDefinitionLinkTargetCompartment before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirGraphDefinitionLinkTargetCompartment);

    // Get the iIndexth FhirGraphDefinitionLinkTargetCompartment. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirGraphDefinitionLinkTargetCompartment);

    // The number of items in the collection
    function Item(index : Integer) : TFhirGraphDefinitionLinkTargetCompartment;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirGraphDefinitionLinkTargetCompartments[index : Integer] : TFhirGraphDefinitionLinkTargetCompartment read GetItemN write SetItemN; default;
  End;

  // A formal computable definition of a graph of resources - that is, a coherent set of resources that form a graph by following references. The Graph Definition resource defines a set and makes rules about the set.
  TFhirGraphDefinition = class (TFhirMetadataResource)
  protected
    FPurpose : TFhirMarkdown;
    FStart : TFhirEnum;
    FProfile : TFhirUri;
    Flink_List : TFhirGraphDefinitionLinkList;
    Procedure SetPurpose(value : TFhirMarkdown);
    Function GetPurposeST : String;
    Procedure SetPurposeST(value : String);
    Procedure SetStart(value : TFhirEnum);
    Function GetStartST : TFhirResourceTypesEnum;
    Procedure SetStartST(value : TFhirResourceTypesEnum);
    Procedure SetProfile(value : TFhirUri);
    Function GetProfileST : String;
    Procedure SetProfileST(value : String);
    function GetLink_List : TFhirGraphDefinitionLinkList;
    function GetHasLink_List : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirGraphDefinition; overload;
    function Clone : TFhirGraphDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this graph definition when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this graph definition is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the graph definition. For more information see [Technical and Business Versions](resource.html#versions).
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this graph definition when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this graph definition is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the graph definition. For more information see [Technical and Business Versions](resource.html#versions).
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to The identifier that is used to identify this version of the graph definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the graph definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the graph definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the graph definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the graph definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the graph definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // The status of this graph definition. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A boolean value to indicate that this graph definition is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A boolean value to indicate that this graph definition is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The date  (and optionally time) when the graph definition was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the graph definition changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the graph definition was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the graph definition changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the graph definition.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the graph definition.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the graph definition from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the graph definition from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These terms may be used to assist with indexing and searching for appropriate graph definition instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the graph definition is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to Explaination of why this graph definition is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explaination of why this graph definition is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // The type of FHIR resource at which instances of this graph start.
    property start : TFhirResourceTypesEnum read GetStartST write SetStartST;
    property startElement : TFhirEnum read FStart write SetStart;

    // Typed access to The profile that describes the use of the base resource.
    property profile : String read GetProfileST write SetProfileST;
    // The profile that describes the use of the base resource.
    property profileElement : TFhirUri read FProfile write SetProfile;

    // Links this graph makes rules about.
    property link_List : TFhirGraphDefinitionLinkList read GetLink_List;
    property hasLink_List : boolean read GetHasLink_List;

  end;

  TFhirGraphDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirGraphDefinitionList;
    function GetCurrent : TFhirGraphDefinition;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirGraphDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirGraphDefinition read GetCurrent;
  end;

  TFhirGraphDefinitionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirGraphDefinition;
    procedure SetItemN(index : Integer; value : TFhirGraphDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirGraphDefinitionList; Overload;
    function Clone : TFhirGraphDefinitionList; Overload;
    function GetEnumerator : TFhirGraphDefinitionListEnumerator;

    //  Add a FhirGraphDefinition to the end of the list.
    function Append : TFhirGraphDefinition;

    // Add an already existing FhirGraphDefinition to the end of the list.
    procedure AddItem(value : TFhirGraphDefinition); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirGraphDefinition) : Integer;

    // Insert FhirGraphDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirGraphDefinition;

    // Insert an existing FhirGraphDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirGraphDefinition);

    // Get the iIndexth FhirGraphDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirGraphDefinition);

    // The number of items in the collection
    function Item(index : Integer) : TFhirGraphDefinition;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirGraphDefinitions[index : Integer] : TFhirGraphDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_GRAPHDEFINITION}

{$IFDEF FHIR_IMPLEMENTATIONGUIDE}

  // Another implementation guide that this implementation depends on. Typically, an implementation guide uses value sets, profiles etc.defined in other implementation guides.
  TFhirImplementationGuideDependency = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FUri : TFhirUri;
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirGuideDependencyTypeEnum;
    Procedure SetType_ST(value : TFhirGuideDependencyTypeEnum);
    Procedure SetUri(value : TFhirUri);
    Function GetUriST : String;
    Procedure SetUriST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImplementationGuideDependency; overload;
    function Clone : TFhirImplementationGuideDependency; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // How the dependency is represented when the guide is {$IFNDEF FPC}Published{$ENDIF}.
    property type_ : TFhirGuideDependencyTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to Where the dependency is located.
    property uri : String read GetUriST write SetUriST;
    // Where the dependency is located.
    property uriElement : TFhirUri read FUri write SetUri;

  end;

  TFhirImplementationGuideDependencyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImplementationGuideDependencyList;
    function GetCurrent : TFhirImplementationGuideDependency;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImplementationGuideDependencyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImplementationGuideDependency read GetCurrent;
  end;

  TFhirImplementationGuideDependencyList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImplementationGuideDependency;
    procedure SetItemN(index : Integer; value : TFhirImplementationGuideDependency);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImplementationGuideDependencyList; Overload;
    function Clone : TFhirImplementationGuideDependencyList; Overload;
    function GetEnumerator : TFhirImplementationGuideDependencyListEnumerator;

    //  Add a FhirImplementationGuideDependency to the end of the list.
    function Append : TFhirImplementationGuideDependency;

    // Add an already existing FhirImplementationGuideDependency to the end of the list.
    procedure AddItem(value : TFhirImplementationGuideDependency); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImplementationGuideDependency) : Integer;

    // Insert FhirImplementationGuideDependency before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImplementationGuideDependency;

    // Insert an existing FhirImplementationGuideDependency before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImplementationGuideDependency);

    // Get the iIndexth FhirImplementationGuideDependency. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImplementationGuideDependency);

    // The number of items in the collection
    function Item(index : Integer) : TFhirImplementationGuideDependency;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirImplementationGuideDependencies[index : Integer] : TFhirImplementationGuideDependency read GetItemN write SetItemN; default;
  End;

  // A logical group of resources. Logical groups can be used when building pages.
  TFhirImplementationGuidePackage = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FDescription : TFhirString;
    FresourceList : TFhirImplementationGuidePackageResourceList;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    function GetResourceList : TFhirImplementationGuidePackageResourceList;
    function GetHasResourceList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImplementationGuidePackage; overload;
    function Clone : TFhirImplementationGuidePackage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The name for the group, as used in page.package.
    property name : String read GetNameST write SetNameST;
    // The name for the group, as used in page.package.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Human readable text describing the package.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Human readable text describing the package.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // A resource that is part of the implementation guide. Conformance resources (value set, structure definition, capability statements etc.) are obvious candidates for inclusion, but any kind of resource can be included as an example resource.
    property resourceList : TFhirImplementationGuidePackageResourceList read GetResourceList;
    property hasResourceList : boolean read GetHasResourceList;

  end;

  TFhirImplementationGuidePackageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImplementationGuidePackageList;
    function GetCurrent : TFhirImplementationGuidePackage;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImplementationGuidePackageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImplementationGuidePackage read GetCurrent;
  end;

  TFhirImplementationGuidePackageList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImplementationGuidePackage;
    procedure SetItemN(index : Integer; value : TFhirImplementationGuidePackage);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImplementationGuidePackageList; Overload;
    function Clone : TFhirImplementationGuidePackageList; Overload;
    function GetEnumerator : TFhirImplementationGuidePackageListEnumerator;

    //  Add a FhirImplementationGuidePackage to the end of the list.
    function Append : TFhirImplementationGuidePackage;

    // Add an already existing FhirImplementationGuidePackage to the end of the list.
    procedure AddItem(value : TFhirImplementationGuidePackage); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImplementationGuidePackage) : Integer;

    // Insert FhirImplementationGuidePackage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImplementationGuidePackage;

    // Insert an existing FhirImplementationGuidePackage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImplementationGuidePackage);

    // Get the iIndexth FhirImplementationGuidePackage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImplementationGuidePackage);

    // The number of items in the collection
    function Item(index : Integer) : TFhirImplementationGuidePackage;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirImplementationGuidePackages[index : Integer] : TFhirImplementationGuidePackage read GetItemN write SetItemN; default;
  End;

  // A resource that is part of the implementation guide. Conformance resources (value set, structure definition, capability statements etc.) are obvious candidates for inclusion, but any kind of resource can be included as an example resource.
  TFhirImplementationGuidePackageResource = class (TFhirBackboneElement)
  protected
    FExample : TFhirBoolean;
    FName : TFhirString;
    FDescription : TFhirString;
    FAcronym : TFhirString;
    FSource : TFhirType;
    FExampleFor : TFhirReference{TFhirStructureDefinition};
    Procedure SetExample(value : TFhirBoolean);
    Function GetExampleST : Boolean;
    Procedure SetExampleST(value : Boolean);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetAcronym(value : TFhirString);
    Function GetAcronymST : String;
    Procedure SetAcronymST(value : String);
    Procedure SetSource(value : TFhirType);
    Procedure SetExampleFor(value : TFhirReference{TFhirStructureDefinition});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImplementationGuidePackageResource; overload;
    function Clone : TFhirImplementationGuidePackageResource; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Whether a resource is included in the guide as part of the rules defined by the guide, or just as an example of a resource that conforms to the rules and/or help implementers understand the intent of the guide.
    property example : Boolean read GetExampleST write SetExampleST;
    // Whether a resource is included in the guide as part of the rules defined by the guide, or just as an example of a resource that conforms to the rules and/or help implementers understand the intent of the guide.
    property exampleElement : TFhirBoolean read FExample write SetExample;

    // Typed access to A human assigned name for the resource. All resources SHOULD have a name, but the name may be extracted from the resource (e.g. ValueSet.name).
    property name : String read GetNameST write SetNameST;
    // A human assigned name for the resource. All resources SHOULD have a name, but the name may be extracted from the resource (e.g. ValueSet.name).
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A description of the reason that a resource has been included in the implementation guide.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A description of the reason that a resource has been included in the implementation guide.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to A short code that may be used to identify the resource throughout the implementation guide.
    property acronym : String read GetAcronymST write SetAcronymST;
    // A short code that may be used to identify the resource throughout the implementation guide.
    property acronymElement : TFhirString read FAcronym write SetAcronym;

    // Typed access to Where this resource is found. (defined for API consistency)
    property source : TFhirType read FSource write SetSource;
    // Where this resource is found.
    property sourceElement : TFhirType read FSource write SetSource;

    // Typed access to Another resource that this resource is an example for. This is mostly used for resources that are included as examples of StructureDefinitions. (defined for API consistency)
    property exampleFor : TFhirReference{TFhirStructureDefinition} read FExampleFor write SetExampleFor;
    // Another resource that this resource is an example for. This is mostly used for resources that are included as examples of StructureDefinitions.
    property exampleForElement : TFhirReference{TFhirStructureDefinition} read FExampleFor write SetExampleFor;

  end;

  TFhirImplementationGuidePackageResourceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImplementationGuidePackageResourceList;
    function GetCurrent : TFhirImplementationGuidePackageResource;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImplementationGuidePackageResourceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImplementationGuidePackageResource read GetCurrent;
  end;

  TFhirImplementationGuidePackageResourceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImplementationGuidePackageResource;
    procedure SetItemN(index : Integer; value : TFhirImplementationGuidePackageResource);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImplementationGuidePackageResourceList; Overload;
    function Clone : TFhirImplementationGuidePackageResourceList; Overload;
    function GetEnumerator : TFhirImplementationGuidePackageResourceListEnumerator;

    //  Add a FhirImplementationGuidePackageResource to the end of the list.
    function Append : TFhirImplementationGuidePackageResource;

    // Add an already existing FhirImplementationGuidePackageResource to the end of the list.
    procedure AddItem(value : TFhirImplementationGuidePackageResource); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImplementationGuidePackageResource) : Integer;

    // Insert FhirImplementationGuidePackageResource before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImplementationGuidePackageResource;

    // Insert an existing FhirImplementationGuidePackageResource before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImplementationGuidePackageResource);

    // Get the iIndexth FhirImplementationGuidePackageResource. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImplementationGuidePackageResource);

    // The number of items in the collection
    function Item(index : Integer) : TFhirImplementationGuidePackageResource;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirImplementationGuidePackageResources[index : Integer] : TFhirImplementationGuidePackageResource read GetItemN write SetItemN; default;
  End;

  // A set of profiles that all resources covered by this implementation guide must conform to.
  TFhirImplementationGuideGlobal = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FProfile : TFhirReference{TFhirStructureDefinition};
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirResourceTypesEnum;
    Procedure SetType_ST(value : TFhirResourceTypesEnum);
    Procedure SetProfile(value : TFhirReference{TFhirStructureDefinition});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImplementationGuideGlobal; overload;
    function Clone : TFhirImplementationGuideGlobal; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The type of resource that all instances must conform to.
    property type_ : TFhirResourceTypesEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to A reference to the profile that all instances must conform to. (defined for API consistency)
    property profile : TFhirReference{TFhirStructureDefinition} read FProfile write SetProfile;
    // A reference to the profile that all instances must conform to.
    property profileElement : TFhirReference{TFhirStructureDefinition} read FProfile write SetProfile;

  end;

  TFhirImplementationGuideGlobalListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImplementationGuideGlobalList;
    function GetCurrent : TFhirImplementationGuideGlobal;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImplementationGuideGlobalList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImplementationGuideGlobal read GetCurrent;
  end;

  TFhirImplementationGuideGlobalList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImplementationGuideGlobal;
    procedure SetItemN(index : Integer; value : TFhirImplementationGuideGlobal);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImplementationGuideGlobalList; Overload;
    function Clone : TFhirImplementationGuideGlobalList; Overload;
    function GetEnumerator : TFhirImplementationGuideGlobalListEnumerator;

    //  Add a FhirImplementationGuideGlobal to the end of the list.
    function Append : TFhirImplementationGuideGlobal;

    // Add an already existing FhirImplementationGuideGlobal to the end of the list.
    procedure AddItem(value : TFhirImplementationGuideGlobal); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImplementationGuideGlobal) : Integer;

    // Insert FhirImplementationGuideGlobal before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImplementationGuideGlobal;

    // Insert an existing FhirImplementationGuideGlobal before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImplementationGuideGlobal);

    // Get the iIndexth FhirImplementationGuideGlobal. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImplementationGuideGlobal);

    // The number of items in the collection
    function Item(index : Integer) : TFhirImplementationGuideGlobal;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirImplementationGuideGlobals[index : Integer] : TFhirImplementationGuideGlobal read GetItemN write SetItemN; default;
  End;

  // A page / section in the implementation guide. The root page is the implementation guide home page.
  TFhirImplementationGuidePage = class (TFhirBackboneElement)
  protected
    FSource : TFhirUri;
    FTitle : TFhirString;
    FKind : TFhirEnum;
    FType_ : TFhirEnumList;
    FpackageList : TFhirStringList;
    FFormat : TFhirCode;
    FpageList : TFhirImplementationGuidePageList;
    Procedure SetSource(value : TFhirUri);
    Function GetSourceST : String;
    Procedure SetSourceST(value : String);
    Procedure SetTitle(value : TFhirString);
    Function GetTitleST : String;
    Procedure SetTitleST(value : String);
    Procedure SetKind(value : TFhirEnum);
    Function GetKindST : TFhirGuidePageKindEnum;
    Procedure SetKindST(value : TFhirGuidePageKindEnum);
    function GetType_ : TFhirEnumList;
    function GetHasType_ : Boolean;
    function GetPackageList : TFhirStringList;
    function GetHasPackageList : Boolean;
    Procedure SetFormat(value : TFhirCode);
    Function GetFormatST : String;
    Procedure SetFormatST(value : String);
    function GetPageList : TFhirImplementationGuidePageList;
    function GetHasPageList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImplementationGuidePage; overload;
    function Clone : TFhirImplementationGuidePage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The source address for the page.
    property source : String read GetSourceST write SetSourceST;
    // The source address for the page.
    property sourceElement : TFhirUri read FSource write SetSource;

    // Typed access to A short title used to represent this page in navigational structures such as table of contents, bread crumbs, etc.
    property title : String read GetTitleST write SetTitleST;
    // A short title used to represent this page in navigational structures such as table of contents, bread crumbs, etc.
    property titleElement : TFhirString read FTitle write SetTitle;

    // The kind of page that this is. Some pages are autogenerated (list, example), and other kinds are of interest so that tools can navigate the user to the page of interest.
    property kind : TFhirGuidePageKindEnum read GetKindST write SetKindST;
    property kindElement : TFhirEnum read FKind write SetKind;

    property type_ : TFhirEnumList read GetType_;
    property type_List : TFhirEnumList read GetType_;
    property hasType_ : boolean read GetHasType_;
    // For constructed pages, a list of packages to include in the page (or else empty for everything).
    property packageList : TFhirStringList read GetPackageList;
    property hasPackageList : boolean read GetHasPackageList;

    // Typed access to The format of the page.
    property format : String read GetFormatST write SetFormatST;
    // The format of the page.
    property formatElement : TFhirCode read FFormat write SetFormat;

    // Nested Pages/Sections under this page.
    property pageList : TFhirImplementationGuidePageList read GetPageList;
    property hasPageList : boolean read GetHasPageList;

  end;

  TFhirImplementationGuidePageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImplementationGuidePageList;
    function GetCurrent : TFhirImplementationGuidePage;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImplementationGuidePageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImplementationGuidePage read GetCurrent;
  end;

  TFhirImplementationGuidePageList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImplementationGuidePage;
    procedure SetItemN(index : Integer; value : TFhirImplementationGuidePage);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImplementationGuidePageList; Overload;
    function Clone : TFhirImplementationGuidePageList; Overload;
    function GetEnumerator : TFhirImplementationGuidePageListEnumerator;

    //  Add a FhirImplementationGuidePage to the end of the list.
    function Append : TFhirImplementationGuidePage;

    // Add an already existing FhirImplementationGuidePage to the end of the list.
    procedure AddItem(value : TFhirImplementationGuidePage); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImplementationGuidePage) : Integer;

    // Insert FhirImplementationGuidePage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImplementationGuidePage;

    // Insert an existing FhirImplementationGuidePage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImplementationGuidePage);

    // Get the iIndexth FhirImplementationGuidePage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImplementationGuidePage);

    // The number of items in the collection
    function Item(index : Integer) : TFhirImplementationGuidePage;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirImplementationGuidePages[index : Integer] : TFhirImplementationGuidePage read GetItemN write SetItemN; default;
  End;

  // A set of rules of how FHIR is used to solve a particular problem. This resource is used to gather all the parts of an implementation guide into a logical whole and to publish a computable definition of all the parts.
  TFhirImplementationGuide = class (TFhirMetadataResource)
  protected
    FCopyright : TFhirMarkdown;
    FFhirVersion : TFhirId;
    FdependencyList : TFhirImplementationGuideDependencyList;
    FpackageList : TFhirImplementationGuidePackageList;
    FglobalList : TFhirImplementationGuideGlobalList;
    FbinaryList : TFhirUriList;
    FPage : TFhirImplementationGuidePage;
    Procedure SetCopyright(value : TFhirMarkdown);
    Function GetCopyrightST : String;
    Procedure SetCopyrightST(value : String);
    Procedure SetFhirVersion(value : TFhirId);
    Function GetFhirVersionST : String;
    Procedure SetFhirVersionST(value : String);
    function GetDependencyList : TFhirImplementationGuideDependencyList;
    function GetHasDependencyList : Boolean;
    function GetPackageList : TFhirImplementationGuidePackageList;
    function GetHasPackageList : Boolean;
    function GetGlobalList : TFhirImplementationGuideGlobalList;
    function GetHasGlobalList : Boolean;
    function GetBinaryList : TFhirUriList;
    function GetHasBinaryList : Boolean;
    Procedure SetPage(value : TFhirImplementationGuidePage);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImplementationGuide; overload;
    function Clone : TFhirImplementationGuide; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this implementation guide when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this implementation guide is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the implementation guide. For more information see [Technical and Business Versions](resource.html#versions).
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this implementation guide when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this implementation guide is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the implementation guide. For more information see [Technical and Business Versions](resource.html#versions).
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to The identifier that is used to identify this version of the implementation guide when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the implementation guide author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the implementation guide when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the implementation guide author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the implementation guide. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the implementation guide. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // The status of this implementation guide. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A boolean value to indicate that this implementation guide is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A boolean value to indicate that this implementation guide is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The date  (and optionally time) when the implementation guide was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the implementation guide changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the implementation guide was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the implementation guide changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the implementation guide.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the implementation guide.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the implementation guide from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the implementation guide from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These terms may be used to assist with indexing and searching for appropriate implementation guide instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the implementation guide is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to A copyright statement relating to the implementation guide and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the implementation guide.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the implementation guide and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the implementation guide.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // Typed access to The version of the FHIR specification on which this ImplementationGuide is based - this is the formal version of the specification, without the revision number, e.g. [publication].[major].[minor], which is 3.0.1 for this version.
    property fhirVersion : String read GetFhirVersionST write SetFhirVersionST;
    // The version of the FHIR specification on which this ImplementationGuide is based - this is the formal version of the specification, without the revision number, e.g. [publication].[major].[minor], which is 3.0.1 for this version.
    property fhirVersionElement : TFhirId read FFhirVersion write SetFhirVersion;

    // Another implementation guide that this implementation depends on. Typically, an implementation guide uses value sets, profiles etc.defined in other implementation guides.
    property dependencyList : TFhirImplementationGuideDependencyList read GetDependencyList;
    property hasDependencyList : boolean read GetHasDependencyList;

    // A logical group of resources. Logical groups can be used when building pages.
    property packageList : TFhirImplementationGuidePackageList read GetPackageList;
    property hasPackageList : boolean read GetHasPackageList;

    // A set of profiles that all resources covered by this implementation guide must conform to.
    property globalList : TFhirImplementationGuideGlobalList read GetGlobalList;
    property hasGlobalList : boolean read GetHasGlobalList;

    // A binary file that is included in the  implementation guide when it is {$IFNDEF FPC}Published{$ENDIF}.
    property binaryList : TFhirUriList read GetBinaryList;
    property hasBinaryList : boolean read GetHasBinaryList;

    // Typed access to A page / section in the implementation guide. The root page is the implementation guide home page. (defined for API consistency)
    property page : TFhirImplementationGuidePage read FPage write SetPage;
    // A page / section in the implementation guide. The root page is the implementation guide home page.
    property pageElement : TFhirImplementationGuidePage read FPage write SetPage;

  end;

  TFhirImplementationGuideListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImplementationGuideList;
    function GetCurrent : TFhirImplementationGuide;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirImplementationGuideList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImplementationGuide read GetCurrent;
  end;

  TFhirImplementationGuideList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirImplementationGuide;
    procedure SetItemN(index : Integer; value : TFhirImplementationGuide);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirImplementationGuideList; Overload;
    function Clone : TFhirImplementationGuideList; Overload;
    function GetEnumerator : TFhirImplementationGuideListEnumerator;

    //  Add a FhirImplementationGuide to the end of the list.
    function Append : TFhirImplementationGuide;

    // Add an already existing FhirImplementationGuide to the end of the list.
    procedure AddItem(value : TFhirImplementationGuide); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImplementationGuide) : Integer;

    // Insert FhirImplementationGuide before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImplementationGuide;

    // Insert an existing FhirImplementationGuide before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImplementationGuide);

    // Get the iIndexth FhirImplementationGuide. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImplementationGuide);

    // The number of items in the collection
    function Item(index : Integer) : TFhirImplementationGuide;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirImplementationGuides[index : Integer] : TFhirImplementationGuide read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_IMPLEMENTATIONGUIDE}

{$IFDEF FHIR_LIBRARY}

  // The Library resource is a general-purpose container for knowledge asset definitions. It can be used to describe and expose existing knowledge assets such as logic libraries and information model descriptions, as well as to describe a collection of knowledge assets.
  TFhirLibrary = class (TFhirMetadataResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FType_ : TFhirCodeableConcept;
    FPurpose : TFhirMarkdown;
    FUsage : TFhirString;
    FApprovalDate : TFhirDate;
    FLastReviewDate : TFhirDate;
    FEffectivePeriod : TFhirPeriod;
    FtopicList : TFhirCodeableConceptList;
    FcontributorList : TFhirContributorList;
    FCopyright : TFhirMarkdown;
    FrelatedArtifactList : TFhirRelatedArtifactList;
    FparameterList : TFhirParameterDefinitionList;
    FdataRequirementList : TFhirDataRequirementList;
    FcontentList : TFhirAttachmentList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetPurpose(value : TFhirMarkdown);
    Function GetPurposeST : String;
    Procedure SetPurposeST(value : String);
    Procedure SetUsage(value : TFhirString);
    Function GetUsageST : String;
    Procedure SetUsageST(value : String);
    Procedure SetApprovalDate(value : TFhirDate);
    Function GetApprovalDateST : TFslDateTime;
    Procedure SetApprovalDateST(value : TFslDateTime);
    Procedure SetLastReviewDate(value : TFhirDate);
    Function GetLastReviewDateST : TFslDateTime;
    Procedure SetLastReviewDateST(value : TFslDateTime);
    Procedure SetEffectivePeriod(value : TFhirPeriod);
    function GetTopicList : TFhirCodeableConceptList;
    function GetHasTopicList : Boolean;
    function GetContributorList : TFhirContributorList;
    function GetHasContributorList : Boolean;
    Procedure SetCopyright(value : TFhirMarkdown);
    Function GetCopyrightST : String;
    Procedure SetCopyrightST(value : String);
    function GetRelatedArtifactList : TFhirRelatedArtifactList;
    function GetHasRelatedArtifactList : Boolean;
    function GetParameterList : TFhirParameterDefinitionList;
    function GetHasParameterList : Boolean;
    function GetDataRequirementList : TFhirDataRequirementList;
    function GetHasDataRequirementList : Boolean;
    function GetContentList : TFhirAttachmentList;
    function GetHasContentList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirLibrary; overload;
    function Clone : TFhirLibrary; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this library when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this library is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the library. For more information see [Technical and Business Versions](resource.html#versions).
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this library when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this library is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the library. For more information see [Technical and Business Versions](resource.html#versions).
    property urlElement : TFhirUri read FUrl write SetUrl;

    // A formal identifier that is used to identify this library when it is represented in other formats, or referenced in a specification, model, design or an instance. e.g. CMS or NQF identifiers for a measure artifact. Note that at least one identifier is required for non-experimental active artifacts.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the library when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the library author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. To provide a version consistent with the Decision Support Service specification, use the format Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge assets, refer to the Decision Support Service specification. Note that a version is required for non-experimental active artifacts.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the library when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the library author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. To provide a version consistent with the Decision Support Service specification, use the format Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge assets, refer to the Decision Support Service specification. Note that a version is required for non-experimental active artifacts.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the library. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the library. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the library.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the library.
    property titleElement : TFhirString read FTitle write SetTitle;

    // The status of this library. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A boolean value to indicate that this library is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A boolean value to indicate that this library is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to Identifies the type of library such as a Logic Library, Model Definition, Asset Collection, or Module Definition. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Identifies the type of library such as a Logic Library, Model Definition, Asset Collection, or Module Definition.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The date  (and optionally time) when the library was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the library changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the library was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the library changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the library.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the library.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Typed access to A free text natural language description of the library from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the library from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // Typed access to Explaination of why this library is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explaination of why this library is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Typed access to A detailed description of how the library is used from a clinical perspective.
    property usage : String read GetUsageST write SetUsageST;
    // A detailed description of how the library is used from a clinical perspective.
    property usageElement : TFhirString read FUsage write SetUsage;

    // Typed access to The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDate : TFslDateTime read GetApprovalDateST write SetApprovalDateST;
    // The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDateElement : TFhirDate read FApprovalDate write SetApprovalDate;

    // Typed access to The date on which the resource content was last reviewed. Review happens periodically after approval, but doesn't change the original approval date.
    property lastReviewDate : TFslDateTime read GetLastReviewDateST write SetLastReviewDateST;
    // The date on which the resource content was last reviewed. Review happens periodically after approval, but doesn't change the original approval date.
    property lastReviewDateElement : TFhirDate read FLastReviewDate write SetLastReviewDate;

    // Typed access to The period during which the library content was or is planned to be in active use. (defined for API consistency)
    property effectivePeriod : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;
    // The period during which the library content was or is planned to be in active use.
    property effectivePeriodElement : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These terms may be used to assist with indexing and searching for appropriate library instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the library is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Descriptive topics related to the content of the library. Topics provide a high-level categorization of the library that can be useful for filtering and searching.
    property topicList : TFhirCodeableConceptList read GetTopicList;
    property hasTopicList : boolean read GetHasTopicList;

    // A contributor to the content of the library, including authors, editors, reviewers, and endorsers.
    property contributorList : TFhirContributorList read GetContributorList;
    property hasContributorList : boolean read GetHasContributorList;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A copyright statement relating to the library and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the library.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the library and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the library.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // Related artifacts such as additional documentation, justification, or bibliographic references.
    property relatedArtifactList : TFhirRelatedArtifactList read GetRelatedArtifactList;
    property hasRelatedArtifactList : boolean read GetHasRelatedArtifactList;

    // The parameter element defines parameters used by the library.
    property parameterList : TFhirParameterDefinitionList read GetParameterList;
    property hasParameterList : boolean read GetHasParameterList;

    // Describes a set of data that must be provided in order to be able to successfully perform the computations defined by the library.
    property dataRequirementList : TFhirDataRequirementList read GetDataRequirementList;
    property hasDataRequirementList : boolean read GetHasDataRequirementList;

    // The content of the library as an Attachment. The content may be a reference to a url, or may be directly embedded as a base-64 string. Either way, the contentType of the attachment determines how to interpret the content.
    property contentList : TFhirAttachmentList read GetContentList;
    property hasContentList : boolean read GetHasContentList;

  end;

  TFhirLibraryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirLibraryList;
    function GetCurrent : TFhirLibrary;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirLibraryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirLibrary read GetCurrent;
  end;

  TFhirLibraryList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirLibrary;
    procedure SetItemN(index : Integer; value : TFhirLibrary);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirLibraryList; Overload;
    function Clone : TFhirLibraryList; Overload;
    function GetEnumerator : TFhirLibraryListEnumerator;

    //  Add a FhirLibrary to the end of the list.
    function Append : TFhirLibrary;

    // Add an already existing FhirLibrary to the end of the list.
    procedure AddItem(value : TFhirLibrary); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirLibrary) : Integer;

    // Insert FhirLibrary before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirLibrary;

    // Insert an existing FhirLibrary before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirLibrary);

    // Get the iIndexth FhirLibrary. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirLibrary);

    // The number of items in the collection
    function Item(index : Integer) : TFhirLibrary;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirLibraries[index : Integer] : TFhirLibrary read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_LIBRARY}

{$IFDEF FHIR_MEASURE}

  // A group of population criteria for the measure.
  TFhirMeasureGroup = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirIdentifier;
    FName : TFhirString;
    FDescription : TFhirString;
    FpopulationList : TFhirMeasureGroupPopulationList;
    FstratifierList : TFhirMeasureGroupStratifierList;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    function GetPopulationList : TFhirMeasureGroupPopulationList;
    function GetHasPopulationList : Boolean;
    function GetStratifierList : TFhirMeasureGroupStratifierList;
    function GetHasStratifierList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMeasureGroup; overload;
    function Clone : TFhirMeasureGroup; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A unique identifier for the group. This identifier will used to report data for the group in the measure report. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // A unique identifier for the group. This identifier will used to report data for the group in the measure report.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to Optional name or short description of this group.
    property name : String read GetNameST write SetNameST;
    // Optional name or short description of this group.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to The human readable description of this population group.
    property description : String read GetDescriptionST write SetDescriptionST;
    // The human readable description of this population group.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // A population criteria for the measure.
    property populationList : TFhirMeasureGroupPopulationList read GetPopulationList;
    property hasPopulationList : boolean read GetHasPopulationList;

    // The stratifier criteria for the measure report, specified as either the name of a valid CQL expression defined within a referenced library, or a valid FHIR Resource Path.
    property stratifierList : TFhirMeasureGroupStratifierList read GetStratifierList;
    property hasStratifierList : boolean read GetHasStratifierList;

  end;

  TFhirMeasureGroupListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMeasureGroupList;
    function GetCurrent : TFhirMeasureGroup;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMeasureGroupList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMeasureGroup read GetCurrent;
  end;

  TFhirMeasureGroupList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMeasureGroup;
    procedure SetItemN(index : Integer; value : TFhirMeasureGroup);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMeasureGroupList; Overload;
    function Clone : TFhirMeasureGroupList; Overload;
    function GetEnumerator : TFhirMeasureGroupListEnumerator;

    //  Add a FhirMeasureGroup to the end of the list.
    function Append : TFhirMeasureGroup;

    // Add an already existing FhirMeasureGroup to the end of the list.
    procedure AddItem(value : TFhirMeasureGroup); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMeasureGroup) : Integer;

    // Insert FhirMeasureGroup before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMeasureGroup;

    // Insert an existing FhirMeasureGroup before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMeasureGroup);

    // Get the iIndexth FhirMeasureGroup. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMeasureGroup);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMeasureGroup;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMeasureGroups[index : Integer] : TFhirMeasureGroup read GetItemN write SetItemN; default;
  End;

  // A population criteria for the measure.
  TFhirMeasureGroupPopulation = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirIdentifier;
    FCode : TFhirCodeableConcept;
    FName : TFhirString;
    FDescription : TFhirString;
    FCriteria : TFhirString;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetCode(value : TFhirCodeableConcept);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetCriteria(value : TFhirString);
    Function GetCriteriaST : String;
    Procedure SetCriteriaST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMeasureGroupPopulation; overload;
    function Clone : TFhirMeasureGroupPopulation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A unique identifier for the population criteria. This identifier is used to report data against this criteria within the measure report. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // A unique identifier for the population criteria. This identifier is used to report data against this criteria within the measure report.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to The type of population criteria. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The type of population criteria.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to Optional name or short description of this population.
    property name : String read GetNameST write SetNameST;
    // Optional name or short description of this population.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to The human readable description of this population criteria.
    property description : String read GetDescriptionST write SetDescriptionST;
    // The human readable description of this population criteria.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to The name of a valid referenced CQL expression (may be namespaced) that defines this population criteria.
    property criteria : String read GetCriteriaST write SetCriteriaST;
    // The name of a valid referenced CQL expression (may be namespaced) that defines this population criteria.
    property criteriaElement : TFhirString read FCriteria write SetCriteria;

  end;

  TFhirMeasureGroupPopulationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMeasureGroupPopulationList;
    function GetCurrent : TFhirMeasureGroupPopulation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMeasureGroupPopulationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMeasureGroupPopulation read GetCurrent;
  end;

  TFhirMeasureGroupPopulationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMeasureGroupPopulation;
    procedure SetItemN(index : Integer; value : TFhirMeasureGroupPopulation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMeasureGroupPopulationList; Overload;
    function Clone : TFhirMeasureGroupPopulationList; Overload;
    function GetEnumerator : TFhirMeasureGroupPopulationListEnumerator;

    //  Add a FhirMeasureGroupPopulation to the end of the list.
    function Append : TFhirMeasureGroupPopulation;

    // Add an already existing FhirMeasureGroupPopulation to the end of the list.
    procedure AddItem(value : TFhirMeasureGroupPopulation); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMeasureGroupPopulation) : Integer;

    // Insert FhirMeasureGroupPopulation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMeasureGroupPopulation;

    // Insert an existing FhirMeasureGroupPopulation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMeasureGroupPopulation);

    // Get the iIndexth FhirMeasureGroupPopulation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMeasureGroupPopulation);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMeasureGroupPopulation;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMeasureGroupPopulations[index : Integer] : TFhirMeasureGroupPopulation read GetItemN write SetItemN; default;
  End;

  // The stratifier criteria for the measure report, specified as either the name of a valid CQL expression defined within a referenced library, or a valid FHIR Resource Path.
  TFhirMeasureGroupStratifier = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirIdentifier;
    FCriteria : TFhirString;
    FPath : TFhirString;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetCriteria(value : TFhirString);
    Function GetCriteriaST : String;
    Procedure SetCriteriaST(value : String);
    Procedure SetPath(value : TFhirString);
    Function GetPathST : String;
    Procedure SetPathST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMeasureGroupStratifier; overload;
    function Clone : TFhirMeasureGroupStratifier; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The identifier for the stratifier used to coordinate the reported data back to this stratifier. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // The identifier for the stratifier used to coordinate the reported data back to this stratifier.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to The criteria for the stratifier. This must be the name of an expression defined within a referenced library.
    property criteria : String read GetCriteriaST write SetCriteriaST;
    // The criteria for the stratifier. This must be the name of an expression defined within a referenced library.
    property criteriaElement : TFhirString read FCriteria write SetCriteria;

    // Typed access to The path to an element that defines the stratifier, specified as a valid FHIR resource path.
    property path : String read GetPathST write SetPathST;
    // The path to an element that defines the stratifier, specified as a valid FHIR resource path.
    property pathElement : TFhirString read FPath write SetPath;

  end;

  TFhirMeasureGroupStratifierListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMeasureGroupStratifierList;
    function GetCurrent : TFhirMeasureGroupStratifier;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMeasureGroupStratifierList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMeasureGroupStratifier read GetCurrent;
  end;

  TFhirMeasureGroupStratifierList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMeasureGroupStratifier;
    procedure SetItemN(index : Integer; value : TFhirMeasureGroupStratifier);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMeasureGroupStratifierList; Overload;
    function Clone : TFhirMeasureGroupStratifierList; Overload;
    function GetEnumerator : TFhirMeasureGroupStratifierListEnumerator;

    //  Add a FhirMeasureGroupStratifier to the end of the list.
    function Append : TFhirMeasureGroupStratifier;

    // Add an already existing FhirMeasureGroupStratifier to the end of the list.
    procedure AddItem(value : TFhirMeasureGroupStratifier); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMeasureGroupStratifier) : Integer;

    // Insert FhirMeasureGroupStratifier before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMeasureGroupStratifier;

    // Insert an existing FhirMeasureGroupStratifier before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMeasureGroupStratifier);

    // Get the iIndexth FhirMeasureGroupStratifier. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMeasureGroupStratifier);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMeasureGroupStratifier;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMeasureGroupStratifiers[index : Integer] : TFhirMeasureGroupStratifier read GetItemN write SetItemN; default;
  End;

  // The supplemental data criteria for the measure report, specified as either the name of a valid CQL expression within a referenced library, or a valid FHIR Resource Path.
  TFhirMeasureSupplementalData = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirIdentifier;
    FusageList : TFhirCodeableConceptList;
    FCriteria : TFhirString;
    FPath : TFhirString;
    Procedure SetIdentifier(value : TFhirIdentifier);
    function GetUsageList : TFhirCodeableConceptList;
    function GetHasUsageList : Boolean;
    Procedure SetCriteria(value : TFhirString);
    Function GetCriteriaST : String;
    Procedure SetCriteriaST(value : String);
    Procedure SetPath(value : TFhirString);
    Function GetPathST : String;
    Procedure SetPathST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMeasureSupplementalData; overload;
    function Clone : TFhirMeasureSupplementalData; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An identifier for the supplemental data. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // An identifier for the supplemental data.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // An indicator of the intended usage for the supplemental data element. Supplemental data indicates the data is additional information requested to augment the measure information. Risk adjustment factor indicates the data is additional information used to calculate risk adjustment factors when applying a risk model to the measure calculation.
    property usageList : TFhirCodeableConceptList read GetUsageList;
    property hasUsageList : boolean read GetHasUsageList;

    // Typed access to The criteria for the supplemental data. This must be the name of a valid expression defined within a referenced library, and defines the data to be returned for this element.
    property criteria : String read GetCriteriaST write SetCriteriaST;
    // The criteria for the supplemental data. This must be the name of a valid expression defined within a referenced library, and defines the data to be returned for this element.
    property criteriaElement : TFhirString read FCriteria write SetCriteria;

    // Typed access to The supplemental data to be supplied as part of the measure response, specified as a valid FHIR Resource Path.
    property path : String read GetPathST write SetPathST;
    // The supplemental data to be supplied as part of the measure response, specified as a valid FHIR Resource Path.
    property pathElement : TFhirString read FPath write SetPath;

  end;

  TFhirMeasureSupplementalDataListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMeasureSupplementalDataList;
    function GetCurrent : TFhirMeasureSupplementalData;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMeasureSupplementalDataList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMeasureSupplementalData read GetCurrent;
  end;

  TFhirMeasureSupplementalDataList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMeasureSupplementalData;
    procedure SetItemN(index : Integer; value : TFhirMeasureSupplementalData);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMeasureSupplementalDataList; Overload;
    function Clone : TFhirMeasureSupplementalDataList; Overload;
    function GetEnumerator : TFhirMeasureSupplementalDataListEnumerator;

    //  Add a FhirMeasureSupplementalData to the end of the list.
    function Append : TFhirMeasureSupplementalData;

    // Add an already existing FhirMeasureSupplementalData to the end of the list.
    procedure AddItem(value : TFhirMeasureSupplementalData); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMeasureSupplementalData) : Integer;

    // Insert FhirMeasureSupplementalData before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMeasureSupplementalData;

    // Insert an existing FhirMeasureSupplementalData before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMeasureSupplementalData);

    // Get the iIndexth FhirMeasureSupplementalData. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMeasureSupplementalData);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMeasureSupplementalData;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMeasureSupplementalData[index : Integer] : TFhirMeasureSupplementalData read GetItemN write SetItemN; default;
  End;

  // The Measure resource provides the definition of a quality measure.
  TFhirMeasure = class (TFhirMetadataResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FPurpose : TFhirMarkdown;
    FUsage : TFhirString;
    FApprovalDate : TFhirDate;
    FLastReviewDate : TFhirDate;
    FEffectivePeriod : TFhirPeriod;
    FtopicList : TFhirCodeableConceptList;
    FcontributorList : TFhirContributorList;
    FCopyright : TFhirMarkdown;
    FrelatedArtifactList : TFhirRelatedArtifactList;
    Flibrary_List : TFhirReferenceList{TFhirLibrary};
    FDisclaimer : TFhirMarkdown;
    FScoring : TFhirCodeableConcept;
    FCompositeScoring : TFhirCodeableConcept;
    Ftype_List : TFhirCodeableConceptList;
    FRiskAdjustment : TFhirString;
    FRateAggregation : TFhirString;
    FRationale : TFhirMarkdown;
    FClinicalRecommendationStatement : TFhirMarkdown;
    FImprovementNotation : TFhirString;
    FdefinitionList : TFhirMarkdownList;
    FGuidance : TFhirMarkdown;
    FSet_ : TFhirString;
    FgroupList : TFhirMeasureGroupList;
    FsupplementalDataList : TFhirMeasureSupplementalDataList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetPurpose(value : TFhirMarkdown);
    Function GetPurposeST : String;
    Procedure SetPurposeST(value : String);
    Procedure SetUsage(value : TFhirString);
    Function GetUsageST : String;
    Procedure SetUsageST(value : String);
    Procedure SetApprovalDate(value : TFhirDate);
    Function GetApprovalDateST : TFslDateTime;
    Procedure SetApprovalDateST(value : TFslDateTime);
    Procedure SetLastReviewDate(value : TFhirDate);
    Function GetLastReviewDateST : TFslDateTime;
    Procedure SetLastReviewDateST(value : TFslDateTime);
    Procedure SetEffectivePeriod(value : TFhirPeriod);
    function GetTopicList : TFhirCodeableConceptList;
    function GetHasTopicList : Boolean;
    function GetContributorList : TFhirContributorList;
    function GetHasContributorList : Boolean;
    Procedure SetCopyright(value : TFhirMarkdown);
    Function GetCopyrightST : String;
    Procedure SetCopyrightST(value : String);
    function GetRelatedArtifactList : TFhirRelatedArtifactList;
    function GetHasRelatedArtifactList : Boolean;
    function GetLibrary_List : TFhirReferenceList{TFhirLibrary};
    function GetHasLibrary_List : Boolean;
    Procedure SetDisclaimer(value : TFhirMarkdown);
    Function GetDisclaimerST : String;
    Procedure SetDisclaimerST(value : String);
    Procedure SetScoring(value : TFhirCodeableConcept);
    Procedure SetCompositeScoring(value : TFhirCodeableConcept);
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    Procedure SetRiskAdjustment(value : TFhirString);
    Function GetRiskAdjustmentST : String;
    Procedure SetRiskAdjustmentST(value : String);
    Procedure SetRateAggregation(value : TFhirString);
    Function GetRateAggregationST : String;
    Procedure SetRateAggregationST(value : String);
    Procedure SetRationale(value : TFhirMarkdown);
    Function GetRationaleST : String;
    Procedure SetRationaleST(value : String);
    Procedure SetClinicalRecommendationStatement(value : TFhirMarkdown);
    Function GetClinicalRecommendationStatementST : String;
    Procedure SetClinicalRecommendationStatementST(value : String);
    Procedure SetImprovementNotation(value : TFhirString);
    Function GetImprovementNotationST : String;
    Procedure SetImprovementNotationST(value : String);
    function GetDefinitionList : TFhirMarkdownList;
    function GetHasDefinitionList : Boolean;
    Procedure SetGuidance(value : TFhirMarkdown);
    Function GetGuidanceST : String;
    Procedure SetGuidanceST(value : String);
    Procedure SetSet_(value : TFhirString);
    Function GetSet_ST : String;
    Procedure SetSet_ST(value : String);
    function GetGroupList : TFhirMeasureGroupList;
    function GetHasGroupList : Boolean;
    function GetSupplementalDataList : TFhirMeasureSupplementalDataList;
    function GetHasSupplementalDataList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMeasure; overload;
    function Clone : TFhirMeasure; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this measure when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this measure is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the measure. For more information see [Technical and Business Versions](resource.html#versions).
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this measure when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this measure is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the measure. For more information see [Technical and Business Versions](resource.html#versions).
    property urlElement : TFhirUri read FUrl write SetUrl;

    // A formal identifier that is used to identify this measure when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the measure when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the measure author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. To provide a version consistent with the Decision Support Service specification, use the format Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge assets, refer to the Decision Support Service specification. Note that a version is required for non-experimental active artifacts.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the measure when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the measure author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. To provide a version consistent with the Decision Support Service specification, use the format Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge assets, refer to the Decision Support Service specification. Note that a version is required for non-experimental active artifacts.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the measure. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the measure. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the measure.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the measure.
    property titleElement : TFhirString read FTitle write SetTitle;

    // The status of this measure. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A boolean value to indicate that this measure is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A boolean value to indicate that this measure is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The date  (and optionally time) when the measure was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the measure changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the measure was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the measure changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the measure.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the measure.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Typed access to A free text natural language description of the measure from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the measure from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // Typed access to Explaination of why this measure is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explaination of why this measure is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Typed access to A detailed description of how the measure is used from a clinical perspective.
    property usage : String read GetUsageST write SetUsageST;
    // A detailed description of how the measure is used from a clinical perspective.
    property usageElement : TFhirString read FUsage write SetUsage;

    // Typed access to The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDate : TFslDateTime read GetApprovalDateST write SetApprovalDateST;
    // The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDateElement : TFhirDate read FApprovalDate write SetApprovalDate;

    // Typed access to The date on which the resource content was last reviewed. Review happens periodically after approval, but doesn't change the original approval date.
    property lastReviewDate : TFslDateTime read GetLastReviewDateST write SetLastReviewDateST;
    // The date on which the resource content was last reviewed. Review happens periodically after approval, but doesn't change the original approval date.
    property lastReviewDateElement : TFhirDate read FLastReviewDate write SetLastReviewDate;

    // Typed access to The period during which the measure content was or is planned to be in active use. (defined for API consistency)
    property effectivePeriod : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;
    // The period during which the measure content was or is planned to be in active use.
    property effectivePeriodElement : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These terms may be used to assist with indexing and searching for appropriate measure instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the measure is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Descriptive topics related to the content of the measure. Topics provide a high-level categorization of the type of the measure that can be useful for filtering and searching.
    property topicList : TFhirCodeableConceptList read GetTopicList;
    property hasTopicList : boolean read GetHasTopicList;

    // A contributor to the content of the measure, including authors, editors, reviewers, and endorsers.
    property contributorList : TFhirContributorList read GetContributorList;
    property hasContributorList : boolean read GetHasContributorList;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A copyright statement relating to the measure and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the measure.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the measure and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the measure.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // Related artifacts such as additional documentation, justification, or bibliographic references.
    property relatedArtifactList : TFhirRelatedArtifactList read GetRelatedArtifactList;
    property hasRelatedArtifactList : boolean read GetHasRelatedArtifactList;

    // A reference to a Library resource containing the formal logic used by the measure.
    property library_List : TFhirReferenceList{TFhirLibrary} read GetLibrary_List;
    property hasLibrary_List : boolean read GetHasLibrary_List;

    // Typed access to Notices and disclaimers regarding the use of the measure, or related to intellectual property (such as code systems) referenced by the measure.
    property disclaimer : String read GetDisclaimerST write SetDisclaimerST;
    // Notices and disclaimers regarding the use of the measure, or related to intellectual property (such as code systems) referenced by the measure.
    property disclaimerElement : TFhirMarkdown read FDisclaimer write SetDisclaimer;

    // Typed access to Indicates how the calculation is performed for the measure, including proportion, ratio, continuous variable, and cohort. The value set is extensible, allowing additional measure scoring types to be represented. (defined for API consistency)
    property scoring : TFhirCodeableConcept read FScoring write SetScoring;
    // Indicates how the calculation is performed for the measure, including proportion, ratio, continuous variable, and cohort. The value set is extensible, allowing additional measure scoring types to be represented.
    property scoringElement : TFhirCodeableConcept read FScoring write SetScoring;

    // Typed access to If this is a composite measure, the scoring method used to combine the component measures to determine the composite score. (defined for API consistency)
    property compositeScoring : TFhirCodeableConcept read FCompositeScoring write SetCompositeScoring;
    // If this is a composite measure, the scoring method used to combine the component measures to determine the composite score.
    property compositeScoringElement : TFhirCodeableConcept read FCompositeScoring write SetCompositeScoring;

    // Indicates whether the measure is used to examine a process, an outcome over time, a patient-reported outcome, or a structure measure such as utilization.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Typed access to A description of the risk adjustment factors that may impact the resulting score for the measure and how they may be accounted for when computing and reporting measure results.
    property riskAdjustment : String read GetRiskAdjustmentST write SetRiskAdjustmentST;
    // A description of the risk adjustment factors that may impact the resulting score for the measure and how they may be accounted for when computing and reporting measure results.
    property riskAdjustmentElement : TFhirString read FRiskAdjustment write SetRiskAdjustment;

    // Typed access to Describes how to combine the information calculated, based on logic in each of several populations, into one summarized result.
    property rateAggregation : String read GetRateAggregationST write SetRateAggregationST;
    // Describes how to combine the information calculated, based on logic in each of several populations, into one summarized result.
    property rateAggregationElement : TFhirString read FRateAggregation write SetRateAggregation;

    // Typed access to Provides a succint statement of the need for the measure. Usually includes statements pertaining to importance criterion: impact, gap in care, and evidence.
    property rationale : String read GetRationaleST write SetRationaleST;
    // Provides a succint statement of the need for the measure. Usually includes statements pertaining to importance criterion: impact, gap in care, and evidence.
    property rationaleElement : TFhirMarkdown read FRationale write SetRationale;

    // Typed access to Provides a summary of relevant clinical guidelines or other clinical recommendations supporting the measure.
    property clinicalRecommendationStatement : String read GetClinicalRecommendationStatementST write SetClinicalRecommendationStatementST;
    // Provides a summary of relevant clinical guidelines or other clinical recommendations supporting the measure.
    property clinicalRecommendationStatementElement : TFhirMarkdown read FClinicalRecommendationStatement write SetClinicalRecommendationStatement;

    // Typed access to Information on whether an increase or decrease in score is the preferred result (e.g., a higher score indicates better quality OR a lower score indicates better quality OR quality is whthin a range).
    property improvementNotation : String read GetImprovementNotationST write SetImprovementNotationST;
    // Information on whether an increase or decrease in score is the preferred result (e.g., a higher score indicates better quality OR a lower score indicates better quality OR quality is whthin a range).
    property improvementNotationElement : TFhirString read FImprovementNotation write SetImprovementNotation;

    // Provides a description of an individual term used within the measure.
    property definitionList : TFhirMarkdownList read GetDefinitionList;
    property hasDefinitionList : boolean read GetHasDefinitionList;

    // Typed access to Additional guidance for the measure including how it can be used in a clinical context, and the intent of the measure.
    property guidance : String read GetGuidanceST write SetGuidanceST;
    // Additional guidance for the measure including how it can be used in a clinical context, and the intent of the measure.
    property guidanceElement : TFhirMarkdown read FGuidance write SetGuidance;

    // Typed access to The measure set, e.g. Preventive Care and Screening.
    property set_ : String read GetSet_ST write SetSet_ST;
    // The measure set, e.g. Preventive Care and Screening.
    property set_Element : TFhirString read FSet_ write SetSet_;

    // A group of population criteria for the measure.
    property groupList : TFhirMeasureGroupList read GetGroupList;
    property hasGroupList : boolean read GetHasGroupList;

    // The supplemental data criteria for the measure report, specified as either the name of a valid CQL expression within a referenced library, or a valid FHIR Resource Path.
    property supplementalDataList : TFhirMeasureSupplementalDataList read GetSupplementalDataList;
    property hasSupplementalDataList : boolean read GetHasSupplementalDataList;

  end;

  TFhirMeasureListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMeasureList;
    function GetCurrent : TFhirMeasure;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMeasureList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMeasure read GetCurrent;
  end;

  TFhirMeasureList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMeasure;
    procedure SetItemN(index : Integer; value : TFhirMeasure);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMeasureList; Overload;
    function Clone : TFhirMeasureList; Overload;
    function GetEnumerator : TFhirMeasureListEnumerator;

    //  Add a FhirMeasure to the end of the list.
    function Append : TFhirMeasure;

    // Add an already existing FhirMeasure to the end of the list.
    procedure AddItem(value : TFhirMeasure); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMeasure) : Integer;

    // Insert FhirMeasure before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMeasure;

    // Insert an existing FhirMeasure before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMeasure);

    // Get the iIndexth FhirMeasure. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMeasure);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMeasure;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMeasures[index : Integer] : TFhirMeasure read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEASURE}

{$IFDEF FHIR_MESSAGEDEFINITION}

  // Identifies the resource (or resources) that are being addressed by the event.  For example, the Encounter for an admit message or two Account records for a merge.
  TFhirMessageDefinitionFocus = class (TFhirBackboneElement)
  protected
    FCode : TFhirEnum;
    FProfile : TFhirReference{TFhirStructureDefinition};
    FMin : TFhirUnsignedInt;
    FMax : TFhirString;
    Procedure SetCode(value : TFhirEnum);
    Function GetCodeST : TFhirResourceTypesEnum;
    Procedure SetCodeST(value : TFhirResourceTypesEnum);
    Procedure SetProfile(value : TFhirReference{TFhirStructureDefinition});
    Procedure SetMin(value : TFhirUnsignedInt);
    Function GetMinST : String;
    Procedure SetMinST(value : String);
    Procedure SetMax(value : TFhirString);
    Function GetMaxST : String;
    Procedure SetMaxST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMessageDefinitionFocus; overload;
    function Clone : TFhirMessageDefinitionFocus; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The kind of resource that must be the focus for this message.
    property code : TFhirResourceTypesEnum read GetCodeST write SetCodeST;
    property codeElement : TFhirEnum read FCode write SetCode;

    // Typed access to A profile that reflects constraints for the focal resource (and potentially for related resources). (defined for API consistency)
    property profile : TFhirReference{TFhirStructureDefinition} read FProfile write SetProfile;
    // A profile that reflects constraints for the focal resource (and potentially for related resources).
    property profileElement : TFhirReference{TFhirStructureDefinition} read FProfile write SetProfile;

    // Typed access to Identifies the minimum number of resources of this type that must be pointed to by a message in order for it to be valid against this MessageDefinition.
    property min : String read GetMinST write SetMinST;
    // Identifies the minimum number of resources of this type that must be pointed to by a message in order for it to be valid against this MessageDefinition.
    property minElement : TFhirUnsignedInt read FMin write SetMin;

    // Typed access to Identifies the maximum number of resources of this type that must be pointed to by a message in order for it to be valid against this MessageDefinition.
    property max : String read GetMaxST write SetMaxST;
    // Identifies the maximum number of resources of this type that must be pointed to by a message in order for it to be valid against this MessageDefinition.
    property maxElement : TFhirString read FMax write SetMax;

  end;

  TFhirMessageDefinitionFocusListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMessageDefinitionFocusList;
    function GetCurrent : TFhirMessageDefinitionFocus;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMessageDefinitionFocusList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMessageDefinitionFocus read GetCurrent;
  end;

  TFhirMessageDefinitionFocusList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMessageDefinitionFocus;
    procedure SetItemN(index : Integer; value : TFhirMessageDefinitionFocus);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMessageDefinitionFocusList; Overload;
    function Clone : TFhirMessageDefinitionFocusList; Overload;
    function GetEnumerator : TFhirMessageDefinitionFocusListEnumerator;

    //  Add a FhirMessageDefinitionFocus to the end of the list.
    function Append : TFhirMessageDefinitionFocus;

    // Add an already existing FhirMessageDefinitionFocus to the end of the list.
    procedure AddItem(value : TFhirMessageDefinitionFocus); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMessageDefinitionFocus) : Integer;

    // Insert FhirMessageDefinitionFocus before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMessageDefinitionFocus;

    // Insert an existing FhirMessageDefinitionFocus before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMessageDefinitionFocus);

    // Get the iIndexth FhirMessageDefinitionFocus. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMessageDefinitionFocus);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMessageDefinitionFocus;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMessageDefinitionFocus[index : Integer] : TFhirMessageDefinitionFocus read GetItemN write SetItemN; default;
  End;

  // Indicates what types of messages may be sent as an application-level response to this message.
  TFhirMessageDefinitionAllowedResponse = class (TFhirBackboneElement)
  protected
    FMessage : TFhirReference{TFhirMessageDefinition};
    FSituation : TFhirMarkdown;
    Procedure SetMessage(value : TFhirReference{TFhirMessageDefinition});
    Procedure SetSituation(value : TFhirMarkdown);
    Function GetSituationST : String;
    Procedure SetSituationST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMessageDefinitionAllowedResponse; overload;
    function Clone : TFhirMessageDefinitionAllowedResponse; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A reference to the message definition that must be adhered to by this supported response. (defined for API consistency)
    property message : TFhirReference{TFhirMessageDefinition} read FMessage write SetMessage;
    // A reference to the message definition that must be adhered to by this supported response.
    property messageElement : TFhirReference{TFhirMessageDefinition} read FMessage write SetMessage;

    // Typed access to Provides a description of the circumstances in which this response should be used (as opposed to one of the alternative responses).
    property situation : String read GetSituationST write SetSituationST;
    // Provides a description of the circumstances in which this response should be used (as opposed to one of the alternative responses).
    property situationElement : TFhirMarkdown read FSituation write SetSituation;

  end;

  TFhirMessageDefinitionAllowedResponseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMessageDefinitionAllowedResponseList;
    function GetCurrent : TFhirMessageDefinitionAllowedResponse;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMessageDefinitionAllowedResponseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMessageDefinitionAllowedResponse read GetCurrent;
  end;

  TFhirMessageDefinitionAllowedResponseList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMessageDefinitionAllowedResponse;
    procedure SetItemN(index : Integer; value : TFhirMessageDefinitionAllowedResponse);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMessageDefinitionAllowedResponseList; Overload;
    function Clone : TFhirMessageDefinitionAllowedResponseList; Overload;
    function GetEnumerator : TFhirMessageDefinitionAllowedResponseListEnumerator;

    //  Add a FhirMessageDefinitionAllowedResponse to the end of the list.
    function Append : TFhirMessageDefinitionAllowedResponse;

    // Add an already existing FhirMessageDefinitionAllowedResponse to the end of the list.
    procedure AddItem(value : TFhirMessageDefinitionAllowedResponse); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMessageDefinitionAllowedResponse) : Integer;

    // Insert FhirMessageDefinitionAllowedResponse before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMessageDefinitionAllowedResponse;

    // Insert an existing FhirMessageDefinitionAllowedResponse before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMessageDefinitionAllowedResponse);

    // Get the iIndexth FhirMessageDefinitionAllowedResponse. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMessageDefinitionAllowedResponse);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMessageDefinitionAllowedResponse;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMessageDefinitionAllowedResponses[index : Integer] : TFhirMessageDefinitionAllowedResponse read GetItemN write SetItemN; default;
  End;

  // Defines the characteristics of a message that can be shared between systems, including the type of event that initiates the message, the content to be transmitted and what response(s), if any, are permitted.
  TFhirMessageDefinition = class (TFhirMetadataResource)
  protected
    FIdentifier : TFhirIdentifier;
    FPurpose : TFhirMarkdown;
    FCopyright : TFhirMarkdown;
    FBase : TFhirReference{TFhirMessageDefinition};
    FparentList : TFhirReferenceList{Resource};
    FreplacesList : TFhirReferenceList{TFhirMessageDefinition};
    FEvent : TFhirCoding;
    FCategory : TFhirEnum;
    FfocusList : TFhirMessageDefinitionFocusList;
    FResponseRequired : TFhirBoolean;
    FallowedResponseList : TFhirMessageDefinitionAllowedResponseList;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetPurpose(value : TFhirMarkdown);
    Function GetPurposeST : String;
    Procedure SetPurposeST(value : String);
    Procedure SetCopyright(value : TFhirMarkdown);
    Function GetCopyrightST : String;
    Procedure SetCopyrightST(value : String);
    Procedure SetBase(value : TFhirReference{TFhirMessageDefinition});
    function GetParentList : TFhirReferenceList{Resource};
    function GetHasParentList : Boolean;
    function GetReplacesList : TFhirReferenceList{TFhirMessageDefinition};
    function GetHasReplacesList : Boolean;
    Procedure SetEvent(value : TFhirCoding);
    Procedure SetCategory(value : TFhirEnum);
    Function GetCategoryST : TFhirMessageSignificanceCategoryEnum;
    Procedure SetCategoryST(value : TFhirMessageSignificanceCategoryEnum);
    function GetFocusList : TFhirMessageDefinitionFocusList;
    function GetHasFocusList : Boolean;
    Procedure SetResponseRequired(value : TFhirBoolean);
    Function GetResponseRequiredST : Boolean;
    Procedure SetResponseRequiredST(value : Boolean);
    function GetAllowedResponseList : TFhirMessageDefinitionAllowedResponseList;
    function GetHasAllowedResponseList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMessageDefinition; overload;
    function Clone : TFhirMessageDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this message definition when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this message definition is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the message definition. For more information see [Technical and Business Versions](resource.html#versions).
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this message definition when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this message definition is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the message definition. For more information see [Technical and Business Versions](resource.html#versions).
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to A formal identifier that is used to identify this message definition when it is represented in other formats, or referenced in a specification, model, design or an instance. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // A formal identifier that is used to identify this message definition when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to The identifier that is used to identify this version of the message definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the message definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the message definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the message definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the message definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the message definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the message definition.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the message definition.
    property titleElement : TFhirString read FTitle write SetTitle;

    // The status of this message definition. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A boolean value to indicate that this message definition is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A boolean value to indicate that this message definition is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The date  (and optionally time) when the message definition was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the message definition changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the message definition was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the message definition changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the message definition.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the message definition.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the message definition from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the message definition from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These terms may be used to assist with indexing and searching for appropriate message definition instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the message definition is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to Explaination of why this message definition is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explaination of why this message definition is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Typed access to A copyright statement relating to the message definition and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the message definition.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the message definition and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the message definition.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // Typed access to The MessageDefinition that is the basis for the contents of this resource. (defined for API consistency)
    property base : TFhirReference{TFhirMessageDefinition} read FBase write SetBase;
    // The MessageDefinition that is the basis for the contents of this resource.
    property baseElement : TFhirReference{TFhirMessageDefinition} read FBase write SetBase;

    // Identifies a protocol or workflow that this MessageDefinition represents a step in.
    property parentList : TFhirReferenceList{Resource} read GetParentList;
    property hasParentList : boolean read GetHasParentList;

    // A MessageDefinition that is superseded by this definition.
    property replacesList : TFhirReferenceList{TFhirMessageDefinition} read GetReplacesList;
    property hasReplacesList : boolean read GetHasReplacesList;

    // Typed access to A coded identifier of a supported messaging event. (defined for API consistency)
    property event : TFhirCoding read FEvent write SetEvent;
    // A coded identifier of a supported messaging event.
    property eventElement : TFhirCoding read FEvent write SetEvent;

    // The impact of the content of the message.
    property category : TFhirMessageSignificanceCategoryEnum read GetCategoryST write SetCategoryST;
    property categoryElement : TFhirEnum read FCategory write SetCategory;

    // Identifies the resource (or resources) that are being addressed by the event.  For example, the Encounter for an admit message or two Account records for a merge.
    property focusList : TFhirMessageDefinitionFocusList read GetFocusList;
    property hasFocusList : boolean read GetHasFocusList;

    // Typed access to Indicates whether a response is required for this message.
    property responseRequired : Boolean read GetResponseRequiredST write SetResponseRequiredST;
    // Indicates whether a response is required for this message.
    property responseRequiredElement : TFhirBoolean read FResponseRequired write SetResponseRequired;

    // Indicates what types of messages may be sent as an application-level response to this message.
    property allowedResponseList : TFhirMessageDefinitionAllowedResponseList read GetAllowedResponseList;
    property hasAllowedResponseList : boolean read GetHasAllowedResponseList;

  end;

  TFhirMessageDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMessageDefinitionList;
    function GetCurrent : TFhirMessageDefinition;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirMessageDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMessageDefinition read GetCurrent;
  end;

  TFhirMessageDefinitionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirMessageDefinition;
    procedure SetItemN(index : Integer; value : TFhirMessageDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirMessageDefinitionList; Overload;
    function Clone : TFhirMessageDefinitionList; Overload;
    function GetEnumerator : TFhirMessageDefinitionListEnumerator;

    //  Add a FhirMessageDefinition to the end of the list.
    function Append : TFhirMessageDefinition;

    // Add an already existing FhirMessageDefinition to the end of the list.
    procedure AddItem(value : TFhirMessageDefinition); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMessageDefinition) : Integer;

    // Insert FhirMessageDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMessageDefinition;

    // Insert an existing FhirMessageDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMessageDefinition);

    // Get the iIndexth FhirMessageDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMessageDefinition);

    // The number of items in the collection
    function Item(index : Integer) : TFhirMessageDefinition;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirMessageDefinitions[index : Integer] : TFhirMessageDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MESSAGEDEFINITION}

{$IFDEF FHIR_NAMINGSYSTEM}

  // Indicates how the system may be identified when referenced in electronic exchange.
  TFhirNamingSystemUniqueId = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FValue : TFhirString;
    FPreferred : TFhirBoolean;
    FComment : TFhirString;
    FPeriod : TFhirPeriod;
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirNamingsystemIdentifierTypeEnum;
    Procedure SetType_ST(value : TFhirNamingsystemIdentifierTypeEnum);
    Procedure SetValue(value : TFhirString);
    Function GetValueST : String;
    Procedure SetValueST(value : String);
    Procedure SetPreferred(value : TFhirBoolean);
    Function GetPreferredST : Boolean;
    Procedure SetPreferredST(value : Boolean);
    Procedure SetComment(value : TFhirString);
    Function GetCommentST : String;
    Procedure SetCommentST(value : String);
    Procedure SetPeriod(value : TFhirPeriod);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNamingSystemUniqueId; overload;
    function Clone : TFhirNamingSystemUniqueId; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Identifies the unique identifier scheme used for this particular identifier.
    property type_ : TFhirNamingsystemIdentifierTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The string that should be sent over the wire to identify the code system or identifier system.
    property value : String read GetValueST write SetValueST;
    // The string that should be sent over the wire to identify the code system or identifier system.
    property valueElement : TFhirString read FValue write SetValue;

    // Typed access to Indicates whether this identifier is the "preferred" identifier of this type.
    property preferred : Boolean read GetPreferredST write SetPreferredST;
    // Indicates whether this identifier is the "preferred" identifier of this type.
    property preferredElement : TFhirBoolean read FPreferred write SetPreferred;

    // Typed access to Notes about the past or intended usage of this identifier.
    property comment : String read GetCommentST write SetCommentST;
    // Notes about the past or intended usage of this identifier.
    property commentElement : TFhirString read FComment write SetComment;

    // Typed access to Identifies the period of time over which this identifier is considered appropriate to refer to the naming system.  Outside of this window, the identifier might be non-deterministic. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Identifies the period of time over which this identifier is considered appropriate to refer to the naming system.  Outside of this window, the identifier might be non-deterministic.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirNamingSystemUniqueIdListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNamingSystemUniqueIdList;
    function GetCurrent : TFhirNamingSystemUniqueId;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirNamingSystemUniqueIdList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNamingSystemUniqueId read GetCurrent;
  end;

  TFhirNamingSystemUniqueIdList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirNamingSystemUniqueId;
    procedure SetItemN(index : Integer; value : TFhirNamingSystemUniqueId);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirNamingSystemUniqueIdList; Overload;
    function Clone : TFhirNamingSystemUniqueIdList; Overload;
    function GetEnumerator : TFhirNamingSystemUniqueIdListEnumerator;

    //  Add a FhirNamingSystemUniqueId to the end of the list.
    function Append : TFhirNamingSystemUniqueId;

    // Add an already existing FhirNamingSystemUniqueId to the end of the list.
    procedure AddItem(value : TFhirNamingSystemUniqueId); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNamingSystemUniqueId) : Integer;

    // Insert FhirNamingSystemUniqueId before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNamingSystemUniqueId;

    // Insert an existing FhirNamingSystemUniqueId before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNamingSystemUniqueId);

    // Get the iIndexth FhirNamingSystemUniqueId. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNamingSystemUniqueId);

    // The number of items in the collection
    function Item(index : Integer) : TFhirNamingSystemUniqueId;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirNamingSystemUniqueIds[index : Integer] : TFhirNamingSystemUniqueId read GetItemN write SetItemN; default;
  End;

  // A curated namespace that issues unique symbols within that namespace for the identification of concepts, people, devices, etc.  Represents a "System" used within the Identifier and Coding data types.
  TFhirNamingSystem = class (TFhirMetadataResource)
  protected
    FKind : TFhirEnum;
    FResponsible : TFhirString;
    FType_ : TFhirCodeableConcept;
    FUsage : TFhirString;
    FuniqueIdList : TFhirNamingSystemUniqueIdList;
    FReplacedBy : TFhirReference{TFhirNamingSystem};
    Procedure SetKind(value : TFhirEnum);
    Function GetKindST : TFhirNamingsystemTypeEnum;
    Procedure SetKindST(value : TFhirNamingsystemTypeEnum);
    Procedure SetResponsible(value : TFhirString);
    Function GetResponsibleST : String;
    Procedure SetResponsibleST(value : String);
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetUsage(value : TFhirString);
    Function GetUsageST : String;
    Procedure SetUsageST(value : String);
    function GetUniqueIdList : TFhirNamingSystemUniqueIdList;
    function GetHasUniqueIdList : Boolean;
    Procedure SetReplacedBy(value : TFhirReference{TFhirNamingSystem});

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNamingSystem; overload;
    function Clone : TFhirNamingSystem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A natural language name identifying the naming system. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the naming system. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // The status of this naming system. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Indicates the purpose for the naming system - what kinds of things does it make unique?
    property kind : TFhirNamingsystemTypeEnum read GetKindST write SetKindST;
    property kindElement : TFhirEnum read FKind write SetKind;

    // Typed access to The date  (and optionally time) when the naming system was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the naming system changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the naming system was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the naming system changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the naming system.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the naming system.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to The name of the organization that is responsible for issuing identifiers or codes for this namespace and ensuring their non-collision.
    property responsible : String read GetResponsibleST write SetResponsibleST;
    // The name of the organization that is responsible for issuing identifiers or codes for this namespace and ensuring their non-collision.
    property responsibleElement : TFhirString read FResponsible write SetResponsible;

    // Typed access to Categorizes a naming system for easier search by grouping related naming systems. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Categorizes a naming system for easier search by grouping related naming systems.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A free text natural language description of the naming system from a consumer's perspective. Details about what the namespace identifies including scope, granularity, version labeling, etc.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the naming system from a consumer's perspective. Details about what the namespace identifies including scope, granularity, version labeling, etc.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These terms may be used to assist with indexing and searching for appropriate naming system instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the naming system is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to Provides guidance on the use of the namespace, including the handling of formatting characters, use of upper vs. lower case, etc.
    property usage : String read GetUsageST write SetUsageST;
    // Provides guidance on the use of the namespace, including the handling of formatting characters, use of upper vs. lower case, etc.
    property usageElement : TFhirString read FUsage write SetUsage;

    // Indicates how the system may be identified when referenced in electronic exchange.
    property uniqueIdList : TFhirNamingSystemUniqueIdList read GetUniqueIdList;
    property hasUniqueIdList : boolean read GetHasUniqueIdList;

    // Typed access to For naming systems that are retired, indicates the naming system that should be used in their place (if any). (defined for API consistency)
    property replacedBy : TFhirReference{TFhirNamingSystem} read FReplacedBy write SetReplacedBy;
    // For naming systems that are retired, indicates the naming system that should be used in their place (if any).
    property replacedByElement : TFhirReference{TFhirNamingSystem} read FReplacedBy write SetReplacedBy;

  end;

  TFhirNamingSystemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNamingSystemList;
    function GetCurrent : TFhirNamingSystem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirNamingSystemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNamingSystem read GetCurrent;
  end;

  TFhirNamingSystemList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirNamingSystem;
    procedure SetItemN(index : Integer; value : TFhirNamingSystem);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirNamingSystemList; Overload;
    function Clone : TFhirNamingSystemList; Overload;
    function GetEnumerator : TFhirNamingSystemListEnumerator;

    //  Add a FhirNamingSystem to the end of the list.
    function Append : TFhirNamingSystem;

    // Add an already existing FhirNamingSystem to the end of the list.
    procedure AddItem(value : TFhirNamingSystem); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNamingSystem) : Integer;

    // Insert FhirNamingSystem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNamingSystem;

    // Insert an existing FhirNamingSystem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNamingSystem);

    // Get the iIndexth FhirNamingSystem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNamingSystem);

    // The number of items in the collection
    function Item(index : Integer) : TFhirNamingSystem;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirNamingSystems[index : Integer] : TFhirNamingSystem read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_NAMINGSYSTEM}

{$IFDEF FHIR_OPERATIONDEFINITION}

  // The parameters for the operation/query.
  TFhirOperationDefinitionParameter = class (TFhirBackboneElement)
  protected
    FName : TFhirCode;
    FUse : TFhirEnum;
    FMin : TFhirInteger;
    FMax : TFhirString;
    FDocumentation : TFhirString;
    FType_ : TFhirEnum;
    FSearchType : TFhirEnum;
    FProfile : TFhirReference{TFhirStructureDefinition};
    FBinding : TFhirOperationDefinitionParameterBinding;
    FpartList : TFhirOperationDefinitionParameterList;
    Procedure SetName(value : TFhirCode);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetUse(value : TFhirEnum);
    Function GetUseST : TFhirOperationParameterUseEnum;
    Procedure SetUseST(value : TFhirOperationParameterUseEnum);
    Procedure SetMin(value : TFhirInteger);
    Function GetMinST : String;
    Procedure SetMinST(value : String);
    Procedure SetMax(value : TFhirString);
    Function GetMaxST : String;
    Procedure SetMaxST(value : String);
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirAllTypesEnum;
    Procedure SetType_ST(value : TFhirAllTypesEnum);
    Procedure SetSearchType(value : TFhirEnum);
    Function GetSearchTypeST : TFhirSearchParamTypeEnum;
    Procedure SetSearchTypeST(value : TFhirSearchParamTypeEnum);
    Procedure SetProfile(value : TFhirReference{TFhirStructureDefinition});
    Procedure SetBinding(value : TFhirOperationDefinitionParameterBinding);
    function GetPartList : TFhirOperationDefinitionParameterList;
    function GetHasPartList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirOperationDefinitionParameter; overload;
    function Clone : TFhirOperationDefinitionParameter; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The name of used to identify the parameter.
    property name : String read GetNameST write SetNameST;
    // The name of used to identify the parameter.
    property nameElement : TFhirCode read FName write SetName;

    // Whether this is an input or an output parameter.
    property use : TFhirOperationParameterUseEnum read GetUseST write SetUseST;
    property useElement : TFhirEnum read FUse write SetUse;

    // Typed access to The minimum number of times this parameter SHALL appear in the request or response.
    property min : String read GetMinST write SetMinST;
    // The minimum number of times this parameter SHALL appear in the request or response.
    property minElement : TFhirInteger read FMin write SetMin;

    // Typed access to The maximum number of times this element is permitted to appear in the request or response.
    property max : String read GetMaxST write SetMaxST;
    // The maximum number of times this element is permitted to appear in the request or response.
    property maxElement : TFhirString read FMax write SetMax;

    // Typed access to Describes the meaning or use of this parameter.
    property documentation : String read GetDocumentationST write SetDocumentationST;
    // Describes the meaning or use of this parameter.
    property documentationElement : TFhirString read FDocumentation write SetDocumentation;

    // The type for this parameter.
    property type_ : TFhirAllTypesEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // How the parameter is understood as a search parameter. This is only used if the parameter type is 'string'.
    property searchType : TFhirSearchParamTypeEnum read GetSearchTypeST write SetSearchTypeST;
    property searchTypeElement : TFhirEnum read FSearchType write SetSearchType;

    // Typed access to A profile the specifies the rules that this parameter must conform to. (defined for API consistency)
    property profile : TFhirReference{TFhirStructureDefinition} read FProfile write SetProfile;
    // A profile the specifies the rules that this parameter must conform to.
    property profileElement : TFhirReference{TFhirStructureDefinition} read FProfile write SetProfile;

    // Typed access to Binds to a value set if this parameter is coded (code, Coding, CodeableConcept). (defined for API consistency)
    property binding : TFhirOperationDefinitionParameterBinding read FBinding write SetBinding;
    // Binds to a value set if this parameter is coded (code, Coding, CodeableConcept).
    property bindingElement : TFhirOperationDefinitionParameterBinding read FBinding write SetBinding;

    // The parts of a nested Parameter.
    property partList : TFhirOperationDefinitionParameterList read GetPartList;
    property hasPartList : boolean read GetHasPartList;

  end;

  TFhirOperationDefinitionParameterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirOperationDefinitionParameterList;
    function GetCurrent : TFhirOperationDefinitionParameter;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirOperationDefinitionParameterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirOperationDefinitionParameter read GetCurrent;
  end;

  TFhirOperationDefinitionParameterList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirOperationDefinitionParameter;
    procedure SetItemN(index : Integer; value : TFhirOperationDefinitionParameter);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirOperationDefinitionParameterList; Overload;
    function Clone : TFhirOperationDefinitionParameterList; Overload;
    function GetEnumerator : TFhirOperationDefinitionParameterListEnumerator;

    //  Add a FhirOperationDefinitionParameter to the end of the list.
    function Append : TFhirOperationDefinitionParameter;

    // Add an already existing FhirOperationDefinitionParameter to the end of the list.
    procedure AddItem(value : TFhirOperationDefinitionParameter); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirOperationDefinitionParameter) : Integer;

    // Insert FhirOperationDefinitionParameter before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirOperationDefinitionParameter;

    // Insert an existing FhirOperationDefinitionParameter before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirOperationDefinitionParameter);

    // Get the iIndexth FhirOperationDefinitionParameter. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirOperationDefinitionParameter);

    // The number of items in the collection
    function Item(index : Integer) : TFhirOperationDefinitionParameter;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirOperationDefinitionParameters[index : Integer] : TFhirOperationDefinitionParameter read GetItemN write SetItemN; default;
  End;

  // Binds to a value set if this parameter is coded (code, Coding, CodeableConcept).
  TFhirOperationDefinitionParameterBinding = class (TFhirBackboneElement)
  protected
    FStrength : TFhirEnum;
    FValueSet : TFhirType;
    Procedure SetStrength(value : TFhirEnum);
    Function GetStrengthST : TFhirBindingStrengthEnum;
    Procedure SetStrengthST(value : TFhirBindingStrengthEnum);
    Procedure SetValueSet(value : TFhirType);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirOperationDefinitionParameterBinding; overload;
    function Clone : TFhirOperationDefinitionParameterBinding; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Indicates the degree of conformance expectations associated with this binding - that is, the degree to which the provided value set must be adhered to in the instances.
    property strength : TFhirBindingStrengthEnum read GetStrengthST write SetStrengthST;
    property strengthElement : TFhirEnum read FStrength write SetStrength;

    // Typed access to Points to the value set or external definition (e.g. implicit value set) that identifies the set of codes to be used. (defined for API consistency)
    property valueSet : TFhirType read FValueSet write SetValueSet;
    // Points to the value set or external definition (e.g. implicit value set) that identifies the set of codes to be used.
    property valueSetElement : TFhirType read FValueSet write SetValueSet;

  end;

  TFhirOperationDefinitionParameterBindingListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirOperationDefinitionParameterBindingList;
    function GetCurrent : TFhirOperationDefinitionParameterBinding;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirOperationDefinitionParameterBindingList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirOperationDefinitionParameterBinding read GetCurrent;
  end;

  TFhirOperationDefinitionParameterBindingList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirOperationDefinitionParameterBinding;
    procedure SetItemN(index : Integer; value : TFhirOperationDefinitionParameterBinding);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirOperationDefinitionParameterBindingList; Overload;
    function Clone : TFhirOperationDefinitionParameterBindingList; Overload;
    function GetEnumerator : TFhirOperationDefinitionParameterBindingListEnumerator;

    //  Add a FhirOperationDefinitionParameterBinding to the end of the list.
    function Append : TFhirOperationDefinitionParameterBinding;

    // Add an already existing FhirOperationDefinitionParameterBinding to the end of the list.
    procedure AddItem(value : TFhirOperationDefinitionParameterBinding); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirOperationDefinitionParameterBinding) : Integer;

    // Insert FhirOperationDefinitionParameterBinding before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirOperationDefinitionParameterBinding;

    // Insert an existing FhirOperationDefinitionParameterBinding before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirOperationDefinitionParameterBinding);

    // Get the iIndexth FhirOperationDefinitionParameterBinding. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirOperationDefinitionParameterBinding);

    // The number of items in the collection
    function Item(index : Integer) : TFhirOperationDefinitionParameterBinding;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirOperationDefinitionParameterBindings[index : Integer] : TFhirOperationDefinitionParameterBinding read GetItemN write SetItemN; default;
  End;

  // Defines an appropriate combination of parameters to use when invoking this operation, to help code generators when generating overloaded parameter sets for this operation.
  TFhirOperationDefinitionOverload = class (TFhirBackboneElement)
  protected
    FparameterNameList : TFhirStringList;
    FComment : TFhirString;
    function GetParameterNameList : TFhirStringList;
    function GetHasParameterNameList : Boolean;
    Procedure SetComment(value : TFhirString);
    Function GetCommentST : String;
    Procedure SetCommentST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirOperationDefinitionOverload; overload;
    function Clone : TFhirOperationDefinitionOverload; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Name of parameter to include in overload.
    property parameterNameList : TFhirStringList read GetParameterNameList;
    property hasParameterNameList : boolean read GetHasParameterNameList;

    // Typed access to Comments to go on overload.
    property comment : String read GetCommentST write SetCommentST;
    // Comments to go on overload.
    property commentElement : TFhirString read FComment write SetComment;

  end;

  TFhirOperationDefinitionOverloadListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirOperationDefinitionOverloadList;
    function GetCurrent : TFhirOperationDefinitionOverload;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirOperationDefinitionOverloadList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirOperationDefinitionOverload read GetCurrent;
  end;

  TFhirOperationDefinitionOverloadList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirOperationDefinitionOverload;
    procedure SetItemN(index : Integer; value : TFhirOperationDefinitionOverload);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirOperationDefinitionOverloadList; Overload;
    function Clone : TFhirOperationDefinitionOverloadList; Overload;
    function GetEnumerator : TFhirOperationDefinitionOverloadListEnumerator;

    //  Add a FhirOperationDefinitionOverload to the end of the list.
    function Append : TFhirOperationDefinitionOverload;

    // Add an already existing FhirOperationDefinitionOverload to the end of the list.
    procedure AddItem(value : TFhirOperationDefinitionOverload); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirOperationDefinitionOverload) : Integer;

    // Insert FhirOperationDefinitionOverload before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirOperationDefinitionOverload;

    // Insert an existing FhirOperationDefinitionOverload before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirOperationDefinitionOverload);

    // Get the iIndexth FhirOperationDefinitionOverload. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirOperationDefinitionOverload);

    // The number of items in the collection
    function Item(index : Integer) : TFhirOperationDefinitionOverload;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirOperationDefinitionOverloads[index : Integer] : TFhirOperationDefinitionOverload read GetItemN write SetItemN; default;
  End;

  // A formal computable definition of an operation (on the RESTful interface) or a named query (using the search interaction).
  TFhirOperationDefinition = class (TFhirMetadataResource)
  protected
    FKind : TFhirEnum;
    FPurpose : TFhirMarkdown;
    FIdempotent : TFhirBoolean;
    FCode : TFhirCode;
    FComment : TFhirString;
    FBase : TFhirReference{TFhirOperationDefinition};
    FResource : TFhirEnumList;
    FSystem : TFhirBoolean;
    FType_ : TFhirBoolean;
    FInstance : TFhirBoolean;
    FparameterList : TFhirOperationDefinitionParameterList;
    FoverloadList : TFhirOperationDefinitionOverloadList;
    Procedure SetKind(value : TFhirEnum);
    Function GetKindST : TFhirOperationKindEnum;
    Procedure SetKindST(value : TFhirOperationKindEnum);
    Procedure SetPurpose(value : TFhirMarkdown);
    Function GetPurposeST : String;
    Procedure SetPurposeST(value : String);
    Procedure SetIdempotent(value : TFhirBoolean);
    Function GetIdempotentST : Boolean;
    Procedure SetIdempotentST(value : Boolean);
    Procedure SetCode(value : TFhirCode);
    Function GetCodeST : String;
    Procedure SetCodeST(value : String);
    Procedure SetComment(value : TFhirString);
    Function GetCommentST : String;
    Procedure SetCommentST(value : String);
    Procedure SetBase(value : TFhirReference{TFhirOperationDefinition});
    function GetResource : TFhirEnumList;
    function GetHasResource : Boolean;
    Procedure SetSystem(value : TFhirBoolean);
    Function GetSystemST : Boolean;
    Procedure SetSystemST(value : Boolean);
    Procedure SetType_(value : TFhirBoolean);
    Function GetType_ST : Boolean;
    Procedure SetType_ST(value : Boolean);
    Procedure SetInstance(value : TFhirBoolean);
    Function GetInstanceST : Boolean;
    Procedure SetInstanceST(value : Boolean);
    function GetParameterList : TFhirOperationDefinitionParameterList;
    function GetHasParameterList : Boolean;
    function GetOverloadList : TFhirOperationDefinitionOverloadList;
    function GetHasOverloadList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirOperationDefinition; overload;
    function Clone : TFhirOperationDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this operation definition when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this operation definition is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the operation definition. For more information see [Technical and Business Versions](resource.html#versions).
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this operation definition when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this operation definition is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the operation definition. For more information see [Technical and Business Versions](resource.html#versions).
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to The identifier that is used to identify this version of the operation definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the operation definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the operation definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the operation definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the operation definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the operation definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // The status of this operation definition. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Whether this is an operation or a named query.
    property kind : TFhirOperationKindEnum read GetKindST write SetKindST;
    property kindElement : TFhirEnum read FKind write SetKind;

    // Typed access to A boolean value to indicate that this operation definition is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A boolean value to indicate that this operation definition is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The date  (and optionally time) when the operation definition was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the operation definition changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the operation definition was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the operation definition changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the operation definition.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the operation definition.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the operation definition from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the operation definition from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These terms may be used to assist with indexing and searching for appropriate operation definition instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the operation definition is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to Explaination of why this operation definition is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explaination of why this operation definition is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Typed access to Operations that are idempotent (see [HTTP specification definition of idempotent](http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html)) may be invoked by performing an HTTP GET operation instead of a POST.
    property idempotent : Boolean read GetIdempotentST write SetIdempotentST;
    // Operations that are idempotent (see [HTTP specification definition of idempotent](http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html)) may be invoked by performing an HTTP GET operation instead of a POST.
    property idempotentElement : TFhirBoolean read FIdempotent write SetIdempotent;

    // Typed access to The name used to invoke the operation.
    property code : String read GetCodeST write SetCodeST;
    // The name used to invoke the operation.
    property codeElement : TFhirCode read FCode write SetCode;

    // Typed access to Additional information about how to use this operation or named query.
    property comment : String read GetCommentST write SetCommentST;
    // Additional information about how to use this operation or named query.
    property commentElement : TFhirString read FComment write SetComment;

    // Typed access to Indicates that this operation definition is a constraining profile on the base. (defined for API consistency)
    property base : TFhirReference{TFhirOperationDefinition} read FBase write SetBase;
    // Indicates that this operation definition is a constraining profile on the base.
    property baseElement : TFhirReference{TFhirOperationDefinition} read FBase write SetBase;

    property resource : TFhirEnumList read GetResource;
    property resourceList : TFhirEnumList read GetResource;
    property hasResource : boolean read GetHasResource;
    // Typed access to Indicates whether this operation or named query can be invoked at the system level (e.g. without needing to choose a resource type for the context).
    property system : Boolean read GetSystemST write SetSystemST;
    // Indicates whether this operation or named query can be invoked at the system level (e.g. without needing to choose a resource type for the context).
    property systemElement : TFhirBoolean read FSystem write SetSystem;

    // Typed access to Indicates whether this operation or named query can be invoked at the resource type level for any given resource type level (e.g. without needing to choose a specific resource id for the context).
    property type_ : Boolean read GetType_ST write SetType_ST;
    // Indicates whether this operation or named query can be invoked at the resource type level for any given resource type level (e.g. without needing to choose a specific resource id for the context).
    property type_Element : TFhirBoolean read FType_ write SetType_;

    // Typed access to Indicates whether this operation can be invoked on a particular instance of one of the given types.
    property instance : Boolean read GetInstanceST write SetInstanceST;
    // Indicates whether this operation can be invoked on a particular instance of one of the given types.
    property instanceElement : TFhirBoolean read FInstance write SetInstance;

    // The parameters for the operation/query.
    property parameterList : TFhirOperationDefinitionParameterList read GetParameterList;
    property hasParameterList : boolean read GetHasParameterList;

    // Defines an appropriate combination of parameters to use when invoking this operation, to help code generators when generating overloaded parameter sets for this operation.
    property overloadList : TFhirOperationDefinitionOverloadList read GetOverloadList;
    property hasOverloadList : boolean read GetHasOverloadList;

  end;

  TFhirOperationDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirOperationDefinitionList;
    function GetCurrent : TFhirOperationDefinition;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirOperationDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirOperationDefinition read GetCurrent;
  end;

  TFhirOperationDefinitionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirOperationDefinition;
    procedure SetItemN(index : Integer; value : TFhirOperationDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirOperationDefinitionList; Overload;
    function Clone : TFhirOperationDefinitionList; Overload;
    function GetEnumerator : TFhirOperationDefinitionListEnumerator;

    //  Add a FhirOperationDefinition to the end of the list.
    function Append : TFhirOperationDefinition;

    // Add an already existing FhirOperationDefinition to the end of the list.
    procedure AddItem(value : TFhirOperationDefinition); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirOperationDefinition) : Integer;

    // Insert FhirOperationDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirOperationDefinition;

    // Insert an existing FhirOperationDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirOperationDefinition);

    // Get the iIndexth FhirOperationDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirOperationDefinition);

    // The number of items in the collection
    function Item(index : Integer) : TFhirOperationDefinition;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirOperationDefinitions[index : Integer] : TFhirOperationDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_OPERATIONDEFINITION}

{$IFDEF FHIR_PLANDEFINITION}

  // Goals that describe what the activities within the plan are intended to achieve. For example, weight loss, restoring an activity of daily living, obtaining herd immunity via immunization, meeting a process improvement objective, etc.
  TFhirPlanDefinitionGoal = class (TFhirBackboneElement)
  protected
    FCategory : TFhirCodeableConcept;
    FDescription : TFhirCodeableConcept;
    FPriority : TFhirCodeableConcept;
    FStart : TFhirCodeableConcept;
    FaddressesList : TFhirCodeableConceptList;
    FdocumentationList : TFhirRelatedArtifactList;
    FtargetList : TFhirPlanDefinitionGoalTargetList;
    Procedure SetCategory(value : TFhirCodeableConcept);
    Procedure SetDescription(value : TFhirCodeableConcept);
    Procedure SetPriority(value : TFhirCodeableConcept);
    Procedure SetStart(value : TFhirCodeableConcept);
    function GetAddressesList : TFhirCodeableConceptList;
    function GetHasAddressesList : Boolean;
    function GetDocumentationList : TFhirRelatedArtifactList;
    function GetHasDocumentationList : Boolean;
    function GetTargetList : TFhirPlanDefinitionGoalTargetList;
    function GetHasTargetList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPlanDefinitionGoal; overload;
    function Clone : TFhirPlanDefinitionGoal; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Indicates a category the goal falls within. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Indicates a category the goal falls within.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to Human-readable and/or coded description of a specific desired objective of care, such as "control blood pressure" or "negotiate an obstacle course" or "dance with child at wedding". (defined for API consistency)
    property description : TFhirCodeableConcept read FDescription write SetDescription;
    // Human-readable and/or coded description of a specific desired objective of care, such as "control blood pressure" or "negotiate an obstacle course" or "dance with child at wedding".
    property descriptionElement : TFhirCodeableConcept read FDescription write SetDescription;

    // Typed access to Identifies the expected level of importance associated with reaching/sustaining the defined goal. (defined for API consistency)
    property priority : TFhirCodeableConcept read FPriority write SetPriority;
    // Identifies the expected level of importance associated with reaching/sustaining the defined goal.
    property priorityElement : TFhirCodeableConcept read FPriority write SetPriority;

    // Typed access to The event after which the goal should begin being pursued. (defined for API consistency)
    property start : TFhirCodeableConcept read FStart write SetStart;
    // The event after which the goal should begin being pursued.
    property startElement : TFhirCodeableConcept read FStart write SetStart;

    // Identifies problems, conditions, issues, or concerns the goal is intended to address.
    property addressesList : TFhirCodeableConceptList read GetAddressesList;
    property hasAddressesList : boolean read GetHasAddressesList;

    // Didactic or other informational resources associated with the goal that provide further supporting information about the goal. Information resources can include inline text commentary and links to web resources.
    property documentationList : TFhirRelatedArtifactList read GetDocumentationList;
    property hasDocumentationList : boolean read GetHasDocumentationList;

    // Indicates what should be done and within what timeframe.
    property targetList : TFhirPlanDefinitionGoalTargetList read GetTargetList;
    property hasTargetList : boolean read GetHasTargetList;

  end;

  TFhirPlanDefinitionGoalListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPlanDefinitionGoalList;
    function GetCurrent : TFhirPlanDefinitionGoal;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPlanDefinitionGoalList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPlanDefinitionGoal read GetCurrent;
  end;

  TFhirPlanDefinitionGoalList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirPlanDefinitionGoal;
    procedure SetItemN(index : Integer; value : TFhirPlanDefinitionGoal);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirPlanDefinitionGoalList; Overload;
    function Clone : TFhirPlanDefinitionGoalList; Overload;
    function GetEnumerator : TFhirPlanDefinitionGoalListEnumerator;

    //  Add a FhirPlanDefinitionGoal to the end of the list.
    function Append : TFhirPlanDefinitionGoal;

    // Add an already existing FhirPlanDefinitionGoal to the end of the list.
    procedure AddItem(value : TFhirPlanDefinitionGoal); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPlanDefinitionGoal) : Integer;

    // Insert FhirPlanDefinitionGoal before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPlanDefinitionGoal;

    // Insert an existing FhirPlanDefinitionGoal before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPlanDefinitionGoal);

    // Get the iIndexth FhirPlanDefinitionGoal. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPlanDefinitionGoal);

    // The number of items in the collection
    function Item(index : Integer) : TFhirPlanDefinitionGoal;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirPlanDefinitionGoals[index : Integer] : TFhirPlanDefinitionGoal read GetItemN write SetItemN; default;
  End;

  // Indicates what should be done and within what timeframe.
  TFhirPlanDefinitionGoalTarget = class (TFhirBackboneElement)
  protected
    FMeasure : TFhirCodeableConcept;
    FDetail : TFhirType;
    FDue : TFhirDuration;
    Procedure SetMeasure(value : TFhirCodeableConcept);
    Procedure SetDetail(value : TFhirType);
    Procedure SetDue(value : TFhirDuration);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPlanDefinitionGoalTarget; overload;
    function Clone : TFhirPlanDefinitionGoalTarget; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The parameter whose value is to be tracked, e.g. body weigth, blood pressure, or hemoglobin A1c level. (defined for API consistency)
    property measure : TFhirCodeableConcept read FMeasure write SetMeasure;
    // The parameter whose value is to be tracked, e.g. body weigth, blood pressure, or hemoglobin A1c level.
    property measureElement : TFhirCodeableConcept read FMeasure write SetMeasure;

    // Typed access to The target value of the measure to be achieved to signify fulfillment of the goal, e.g. 150 pounds or 7.0%. Either the high or low or both values of the range can be specified. Whan a low value is missing, it indicates that the goal is achieved at any value at or below the high value. Similarly, if the high value is missing, it indicates that the goal is achieved at any value at or above the low value. (defined for API consistency)
    property detail : TFhirType read FDetail write SetDetail;
    // The target value of the measure to be achieved to signify fulfillment of the goal, e.g. 150 pounds or 7.0%. Either the high or low or both values of the range can be specified. Whan a low value is missing, it indicates that the goal is achieved at any value at or below the high value. Similarly, if the high value is missing, it indicates that the goal is achieved at any value at or above the low value.
    property detailElement : TFhirType read FDetail write SetDetail;

    // Typed access to Indicates the timeframe after the start of the goal in which the goal should be met. (defined for API consistency)
    property due : TFhirDuration read FDue write SetDue;
    // Indicates the timeframe after the start of the goal in which the goal should be met.
    property dueElement : TFhirDuration read FDue write SetDue;

  end;

  TFhirPlanDefinitionGoalTargetListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPlanDefinitionGoalTargetList;
    function GetCurrent : TFhirPlanDefinitionGoalTarget;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPlanDefinitionGoalTargetList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPlanDefinitionGoalTarget read GetCurrent;
  end;

  TFhirPlanDefinitionGoalTargetList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirPlanDefinitionGoalTarget;
    procedure SetItemN(index : Integer; value : TFhirPlanDefinitionGoalTarget);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirPlanDefinitionGoalTargetList; Overload;
    function Clone : TFhirPlanDefinitionGoalTargetList; Overload;
    function GetEnumerator : TFhirPlanDefinitionGoalTargetListEnumerator;

    //  Add a FhirPlanDefinitionGoalTarget to the end of the list.
    function Append : TFhirPlanDefinitionGoalTarget;

    // Add an already existing FhirPlanDefinitionGoalTarget to the end of the list.
    procedure AddItem(value : TFhirPlanDefinitionGoalTarget); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPlanDefinitionGoalTarget) : Integer;

    // Insert FhirPlanDefinitionGoalTarget before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPlanDefinitionGoalTarget;

    // Insert an existing FhirPlanDefinitionGoalTarget before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPlanDefinitionGoalTarget);

    // Get the iIndexth FhirPlanDefinitionGoalTarget. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPlanDefinitionGoalTarget);

    // The number of items in the collection
    function Item(index : Integer) : TFhirPlanDefinitionGoalTarget;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirPlanDefinitionGoalTargets[index : Integer] : TFhirPlanDefinitionGoalTarget read GetItemN write SetItemN; default;
  End;

  // An action to be taken as part of the plan.
  TFhirPlanDefinitionAction = class (TFhirBackboneElement)
  protected
    FLabel_ : TFhirString;
    FTitle : TFhirString;
    FDescription : TFhirString;
    FTextEquivalent : TFhirString;
    FcodeList : TFhirCodeableConceptList;
    FreasonList : TFhirCodeableConceptList;
    FdocumentationList : TFhirRelatedArtifactList;
    FgoalIdList : TFhirIdList;
    FtriggerDefinitionList : TFhirTriggerDefinitionList;
    FconditionList : TFhirPlanDefinitionActionConditionList;
    FinputList : TFhirDataRequirementList;
    FoutputList : TFhirDataRequirementList;
    FrelatedActionList : TFhirPlanDefinitionActionRelatedActionList;
    FTiming : TFhirType;
    FparticipantList : TFhirPlanDefinitionActionParticipantList;
    FType_ : TFhirCoding;
    FGroupingBehavior : TFhirEnum;
    FSelectionBehavior : TFhirEnum;
    FRequiredBehavior : TFhirEnum;
    FPrecheckBehavior : TFhirEnum;
    FCardinalityBehavior : TFhirEnum;
    FDefinition : TFhirReference{Resource};
    FTransform : TFhirReference{TFhirStructureMap};
    FdynamicValueList : TFhirPlanDefinitionActionDynamicValueList;
    FactionList : TFhirPlanDefinitionActionList;
    Procedure SetLabel_(value : TFhirString);
    Function GetLabel_ST : String;
    Procedure SetLabel_ST(value : String);
    Procedure SetTitle(value : TFhirString);
    Function GetTitleST : String;
    Procedure SetTitleST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetTextEquivalent(value : TFhirString);
    Function GetTextEquivalentST : String;
    Procedure SetTextEquivalentST(value : String);
    function GetCodeList : TFhirCodeableConceptList;
    function GetHasCodeList : Boolean;
    function GetReasonList : TFhirCodeableConceptList;
    function GetHasReasonList : Boolean;
    function GetDocumentationList : TFhirRelatedArtifactList;
    function GetHasDocumentationList : Boolean;
    function GetGoalIdList : TFhirIdList;
    function GetHasGoalIdList : Boolean;
    function GetTriggerDefinitionList : TFhirTriggerDefinitionList;
    function GetHasTriggerDefinitionList : Boolean;
    function GetConditionList : TFhirPlanDefinitionActionConditionList;
    function GetHasConditionList : Boolean;
    function GetInputList : TFhirDataRequirementList;
    function GetHasInputList : Boolean;
    function GetOutputList : TFhirDataRequirementList;
    function GetHasOutputList : Boolean;
    function GetRelatedActionList : TFhirPlanDefinitionActionRelatedActionList;
    function GetHasRelatedActionList : Boolean;
    Procedure SetTiming(value : TFhirType);
    function GetParticipantList : TFhirPlanDefinitionActionParticipantList;
    function GetHasParticipantList : Boolean;
    Procedure SetType_(value : TFhirCoding);
    Procedure SetGroupingBehavior(value : TFhirEnum);
    Function GetGroupingBehaviorST : TFhirActionGroupingBehaviorEnum;
    Procedure SetGroupingBehaviorST(value : TFhirActionGroupingBehaviorEnum);
    Procedure SetSelectionBehavior(value : TFhirEnum);
    Function GetSelectionBehaviorST : TFhirActionSelectionBehaviorEnum;
    Procedure SetSelectionBehaviorST(value : TFhirActionSelectionBehaviorEnum);
    Procedure SetRequiredBehavior(value : TFhirEnum);
    Function GetRequiredBehaviorST : TFhirActionRequiredBehaviorEnum;
    Procedure SetRequiredBehaviorST(value : TFhirActionRequiredBehaviorEnum);
    Procedure SetPrecheckBehavior(value : TFhirEnum);
    Function GetPrecheckBehaviorST : TFhirActionPrecheckBehaviorEnum;
    Procedure SetPrecheckBehaviorST(value : TFhirActionPrecheckBehaviorEnum);
    Procedure SetCardinalityBehavior(value : TFhirEnum);
    Function GetCardinalityBehaviorST : TFhirActionCardinalityBehaviorEnum;
    Procedure SetCardinalityBehaviorST(value : TFhirActionCardinalityBehaviorEnum);
    Procedure SetDefinition(value : TFhirReference{Resource});
    Procedure SetTransform(value : TFhirReference{TFhirStructureMap});
    function GetDynamicValueList : TFhirPlanDefinitionActionDynamicValueList;
    function GetHasDynamicValueList : Boolean;
    function GetActionList : TFhirPlanDefinitionActionList;
    function GetHasActionList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPlanDefinitionAction; overload;
    function Clone : TFhirPlanDefinitionAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A user-visible label for the action.
    property label_ : String read GetLabel_ST write SetLabel_ST;
    // A user-visible label for the action.
    property label_Element : TFhirString read FLabel_ write SetLabel_;

    // Typed access to The title of the action displayed to a user.
    property title : String read GetTitleST write SetTitleST;
    // The title of the action displayed to a user.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to A short description of the action used to provide a summary to display to the user.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A short description of the action used to provide a summary to display to the user.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to A text equivalent of the action to be performed. This provides a human-interpretable description of the action when the definition is consumed by a system that may not be capable of interpreting it dynamically.
    property textEquivalent : String read GetTextEquivalentST write SetTextEquivalentST;
    // A text equivalent of the action to be performed. This provides a human-interpretable description of the action when the definition is consumed by a system that may not be capable of interpreting it dynamically.
    property textEquivalentElement : TFhirString read FTextEquivalent write SetTextEquivalent;

    // A code that provides meaning for the action or action group. For example, a section may have a LOINC code for a the section of a documentation template.
    property codeList : TFhirCodeableConceptList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // A description of why this action is necessary or appropriate.
    property reasonList : TFhirCodeableConceptList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // Didactic or other informational resources associated with the action that can be provided to the CDS recipient. Information resources can include inline text commentary and links to web resources.
    property documentationList : TFhirRelatedArtifactList read GetDocumentationList;
    property hasDocumentationList : boolean read GetHasDocumentationList;

    // Identifies goals that this action supports. The reference must be to a goal element defined within this plan definition.
    property goalIdList : TFhirIdList read GetGoalIdList;
    property hasGoalIdList : boolean read GetHasGoalIdList;

    // A description of when the action should be triggered.
    property triggerDefinitionList : TFhirTriggerDefinitionList read GetTriggerDefinitionList;
    property hasTriggerDefinitionList : boolean read GetHasTriggerDefinitionList;

    // An expression that describes applicability criteria, or start/stop conditions for the action.
    property conditionList : TFhirPlanDefinitionActionConditionList read GetConditionList;
    property hasConditionList : boolean read GetHasConditionList;

    // Defines input data requirements for the action.
    property inputList : TFhirDataRequirementList read GetInputList;
    property hasInputList : boolean read GetHasInputList;

    // Defines the outputs of the action, if any.
    property outputList : TFhirDataRequirementList read GetOutputList;
    property hasOutputList : boolean read GetHasOutputList;

    // A relationship to another action such as "before" or "30-60 minutes after start of".
    property relatedActionList : TFhirPlanDefinitionActionRelatedActionList read GetRelatedActionList;
    property hasRelatedActionList : boolean read GetHasRelatedActionList;

    // Typed access to An optional value describing when the action should be performed. (defined for API consistency)
    property timing : TFhirType read FTiming write SetTiming;
    // An optional value describing when the action should be performed.
    property timingElement : TFhirType read FTiming write SetTiming;

    // Indicates who should participate in performing the action described.
    property participantList : TFhirPlanDefinitionActionParticipantList read GetParticipantList;
    property hasParticipantList : boolean read GetHasParticipantList;

    // Typed access to The type of action to perform (create, update, remove). (defined for API consistency)
    property type_ : TFhirCoding read FType_ write SetType_;
    // The type of action to perform (create, update, remove).
    property type_Element : TFhirCoding read FType_ write SetType_;

    // Defines the grouping behavior for the action and its children.
    property groupingBehavior : TFhirActionGroupingBehaviorEnum read GetGroupingBehaviorST write SetGroupingBehaviorST;
    property groupingBehaviorElement : TFhirEnum read FGroupingBehavior write SetGroupingBehavior;

    // Defines the selection behavior for the action and its children.
    property selectionBehavior : TFhirActionSelectionBehaviorEnum read GetSelectionBehaviorST write SetSelectionBehaviorST;
    property selectionBehaviorElement : TFhirEnum read FSelectionBehavior write SetSelectionBehavior;

    // Defines the requiredness behavior for the action.
    property requiredBehavior : TFhirActionRequiredBehaviorEnum read GetRequiredBehaviorST write SetRequiredBehaviorST;
    property requiredBehaviorElement : TFhirEnum read FRequiredBehavior write SetRequiredBehavior;

    // Defines whether the action should usually be preselected.
    property precheckBehavior : TFhirActionPrecheckBehaviorEnum read GetPrecheckBehaviorST write SetPrecheckBehaviorST;
    property precheckBehaviorElement : TFhirEnum read FPrecheckBehavior write SetPrecheckBehavior;

    // Defines whether the action can be selected multiple times.
    property cardinalityBehavior : TFhirActionCardinalityBehaviorEnum read GetCardinalityBehaviorST write SetCardinalityBehaviorST;
    property cardinalityBehaviorElement : TFhirEnum read FCardinalityBehavior write SetCardinalityBehavior;

    // Typed access to A reference to an ActivityDefinition that describes the action to be taken in detail, or a PlanDefinition that describes a series of actions to be taken. (defined for API consistency)
    property definition : TFhirReference{Resource} read FDefinition write SetDefinition;
    // A reference to an ActivityDefinition that describes the action to be taken in detail, or a PlanDefinition that describes a series of actions to be taken.
    property definitionElement : TFhirReference{Resource} read FDefinition write SetDefinition;

    // Typed access to A reference to a StructureMap resource that defines a transform that can be executed to produce the intent resource using the ActivityDefinition instance as the input. (defined for API consistency)
    property transform : TFhirReference{TFhirStructureMap} read FTransform write SetTransform;
    // A reference to a StructureMap resource that defines a transform that can be executed to produce the intent resource using the ActivityDefinition instance as the input.
    property transformElement : TFhirReference{TFhirStructureMap} read FTransform write SetTransform;

    // Customizations that should be applied to the statically defined resource. For example, if the dosage of a medication must be computed based on the patient's weight, a customization would be used to specify an expression that calculated the weight, and the path on the resource that would contain the result.
    property dynamicValueList : TFhirPlanDefinitionActionDynamicValueList read GetDynamicValueList;
    property hasDynamicValueList : boolean read GetHasDynamicValueList;

    // Sub actions that are contained within the action. The behavior of this action determines the functionality of the sub-actions. For example, a selection behavior of at-most-one indicates that of the sub-actions, at most one may be chosen as part of realizing the action definition.
    property actionList : TFhirPlanDefinitionActionList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

  end;

  TFhirPlanDefinitionActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPlanDefinitionActionList;
    function GetCurrent : TFhirPlanDefinitionAction;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPlanDefinitionActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPlanDefinitionAction read GetCurrent;
  end;

  TFhirPlanDefinitionActionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirPlanDefinitionAction;
    procedure SetItemN(index : Integer; value : TFhirPlanDefinitionAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirPlanDefinitionActionList; Overload;
    function Clone : TFhirPlanDefinitionActionList; Overload;
    function GetEnumerator : TFhirPlanDefinitionActionListEnumerator;

    //  Add a FhirPlanDefinitionAction to the end of the list.
    function Append : TFhirPlanDefinitionAction;

    // Add an already existing FhirPlanDefinitionAction to the end of the list.
    procedure AddItem(value : TFhirPlanDefinitionAction); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPlanDefinitionAction) : Integer;

    // Insert FhirPlanDefinitionAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPlanDefinitionAction;

    // Insert an existing FhirPlanDefinitionAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPlanDefinitionAction);

    // Get the iIndexth FhirPlanDefinitionAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPlanDefinitionAction);

    // The number of items in the collection
    function Item(index : Integer) : TFhirPlanDefinitionAction;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirPlanDefinitionActions[index : Integer] : TFhirPlanDefinitionAction read GetItemN write SetItemN; default;
  End;

  // An expression that describes applicability criteria, or start/stop conditions for the action.
  TFhirPlanDefinitionActionCondition = class (TFhirBackboneElement)
  protected
    FKind : TFhirEnum;
    FDescription : TFhirString;
    FLanguage : TFhirString;
    FExpression : TFhirString;
    Procedure SetKind(value : TFhirEnum);
    Function GetKindST : TFhirActionConditionKindEnum;
    Procedure SetKindST(value : TFhirActionConditionKindEnum);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetLanguage(value : TFhirString);
    Function GetLanguageST : String;
    Procedure SetLanguageST(value : String);
    Procedure SetExpression(value : TFhirString);
    Function GetExpressionST : String;
    Procedure SetExpressionST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPlanDefinitionActionCondition; overload;
    function Clone : TFhirPlanDefinitionActionCondition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The kind of condition.
    property kind : TFhirActionConditionKindEnum read GetKindST write SetKindST;
    property kindElement : TFhirEnum read FKind write SetKind;

    // Typed access to A brief, natural language description of the condition that effectively communicates the intended semantics.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A brief, natural language description of the condition that effectively communicates the intended semantics.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to The media type of the language for the expression.
    property language : String read GetLanguageST write SetLanguageST;
    // The media type of the language for the expression.
    property languageElement : TFhirString read FLanguage write SetLanguage;

    // Typed access to An expression that returns true or false, indicating whether or not the condition is satisfied.
    property expression : String read GetExpressionST write SetExpressionST;
    // An expression that returns true or false, indicating whether or not the condition is satisfied.
    property expressionElement : TFhirString read FExpression write SetExpression;

  end;

  TFhirPlanDefinitionActionConditionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPlanDefinitionActionConditionList;
    function GetCurrent : TFhirPlanDefinitionActionCondition;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPlanDefinitionActionConditionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPlanDefinitionActionCondition read GetCurrent;
  end;

  TFhirPlanDefinitionActionConditionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirPlanDefinitionActionCondition;
    procedure SetItemN(index : Integer; value : TFhirPlanDefinitionActionCondition);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirPlanDefinitionActionConditionList; Overload;
    function Clone : TFhirPlanDefinitionActionConditionList; Overload;
    function GetEnumerator : TFhirPlanDefinitionActionConditionListEnumerator;

    //  Add a FhirPlanDefinitionActionCondition to the end of the list.
    function Append : TFhirPlanDefinitionActionCondition;

    // Add an already existing FhirPlanDefinitionActionCondition to the end of the list.
    procedure AddItem(value : TFhirPlanDefinitionActionCondition); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPlanDefinitionActionCondition) : Integer;

    // Insert FhirPlanDefinitionActionCondition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPlanDefinitionActionCondition;

    // Insert an existing FhirPlanDefinitionActionCondition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPlanDefinitionActionCondition);

    // Get the iIndexth FhirPlanDefinitionActionCondition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPlanDefinitionActionCondition);

    // The number of items in the collection
    function Item(index : Integer) : TFhirPlanDefinitionActionCondition;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirPlanDefinitionActionConditions[index : Integer] : TFhirPlanDefinitionActionCondition read GetItemN write SetItemN; default;
  End;

  // A relationship to another action such as "before" or "30-60 minutes after start of".
  TFhirPlanDefinitionActionRelatedAction = class (TFhirBackboneElement)
  protected
    FActionId : TFhirId;
    FRelationship : TFhirEnum;
    FOffset : TFhirType;
    Procedure SetActionId(value : TFhirId);
    Function GetActionIdST : String;
    Procedure SetActionIdST(value : String);
    Procedure SetRelationship(value : TFhirEnum);
    Function GetRelationshipST : TFhirActionRelationshipTypeEnum;
    Procedure SetRelationshipST(value : TFhirActionRelationshipTypeEnum);
    Procedure SetOffset(value : TFhirType);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPlanDefinitionActionRelatedAction; overload;
    function Clone : TFhirPlanDefinitionActionRelatedAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The element id of the related action.
    property actionId : String read GetActionIdST write SetActionIdST;
    // The element id of the related action.
    property actionIdElement : TFhirId read FActionId write SetActionId;

    // The relationship of this action to the related action.
    property relationship : TFhirActionRelationshipTypeEnum read GetRelationshipST write SetRelationshipST;
    property relationshipElement : TFhirEnum read FRelationship write SetRelationship;

    // Typed access to A duration or range of durations to apply to the relationship. For example, 30-60 minutes before. (defined for API consistency)
    property offset : TFhirType read FOffset write SetOffset;
    // A duration or range of durations to apply to the relationship. For example, 30-60 minutes before.
    property offsetElement : TFhirType read FOffset write SetOffset;

  end;

  TFhirPlanDefinitionActionRelatedActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPlanDefinitionActionRelatedActionList;
    function GetCurrent : TFhirPlanDefinitionActionRelatedAction;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPlanDefinitionActionRelatedActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPlanDefinitionActionRelatedAction read GetCurrent;
  end;

  TFhirPlanDefinitionActionRelatedActionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirPlanDefinitionActionRelatedAction;
    procedure SetItemN(index : Integer; value : TFhirPlanDefinitionActionRelatedAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirPlanDefinitionActionRelatedActionList; Overload;
    function Clone : TFhirPlanDefinitionActionRelatedActionList; Overload;
    function GetEnumerator : TFhirPlanDefinitionActionRelatedActionListEnumerator;

    //  Add a FhirPlanDefinitionActionRelatedAction to the end of the list.
    function Append : TFhirPlanDefinitionActionRelatedAction;

    // Add an already existing FhirPlanDefinitionActionRelatedAction to the end of the list.
    procedure AddItem(value : TFhirPlanDefinitionActionRelatedAction); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPlanDefinitionActionRelatedAction) : Integer;

    // Insert FhirPlanDefinitionActionRelatedAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPlanDefinitionActionRelatedAction;

    // Insert an existing FhirPlanDefinitionActionRelatedAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPlanDefinitionActionRelatedAction);

    // Get the iIndexth FhirPlanDefinitionActionRelatedAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPlanDefinitionActionRelatedAction);

    // The number of items in the collection
    function Item(index : Integer) : TFhirPlanDefinitionActionRelatedAction;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirPlanDefinitionActionRelatedActions[index : Integer] : TFhirPlanDefinitionActionRelatedAction read GetItemN write SetItemN; default;
  End;

  // Indicates who should participate in performing the action described.
  TFhirPlanDefinitionActionParticipant = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FRole : TFhirCodeableConcept;
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirActionParticipantTypeEnum;
    Procedure SetType_ST(value : TFhirActionParticipantTypeEnum);
    Procedure SetRole(value : TFhirCodeableConcept);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPlanDefinitionActionParticipant; overload;
    function Clone : TFhirPlanDefinitionActionParticipant; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The type of participant in the action.
    property type_ : TFhirActionParticipantTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The role the participant should play in performing the described action. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // The role the participant should play in performing the described action.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

  end;

  TFhirPlanDefinitionActionParticipantListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPlanDefinitionActionParticipantList;
    function GetCurrent : TFhirPlanDefinitionActionParticipant;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPlanDefinitionActionParticipantList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPlanDefinitionActionParticipant read GetCurrent;
  end;

  TFhirPlanDefinitionActionParticipantList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirPlanDefinitionActionParticipant;
    procedure SetItemN(index : Integer; value : TFhirPlanDefinitionActionParticipant);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirPlanDefinitionActionParticipantList; Overload;
    function Clone : TFhirPlanDefinitionActionParticipantList; Overload;
    function GetEnumerator : TFhirPlanDefinitionActionParticipantListEnumerator;

    //  Add a FhirPlanDefinitionActionParticipant to the end of the list.
    function Append : TFhirPlanDefinitionActionParticipant;

    // Add an already existing FhirPlanDefinitionActionParticipant to the end of the list.
    procedure AddItem(value : TFhirPlanDefinitionActionParticipant); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPlanDefinitionActionParticipant) : Integer;

    // Insert FhirPlanDefinitionActionParticipant before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPlanDefinitionActionParticipant;

    // Insert an existing FhirPlanDefinitionActionParticipant before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPlanDefinitionActionParticipant);

    // Get the iIndexth FhirPlanDefinitionActionParticipant. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPlanDefinitionActionParticipant);

    // The number of items in the collection
    function Item(index : Integer) : TFhirPlanDefinitionActionParticipant;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirPlanDefinitionActionParticipants[index : Integer] : TFhirPlanDefinitionActionParticipant read GetItemN write SetItemN; default;
  End;

  // Customizations that should be applied to the statically defined resource. For example, if the dosage of a medication must be computed based on the patient's weight, a customization would be used to specify an expression that calculated the weight, and the path on the resource that would contain the result.
  TFhirPlanDefinitionActionDynamicValue = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FPath : TFhirString;
    FLanguage : TFhirString;
    FExpression : TFhirString;
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetPath(value : TFhirString);
    Function GetPathST : String;
    Procedure SetPathST(value : String);
    Procedure SetLanguage(value : TFhirString);
    Function GetLanguageST : String;
    Procedure SetLanguageST(value : String);
    Procedure SetExpression(value : TFhirString);
    Function GetExpressionST : String;
    Procedure SetExpressionST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPlanDefinitionActionDynamicValue; overload;
    function Clone : TFhirPlanDefinitionActionDynamicValue; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A brief, natural language description of the intended semantics of the dynamic value.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A brief, natural language description of the intended semantics of the dynamic value.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to The path to the element to be customized. This is the path on the resource that will hold the result of the calculation defined by the expression.
    property path : String read GetPathST write SetPathST;
    // The path to the element to be customized. This is the path on the resource that will hold the result of the calculation defined by the expression.
    property pathElement : TFhirString read FPath write SetPath;

    // Typed access to The media type of the language for the expression.
    property language : String read GetLanguageST write SetLanguageST;
    // The media type of the language for the expression.
    property languageElement : TFhirString read FLanguage write SetLanguage;

    // Typed access to An expression specifying the value of the customized element.
    property expression : String read GetExpressionST write SetExpressionST;
    // An expression specifying the value of the customized element.
    property expressionElement : TFhirString read FExpression write SetExpression;

  end;

  TFhirPlanDefinitionActionDynamicValueListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPlanDefinitionActionDynamicValueList;
    function GetCurrent : TFhirPlanDefinitionActionDynamicValue;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPlanDefinitionActionDynamicValueList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPlanDefinitionActionDynamicValue read GetCurrent;
  end;

  TFhirPlanDefinitionActionDynamicValueList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirPlanDefinitionActionDynamicValue;
    procedure SetItemN(index : Integer; value : TFhirPlanDefinitionActionDynamicValue);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirPlanDefinitionActionDynamicValueList; Overload;
    function Clone : TFhirPlanDefinitionActionDynamicValueList; Overload;
    function GetEnumerator : TFhirPlanDefinitionActionDynamicValueListEnumerator;

    //  Add a FhirPlanDefinitionActionDynamicValue to the end of the list.
    function Append : TFhirPlanDefinitionActionDynamicValue;

    // Add an already existing FhirPlanDefinitionActionDynamicValue to the end of the list.
    procedure AddItem(value : TFhirPlanDefinitionActionDynamicValue); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPlanDefinitionActionDynamicValue) : Integer;

    // Insert FhirPlanDefinitionActionDynamicValue before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPlanDefinitionActionDynamicValue;

    // Insert an existing FhirPlanDefinitionActionDynamicValue before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPlanDefinitionActionDynamicValue);

    // Get the iIndexth FhirPlanDefinitionActionDynamicValue. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPlanDefinitionActionDynamicValue);

    // The number of items in the collection
    function Item(index : Integer) : TFhirPlanDefinitionActionDynamicValue;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirPlanDefinitionActionDynamicValues[index : Integer] : TFhirPlanDefinitionActionDynamicValue read GetItemN write SetItemN; default;
  End;

  // This resource allows for the definition of various types of plans as a sharable, consumable, and executable artifact. The resource is general enough to support the description of a broad range of clinical artifacts such as clinical decision support rules, order sets and protocols.
  TFhirPlanDefinition = class (TFhirMetadataResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FType_ : TFhirCodeableConcept;
    FPurpose : TFhirMarkdown;
    FUsage : TFhirString;
    FApprovalDate : TFhirDate;
    FLastReviewDate : TFhirDate;
    FEffectivePeriod : TFhirPeriod;
    FtopicList : TFhirCodeableConceptList;
    FcontributorList : TFhirContributorList;
    FCopyright : TFhirMarkdown;
    FrelatedArtifactList : TFhirRelatedArtifactList;
    Flibrary_List : TFhirReferenceList{TFhirLibrary};
    FgoalList : TFhirPlanDefinitionGoalList;
    FactionList : TFhirPlanDefinitionActionList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetType_(value : TFhirCodeableConcept);
    Procedure SetPurpose(value : TFhirMarkdown);
    Function GetPurposeST : String;
    Procedure SetPurposeST(value : String);
    Procedure SetUsage(value : TFhirString);
    Function GetUsageST : String;
    Procedure SetUsageST(value : String);
    Procedure SetApprovalDate(value : TFhirDate);
    Function GetApprovalDateST : TFslDateTime;
    Procedure SetApprovalDateST(value : TFslDateTime);
    Procedure SetLastReviewDate(value : TFhirDate);
    Function GetLastReviewDateST : TFslDateTime;
    Procedure SetLastReviewDateST(value : TFslDateTime);
    Procedure SetEffectivePeriod(value : TFhirPeriod);
    function GetTopicList : TFhirCodeableConceptList;
    function GetHasTopicList : Boolean;
    function GetContributorList : TFhirContributorList;
    function GetHasContributorList : Boolean;
    Procedure SetCopyright(value : TFhirMarkdown);
    Function GetCopyrightST : String;
    Procedure SetCopyrightST(value : String);
    function GetRelatedArtifactList : TFhirRelatedArtifactList;
    function GetHasRelatedArtifactList : Boolean;
    function GetLibrary_List : TFhirReferenceList{TFhirLibrary};
    function GetHasLibrary_List : Boolean;
    function GetGoalList : TFhirPlanDefinitionGoalList;
    function GetHasGoalList : Boolean;
    function GetActionList : TFhirPlanDefinitionActionList;
    function GetHasActionList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPlanDefinition; overload;
    function Clone : TFhirPlanDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this plan definition when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this plan definition is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the plan definition. For more information see [Technical and Business Versions](resource.html#versions).
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this plan definition when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this plan definition is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the plan definition. For more information see [Technical and Business Versions](resource.html#versions).
    property urlElement : TFhirUri read FUrl write SetUrl;

    // A formal identifier that is used to identify this plan definition when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the plan definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the plan definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. To provide a version consistent with the Decision Support Service specification, use the format Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge assets, refer to the Decision Support Service specification. Note that a version is required for non-experimental active artifacts.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the plan definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the plan definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. To provide a version consistent with the Decision Support Service specification, use the format Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge assets, refer to the Decision Support Service specification. Note that a version is required for non-experimental active artifacts.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the plan definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the plan definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the plan definition.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the plan definition.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to The type of asset the plan definition represents, e.g. an order set, protocol, or event-condition-action rule. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of asset the plan definition represents, e.g. an order set, protocol, or event-condition-action rule.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // The status of this plan definition. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A boolean value to indicate that this plan definition is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A boolean value to indicate that this plan definition is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The date  (and optionally time) when the plan definition was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the plan definition changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the plan definition was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the plan definition changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the plan definition.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the plan definition.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Typed access to A free text natural language description of the plan definition from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the plan definition from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // Typed access to Explaination of why this plan definition is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explaination of why this plan definition is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Typed access to A detailed description of how the asset is used from a clinical perspective.
    property usage : String read GetUsageST write SetUsageST;
    // A detailed description of how the asset is used from a clinical perspective.
    property usageElement : TFhirString read FUsage write SetUsage;

    // Typed access to The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDate : TFslDateTime read GetApprovalDateST write SetApprovalDateST;
    // The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDateElement : TFhirDate read FApprovalDate write SetApprovalDate;

    // Typed access to The date on which the resource content was last reviewed. Review happens periodically after approval, but doesn't change the original approval date.
    property lastReviewDate : TFslDateTime read GetLastReviewDateST write SetLastReviewDateST;
    // The date on which the resource content was last reviewed. Review happens periodically after approval, but doesn't change the original approval date.
    property lastReviewDateElement : TFhirDate read FLastReviewDate write SetLastReviewDate;

    // Typed access to The period during which the plan definition content was or is planned to be in active use. (defined for API consistency)
    property effectivePeriod : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;
    // The period during which the plan definition content was or is planned to be in active use.
    property effectivePeriodElement : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These terms may be used to assist with indexing and searching for appropriate plan definition instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the plan definition is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Descriptive topics related to the content of the plan definition. Topics provide a high-level categorization of the definition that can be useful for filtering and searching.
    property topicList : TFhirCodeableConceptList read GetTopicList;
    property hasTopicList : boolean read GetHasTopicList;

    // A contributor to the content of the asset, including authors, editors, reviewers, and endorsers.
    property contributorList : TFhirContributorList read GetContributorList;
    property hasContributorList : boolean read GetHasContributorList;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A copyright statement relating to the plan definition and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the plan definition.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the plan definition and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the plan definition.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // Related artifacts such as additional documentation, justification, or bibliographic references.
    property relatedArtifactList : TFhirRelatedArtifactList read GetRelatedArtifactList;
    property hasRelatedArtifactList : boolean read GetHasRelatedArtifactList;

    // A reference to a Library resource containing any formal logic used by the plan definition.
    property library_List : TFhirReferenceList{TFhirLibrary} read GetLibrary_List;
    property hasLibrary_List : boolean read GetHasLibrary_List;

    // Goals that describe what the activities within the plan are intended to achieve. For example, weight loss, restoring an activity of daily living, obtaining herd immunity via immunization, meeting a process improvement objective, etc.
    property goalList : TFhirPlanDefinitionGoalList read GetGoalList;
    property hasGoalList : boolean read GetHasGoalList;

    // An action to be taken as part of the plan.
    property actionList : TFhirPlanDefinitionActionList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

  end;

  TFhirPlanDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPlanDefinitionList;
    function GetCurrent : TFhirPlanDefinition;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirPlanDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPlanDefinition read GetCurrent;
  end;

  TFhirPlanDefinitionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirPlanDefinition;
    procedure SetItemN(index : Integer; value : TFhirPlanDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirPlanDefinitionList; Overload;
    function Clone : TFhirPlanDefinitionList; Overload;
    function GetEnumerator : TFhirPlanDefinitionListEnumerator;

    //  Add a FhirPlanDefinition to the end of the list.
    function Append : TFhirPlanDefinition;

    // Add an already existing FhirPlanDefinition to the end of the list.
    procedure AddItem(value : TFhirPlanDefinition); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPlanDefinition) : Integer;

    // Insert FhirPlanDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPlanDefinition;

    // Insert an existing FhirPlanDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPlanDefinition);

    // Get the iIndexth FhirPlanDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPlanDefinition);

    // The number of items in the collection
    function Item(index : Integer) : TFhirPlanDefinition;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirPlanDefinitions[index : Integer] : TFhirPlanDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PLANDEFINITION}

{$IFDEF FHIR_QUESTIONNAIRE}

  // A particular question, question grouping or display text that is part of the questionnaire.
  TFhirQuestionnaireItem = class (TFhirBackboneElement)
  protected
    FLinkId : TFhirString;
    FDefinition : TFhirUri;
    FcodeList : TFhirCodingList;
    FPrefix : TFhirString;
    FText : TFhirString;
    FType_ : TFhirEnum;
    FenableWhenList : TFhirQuestionnaireItemEnableWhenList;
    FRequired : TFhirBoolean;
    FRepeats : TFhirBoolean;
    FReadOnly : TFhirBoolean;
    FMaxLength : TFhirInteger;
    FOptions : TFhirReference{TFhirValueSet};
    FoptionList : TFhirQuestionnaireItemOptionList;
    FInitial : TFhirType;
    FitemList : TFhirQuestionnaireItemList;
    Procedure SetLinkId(value : TFhirString);
    Function GetLinkIdST : String;
    Procedure SetLinkIdST(value : String);
    Procedure SetDefinition(value : TFhirUri);
    Function GetDefinitionST : String;
    Procedure SetDefinitionST(value : String);
    function GetCodeList : TFhirCodingList;
    function GetHasCodeList : Boolean;
    Procedure SetPrefix(value : TFhirString);
    Function GetPrefixST : String;
    Procedure SetPrefixST(value : String);
    Procedure SetText(value : TFhirString);
    Function GetTextST : String;
    Procedure SetTextST(value : String);
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirItemTypeEnum;
    Procedure SetType_ST(value : TFhirItemTypeEnum);
    function GetEnableWhenList : TFhirQuestionnaireItemEnableWhenList;
    function GetHasEnableWhenList : Boolean;
    Procedure SetRequired(value : TFhirBoolean);
    Function GetRequiredST : Boolean;
    Procedure SetRequiredST(value : Boolean);
    Procedure SetRepeats(value : TFhirBoolean);
    Function GetRepeatsST : Boolean;
    Procedure SetRepeatsST(value : Boolean);
    Procedure SetReadOnly(value : TFhirBoolean);
    Function GetReadOnlyST : Boolean;
    Procedure SetReadOnlyST(value : Boolean);
    Procedure SetMaxLength(value : TFhirInteger);
    Function GetMaxLengthST : String;
    Procedure SetMaxLengthST(value : String);
    Procedure SetOptions(value : TFhirReference{TFhirValueSet});
    function GetOptionList : TFhirQuestionnaireItemOptionList;
    function GetHasOptionList : Boolean;
    Procedure SetInitial(value : TFhirType);
    function GetItemList : TFhirQuestionnaireItemList;
    function GetHasItemList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirQuestionnaireItem; overload;
    function Clone : TFhirQuestionnaireItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An identifier that is unique within the Questionnaire allowing linkage to the equivalent item in a QuestionnaireResponse resource.
    property linkId : String read GetLinkIdST write SetLinkIdST;
    // An identifier that is unique within the Questionnaire allowing linkage to the equivalent item in a QuestionnaireResponse resource.
    property linkIdElement : TFhirString read FLinkId write SetLinkId;

    // Typed access to A reference to an [ElementDefinition](elementdefinition.html) that provides the details for the item. If a definition is provided, then the following element values can be inferred from the definition:   * code (ElementDefinition.code) * type (ElementDefinition.type) * required (ElementDefinition.min) * repeats (ElementDefinition.max) * maxLength (ElementDefinition.maxLength) * options (ElementDefinition.binding)  Any information provided in these elements on a Questionnaire Item overrides the information from the definition.
    property definition : String read GetDefinitionST write SetDefinitionST;
    // A reference to an [ElementDefinition](elementdefinition.html) that provides the details for the item. If a definition is provided, then the following element values can be inferred from the definition:   * code (ElementDefinition.code) * type (ElementDefinition.type) * required (ElementDefinition.min) * repeats (ElementDefinition.max) * maxLength (ElementDefinition.maxLength) * options (ElementDefinition.binding)  Any information provided in these elements on a Questionnaire Item overrides the information from the definition.
    property definitionElement : TFhirUri read FDefinition write SetDefinition;

    // A terminology code that corresponds to this group or question (e.g. a code from LOINC, which defines many questions and answers).
    property codeList : TFhirCodingList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // Typed access to A short label for a particular group, question or set of display text within the questionnaire used for reference by the individual completing the questionnaire.
    property prefix : String read GetPrefixST write SetPrefixST;
    // A short label for a particular group, question or set of display text within the questionnaire used for reference by the individual completing the questionnaire.
    property prefixElement : TFhirString read FPrefix write SetPrefix;

    // Typed access to The name of a section, the text of a question or text content for a display item.
    property text : String read GetTextST write SetTextST;
    // The name of a section, the text of a question or text content for a display item.
    property textElement : TFhirString read FText write SetText;

    // The type of questionnaire item this is - whether text for display, a grouping of other items or a particular type of data to be captured (string, integer, coded choice, etc.).
    property type_ : TFhirItemTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // A constraint indicating that this item should only be enabled (displayed/allow answers to be captured) when the specified condition is true.
    property enableWhenList : TFhirQuestionnaireItemEnableWhenList read GetEnableWhenList;
    property hasEnableWhenList : boolean read GetHasEnableWhenList;

    // Typed access to An indication, if true, that the item must be present in a "completed" QuestionnaireResponse.  If false, the item may be skipped when answering the questionnaire.
    property required : Boolean read GetRequiredST write SetRequiredST;
    // An indication, if true, that the item must be present in a "completed" QuestionnaireResponse.  If false, the item may be skipped when answering the questionnaire.
    property requiredElement : TFhirBoolean read FRequired write SetRequired;

    // Typed access to An indication, if true, that the item may occur multiple times in the response, collecting multiple answers answers for questions or multiple sets of answers for groups.
    property repeats : Boolean read GetRepeatsST write SetRepeatsST;
    // An indication, if true, that the item may occur multiple times in the response, collecting multiple answers answers for questions or multiple sets of answers for groups.
    property repeatsElement : TFhirBoolean read FRepeats write SetRepeats;

    // Typed access to An indication, when true, that the value cannot be changed by a human respondent to the Questionnaire.
    property readOnly : Boolean read GetReadOnlyST write SetReadOnlyST;
    // An indication, when true, that the value cannot be changed by a human respondent to the Questionnaire.
    property readOnlyElement : TFhirBoolean read FReadOnly write SetReadOnly;

    // Typed access to The maximum number of characters that are permitted in the answer to be considered a "valid" QuestionnaireResponse.
    property maxLength : String read GetMaxLengthST write SetMaxLengthST;
    // The maximum number of characters that are permitted in the answer to be considered a "valid" QuestionnaireResponse.
    property maxLengthElement : TFhirInteger read FMaxLength write SetMaxLength;

    // Typed access to A reference to a value set containing a list of codes representing permitted answers for a "choice" or "open-choice" question. (defined for API consistency)
    property options : TFhirReference{TFhirValueSet} read FOptions write SetOptions;
    // A reference to a value set containing a list of codes representing permitted answers for a "choice" or "open-choice" question.
    property optionsElement : TFhirReference{TFhirValueSet} read FOptions write SetOptions;

    // One of the permitted answers for a "choice" or "open-choice" question.
    property optionList : TFhirQuestionnaireItemOptionList read GetOptionList;
    property hasOptionList : boolean read GetHasOptionList;

    // Typed access to The value that should be defaulted when initially rendering the questionnaire for user input. (defined for API consistency)
    property initial : TFhirType read FInitial write SetInitial;
    // The value that should be defaulted when initially rendering the questionnaire for user input.
    property initialElement : TFhirType read FInitial write SetInitial;

    // Text, questions and other groups to be nested beneath a question or group.
    property itemList : TFhirQuestionnaireItemList read GetItemList;
    property hasItemList : boolean read GetHasItemList;

  end;

  TFhirQuestionnaireItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirQuestionnaireItemList;
    function GetCurrent : TFhirQuestionnaireItem;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirQuestionnaireItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirQuestionnaireItem read GetCurrent;
  end;

  TFhirQuestionnaireItemList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirQuestionnaireItem;
    procedure SetItemN(index : Integer; value : TFhirQuestionnaireItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirQuestionnaireItemList; Overload;
    function Clone : TFhirQuestionnaireItemList; Overload;
    function GetEnumerator : TFhirQuestionnaireItemListEnumerator;

    //  Add a FhirQuestionnaireItem to the end of the list.
    function Append : TFhirQuestionnaireItem;

    // Add an already existing FhirQuestionnaireItem to the end of the list.
    procedure AddItem(value : TFhirQuestionnaireItem); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirQuestionnaireItem) : Integer;

    // Insert FhirQuestionnaireItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirQuestionnaireItem;

    // Insert an existing FhirQuestionnaireItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirQuestionnaireItem);

    // Get the iIndexth FhirQuestionnaireItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirQuestionnaireItem);

    // The number of items in the collection
    function Item(index : Integer) : TFhirQuestionnaireItem;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirQuestionnaireItems[index : Integer] : TFhirQuestionnaireItem read GetItemN write SetItemN; default;
  End;

  // A constraint indicating that this item should only be enabled (displayed/allow answers to be captured) when the specified condition is true.
  TFhirQuestionnaireItemEnableWhen = class (TFhirBackboneElement)
  protected
    FQuestion : TFhirString;
    FHasAnswer : TFhirBoolean;
    FAnswer : TFhirType;
    Procedure SetQuestion(value : TFhirString);
    Function GetQuestionST : String;
    Procedure SetQuestionST(value : String);
    Procedure SetHasAnswer(value : TFhirBoolean);
    Function GetHasAnswerST : Boolean;
    Procedure SetHasAnswerST(value : Boolean);
    Procedure SetAnswer(value : TFhirType);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirQuestionnaireItemEnableWhen; overload;
    function Clone : TFhirQuestionnaireItemEnableWhen; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The linkId for the question whose answer (or lack of answer) governs whether this item is enabled.
    property question : String read GetQuestionST write SetQuestionST;
    // The linkId for the question whose answer (or lack of answer) governs whether this item is enabled.
    property questionElement : TFhirString read FQuestion write SetQuestion;

    // Typed access to An indication that this item should be enabled only if the specified question is answered (hasAnswer=true) or not answered (hasAnswer=false).
    property hasAnswer : Boolean read GetHasAnswerST write SetHasAnswerST;
    // An indication that this item should be enabled only if the specified question is answered (hasAnswer=true) or not answered (hasAnswer=false).
    property hasAnswerElement : TFhirBoolean read FHasAnswer write SetHasAnswer;

    // Typed access to An answer that the referenced question must match in order for the item to be enabled. (defined for API consistency)
    property answer : TFhirType read FAnswer write SetAnswer;
    // An answer that the referenced question must match in order for the item to be enabled.
    property answerElement : TFhirType read FAnswer write SetAnswer;

  end;

  TFhirQuestionnaireItemEnableWhenListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirQuestionnaireItemEnableWhenList;
    function GetCurrent : TFhirQuestionnaireItemEnableWhen;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirQuestionnaireItemEnableWhenList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirQuestionnaireItemEnableWhen read GetCurrent;
  end;

  TFhirQuestionnaireItemEnableWhenList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirQuestionnaireItemEnableWhen;
    procedure SetItemN(index : Integer; value : TFhirQuestionnaireItemEnableWhen);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirQuestionnaireItemEnableWhenList; Overload;
    function Clone : TFhirQuestionnaireItemEnableWhenList; Overload;
    function GetEnumerator : TFhirQuestionnaireItemEnableWhenListEnumerator;

    //  Add a FhirQuestionnaireItemEnableWhen to the end of the list.
    function Append : TFhirQuestionnaireItemEnableWhen;

    // Add an already existing FhirQuestionnaireItemEnableWhen to the end of the list.
    procedure AddItem(value : TFhirQuestionnaireItemEnableWhen); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirQuestionnaireItemEnableWhen) : Integer;

    // Insert FhirQuestionnaireItemEnableWhen before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirQuestionnaireItemEnableWhen;

    // Insert an existing FhirQuestionnaireItemEnableWhen before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirQuestionnaireItemEnableWhen);

    // Get the iIndexth FhirQuestionnaireItemEnableWhen. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirQuestionnaireItemEnableWhen);

    // The number of items in the collection
    function Item(index : Integer) : TFhirQuestionnaireItemEnableWhen;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirQuestionnaireItemEnableWhens[index : Integer] : TFhirQuestionnaireItemEnableWhen read GetItemN write SetItemN; default;
  End;

  // One of the permitted answers for a "choice" or "open-choice" question.
  TFhirQuestionnaireItemOption = class (TFhirBackboneElement)
  protected
    FValue : TFhirType;
    Procedure SetValue(value : TFhirType);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirQuestionnaireItemOption; overload;
    function Clone : TFhirQuestionnaireItemOption; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A potential answer that's allowed as the answer to this question. (defined for API consistency)
    property value : TFhirType read FValue write SetValue;
    // A potential answer that's allowed as the answer to this question.
    property valueElement : TFhirType read FValue write SetValue;

  end;

  TFhirQuestionnaireItemOptionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirQuestionnaireItemOptionList;
    function GetCurrent : TFhirQuestionnaireItemOption;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirQuestionnaireItemOptionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirQuestionnaireItemOption read GetCurrent;
  end;

  TFhirQuestionnaireItemOptionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirQuestionnaireItemOption;
    procedure SetItemN(index : Integer; value : TFhirQuestionnaireItemOption);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirQuestionnaireItemOptionList; Overload;
    function Clone : TFhirQuestionnaireItemOptionList; Overload;
    function GetEnumerator : TFhirQuestionnaireItemOptionListEnumerator;

    //  Add a FhirQuestionnaireItemOption to the end of the list.
    function Append : TFhirQuestionnaireItemOption;

    // Add an already existing FhirQuestionnaireItemOption to the end of the list.
    procedure AddItem(value : TFhirQuestionnaireItemOption); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirQuestionnaireItemOption) : Integer;

    // Insert FhirQuestionnaireItemOption before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirQuestionnaireItemOption;

    // Insert an existing FhirQuestionnaireItemOption before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirQuestionnaireItemOption);

    // Get the iIndexth FhirQuestionnaireItemOption. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirQuestionnaireItemOption);

    // The number of items in the collection
    function Item(index : Integer) : TFhirQuestionnaireItemOption;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirQuestionnaireItemOptions[index : Integer] : TFhirQuestionnaireItemOption read GetItemN write SetItemN; default;
  End;

  // A structured set of questions intended to guide the collection of answers from end-users. Questionnaires provide detailed control over order, presentation, phraseology and grouping to allow coherent, consistent data collection.
  TFhirQuestionnaire = class (TFhirMetadataResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FPurpose : TFhirMarkdown;
    FApprovalDate : TFhirDate;
    FLastReviewDate : TFhirDate;
    FEffectivePeriod : TFhirPeriod;
    FCopyright : TFhirMarkdown;
    FcodeList : TFhirCodingList;
    FSubjectType : TFhirEnumList;
    FitemList : TFhirQuestionnaireItemList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetPurpose(value : TFhirMarkdown);
    Function GetPurposeST : String;
    Procedure SetPurposeST(value : String);
    Procedure SetApprovalDate(value : TFhirDate);
    Function GetApprovalDateST : TFslDateTime;
    Procedure SetApprovalDateST(value : TFslDateTime);
    Procedure SetLastReviewDate(value : TFhirDate);
    Function GetLastReviewDateST : TFslDateTime;
    Procedure SetLastReviewDateST(value : TFslDateTime);
    Procedure SetEffectivePeriod(value : TFhirPeriod);
    Procedure SetCopyright(value : TFhirMarkdown);
    Function GetCopyrightST : String;
    Procedure SetCopyrightST(value : String);
    function GetCodeList : TFhirCodingList;
    function GetHasCodeList : Boolean;
    function GetSubjectType : TFhirEnumList;
    function GetHasSubjectType : Boolean;
    function GetItemList : TFhirQuestionnaireItemList;
    function GetHasItemList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirQuestionnaire; overload;
    function Clone : TFhirQuestionnaire; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this questionnaire when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this questionnaire is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the questionnaire. For more information see [Technical and Business Versions](resource.html#versions).
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this questionnaire when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this questionnaire is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the questionnaire. For more information see [Technical and Business Versions](resource.html#versions).
    property urlElement : TFhirUri read FUrl write SetUrl;

    // A formal identifier that is used to identify this questionnaire when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the questionnaire when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the questionnaire author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the questionnaire when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the questionnaire author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the questionnaire. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the questionnaire. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the questionnaire.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the questionnaire.
    property titleElement : TFhirString read FTitle write SetTitle;

    // The status of this questionnaire. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A boolean value to indicate that this questionnaire is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A boolean value to indicate that this questionnaire is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The date  (and optionally time) when the questionnaire was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the questionnaire changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the questionnaire was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the questionnaire changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the questionnaire.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the questionnaire.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Typed access to A free text natural language description of the questionnaire from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the questionnaire from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // Typed access to Explaination of why this questionnaire is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explaination of why this questionnaire is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Typed access to The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDate : TFslDateTime read GetApprovalDateST write SetApprovalDateST;
    // The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDateElement : TFhirDate read FApprovalDate write SetApprovalDate;

    // Typed access to The date on which the resource content was last reviewed. Review happens periodically after approval, but doesn't change the original approval date.
    property lastReviewDate : TFslDateTime read GetLastReviewDateST write SetLastReviewDateST;
    // The date on which the resource content was last reviewed. Review happens periodically after approval, but doesn't change the original approval date.
    property lastReviewDateElement : TFhirDate read FLastReviewDate write SetLastReviewDate;

    // Typed access to The period during which the questionnaire content was or is planned to be in active use. (defined for API consistency)
    property effectivePeriod : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;
    // The period during which the questionnaire content was or is planned to be in active use.
    property effectivePeriodElement : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These terms may be used to assist with indexing and searching for appropriate questionnaire instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the questionnaire is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A copyright statement relating to the questionnaire and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the questionnaire.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the questionnaire and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the questionnaire.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // An identifier for this question or group of questions in a particular terminology such as LOINC.
    property codeList : TFhirCodingList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    property subjectType : TFhirEnumList read GetSubjectType;
    property subjectTypeList : TFhirEnumList read GetSubjectType;
    property hasSubjectType : boolean read GetHasSubjectType;
    // A particular question, question grouping or display text that is part of the questionnaire.
    property itemList : TFhirQuestionnaireItemList read GetItemList;
    property hasItemList : boolean read GetHasItemList;

  end;

  TFhirQuestionnaireListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirQuestionnaireList;
    function GetCurrent : TFhirQuestionnaire;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirQuestionnaireList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirQuestionnaire read GetCurrent;
  end;

  TFhirQuestionnaireList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirQuestionnaire;
    procedure SetItemN(index : Integer; value : TFhirQuestionnaire);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirQuestionnaireList; Overload;
    function Clone : TFhirQuestionnaireList; Overload;
    function GetEnumerator : TFhirQuestionnaireListEnumerator;

    //  Add a FhirQuestionnaire to the end of the list.
    function Append : TFhirQuestionnaire;

    // Add an already existing FhirQuestionnaire to the end of the list.
    procedure AddItem(value : TFhirQuestionnaire); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirQuestionnaire) : Integer;

    // Insert FhirQuestionnaire before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirQuestionnaire;

    // Insert an existing FhirQuestionnaire before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirQuestionnaire);

    // Get the iIndexth FhirQuestionnaire. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirQuestionnaire);

    // The number of items in the collection
    function Item(index : Integer) : TFhirQuestionnaire;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirQuestionnaires[index : Integer] : TFhirQuestionnaire read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_QUESTIONNAIRE}

{$IFDEF FHIR_REQUESTGROUP}

  // The actions, if any, produced by the evaluation of the artifact.
  TFhirRequestGroupAction = class (TFhirBackboneElement)
  protected
    FLabel_ : TFhirString;
    FTitle : TFhirString;
    FDescription : TFhirString;
    FTextEquivalent : TFhirString;
    FcodeList : TFhirCodeableConceptList;
    FdocumentationList : TFhirRelatedArtifactList;
    FconditionList : TFhirRequestGroupActionConditionList;
    FrelatedActionList : TFhirRequestGroupActionRelatedActionList;
    FTiming : TFhirType;
    FparticipantList : TFhirReferenceList{Resource};
    FType_ : TFhirCoding;
    FGroupingBehavior : TFhirEnum;
    FSelectionBehavior : TFhirEnum;
    FRequiredBehavior : TFhirEnum;
    FPrecheckBehavior : TFhirEnum;
    FCardinalityBehavior : TFhirEnum;
    FResource : TFhirReference{TFhirReference};
    FactionList : TFhirRequestGroupActionList;
    Procedure SetLabel_(value : TFhirString);
    Function GetLabel_ST : String;
    Procedure SetLabel_ST(value : String);
    Procedure SetTitle(value : TFhirString);
    Function GetTitleST : String;
    Procedure SetTitleST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetTextEquivalent(value : TFhirString);
    Function GetTextEquivalentST : String;
    Procedure SetTextEquivalentST(value : String);
    function GetCodeList : TFhirCodeableConceptList;
    function GetHasCodeList : Boolean;
    function GetDocumentationList : TFhirRelatedArtifactList;
    function GetHasDocumentationList : Boolean;
    function GetConditionList : TFhirRequestGroupActionConditionList;
    function GetHasConditionList : Boolean;
    function GetRelatedActionList : TFhirRequestGroupActionRelatedActionList;
    function GetHasRelatedActionList : Boolean;
    Procedure SetTiming(value : TFhirType);
    function GetParticipantList : TFhirReferenceList{Resource};
    function GetHasParticipantList : Boolean;
    Procedure SetType_(value : TFhirCoding);
    Procedure SetGroupingBehavior(value : TFhirEnum);
    Function GetGroupingBehaviorST : TFhirActionGroupingBehaviorEnum;
    Procedure SetGroupingBehaviorST(value : TFhirActionGroupingBehaviorEnum);
    Procedure SetSelectionBehavior(value : TFhirEnum);
    Function GetSelectionBehaviorST : TFhirActionSelectionBehaviorEnum;
    Procedure SetSelectionBehaviorST(value : TFhirActionSelectionBehaviorEnum);
    Procedure SetRequiredBehavior(value : TFhirEnum);
    Function GetRequiredBehaviorST : TFhirActionRequiredBehaviorEnum;
    Procedure SetRequiredBehaviorST(value : TFhirActionRequiredBehaviorEnum);
    Procedure SetPrecheckBehavior(value : TFhirEnum);
    Function GetPrecheckBehaviorST : TFhirActionPrecheckBehaviorEnum;
    Procedure SetPrecheckBehaviorST(value : TFhirActionPrecheckBehaviorEnum);
    Procedure SetCardinalityBehavior(value : TFhirEnum);
    Function GetCardinalityBehaviorST : TFhirActionCardinalityBehaviorEnum;
    Procedure SetCardinalityBehaviorST(value : TFhirActionCardinalityBehaviorEnum);
    Procedure SetResource(value : TFhirReference{TFhirReference});
    function GetActionList : TFhirRequestGroupActionList;
    function GetHasActionList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRequestGroupAction; overload;
    function Clone : TFhirRequestGroupAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A user-visible label for the action.
    property label_ : String read GetLabel_ST write SetLabel_ST;
    // A user-visible label for the action.
    property label_Element : TFhirString read FLabel_ write SetLabel_;

    // Typed access to The title of the action displayed to a user.
    property title : String read GetTitleST write SetTitleST;
    // The title of the action displayed to a user.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to A short description of the action used to provide a summary to display to the user.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A short description of the action used to provide a summary to display to the user.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to A text equivalent of the action to be performed. This provides a human-interpretable description of the action when the definition is consumed by a system that may not be capable of interpreting it dynamically.
    property textEquivalent : String read GetTextEquivalentST write SetTextEquivalentST;
    // A text equivalent of the action to be performed. This provides a human-interpretable description of the action when the definition is consumed by a system that may not be capable of interpreting it dynamically.
    property textEquivalentElement : TFhirString read FTextEquivalent write SetTextEquivalent;

    // A code that provides meaning for the action or action group. For example, a section may have a LOINC code for a the section of a documentation template.
    property codeList : TFhirCodeableConceptList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // Didactic or other informational resources associated with the action that can be provided to the CDS recipient. Information resources can include inline text commentary and links to web resources.
    property documentationList : TFhirRelatedArtifactList read GetDocumentationList;
    property hasDocumentationList : boolean read GetHasDocumentationList;

    // An expression that describes applicability criteria, or start/stop conditions for the action.
    property conditionList : TFhirRequestGroupActionConditionList read GetConditionList;
    property hasConditionList : boolean read GetHasConditionList;

    // A relationship to another action such as "before" or "30-60 minutes after start of".
    property relatedActionList : TFhirRequestGroupActionRelatedActionList read GetRelatedActionList;
    property hasRelatedActionList : boolean read GetHasRelatedActionList;

    // Typed access to An optional value describing when the action should be performed. (defined for API consistency)
    property timing : TFhirType read FTiming write SetTiming;
    // An optional value describing when the action should be performed.
    property timingElement : TFhirType read FTiming write SetTiming;

    // The participant that should perform or be responsible for this action.
    property participantList : TFhirReferenceList{Resource} read GetParticipantList;
    property hasParticipantList : boolean read GetHasParticipantList;

    // Typed access to The type of action to perform (create, update, remove). (defined for API consistency)
    property type_ : TFhirCoding read FType_ write SetType_;
    // The type of action to perform (create, update, remove).
    property type_Element : TFhirCoding read FType_ write SetType_;

    // Defines the grouping behavior for the action and its children.
    property groupingBehavior : TFhirActionGroupingBehaviorEnum read GetGroupingBehaviorST write SetGroupingBehaviorST;
    property groupingBehaviorElement : TFhirEnum read FGroupingBehavior write SetGroupingBehavior;

    // Defines the selection behavior for the action and its children.
    property selectionBehavior : TFhirActionSelectionBehaviorEnum read GetSelectionBehaviorST write SetSelectionBehaviorST;
    property selectionBehaviorElement : TFhirEnum read FSelectionBehavior write SetSelectionBehavior;

    // Defines the requiredness behavior for the action.
    property requiredBehavior : TFhirActionRequiredBehaviorEnum read GetRequiredBehaviorST write SetRequiredBehaviorST;
    property requiredBehaviorElement : TFhirEnum read FRequiredBehavior write SetRequiredBehavior;

    // Defines whether the action should usually be preselected.
    property precheckBehavior : TFhirActionPrecheckBehaviorEnum read GetPrecheckBehaviorST write SetPrecheckBehaviorST;
    property precheckBehaviorElement : TFhirEnum read FPrecheckBehavior write SetPrecheckBehavior;

    // Defines whether the action can be selected multiple times.
    property cardinalityBehavior : TFhirActionCardinalityBehaviorEnum read GetCardinalityBehaviorST write SetCardinalityBehaviorST;
    property cardinalityBehaviorElement : TFhirEnum read FCardinalityBehavior write SetCardinalityBehavior;

    // Typed access to The resource that is the target of the action (e.g. CommunicationRequest). (defined for API consistency)
    property resource : TFhirReference{TFhirReference} read FResource write SetResource;
    // The resource that is the target of the action (e.g. CommunicationRequest).
    property resourceElement : TFhirReference{TFhirReference} read FResource write SetResource;

    // Sub actions.
    property actionList : TFhirRequestGroupActionList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

  end;

  TFhirRequestGroupActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRequestGroupActionList;
    function GetCurrent : TFhirRequestGroupAction;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirRequestGroupActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRequestGroupAction read GetCurrent;
  end;

  TFhirRequestGroupActionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirRequestGroupAction;
    procedure SetItemN(index : Integer; value : TFhirRequestGroupAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirRequestGroupActionList; Overload;
    function Clone : TFhirRequestGroupActionList; Overload;
    function GetEnumerator : TFhirRequestGroupActionListEnumerator;

    //  Add a FhirRequestGroupAction to the end of the list.
    function Append : TFhirRequestGroupAction;

    // Add an already existing FhirRequestGroupAction to the end of the list.
    procedure AddItem(value : TFhirRequestGroupAction); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRequestGroupAction) : Integer;

    // Insert FhirRequestGroupAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRequestGroupAction;

    // Insert an existing FhirRequestGroupAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRequestGroupAction);

    // Get the iIndexth FhirRequestGroupAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRequestGroupAction);

    // The number of items in the collection
    function Item(index : Integer) : TFhirRequestGroupAction;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirRequestGroupActions[index : Integer] : TFhirRequestGroupAction read GetItemN write SetItemN; default;
  End;

  // An expression that describes applicability criteria, or start/stop conditions for the action.
  TFhirRequestGroupActionCondition = class (TFhirBackboneElement)
  protected
    FKind : TFhirEnum;
    FDescription : TFhirString;
    FLanguage : TFhirString;
    FExpression : TFhirString;
    Procedure SetKind(value : TFhirEnum);
    Function GetKindST : TFhirActionConditionKindEnum;
    Procedure SetKindST(value : TFhirActionConditionKindEnum);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetLanguage(value : TFhirString);
    Function GetLanguageST : String;
    Procedure SetLanguageST(value : String);
    Procedure SetExpression(value : TFhirString);
    Function GetExpressionST : String;
    Procedure SetExpressionST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRequestGroupActionCondition; overload;
    function Clone : TFhirRequestGroupActionCondition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The kind of condition.
    property kind : TFhirActionConditionKindEnum read GetKindST write SetKindST;
    property kindElement : TFhirEnum read FKind write SetKind;

    // Typed access to A brief, natural language description of the condition that effectively communicates the intended semantics.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A brief, natural language description of the condition that effectively communicates the intended semantics.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to The media type of the language for the expression.
    property language : String read GetLanguageST write SetLanguageST;
    // The media type of the language for the expression.
    property languageElement : TFhirString read FLanguage write SetLanguage;

    // Typed access to An expression that returns true or false, indicating whether or not the condition is satisfied.
    property expression : String read GetExpressionST write SetExpressionST;
    // An expression that returns true or false, indicating whether or not the condition is satisfied.
    property expressionElement : TFhirString read FExpression write SetExpression;

  end;

  TFhirRequestGroupActionConditionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRequestGroupActionConditionList;
    function GetCurrent : TFhirRequestGroupActionCondition;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirRequestGroupActionConditionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRequestGroupActionCondition read GetCurrent;
  end;

  TFhirRequestGroupActionConditionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirRequestGroupActionCondition;
    procedure SetItemN(index : Integer; value : TFhirRequestGroupActionCondition);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirRequestGroupActionConditionList; Overload;
    function Clone : TFhirRequestGroupActionConditionList; Overload;
    function GetEnumerator : TFhirRequestGroupActionConditionListEnumerator;

    //  Add a FhirRequestGroupActionCondition to the end of the list.
    function Append : TFhirRequestGroupActionCondition;

    // Add an already existing FhirRequestGroupActionCondition to the end of the list.
    procedure AddItem(value : TFhirRequestGroupActionCondition); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRequestGroupActionCondition) : Integer;

    // Insert FhirRequestGroupActionCondition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRequestGroupActionCondition;

    // Insert an existing FhirRequestGroupActionCondition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRequestGroupActionCondition);

    // Get the iIndexth FhirRequestGroupActionCondition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRequestGroupActionCondition);

    // The number of items in the collection
    function Item(index : Integer) : TFhirRequestGroupActionCondition;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirRequestGroupActionConditions[index : Integer] : TFhirRequestGroupActionCondition read GetItemN write SetItemN; default;
  End;

  // A relationship to another action such as "before" or "30-60 minutes after start of".
  TFhirRequestGroupActionRelatedAction = class (TFhirBackboneElement)
  protected
    FActionId : TFhirId;
    FRelationship : TFhirEnum;
    FOffset : TFhirType;
    Procedure SetActionId(value : TFhirId);
    Function GetActionIdST : String;
    Procedure SetActionIdST(value : String);
    Procedure SetRelationship(value : TFhirEnum);
    Function GetRelationshipST : TFhirActionRelationshipTypeEnum;
    Procedure SetRelationshipST(value : TFhirActionRelationshipTypeEnum);
    Procedure SetOffset(value : TFhirType);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRequestGroupActionRelatedAction; overload;
    function Clone : TFhirRequestGroupActionRelatedAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The element id of the action this is related to.
    property actionId : String read GetActionIdST write SetActionIdST;
    // The element id of the action this is related to.
    property actionIdElement : TFhirId read FActionId write SetActionId;

    // The relationship of this action to the related action.
    property relationship : TFhirActionRelationshipTypeEnum read GetRelationshipST write SetRelationshipST;
    property relationshipElement : TFhirEnum read FRelationship write SetRelationship;

    // Typed access to A duration or range of durations to apply to the relationship. For example, 30-60 minutes before. (defined for API consistency)
    property offset : TFhirType read FOffset write SetOffset;
    // A duration or range of durations to apply to the relationship. For example, 30-60 minutes before.
    property offsetElement : TFhirType read FOffset write SetOffset;

  end;

  TFhirRequestGroupActionRelatedActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRequestGroupActionRelatedActionList;
    function GetCurrent : TFhirRequestGroupActionRelatedAction;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirRequestGroupActionRelatedActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRequestGroupActionRelatedAction read GetCurrent;
  end;

  TFhirRequestGroupActionRelatedActionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirRequestGroupActionRelatedAction;
    procedure SetItemN(index : Integer; value : TFhirRequestGroupActionRelatedAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirRequestGroupActionRelatedActionList; Overload;
    function Clone : TFhirRequestGroupActionRelatedActionList; Overload;
    function GetEnumerator : TFhirRequestGroupActionRelatedActionListEnumerator;

    //  Add a FhirRequestGroupActionRelatedAction to the end of the list.
    function Append : TFhirRequestGroupActionRelatedAction;

    // Add an already existing FhirRequestGroupActionRelatedAction to the end of the list.
    procedure AddItem(value : TFhirRequestGroupActionRelatedAction); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRequestGroupActionRelatedAction) : Integer;

    // Insert FhirRequestGroupActionRelatedAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRequestGroupActionRelatedAction;

    // Insert an existing FhirRequestGroupActionRelatedAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRequestGroupActionRelatedAction);

    // Get the iIndexth FhirRequestGroupActionRelatedAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRequestGroupActionRelatedAction);

    // The number of items in the collection
    function Item(index : Integer) : TFhirRequestGroupActionRelatedAction;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirRequestGroupActionRelatedActions[index : Integer] : TFhirRequestGroupActionRelatedAction read GetItemN write SetItemN; default;
  End;

  // A group of related requests that can be used to capture intended activities that have inter-dependencies such as "give this medication after that one".
  TFhirRequestGroup = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FdefinitionList : TFhirReferenceList{TFhirReference};
    FbasedOnList : TFhirReferenceList{TFhirReference};
    FreplacesList : TFhirReferenceList{TFhirReference};
    FGroupIdentifier : TFhirIdentifier;
    FStatus : TFhirEnum;
    FIntent : TFhirEnum;
    FPriority : TFhirEnum;
    FSubject : TFhirReference{Resource};
    FContext : TFhirReference{Resource};
    FAuthoredOn : TFhirDateTime;
    FAuthor : TFhirReference{Resource};
    FReason : TFhirType;
    FnoteList : TFhirAnnotationList;
    FactionList : TFhirRequestGroupActionList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetDefinitionList : TFhirReferenceList{TFhirReference};
    function GetHasDefinitionList : Boolean;
    function GetBasedOnList : TFhirReferenceList{TFhirReference};
    function GetHasBasedOnList : Boolean;
    function GetReplacesList : TFhirReferenceList{TFhirReference};
    function GetHasReplacesList : Boolean;
    Procedure SetGroupIdentifier(value : TFhirIdentifier);
    Procedure SetStatus(value : TFhirEnum);
    Function GetStatusST : TFhirRequestStatusEnum;
    Procedure SetStatusST(value : TFhirRequestStatusEnum);
    Procedure SetIntent(value : TFhirEnum);
    Function GetIntentST : TFhirRequestIntentEnum;
    Procedure SetIntentST(value : TFhirRequestIntentEnum);
    Procedure SetPriority(value : TFhirEnum);
    Function GetPriorityST : TFhirRequestPriorityEnum;
    Procedure SetPriorityST(value : TFhirRequestPriorityEnum);
    Procedure SetSubject(value : TFhirReference{Resource});
    Procedure SetContext(value : TFhirReference{Resource});
    Procedure SetAuthoredOn(value : TFhirDateTime);
    Function GetAuthoredOnST : TFslDateTime;
    Procedure SetAuthoredOnST(value : TFslDateTime);
    Procedure SetAuthor(value : TFhirReference{Resource});
    Procedure SetReason(value : TFhirType);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetActionList : TFhirRequestGroupActionList;
    function GetHasActionList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRequestGroup; overload;
    function Clone : TFhirRequestGroup; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Allows a service to provide a unique, business identifier for the request.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A protocol, guideline, orderset or other definition that is adhered to in whole or in part by this request.
    property definitionList : TFhirReferenceList{TFhirReference} read GetDefinitionList;
    property hasDefinitionList : boolean read GetHasDefinitionList;

    // A plan, proposal or order that is fulfilled in whole or in part by this request.
    property basedOnList : TFhirReferenceList{TFhirReference} read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // Completed or terminated request(s) whose function is taken by this new request.
    property replacesList : TFhirReferenceList{TFhirReference} read GetReplacesList;
    property hasReplacesList : boolean read GetHasReplacesList;

    // Typed access to A shared identifier common to all requests that were authorized more or less simultaneously by a single author, representing the identifier of the requisition, prescription or similar form. (defined for API consistency)
    property groupIdentifier : TFhirIdentifier read FGroupIdentifier write SetGroupIdentifier;
    // A shared identifier common to all requests that were authorized more or less simultaneously by a single author, representing the identifier of the requisition, prescription or similar form.
    property groupIdentifierElement : TFhirIdentifier read FGroupIdentifier write SetGroupIdentifier;

    // The current state of the request. For request groups, the status reflects the status of all the requests in the group.
    property status : TFhirRequestStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Indicates the level of authority/intentionality associated with the request and where the request fits into the workflow chain.
    property intent : TFhirRequestIntentEnum read GetIntentST write SetIntentST;
    property intentElement : TFhirEnum read FIntent write SetIntent;

    // Indicates how quickly the request should be addressed with respect to other requests.
    property priority : TFhirRequestPriorityEnum read GetPriorityST write SetPriorityST;
    property priorityElement : TFhirEnum read FPriority write SetPriority;

    // Typed access to The subject for which the request group was created. (defined for API consistency)
    property subject : TFhirReference{Resource} read FSubject write SetSubject;
    // The subject for which the request group was created.
    property subjectElement : TFhirReference{Resource} read FSubject write SetSubject;

    // Typed access to Describes the context of the request group, if any. (defined for API consistency)
    property context : TFhirReference{Resource} read FContext write SetContext;
    // Describes the context of the request group, if any.
    property contextElement : TFhirReference{Resource} read FContext write SetContext;

    // Typed access to Indicates when the request group was created.
    property authoredOn : TFslDateTime read GetAuthoredOnST write SetAuthoredOnST;
    // Indicates when the request group was created.
    property authoredOnElement : TFhirDateTime read FAuthoredOn write SetAuthoredOn;

    // Typed access to Provides a reference to the author of the request group. (defined for API consistency)
    property author : TFhirReference{Resource} read FAuthor write SetAuthor;
    // Provides a reference to the author of the request group.
    property authorElement : TFhirReference{Resource} read FAuthor write SetAuthor;

    // Typed access to Indicates the reason the request group was created. This is typically provided as a parameter to the evaluation and echoed by the service, although for some use cases, such as subscription- or event-based scenarios, it may provide an indication of the cause for the response. (defined for API consistency)
    property reason : TFhirType read FReason write SetReason;
    // Indicates the reason the request group was created. This is typically provided as a parameter to the evaluation and echoed by the service, although for some use cases, such as subscription- or event-based scenarios, it may provide an indication of the cause for the response.
    property reasonElement : TFhirType read FReason write SetReason;

    // Provides a mechanism to communicate additional information about the response.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // The actions, if any, produced by the evaluation of the artifact.
    property actionList : TFhirRequestGroupActionList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

  end;

  TFhirRequestGroupListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRequestGroupList;
    function GetCurrent : TFhirRequestGroup;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirRequestGroupList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRequestGroup read GetCurrent;
  end;

  TFhirRequestGroupList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirRequestGroup;
    procedure SetItemN(index : Integer; value : TFhirRequestGroup);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirRequestGroupList; Overload;
    function Clone : TFhirRequestGroupList; Overload;
    function GetEnumerator : TFhirRequestGroupListEnumerator;

    //  Add a FhirRequestGroup to the end of the list.
    function Append : TFhirRequestGroup;

    // Add an already existing FhirRequestGroup to the end of the list.
    procedure AddItem(value : TFhirRequestGroup); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRequestGroup) : Integer;

    // Insert FhirRequestGroup before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRequestGroup;

    // Insert an existing FhirRequestGroup before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRequestGroup);

    // Get the iIndexth FhirRequestGroup. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRequestGroup);

    // The number of items in the collection
    function Item(index : Integer) : TFhirRequestGroup;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirRequestGroups[index : Integer] : TFhirRequestGroup read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_REQUESTGROUP}

{$IFDEF FHIR_SEARCHPARAMETER}

  // Used to define the parts of a composite search parameter.
  TFhirSearchParameterComponent = class (TFhirBackboneElement)
  protected
    FDefinition : TFhirReference{TFhirSearchParameter};
    FExpression : TFhirString;
    Procedure SetDefinition(value : TFhirReference{TFhirSearchParameter});
    Procedure SetExpression(value : TFhirString);
    Function GetExpressionST : String;
    Procedure SetExpressionST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSearchParameterComponent; overload;
    function Clone : TFhirSearchParameterComponent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The definition of the search parameter that describes this part. (defined for API consistency)
    property definition : TFhirReference{TFhirSearchParameter} read FDefinition write SetDefinition;
    // The definition of the search parameter that describes this part.
    property definitionElement : TFhirReference{TFhirSearchParameter} read FDefinition write SetDefinition;

    // Typed access to A sub-expression that defines how to extract values for this component from the output of the main SearchParameter.expression.
    property expression : String read GetExpressionST write SetExpressionST;
    // A sub-expression that defines how to extract values for this component from the output of the main SearchParameter.expression.
    property expressionElement : TFhirString read FExpression write SetExpression;

  end;

  TFhirSearchParameterComponentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSearchParameterComponentList;
    function GetCurrent : TFhirSearchParameterComponent;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSearchParameterComponentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSearchParameterComponent read GetCurrent;
  end;

  TFhirSearchParameterComponentList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSearchParameterComponent;
    procedure SetItemN(index : Integer; value : TFhirSearchParameterComponent);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSearchParameterComponentList; Overload;
    function Clone : TFhirSearchParameterComponentList; Overload;
    function GetEnumerator : TFhirSearchParameterComponentListEnumerator;

    //  Add a FhirSearchParameterComponent to the end of the list.
    function Append : TFhirSearchParameterComponent;

    // Add an already existing FhirSearchParameterComponent to the end of the list.
    procedure AddItem(value : TFhirSearchParameterComponent); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSearchParameterComponent) : Integer;

    // Insert FhirSearchParameterComponent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSearchParameterComponent;

    // Insert an existing FhirSearchParameterComponent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSearchParameterComponent);

    // Get the iIndexth FhirSearchParameterComponent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSearchParameterComponent);

    // The number of items in the collection
    function Item(index : Integer) : TFhirSearchParameterComponent;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirSearchParameterComponents[index : Integer] : TFhirSearchParameterComponent read GetItemN write SetItemN; default;
  End;

  // A search parameter that defines a named search item that can be used to search/filter on a resource.
  TFhirSearchParameter = class (TFhirMetadataResource)
  protected
    FPurpose : TFhirMarkdown;
    FCode : TFhirCode;
    FBase : TFhirEnumList;
    FType_ : TFhirEnum;
    FDerivedFrom : TFhirUri;
    FExpression : TFhirString;
    FXpath : TFhirString;
    FXpathUsage : TFhirEnum;
    FTarget : TFhirEnumList;
    FComparator : TFhirEnumList;
    FModifier : TFhirEnumList;
    FchainList : TFhirStringList;
    FcomponentList : TFhirSearchParameterComponentList;
    Procedure SetPurpose(value : TFhirMarkdown);
    Function GetPurposeST : String;
    Procedure SetPurposeST(value : String);
    Procedure SetCode(value : TFhirCode);
    Function GetCodeST : String;
    Procedure SetCodeST(value : String);
    function GetBase : TFhirEnumList;
    function GetHasBase : Boolean;
    Procedure SetType_(value : TFhirEnum);
    Function GetType_ST : TFhirSearchParamTypeEnum;
    Procedure SetType_ST(value : TFhirSearchParamTypeEnum);
    Procedure SetDerivedFrom(value : TFhirUri);
    Function GetDerivedFromST : String;
    Procedure SetDerivedFromST(value : String);
    Procedure SetExpression(value : TFhirString);
    Function GetExpressionST : String;
    Procedure SetExpressionST(value : String);
    Procedure SetXpath(value : TFhirString);
    Function GetXpathST : String;
    Procedure SetXpathST(value : String);
    Procedure SetXpathUsage(value : TFhirEnum);
    Function GetXpathUsageST : TFhirSearchXpathUsageEnum;
    Procedure SetXpathUsageST(value : TFhirSearchXpathUsageEnum);
    function GetTarget : TFhirEnumList;
    function GetHasTarget : Boolean;
    function GetComparator : TFhirEnumList;
    function GetHasComparator : Boolean;
    Function GetComparatorST : TFhirSearchComparatorEnumList;
    Procedure SetComparatorST(value : TFhirSearchComparatorEnumList);
    function GetModifier : TFhirEnumList;
    function GetHasModifier : Boolean;
    Function GetModifierST : TFhirSearchModifierCodeEnumList;
    Procedure SetModifierST(value : TFhirSearchModifierCodeEnumList);
    function GetChainList : TFhirStringList;
    function GetHasChainList : Boolean;
    function GetComponentList : TFhirSearchParameterComponentList;
    function GetHasComponentList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSearchParameter; overload;
    function Clone : TFhirSearchParameter; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this search parameter when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this search parameter is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the search parameter. For more information see [Technical and Business Versions](resource.html#versions).
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this search parameter when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this search parameter is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the search parameter. For more information see [Technical and Business Versions](resource.html#versions).
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to The identifier that is used to identify this version of the search parameter when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the search parameter author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the search parameter when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the search parameter author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the search parameter. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the search parameter. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // The status of this search parameter. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A boolean value to indicate that this search parameter is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A boolean value to indicate that this search parameter is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The date  (and optionally time) when the search parameter was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the search parameter changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the search parameter was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the search parameter changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the search parameter.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the search parameter.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These terms may be used to assist with indexing and searching for appropriate search parameter instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the search parameter is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to Explaination of why this search parameter is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explaination of why this search parameter is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Typed access to The code used in the URL or the parameter name in a parameters resource for this search parameter.
    property code : String read GetCodeST write SetCodeST;
    // The code used in the URL or the parameter name in a parameters resource for this search parameter.
    property codeElement : TFhirCode read FCode write SetCode;

    property base : TFhirEnumList read GetBase;
    property baseList : TFhirEnumList read GetBase;
    property hasBase : boolean read GetHasBase;
    // The type of value a search parameter refers to, and how the content is interpreted.
    property type_ : TFhirSearchParamTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to Where this search parameter is originally defined. If a derivedFrom is provided, then the details in the search parameter must be consistent with the definition from which it is defined. I.e. the parameter should have the same meaning, and (usually) the functionality should be a proper subset of the underlying search parameter.
    property derivedFrom : String read GetDerivedFromST write SetDerivedFromST;
    // Where this search parameter is originally defined. If a derivedFrom is provided, then the details in the search parameter must be consistent with the definition from which it is defined. I.e. the parameter should have the same meaning, and (usually) the functionality should be a proper subset of the underlying search parameter.
    property derivedFromElement : TFhirUri read FDerivedFrom write SetDerivedFrom;

    // Typed access to A free text natural language description of the search parameter from a consumer's perspective. and how it used.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the search parameter from a consumer's perspective. and how it used.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // Typed access to A FHIRPath expression that returns a set of elements for the search parameter.
    property expression : String read GetExpressionST write SetExpressionST;
    // A FHIRPath expression that returns a set of elements for the search parameter.
    property expressionElement : TFhirString read FExpression write SetExpression;

    // Typed access to An XPath expression that returns a set of elements for the search parameter.
    property xpath : String read GetXpathST write SetXpathST;
    // An XPath expression that returns a set of elements for the search parameter.
    property xpathElement : TFhirString read FXpath write SetXpath;

    // How the search parameter relates to the set of elements returned by evaluating the xpath query.
    property xpathUsage : TFhirSearchXpathUsageEnum read GetXpathUsageST write SetXpathUsageST;
    property xpathUsageElement : TFhirEnum read FXpathUsage write SetXpathUsage;

    property target : TFhirEnumList read GetTarget;
    property targetList : TFhirEnumList read GetTarget;
    property hasTarget : boolean read GetHasTarget;
    // Comparators supported for the search parameter.
    property comparator : TFhirSearchComparatorEnumList read GetComparatorST write SetComparatorST;
    property comparatorList : TFhirEnumList read GetComparator;
    property hasComparator : boolean read GetHasComparator;
    // A modifier supported for the search parameter.
    property modifier : TFhirSearchModifierCodeEnumList read GetModifierST write SetModifierST;
    property modifierList : TFhirEnumList read GetModifier;
    property hasModifier : boolean read GetHasModifier;
    // Contains the names of any search parameters which may be chained to the containing search parameter. Chained parameters may be added to search parameters of type reference, and specify that resources will only be returned if they contain a reference to a resource which matches the chained parameter value. Values for this field should be drawn from SearchParameter.code for a parameter on the target resource type.
    property chainList : TFhirStringList read GetChainList;
    property hasChainList : boolean read GetHasChainList;

    // Used to define the parts of a composite search parameter.
    property componentList : TFhirSearchParameterComponentList read GetComponentList;
    property hasComponentList : boolean read GetHasComponentList;

  end;

  TFhirSearchParameterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSearchParameterList;
    function GetCurrent : TFhirSearchParameter;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirSearchParameterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSearchParameter read GetCurrent;
  end;

  TFhirSearchParameterList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirSearchParameter;
    procedure SetItemN(index : Integer; value : TFhirSearchParameter);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirSearchParameterList; Overload;
    function Clone : TFhirSearchParameterList; Overload;
    function GetEnumerator : TFhirSearchParameterListEnumerator;

    //  Add a FhirSearchParameter to the end of the list.
    function Append : TFhirSearchParameter;

    // Add an already existing FhirSearchParameter to the end of the list.
    procedure AddItem(value : TFhirSearchParameter); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSearchParameter) : Integer;

    // Insert FhirSearchParameter before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSearchParameter;

    // Insert an existing FhirSearchParameter before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSearchParameter);

    // Get the iIndexth FhirSearchParameter. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSearchParameter);

    // The number of items in the collection
    function Item(index : Integer) : TFhirSearchParameter;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirSearchParameters[index : Integer] : TFhirSearchParameter read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SEARCHPARAMETER}

{$IFDEF FHIR_SERVICEDEFINITION}

  // The ServiceDefinition describes a unit of decision support functionality that is made available as a service, such as immunization modules or drug-drug interaction checking.
  TFhirServiceDefinition = class (TFhirMetadataResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FPurpose : TFhirMarkdown;
    FUsage : TFhirString;
    FApprovalDate : TFhirDate;
    FLastReviewDate : TFhirDate;
    FEffectivePeriod : TFhirPeriod;
    FtopicList : TFhirCodeableConceptList;
    FcontributorList : TFhirContributorList;
    FCopyright : TFhirMarkdown;
    FrelatedArtifactList : TFhirRelatedArtifactList;
    FtriggerList : TFhirTriggerDefinitionList;
    FdataRequirementList : TFhirDataRequirementList;
    FOperationDefinition : TFhirReference{TFhirOperationDefinition};
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetPurpose(value : TFhirMarkdown);
    Function GetPurposeST : String;
    Procedure SetPurposeST(value : String);
    Procedure SetUsage(value : TFhirString);
    Function GetUsageST : String;
    Procedure SetUsageST(value : String);
    Procedure SetApprovalDate(value : TFhirDate);
    Function GetApprovalDateST : TFslDateTime;
    Procedure SetApprovalDateST(value : TFslDateTime);
    Procedure SetLastReviewDate(value : TFhirDate);
    Function GetLastReviewDateST : TFslDateTime;
    Procedure SetLastReviewDateST(value : TFslDateTime);
    Procedure SetEffectivePeriod(value : TFhirPeriod);
    function GetTopicList : TFhirCodeableConceptList;
    function GetHasTopicList : Boolean;
    function GetContributorList : TFhirContributorList;
    function GetHasContributorList : Boolean;
    Procedure SetCopyright(value : TFhirMarkdown);
    Function GetCopyrightST : String;
    Procedure SetCopyrightST(value : String);
    function GetRelatedArtifactList : TFhirRelatedArtifactList;
    function GetHasRelatedArtifactList : Boolean;
    function GetTriggerList : TFhirTriggerDefinitionList;
    function GetHasTriggerList : Boolean;
    function GetDataRequirementList : TFhirDataRequirementList;
    function GetHasDataRequirementList : Boolean;
    Procedure SetOperationDefinition(value : TFhirReference{TFhirOperationDefinition});

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirServiceDefinition; overload;
    function Clone : TFhirServiceDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this service definition when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this service definition is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the service definition. For more information see [Technical and Business Versions](resource.html#versions).
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this service definition when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this service definition is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the service definition. For more information see [Technical and Business Versions](resource.html#versions).
    property urlElement : TFhirUri read FUrl write SetUrl;

    // A formal identifier that is used to identify this service definition when it is represented in other formats, or referenced in a specification, model, design or an instance. This is used for CMS or NQF identifiers for a measure artifact. Note that at least one identifier is required for non-experimental active artifacts.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the service definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the service definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the service definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the service definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the service definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the service definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the service definition.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the service definition.
    property titleElement : TFhirString read FTitle write SetTitle;

    // The status of this service definition. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A boolean value to indicate that this service definition is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A boolean value to indicate that this service definition is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The date  (and optionally time) when the service definition was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the service definition changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the service definition was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the service definition changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the service definition.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the service definition.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Typed access to A free text natural language description of the service definition from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the service definition from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // Typed access to Explaination of why this service definition is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explaination of why this service definition is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Typed access to A detailed description of how the module is used from a clinical perspective.
    property usage : String read GetUsageST write SetUsageST;
    // A detailed description of how the module is used from a clinical perspective.
    property usageElement : TFhirString read FUsage write SetUsage;

    // Typed access to The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDate : TFslDateTime read GetApprovalDateST write SetApprovalDateST;
    // The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDateElement : TFhirDate read FApprovalDate write SetApprovalDate;

    // Typed access to The date on which the resource content was last reviewed. Review happens periodically after approval, but doesn't change the original approval date.
    property lastReviewDate : TFslDateTime read GetLastReviewDateST write SetLastReviewDateST;
    // The date on which the resource content was last reviewed. Review happens periodically after approval, but doesn't change the original approval date.
    property lastReviewDateElement : TFhirDate read FLastReviewDate write SetLastReviewDate;

    // Typed access to The period during which the service definition content was or is planned to be in active use. (defined for API consistency)
    property effectivePeriod : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;
    // The period during which the service definition content was or is planned to be in active use.
    property effectivePeriodElement : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These terms may be used to assist with indexing and searching for appropriate service definition instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the service definition is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Descriptive topics related to the module. Topics provide a high-level categorization of the module that can be useful for filtering and searching.
    property topicList : TFhirCodeableConceptList read GetTopicList;
    property hasTopicList : boolean read GetHasTopicList;

    // A contributor to the content of the module, including authors, editors, reviewers, and endorsers.
    property contributorList : TFhirContributorList read GetContributorList;
    property hasContributorList : boolean read GetHasContributorList;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A copyright statement relating to the service definition and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the service definition.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the service definition and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the service definition.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // Related resources such as additional documentation, justification, or bibliographic references.
    property relatedArtifactList : TFhirRelatedArtifactList read GetRelatedArtifactList;
    property hasRelatedArtifactList : boolean read GetHasRelatedArtifactList;

    // The trigger element defines when the rule should be invoked. This information is used by consumers of the rule to determine how to integrate the rule into a specific workflow.
    property triggerList : TFhirTriggerDefinitionList read GetTriggerList;
    property hasTriggerList : boolean read GetHasTriggerList;

    // Data requirements are a machine processable description of the data required by the module in order to perform a successful evaluation.
    property dataRequirementList : TFhirDataRequirementList read GetDataRequirementList;
    property hasDataRequirementList : boolean read GetHasDataRequirementList;

    // Typed access to A reference to the operation that is used to invoke this service. (defined for API consistency)
    property operationDefinition : TFhirReference{TFhirOperationDefinition} read FOperationDefinition write SetOperationDefinition;
    // A reference to the operation that is used to invoke this service.
    property operationDefinitionElement : TFhirReference{TFhirOperationDefinition} read FOperationDefinition write SetOperationDefinition;

  end;

  TFhirServiceDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirServiceDefinitionList;
    function GetCurrent : TFhirServiceDefinition;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirServiceDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirServiceDefinition read GetCurrent;
  end;

  TFhirServiceDefinitionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirServiceDefinition;
    procedure SetItemN(index : Integer; value : TFhirServiceDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirServiceDefinitionList; Overload;
    function Clone : TFhirServiceDefinitionList; Overload;
    function GetEnumerator : TFhirServiceDefinitionListEnumerator;

    //  Add a FhirServiceDefinition to the end of the list.
    function Append : TFhirServiceDefinition;

    // Add an already existing FhirServiceDefinition to the end of the list.
    procedure AddItem(value : TFhirServiceDefinition); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirServiceDefinition) : Integer;

    // Insert FhirServiceDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirServiceDefinition;

    // Insert an existing FhirServiceDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirServiceDefinition);

    // Get the iIndexth FhirServiceDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirServiceDefinition);

    // The number of items in the collection
    function Item(index : Integer) : TFhirServiceDefinition;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirServiceDefinitions[index : Integer] : TFhirServiceDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SERVICEDEFINITION}

{$IFDEF FHIR_STRUCTUREDEFINITION}

  // An external specification that the content is mapped to.
  TFhirStructureDefinitionMapping = class (TFhirBackboneElement)
  protected
    FIdentity : TFhirId;
    FUri : TFhirUri;
    FName : TFhirString;
    FComment : TFhirString;
    Procedure SetIdentity(value : TFhirId);
    Function GetIdentityST : String;
    Procedure SetIdentityST(value : String);
    Procedure SetUri(value : TFhirUri);
    Function GetUriST : String;
    Procedure SetUriST(value : String);
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetComment(value : TFhirString);
    Function GetCommentST : String;
    Procedure SetCommentST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirStructureDefinitionMapping; overload;
    function Clone : TFhirStructureDefinitionMapping; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An Internal id that is used to identify this mapping set when specific mappings are made.
    property identity : String read GetIdentityST write SetIdentityST;
    // An Internal id that is used to identify this mapping set when specific mappings are made.
    property identityElement : TFhirId read FIdentity write SetIdentity;

    // Typed access to An absolute URI that identifies the specification that this mapping is expressed to.
    property uri : String read GetUriST write SetUriST;
    // An absolute URI that identifies the specification that this mapping is expressed to.
    property uriElement : TFhirUri read FUri write SetUri;

    // Typed access to A name for the specification that is being mapped to.
    property name : String read GetNameST write SetNameST;
    // A name for the specification that is being mapped to.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Comments about this mapping, including version notes, issues, scope limitations, and other important notes for usage.
    property comment : String read GetCommentST write SetCommentST;
    // Comments about this mapping, including version notes, issues, scope limitations, and other important notes for usage.
    property commentElement : TFhirString read FComment write SetComment;

  end;

  TFhirStructureDefinitionMappingListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirStructureDefinitionMappingList;
    function GetCurrent : TFhirStructureDefinitionMapping;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirStructureDefinitionMappingList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirStructureDefinitionMapping read GetCurrent;
  end;

  TFhirStructureDefinitionMappingList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirStructureDefinitionMapping;
    procedure SetItemN(index : Integer; value : TFhirStructureDefinitionMapping);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirStructureDefinitionMappingList; Overload;
    function Clone : TFhirStructureDefinitionMappingList; Overload;
    function GetEnumerator : TFhirStructureDefinitionMappingListEnumerator;

    //  Add a FhirStructureDefinitionMapping to the end of the list.
    function Append : TFhirStructureDefinitionMapping;

    // Add an already existing FhirStructureDefinitionMapping to the end of the list.
    procedure AddItem(value : TFhirStructureDefinitionMapping); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirStructureDefinitionMapping) : Integer;

    // Insert FhirStructureDefinitionMapping before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirStructureDefinitionMapping;

    // Insert an existing FhirStructureDefinitionMapping before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirStructureDefinitionMapping);

    // Get the iIndexth FhirStructureDefinitionMapping. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirStructureDefinitionMapping);

    // The number of items in the collection
    function Item(index : Integer) : TFhirStructureDefinitionMapping;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirStructureDefinitionMappings[index : Integer] : TFhirStructureDefinitionMapping read GetItemN write SetItemN; default;
  End;

  // A snapshot view is expressed in a stand alone form that can be used and interpreted without considering the base StructureDefinition.
  TFhirStructureDefinitionSnapshot = class (TFhirBackboneElement)
  protected
    FelementList : TFhirElementDefinitionList;
    function GetElementList : TFhirElementDefinitionList;
    function GetHasElementList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirStructureDefinitionSnapshot; overload;
    function Clone : TFhirStructureDefinitionSnapshot; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Captures constraints on each element within the resource.
    property elementList : TFhirElementDefinitionList read GetElementList;
    property hasElementList : boolean read GetHasElementList;

  end;

  TFhirStructureDefinitionSnapshotListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirStructureDefinitionSnapshotList;
    function GetCurrent : TFhirStructureDefinitionSnapshot;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirStructureDefinitionSnapshotList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirStructureDefinitionSnapshot read GetCurrent;
  end;

  TFhirStructureDefinitionSnapshotList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirStructureDefinitionSnapshot;
    procedure SetItemN(index : Integer; value : TFhirStructureDefinitionSnapshot);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirStructureDefinitionSnapshotList; Overload;
    function Clone : TFhirStructureDefinitionSnapshotList; Overload;
    function GetEnumerator : TFhirStructureDefinitionSnapshotListEnumerator;

    //  Add a FhirStructureDefinitionSnapshot to the end of the list.
    function Append : TFhirStructureDefinitionSnapshot;

    // Add an already existing FhirStructureDefinitionSnapshot to the end of the list.
    procedure AddItem(value : TFhirStructureDefinitionSnapshot); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirStructureDefinitionSnapshot) : Integer;

    // Insert FhirStructureDefinitionSnapshot before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirStructureDefinitionSnapshot;

    // Insert an existing FhirStructureDefinitionSnapshot before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirStructureDefinitionSnapshot);

    // Get the iIndexth FhirStructureDefinitionSnapshot. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirStructureDefinitionSnapshot);

    // The number of items in the collection
    function Item(index : Integer) : TFhirStructureDefinitionSnapshot;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirStructureDefinitionSnapshots[index : Integer] : TFhirStructureDefinitionSnapshot read GetItemN write SetItemN; default;
  End;

  // A differential view is expressed relative to the base StructureDefinition - a statement of differences that it applies.
  TFhirStructureDefinitionDifferential = class (TFhirBackboneElement)
  protected
    FelementList : TFhirElementDefinitionList;
    function GetElementList : TFhirElementDefinitionList;
    function GetHasElementList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirStructureDefinitionDifferential; overload;
    function Clone : TFhirStructureDefinitionDifferential; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Captures constraints on each element within the resource.
    property elementList : TFhirElementDefinitionList read GetElementList;
    property hasElementList : boolean read GetHasElementList;

  end;

  TFhirStructureDefinitionDifferentialListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirStructureDefinitionDifferentialList;
    function GetCurrent : TFhirStructureDefinitionDifferential;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirStructureDefinitionDifferentialList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirStructureDefinitionDifferential read GetCurrent;
  end;

  TFhirStructureDefinitionDifferentialList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirStructureDefinitionDifferential;
    procedure SetItemN(index : Integer; value : TFhirStructureDefinitionDifferential);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirStructureDefinitionDifferentialList; Overload;
    function Clone : TFhirStructureDefinitionDifferentialList; Overload;
    function GetEnumerator : TFhirStructureDefinitionDifferentialListEnumerator;

    //  Add a FhirStructureDefinitionDifferential to the end of the list.
    function Append : TFhirStructureDefinitionDifferential;

    // Add an already existing FhirStructureDefinitionDifferential to the end of the list.
    procedure AddItem(value : TFhirStructureDefinitionDifferential); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirStructureDefinitionDifferential) : Integer;

    // Insert FhirStructureDefinitionDifferential before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirStructureDefinitionDifferential;

    // Insert an existing FhirStructureDefinitionDifferential before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirStructureDefinitionDifferential);

    // Get the iIndexth FhirStructureDefinitionDifferential. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirStructureDefinitionDifferential);

    // The number of items in the collection
    function Item(index : Integer) : TFhirStructureDefinitionDifferential;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirStructureDefinitionDifferentials[index : Integer] : TFhirStructureDefinitionDifferential read GetItemN write SetItemN; default;
  End;

  // A definition of a FHIR structure. This resource is used to describe the underlying resources, data types defined in FHIR, and also for describing extensions and constraints on resources and data types.
  TFhirStructureDefinition = class (TFhirMetadataResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FPurpose : TFhirMarkdown;
    FCopyright : TFhirMarkdown;
    FkeywordList : TFhirCodingList;
    FFhirVersion : TFhirId;
    FmappingList : TFhirStructureDefinitionMappingList;
    FKind : TFhirEnum;
    FAbstract : TFhirBoolean;
    FContextType : TFhirEnum;
    FcontextList : TFhirStringList;
    FcontextInvariantList : TFhirStringList;
    FType_ : TFhirCode;
    FBaseDefinition : TFhirUri;
    FDerivation : TFhirEnum;
    FSnapshot : TFhirStructureDefinitionSnapshot;
    FDifferential : TFhirStructureDefinitionDifferential;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetPurpose(value : TFhirMarkdown);
    Function GetPurposeST : String;
    Procedure SetPurposeST(value : String);
    Procedure SetCopyright(value : TFhirMarkdown);
    Function GetCopyrightST : String;
    Procedure SetCopyrightST(value : String);
    function GetKeywordList : TFhirCodingList;
    function GetHasKeywordList : Boolean;
    Procedure SetFhirVersion(value : TFhirId);
    Function GetFhirVersionST : String;
    Procedure SetFhirVersionST(value : String);
    function GetMappingList : TFhirStructureDefinitionMappingList;
    function GetHasMappingList : Boolean;
    Procedure SetKind(value : TFhirEnum);
    Function GetKindST : TFhirStructureDefinitionKindEnum;
    Procedure SetKindST(value : TFhirStructureDefinitionKindEnum);
    Procedure SetAbstract(value : TFhirBoolean);
    Function GetAbstractST : Boolean;
    Procedure SetAbstractST(value : Boolean);
    Procedure SetContextType(value : TFhirEnum);
    Function GetContextTypeST : TFhirExtensionContextEnum;
    Procedure SetContextTypeST(value : TFhirExtensionContextEnum);
    function GetContextList : TFhirStringList;
    function GetHasContextList : Boolean;
    function GetContextInvariantList : TFhirStringList;
    function GetHasContextInvariantList : Boolean;
    Procedure SetType_(value : TFhirCode);
    Function GetType_ST : String;
    Procedure SetType_ST(value : String);
    Procedure SetBaseDefinition(value : TFhirUri);
    Function GetBaseDefinitionST : String;
    Procedure SetBaseDefinitionST(value : String);
    Procedure SetDerivation(value : TFhirEnum);
    Function GetDerivationST : TFhirTypeDerivationRuleEnum;
    Procedure SetDerivationST(value : TFhirTypeDerivationRuleEnum);
    Procedure SetSnapshot(value : TFhirStructureDefinitionSnapshot);
    Procedure SetDifferential(value : TFhirStructureDefinitionDifferential);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirStructureDefinition; overload;
    function Clone : TFhirStructureDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this structure definition when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this structure definition is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the structure definition. For more information see [Technical and Business Versions](resource.html#versions).
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this structure definition when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this structure definition is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the structure definition. For more information see [Technical and Business Versions](resource.html#versions).
    property urlElement : TFhirUri read FUrl write SetUrl;

    // A formal identifier that is used to identify this structure definition when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the structure definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the structure definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the structure definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the structure definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the structure definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the structure definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the structure definition.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the structure definition.
    property titleElement : TFhirString read FTitle write SetTitle;

    // The status of this structure definition. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A boolean value to indicate that this structure definition is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A boolean value to indicate that this structure definition is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The date  (and optionally time) when the structure definition was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the structure definition changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the structure definition was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the structure definition changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the structure definition.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the structure definition.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the structure definition from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the structure definition from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These terms may be used to assist with indexing and searching for appropriate structure definition instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the structure definition is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to Explaination of why this structure definition is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explaination of why this structure definition is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Typed access to A copyright statement relating to the structure definition and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the structure definition.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the structure definition and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the structure definition.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // A set of key words or terms from external terminologies that may be used to assist with indexing and searching of templates.
    property keywordList : TFhirCodingList read GetKeywordList;
    property hasKeywordList : boolean read GetHasKeywordList;

    // Typed access to The version of the FHIR specification on which this StructureDefinition is based - this is the formal version of the specification, without the revision number, e.g. [publication].[major].[minor], which is 3.0.1 for this version.
    property fhirVersion : String read GetFhirVersionST write SetFhirVersionST;
    // The version of the FHIR specification on which this StructureDefinition is based - this is the formal version of the specification, without the revision number, e.g. [publication].[major].[minor], which is 3.0.1 for this version.
    property fhirVersionElement : TFhirId read FFhirVersion write SetFhirVersion;

    // An external specification that the content is mapped to.
    property mappingList : TFhirStructureDefinitionMappingList read GetMappingList;
    property hasMappingList : boolean read GetHasMappingList;

    // Defines the kind of structure that this definition is describing.
    property kind : TFhirStructureDefinitionKindEnum read GetKindST write SetKindST;
    property kindElement : TFhirEnum read FKind write SetKind;

    // Typed access to Whether structure this definition describes is abstract or not  - that is, whether the structure is not intended to be instantiated. For Resources and Data types, abstract types will never be exchanged  between systems.
    property abstract : Boolean read GetAbstractST write SetAbstractST;
    // Whether structure this definition describes is abstract or not  - that is, whether the structure is not intended to be instantiated. For Resources and Data types, abstract types will never be exchanged  between systems.
    property abstractElement : TFhirBoolean read FAbstract write SetAbstract;

    // If this is an extension, Identifies the context within FHIR resources where the extension can be used.
    property contextType : TFhirExtensionContextEnum read GetContextTypeST write SetContextTypeST;
    property contextTypeElement : TFhirEnum read FContextType write SetContextType;

    // Identifies the types of resource or data type elements to which the extension can be applied.
    property contextList : TFhirStringList read GetContextList;
    property hasContextList : boolean read GetHasContextList;

    // A set of rules as Fluent Invariants about when the extension can be used (e.g. co-occurrence variants for the extension).
    property contextInvariantList : TFhirStringList read GetContextInvariantList;
    property hasContextInvariantList : boolean read GetHasContextInvariantList;

    // Typed access to The type this structure describes. If the derivation kind is 'specialization' then this is the master definition for a type, and there is always one of these (a data type, an extension, a resource, including abstract ones). Otherwise the structure definition is a constraint on the stated type (and in this case, the type cannot be an abstract type).
    property type_ : String read GetType_ST write SetType_ST;
    // The type this structure describes. If the derivation kind is 'specialization' then this is the master definition for a type, and there is always one of these (a data type, an extension, a resource, including abstract ones). Otherwise the structure definition is a constraint on the stated type (and in this case, the type cannot be an abstract type).
    property type_Element : TFhirCode read FType_ write SetType_;

    // Typed access to An absolute URI that is the base structure from which this type is derived, either by specialization or constraint.
    property baseDefinition : String read GetBaseDefinitionST write SetBaseDefinitionST;
    // An absolute URI that is the base structure from which this type is derived, either by specialization or constraint.
    property baseDefinitionElement : TFhirUri read FBaseDefinition write SetBaseDefinition;

    // How the type relates to the baseDefinition.
    property derivation : TFhirTypeDerivationRuleEnum read GetDerivationST write SetDerivationST;
    property derivationElement : TFhirEnum read FDerivation write SetDerivation;

    // Typed access to A snapshot view is expressed in a stand alone form that can be used and interpreted without considering the base StructureDefinition. (defined for API consistency)
    property snapshot : TFhirStructureDefinitionSnapshot read FSnapshot write SetSnapshot;
    // A snapshot view is expressed in a stand alone form that can be used and interpreted without considering the base StructureDefinition.
    property snapshotElement : TFhirStructureDefinitionSnapshot read FSnapshot write SetSnapshot;

    // Typed access to A differential view is expressed relative to the base StructureDefinition - a statement of differences that it applies. (defined for API consistency)
    property differential : TFhirStructureDefinitionDifferential read FDifferential write SetDifferential;
    // A differential view is expressed relative to the base StructureDefinition - a statement of differences that it applies.
    property differentialElement : TFhirStructureDefinitionDifferential read FDifferential write SetDifferential;

  end;

  TFhirStructureDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirStructureDefinitionList;
    function GetCurrent : TFhirStructureDefinition;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirStructureDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirStructureDefinition read GetCurrent;
  end;

  TFhirStructureDefinitionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirStructureDefinition;
    procedure SetItemN(index : Integer; value : TFhirStructureDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirStructureDefinitionList; Overload;
    function Clone : TFhirStructureDefinitionList; Overload;
    function GetEnumerator : TFhirStructureDefinitionListEnumerator;

    //  Add a FhirStructureDefinition to the end of the list.
    function Append : TFhirStructureDefinition;

    // Add an already existing FhirStructureDefinition to the end of the list.
    procedure AddItem(value : TFhirStructureDefinition); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirStructureDefinition) : Integer;

    // Insert FhirStructureDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirStructureDefinition;

    // Insert an existing FhirStructureDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirStructureDefinition);

    // Get the iIndexth FhirStructureDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirStructureDefinition);

    // The number of items in the collection
    function Item(index : Integer) : TFhirStructureDefinition;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirStructureDefinitions[index : Integer] : TFhirStructureDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_STRUCTUREDEFINITION}

{$IFDEF FHIR_STRUCTUREMAP}

  // A structure definition used by this map. The structure definition may describe instances that are converted, or the instances that are produced.
  TFhirStructureMapStructure = class (TFhirBackboneElement)
  protected
    FUrl : TFhirUri;
    FMode : TFhirEnum;
    FAlias : TFhirString;
    FDocumentation : TFhirString;
    Procedure SetUrl(value : TFhirUri);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);
    Procedure SetMode(value : TFhirEnum);
    Function GetModeST : TFhirMapModelModeEnum;
    Procedure SetModeST(value : TFhirMapModelModeEnum);
    Procedure SetAlias(value : TFhirString);
    Function GetAliasST : String;
    Procedure SetAliasST(value : String);
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirStructureMapStructure; overload;
    function Clone : TFhirStructureMapStructure; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The canonical URL that identifies the structure.
    property url : String read GetUrlST write SetUrlST;
    // The canonical URL that identifies the structure.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // How the referenced structure is used in this mapping.
    property mode : TFhirMapModelModeEnum read GetModeST write SetModeST;
    property modeElement : TFhirEnum read FMode write SetMode;

    // Typed access to The name used for this type in the map.
    property alias : String read GetAliasST write SetAliasST;
    // The name used for this type in the map.
    property aliasElement : TFhirString read FAlias write SetAlias;

    // Typed access to Documentation that describes how the structure is used in the mapping.
    property documentation : String read GetDocumentationST write SetDocumentationST;
    // Documentation that describes how the structure is used in the mapping.
    property documentationElement : TFhirString read FDocumentation write SetDocumentation;

  end;

  TFhirStructureMapStructureListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirStructureMapStructureList;
    function GetCurrent : TFhirStructureMapStructure;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirStructureMapStructureList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirStructureMapStructure read GetCurrent;
  end;

  TFhirStructureMapStructureList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirStructureMapStructure;
    procedure SetItemN(index : Integer; value : TFhirStructureMapStructure);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirStructureMapStructureList; Overload;
    function Clone : TFhirStructureMapStructureList; Overload;
    function GetEnumerator : TFhirStructureMapStructureListEnumerator;

    //  Add a FhirStructureMapStructure to the end of the list.
    function Append : TFhirStructureMapStructure;

    // Add an already existing FhirStructureMapStructure to the end of the list.
    procedure AddItem(value : TFhirStructureMapStructure); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirStructureMapStructure) : Integer;

    // Insert FhirStructureMapStructure before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirStructureMapStructure;

    // Insert an existing FhirStructureMapStructure before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirStructureMapStructure);

    // Get the iIndexth FhirStructureMapStructure. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirStructureMapStructure);

    // The number of items in the collection
    function Item(index : Integer) : TFhirStructureMapStructure;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirStructureMapStructures[index : Integer] : TFhirStructureMapStructure read GetItemN write SetItemN; default;
  End;

  // Organizes the mapping into managable chunks for human review/ease of maintenance.
  TFhirStructureMapGroup = class (TFhirBackboneElement)
  protected
    FName : TFhirId;
    FExtends : TFhirId;
    FTypeMode : TFhirEnum;
    FDocumentation : TFhirString;
    FinputList : TFhirStructureMapGroupInputList;
    FruleList : TFhirStructureMapGroupRuleList;
    Procedure SetName(value : TFhirId);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetExtends(value : TFhirId);
    Function GetExtendsST : String;
    Procedure SetExtendsST(value : String);
    Procedure SetTypeMode(value : TFhirEnum);
    Function GetTypeModeST : TFhirMapGroupTypeModeEnum;
    Procedure SetTypeModeST(value : TFhirMapGroupTypeModeEnum);
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);
    function GetInputList : TFhirStructureMapGroupInputList;
    function GetHasInputList : Boolean;
    function GetRuleList : TFhirStructureMapGroupRuleList;
    function GetHasRuleList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirStructureMapGroup; overload;
    function Clone : TFhirStructureMapGroup; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A unique name for the group for the convenience of human readers.
    property name : String read GetNameST write SetNameST;
    // A unique name for the group for the convenience of human readers.
    property nameElement : TFhirId read FName write SetName;

    // Typed access to Another group that this group adds rules to.
    property extends : String read GetExtendsST write SetExtendsST;
    // Another group that this group adds rules to.
    property extendsElement : TFhirId read FExtends write SetExtends;

    // If this is the default rule set to apply for thie source type, or this combination of types.
    property typeMode : TFhirMapGroupTypeModeEnum read GetTypeModeST write SetTypeModeST;
    property typeModeElement : TFhirEnum read FTypeMode write SetTypeMode;

    // Typed access to Additional supporting documentation that explains the purpose of the group and the types of mappings within it.
    property documentation : String read GetDocumentationST write SetDocumentationST;
    // Additional supporting documentation that explains the purpose of the group and the types of mappings within it.
    property documentationElement : TFhirString read FDocumentation write SetDocumentation;

    // A name assigned to an instance of data. The instance must be provided when the mapping is invoked.
    property inputList : TFhirStructureMapGroupInputList read GetInputList;
    property hasInputList : boolean read GetHasInputList;

    // Transform Rule from source to target.
    property ruleList : TFhirStructureMapGroupRuleList read GetRuleList;
    property hasRuleList : boolean read GetHasRuleList;

  end;

  TFhirStructureMapGroupListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirStructureMapGroupList;
    function GetCurrent : TFhirStructureMapGroup;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirStructureMapGroupList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirStructureMapGroup read GetCurrent;
  end;

  TFhirStructureMapGroupList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirStructureMapGroup;
    procedure SetItemN(index : Integer; value : TFhirStructureMapGroup);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirStructureMapGroupList; Overload;
    function Clone : TFhirStructureMapGroupList; Overload;
    function GetEnumerator : TFhirStructureMapGroupListEnumerator;

    //  Add a FhirStructureMapGroup to the end of the list.
    function Append : TFhirStructureMapGroup;

    // Add an already existing FhirStructureMapGroup to the end of the list.
    procedure AddItem(value : TFhirStructureMapGroup); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirStructureMapGroup) : Integer;

    // Insert FhirStructureMapGroup before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirStructureMapGroup;

    // Insert an existing FhirStructureMapGroup before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirStructureMapGroup);

    // Get the iIndexth FhirStructureMapGroup. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirStructureMapGroup);

    // The number of items in the collection
    function Item(index : Integer) : TFhirStructureMapGroup;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirStructureMapGroups[index : Integer] : TFhirStructureMapGroup read GetItemN write SetItemN; default;
  End;

  // A name assigned to an instance of data. The instance must be provided when the mapping is invoked.
  TFhirStructureMapGroupInput = class (TFhirBackboneElement)
  protected
    FName : TFhirId;
    FType_ : TFhirString;
    FMode : TFhirEnum;
    FDocumentation : TFhirString;
    Procedure SetName(value : TFhirId);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetType_(value : TFhirString);
    Function GetType_ST : String;
    Procedure SetType_ST(value : String);
    Procedure SetMode(value : TFhirEnum);
    Function GetModeST : TFhirMapInputModeEnum;
    Procedure SetModeST(value : TFhirMapInputModeEnum);
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirStructureMapGroupInput; overload;
    function Clone : TFhirStructureMapGroupInput; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Name for this instance of data.
    property name : String read GetNameST write SetNameST;
    // Name for this instance of data.
    property nameElement : TFhirId read FName write SetName;

    // Typed access to Type for this instance of data.
    property type_ : String read GetType_ST write SetType_ST;
    // Type for this instance of data.
    property type_Element : TFhirString read FType_ write SetType_;

    // Mode for this instance of data.
    property mode : TFhirMapInputModeEnum read GetModeST write SetModeST;
    property modeElement : TFhirEnum read FMode write SetMode;

    // Typed access to Documentation for this instance of data.
    property documentation : String read GetDocumentationST write SetDocumentationST;
    // Documentation for this instance of data.
    property documentationElement : TFhirString read FDocumentation write SetDocumentation;

  end;

  TFhirStructureMapGroupInputListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirStructureMapGroupInputList;
    function GetCurrent : TFhirStructureMapGroupInput;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirStructureMapGroupInputList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirStructureMapGroupInput read GetCurrent;
  end;

  TFhirStructureMapGroupInputList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirStructureMapGroupInput;
    procedure SetItemN(index : Integer; value : TFhirStructureMapGroupInput);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirStructureMapGroupInputList; Overload;
    function Clone : TFhirStructureMapGroupInputList; Overload;
    function GetEnumerator : TFhirStructureMapGroupInputListEnumerator;

    //  Add a FhirStructureMapGroupInput to the end of the list.
    function Append : TFhirStructureMapGroupInput;

    // Add an already existing FhirStructureMapGroupInput to the end of the list.
    procedure AddItem(value : TFhirStructureMapGroupInput); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirStructureMapGroupInput) : Integer;

    // Insert FhirStructureMapGroupInput before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirStructureMapGroupInput;

    // Insert an existing FhirStructureMapGroupInput before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirStructureMapGroupInput);

    // Get the iIndexth FhirStructureMapGroupInput. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirStructureMapGroupInput);

    // The number of items in the collection
    function Item(index : Integer) : TFhirStructureMapGroupInput;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirStructureMapGroupInputs[index : Integer] : TFhirStructureMapGroupInput read GetItemN write SetItemN; default;
  End;

  // Transform Rule from source to target.
  TFhirStructureMapGroupRule = class (TFhirBackboneElement)
  protected
    FName : TFhirId;
    FsourceList : TFhirStructureMapGroupRuleSourceList;
    FtargetList : TFhirStructureMapGroupRuleTargetList;
    FruleList : TFhirStructureMapGroupRuleList;
    FdependentList : TFhirStructureMapGroupRuleDependentList;
    FDocumentation : TFhirString;
    Procedure SetName(value : TFhirId);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    function GetSourceList : TFhirStructureMapGroupRuleSourceList;
    function GetHasSourceList : Boolean;
    function GetTargetList : TFhirStructureMapGroupRuleTargetList;
    function GetHasTargetList : Boolean;
    function GetRuleList : TFhirStructureMapGroupRuleList;
    function GetHasRuleList : Boolean;
    function GetDependentList : TFhirStructureMapGroupRuleDependentList;
    function GetHasDependentList : Boolean;
    Procedure SetDocumentation(value : TFhirString);
    Function GetDocumentationST : String;
    Procedure SetDocumentationST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirStructureMapGroupRule; overload;
    function Clone : TFhirStructureMapGroupRule; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Name of the rule for internal references.
    property name : String read GetNameST write SetNameST;
    // Name of the rule for internal references.
    property nameElement : TFhirId read FName write SetName;

    // Source inputs to the mapping.
    property sourceList : TFhirStructureMapGroupRuleSourceList read GetSourceList;
    property hasSourceList : boolean read GetHasSourceList;

    // Content to create because of this mapping rule.
    property targetList : TFhirStructureMapGroupRuleTargetList read GetTargetList;
    property hasTargetList : boolean read GetHasTargetList;

    // Rules contained in this rule.
    property ruleList : TFhirStructureMapGroupRuleList read GetRuleList;
    property hasRuleList : boolean read GetHasRuleList;

    // Which other rules to apply in the context of this rule.
    property dependentList : TFhirStructureMapGroupRuleDependentList read GetDependentList;
    property hasDependentList : boolean read GetHasDependentList;

    // Typed access to Documentation for this instance of data.
    property documentation : String read GetDocumentationST write SetDocumentationST;
    // Documentation for this instance of data.
    property documentationElement : TFhirString read FDocumentation write SetDocumentation;

  end;

  TFhirStructureMapGroupRuleListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirStructureMapGroupRuleList;
    function GetCurrent : TFhirStructureMapGroupRule;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirStructureMapGroupRuleList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirStructureMapGroupRule read GetCurrent;
  end;

  TFhirStructureMapGroupRuleList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirStructureMapGroupRule;
    procedure SetItemN(index : Integer; value : TFhirStructureMapGroupRule);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirStructureMapGroupRuleList; Overload;
    function Clone : TFhirStructureMapGroupRuleList; Overload;
    function GetEnumerator : TFhirStructureMapGroupRuleListEnumerator;

    //  Add a FhirStructureMapGroupRule to the end of the list.
    function Append : TFhirStructureMapGroupRule;

    // Add an already existing FhirStructureMapGroupRule to the end of the list.
    procedure AddItem(value : TFhirStructureMapGroupRule); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirStructureMapGroupRule) : Integer;

    // Insert FhirStructureMapGroupRule before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirStructureMapGroupRule;

    // Insert an existing FhirStructureMapGroupRule before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirStructureMapGroupRule);

    // Get the iIndexth FhirStructureMapGroupRule. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirStructureMapGroupRule);

    // The number of items in the collection
    function Item(index : Integer) : TFhirStructureMapGroupRule;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirStructureMapGroupRules[index : Integer] : TFhirStructureMapGroupRule read GetItemN write SetItemN; default;
  End;

  // Source inputs to the mapping.
  TFhirStructureMapGroupRuleSource = class (TFhirBackboneElement)
  protected
    FContext : TFhirId;
    FMin : TFhirInteger;
    FMax : TFhirString;
    FType_ : TFhirString;
    FDefaultValue : TFhirType;
    FElement : TFhirString;
    FListMode : TFhirEnum;
    FVariable : TFhirId;
    FCondition : TFhirString;
    FCheck : TFhirString;
    Procedure SetContext(value : TFhirId);
    Function GetContextST : String;
    Procedure SetContextST(value : String);
    Procedure SetMin(value : TFhirInteger);
    Function GetMinST : String;
    Procedure SetMinST(value : String);
    Procedure SetMax(value : TFhirString);
    Function GetMaxST : String;
    Procedure SetMaxST(value : String);
    Procedure SetType_(value : TFhirString);
    Function GetType_ST : String;
    Procedure SetType_ST(value : String);
    Procedure SetDefaultValue(value : TFhirType);
    Procedure SetElement(value : TFhirString);
    Function GetElementST : String;
    Procedure SetElementST(value : String);
    Procedure SetListMode(value : TFhirEnum);
    Function GetListModeST : TFhirMapSourceListModeEnum;
    Procedure SetListModeST(value : TFhirMapSourceListModeEnum);
    Procedure SetVariable(value : TFhirId);
    Function GetVariableST : String;
    Procedure SetVariableST(value : String);
    Procedure SetCondition(value : TFhirString);
    Function GetConditionST : String;
    Procedure SetConditionST(value : String);
    Procedure SetCheck(value : TFhirString);
    Function GetCheckST : String;
    Procedure SetCheckST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirStructureMapGroupRuleSource; overload;
    function Clone : TFhirStructureMapGroupRuleSource; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Type or variable this rule applies to.
    property context : String read GetContextST write SetContextST;
    // Type or variable this rule applies to.
    property contextElement : TFhirId read FContext write SetContext;

    // Typed access to Specified minimum cardinality for the element. This is optional; if present, it acts an implicit check on the input content.
    property min : String read GetMinST write SetMinST;
    // Specified minimum cardinality for the element. This is optional; if present, it acts an implicit check on the input content.
    property minElement : TFhirInteger read FMin write SetMin;

    // Typed access to Specified maximum cardinality for the element - a number or a "*". This is optional; if present, it acts an implicit check on the input content (* just serves as documentation; it's the default value).
    property max : String read GetMaxST write SetMaxST;
    // Specified maximum cardinality for the element - a number or a "*". This is optional; if present, it acts an implicit check on the input content (* just serves as documentation; it's the default value).
    property maxElement : TFhirString read FMax write SetMax;

    // Typed access to Specified type for the element. This works as a condition on the mapping - use for polymorphic elements.
    property type_ : String read GetType_ST write SetType_ST;
    // Specified type for the element. This works as a condition on the mapping - use for polymorphic elements.
    property type_Element : TFhirString read FType_ write SetType_;

    // Typed access to A value to use if there is no existing value in the source object. (defined for API consistency)
    property defaultValue : TFhirType read FDefaultValue write SetDefaultValue;
    // A value to use if there is no existing value in the source object.
    property defaultValueElement : TFhirType read FDefaultValue write SetDefaultValue;

    // Typed access to Optional field for this source.
    property element : String read GetElementST write SetElementST;
    // Optional field for this source.
    property elementElement : TFhirString read FElement write SetElement;

    // How to handle the list mode for this element.
    property listMode : TFhirMapSourceListModeEnum read GetListModeST write SetListModeST;
    property listModeElement : TFhirEnum read FListMode write SetListMode;

    // Typed access to Named context for field, if a field is specified.
    property variable : String read GetVariableST write SetVariableST;
    // Named context for field, if a field is specified.
    property variableElement : TFhirId read FVariable write SetVariable;

    // Typed access to FHIRPath expression  - must be true or the rule does not apply.
    property condition : String read GetConditionST write SetConditionST;
    // FHIRPath expression  - must be true or the rule does not apply.
    property conditionElement : TFhirString read FCondition write SetCondition;

    // Typed access to FHIRPath expression  - must be true or the mapping engine throws an error instead of completing.
    property check : String read GetCheckST write SetCheckST;
    // FHIRPath expression  - must be true or the mapping engine throws an error instead of completing.
    property checkElement : TFhirString read FCheck write SetCheck;

  end;

  TFhirStructureMapGroupRuleSourceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirStructureMapGroupRuleSourceList;
    function GetCurrent : TFhirStructureMapGroupRuleSource;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirStructureMapGroupRuleSourceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirStructureMapGroupRuleSource read GetCurrent;
  end;

  TFhirStructureMapGroupRuleSourceList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirStructureMapGroupRuleSource;
    procedure SetItemN(index : Integer; value : TFhirStructureMapGroupRuleSource);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirStructureMapGroupRuleSourceList; Overload;
    function Clone : TFhirStructureMapGroupRuleSourceList; Overload;
    function GetEnumerator : TFhirStructureMapGroupRuleSourceListEnumerator;

    //  Add a FhirStructureMapGroupRuleSource to the end of the list.
    function Append : TFhirStructureMapGroupRuleSource;

    // Add an already existing FhirStructureMapGroupRuleSource to the end of the list.
    procedure AddItem(value : TFhirStructureMapGroupRuleSource); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirStructureMapGroupRuleSource) : Integer;

    // Insert FhirStructureMapGroupRuleSource before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirStructureMapGroupRuleSource;

    // Insert an existing FhirStructureMapGroupRuleSource before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirStructureMapGroupRuleSource);

    // Get the iIndexth FhirStructureMapGroupRuleSource. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirStructureMapGroupRuleSource);

    // The number of items in the collection
    function Item(index : Integer) : TFhirStructureMapGroupRuleSource;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirStructureMapGroupRuleSources[index : Integer] : TFhirStructureMapGroupRuleSource read GetItemN write SetItemN; default;
  End;

  // Content to create because of this mapping rule.
  TFhirStructureMapGroupRuleTarget = class (TFhirBackboneElement)
  protected
    FContext : TFhirId;
    FContextType : TFhirEnum;
    FElement : TFhirString;
    FVariable : TFhirId;
    FListMode : TFhirEnumList;
    FListRuleId : TFhirId;
    FTransform : TFhirEnum;
    FparameterList : TFhirStructureMapGroupRuleTargetParameterList;
    Procedure SetContext(value : TFhirId);
    Function GetContextST : String;
    Procedure SetContextST(value : String);
    Procedure SetContextType(value : TFhirEnum);
    Function GetContextTypeST : TFhirMapContextTypeEnum;
    Procedure SetContextTypeST(value : TFhirMapContextTypeEnum);
    Procedure SetElement(value : TFhirString);
    Function GetElementST : String;
    Procedure SetElementST(value : String);
    Procedure SetVariable(value : TFhirId);
    Function GetVariableST : String;
    Procedure SetVariableST(value : String);
    function GetListMode : TFhirEnumList;
    function GetHasListMode : Boolean;
    Function GetListModeST : TFhirMapTargetListModeEnumList;
    Procedure SetListModeST(value : TFhirMapTargetListModeEnumList);
    Procedure SetListRuleId(value : TFhirId);
    Function GetListRuleIdST : String;
    Procedure SetListRuleIdST(value : String);
    Procedure SetTransform(value : TFhirEnum);
    Function GetTransformST : TFhirMapTransformEnum;
    Procedure SetTransformST(value : TFhirMapTransformEnum);
    function GetParameterList : TFhirStructureMapGroupRuleTargetParameterList;
    function GetHasParameterList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirStructureMapGroupRuleTarget; overload;
    function Clone : TFhirStructureMapGroupRuleTarget; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Type or variable this rule applies to.
    property context : String read GetContextST write SetContextST;
    // Type or variable this rule applies to.
    property contextElement : TFhirId read FContext write SetContext;

    // How to interpret the context.
    property contextType : TFhirMapContextTypeEnum read GetContextTypeST write SetContextTypeST;
    property contextTypeElement : TFhirEnum read FContextType write SetContextType;

    // Typed access to Field to create in the context.
    property element : String read GetElementST write SetElementST;
    // Field to create in the context.
    property elementElement : TFhirString read FElement write SetElement;

    // Typed access to Named context for field, if desired, and a field is specified.
    property variable : String read GetVariableST write SetVariableST;
    // Named context for field, if desired, and a field is specified.
    property variableElement : TFhirId read FVariable write SetVariable;

    // If field is a list, how to manage the list.
    property listMode : TFhirMapTargetListModeEnumList read GetListModeST write SetListModeST;
    property listModeList : TFhirEnumList read GetListMode;
    property hasListMode : boolean read GetHasListMode;
    // Typed access to Internal rule reference for shared list items.
    property listRuleId : String read GetListRuleIdST write SetListRuleIdST;
    // Internal rule reference for shared list items.
    property listRuleIdElement : TFhirId read FListRuleId write SetListRuleId;

    // How the data is copied / created.
    property transform : TFhirMapTransformEnum read GetTransformST write SetTransformST;
    property transformElement : TFhirEnum read FTransform write SetTransform;

    // Parameters to the transform.
    property parameterList : TFhirStructureMapGroupRuleTargetParameterList read GetParameterList;
    property hasParameterList : boolean read GetHasParameterList;

  end;

  TFhirStructureMapGroupRuleTargetListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirStructureMapGroupRuleTargetList;
    function GetCurrent : TFhirStructureMapGroupRuleTarget;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirStructureMapGroupRuleTargetList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirStructureMapGroupRuleTarget read GetCurrent;
  end;

  TFhirStructureMapGroupRuleTargetList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirStructureMapGroupRuleTarget;
    procedure SetItemN(index : Integer; value : TFhirStructureMapGroupRuleTarget);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirStructureMapGroupRuleTargetList; Overload;
    function Clone : TFhirStructureMapGroupRuleTargetList; Overload;
    function GetEnumerator : TFhirStructureMapGroupRuleTargetListEnumerator;

    //  Add a FhirStructureMapGroupRuleTarget to the end of the list.
    function Append : TFhirStructureMapGroupRuleTarget;

    // Add an already existing FhirStructureMapGroupRuleTarget to the end of the list.
    procedure AddItem(value : TFhirStructureMapGroupRuleTarget); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirStructureMapGroupRuleTarget) : Integer;

    // Insert FhirStructureMapGroupRuleTarget before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirStructureMapGroupRuleTarget;

    // Insert an existing FhirStructureMapGroupRuleTarget before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirStructureMapGroupRuleTarget);

    // Get the iIndexth FhirStructureMapGroupRuleTarget. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirStructureMapGroupRuleTarget);

    // The number of items in the collection
    function Item(index : Integer) : TFhirStructureMapGroupRuleTarget;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirStructureMapGroupRuleTargets[index : Integer] : TFhirStructureMapGroupRuleTarget read GetItemN write SetItemN; default;
  End;

  // Parameters to the transform.
  TFhirStructureMapGroupRuleTargetParameter = class (TFhirBackboneElement)
  protected
    FValue : TFhirType;
    Procedure SetValue(value : TFhirType);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirStructureMapGroupRuleTargetParameter; overload;
    function Clone : TFhirStructureMapGroupRuleTargetParameter; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Parameter value - variable or literal. (defined for API consistency)
    property value : TFhirType read FValue write SetValue;
    // Parameter value - variable or literal.
    property valueElement : TFhirType read FValue write SetValue;

  end;

  TFhirStructureMapGroupRuleTargetParameterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirStructureMapGroupRuleTargetParameterList;
    function GetCurrent : TFhirStructureMapGroupRuleTargetParameter;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirStructureMapGroupRuleTargetParameterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirStructureMapGroupRuleTargetParameter read GetCurrent;
  end;

  TFhirStructureMapGroupRuleTargetParameterList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirStructureMapGroupRuleTargetParameter;
    procedure SetItemN(index : Integer; value : TFhirStructureMapGroupRuleTargetParameter);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirStructureMapGroupRuleTargetParameterList; Overload;
    function Clone : TFhirStructureMapGroupRuleTargetParameterList; Overload;
    function GetEnumerator : TFhirStructureMapGroupRuleTargetParameterListEnumerator;

    //  Add a FhirStructureMapGroupRuleTargetParameter to the end of the list.
    function Append : TFhirStructureMapGroupRuleTargetParameter;

    // Add an already existing FhirStructureMapGroupRuleTargetParameter to the end of the list.
    procedure AddItem(value : TFhirStructureMapGroupRuleTargetParameter); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirStructureMapGroupRuleTargetParameter) : Integer;

    // Insert FhirStructureMapGroupRuleTargetParameter before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirStructureMapGroupRuleTargetParameter;

    // Insert an existing FhirStructureMapGroupRuleTargetParameter before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirStructureMapGroupRuleTargetParameter);

    // Get the iIndexth FhirStructureMapGroupRuleTargetParameter. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirStructureMapGroupRuleTargetParameter);

    // The number of items in the collection
    function Item(index : Integer) : TFhirStructureMapGroupRuleTargetParameter;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirStructureMapGroupRuleTargetParameters[index : Integer] : TFhirStructureMapGroupRuleTargetParameter read GetItemN write SetItemN; default;
  End;

  // Which other rules to apply in the context of this rule.
  TFhirStructureMapGroupRuleDependent = class (TFhirBackboneElement)
  protected
    FName : TFhirId;
    FvariableList : TFhirStringList;
    Procedure SetName(value : TFhirId);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    function GetVariableList : TFhirStringList;
    function GetHasVariableList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirStructureMapGroupRuleDependent; overload;
    function Clone : TFhirStructureMapGroupRuleDependent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Name of a rule or group to apply.
    property name : String read GetNameST write SetNameST;
    // Name of a rule or group to apply.
    property nameElement : TFhirId read FName write SetName;

    // Variable to pass to the rule or group.
    property variableList : TFhirStringList read GetVariableList;
    property hasVariableList : boolean read GetHasVariableList;

  end;

  TFhirStructureMapGroupRuleDependentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirStructureMapGroupRuleDependentList;
    function GetCurrent : TFhirStructureMapGroupRuleDependent;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirStructureMapGroupRuleDependentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirStructureMapGroupRuleDependent read GetCurrent;
  end;

  TFhirStructureMapGroupRuleDependentList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirStructureMapGroupRuleDependent;
    procedure SetItemN(index : Integer; value : TFhirStructureMapGroupRuleDependent);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirStructureMapGroupRuleDependentList; Overload;
    function Clone : TFhirStructureMapGroupRuleDependentList; Overload;
    function GetEnumerator : TFhirStructureMapGroupRuleDependentListEnumerator;

    //  Add a FhirStructureMapGroupRuleDependent to the end of the list.
    function Append : TFhirStructureMapGroupRuleDependent;

    // Add an already existing FhirStructureMapGroupRuleDependent to the end of the list.
    procedure AddItem(value : TFhirStructureMapGroupRuleDependent); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirStructureMapGroupRuleDependent) : Integer;

    // Insert FhirStructureMapGroupRuleDependent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirStructureMapGroupRuleDependent;

    // Insert an existing FhirStructureMapGroupRuleDependent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirStructureMapGroupRuleDependent);

    // Get the iIndexth FhirStructureMapGroupRuleDependent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirStructureMapGroupRuleDependent);

    // The number of items in the collection
    function Item(index : Integer) : TFhirStructureMapGroupRuleDependent;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirStructureMapGroupRuleDependents[index : Integer] : TFhirStructureMapGroupRuleDependent read GetItemN write SetItemN; default;
  End;

  // A Map of relationships between 2 structures that can be used to transform data.
  TFhirStructureMap = class (TFhirMetadataResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FPurpose : TFhirMarkdown;
    FCopyright : TFhirMarkdown;
    FstructureList : TFhirStructureMapStructureList;
    FimportList : TFhirUriList;
    FgroupList : TFhirStructureMapGroupList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetPurpose(value : TFhirMarkdown);
    Function GetPurposeST : String;
    Procedure SetPurposeST(value : String);
    Procedure SetCopyright(value : TFhirMarkdown);
    Function GetCopyrightST : String;
    Procedure SetCopyrightST(value : String);
    function GetStructureList : TFhirStructureMapStructureList;
    function GetHasStructureList : Boolean;
    function GetImportList : TFhirUriList;
    function GetHasImportList : Boolean;
    function GetGroupList : TFhirStructureMapGroupList;
    function GetHasGroupList : Boolean;

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirStructureMap; overload;
    function Clone : TFhirStructureMap; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this structure map when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this structure map is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the structure map. For more information see [Technical and Business Versions](resource.html#versions).
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this structure map when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this structure map is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the structure map. For more information see [Technical and Business Versions](resource.html#versions).
    property urlElement : TFhirUri read FUrl write SetUrl;

    // A formal identifier that is used to identify this structure map when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the structure map when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the structure map author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the structure map when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the structure map author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the structure map. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the structure map. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the structure map.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the structure map.
    property titleElement : TFhirString read FTitle write SetTitle;

    // The status of this structure map. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A boolean value to indicate that this structure map is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A boolean value to indicate that this structure map is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The date  (and optionally time) when the structure map was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the structure map changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the structure map was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the structure map changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the structure map.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the structure map.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the structure map from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the structure map from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These terms may be used to assist with indexing and searching for appropriate structure map instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the structure map is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to Explaination of why this structure map is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explaination of why this structure map is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Typed access to A copyright statement relating to the structure map and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the structure map.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the structure map and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the structure map.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // A structure definition used by this map. The structure definition may describe instances that are converted, or the instances that are produced.
    property structureList : TFhirStructureMapStructureList read GetStructureList;
    property hasStructureList : boolean read GetHasStructureList;

    // Other maps used by this map (canonical URLs).
    property importList : TFhirUriList read GetImportList;
    property hasImportList : boolean read GetHasImportList;

    // Organizes the mapping into managable chunks for human review/ease of maintenance.
    property groupList : TFhirStructureMapGroupList read GetGroupList;
    property hasGroupList : boolean read GetHasGroupList;

  end;

  TFhirStructureMapListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirStructureMapList;
    function GetCurrent : TFhirStructureMap;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirStructureMapList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirStructureMap read GetCurrent;
  end;

  TFhirStructureMapList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirStructureMap;
    procedure SetItemN(index : Integer; value : TFhirStructureMap);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirStructureMapList; Overload;
    function Clone : TFhirStructureMapList; Overload;
    function GetEnumerator : TFhirStructureMapListEnumerator;

    //  Add a FhirStructureMap to the end of the list.
    function Append : TFhirStructureMap;

    // Add an already existing FhirStructureMap to the end of the list.
    procedure AddItem(value : TFhirStructureMap); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirStructureMap) : Integer;

    // Insert FhirStructureMap before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirStructureMap;

    // Insert an existing FhirStructureMap before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirStructureMap);

    // Get the iIndexth FhirStructureMap. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirStructureMap);

    // The number of items in the collection
    function Item(index : Integer) : TFhirStructureMap;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirStructureMaps[index : Integer] : TFhirStructureMap read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_STRUCTUREMAP}

{$IFDEF FHIR_TESTSCRIPT}

  // An abstract server used in operations within this test script in the origin element.
  TFhirTestScriptOrigin = class (TFhirBackboneElement)
  protected
    FIndex : TFhirInteger;
    FProfile : TFhirCoding;
    Procedure SetIndex(value : TFhirInteger);
    Function GetIndexST : String;
    Procedure SetIndexST(value : String);
    Procedure SetProfile(value : TFhirCoding);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptOrigin; overload;
    function Clone : TFhirTestScriptOrigin; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Abstract name given to an origin server in this test script.  The name is provided as a number starting at 1.
    property index : String read GetIndexST write SetIndexST;
    // Abstract name given to an origin server in this test script.  The name is provided as a number starting at 1.
    property indexElement : TFhirInteger read FIndex write SetIndex;

    // Typed access to The type of origin profile the test system supports. (defined for API consistency)
    property profile : TFhirCoding read FProfile write SetProfile;
    // The type of origin profile the test system supports.
    property profileElement : TFhirCoding read FProfile write SetProfile;

  end;

  TFhirTestScriptOriginListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptOriginList;
    function GetCurrent : TFhirTestScriptOrigin;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptOriginList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptOrigin read GetCurrent;
  end;

  TFhirTestScriptOriginList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScriptOrigin;
    procedure SetItemN(index : Integer; value : TFhirTestScriptOrigin);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptOriginList; Overload;
    function Clone : TFhirTestScriptOriginList; Overload;
    function GetEnumerator : TFhirTestScriptOriginListEnumerator;

    //  Add a FhirTestScriptOrigin to the end of the list.
    function Append : TFhirTestScriptOrigin;

    // Add an already existing FhirTestScriptOrigin to the end of the list.
    procedure AddItem(value : TFhirTestScriptOrigin); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptOrigin) : Integer;

    // Insert FhirTestScriptOrigin before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptOrigin;

    // Insert an existing FhirTestScriptOrigin before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptOrigin);

    // Get the iIndexth FhirTestScriptOrigin. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptOrigin);

    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptOrigin;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirTestScriptOrigins[index : Integer] : TFhirTestScriptOrigin read GetItemN write SetItemN; default;
  End;

  // An abstract server used in operations within this test script in the destination element.
  TFhirTestScriptDestination = class (TFhirBackboneElement)
  protected
    FIndex : TFhirInteger;
    FProfile : TFhirCoding;
    Procedure SetIndex(value : TFhirInteger);
    Function GetIndexST : String;
    Procedure SetIndexST(value : String);
    Procedure SetProfile(value : TFhirCoding);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptDestination; overload;
    function Clone : TFhirTestScriptDestination; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Abstract name given to a destination server in this test script.  The name is provided as a number starting at 1.
    property index : String read GetIndexST write SetIndexST;
    // Abstract name given to a destination server in this test script.  The name is provided as a number starting at 1.
    property indexElement : TFhirInteger read FIndex write SetIndex;

    // Typed access to The type of destination profile the test system supports. (defined for API consistency)
    property profile : TFhirCoding read FProfile write SetProfile;
    // The type of destination profile the test system supports.
    property profileElement : TFhirCoding read FProfile write SetProfile;

  end;

  TFhirTestScriptDestinationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptDestinationList;
    function GetCurrent : TFhirTestScriptDestination;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptDestinationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptDestination read GetCurrent;
  end;

  TFhirTestScriptDestinationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScriptDestination;
    procedure SetItemN(index : Integer; value : TFhirTestScriptDestination);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptDestinationList; Overload;
    function Clone : TFhirTestScriptDestinationList; Overload;
    function GetEnumerator : TFhirTestScriptDestinationListEnumerator;

    //  Add a FhirTestScriptDestination to the end of the list.
    function Append : TFhirTestScriptDestination;

    // Add an already existing FhirTestScriptDestination to the end of the list.
    procedure AddItem(value : TFhirTestScriptDestination); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptDestination) : Integer;

    // Insert FhirTestScriptDestination before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptDestination;

    // Insert an existing FhirTestScriptDestination before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptDestination);

    // Get the iIndexth FhirTestScriptDestination. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptDestination);

    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptDestination;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirTestScriptDestinations[index : Integer] : TFhirTestScriptDestination read GetItemN write SetItemN; default;
  End;

  // The required capability must exist and are assumed to function correctly on the FHIR server being tested.
  TFhirTestScriptMetadata = class (TFhirBackboneElement)
  protected
    Flink_List : TFhirTestScriptMetadataLinkList;
    FcapabilityList : TFhirTestScriptMetadataCapabilityList;
    function GetLink_List : TFhirTestScriptMetadataLinkList;
    function GetHasLink_List : Boolean;
    function GetCapabilityList : TFhirTestScriptMetadataCapabilityList;
    function GetHasCapabilityList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptMetadata; overload;
    function Clone : TFhirTestScriptMetadata; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // A link to the FHIR specification that this test is covering.
    property link_List : TFhirTestScriptMetadataLinkList read GetLink_List;
    property hasLink_List : boolean read GetHasLink_List;

    // Capabilities that must exist and are assumed to function correctly on the FHIR server being tested.
    property capabilityList : TFhirTestScriptMetadataCapabilityList read GetCapabilityList;
    property hasCapabilityList : boolean read GetHasCapabilityList;

  end;

  TFhirTestScriptMetadataListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptMetadataList;
    function GetCurrent : TFhirTestScriptMetadata;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptMetadataList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptMetadata read GetCurrent;
  end;

  TFhirTestScriptMetadataList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScriptMetadata;
    procedure SetItemN(index : Integer; value : TFhirTestScriptMetadata);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptMetadataList; Overload;
    function Clone : TFhirTestScriptMetadataList; Overload;
    function GetEnumerator : TFhirTestScriptMetadataListEnumerator;

    //  Add a FhirTestScriptMetadata to the end of the list.
    function Append : TFhirTestScriptMetadata;

    // Add an already existing FhirTestScriptMetadata to the end of the list.
    procedure AddItem(value : TFhirTestScriptMetadata); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptMetadata) : Integer;

    // Insert FhirTestScriptMetadata before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptMetadata;

    // Insert an existing FhirTestScriptMetadata before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptMetadata);

    // Get the iIndexth FhirTestScriptMetadata. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptMetadata);

    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptMetadata;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirTestScriptMetadata[index : Integer] : TFhirTestScriptMetadata read GetItemN write SetItemN; default;
  End;

  // A link to the FHIR specification that this test is covering.
  TFhirTestScriptMetadataLink = class (TFhirBackboneElement)
  protected
    FUrl : TFhirUri;
    FDescription : TFhirString;
    Procedure SetUrl(value : TFhirUri);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptMetadataLink; overload;
    function Clone : TFhirTestScriptMetadataLink; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to URL to a particular requirement or feature within the FHIR specification.
    property url : String read GetUrlST write SetUrlST;
    // URL to a particular requirement or feature within the FHIR specification.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to Short description of the link.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Short description of the link.
    property descriptionElement : TFhirString read FDescription write SetDescription;

  end;

  TFhirTestScriptMetadataLinkListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptMetadataLinkList;
    function GetCurrent : TFhirTestScriptMetadataLink;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptMetadataLinkList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptMetadataLink read GetCurrent;
  end;

  TFhirTestScriptMetadataLinkList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScriptMetadataLink;
    procedure SetItemN(index : Integer; value : TFhirTestScriptMetadataLink);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptMetadataLinkList; Overload;
    function Clone : TFhirTestScriptMetadataLinkList; Overload;
    function GetEnumerator : TFhirTestScriptMetadataLinkListEnumerator;

    //  Add a FhirTestScriptMetadataLink to the end of the list.
    function Append : TFhirTestScriptMetadataLink;

    // Add an already existing FhirTestScriptMetadataLink to the end of the list.
    procedure AddItem(value : TFhirTestScriptMetadataLink); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptMetadataLink) : Integer;

    // Insert FhirTestScriptMetadataLink before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptMetadataLink;

    // Insert an existing FhirTestScriptMetadataLink before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptMetadataLink);

    // Get the iIndexth FhirTestScriptMetadataLink. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptMetadataLink);

    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptMetadataLink;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirTestScriptMetadataLinks[index : Integer] : TFhirTestScriptMetadataLink read GetItemN write SetItemN; default;
  End;

  // Capabilities that must exist and are assumed to function correctly on the FHIR server being tested.
  TFhirTestScriptMetadataCapability = class (TFhirBackboneElement)
  protected
    FRequired : TFhirBoolean;
    FValidated : TFhirBoolean;
    FDescription : TFhirString;
    ForiginList : TFhirIntegerList;
    FDestination : TFhirInteger;
    Flink_List : TFhirUriList;
    FCapabilities : TFhirReference{TFhirCapabilityStatement};
    Procedure SetRequired(value : TFhirBoolean);
    Function GetRequiredST : Boolean;
    Procedure SetRequiredST(value : Boolean);
    Procedure SetValidated(value : TFhirBoolean);
    Function GetValidatedST : Boolean;
    Procedure SetValidatedST(value : Boolean);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    function GetOriginList : TFhirIntegerList;
    function GetHasOriginList : Boolean;
    Procedure SetDestination(value : TFhirInteger);
    Function GetDestinationST : String;
    Procedure SetDestinationST(value : String);
    function GetLink_List : TFhirUriList;
    function GetHasLink_List : Boolean;
    Procedure SetCapabilities(value : TFhirReference{TFhirCapabilityStatement});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptMetadataCapability; overload;
    function Clone : TFhirTestScriptMetadataCapability; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Whether or not the test execution will require the given capabilities of the server in order for this test script to execute.
    property required : Boolean read GetRequiredST write SetRequiredST;
    // Whether or not the test execution will require the given capabilities of the server in order for this test script to execute.
    property requiredElement : TFhirBoolean read FRequired write SetRequired;

    // Typed access to Whether or not the test execution will validate the given capabilities of the server in order for this test script to execute.
    property validated : Boolean read GetValidatedST write SetValidatedST;
    // Whether or not the test execution will validate the given capabilities of the server in order for this test script to execute.
    property validatedElement : TFhirBoolean read FValidated write SetValidated;

    // Typed access to Description of the capabilities that this test script is requiring the server to support.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Description of the capabilities that this test script is requiring the server to support.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Which origin server these requirements apply to.
    property originList : TFhirIntegerList read GetOriginList;
    property hasOriginList : boolean read GetHasOriginList;

    // Typed access to Which server these requirements apply to.
    property destination : String read GetDestinationST write SetDestinationST;
    // Which server these requirements apply to.
    property destinationElement : TFhirInteger read FDestination write SetDestination;

    // Links to the FHIR specification that describes this interaction and the resources involved in more detail.
    property link_List : TFhirUriList read GetLink_List;
    property hasLink_List : boolean read GetHasLink_List;

    // Typed access to Minimum capabilities required of server for test script to execute successfully.   If server does not meet at a minimum the referenced capability statement, then all tests in this script are skipped. (defined for API consistency)
    property capabilities : TFhirReference{TFhirCapabilityStatement} read FCapabilities write SetCapabilities;
    // Minimum capabilities required of server for test script to execute successfully.   If server does not meet at a minimum the referenced capability statement, then all tests in this script are skipped.
    property capabilitiesElement : TFhirReference{TFhirCapabilityStatement} read FCapabilities write SetCapabilities;

  end;

  TFhirTestScriptMetadataCapabilityListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptMetadataCapabilityList;
    function GetCurrent : TFhirTestScriptMetadataCapability;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptMetadataCapabilityList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptMetadataCapability read GetCurrent;
  end;

  TFhirTestScriptMetadataCapabilityList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScriptMetadataCapability;
    procedure SetItemN(index : Integer; value : TFhirTestScriptMetadataCapability);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptMetadataCapabilityList; Overload;
    function Clone : TFhirTestScriptMetadataCapabilityList; Overload;
    function GetEnumerator : TFhirTestScriptMetadataCapabilityListEnumerator;

    //  Add a FhirTestScriptMetadataCapability to the end of the list.
    function Append : TFhirTestScriptMetadataCapability;

    // Add an already existing FhirTestScriptMetadataCapability to the end of the list.
    procedure AddItem(value : TFhirTestScriptMetadataCapability); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptMetadataCapability) : Integer;

    // Insert FhirTestScriptMetadataCapability before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptMetadataCapability;

    // Insert an existing FhirTestScriptMetadataCapability before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptMetadataCapability);

    // Get the iIndexth FhirTestScriptMetadataCapability. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptMetadataCapability);

    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptMetadataCapability;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirTestScriptMetadataCapabilities[index : Integer] : TFhirTestScriptMetadataCapability read GetItemN write SetItemN; default;
  End;

  // Fixture in the test script - by reference (uri). All fixtures are required for the test script to execute.
  TFhirTestScriptFixture = class (TFhirBackboneElement)
  protected
    FAutocreate : TFhirBoolean;
    FAutodelete : TFhirBoolean;
    FResource : TFhirReference{TFhirReference};
    Procedure SetAutocreate(value : TFhirBoolean);
    Function GetAutocreateST : Boolean;
    Procedure SetAutocreateST(value : Boolean);
    Procedure SetAutodelete(value : TFhirBoolean);
    Function GetAutodeleteST : Boolean;
    Procedure SetAutodeleteST(value : Boolean);
    Procedure SetResource(value : TFhirReference{TFhirReference});

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptFixture; overload;
    function Clone : TFhirTestScriptFixture; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Whether or not to implicitly create the fixture during setup. If true, the fixture is automatically created on each server being tested during setup, therefore no create operation is required for this fixture in the TestScript.setup section.
    property autocreate : Boolean read GetAutocreateST write SetAutocreateST;
    // Whether or not to implicitly create the fixture during setup. If true, the fixture is automatically created on each server being tested during setup, therefore no create operation is required for this fixture in the TestScript.setup section.
    property autocreateElement : TFhirBoolean read FAutocreate write SetAutocreate;

    // Typed access to Whether or not to implicitly delete the fixture during teardown. If true, the fixture is automatically deleted on each server being tested during teardown, therefore no delete operation is required for this fixture in the TestScript.teardown section.
    property autodelete : Boolean read GetAutodeleteST write SetAutodeleteST;
    // Whether or not to implicitly delete the fixture during teardown. If true, the fixture is automatically deleted on each server being tested during teardown, therefore no delete operation is required for this fixture in the TestScript.teardown section.
    property autodeleteElement : TFhirBoolean read FAutodelete write SetAutodelete;

    // Typed access to Reference to the resource (containing the contents of the resource needed for operations). (defined for API consistency)
    property resource : TFhirReference{TFhirReference} read FResource write SetResource;
    // Reference to the resource (containing the contents of the resource needed for operations).
    property resourceElement : TFhirReference{TFhirReference} read FResource write SetResource;

  end;

  TFhirTestScriptFixtureListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptFixtureList;
    function GetCurrent : TFhirTestScriptFixture;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptFixtureList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptFixture read GetCurrent;
  end;

  TFhirTestScriptFixtureList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScriptFixture;
    procedure SetItemN(index : Integer; value : TFhirTestScriptFixture);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptFixtureList; Overload;
    function Clone : TFhirTestScriptFixtureList; Overload;
    function GetEnumerator : TFhirTestScriptFixtureListEnumerator;

    //  Add a FhirTestScriptFixture to the end of the list.
    function Append : TFhirTestScriptFixture;

    // Add an already existing FhirTestScriptFixture to the end of the list.
    procedure AddItem(value : TFhirTestScriptFixture); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptFixture) : Integer;

    // Insert FhirTestScriptFixture before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptFixture;

    // Insert an existing FhirTestScriptFixture before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptFixture);

    // Get the iIndexth FhirTestScriptFixture. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptFixture);

    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptFixture;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirTestScriptFixtures[index : Integer] : TFhirTestScriptFixture read GetItemN write SetItemN; default;
  End;

  // Variable is set based either on element value in response body or on header field value in the response headers.
  TFhirTestScriptVariable = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FDefaultValue : TFhirString;
    FDescription : TFhirString;
    FExpression : TFhirString;
    FHeaderField : TFhirString;
    FHint : TFhirString;
    FPath : TFhirString;
    FSourceId : TFhirId;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetDefaultValue(value : TFhirString);
    Function GetDefaultValueST : String;
    Procedure SetDefaultValueST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetExpression(value : TFhirString);
    Function GetExpressionST : String;
    Procedure SetExpressionST(value : String);
    Procedure SetHeaderField(value : TFhirString);
    Function GetHeaderFieldST : String;
    Procedure SetHeaderFieldST(value : String);
    Procedure SetHint(value : TFhirString);
    Function GetHintST : String;
    Procedure SetHintST(value : String);
    Procedure SetPath(value : TFhirString);
    Function GetPathST : String;
    Procedure SetPathST(value : String);
    Procedure SetSourceId(value : TFhirId);
    Function GetSourceIdST : String;
    Procedure SetSourceIdST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptVariable; overload;
    function Clone : TFhirTestScriptVariable; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Descriptive name for this variable.
    property name : String read GetNameST write SetNameST;
    // Descriptive name for this variable.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A default, hard-coded, or user-defined value for this variable.
    property defaultValue : String read GetDefaultValueST write SetDefaultValueST;
    // A default, hard-coded, or user-defined value for this variable.
    property defaultValueElement : TFhirString read FDefaultValue write SetDefaultValue;

    // Typed access to A free text natural language description of the variable and its purpose.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the variable and its purpose.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to The fluentpath expression to evaluate against the fixture body. When variables are defined, only one of either expression, headerField or path must be specified.
    property expression : String read GetExpressionST write SetExpressionST;
    // The fluentpath expression to evaluate against the fixture body. When variables are defined, only one of either expression, headerField or path must be specified.
    property expressionElement : TFhirString read FExpression write SetExpression;

    // Typed access to Will be used to grab the HTTP header field value from the headers that sourceId is pointing to.
    property headerField : String read GetHeaderFieldST write SetHeaderFieldST;
    // Will be used to grab the HTTP header field value from the headers that sourceId is pointing to.
    property headerFieldElement : TFhirString read FHeaderField write SetHeaderField;

    // Typed access to Displayable text string with hint help information to the user when entering a default value.
    property hint : String read GetHintST write SetHintST;
    // Displayable text string with hint help information to the user when entering a default value.
    property hintElement : TFhirString read FHint write SetHint;

    // Typed access to XPath or JSONPath to evaluate against the fixture body.  When variables are defined, only one of either expression, headerField or path must be specified.
    property path : String read GetPathST write SetPathST;
    // XPath or JSONPath to evaluate against the fixture body.  When variables are defined, only one of either expression, headerField or path must be specified.
    property pathElement : TFhirString read FPath write SetPath;

    // Typed access to Fixture to evaluate the XPath/JSONPath expression or the headerField  against within this variable.
    property sourceId : String read GetSourceIdST write SetSourceIdST;
    // Fixture to evaluate the XPath/JSONPath expression or the headerField  against within this variable.
    property sourceIdElement : TFhirId read FSourceId write SetSourceId;

  end;

  TFhirTestScriptVariableListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptVariableList;
    function GetCurrent : TFhirTestScriptVariable;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptVariableList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptVariable read GetCurrent;
  end;

  TFhirTestScriptVariableList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScriptVariable;
    procedure SetItemN(index : Integer; value : TFhirTestScriptVariable);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptVariableList; Overload;
    function Clone : TFhirTestScriptVariableList; Overload;
    function GetEnumerator : TFhirTestScriptVariableListEnumerator;

    //  Add a FhirTestScriptVariable to the end of the list.
    function Append : TFhirTestScriptVariable;

    // Add an already existing FhirTestScriptVariable to the end of the list.
    procedure AddItem(value : TFhirTestScriptVariable); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptVariable) : Integer;

    // Insert FhirTestScriptVariable before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptVariable;

    // Insert an existing FhirTestScriptVariable before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptVariable);

    // Get the iIndexth FhirTestScriptVariable. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptVariable);

    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptVariable;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirTestScriptVariables[index : Integer] : TFhirTestScriptVariable read GetItemN write SetItemN; default;
  End;

  // Assert rule to be used in one or more asserts within the test script.
  TFhirTestScriptRule = class (TFhirBackboneElement)
  protected
    FResource : TFhirReference{TFhirReference};
    FparamList : TFhirTestScriptRuleParamList;
    Procedure SetResource(value : TFhirReference{TFhirReference});
    function GetParamList : TFhirTestScriptRuleParamList;
    function GetHasParamList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptRule; overload;
    function Clone : TFhirTestScriptRule; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Reference to the resource (containing the contents of the rule needed for assertions). (defined for API consistency)
    property resource : TFhirReference{TFhirReference} read FResource write SetResource;
    // Reference to the resource (containing the contents of the rule needed for assertions).
    property resourceElement : TFhirReference{TFhirReference} read FResource write SetResource;

    // Each rule template can take one or more parameters for rule evaluation.
    property paramList : TFhirTestScriptRuleParamList read GetParamList;
    property hasParamList : boolean read GetHasParamList;

  end;

  TFhirTestScriptRuleListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptRuleList;
    function GetCurrent : TFhirTestScriptRule;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptRuleList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptRule read GetCurrent;
  end;

  TFhirTestScriptRuleList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScriptRule;
    procedure SetItemN(index : Integer; value : TFhirTestScriptRule);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptRuleList; Overload;
    function Clone : TFhirTestScriptRuleList; Overload;
    function GetEnumerator : TFhirTestScriptRuleListEnumerator;

    //  Add a FhirTestScriptRule to the end of the list.
    function Append : TFhirTestScriptRule;

    // Add an already existing FhirTestScriptRule to the end of the list.
    procedure AddItem(value : TFhirTestScriptRule); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptRule) : Integer;

    // Insert FhirTestScriptRule before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptRule;

    // Insert an existing FhirTestScriptRule before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptRule);

    // Get the iIndexth FhirTestScriptRule. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptRule);

    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptRule;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirTestScriptRules[index : Integer] : TFhirTestScriptRule read GetItemN write SetItemN; default;
  End;

  // Each rule template can take one or more parameters for rule evaluation.
  TFhirTestScriptRuleParam = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FValue : TFhirString;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetValue(value : TFhirString);
    Function GetValueST : String;
    Procedure SetValueST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptRuleParam; overload;
    function Clone : TFhirTestScriptRuleParam; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Descriptive name for this parameter that matches the external assert rule parameter name.
    property name : String read GetNameST write SetNameST;
    // Descriptive name for this parameter that matches the external assert rule parameter name.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to The explicit or dynamic value for the parameter that will be passed on to the external rule template.
    property value : String read GetValueST write SetValueST;
    // The explicit or dynamic value for the parameter that will be passed on to the external rule template.
    property valueElement : TFhirString read FValue write SetValue;

  end;

  TFhirTestScriptRuleParamListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptRuleParamList;
    function GetCurrent : TFhirTestScriptRuleParam;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptRuleParamList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptRuleParam read GetCurrent;
  end;

  TFhirTestScriptRuleParamList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScriptRuleParam;
    procedure SetItemN(index : Integer; value : TFhirTestScriptRuleParam);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptRuleParamList; Overload;
    function Clone : TFhirTestScriptRuleParamList; Overload;
    function GetEnumerator : TFhirTestScriptRuleParamListEnumerator;

    //  Add a FhirTestScriptRuleParam to the end of the list.
    function Append : TFhirTestScriptRuleParam;

    // Add an already existing FhirTestScriptRuleParam to the end of the list.
    procedure AddItem(value : TFhirTestScriptRuleParam); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptRuleParam) : Integer;

    // Insert FhirTestScriptRuleParam before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptRuleParam;

    // Insert an existing FhirTestScriptRuleParam before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptRuleParam);

    // Get the iIndexth FhirTestScriptRuleParam. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptRuleParam);

    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptRuleParam;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirTestScriptRuleParams[index : Integer] : TFhirTestScriptRuleParam read GetItemN write SetItemN; default;
  End;

  // Contains one or more rules.  Offers a way to group rules so assertions could reference the group of rules and have them all applied.
  TFhirTestScriptRuleset = class (TFhirBackboneElement)
  protected
    FResource : TFhirReference{TFhirReference};
    FruleList : TFhirTestScriptRulesetRuleList;
    Procedure SetResource(value : TFhirReference{TFhirReference});
    function GetRuleList : TFhirTestScriptRulesetRuleList;
    function GetHasRuleList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptRuleset; overload;
    function Clone : TFhirTestScriptRuleset; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Reference to the resource (containing the contents of the ruleset needed for assertions). (defined for API consistency)
    property resource : TFhirReference{TFhirReference} read FResource write SetResource;
    // Reference to the resource (containing the contents of the ruleset needed for assertions).
    property resourceElement : TFhirReference{TFhirReference} read FResource write SetResource;

    // The referenced rule within the external ruleset template.
    property ruleList : TFhirTestScriptRulesetRuleList read GetRuleList;
    property hasRuleList : boolean read GetHasRuleList;

  end;

  TFhirTestScriptRulesetListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptRulesetList;
    function GetCurrent : TFhirTestScriptRuleset;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptRulesetList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptRuleset read GetCurrent;
  end;

  TFhirTestScriptRulesetList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScriptRuleset;
    procedure SetItemN(index : Integer; value : TFhirTestScriptRuleset);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptRulesetList; Overload;
    function Clone : TFhirTestScriptRulesetList; Overload;
    function GetEnumerator : TFhirTestScriptRulesetListEnumerator;

    //  Add a FhirTestScriptRuleset to the end of the list.
    function Append : TFhirTestScriptRuleset;

    // Add an already existing FhirTestScriptRuleset to the end of the list.
    procedure AddItem(value : TFhirTestScriptRuleset); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptRuleset) : Integer;

    // Insert FhirTestScriptRuleset before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptRuleset;

    // Insert an existing FhirTestScriptRuleset before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptRuleset);

    // Get the iIndexth FhirTestScriptRuleset. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptRuleset);

    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptRuleset;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirTestScriptRulesets[index : Integer] : TFhirTestScriptRuleset read GetItemN write SetItemN; default;
  End;

  // The referenced rule within the external ruleset template.
  TFhirTestScriptRulesetRule = class (TFhirBackboneElement)
  protected
    FRuleId : TFhirId;
    FparamList : TFhirTestScriptRulesetRuleParamList;
    Procedure SetRuleId(value : TFhirId);
    Function GetRuleIdST : String;
    Procedure SetRuleIdST(value : String);
    function GetParamList : TFhirTestScriptRulesetRuleParamList;
    function GetHasParamList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptRulesetRule; overload;
    function Clone : TFhirTestScriptRulesetRule; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Id of the referenced rule within the external ruleset template.
    property ruleId : String read GetRuleIdST write SetRuleIdST;
    // Id of the referenced rule within the external ruleset template.
    property ruleIdElement : TFhirId read FRuleId write SetRuleId;

    // Each rule template can take one or more parameters for rule evaluation.
    property paramList : TFhirTestScriptRulesetRuleParamList read GetParamList;
    property hasParamList : boolean read GetHasParamList;

  end;

  TFhirTestScriptRulesetRuleListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptRulesetRuleList;
    function GetCurrent : TFhirTestScriptRulesetRule;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptRulesetRuleList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptRulesetRule read GetCurrent;
  end;

  TFhirTestScriptRulesetRuleList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScriptRulesetRule;
    procedure SetItemN(index : Integer; value : TFhirTestScriptRulesetRule);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptRulesetRuleList; Overload;
    function Clone : TFhirTestScriptRulesetRuleList; Overload;
    function GetEnumerator : TFhirTestScriptRulesetRuleListEnumerator;

    //  Add a FhirTestScriptRulesetRule to the end of the list.
    function Append : TFhirTestScriptRulesetRule;

    // Add an already existing FhirTestScriptRulesetRule to the end of the list.
    procedure AddItem(value : TFhirTestScriptRulesetRule); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptRulesetRule) : Integer;

    // Insert FhirTestScriptRulesetRule before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptRulesetRule;

    // Insert an existing FhirTestScriptRulesetRule before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptRulesetRule);

    // Get the iIndexth FhirTestScriptRulesetRule. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptRulesetRule);

    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptRulesetRule;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirTestScriptRulesetRules[index : Integer] : TFhirTestScriptRulesetRule read GetItemN write SetItemN; default;
  End;

  // Each rule template can take one or more parameters for rule evaluation.
  TFhirTestScriptRulesetRuleParam = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FValue : TFhirString;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetValue(value : TFhirString);
    Function GetValueST : String;
    Procedure SetValueST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptRulesetRuleParam; overload;
    function Clone : TFhirTestScriptRulesetRuleParam; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Descriptive name for this parameter that matches the external assert ruleset rule parameter name.
    property name : String read GetNameST write SetNameST;
    // Descriptive name for this parameter that matches the external assert ruleset rule parameter name.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to The value for the parameter that will be passed on to the external ruleset rule template.
    property value : String read GetValueST write SetValueST;
    // The value for the parameter that will be passed on to the external ruleset rule template.
    property valueElement : TFhirString read FValue write SetValue;

  end;

  TFhirTestScriptRulesetRuleParamListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptRulesetRuleParamList;
    function GetCurrent : TFhirTestScriptRulesetRuleParam;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptRulesetRuleParamList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptRulesetRuleParam read GetCurrent;
  end;

  TFhirTestScriptRulesetRuleParamList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScriptRulesetRuleParam;
    procedure SetItemN(index : Integer; value : TFhirTestScriptRulesetRuleParam);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptRulesetRuleParamList; Overload;
    function Clone : TFhirTestScriptRulesetRuleParamList; Overload;
    function GetEnumerator : TFhirTestScriptRulesetRuleParamListEnumerator;

    //  Add a FhirTestScriptRulesetRuleParam to the end of the list.
    function Append : TFhirTestScriptRulesetRuleParam;

    // Add an already existing FhirTestScriptRulesetRuleParam to the end of the list.
    procedure AddItem(value : TFhirTestScriptRulesetRuleParam); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptRulesetRuleParam) : Integer;

    // Insert FhirTestScriptRulesetRuleParam before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptRulesetRuleParam;

    // Insert an existing FhirTestScriptRulesetRuleParam before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptRulesetRuleParam);

    // Get the iIndexth FhirTestScriptRulesetRuleParam. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptRulesetRuleParam);

    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptRulesetRuleParam;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirTestScriptRulesetRuleParams[index : Integer] : TFhirTestScriptRulesetRuleParam read GetItemN write SetItemN; default;
  End;

  // A series of required setup operations before tests are executed.
  TFhirTestScriptSetup = class (TFhirBackboneElement)
  protected
    FactionList : TFhirTestScriptSetupActionList;
    function GetActionList : TFhirTestScriptSetupActionList;
    function GetHasActionList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptSetup; overload;
    function Clone : TFhirTestScriptSetup; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Action would contain either an operation or an assertion.
    property actionList : TFhirTestScriptSetupActionList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

  end;

  TFhirTestScriptSetupListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptSetupList;
    function GetCurrent : TFhirTestScriptSetup;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptSetupList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptSetup read GetCurrent;
  end;

  TFhirTestScriptSetupList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScriptSetup;
    procedure SetItemN(index : Integer; value : TFhirTestScriptSetup);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptSetupList; Overload;
    function Clone : TFhirTestScriptSetupList; Overload;
    function GetEnumerator : TFhirTestScriptSetupListEnumerator;

    //  Add a FhirTestScriptSetup to the end of the list.
    function Append : TFhirTestScriptSetup;

    // Add an already existing FhirTestScriptSetup to the end of the list.
    procedure AddItem(value : TFhirTestScriptSetup); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptSetup) : Integer;

    // Insert FhirTestScriptSetup before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptSetup;

    // Insert an existing FhirTestScriptSetup before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptSetup);

    // Get the iIndexth FhirTestScriptSetup. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptSetup);

    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptSetup;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirTestScriptSetups[index : Integer] : TFhirTestScriptSetup read GetItemN write SetItemN; default;
  End;

  // Action would contain either an operation or an assertion.
  TFhirTestScriptSetupAction = class (TFhirBackboneElement)
  protected
    FOperation : TFhirTestScriptSetupActionOperation;
    FAssert : TFhirTestScriptSetupActionAssert;
    Procedure SetOperation(value : TFhirTestScriptSetupActionOperation);
    Procedure SetAssert(value : TFhirTestScriptSetupActionAssert);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptSetupAction; overload;
    function Clone : TFhirTestScriptSetupAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The operation to perform. (defined for API consistency)
    property operation : TFhirTestScriptSetupActionOperation read FOperation write SetOperation;
    // The operation to perform.
    property operationElement : TFhirTestScriptSetupActionOperation read FOperation write SetOperation;

    // Typed access to Evaluates the results of previous operations to determine if the server under test behaves appropriately. (defined for API consistency)
    property assert : TFhirTestScriptSetupActionAssert read FAssert write SetAssert;
    // Evaluates the results of previous operations to determine if the server under test behaves appropriately.
    property assertElement : TFhirTestScriptSetupActionAssert read FAssert write SetAssert;

  end;

  TFhirTestScriptSetupActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptSetupActionList;
    function GetCurrent : TFhirTestScriptSetupAction;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptSetupActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptSetupAction read GetCurrent;
  end;

  TFhirTestScriptSetupActionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScriptSetupAction;
    procedure SetItemN(index : Integer; value : TFhirTestScriptSetupAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptSetupActionList; Overload;
    function Clone : TFhirTestScriptSetupActionList; Overload;
    function GetEnumerator : TFhirTestScriptSetupActionListEnumerator;

    //  Add a FhirTestScriptSetupAction to the end of the list.
    function Append : TFhirTestScriptSetupAction;

    // Add an already existing FhirTestScriptSetupAction to the end of the list.
    procedure AddItem(value : TFhirTestScriptSetupAction); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptSetupAction) : Integer;

    // Insert FhirTestScriptSetupAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptSetupAction;

    // Insert an existing FhirTestScriptSetupAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptSetupAction);

    // Get the iIndexth FhirTestScriptSetupAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptSetupAction);

    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptSetupAction;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirTestScriptSetupActions[index : Integer] : TFhirTestScriptSetupAction read GetItemN write SetItemN; default;
  End;

  // The operation to perform.
  TFhirTestScriptSetupActionOperation = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCoding;
    FResource : TFhirCode;
    FLabel_ : TFhirString;
    FDescription : TFhirString;
    FAccept : TFhirEnum;
    FContentType : TFhirEnum;
    FDestination : TFhirInteger;
    FEncodeRequestUrl : TFhirBoolean;
    FOrigin : TFhirInteger;
    FParams : TFhirString;
    FrequestHeaderList : TFhirTestScriptSetupActionOperationRequestHeaderList;
    FRequestId : TFhirId;
    FResponseId : TFhirId;
    FSourceId : TFhirId;
    FTargetId : TFhirId;
    FUrl : TFhirString;
    Procedure SetType_(value : TFhirCoding);
    Procedure SetResource(value : TFhirCode);
    Function GetResourceST : String;
    Procedure SetResourceST(value : String);
    Procedure SetLabel_(value : TFhirString);
    Function GetLabel_ST : String;
    Procedure SetLabel_ST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetAccept(value : TFhirEnum);
    Function GetAcceptST : TFhirContentTypeEnum;
    Procedure SetAcceptST(value : TFhirContentTypeEnum);
    Procedure SetContentType(value : TFhirEnum);
    Function GetContentTypeST : TFhirContentTypeEnum;
    Procedure SetContentTypeST(value : TFhirContentTypeEnum);
    Procedure SetDestination(value : TFhirInteger);
    Function GetDestinationST : String;
    Procedure SetDestinationST(value : String);
    Procedure SetEncodeRequestUrl(value : TFhirBoolean);
    Function GetEncodeRequestUrlST : Boolean;
    Procedure SetEncodeRequestUrlST(value : Boolean);
    Procedure SetOrigin(value : TFhirInteger);
    Function GetOriginST : String;
    Procedure SetOriginST(value : String);
    Procedure SetParams(value : TFhirString);
    Function GetParamsST : String;
    Procedure SetParamsST(value : String);
    function GetRequestHeaderList : TFhirTestScriptSetupActionOperationRequestHeaderList;
    function GetHasRequestHeaderList : Boolean;
    Procedure SetRequestId(value : TFhirId);
    Function GetRequestIdST : String;
    Procedure SetRequestIdST(value : String);
    Procedure SetResponseId(value : TFhirId);
    Function GetResponseIdST : String;
    Procedure SetResponseIdST(value : String);
    Procedure SetSourceId(value : TFhirId);
    Function GetSourceIdST : String;
    Procedure SetSourceIdST(value : String);
    Procedure SetTargetId(value : TFhirId);
    Function GetTargetIdST : String;
    Procedure SetTargetIdST(value : String);
    Procedure SetUrl(value : TFhirString);
    Function GetUrlST : String;
    Procedure SetUrlST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptSetupActionOperation; overload;
    function Clone : TFhirTestScriptSetupActionOperation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Server interaction or operation type. (defined for API consistency)
    property type_ : TFhirCoding read FType_ write SetType_;
    // Server interaction or operation type.
    property type_Element : TFhirCoding read FType_ write SetType_;

    // Typed access to The type of the resource.  See http://build.fhir.org/resourcelist.html.
    property resource : String read GetResourceST write SetResourceST;
    // The type of the resource.  See http://build.fhir.org/resourcelist.html.
    property resourceElement : TFhirCode read FResource write SetResource;

    // Typed access to The label would be used for tracking/logging purposes by test engines.
    property label_ : String read GetLabel_ST write SetLabel_ST;
    // The label would be used for tracking/logging purposes by test engines.
    property label_Element : TFhirString read FLabel_ write SetLabel_;

    // Typed access to The description would be used by test engines for tracking and reporting purposes.
    property description : String read GetDescriptionST write SetDescriptionST;
    // The description would be used by test engines for tracking and reporting purposes.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // The content-type or mime-type to use for RESTful operation in the 'Accept' header.
    property accept : TFhirContentTypeEnum read GetAcceptST write SetAcceptST;
    property acceptElement : TFhirEnum read FAccept write SetAccept;

    // The content-type or mime-type to use for RESTful operation in the 'Content-Type' header.
    property contentType : TFhirContentTypeEnum read GetContentTypeST write SetContentTypeST;
    property contentTypeElement : TFhirEnum read FContentType write SetContentType;

    // Typed access to The server where the request message is destined for.  Must be one of the server numbers listed in TestScript.destination section.
    property destination : String read GetDestinationST write SetDestinationST;
    // The server where the request message is destined for.  Must be one of the server numbers listed in TestScript.destination section.
    property destinationElement : TFhirInteger read FDestination write SetDestination;

    // Typed access to Whether or not to implicitly send the request url in encoded format. The default is true to match the standard RESTful client behavior. Set to false when communicating with a server that does not support encoded url paths.
    property encodeRequestUrl : Boolean read GetEncodeRequestUrlST write SetEncodeRequestUrlST;
    // Whether or not to implicitly send the request url in encoded format. The default is true to match the standard RESTful client behavior. Set to false when communicating with a server that does not support encoded url paths.
    property encodeRequestUrlElement : TFhirBoolean read FEncodeRequestUrl write SetEncodeRequestUrl;

    // Typed access to The server where the request message originates from.  Must be one of the server numbers listed in TestScript.origin section.
    property origin : String read GetOriginST write SetOriginST;
    // The server where the request message originates from.  Must be one of the server numbers listed in TestScript.origin section.
    property originElement : TFhirInteger read FOrigin write SetOrigin;

    // Typed access to Path plus parameters after [type].  Used to set parts of the request URL explicitly.
    property params : String read GetParamsST write SetParamsST;
    // Path plus parameters after [type].  Used to set parts of the request URL explicitly.
    property paramsElement : TFhirString read FParams write SetParams;

    // Header elements would be used to set HTTP headers.
    property requestHeaderList : TFhirTestScriptSetupActionOperationRequestHeaderList read GetRequestHeaderList;
    property hasRequestHeaderList : boolean read GetHasRequestHeaderList;

    // Typed access to The fixture id (maybe new) to map to the request.
    property requestId : String read GetRequestIdST write SetRequestIdST;
    // The fixture id (maybe new) to map to the request.
    property requestIdElement : TFhirId read FRequestId write SetRequestId;

    // Typed access to The fixture id (maybe new) to map to the response.
    property responseId : String read GetResponseIdST write SetResponseIdST;
    // The fixture id (maybe new) to map to the response.
    property responseIdElement : TFhirId read FResponseId write SetResponseId;

    // Typed access to The id of the fixture used as the body of a PUT or POST request.
    property sourceId : String read GetSourceIdST write SetSourceIdST;
    // The id of the fixture used as the body of a PUT or POST request.
    property sourceIdElement : TFhirId read FSourceId write SetSourceId;

    // Typed access to Id of fixture used for extracting the [id],  [type], and [vid] for GET requests.
    property targetId : String read GetTargetIdST write SetTargetIdST;
    // Id of fixture used for extracting the [id],  [type], and [vid] for GET requests.
    property targetIdElement : TFhirId read FTargetId write SetTargetId;

    // Typed access to Complete request URL.
    property url : String read GetUrlST write SetUrlST;
    // Complete request URL.
    property urlElement : TFhirString read FUrl write SetUrl;

  end;

  TFhirTestScriptSetupActionOperationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptSetupActionOperationList;
    function GetCurrent : TFhirTestScriptSetupActionOperation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptSetupActionOperationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptSetupActionOperation read GetCurrent;
  end;

  TFhirTestScriptSetupActionOperationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScriptSetupActionOperation;
    procedure SetItemN(index : Integer; value : TFhirTestScriptSetupActionOperation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptSetupActionOperationList; Overload;
    function Clone : TFhirTestScriptSetupActionOperationList; Overload;
    function GetEnumerator : TFhirTestScriptSetupActionOperationListEnumerator;

    //  Add a FhirTestScriptSetupActionOperation to the end of the list.
    function Append : TFhirTestScriptSetupActionOperation;

    // Add an already existing FhirTestScriptSetupActionOperation to the end of the list.
    procedure AddItem(value : TFhirTestScriptSetupActionOperation); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptSetupActionOperation) : Integer;

    // Insert FhirTestScriptSetupActionOperation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptSetupActionOperation;

    // Insert an existing FhirTestScriptSetupActionOperation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptSetupActionOperation);

    // Get the iIndexth FhirTestScriptSetupActionOperation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptSetupActionOperation);

    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptSetupActionOperation;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirTestScriptSetupActionOperations[index : Integer] : TFhirTestScriptSetupActionOperation read GetItemN write SetItemN; default;
  End;

  // Header elements would be used to set HTTP headers.
  TFhirTestScriptSetupActionOperationRequestHeader = class (TFhirBackboneElement)
  protected
    FField : TFhirString;
    FValue : TFhirString;
    Procedure SetField(value : TFhirString);
    Function GetFieldST : String;
    Procedure SetFieldST(value : String);
    Procedure SetValue(value : TFhirString);
    Function GetValueST : String;
    Procedure SetValueST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptSetupActionOperationRequestHeader; overload;
    function Clone : TFhirTestScriptSetupActionOperationRequestHeader; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The HTTP header field e.g. "Accept".
    property field : String read GetFieldST write SetFieldST;
    // The HTTP header field e.g. "Accept".
    property fieldElement : TFhirString read FField write SetField;

    // Typed access to The value of the header e.g. "application/fhir+xml".
    property value : String read GetValueST write SetValueST;
    // The value of the header e.g. "application/fhir+xml".
    property valueElement : TFhirString read FValue write SetValue;

  end;

  TFhirTestScriptSetupActionOperationRequestHeaderListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptSetupActionOperationRequestHeaderList;
    function GetCurrent : TFhirTestScriptSetupActionOperationRequestHeader;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptSetupActionOperationRequestHeaderList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptSetupActionOperationRequestHeader read GetCurrent;
  end;

  TFhirTestScriptSetupActionOperationRequestHeaderList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScriptSetupActionOperationRequestHeader;
    procedure SetItemN(index : Integer; value : TFhirTestScriptSetupActionOperationRequestHeader);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptSetupActionOperationRequestHeaderList; Overload;
    function Clone : TFhirTestScriptSetupActionOperationRequestHeaderList; Overload;
    function GetEnumerator : TFhirTestScriptSetupActionOperationRequestHeaderListEnumerator;

    //  Add a FhirTestScriptSetupActionOperationRequestHeader to the end of the list.
    function Append : TFhirTestScriptSetupActionOperationRequestHeader;

    // Add an already existing FhirTestScriptSetupActionOperationRequestHeader to the end of the list.
    procedure AddItem(value : TFhirTestScriptSetupActionOperationRequestHeader); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptSetupActionOperationRequestHeader) : Integer;

    // Insert FhirTestScriptSetupActionOperationRequestHeader before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptSetupActionOperationRequestHeader;

    // Insert an existing FhirTestScriptSetupActionOperationRequestHeader before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptSetupActionOperationRequestHeader);

    // Get the iIndexth FhirTestScriptSetupActionOperationRequestHeader. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptSetupActionOperationRequestHeader);

    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptSetupActionOperationRequestHeader;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirTestScriptSetupActionOperationRequestHeaders[index : Integer] : TFhirTestScriptSetupActionOperationRequestHeader read GetItemN write SetItemN; default;
  End;

  // Evaluates the results of previous operations to determine if the server under test behaves appropriately.
  TFhirTestScriptSetupActionAssert = class (TFhirBackboneElement)
  protected
    FLabel_ : TFhirString;
    FDescription : TFhirString;
    FDirection : TFhirEnum;
    FCompareToSourceId : TFhirString;
    FCompareToSourceExpression : TFhirString;
    FCompareToSourcePath : TFhirString;
    FContentType : TFhirEnum;
    FExpression : TFhirString;
    FHeaderField : TFhirString;
    FMinimumId : TFhirString;
    FNavigationLinks : TFhirBoolean;
    FOperator : TFhirEnum;
    FPath : TFhirString;
    FRequestMethod : TFhirEnum;
    FRequestURL : TFhirString;
    FResource : TFhirCode;
    FResponse : TFhirEnum;
    FResponseCode : TFhirString;
    FRule : TFhirTestScriptSetupActionAssertRule;
    FRuleset : TFhirTestScriptSetupActionAssertRuleset;
    FSourceId : TFhirId;
    FValidateProfileId : TFhirId;
    FValue : TFhirString;
    FWarningOnly : TFhirBoolean;
    Procedure SetLabel_(value : TFhirString);
    Function GetLabel_ST : String;
    Procedure SetLabel_ST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    Procedure SetDirection(value : TFhirEnum);
    Function GetDirectionST : TFhirAssertDirectionCodesEnum;
    Procedure SetDirectionST(value : TFhirAssertDirectionCodesEnum);
    Procedure SetCompareToSourceId(value : TFhirString);
    Function GetCompareToSourceIdST : String;
    Procedure SetCompareToSourceIdST(value : String);
    Procedure SetCompareToSourceExpression(value : TFhirString);
    Function GetCompareToSourceExpressionST : String;
    Procedure SetCompareToSourceExpressionST(value : String);
    Procedure SetCompareToSourcePath(value : TFhirString);
    Function GetCompareToSourcePathST : String;
    Procedure SetCompareToSourcePathST(value : String);
    Procedure SetContentType(value : TFhirEnum);
    Function GetContentTypeST : TFhirContentTypeEnum;
    Procedure SetContentTypeST(value : TFhirContentTypeEnum);
    Procedure SetExpression(value : TFhirString);
    Function GetExpressionST : String;
    Procedure SetExpressionST(value : String);
    Procedure SetHeaderField(value : TFhirString);
    Function GetHeaderFieldST : String;
    Procedure SetHeaderFieldST(value : String);
    Procedure SetMinimumId(value : TFhirString);
    Function GetMinimumIdST : String;
    Procedure SetMinimumIdST(value : String);
    Procedure SetNavigationLinks(value : TFhirBoolean);
    Function GetNavigationLinksST : Boolean;
    Procedure SetNavigationLinksST(value : Boolean);
    Procedure SetOperator(value : TFhirEnum);
    Function GetOperatorST : TFhirAssertOperatorCodesEnum;
    Procedure SetOperatorST(value : TFhirAssertOperatorCodesEnum);
    Procedure SetPath(value : TFhirString);
    Function GetPathST : String;
    Procedure SetPathST(value : String);
    Procedure SetRequestMethod(value : TFhirEnum);
    Function GetRequestMethodST : TFhirHttpOperationsEnum;
    Procedure SetRequestMethodST(value : TFhirHttpOperationsEnum);
    Procedure SetRequestURL(value : TFhirString);
    Function GetRequestURLST : String;
    Procedure SetRequestURLST(value : String);
    Procedure SetResource(value : TFhirCode);
    Function GetResourceST : String;
    Procedure SetResourceST(value : String);
    Procedure SetResponse(value : TFhirEnum);
    Function GetResponseST : TFhirAssertResponseCodeTypesEnum;
    Procedure SetResponseST(value : TFhirAssertResponseCodeTypesEnum);
    Procedure SetResponseCode(value : TFhirString);
    Function GetResponseCodeST : String;
    Procedure SetResponseCodeST(value : String);
    Procedure SetRule(value : TFhirTestScriptSetupActionAssertRule);
    Procedure SetRuleset(value : TFhirTestScriptSetupActionAssertRuleset);
    Procedure SetSourceId(value : TFhirId);
    Function GetSourceIdST : String;
    Procedure SetSourceIdST(value : String);
    Procedure SetValidateProfileId(value : TFhirId);
    Function GetValidateProfileIdST : String;
    Procedure SetValidateProfileIdST(value : String);
    Procedure SetValue(value : TFhirString);
    Function GetValueST : String;
    Procedure SetValueST(value : String);
    Procedure SetWarningOnly(value : TFhirBoolean);
    Function GetWarningOnlyST : Boolean;
    Procedure SetWarningOnlyST(value : Boolean);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptSetupActionAssert; overload;
    function Clone : TFhirTestScriptSetupActionAssert; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The label would be used for tracking/logging purposes by test engines.
    property label_ : String read GetLabel_ST write SetLabel_ST;
    // The label would be used for tracking/logging purposes by test engines.
    property label_Element : TFhirString read FLabel_ write SetLabel_;

    // Typed access to The description would be used by test engines for tracking and reporting purposes.
    property description : String read GetDescriptionST write SetDescriptionST;
    // The description would be used by test engines for tracking and reporting purposes.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // The direction to use for the assertion.
    property direction : TFhirAssertDirectionCodesEnum read GetDirectionST write SetDirectionST;
    property directionElement : TFhirEnum read FDirection write SetDirection;

    // Typed access to Id of the source fixture used as the contents to be evaluated by either the "source/expression" or "sourceId/path" definition.
    property compareToSourceId : String read GetCompareToSourceIdST write SetCompareToSourceIdST;
    // Id of the source fixture used as the contents to be evaluated by either the "source/expression" or "sourceId/path" definition.
    property compareToSourceIdElement : TFhirString read FCompareToSourceId write SetCompareToSourceId;

    // Typed access to The fluentpath expression to evaluate against the source fixture. When compareToSourceId is defined, either compareToSourceExpression or compareToSourcePath must be defined, but not both.
    property compareToSourceExpression : String read GetCompareToSourceExpressionST write SetCompareToSourceExpressionST;
    // The fluentpath expression to evaluate against the source fixture. When compareToSourceId is defined, either compareToSourceExpression or compareToSourcePath must be defined, but not both.
    property compareToSourceExpressionElement : TFhirString read FCompareToSourceExpression write SetCompareToSourceExpression;

    // Typed access to XPath or JSONPath expression to evaluate against the source fixture. When compareToSourceId is defined, either compareToSourceExpression or compareToSourcePath must be defined, but not both.
    property compareToSourcePath : String read GetCompareToSourcePathST write SetCompareToSourcePathST;
    // XPath or JSONPath expression to evaluate against the source fixture. When compareToSourceId is defined, either compareToSourceExpression or compareToSourcePath must be defined, but not both.
    property compareToSourcePathElement : TFhirString read FCompareToSourcePath write SetCompareToSourcePath;

    // The content-type or mime-type to use for RESTful operation in the 'Content-Type' header.
    property contentType : TFhirContentTypeEnum read GetContentTypeST write SetContentTypeST;
    property contentTypeElement : TFhirEnum read FContentType write SetContentType;

    // Typed access to The fluentpath expression to be evaluated against the request or response message contents - HTTP headers and payload.
    property expression : String read GetExpressionST write SetExpressionST;
    // The fluentpath expression to be evaluated against the request or response message contents - HTTP headers and payload.
    property expressionElement : TFhirString read FExpression write SetExpression;

    // Typed access to The HTTP header field name e.g. 'Location'.
    property headerField : String read GetHeaderFieldST write SetHeaderFieldST;
    // The HTTP header field name e.g. 'Location'.
    property headerFieldElement : TFhirString read FHeaderField write SetHeaderField;

    // Typed access to The ID of a fixture.  Asserts that the response contains at a minimum the fixture specified by minimumId.
    property minimumId : String read GetMinimumIdST write SetMinimumIdST;
    // The ID of a fixture.  Asserts that the response contains at a minimum the fixture specified by minimumId.
    property minimumIdElement : TFhirString read FMinimumId write SetMinimumId;

    // Typed access to Whether or not the test execution performs validation on the bundle navigation links.
    property navigationLinks : Boolean read GetNavigationLinksST write SetNavigationLinksST;
    // Whether or not the test execution performs validation on the bundle navigation links.
    property navigationLinksElement : TFhirBoolean read FNavigationLinks write SetNavigationLinks;

    // The operator type defines the conditional behavior of the assert. If not defined, the default is equals.
    property operator : TFhirAssertOperatorCodesEnum read GetOperatorST write SetOperatorST;
    property operatorElement : TFhirEnum read FOperator write SetOperator;

    // Typed access to The XPath or JSONPath expression to be evaluated against the fixture representing the response received from server.
    property path : String read GetPathST write SetPathST;
    // The XPath or JSONPath expression to be evaluated against the fixture representing the response received from server.
    property pathElement : TFhirString read FPath write SetPath;

    // The request method or HTTP operation code to compare against that used by the client system under test.
    property requestMethod : TFhirHttpOperationsEnum read GetRequestMethodST write SetRequestMethodST;
    property requestMethodElement : TFhirEnum read FRequestMethod write SetRequestMethod;

    // Typed access to The value to use in a comparison against the request URL path string.
    property requestURL : String read GetRequestURLST write SetRequestURLST;
    // The value to use in a comparison against the request URL path string.
    property requestURLElement : TFhirString read FRequestURL write SetRequestURL;

    // Typed access to The type of the resource.  See http://build.fhir.org/resourcelist.html.
    property resource : String read GetResourceST write SetResourceST;
    // The type of the resource.  See http://build.fhir.org/resourcelist.html.
    property resourceElement : TFhirCode read FResource write SetResource;

    // okay | created | noContent | notModified | bad | forbidden | notFound | methodNotAllowed | conflict | gone | preconditionFailed | unprocessable.
    property response : TFhirAssertResponseCodeTypesEnum read GetResponseST write SetResponseST;
    property responseElement : TFhirEnum read FResponse write SetResponse;

    // Typed access to The value of the HTTP response code to be tested.
    property responseCode : String read GetResponseCodeST write SetResponseCodeST;
    // The value of the HTTP response code to be tested.
    property responseCodeElement : TFhirString read FResponseCode write SetResponseCode;

    // Typed access to The TestScript.rule this assert will evaluate. (defined for API consistency)
    property rule : TFhirTestScriptSetupActionAssertRule read FRule write SetRule;
    // The TestScript.rule this assert will evaluate.
    property ruleElement : TFhirTestScriptSetupActionAssertRule read FRule write SetRule;

    // Typed access to The TestScript.ruleset this assert will evaluate. (defined for API consistency)
    property ruleset : TFhirTestScriptSetupActionAssertRuleset read FRuleset write SetRuleset;
    // The TestScript.ruleset this assert will evaluate.
    property rulesetElement : TFhirTestScriptSetupActionAssertRuleset read FRuleset write SetRuleset;

    // Typed access to Fixture to evaluate the XPath/JSONPath expression or the headerField  against.
    property sourceId : String read GetSourceIdST write SetSourceIdST;
    // Fixture to evaluate the XPath/JSONPath expression or the headerField  against.
    property sourceIdElement : TFhirId read FSourceId write SetSourceId;

    // Typed access to The ID of the Profile to validate against.
    property validateProfileId : String read GetValidateProfileIdST write SetValidateProfileIdST;
    // The ID of the Profile to validate against.
    property validateProfileIdElement : TFhirId read FValidateProfileId write SetValidateProfileId;

    // Typed access to The value to compare to.
    property value : String read GetValueST write SetValueST;
    // The value to compare to.
    property valueElement : TFhirString read FValue write SetValue;

    // Typed access to Whether or not the test execution will produce a warning only on error for this assert.
    property warningOnly : Boolean read GetWarningOnlyST write SetWarningOnlyST;
    // Whether or not the test execution will produce a warning only on error for this assert.
    property warningOnlyElement : TFhirBoolean read FWarningOnly write SetWarningOnly;

  end;

  TFhirTestScriptSetupActionAssertListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptSetupActionAssertList;
    function GetCurrent : TFhirTestScriptSetupActionAssert;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptSetupActionAssertList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptSetupActionAssert read GetCurrent;
  end;

  TFhirTestScriptSetupActionAssertList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScriptSetupActionAssert;
    procedure SetItemN(index : Integer; value : TFhirTestScriptSetupActionAssert);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptSetupActionAssertList; Overload;
    function Clone : TFhirTestScriptSetupActionAssertList; Overload;
    function GetEnumerator : TFhirTestScriptSetupActionAssertListEnumerator;

    //  Add a FhirTestScriptSetupActionAssert to the end of the list.
    function Append : TFhirTestScriptSetupActionAssert;

    // Add an already existing FhirTestScriptSetupActionAssert to the end of the list.
    procedure AddItem(value : TFhirTestScriptSetupActionAssert); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptSetupActionAssert) : Integer;

    // Insert FhirTestScriptSetupActionAssert before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptSetupActionAssert;

    // Insert an existing FhirTestScriptSetupActionAssert before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptSetupActionAssert);

    // Get the iIndexth FhirTestScriptSetupActionAssert. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptSetupActionAssert);

    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptSetupActionAssert;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirTestScriptSetupActionAsserts[index : Integer] : TFhirTestScriptSetupActionAssert read GetItemN write SetItemN; default;
  End;

  // The TestScript.rule this assert will evaluate.
  TFhirTestScriptSetupActionAssertRule = class (TFhirBackboneElement)
  protected
    FRuleId : TFhirId;
    FparamList : TFhirTestScriptSetupActionAssertRuleParamList;
    Procedure SetRuleId(value : TFhirId);
    Function GetRuleIdST : String;
    Procedure SetRuleIdST(value : String);
    function GetParamList : TFhirTestScriptSetupActionAssertRuleParamList;
    function GetHasParamList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptSetupActionAssertRule; overload;
    function Clone : TFhirTestScriptSetupActionAssertRule; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The TestScript.rule id value this assert will evaluate.
    property ruleId : String read GetRuleIdST write SetRuleIdST;
    // The TestScript.rule id value this assert will evaluate.
    property ruleIdElement : TFhirId read FRuleId write SetRuleId;

    // Each rule template can take one or more parameters for rule evaluation.
    property paramList : TFhirTestScriptSetupActionAssertRuleParamList read GetParamList;
    property hasParamList : boolean read GetHasParamList;

  end;

  TFhirTestScriptSetupActionAssertRuleListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptSetupActionAssertRuleList;
    function GetCurrent : TFhirTestScriptSetupActionAssertRule;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptSetupActionAssertRuleList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptSetupActionAssertRule read GetCurrent;
  end;

  TFhirTestScriptSetupActionAssertRuleList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScriptSetupActionAssertRule;
    procedure SetItemN(index : Integer; value : TFhirTestScriptSetupActionAssertRule);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptSetupActionAssertRuleList; Overload;
    function Clone : TFhirTestScriptSetupActionAssertRuleList; Overload;
    function GetEnumerator : TFhirTestScriptSetupActionAssertRuleListEnumerator;

    //  Add a FhirTestScriptSetupActionAssertRule to the end of the list.
    function Append : TFhirTestScriptSetupActionAssertRule;

    // Add an already existing FhirTestScriptSetupActionAssertRule to the end of the list.
    procedure AddItem(value : TFhirTestScriptSetupActionAssertRule); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptSetupActionAssertRule) : Integer;

    // Insert FhirTestScriptSetupActionAssertRule before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptSetupActionAssertRule;

    // Insert an existing FhirTestScriptSetupActionAssertRule before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptSetupActionAssertRule);

    // Get the iIndexth FhirTestScriptSetupActionAssertRule. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptSetupActionAssertRule);

    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptSetupActionAssertRule;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirTestScriptSetupActionAssertRules[index : Integer] : TFhirTestScriptSetupActionAssertRule read GetItemN write SetItemN; default;
  End;

  // Each rule template can take one or more parameters for rule evaluation.
  TFhirTestScriptSetupActionAssertRuleParam = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FValue : TFhirString;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetValue(value : TFhirString);
    Function GetValueST : String;
    Procedure SetValueST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptSetupActionAssertRuleParam; overload;
    function Clone : TFhirTestScriptSetupActionAssertRuleParam; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Descriptive name for this parameter that matches the external assert rule parameter name.
    property name : String read GetNameST write SetNameST;
    // Descriptive name for this parameter that matches the external assert rule parameter name.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to The value for the parameter that will be passed on to the external rule template.
    property value : String read GetValueST write SetValueST;
    // The value for the parameter that will be passed on to the external rule template.
    property valueElement : TFhirString read FValue write SetValue;

  end;

  TFhirTestScriptSetupActionAssertRuleParamListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptSetupActionAssertRuleParamList;
    function GetCurrent : TFhirTestScriptSetupActionAssertRuleParam;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptSetupActionAssertRuleParamList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptSetupActionAssertRuleParam read GetCurrent;
  end;

  TFhirTestScriptSetupActionAssertRuleParamList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScriptSetupActionAssertRuleParam;
    procedure SetItemN(index : Integer; value : TFhirTestScriptSetupActionAssertRuleParam);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptSetupActionAssertRuleParamList; Overload;
    function Clone : TFhirTestScriptSetupActionAssertRuleParamList; Overload;
    function GetEnumerator : TFhirTestScriptSetupActionAssertRuleParamListEnumerator;

    //  Add a FhirTestScriptSetupActionAssertRuleParam to the end of the list.
    function Append : TFhirTestScriptSetupActionAssertRuleParam;

    // Add an already existing FhirTestScriptSetupActionAssertRuleParam to the end of the list.
    procedure AddItem(value : TFhirTestScriptSetupActionAssertRuleParam); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptSetupActionAssertRuleParam) : Integer;

    // Insert FhirTestScriptSetupActionAssertRuleParam before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptSetupActionAssertRuleParam;

    // Insert an existing FhirTestScriptSetupActionAssertRuleParam before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptSetupActionAssertRuleParam);

    // Get the iIndexth FhirTestScriptSetupActionAssertRuleParam. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptSetupActionAssertRuleParam);

    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptSetupActionAssertRuleParam;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirTestScriptSetupActionAssertRuleParams[index : Integer] : TFhirTestScriptSetupActionAssertRuleParam read GetItemN write SetItemN; default;
  End;

  // The TestScript.ruleset this assert will evaluate.
  TFhirTestScriptSetupActionAssertRuleset = class (TFhirBackboneElement)
  protected
    FRulesetId : TFhirId;
    FruleList : TFhirTestScriptSetupActionAssertRulesetRuleList;
    Procedure SetRulesetId(value : TFhirId);
    Function GetRulesetIdST : String;
    Procedure SetRulesetIdST(value : String);
    function GetRuleList : TFhirTestScriptSetupActionAssertRulesetRuleList;
    function GetHasRuleList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptSetupActionAssertRuleset; overload;
    function Clone : TFhirTestScriptSetupActionAssertRuleset; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The TestScript.ruleset id value this assert will evaluate.
    property rulesetId : String read GetRulesetIdST write SetRulesetIdST;
    // The TestScript.ruleset id value this assert will evaluate.
    property rulesetIdElement : TFhirId read FRulesetId write SetRulesetId;

    // The referenced rule within the external ruleset template.
    property ruleList : TFhirTestScriptSetupActionAssertRulesetRuleList read GetRuleList;
    property hasRuleList : boolean read GetHasRuleList;

  end;

  TFhirTestScriptSetupActionAssertRulesetListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptSetupActionAssertRulesetList;
    function GetCurrent : TFhirTestScriptSetupActionAssertRuleset;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptSetupActionAssertRulesetList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptSetupActionAssertRuleset read GetCurrent;
  end;

  TFhirTestScriptSetupActionAssertRulesetList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScriptSetupActionAssertRuleset;
    procedure SetItemN(index : Integer; value : TFhirTestScriptSetupActionAssertRuleset);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptSetupActionAssertRulesetList; Overload;
    function Clone : TFhirTestScriptSetupActionAssertRulesetList; Overload;
    function GetEnumerator : TFhirTestScriptSetupActionAssertRulesetListEnumerator;

    //  Add a FhirTestScriptSetupActionAssertRuleset to the end of the list.
    function Append : TFhirTestScriptSetupActionAssertRuleset;

    // Add an already existing FhirTestScriptSetupActionAssertRuleset to the end of the list.
    procedure AddItem(value : TFhirTestScriptSetupActionAssertRuleset); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptSetupActionAssertRuleset) : Integer;

    // Insert FhirTestScriptSetupActionAssertRuleset before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptSetupActionAssertRuleset;

    // Insert an existing FhirTestScriptSetupActionAssertRuleset before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptSetupActionAssertRuleset);

    // Get the iIndexth FhirTestScriptSetupActionAssertRuleset. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptSetupActionAssertRuleset);

    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptSetupActionAssertRuleset;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirTestScriptSetupActionAssertRulesets[index : Integer] : TFhirTestScriptSetupActionAssertRuleset read GetItemN write SetItemN; default;
  End;

  // The referenced rule within the external ruleset template.
  TFhirTestScriptSetupActionAssertRulesetRule = class (TFhirBackboneElement)
  protected
    FRuleId : TFhirId;
    FparamList : TFhirTestScriptSetupActionAssertRulesetRuleParamList;
    Procedure SetRuleId(value : TFhirId);
    Function GetRuleIdST : String;
    Procedure SetRuleIdST(value : String);
    function GetParamList : TFhirTestScriptSetupActionAssertRulesetRuleParamList;
    function GetHasParamList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptSetupActionAssertRulesetRule; overload;
    function Clone : TFhirTestScriptSetupActionAssertRulesetRule; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Id of the referenced rule within the external ruleset template.
    property ruleId : String read GetRuleIdST write SetRuleIdST;
    // Id of the referenced rule within the external ruleset template.
    property ruleIdElement : TFhirId read FRuleId write SetRuleId;

    // Each rule template can take one or more parameters for rule evaluation.
    property paramList : TFhirTestScriptSetupActionAssertRulesetRuleParamList read GetParamList;
    property hasParamList : boolean read GetHasParamList;

  end;

  TFhirTestScriptSetupActionAssertRulesetRuleListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptSetupActionAssertRulesetRuleList;
    function GetCurrent : TFhirTestScriptSetupActionAssertRulesetRule;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptSetupActionAssertRulesetRuleList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptSetupActionAssertRulesetRule read GetCurrent;
  end;

  TFhirTestScriptSetupActionAssertRulesetRuleList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScriptSetupActionAssertRulesetRule;
    procedure SetItemN(index : Integer; value : TFhirTestScriptSetupActionAssertRulesetRule);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptSetupActionAssertRulesetRuleList; Overload;
    function Clone : TFhirTestScriptSetupActionAssertRulesetRuleList; Overload;
    function GetEnumerator : TFhirTestScriptSetupActionAssertRulesetRuleListEnumerator;

    //  Add a FhirTestScriptSetupActionAssertRulesetRule to the end of the list.
    function Append : TFhirTestScriptSetupActionAssertRulesetRule;

    // Add an already existing FhirTestScriptSetupActionAssertRulesetRule to the end of the list.
    procedure AddItem(value : TFhirTestScriptSetupActionAssertRulesetRule); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptSetupActionAssertRulesetRule) : Integer;

    // Insert FhirTestScriptSetupActionAssertRulesetRule before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptSetupActionAssertRulesetRule;

    // Insert an existing FhirTestScriptSetupActionAssertRulesetRule before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptSetupActionAssertRulesetRule);

    // Get the iIndexth FhirTestScriptSetupActionAssertRulesetRule. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptSetupActionAssertRulesetRule);

    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptSetupActionAssertRulesetRule;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirTestScriptSetupActionAssertRulesetRules[index : Integer] : TFhirTestScriptSetupActionAssertRulesetRule read GetItemN write SetItemN; default;
  End;

  // Each rule template can take one or more parameters for rule evaluation.
  TFhirTestScriptSetupActionAssertRulesetRuleParam = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FValue : TFhirString;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetValue(value : TFhirString);
    Function GetValueST : String;
    Procedure SetValueST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptSetupActionAssertRulesetRuleParam; overload;
    function Clone : TFhirTestScriptSetupActionAssertRulesetRuleParam; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Descriptive name for this parameter that matches the external assert ruleset rule parameter name.
    property name : String read GetNameST write SetNameST;
    // Descriptive name for this parameter that matches the external assert ruleset rule parameter name.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to The value for the parameter that will be passed on to the external ruleset rule template.
    property value : String read GetValueST write SetValueST;
    // The value for the parameter that will be passed on to the external ruleset rule template.
    property valueElement : TFhirString read FValue write SetValue;

  end;

  TFhirTestScriptSetupActionAssertRulesetRuleParamListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptSetupActionAssertRulesetRuleParamList;
    function GetCurrent : TFhirTestScriptSetupActionAssertRulesetRuleParam;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptSetupActionAssertRulesetRuleParamList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptSetupActionAssertRulesetRuleParam read GetCurrent;
  end;

  TFhirTestScriptSetupActionAssertRulesetRuleParamList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScriptSetupActionAssertRulesetRuleParam;
    procedure SetItemN(index : Integer; value : TFhirTestScriptSetupActionAssertRulesetRuleParam);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptSetupActionAssertRulesetRuleParamList; Overload;
    function Clone : TFhirTestScriptSetupActionAssertRulesetRuleParamList; Overload;
    function GetEnumerator : TFhirTestScriptSetupActionAssertRulesetRuleParamListEnumerator;

    //  Add a FhirTestScriptSetupActionAssertRulesetRuleParam to the end of the list.
    function Append : TFhirTestScriptSetupActionAssertRulesetRuleParam;

    // Add an already existing FhirTestScriptSetupActionAssertRulesetRuleParam to the end of the list.
    procedure AddItem(value : TFhirTestScriptSetupActionAssertRulesetRuleParam); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptSetupActionAssertRulesetRuleParam) : Integer;

    // Insert FhirTestScriptSetupActionAssertRulesetRuleParam before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptSetupActionAssertRulesetRuleParam;

    // Insert an existing FhirTestScriptSetupActionAssertRulesetRuleParam before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptSetupActionAssertRulesetRuleParam);

    // Get the iIndexth FhirTestScriptSetupActionAssertRulesetRuleParam. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptSetupActionAssertRulesetRuleParam);

    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptSetupActionAssertRulesetRuleParam;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirTestScriptSetupActionAssertRulesetRuleParams[index : Integer] : TFhirTestScriptSetupActionAssertRulesetRuleParam read GetItemN write SetItemN; default;
  End;

  // A test in this script.
  TFhirTestScriptTest = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FDescription : TFhirString;
    FactionList : TFhirTestScriptTestActionList;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetDescription(value : TFhirString);
    Function GetDescriptionST : String;
    Procedure SetDescriptionST(value : String);
    function GetActionList : TFhirTestScriptTestActionList;
    function GetHasActionList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptTest; overload;
    function Clone : TFhirTestScriptTest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The name of this test used for tracking/logging purposes by test engines.
    property name : String read GetNameST write SetNameST;
    // The name of this test used for tracking/logging purposes by test engines.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short description of the test used by test engines for tracking and reporting purposes.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A short description of the test used by test engines for tracking and reporting purposes.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Action would contain either an operation or an assertion.
    property actionList : TFhirTestScriptTestActionList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

  end;

  TFhirTestScriptTestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptTestList;
    function GetCurrent : TFhirTestScriptTest;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptTestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptTest read GetCurrent;
  end;

  TFhirTestScriptTestList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScriptTest;
    procedure SetItemN(index : Integer; value : TFhirTestScriptTest);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptTestList; Overload;
    function Clone : TFhirTestScriptTestList; Overload;
    function GetEnumerator : TFhirTestScriptTestListEnumerator;

    //  Add a FhirTestScriptTest to the end of the list.
    function Append : TFhirTestScriptTest;

    // Add an already existing FhirTestScriptTest to the end of the list.
    procedure AddItem(value : TFhirTestScriptTest); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptTest) : Integer;

    // Insert FhirTestScriptTest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptTest;

    // Insert an existing FhirTestScriptTest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptTest);

    // Get the iIndexth FhirTestScriptTest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptTest);

    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptTest;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirTestScriptTests[index : Integer] : TFhirTestScriptTest read GetItemN write SetItemN; default;
  End;

  // Action would contain either an operation or an assertion.
  TFhirTestScriptTestAction = class (TFhirBackboneElement)
  protected
    FOperation : TFhirTestScriptSetupActionOperation;
    FAssert : TFhirTestScriptSetupActionAssert;
    Procedure SetOperation(value : TFhirTestScriptSetupActionOperation);
    Procedure SetAssert(value : TFhirTestScriptSetupActionAssert);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptTestAction; overload;
    function Clone : TFhirTestScriptTestAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An operation would involve a REST request to a server. (defined for API consistency)
    property operation : TFhirTestScriptSetupActionOperation read FOperation write SetOperation;
    // An operation would involve a REST request to a server.
    property operationElement : TFhirTestScriptSetupActionOperation read FOperation write SetOperation;

    // Typed access to Evaluates the results of previous operations to determine if the server under test behaves appropriately. (defined for API consistency)
    property assert : TFhirTestScriptSetupActionAssert read FAssert write SetAssert;
    // Evaluates the results of previous operations to determine if the server under test behaves appropriately.
    property assertElement : TFhirTestScriptSetupActionAssert read FAssert write SetAssert;

  end;

  TFhirTestScriptTestActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptTestActionList;
    function GetCurrent : TFhirTestScriptTestAction;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptTestActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptTestAction read GetCurrent;
  end;

  TFhirTestScriptTestActionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScriptTestAction;
    procedure SetItemN(index : Integer; value : TFhirTestScriptTestAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptTestActionList; Overload;
    function Clone : TFhirTestScriptTestActionList; Overload;
    function GetEnumerator : TFhirTestScriptTestActionListEnumerator;

    //  Add a FhirTestScriptTestAction to the end of the list.
    function Append : TFhirTestScriptTestAction;

    // Add an already existing FhirTestScriptTestAction to the end of the list.
    procedure AddItem(value : TFhirTestScriptTestAction); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptTestAction) : Integer;

    // Insert FhirTestScriptTestAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptTestAction;

    // Insert an existing FhirTestScriptTestAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptTestAction);

    // Get the iIndexth FhirTestScriptTestAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptTestAction);

    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptTestAction;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirTestScriptTestActions[index : Integer] : TFhirTestScriptTestAction read GetItemN write SetItemN; default;
  End;

  // A series of operations required to clean up after the all the tests are executed (successfully or otherwise).
  TFhirTestScriptTeardown = class (TFhirBackboneElement)
  protected
    FactionList : TFhirTestScriptTeardownActionList;
    function GetActionList : TFhirTestScriptTeardownActionList;
    function GetHasActionList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptTeardown; overload;
    function Clone : TFhirTestScriptTeardown; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // The teardown action will only contain an operation.
    property actionList : TFhirTestScriptTeardownActionList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

  end;

  TFhirTestScriptTeardownListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptTeardownList;
    function GetCurrent : TFhirTestScriptTeardown;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptTeardownList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptTeardown read GetCurrent;
  end;

  TFhirTestScriptTeardownList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScriptTeardown;
    procedure SetItemN(index : Integer; value : TFhirTestScriptTeardown);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptTeardownList; Overload;
    function Clone : TFhirTestScriptTeardownList; Overload;
    function GetEnumerator : TFhirTestScriptTeardownListEnumerator;

    //  Add a FhirTestScriptTeardown to the end of the list.
    function Append : TFhirTestScriptTeardown;

    // Add an already existing FhirTestScriptTeardown to the end of the list.
    procedure AddItem(value : TFhirTestScriptTeardown); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptTeardown) : Integer;

    // Insert FhirTestScriptTeardown before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptTeardown;

    // Insert an existing FhirTestScriptTeardown before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptTeardown);

    // Get the iIndexth FhirTestScriptTeardown. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptTeardown);

    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptTeardown;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirTestScriptTeardowns[index : Integer] : TFhirTestScriptTeardown read GetItemN write SetItemN; default;
  End;

  // The teardown action will only contain an operation.
  TFhirTestScriptTeardownAction = class (TFhirBackboneElement)
  protected
    FOperation : TFhirTestScriptSetupActionOperation;
    Procedure SetOperation(value : TFhirTestScriptSetupActionOperation);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScriptTeardownAction; overload;
    function Clone : TFhirTestScriptTeardownAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An operation would involve a REST request to a server. (defined for API consistency)
    property operation : TFhirTestScriptSetupActionOperation read FOperation write SetOperation;
    // An operation would involve a REST request to a server.
    property operationElement : TFhirTestScriptSetupActionOperation read FOperation write SetOperation;

  end;

  TFhirTestScriptTeardownActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptTeardownActionList;
    function GetCurrent : TFhirTestScriptTeardownAction;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptTeardownActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScriptTeardownAction read GetCurrent;
  end;

  TFhirTestScriptTeardownActionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScriptTeardownAction;
    procedure SetItemN(index : Integer; value : TFhirTestScriptTeardownAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptTeardownActionList; Overload;
    function Clone : TFhirTestScriptTeardownActionList; Overload;
    function GetEnumerator : TFhirTestScriptTeardownActionListEnumerator;

    //  Add a FhirTestScriptTeardownAction to the end of the list.
    function Append : TFhirTestScriptTeardownAction;

    // Add an already existing FhirTestScriptTeardownAction to the end of the list.
    procedure AddItem(value : TFhirTestScriptTeardownAction); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScriptTeardownAction) : Integer;

    // Insert FhirTestScriptTeardownAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScriptTeardownAction;

    // Insert an existing FhirTestScriptTeardownAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScriptTeardownAction);

    // Get the iIndexth FhirTestScriptTeardownAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScriptTeardownAction);

    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScriptTeardownAction;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirTestScriptTeardownActions[index : Integer] : TFhirTestScriptTeardownAction read GetItemN write SetItemN; default;
  End;

  // A structured set of tests against a FHIR server implementation to determine compliance against the FHIR specification.
  TFhirTestScript = class (TFhirMetadataResource)
  protected
    FIdentifier : TFhirIdentifier;
    FPurpose : TFhirMarkdown;
    FCopyright : TFhirMarkdown;
    ForiginList : TFhirTestScriptOriginList;
    FdestinationList : TFhirTestScriptDestinationList;
    FMetadata : TFhirTestScriptMetadata;
    FfixtureList : TFhirTestScriptFixtureList;
    FprofileList : TFhirReferenceList{TFhirReference};
    FvariableList : TFhirTestScriptVariableList;
    FruleList : TFhirTestScriptRuleList;
    FrulesetList : TFhirTestScriptRulesetList;
    FSetup : TFhirTestScriptSetup;
    FtestList : TFhirTestScriptTestList;
    FTeardown : TFhirTestScriptTeardown;
    Procedure SetIdentifier(value : TFhirIdentifier);
    Procedure SetPurpose(value : TFhirMarkdown);
    Function GetPurposeST : String;
    Procedure SetPurposeST(value : String);
    Procedure SetCopyright(value : TFhirMarkdown);
    Function GetCopyrightST : String;
    Procedure SetCopyrightST(value : String);
    function GetOriginList : TFhirTestScriptOriginList;
    function GetHasOriginList : Boolean;
    function GetDestinationList : TFhirTestScriptDestinationList;
    function GetHasDestinationList : Boolean;
    Procedure SetMetadata(value : TFhirTestScriptMetadata);
    function GetFixtureList : TFhirTestScriptFixtureList;
    function GetHasFixtureList : Boolean;
    function GetProfileList : TFhirReferenceList{TFhirReference};
    function GetHasProfileList : Boolean;
    function GetVariableList : TFhirTestScriptVariableList;
    function GetHasVariableList : Boolean;
    function GetRuleList : TFhirTestScriptRuleList;
    function GetHasRuleList : Boolean;
    function GetRulesetList : TFhirTestScriptRulesetList;
    function GetHasRulesetList : Boolean;
    Procedure SetSetup(value : TFhirTestScriptSetup);
    function GetTestList : TFhirTestScriptTestList;
    function GetHasTestList : Boolean;
    Procedure SetTeardown(value : TFhirTestScriptTeardown);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestScript; overload;
    function Clone : TFhirTestScript; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this test script when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this test script is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the test script. For more information see [Technical and Business Versions](resource.html#versions).
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this test script when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this test script is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the test script. For more information see [Technical and Business Versions](resource.html#versions).
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to A formal identifier that is used to identify this test script when it is represented in other formats, or referenced in a specification, model, design or an instance. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // A formal identifier that is used to identify this test script when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to The identifier that is used to identify this version of the test script when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the test script author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the test script when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the test script author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the test script. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the test script. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the test script.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the test script.
    property titleElement : TFhirString read FTitle write SetTitle;

    // The status of this test script. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A boolean value to indicate that this test script is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A boolean value to indicate that this test script is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The date  (and optionally time) when the test script was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the test script changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the test script was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the test script changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the test script.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the test script.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the test script from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the test script from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These terms may be used to assist with indexing and searching for appropriate test script instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the test script is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to Explaination of why this test script is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explaination of why this test script is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Typed access to A copyright statement relating to the test script and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the test script.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the test script and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the test script.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // An abstract server used in operations within this test script in the origin element.
    property originList : TFhirTestScriptOriginList read GetOriginList;
    property hasOriginList : boolean read GetHasOriginList;

    // An abstract server used in operations within this test script in the destination element.
    property destinationList : TFhirTestScriptDestinationList read GetDestinationList;
    property hasDestinationList : boolean read GetHasDestinationList;

    // Typed access to The required capability must exist and are assumed to function correctly on the FHIR server being tested. (defined for API consistency)
    property metadata : TFhirTestScriptMetadata read FMetadata write SetMetadata;
    // The required capability must exist and are assumed to function correctly on the FHIR server being tested.
    property metadataElement : TFhirTestScriptMetadata read FMetadata write SetMetadata;

    // Fixture in the test script - by reference (uri). All fixtures are required for the test script to execute.
    property fixtureList : TFhirTestScriptFixtureList read GetFixtureList;
    property hasFixtureList : boolean read GetHasFixtureList;

    // Reference to the profile to be used for validation.
    property profileList : TFhirReferenceList{TFhirReference} read GetProfileList;
    property hasProfileList : boolean read GetHasProfileList;

    // Variable is set based either on element value in response body or on header field value in the response headers.
    property variableList : TFhirTestScriptVariableList read GetVariableList;
    property hasVariableList : boolean read GetHasVariableList;

    // Assert rule to be used in one or more asserts within the test script.
    property ruleList : TFhirTestScriptRuleList read GetRuleList;
    property hasRuleList : boolean read GetHasRuleList;

    // Contains one or more rules.  Offers a way to group rules so assertions could reference the group of rules and have them all applied.
    property rulesetList : TFhirTestScriptRulesetList read GetRulesetList;
    property hasRulesetList : boolean read GetHasRulesetList;

    // Typed access to A series of required setup operations before tests are executed. (defined for API consistency)
    property setup : TFhirTestScriptSetup read FSetup write SetSetup;
    // A series of required setup operations before tests are executed.
    property setupElement : TFhirTestScriptSetup read FSetup write SetSetup;

    // A test in this script.
    property testList : TFhirTestScriptTestList read GetTestList;
    property hasTestList : boolean read GetHasTestList;

    // Typed access to A series of operations required to clean up after the all the tests are executed (successfully or otherwise). (defined for API consistency)
    property teardown : TFhirTestScriptTeardown read FTeardown write SetTeardown;
    // A series of operations required to clean up after the all the tests are executed (successfully or otherwise).
    property teardownElement : TFhirTestScriptTeardown read FTeardown write SetTeardown;

  end;

  TFhirTestScriptListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestScriptList;
    function GetCurrent : TFhirTestScript;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirTestScriptList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestScript read GetCurrent;
  end;

  TFhirTestScriptList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirTestScript;
    procedure SetItemN(index : Integer; value : TFhirTestScript);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirTestScriptList; Overload;
    function Clone : TFhirTestScriptList; Overload;
    function GetEnumerator : TFhirTestScriptListEnumerator;

    //  Add a FhirTestScript to the end of the list.
    function Append : TFhirTestScript;

    // Add an already existing FhirTestScript to the end of the list.
    procedure AddItem(value : TFhirTestScript); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestScript) : Integer;

    // Insert FhirTestScript before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestScript;

    // Insert an existing FhirTestScript before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestScript);

    // Get the iIndexth FhirTestScript. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestScript);

    // The number of items in the collection
    function Item(index : Integer) : TFhirTestScript;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirTestScripts[index : Integer] : TFhirTestScript read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_TESTSCRIPT}

{$IFDEF FHIR_VALUESET}

  // A set of criteria that define the content logical definition of the value set by including or excluding codes from outside this value set. This I also known as the "Content Logical Definition" (CLD).
  TFhirValueSetCompose = class (TFhirBackboneElement)
  protected
    FLockedDate : TFhirDate;
    FInactive : TFhirBoolean;
    FincludeList : TFhirValueSetComposeIncludeList;
    FexcludeList : TFhirValueSetComposeIncludeList;
    Procedure SetLockedDate(value : TFhirDate);
    Function GetLockedDateST : TFslDateTime;
    Procedure SetLockedDateST(value : TFslDateTime);
    Procedure SetInactive(value : TFhirBoolean);
    Function GetInactiveST : Boolean;
    Procedure SetInactiveST(value : Boolean);
    function GetIncludeList : TFhirValueSetComposeIncludeList;
    function GetHasIncludeList : Boolean;
    function GetExcludeList : TFhirValueSetComposeIncludeList;
    function GetHasExcludeList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirValueSetCompose; overload;
    function Clone : TFhirValueSetCompose; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to If a locked date is defined, then the Content Logical Definition must be evaluated using the current version as of the locked date for referenced code system(s) and value set instances where ValueSet.compose.include.version is not defined.
    property lockedDate : TFslDateTime read GetLockedDateST write SetLockedDateST;
    // If a locked date is defined, then the Content Logical Definition must be evaluated using the current version as of the locked date for referenced code system(s) and value set instances where ValueSet.compose.include.version is not defined.
    property lockedDateElement : TFhirDate read FLockedDate write SetLockedDate;

    // Typed access to Whether inactive codes - codes that are not approved for current use - are in the value set. If inactive = true, inactive codes are to be included in the expansion, if inactive = false, the inactive codes will not be included in the expansion. If absent, the behavior is determined by the implementation, or by the applicable ExpansionProfile (but generally, inactive codes would be expected to be included).
    property inactive : Boolean read GetInactiveST write SetInactiveST;
    // Whether inactive codes - codes that are not approved for current use - are in the value set. If inactive = true, inactive codes are to be included in the expansion, if inactive = false, the inactive codes will not be included in the expansion. If absent, the behavior is determined by the implementation, or by the applicable ExpansionProfile (but generally, inactive codes would be expected to be included).
    property inactiveElement : TFhirBoolean read FInactive write SetInactive;

    // Include one or more codes from a code system or other value set(s).
    property includeList : TFhirValueSetComposeIncludeList read GetIncludeList;
    property hasIncludeList : boolean read GetHasIncludeList;

    // Exclude one or more codes from the value set based on code system filters and/or other value sets.
    property excludeList : TFhirValueSetComposeIncludeList read GetExcludeList;
    property hasExcludeList : boolean read GetHasExcludeList;

  end;

  TFhirValueSetComposeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirValueSetComposeList;
    function GetCurrent : TFhirValueSetCompose;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirValueSetComposeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirValueSetCompose read GetCurrent;
  end;

  TFhirValueSetComposeList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirValueSetCompose;
    procedure SetItemN(index : Integer; value : TFhirValueSetCompose);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirValueSetComposeList; Overload;
    function Clone : TFhirValueSetComposeList; Overload;
    function GetEnumerator : TFhirValueSetComposeListEnumerator;

    //  Add a FhirValueSetCompose to the end of the list.
    function Append : TFhirValueSetCompose;

    // Add an already existing FhirValueSetCompose to the end of the list.
    procedure AddItem(value : TFhirValueSetCompose); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirValueSetCompose) : Integer;

    // Insert FhirValueSetCompose before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirValueSetCompose;

    // Insert an existing FhirValueSetCompose before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirValueSetCompose);

    // Get the iIndexth FhirValueSetCompose. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetCompose);

    // The number of items in the collection
    function Item(index : Integer) : TFhirValueSetCompose;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirValueSetComposes[index : Integer] : TFhirValueSetCompose read GetItemN write SetItemN; default;
  End;

  // Include one or more codes from a code system or other value set(s).
  TFhirValueSetComposeInclude = class (TFhirBackboneElement)
  protected
    FSystem : TFhirUri;
    FVersion : TFhirString;
    FconceptList : TFhirValueSetComposeIncludeConceptList;
    FfilterList : TFhirValueSetComposeIncludeFilterList;
    FvalueSetList : TFhirUriList;
    Procedure SetSystem(value : TFhirUri);
    Function GetSystemST : String;
    Procedure SetSystemST(value : String);
    Procedure SetVersion(value : TFhirString);
    Function GetVersionST : String;
    Procedure SetVersionST(value : String);
    function GetConceptList : TFhirValueSetComposeIncludeConceptList;
    function GetHasConceptList : Boolean;
    function GetFilterList : TFhirValueSetComposeIncludeFilterList;
    function GetHasFilterList : Boolean;
    function GetValueSetList : TFhirUriList;
    function GetHasValueSetList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirValueSetComposeInclude; overload;
    function Clone : TFhirValueSetComposeInclude; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An absolute URI which is the code system from which the selected codes come from.
    property system : String read GetSystemST write SetSystemST;
    // An absolute URI which is the code system from which the selected codes come from.
    property systemElement : TFhirUri read FSystem write SetSystem;

    // Typed access to The version of the code system that the codes are selected from.
    property version : String read GetVersionST write SetVersionST;
    // The version of the code system that the codes are selected from.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Specifies a concept to be included or excluded.
    property conceptList : TFhirValueSetComposeIncludeConceptList read GetConceptList;
    property hasConceptList : boolean read GetHasConceptList;

    // Select concepts by specify a matching criteria based on the properties (including relationships) defined by the system. If multiple filters are specified, they SHALL all be true.
    property filterList : TFhirValueSetComposeIncludeFilterList read GetFilterList;
    property hasFilterList : boolean read GetHasFilterList;

    // Selects concepts found in this value set. This is an absolute URI that is a reference to ValueSet.url.
    property valueSetList : TFhirUriList read GetValueSetList;
    property hasValueSetList : boolean read GetHasValueSetList;

  end;

  TFhirValueSetComposeIncludeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirValueSetComposeIncludeList;
    function GetCurrent : TFhirValueSetComposeInclude;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirValueSetComposeIncludeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirValueSetComposeInclude read GetCurrent;
  end;

  TFhirValueSetComposeIncludeList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirValueSetComposeInclude;
    procedure SetItemN(index : Integer; value : TFhirValueSetComposeInclude);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirValueSetComposeIncludeList; Overload;
    function Clone : TFhirValueSetComposeIncludeList; Overload;
    function GetEnumerator : TFhirValueSetComposeIncludeListEnumerator;

    //  Add a FhirValueSetComposeInclude to the end of the list.
    function Append : TFhirValueSetComposeInclude;

    // Add an already existing FhirValueSetComposeInclude to the end of the list.
    procedure AddItem(value : TFhirValueSetComposeInclude); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirValueSetComposeInclude) : Integer;

    // Insert FhirValueSetComposeInclude before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirValueSetComposeInclude;

    // Insert an existing FhirValueSetComposeInclude before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirValueSetComposeInclude);

    // Get the iIndexth FhirValueSetComposeInclude. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetComposeInclude);

    // The number of items in the collection
    function Item(index : Integer) : TFhirValueSetComposeInclude;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirValueSetComposeIncludes[index : Integer] : TFhirValueSetComposeInclude read GetItemN write SetItemN; default;
  End;

  // Specifies a concept to be included or excluded.
  TFhirValueSetComposeIncludeConcept = class (TFhirBackboneElement)
  protected
    FCode : TFhirCode;
    FDisplay : TFhirString;
    FdesignationList : TFhirValueSetComposeIncludeConceptDesignationList;
    Procedure SetCode(value : TFhirCode);
    Function GetCodeST : String;
    Procedure SetCodeST(value : String);
    Procedure SetDisplay(value : TFhirString);
    Function GetDisplayST : String;
    Procedure SetDisplayST(value : String);
    function GetDesignationList : TFhirValueSetComposeIncludeConceptDesignationList;
    function GetHasDesignationList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirValueSetComposeIncludeConcept; overload;
    function Clone : TFhirValueSetComposeIncludeConcept; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to Specifies a code for the concept to be included or excluded.
    property code : String read GetCodeST write SetCodeST;
    // Specifies a code for the concept to be included or excluded.
    property codeElement : TFhirCode read FCode write SetCode;

    // Typed access to The text to display to the user for this concept in the context of this valueset. If no display is provided, then applications using the value set use the display specified for the code by the system.
    property display : String read GetDisplayST write SetDisplayST;
    // The text to display to the user for this concept in the context of this valueset. If no display is provided, then applications using the value set use the display specified for the code by the system.
    property displayElement : TFhirString read FDisplay write SetDisplay;

    // Additional representations for this concept when used in this value set - other languages, aliases, specialized purposes, used for particular purposes, etc.
    property designationList : TFhirValueSetComposeIncludeConceptDesignationList read GetDesignationList;
    property hasDesignationList : boolean read GetHasDesignationList;

  end;

  TFhirValueSetComposeIncludeConceptListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirValueSetComposeIncludeConceptList;
    function GetCurrent : TFhirValueSetComposeIncludeConcept;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirValueSetComposeIncludeConceptList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirValueSetComposeIncludeConcept read GetCurrent;
  end;

  TFhirValueSetComposeIncludeConceptList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirValueSetComposeIncludeConcept;
    procedure SetItemN(index : Integer; value : TFhirValueSetComposeIncludeConcept);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirValueSetComposeIncludeConceptList; Overload;
    function Clone : TFhirValueSetComposeIncludeConceptList; Overload;
    function GetEnumerator : TFhirValueSetComposeIncludeConceptListEnumerator;

    //  Add a FhirValueSetComposeIncludeConcept to the end of the list.
    function Append : TFhirValueSetComposeIncludeConcept;

    // Add an already existing FhirValueSetComposeIncludeConcept to the end of the list.
    procedure AddItem(value : TFhirValueSetComposeIncludeConcept); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirValueSetComposeIncludeConcept) : Integer;

    // Insert FhirValueSetComposeIncludeConcept before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirValueSetComposeIncludeConcept;

    // Insert an existing FhirValueSetComposeIncludeConcept before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirValueSetComposeIncludeConcept);

    // Get the iIndexth FhirValueSetComposeIncludeConcept. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetComposeIncludeConcept);

    // The number of items in the collection
    function Item(index : Integer) : TFhirValueSetComposeIncludeConcept;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirValueSetComposeIncludeConcepts[index : Integer] : TFhirValueSetComposeIncludeConcept read GetItemN write SetItemN; default;
  End;

  // Additional representations for this concept when used in this value set - other languages, aliases, specialized purposes, used for particular purposes, etc.
  TFhirValueSetComposeIncludeConceptDesignation = class (TFhirBackboneElement)
  protected
    FLanguage : TFhirCode;
    FUse : TFhirCoding;
    FValue : TFhirString;
    Procedure SetLanguage(value : TFhirCode);
    Function GetLanguageST : String;
    Procedure SetLanguageST(value : String);
    Procedure SetUse(value : TFhirCoding);
    Procedure SetValue(value : TFhirString);
    Function GetValueST : String;
    Procedure SetValueST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirValueSetComposeIncludeConceptDesignation; overload;
    function Clone : TFhirValueSetComposeIncludeConceptDesignation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The language this designation is defined for.
    property language : String read GetLanguageST write SetLanguageST;
    // The language this designation is defined for.
    property languageElement : TFhirCode read FLanguage write SetLanguage;

    // Typed access to A code that details how this designation would be used. (defined for API consistency)
    property use : TFhirCoding read FUse write SetUse;
    // A code that details how this designation would be used.
    property useElement : TFhirCoding read FUse write SetUse;

    // Typed access to The text value for this designation.
    property value : String read GetValueST write SetValueST;
    // The text value for this designation.
    property valueElement : TFhirString read FValue write SetValue;

  end;

  TFhirValueSetComposeIncludeConceptDesignationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirValueSetComposeIncludeConceptDesignationList;
    function GetCurrent : TFhirValueSetComposeIncludeConceptDesignation;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirValueSetComposeIncludeConceptDesignationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirValueSetComposeIncludeConceptDesignation read GetCurrent;
  end;

  TFhirValueSetComposeIncludeConceptDesignationList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirValueSetComposeIncludeConceptDesignation;
    procedure SetItemN(index : Integer; value : TFhirValueSetComposeIncludeConceptDesignation);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirValueSetComposeIncludeConceptDesignationList; Overload;
    function Clone : TFhirValueSetComposeIncludeConceptDesignationList; Overload;
    function GetEnumerator : TFhirValueSetComposeIncludeConceptDesignationListEnumerator;

    //  Add a FhirValueSetComposeIncludeConceptDesignation to the end of the list.
    function Append : TFhirValueSetComposeIncludeConceptDesignation;

    // Add an already existing FhirValueSetComposeIncludeConceptDesignation to the end of the list.
    procedure AddItem(value : TFhirValueSetComposeIncludeConceptDesignation); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirValueSetComposeIncludeConceptDesignation) : Integer;

    // Insert FhirValueSetComposeIncludeConceptDesignation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirValueSetComposeIncludeConceptDesignation;

    // Insert an existing FhirValueSetComposeIncludeConceptDesignation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirValueSetComposeIncludeConceptDesignation);

    // Get the iIndexth FhirValueSetComposeIncludeConceptDesignation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetComposeIncludeConceptDesignation);

    // The number of items in the collection
    function Item(index : Integer) : TFhirValueSetComposeIncludeConceptDesignation;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirValueSetComposeIncludeConceptDesignations[index : Integer] : TFhirValueSetComposeIncludeConceptDesignation read GetItemN write SetItemN; default;
  End;

  // Select concepts by specify a matching criteria based on the properties (including relationships) defined by the system. If multiple filters are specified, they SHALL all be true.
  TFhirValueSetComposeIncludeFilter = class (TFhirBackboneElement)
  protected
    FProperty_ : TFhirCode;
    FOp : TFhirEnum;
    FValue : TFhirCode;
    Procedure SetProperty_(value : TFhirCode);
    Function GetProperty_ST : String;
    Procedure SetProperty_ST(value : String);
    Procedure SetOp(value : TFhirEnum);
    Function GetOpST : TFhirFilterOperatorEnum;
    Procedure SetOpST(value : TFhirFilterOperatorEnum);
    Procedure SetValue(value : TFhirCode);
    Function GetValueST : String;
    Procedure SetValueST(value : String);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirValueSetComposeIncludeFilter; overload;
    function Clone : TFhirValueSetComposeIncludeFilter; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to A code that identifies a property defined in the code system.
    property property_ : String read GetProperty_ST write SetProperty_ST;
    // A code that identifies a property defined in the code system.
    property property_Element : TFhirCode read FProperty_ write SetProperty_;

    // The kind of operation to perform as a part of the filter criteria.
    property op : TFhirFilterOperatorEnum read GetOpST write SetOpST;
    property opElement : TFhirEnum read FOp write SetOp;

    // Typed access to The match value may be either a code defined by the system, or a string value, which is a regex match on the literal string of the property value when the operation is 'regex', or one of the values (true and false), when the operation is 'exists'.
    property value : String read GetValueST write SetValueST;
    // The match value may be either a code defined by the system, or a string value, which is a regex match on the literal string of the property value when the operation is 'regex', or one of the values (true and false), when the operation is 'exists'.
    property valueElement : TFhirCode read FValue write SetValue;

  end;

  TFhirValueSetComposeIncludeFilterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirValueSetComposeIncludeFilterList;
    function GetCurrent : TFhirValueSetComposeIncludeFilter;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirValueSetComposeIncludeFilterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirValueSetComposeIncludeFilter read GetCurrent;
  end;

  TFhirValueSetComposeIncludeFilterList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirValueSetComposeIncludeFilter;
    procedure SetItemN(index : Integer; value : TFhirValueSetComposeIncludeFilter);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirValueSetComposeIncludeFilterList; Overload;
    function Clone : TFhirValueSetComposeIncludeFilterList; Overload;
    function GetEnumerator : TFhirValueSetComposeIncludeFilterListEnumerator;

    //  Add a FhirValueSetComposeIncludeFilter to the end of the list.
    function Append : TFhirValueSetComposeIncludeFilter;

    // Add an already existing FhirValueSetComposeIncludeFilter to the end of the list.
    procedure AddItem(value : TFhirValueSetComposeIncludeFilter); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirValueSetComposeIncludeFilter) : Integer;

    // Insert FhirValueSetComposeIncludeFilter before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirValueSetComposeIncludeFilter;

    // Insert an existing FhirValueSetComposeIncludeFilter before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirValueSetComposeIncludeFilter);

    // Get the iIndexth FhirValueSetComposeIncludeFilter. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetComposeIncludeFilter);

    // The number of items in the collection
    function Item(index : Integer) : TFhirValueSetComposeIncludeFilter;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirValueSetComposeIncludeFilters[index : Integer] : TFhirValueSetComposeIncludeFilter read GetItemN write SetItemN; default;
  End;

  // A value set can also be "expanded", where the value set is turned into a simple collection of enumerated codes. This element holds the expansion, if it has been performed.
  TFhirValueSetExpansion = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirUri;
    FTimestamp : TFhirDateTime;
    FTotal : TFhirInteger;
    FOffset : TFhirInteger;
    FparameterList : TFhirValueSetExpansionParameterList;
    FcontainsList : TFhirValueSetExpansionContainsList;
    Procedure SetIdentifier(value : TFhirUri);
    Function GetIdentifierST : String;
    Procedure SetIdentifierST(value : String);
    Procedure SetTimestamp(value : TFhirDateTime);
    Function GetTimestampST : TFslDateTime;
    Procedure SetTimestampST(value : TFslDateTime);
    Procedure SetTotal(value : TFhirInteger);
    Function GetTotalST : String;
    Procedure SetTotalST(value : String);
    Procedure SetOffset(value : TFhirInteger);
    Function GetOffsetST : String;
    Procedure SetOffsetST(value : String);
    function GetParameterList : TFhirValueSetExpansionParameterList;
    function GetHasParameterList : Boolean;
    function GetContainsList : TFhirValueSetExpansionContainsList;
    function GetHasContainsList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirValueSetExpansion; overload;
    function Clone : TFhirValueSetExpansion; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An identifier that uniquely identifies this expansion of the valueset. Systems may re-use the same identifier as long as the expansion and the definition remain the same, but are not required to do so.
    property identifier : String read GetIdentifierST write SetIdentifierST;
    // An identifier that uniquely identifies this expansion of the valueset. Systems may re-use the same identifier as long as the expansion and the definition remain the same, but are not required to do so.
    property identifierElement : TFhirUri read FIdentifier write SetIdentifier;

    // Typed access to The time at which the expansion was produced by the expanding system.
    property timestamp : TFslDateTime read GetTimestampST write SetTimestampST;
    // The time at which the expansion was produced by the expanding system.
    property timestampElement : TFhirDateTime read FTimestamp write SetTimestamp;

    // Typed access to The total number of concepts in the expansion. If the number of concept nodes in this resource is less than the stated number, then the server can return more using the offset parameter.
    property total : String read GetTotalST write SetTotalST;
    // The total number of concepts in the expansion. If the number of concept nodes in this resource is less than the stated number, then the server can return more using the offset parameter.
    property totalElement : TFhirInteger read FTotal write SetTotal;

    // Typed access to If paging is being used, the offset at which this resource starts.  I.e. this resource is a partial view into the expansion. If paging is not being used, this element SHALL not be present.
    property offset : String read GetOffsetST write SetOffsetST;
    // If paging is being used, the offset at which this resource starts.  I.e. this resource is a partial view into the expansion. If paging is not being used, this element SHALL not be present.
    property offsetElement : TFhirInteger read FOffset write SetOffset;

    // A parameter that controlled the expansion process. These parameters may be used by users of expanded value sets to check whether the expansion is suitable for a particular purpose, or to pick the correct expansion.
    property parameterList : TFhirValueSetExpansionParameterList read GetParameterList;
    property hasParameterList : boolean read GetHasParameterList;

    // The codes that are contained in the value set expansion.
    property containsList : TFhirValueSetExpansionContainsList read GetContainsList;
    property hasContainsList : boolean read GetHasContainsList;

  end;

  TFhirValueSetExpansionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirValueSetExpansionList;
    function GetCurrent : TFhirValueSetExpansion;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirValueSetExpansionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirValueSetExpansion read GetCurrent;
  end;

  TFhirValueSetExpansionList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirValueSetExpansion;
    procedure SetItemN(index : Integer; value : TFhirValueSetExpansion);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirValueSetExpansionList; Overload;
    function Clone : TFhirValueSetExpansionList; Overload;
    function GetEnumerator : TFhirValueSetExpansionListEnumerator;

    //  Add a FhirValueSetExpansion to the end of the list.
    function Append : TFhirValueSetExpansion;

    // Add an already existing FhirValueSetExpansion to the end of the list.
    procedure AddItem(value : TFhirValueSetExpansion); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirValueSetExpansion) : Integer;

    // Insert FhirValueSetExpansion before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirValueSetExpansion;

    // Insert an existing FhirValueSetExpansion before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirValueSetExpansion);

    // Get the iIndexth FhirValueSetExpansion. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetExpansion);

    // The number of items in the collection
    function Item(index : Integer) : TFhirValueSetExpansion;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirValueSetExpansions[index : Integer] : TFhirValueSetExpansion read GetItemN write SetItemN; default;
  End;

  // A parameter that controlled the expansion process. These parameters may be used by users of expanded value sets to check whether the expansion is suitable for a particular purpose, or to pick the correct expansion.
  TFhirValueSetExpansionParameter = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FValue : TFhirType;
    Procedure SetName(value : TFhirString);
    Function GetNameST : String;
    Procedure SetNameST(value : String);
    Procedure SetValue(value : TFhirType);

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirValueSetExpansionParameter; overload;
    function Clone : TFhirValueSetExpansionParameter; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to The name of the parameter.
    property name : String read GetNameST write SetNameST;
    // The name of the parameter.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to The value of the parameter. (defined for API consistency)
    property value : TFhirType read FValue write SetValue;
    // The value of the parameter.
    property valueElement : TFhirType read FValue write SetValue;

  end;

  TFhirValueSetExpansionParameterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirValueSetExpansionParameterList;
    function GetCurrent : TFhirValueSetExpansionParameter;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirValueSetExpansionParameterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirValueSetExpansionParameter read GetCurrent;
  end;

  TFhirValueSetExpansionParameterList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirValueSetExpansionParameter;
    procedure SetItemN(index : Integer; value : TFhirValueSetExpansionParameter);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirValueSetExpansionParameterList; Overload;
    function Clone : TFhirValueSetExpansionParameterList; Overload;
    function GetEnumerator : TFhirValueSetExpansionParameterListEnumerator;

    //  Add a FhirValueSetExpansionParameter to the end of the list.
    function Append : TFhirValueSetExpansionParameter;

    // Add an already existing FhirValueSetExpansionParameter to the end of the list.
    procedure AddItem(value : TFhirValueSetExpansionParameter); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirValueSetExpansionParameter) : Integer;

    // Insert FhirValueSetExpansionParameter before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirValueSetExpansionParameter;

    // Insert an existing FhirValueSetExpansionParameter before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirValueSetExpansionParameter);

    // Get the iIndexth FhirValueSetExpansionParameter. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetExpansionParameter);

    // The number of items in the collection
    function Item(index : Integer) : TFhirValueSetExpansionParameter;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirValueSetExpansionParameters[index : Integer] : TFhirValueSetExpansionParameter read GetItemN write SetItemN; default;
  End;

  // The codes that are contained in the value set expansion.
  TFhirValueSetExpansionContains = class (TFhirBackboneElement)
  protected
    FSystem : TFhirUri;
    FAbstract : TFhirBoolean;
    FInactive : TFhirBoolean;
    FVersion : TFhirString;
    FCode : TFhirCode;
    FDisplay : TFhirString;
    FdesignationList : TFhirValueSetComposeIncludeConceptDesignationList;
    FcontainsList : TFhirValueSetExpansionContainsList;
    Procedure SetSystem(value : TFhirUri);
    Function GetSystemST : String;
    Procedure SetSystemST(value : String);
    Procedure SetAbstract(value : TFhirBoolean);
    Function GetAbstractST : Boolean;
    Procedure SetAbstractST(value : Boolean);
    Procedure SetInactive(value : TFhirBoolean);
    Function GetInactiveST : Boolean;
    Procedure SetInactiveST(value : Boolean);
    Procedure SetVersion(value : TFhirString);
    Function GetVersionST : String;
    Procedure SetVersionST(value : String);
    Procedure SetCode(value : TFhirCode);
    Function GetCodeST : String;
    Procedure SetCodeST(value : String);
    Procedure SetDisplay(value : TFhirString);
    Function GetDisplayST : String;
    Procedure SetDisplayST(value : String);
    function GetDesignationList : TFhirValueSetComposeIncludeConceptDesignationList;
    function GetHasDesignationList : Boolean;
    function GetContainsList : TFhirValueSetExpansionContainsList;
    function GetHasContainsList : Boolean;

    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirValueSetExpansionContains; overload;
    function Clone : TFhirValueSetExpansionContains; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An absolute URI which is the code system in which the code for this item in the expansion is defined.
    property system : String read GetSystemST write SetSystemST;
    // An absolute URI which is the code system in which the code for this item in the expansion is defined.
    property systemElement : TFhirUri read FSystem write SetSystem;

    // Typed access to If true, this entry is included in the expansion for navigational purposes, and the user cannot select the code directly as a proper value.
    property abstract : Boolean read GetAbstractST write SetAbstractST;
    // If true, this entry is included in the expansion for navigational purposes, and the user cannot select the code directly as a proper value.
    property abstractElement : TFhirBoolean read FAbstract write SetAbstract;

    // Typed access to If the concept is inactive in the code system that defines it. Inactive codes are those that are no longer to be used, but are maintained by the code system for understanding legacy data.
    property inactive : Boolean read GetInactiveST write SetInactiveST;
    // If the concept is inactive in the code system that defines it. Inactive codes are those that are no longer to be used, but are maintained by the code system for understanding legacy data.
    property inactiveElement : TFhirBoolean read FInactive write SetInactive;

    // Typed access to The version of this code system that defined this code and/or display. This should only be used with code systems that do not enforce concept permanence.
    property version : String read GetVersionST write SetVersionST;
    // The version of this code system that defined this code and/or display. This should only be used with code systems that do not enforce concept permanence.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to The code for this item in the expansion hierarchy. If this code is missing the entry in the hierarchy is a place holder (abstract) and does not represent a valid code in the value set.
    property code : String read GetCodeST write SetCodeST;
    // The code for this item in the expansion hierarchy. If this code is missing the entry in the hierarchy is a place holder (abstract) and does not represent a valid code in the value set.
    property codeElement : TFhirCode read FCode write SetCode;

    // Typed access to The recommended display for this item in the expansion.
    property display : String read GetDisplayST write SetDisplayST;
    // The recommended display for this item in the expansion.
    property displayElement : TFhirString read FDisplay write SetDisplay;

    // Additional representations for this item - other languages, aliases, specialized purposes, used for particular purposes, etc. These are relevant when the conditions of the expansion do not fix to a single correct representation.
    property designationList : TFhirValueSetComposeIncludeConceptDesignationList read GetDesignationList;
    property hasDesignationList : boolean read GetHasDesignationList;

    // Other codes and entries contained under this entry in the hierarchy.
    property containsList : TFhirValueSetExpansionContainsList read GetContainsList;
    property hasContainsList : boolean read GetHasContainsList;

  end;

  TFhirValueSetExpansionContainsListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirValueSetExpansionContainsList;
    function GetCurrent : TFhirValueSetExpansionContains;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirValueSetExpansionContainsList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirValueSetExpansionContains read GetCurrent;
  end;

  TFhirValueSetExpansionContainsList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirValueSetExpansionContains;
    procedure SetItemN(index : Integer; value : TFhirValueSetExpansionContains);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirValueSetExpansionContainsList; Overload;
    function Clone : TFhirValueSetExpansionContainsList; Overload;
    function GetEnumerator : TFhirValueSetExpansionContainsListEnumerator;

    //  Add a FhirValueSetExpansionContains to the end of the list.
    function Append : TFhirValueSetExpansionContains;

    // Add an already existing FhirValueSetExpansionContains to the end of the list.
    procedure AddItem(value : TFhirValueSetExpansionContains); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirValueSetExpansionContains) : Integer;

    // Insert FhirValueSetExpansionContains before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirValueSetExpansionContains;

    // Insert an existing FhirValueSetExpansionContains before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirValueSetExpansionContains);

    // Get the iIndexth FhirValueSetExpansionContains. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirValueSetExpansionContains);

    // The number of items in the collection
    function Item(index : Integer) : TFhirValueSetExpansionContains;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirValueSetExpansionContains[index : Integer] : TFhirValueSetExpansionContains read GetItemN write SetItemN; default;
  End;

  // A value set specifies a set of codes drawn from one or more code systems.
  TFhirValueSet = class (TFhirMetadataResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FImmutable : TFhirBoolean;
    FPurpose : TFhirMarkdown;
    FCopyright : TFhirMarkdown;
    FExtensible : TFhirBoolean;
    FCompose : TFhirValueSetCompose;
    FExpansion : TFhirValueSetExpansion;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    Procedure SetImmutable(value : TFhirBoolean);
    Function GetImmutableST : Boolean;
    Procedure SetImmutableST(value : Boolean);
    Procedure SetPurpose(value : TFhirMarkdown);
    Function GetPurposeST : String;
    Procedure SetPurposeST(value : String);
    Procedure SetCopyright(value : TFhirMarkdown);
    Function GetCopyrightST : String;
    Procedure SetCopyrightST(value : String);
    Procedure SetExtensible(value : TFhirBoolean);
    Function GetExtensibleST : Boolean;
    Procedure SetExtensibleST(value : Boolean);
    Procedure SetCompose(value : TFhirValueSetCompose);
    Procedure SetExpansion(value : TFhirValueSetExpansion);

    function GetResourceType : TFhirResourceType; override;
    Procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    Procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); Override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV : cardinal; override;
  public
    constructor Create; Override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirValueSet; overload;
    function Clone : TFhirValueSet; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string): TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}Published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this value set when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this value set is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the value set. For more information see [Technical and Business Versions](resource.html#versions).
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this value set when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this value set is (or will be) {$IFNDEF FPC}Published{$ENDIF}. The URL SHOULD include the major version of the value set. For more information see [Technical and Business Versions](resource.html#versions).
    property urlElement : TFhirUri read FUrl write SetUrl;

    // A formal identifier that is used to identify this value set when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the value set when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the value set author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the value set when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the value set author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the value set. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the value set. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the value set.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the value set.
    property titleElement : TFhirString read FTitle write SetTitle;

    // The status of this value set. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A boolean value to indicate that this value set is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A boolean value to indicate that this value set is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The date  (and optionally time) when the value set was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the value set changes. (e.g. the 'content logical definition').
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the value set was {$IFNDEF FPC}Published{$ENDIF}. The date must change if and when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the value set changes. (e.g. the 'content logical definition').
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the value set.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the individual or organization that {$IFNDEF FPC}Published{$ENDIF} the value set.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the value set from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the value set from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These terms may be used to assist with indexing and searching for appropriate value set instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the value set is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to If this is set to 'true', then no new versions of the content logical definition can be created.  Note: Other metadata might still change.
    property immutable : Boolean read GetImmutableST write SetImmutableST;
    // If this is set to 'true', then no new versions of the content logical definition can be created.  Note: Other metadata might still change.
    property immutableElement : TFhirBoolean read FImmutable write SetImmutable;

    // Typed access to Explaination of why this value set is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explaination of why this value set is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Typed access to A copyright statement relating to the value set and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the value set.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the value set and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the value set.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // Typed access to Whether this is intended to be used with an extensible binding or not.
    property extensible : Boolean read GetExtensibleST write SetExtensibleST;
    // Whether this is intended to be used with an extensible binding or not.
    property extensibleElement : TFhirBoolean read FExtensible write SetExtensible;

    // Typed access to A set of criteria that define the content logical definition of the value set by including or excluding codes from outside this value set. This I also known as the "Content Logical Definition" (CLD). (defined for API consistency)
    property compose : TFhirValueSetCompose read FCompose write SetCompose;
    // A set of criteria that define the content logical definition of the value set by including or excluding codes from outside this value set. This I also known as the "Content Logical Definition" (CLD).
    property composeElement : TFhirValueSetCompose read FCompose write SetCompose;

    // Typed access to A value set can also be "expanded", where the value set is turned into a simple collection of enumerated codes. This element holds the expansion, if it has been performed. (defined for API consistency)
    property expansion : TFhirValueSetExpansion read FExpansion write SetExpansion;
    // A value set can also be "expanded", where the value set is turned into a simple collection of enumerated codes. This element holds the expansion, if it has been performed.
    property expansionElement : TFhirValueSetExpansion read FExpansion write SetExpansion;

  end;

  TFhirValueSetListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirValueSetList;
    function GetCurrent : TFhirValueSet;
  protected
    function sizeInBytesV : cardinal; override;
  public
    constructor Create(list : TFhirValueSetList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirValueSet read GetCurrent;
  end;

  TFhirValueSetList = class (TFHIRObjectList)
  private

    function GetItemN(index : Integer) : TFhirValueSet;
    procedure SetItemN(index : Integer; value : TFhirValueSet);
  protected
    function ItemClass : TFslObjectClass; override;
  public

    function Link : TFhirValueSetList; Overload;
    function Clone : TFhirValueSetList; Overload;
    function GetEnumerator : TFhirValueSetListEnumerator;

    //  Add a FhirValueSet to the end of the list.
    function Append : TFhirValueSet;

    // Add an already existing FhirValueSet to the end of the list.
    procedure AddItem(value : TFhirValueSet); overload;

    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirValueSet) : Integer;

    // Insert FhirValueSet before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirValueSet;

    // Insert an existing FhirValueSet before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirValueSet);

    // Get the iIndexth FhirValueSet. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirValueSet);

    // The number of items in the collection
    function Item(index : Integer) : TFhirValueSet;

    // The number of items in the collection
    function Count : Integer; Overload;

    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);

    // Remove All Items from the list
    procedure ClearItems;

    Property FhirValueSets[index : Integer] : TFhirValueSet read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_VALUESET}

implementation

uses
  fhir3_utilities;

{ TFhirMetadataResource }

constructor TFhirMetadataResource.Create;
begin
  inherited;
end;

destructor TFhirMetadataResource.Destroy;
begin
  FUrl.free;
  FVersion.free;
  FName.free;
  FTitle.free;
  FStatus.free;
  FExperimental.free;
  FDate.free;
  FPublisher.free;
  FContactList.Free;
  FUseContextList.Free;
  FJurisdictionList.Free;
  FDescription.free;
  inherited;
end;

procedure TFhirMetadataResource.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirMetadataResource(oSource).urlElement.Clone;
  versionElement := TFhirMetadataResource(oSource).versionElement.Clone;
  nameElement := TFhirMetadataResource(oSource).nameElement.Clone;
  titleElement := TFhirMetadataResource(oSource).titleElement.Clone;
  FStatus := TFhirMetadataResource(oSource).FStatus.Link;
  experimentalElement := TFhirMetadataResource(oSource).experimentalElement.Clone;
  dateElement := TFhirMetadataResource(oSource).dateElement.Clone;
  publisherElement := TFhirMetadataResource(oSource).publisherElement.Clone;
  if (TFhirMetadataResource(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactDetailList.Create;
    FContactList.Assign(TFhirMetadataResource(oSource).FContactList);
  end;
  if (TFhirMetadataResource(oSource).FUseContextList = nil) then
  begin
    FUseContextList.free;
    FUseContextList := nil;
  end
  else
  begin
    if FUseContextList = nil then
      FUseContextList := TFhirUsageContextList.Create;
    FUseContextList.Assign(TFhirMetadataResource(oSource).FUseContextList);
  end;
  if (TFhirMetadataResource(oSource).FJurisdictionList = nil) then
  begin
    FJurisdictionList.free;
    FJurisdictionList := nil;
  end
  else
  begin
    if FJurisdictionList = nil then
      FJurisdictionList := TFhirCodeableConceptList.Create;
    FJurisdictionList.Assign(TFhirMetadataResource(oSource).FJurisdictionList);
  end;
  descriptionElement := TFhirMetadataResource(oSource).descriptionElement.Clone;
end;

procedure TFhirMetadataResource.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'experimental') Then
     list.add(self.link, 'experimental', FExperimental.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'useContext') Then
    list.addAll(self, 'useContext', FUseContextList);
  if (child_name = 'jurisdiction') Then
    list.addAll(self, 'jurisdiction', FJurisdictionList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
end;

procedure TFhirMetadataResource.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));{2}
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'experimental', 'boolean', false, TFhirBoolean, FExperimental.Link));{2}
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'publisher', 'string', false, TFhirString, FPublisher.Link));{2}
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactDetail', true, TFhirContactDetail, FContactList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'useContext', 'UsageContext', true, TFhirUsageContext, FUseContextList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'CodeableConcept', true, TFhirCodeableConcept, FJurisdictionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));{2}
end;

function TFhirMetadataResource.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'experimental') then
  begin
    ExperimentalElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    PublisherElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactDetail){2a};
    result := propValue;
  end
  else if (propName = 'useContext') then
  begin
    UseContextList.add(propValue as TFhirUsageContext){2a};
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    JurisdictionList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMetadataResource.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactDetail){2a}
  else if (propName = 'useContext') then UseContextList.insertItem(index, propValue as TFhirUsageContext){2a}
  else if (propName = 'jurisdiction') then JurisdictionList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirMetadataResource.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create() {5b}
  else if (propName = 'version') then result := TFhirString.create() {5b}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'title') then result := TFhirString.create() {5b}
  else if (propName = 'experimental') then result := TFhirBoolean.create() {5b}
  else if (propName = 'date') then result := TFhirDateTime.create() {5b}
  else if (propName = 'publisher') then result := TFhirString.create() {5b}
  else if (propName = 'contact') then result := ContactList.new(){2}
  else if (propName = 'useContext') then result := UseContextList.new(){2}
  else if (propName = 'jurisdiction') then result := JurisdictionList.new(){2}
  else if (propName = 'description') then result := TFhirMarkdown.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMetadataResource.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'experimental') then result := 'boolean'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'publisher') then result := 'string'
  else if (propName = 'contact') then result := 'ContactDetail'
  else if (propName = 'useContext') then result := 'UsageContext'
  else if (propName = 'jurisdiction') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'markdown'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMetadataResource.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'experimental') then ExperimentalElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value) {2}
  else if (propName = 'useContext') then deletePropertyValue('useContext', UseContextList, value) {2}
  else if (propName = 'jurisdiction') then deletePropertyValue('jurisdiction', JurisdictionList, value) {2}
  else if (propName = 'description') then DescriptionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMetadataResource.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new){5b}
  else if (propName = 'version') then VersionElement := asString(new){5b}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'title') then TitleElement := asString(new){5b}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, new){4}
  else if (propName = 'experimental') then ExperimentalElement := asBoolean(new){5b}
  else if (propName = 'date') then DateElement := asDateTime(new){5b}
  else if (propName = 'publisher') then PublisherElement := asString(new){5b}
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new) {2}
  else if (propName = 'useContext') then replacePropertyValue('useContext', UseContextList, existing, new) {2}
  else if (propName = 'jurisdiction') then replacePropertyValue('jurisdiction', JurisdictionList, existing, new) {2}
  else if (propName = 'description') then DescriptionElement := asMarkdown(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMetadataResource.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'contact') then ContactList.move(source, destination){2a}
  else if (propName = 'useContext') then UseContextList.move(source, destination){2a}
  else if (propName = 'jurisdiction') then JurisdictionList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMetadataResource.fhirType : string;
begin
  result := 'MetadataResource';
end;

function TFhirMetadataResource.equals(other : TObject) : boolean;
var
  o : TFhirMetadataResource;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMetadataResource)) then
    result := false
  else
  begin
    o := TFhirMetadataResource(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(versionElement, o.versionElement, true) and
      compareDeep(nameElement, o.nameElement, true) and compareDeep(titleElement, o.titleElement, true) and
      compareDeep(statusElement, o.statusElement, true) and compareDeep(experimentalElement, o.experimentalElement, true) and
      compareDeep(dateElement, o.dateElement, true) and compareDeep(publisherElement, o.publisherElement, true) and
      compareDeep(contactList, o.contactList, true) and compareDeep(useContextList, o.useContextList, true) and
      compareDeep(jurisdictionList, o.jurisdictionList, true) and compareDeep(descriptionElement, o.descriptionElement, true);
  end;
end;

function TFhirMetadataResource.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FVersion) and isEmptyProp(FName) and isEmptyProp(FTitle) and isEmptyProp(FStatus) and isEmptyProp(FExperimental) and isEmptyProp(FDate) and isEmptyProp(FPublisher) and isEmptyProp(FcontactList) and isEmptyProp(FuseContextList) and isEmptyProp(FjurisdictionList) and isEmptyProp(FDescription);
end;

function TFhirMetadataResource.Link : TFhirMetadataResource;
begin
  result := TFhirMetadataResource(inherited Link);
end;

function TFhirMetadataResource.Clone : TFhirMetadataResource;
begin
  result := TFhirMetadataResource(inherited Clone);
end;

{ TFhirMetadataResource }

Procedure TFhirMetadataResource.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirMetadataResource.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

Procedure TFhirMetadataResource.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

Procedure TFhirMetadataResource.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

Function TFhirMetadataResource.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

Procedure TFhirMetadataResource.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

Procedure TFhirMetadataResource.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirMetadataResource.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirMetadataResource.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirMetadataResource.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

Function TFhirMetadataResource.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

Procedure TFhirMetadataResource.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

Procedure TFhirMetadataResource.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirMetadataResource.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

Procedure TFhirMetadataResource.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

Procedure TFhirMetadataResource.SetExperimental(value : TFhirBoolean);
begin
  FExperimental.free;
  FExperimental := value;
end;

Function TFhirMetadataResource.GetExperimentalST : Boolean;
begin
  if FExperimental = nil then
    result := false
  else
    result := FExperimental.value;
end;

Procedure TFhirMetadataResource.SetExperimentalST(value : Boolean);
begin
  if FExperimental = nil then
    FExperimental := TFhirBoolean.create;
  FExperimental.value := value
end;

Procedure TFhirMetadataResource.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

Function TFhirMetadataResource.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

Procedure TFhirMetadataResource.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

Procedure TFhirMetadataResource.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

Function TFhirMetadataResource.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

Procedure TFhirMetadataResource.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

Function TFhirMetadataResource.GetContactList : TFhirContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirContactDetailList.Create;
  result := FContactList;
end;

Function TFhirMetadataResource.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

Function TFhirMetadataResource.GetUseContextList : TFhirUsageContextList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirUsageContextList.Create;
  result := FUseContextList;
end;

Function TFhirMetadataResource.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

Function TFhirMetadataResource.GetJurisdictionList : TFhirCodeableConceptList;
begin
  if FJurisdictionList = nil then
    FJurisdictionList := TFhirCodeableConceptList.Create;
  result := FJurisdictionList;
end;

Function TFhirMetadataResource.GetHasJurisdictionList : boolean;
begin
  result := (FJurisdictionList <> nil) and (FJurisdictionList.count > 0);
end;

Procedure TFhirMetadataResource.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirMetadataResource.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirMetadataResource.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

{ TFhirMetadataResourceListEnumerator }

Constructor TFhirMetadataResourceListEnumerator.Create(list : TFhirMetadataResourceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMetadataResourceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMetadataResourceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMetadataResourceListEnumerator.GetCurrent : TFhirMetadataResource;
begin
  Result := FList[FIndex];
end;

function TFhirMetadataResourceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMetadataResourceList }
procedure TFhirMetadataResourceList.AddItem(value: TFhirMetadataResource);
begin
  assert(value.ClassName = 'TFhirMetadataResource', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMetadataResource');
  add(value);
end;

procedure TFhirMetadataResourceList.ClearItems;
begin
  Clear;
end;

function TFhirMetadataResourceList.GetEnumerator : TFhirMetadataResourceListEnumerator;
begin
  result := TFhirMetadataResourceListEnumerator.Create(self.link);
end;

function TFhirMetadataResourceList.Clone: TFhirMetadataResourceList;
begin
  result := TFhirMetadataResourceList(inherited Clone);
end;

function TFhirMetadataResourceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMetadataResourceList.GetItemN(index: Integer): TFhirMetadataResource;
begin
  result := TFhirMetadataResource(ObjectByIndex[index]);
end;

function TFhirMetadataResourceList.ItemClass: TFslObjectClass;
begin
  result := TFhirMetadataResource;
end;
function TFhirMetadataResourceList.IndexOf(value: TFhirMetadataResource): Integer;
begin
  result := IndexByReference(value);
end;

procedure TFhirMetadataResourceList.InsertItem(index: Integer; value: TFhirMetadataResource);
begin
  assert(value is TFhirMetadataResource);
  Inherited Insert(index, value);
end;

function TFhirMetadataResourceList.Item(index: Integer): TFhirMetadataResource;
begin
  result := TFhirMetadataResource(ObjectByIndex[index]);
end;

function TFhirMetadataResourceList.Link: TFhirMetadataResourceList;
begin
  result := TFhirMetadataResourceList(inherited Link);
end;

procedure TFhirMetadataResourceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMetadataResourceList.SetItemByIndex(index: Integer; value: TFhirMetadataResource);
begin
  assert(value is TFhirMetadataResource);
  FhirMetadataResources[index] := value;
end;

procedure TFhirMetadataResourceList.SetItemN(index: Integer; value: TFhirMetadataResource);
begin
  assert(value is TFhirMetadataResource);
  ObjectByIndex[index] := value;
end;

{$IFDEF FHIR_ACTIVITYDEFINITION}

{ TFhirActivityDefinitionParticipant }

constructor TFhirActivityDefinitionParticipant.Create;
begin
  inherited;
end;

destructor TFhirActivityDefinitionParticipant.Destroy;
begin
  FType_.free;
  FRole.free;
  inherited;
end;

procedure TFhirActivityDefinitionParticipant.Assign(oSource : TFslObject);
begin
  inherited;
  FType_ := TFhirActivityDefinitionParticipant(oSource).FType_.Link;
  role := TFhirActivityDefinitionParticipant(oSource).role.Clone;
end;

procedure TFhirActivityDefinitionParticipant.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
end;

procedure TFhirActivityDefinitionParticipant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));{2}
end;

function TFhirActivityDefinitionParticipant.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirActionParticipantTypeEnum, CODES_TFhirActionParticipantTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirActivityDefinitionParticipant.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirActivityDefinitionParticipant.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'role') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirActivityDefinitionParticipant.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'role') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirActivityDefinitionParticipant.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'role') then RoleElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirActivityDefinitionParticipant.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirActionParticipantTypeEnum, CODES_TFhirActionParticipantTypeEnum, new){4}
  else if (propName = 'role') then RoleElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirActivityDefinitionParticipant.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirActivityDefinitionParticipant.fhirType : string;
begin
  result := 'participant';
end;

function TFhirActivityDefinitionParticipant.Link : TFhirActivityDefinitionParticipant;
begin
  result := TFhirActivityDefinitionParticipant(inherited Link);
end;

function TFhirActivityDefinitionParticipant.Clone : TFhirActivityDefinitionParticipant;
begin
  result := TFhirActivityDefinitionParticipant(inherited Clone);
end;

function TFhirActivityDefinitionParticipant.equals(other : TObject) : boolean;
var
  o : TFhirActivityDefinitionParticipant;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirActivityDefinitionParticipant)) then
    result := false
  else
  begin
    o := TFhirActivityDefinitionParticipant(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(roleElement, o.roleElement, true);
  end;
end;

function TFhirActivityDefinitionParticipant.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FRole);
end;

procedure TFhirActivityDefinitionParticipant.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('role');
end;

{ TFhirActivityDefinitionParticipant }

Procedure TFhirActivityDefinitionParticipant.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirActivityDefinitionParticipant.GetType_ST : TFhirActionParticipantTypeEnum;
begin
  if FType_ = nil then
    result := TFhirActionParticipantTypeEnum(0)
  else
    result := TFhirActionParticipantTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirActionParticipantTypeEnum, FType_.value));
end;

Procedure TFhirActivityDefinitionParticipant.SetType_ST(value : TFhirActionParticipantTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirActionParticipantTypeEnum[value], CODES_TFhirActionParticipantTypeEnum[value]);
end;

Procedure TFhirActivityDefinitionParticipant.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

function TFhirActivityDefinitionParticipant.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FRole.sizeInBytes);
end;

{ TFhirActivityDefinitionParticipantListEnumerator }

Constructor TFhirActivityDefinitionParticipantListEnumerator.Create(list : TFhirActivityDefinitionParticipantList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirActivityDefinitionParticipantListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirActivityDefinitionParticipantListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirActivityDefinitionParticipantListEnumerator.GetCurrent : TFhirActivityDefinitionParticipant;
begin
  Result := FList[FIndex];
end;

function TFhirActivityDefinitionParticipantListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirActivityDefinitionParticipantList }
procedure TFhirActivityDefinitionParticipantList.AddItem(value: TFhirActivityDefinitionParticipant);
begin
  assert(value.ClassName = 'TFhirActivityDefinitionParticipant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirActivityDefinitionParticipant');
  add(value);
end;

function TFhirActivityDefinitionParticipantList.Append: TFhirActivityDefinitionParticipant;
begin
  result := TFhirActivityDefinitionParticipant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirActivityDefinitionParticipantList.ClearItems;
begin
  Clear;
end;

function TFhirActivityDefinitionParticipantList.GetEnumerator : TFhirActivityDefinitionParticipantListEnumerator;
begin
  result := TFhirActivityDefinitionParticipantListEnumerator.Create(self.link);
end;

function TFhirActivityDefinitionParticipantList.Clone: TFhirActivityDefinitionParticipantList;
begin
  result := TFhirActivityDefinitionParticipantList(inherited Clone);
end;

function TFhirActivityDefinitionParticipantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirActivityDefinitionParticipantList.GetItemN(index: Integer): TFhirActivityDefinitionParticipant;
begin
  result := TFhirActivityDefinitionParticipant(ObjectByIndex[index]);
end;

function TFhirActivityDefinitionParticipantList.ItemClass: TFslObjectClass;
begin
  result := TFhirActivityDefinitionParticipant;
end;
function TFhirActivityDefinitionParticipantList.IndexOf(value: TFhirActivityDefinitionParticipant): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirActivityDefinitionParticipantList.Insert(index: Integer): TFhirActivityDefinitionParticipant;
begin
  result := TFhirActivityDefinitionParticipant.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirActivityDefinitionParticipantList.InsertItem(index: Integer; value: TFhirActivityDefinitionParticipant);
begin
  assert(value is TFhirActivityDefinitionParticipant);
  Inherited Insert(index, value);
end;

function TFhirActivityDefinitionParticipantList.Item(index: Integer): TFhirActivityDefinitionParticipant;
begin
  result := TFhirActivityDefinitionParticipant(ObjectByIndex[index]);
end;

function TFhirActivityDefinitionParticipantList.Link: TFhirActivityDefinitionParticipantList;
begin
  result := TFhirActivityDefinitionParticipantList(inherited Link);
end;

procedure TFhirActivityDefinitionParticipantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirActivityDefinitionParticipantList.SetItemByIndex(index: Integer; value: TFhirActivityDefinitionParticipant);
begin
  assert(value is TFhirActivityDefinitionParticipant);
  FhirActivityDefinitionParticipants[index] := value;
end;

procedure TFhirActivityDefinitionParticipantList.SetItemN(index: Integer; value: TFhirActivityDefinitionParticipant);
begin
  assert(value is TFhirActivityDefinitionParticipant);
  ObjectByIndex[index] := value;
end;

{ TFhirActivityDefinitionDynamicValue }

constructor TFhirActivityDefinitionDynamicValue.Create;
begin
  inherited;
end;

destructor TFhirActivityDefinitionDynamicValue.Destroy;
begin
  FDescription.free;
  FPath.free;
  FLanguage.free;
  FExpression.free;
  inherited;
end;

procedure TFhirActivityDefinitionDynamicValue.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirActivityDefinitionDynamicValue(oSource).descriptionElement.Clone;
  pathElement := TFhirActivityDefinitionDynamicValue(oSource).pathElement.Clone;
  languageElement := TFhirActivityDefinitionDynamicValue(oSource).languageElement.Clone;
  expressionElement := TFhirActivityDefinitionDynamicValue(oSource).expressionElement.Clone;
end;

procedure TFhirActivityDefinitionDynamicValue.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'path') Then
     list.add(self.link, 'path', FPath.Link);
  if (child_name = 'language') Then
     list.add(self.link, 'language', FLanguage.Link);
  if (child_name = 'expression') Then
     list.add(self.link, 'expression', FExpression.Link);
end;

procedure TFhirActivityDefinitionDynamicValue.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'path', 'string', false, TFhirString, FPath.Link));{2}
  oList.add(TFHIRProperty.create(self, 'language', 'string', false, TFhirString, FLanguage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'expression', 'string', false, TFhirString, FExpression.Link));{2}
end;

function TFhirActivityDefinitionDynamicValue.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'path') then
  begin
    PathElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'language') then
  begin
    LanguageElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'expression') then
  begin
    ExpressionElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirActivityDefinitionDynamicValue.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirActivityDefinitionDynamicValue.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'path') then result := TFhirString.create() {5b}
  else if (propName = 'language') then result := TFhirString.create() {5b}
  else if (propName = 'expression') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirActivityDefinitionDynamicValue.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'path') then result := 'string'
  else if (propName = 'language') then result := 'string'
  else if (propName = 'expression') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirActivityDefinitionDynamicValue.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'path') then PathElement := nil
  else if (propName = 'language') then LanguageElement := nil
  else if (propName = 'expression') then ExpressionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirActivityDefinitionDynamicValue.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'path') then PathElement := asString(new){5b}
  else if (propName = 'language') then LanguageElement := asString(new){5b}
  else if (propName = 'expression') then ExpressionElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirActivityDefinitionDynamicValue.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirActivityDefinitionDynamicValue.fhirType : string;
begin
  result := 'dynamicValue';
end;

function TFhirActivityDefinitionDynamicValue.Link : TFhirActivityDefinitionDynamicValue;
begin
  result := TFhirActivityDefinitionDynamicValue(inherited Link);
end;

function TFhirActivityDefinitionDynamicValue.Clone : TFhirActivityDefinitionDynamicValue;
begin
  result := TFhirActivityDefinitionDynamicValue(inherited Clone);
end;

function TFhirActivityDefinitionDynamicValue.equals(other : TObject) : boolean;
var
  o : TFhirActivityDefinitionDynamicValue;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirActivityDefinitionDynamicValue)) then
    result := false
  else
  begin
    o := TFhirActivityDefinitionDynamicValue(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(pathElement, o.pathElement, true) and
      compareDeep(languageElement, o.languageElement, true) and compareDeep(expressionElement, o.expressionElement, true);
  end;
end;

function TFhirActivityDefinitionDynamicValue.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FPath) and isEmptyProp(FLanguage) and isEmptyProp(FExpression);
end;

procedure TFhirActivityDefinitionDynamicValue.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('description');
  fields.add('path');
  fields.add('language');
  fields.add('expression');
end;

{ TFhirActivityDefinitionDynamicValue }

Procedure TFhirActivityDefinitionDynamicValue.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirActivityDefinitionDynamicValue.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirActivityDefinitionDynamicValue.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirActivityDefinitionDynamicValue.SetPath(value : TFhirString);
begin
  FPath.free;
  FPath := value;
end;

Function TFhirActivityDefinitionDynamicValue.GetPathST : String;
begin
  if FPath = nil then
    result := ''
  else
    result := FPath.value;
end;

Procedure TFhirActivityDefinitionDynamicValue.SetPathST(value : String);
begin
  if value <> '' then
  begin
    if FPath = nil then
      FPath := TFhirString.create;
    FPath.value := value
  end
  else if FPath <> nil then
    FPath.value := '';
end;

Procedure TFhirActivityDefinitionDynamicValue.SetLanguage(value : TFhirString);
begin
  FLanguage.free;
  FLanguage := value;
end;

Function TFhirActivityDefinitionDynamicValue.GetLanguageST : String;
begin
  if FLanguage = nil then
    result := ''
  else
    result := FLanguage.value;
end;

Procedure TFhirActivityDefinitionDynamicValue.SetLanguageST(value : String);
begin
  if value <> '' then
  begin
    if FLanguage = nil then
      FLanguage := TFhirString.create;
    FLanguage.value := value
  end
  else if FLanguage <> nil then
    FLanguage.value := '';
end;

Procedure TFhirActivityDefinitionDynamicValue.SetExpression(value : TFhirString);
begin
  FExpression.free;
  FExpression := value;
end;

Function TFhirActivityDefinitionDynamicValue.GetExpressionST : String;
begin
  if FExpression = nil then
    result := ''
  else
    result := FExpression.value;
end;

Procedure TFhirActivityDefinitionDynamicValue.SetExpressionST(value : String);
begin
  if value <> '' then
  begin
    if FExpression = nil then
      FExpression := TFhirString.create;
    FExpression.value := value
  end
  else if FExpression <> nil then
    FExpression.value := '';
end;

function TFhirActivityDefinitionDynamicValue.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDescription.sizeInBytes);
  inc(result, FPath.sizeInBytes);
  inc(result, FLanguage.sizeInBytes);
  inc(result, FExpression.sizeInBytes);
end;

{ TFhirActivityDefinitionDynamicValueListEnumerator }

Constructor TFhirActivityDefinitionDynamicValueListEnumerator.Create(list : TFhirActivityDefinitionDynamicValueList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirActivityDefinitionDynamicValueListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirActivityDefinitionDynamicValueListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirActivityDefinitionDynamicValueListEnumerator.GetCurrent : TFhirActivityDefinitionDynamicValue;
begin
  Result := FList[FIndex];
end;

function TFhirActivityDefinitionDynamicValueListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirActivityDefinitionDynamicValueList }
procedure TFhirActivityDefinitionDynamicValueList.AddItem(value: TFhirActivityDefinitionDynamicValue);
begin
  assert(value.ClassName = 'TFhirActivityDefinitionDynamicValue', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirActivityDefinitionDynamicValue');
  add(value);
end;

function TFhirActivityDefinitionDynamicValueList.Append: TFhirActivityDefinitionDynamicValue;
begin
  result := TFhirActivityDefinitionDynamicValue.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirActivityDefinitionDynamicValueList.ClearItems;
begin
  Clear;
end;

function TFhirActivityDefinitionDynamicValueList.GetEnumerator : TFhirActivityDefinitionDynamicValueListEnumerator;
begin
  result := TFhirActivityDefinitionDynamicValueListEnumerator.Create(self.link);
end;

function TFhirActivityDefinitionDynamicValueList.Clone: TFhirActivityDefinitionDynamicValueList;
begin
  result := TFhirActivityDefinitionDynamicValueList(inherited Clone);
end;

function TFhirActivityDefinitionDynamicValueList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirActivityDefinitionDynamicValueList.GetItemN(index: Integer): TFhirActivityDefinitionDynamicValue;
begin
  result := TFhirActivityDefinitionDynamicValue(ObjectByIndex[index]);
end;

function TFhirActivityDefinitionDynamicValueList.ItemClass: TFslObjectClass;
begin
  result := TFhirActivityDefinitionDynamicValue;
end;
function TFhirActivityDefinitionDynamicValueList.IndexOf(value: TFhirActivityDefinitionDynamicValue): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirActivityDefinitionDynamicValueList.Insert(index: Integer): TFhirActivityDefinitionDynamicValue;
begin
  result := TFhirActivityDefinitionDynamicValue.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirActivityDefinitionDynamicValueList.InsertItem(index: Integer; value: TFhirActivityDefinitionDynamicValue);
begin
  assert(value is TFhirActivityDefinitionDynamicValue);
  Inherited Insert(index, value);
end;

function TFhirActivityDefinitionDynamicValueList.Item(index: Integer): TFhirActivityDefinitionDynamicValue;
begin
  result := TFhirActivityDefinitionDynamicValue(ObjectByIndex[index]);
end;

function TFhirActivityDefinitionDynamicValueList.Link: TFhirActivityDefinitionDynamicValueList;
begin
  result := TFhirActivityDefinitionDynamicValueList(inherited Link);
end;

procedure TFhirActivityDefinitionDynamicValueList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirActivityDefinitionDynamicValueList.SetItemByIndex(index: Integer; value: TFhirActivityDefinitionDynamicValue);
begin
  assert(value is TFhirActivityDefinitionDynamicValue);
  FhirActivityDefinitionDynamicValues[index] := value;
end;

procedure TFhirActivityDefinitionDynamicValueList.SetItemN(index: Integer; value: TFhirActivityDefinitionDynamicValue);
begin
  assert(value is TFhirActivityDefinitionDynamicValue);
  ObjectByIndex[index] := value;
end;

{ TFhirActivityDefinition }

constructor TFhirActivityDefinition.Create;
begin
  inherited;
end;

destructor TFhirActivityDefinition.Destroy;
begin
  FIdentifierList.Free;
  FPurpose.free;
  FUsage.free;
  FApprovalDate.free;
  FLastReviewDate.free;
  FEffectivePeriod.free;
  FTopicList.Free;
  FContributorList.Free;
  FCopyright.free;
  FRelatedArtifactList.Free;
  FLibrary_List.Free;
  FKind.free;
  FCode.free;
  FTiming.free;
  FLocation.free;
  FParticipantList.Free;
  FProduct.free;
  FQuantity.free;
  FDosageList.Free;
  FBodySiteList.Free;
  FTransform.free;
  FDynamicValueList.Free;
  inherited;
end;

function TFhirActivityDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtActivityDefinition;
end;

procedure TFhirActivityDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirActivityDefinition(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirActivityDefinition(oSource).FIdentifierList);
  end;
  purposeElement := TFhirActivityDefinition(oSource).purposeElement.Clone;
  usageElement := TFhirActivityDefinition(oSource).usageElement.Clone;
  approvalDateElement := TFhirActivityDefinition(oSource).approvalDateElement.Clone;
  lastReviewDateElement := TFhirActivityDefinition(oSource).lastReviewDateElement.Clone;
  effectivePeriod := TFhirActivityDefinition(oSource).effectivePeriod.Clone;
  if (TFhirActivityDefinition(oSource).FTopicList = nil) then
  begin
    FTopicList.free;
    FTopicList := nil;
  end
  else
  begin
    if FTopicList = nil then
      FTopicList := TFhirCodeableConceptList.Create;
    FTopicList.Assign(TFhirActivityDefinition(oSource).FTopicList);
  end;
  if (TFhirActivityDefinition(oSource).FContributorList = nil) then
  begin
    FContributorList.free;
    FContributorList := nil;
  end
  else
  begin
    if FContributorList = nil then
      FContributorList := TFhirContributorList.Create;
    FContributorList.Assign(TFhirActivityDefinition(oSource).FContributorList);
  end;
  copyrightElement := TFhirActivityDefinition(oSource).copyrightElement.Clone;
  if (TFhirActivityDefinition(oSource).FRelatedArtifactList = nil) then
  begin
    FRelatedArtifactList.free;
    FRelatedArtifactList := nil;
  end
  else
  begin
    if FRelatedArtifactList = nil then
      FRelatedArtifactList := TFhirRelatedArtifactList.Create;
    FRelatedArtifactList.Assign(TFhirActivityDefinition(oSource).FRelatedArtifactList);
  end;
  if (TFhirActivityDefinition(oSource).FLibrary_List = nil) then
  begin
    FLibrary_List.free;
    FLibrary_List := nil;
  end
  else
  begin
    if FLibrary_List = nil then
      FLibrary_List := TFhirReferenceList{TFhirLibrary}.Create;
    FLibrary_List.Assign(TFhirActivityDefinition(oSource).FLibrary_List);
  end;
  FKind := TFhirActivityDefinition(oSource).FKind.Link;
  code := TFhirActivityDefinition(oSource).code.Clone;
  timing := TFhirActivityDefinition(oSource).timing.Clone;
  location := TFhirActivityDefinition(oSource).location.Clone;
  if (TFhirActivityDefinition(oSource).FParticipantList = nil) then
  begin
    FParticipantList.free;
    FParticipantList := nil;
  end
  else
  begin
    if FParticipantList = nil then
      FParticipantList := TFhirActivityDefinitionParticipantList.Create;
    FParticipantList.Assign(TFhirActivityDefinition(oSource).FParticipantList);
  end;
  product := TFhirActivityDefinition(oSource).product.Clone;
  quantity := TFhirActivityDefinition(oSource).quantity.Clone;
  if (TFhirActivityDefinition(oSource).FDosageList = nil) then
  begin
    FDosageList.free;
    FDosageList := nil;
  end
  else
  begin
    if FDosageList = nil then
      FDosageList := TFhirDosageList.Create;
    FDosageList.Assign(TFhirActivityDefinition(oSource).FDosageList);
  end;
  if (TFhirActivityDefinition(oSource).FBodySiteList = nil) then
  begin
    FBodySiteList.free;
    FBodySiteList := nil;
  end
  else
  begin
    if FBodySiteList = nil then
      FBodySiteList := TFhirCodeableConceptList.Create;
    FBodySiteList.Assign(TFhirActivityDefinition(oSource).FBodySiteList);
  end;
  transform := TFhirActivityDefinition(oSource).transform.Clone;
  if (TFhirActivityDefinition(oSource).FDynamicValueList = nil) then
  begin
    FDynamicValueList.free;
    FDynamicValueList := nil;
  end
  else
  begin
    if FDynamicValueList = nil then
      FDynamicValueList := TFhirActivityDefinitionDynamicValueList.Create;
    FDynamicValueList.Assign(TFhirActivityDefinition(oSource).FDynamicValueList);
  end;
end;

procedure TFhirActivityDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'usage') Then
     list.add(self.link, 'usage', FUsage.Link);
  if (child_name = 'approvalDate') Then
     list.add(self.link, 'approvalDate', FApprovalDate.Link);
  if (child_name = 'lastReviewDate') Then
     list.add(self.link, 'lastReviewDate', FLastReviewDate.Link);
  if (child_name = 'effectivePeriod') Then
     list.add(self.link, 'effectivePeriod', FEffectivePeriod.Link);
  if (child_name = 'topic') Then
    list.addAll(self, 'topic', FTopicList);
  if (child_name = 'contributor') Then
    list.addAll(self, 'contributor', FContributorList);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'relatedArtifact') Then
    list.addAll(self, 'relatedArtifact', FRelatedArtifactList);
  if (child_name = 'library') Then
    list.addAll(self, 'library', FLibrary_List);
  if (child_name = 'kind') Then
     list.add(self.link, 'kind', FKind.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'timing[x]') or (child_name = 'timing') Then
     list.add(self.link, 'timing[x]', FTiming.Link);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'participant') Then
    list.addAll(self, 'participant', FParticipantList);
  if (child_name = 'product[x]') or (child_name = 'product') Then
     list.add(self.link, 'product[x]', FProduct.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'dosage') Then
    list.addAll(self, 'dosage', FDosageList);
  if (child_name = 'bodySite') Then
    list.addAll(self, 'bodySite', FBodySiteList);
  if (child_name = 'transform') Then
     list.add(self.link, 'transform', FTransform.Link);
  if (child_name = 'dynamicValue') Then
    list.addAll(self, 'dynamicValue', FDynamicValueList);
end;

procedure TFhirActivityDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));{2}
  oList.add(TFHIRProperty.create(self, 'usage', 'string', false, TFhirString, FUsage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'approvalDate', 'date', false, TFhirDate, FApprovalDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'lastReviewDate', 'date', false, TFhirDate, FLastReviewDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'effectivePeriod', 'Period', false, TFhirPeriod, FEffectivePeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'topic', 'CodeableConcept', true, TFhirCodeableConcept, FTopicList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'contributor', 'Contributor', true, TFhirContributor, FContributorList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));{2}
  oList.add(TFHIRProperty.create(self, 'relatedArtifact', 'RelatedArtifact', true, TFhirRelatedArtifact, FRelatedArtifactList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'library', 'Reference(Library)', true, TFhirReference{TFhirLibrary}, FLibrary_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'kind', 'code', false, TFHIREnum, FKind.Link));{1}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'timing[x]', 'Timing|dateTime|Period|Range', false, TFhirType, FTiming.Link));{2}
  oList.add(TFHIRProperty.create(self, 'location', 'Reference(Location)', false, TFhirReference{TFhirLocation}, FLocation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'participant', '', true, TFhirActivityDefinitionParticipant, FParticipantList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'product[x]', 'Reference(Medication|Substance)|CodeableConcept', false, TFhirType, FProduct.Link));{2}
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dosage', 'Dosage', true, TFhirDosage, FDosageList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', true, TFhirCodeableConcept, FBodySiteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'transform', 'Reference(StructureMap)', false, TFhirReference{TFhirStructureMap}, FTransform.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dynamicValue', '', true, TFhirActivityDefinitionDynamicValue, FDynamicValueList.Link)){3};
end;

function TFhirActivityDefinition.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'usage') then
  begin
    UsageElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'approvalDate') then
  begin
    ApprovalDateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'lastReviewDate') then
  begin
    LastReviewDateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'effectivePeriod') then
  begin
    EffectivePeriod := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'topic') then
  begin
    TopicList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'contributor') then
  begin
    ContributorList.add(propValue as TFhirContributor){2a};
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'relatedArtifact') then
  begin
    RelatedArtifactList.add(propValue as TFhirRelatedArtifact){2a};
    result := propValue;
  end
  else if (propName = 'library') then
  begin
    Library_List.add(propValue as TFhirReference{TFhirLibrary}){2a};
    result := propValue;
  end
  else if (propName = 'kind') then
  begin
    KindElement := asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue);
    result := propValue
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'timing', ['Timing', 'DateTime', 'Period', 'Range'])) then
  begin
    Timing := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirReference{TFhirLocation}{4b};
    result := propValue;
  end
  else if (propName = 'participant') then
  begin
    ParticipantList.add(propValue as TFhirActivityDefinitionParticipant){2a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'product', ['Reference', 'CodeableConcept'])) then
  begin
    Product := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity{4b};
    result := propValue;
  end
  else if (propName = 'dosage') then
  begin
    DosageList.add(propValue as TFhirDosage){2a};
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySiteList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'transform') then
  begin
    Transform := propValue as TFhirReference{TFhirStructureMap}{4b};
    result := propValue;
  end
  else if (propName = 'dynamicValue') then
  begin
    DynamicValueList.add(propValue as TFhirActivityDefinitionDynamicValue){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirActivityDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'topic') then TopicList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'contributor') then ContributorList.insertItem(index, propValue as TFhirContributor){2a}
  else if (propName = 'relatedArtifact') then RelatedArtifactList.insertItem(index, propValue as TFhirRelatedArtifact){2a}
  else if (propName = 'library') then Library_List.insertItem(index, propValue as TFhirReference{TFhirLibrary}){2a}
  else if (propName = 'participant') then ParticipantList.insertItem(index, propValue as TFhirActivityDefinitionParticipant){2a}
  else if (propName = 'dosage') then DosageList.insertItem(index, propValue as TFhirDosage){2a}
  else if (propName = 'bodySite') then BodySiteList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'dynamicValue') then DynamicValueList.insertItem(index, propValue as TFhirActivityDefinitionDynamicValue){2a}
  else inherited;
end;

function TFhirActivityDefinition.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'purpose') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'usage') then result := TFhirString.create() {5b}
  else if (propName = 'approvalDate') then result := TFhirDate.create() {5b}
  else if (propName = 'lastReviewDate') then result := TFhirDate.create() {5b}
  else if (propName = 'effectivePeriod') then result := TFhirPeriod.create(){4b}
  else if (propName = 'topic') then result := TopicList.new(){2}
  else if (propName = 'contributor') then result := ContributorList.new(){2}
  else if (propName = 'copyright') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'relatedArtifact') then result := RelatedArtifactList.new(){2}
  else if (propName = 'library') then result := Library_List.new(){2}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'timing', ['Timing', 'DateTime', 'Period', 'Range'])) then raise EFHIRException.create('Cannot make property Timing'){4x}
  else if (propName = 'location') then result := TFhirReference{TFhirLocation}.create(){4b}
  else if (propName = 'participant') then result := ParticipantList.new(){2}
  else if (isMatchingName(propName, 'product', ['Reference', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property Product'){4x}
  else if (propName = 'quantity') then result := TFhirQuantity.create(){4b}
  else if (propName = 'dosage') then result := DosageList.new(){2}
  else if (propName = 'bodySite') then result := BodySiteList.new(){2}
  else if (propName = 'transform') then result := TFhirReference{TFhirStructureMap}.create(){4b}
  else if (propName = 'dynamicValue') then result := DynamicValueList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirActivityDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'usage') then result := 'string'
  else if (propName = 'approvalDate') then result := 'date'
  else if (propName = 'lastReviewDate') then result := 'date'
  else if (propName = 'effectivePeriod') then result := 'Period'
  else if (propName = 'topic') then result := 'CodeableConcept'
  else if (propName = 'contributor') then result := 'Contributor'
  else if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'relatedArtifact') then result := 'RelatedArtifact'
  else if (propName = 'library') then result := 'Reference'
  else if (propName = 'kind') then result := 'code'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'timing[x]') then result := 'Timing|dateTime|Period|Range'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'participant') then result := ''
  else if (propName = 'product[x]') then result := 'Reference|CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'dosage') then result := 'Dosage'
  else if (propName = 'bodySite') then result := 'CodeableConcept'
  else if (propName = 'transform') then result := 'Reference'
  else if (propName = 'dynamicValue') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirActivityDefinition.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'usage') then UsageElement := nil
  else if (propName = 'approvalDate') then ApprovalDateElement := nil
  else if (propName = 'lastReviewDate') then LastReviewDateElement := nil
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := nil
  else if (propName = 'topic') then deletePropertyValue('topic', TopicList, value) {2}
  else if (propName = 'contributor') then deletePropertyValue('contributor', ContributorList, value) {2}
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'relatedArtifact') then deletePropertyValue('relatedArtifact', RelatedArtifactList, value) {2}
  else if (propName = 'library') then deletePropertyValue('library', Library_List, value) {2}
  else if (propName = 'kind') then KindElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (isMatchingName(propName, 'timing', ['Timing', 'DateTime', 'Period', 'Range'])) then TimingElement := nil{4x}
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'participant') then deletePropertyValue('participant', ParticipantList, value) {2}
  else if (isMatchingName(propName, 'product', ['Reference', 'CodeableConcept'])) then ProductElement := nil{4x}
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'dosage') then deletePropertyValue('dosage', DosageList, value) {2}
  else if (propName = 'bodySite') then deletePropertyValue('bodySite', BodySiteList, value) {2}
  else if (propName = 'transform') then TransformElement := nil
  else if (propName = 'dynamicValue') then deletePropertyValue('dynamicValue', DynamicValueList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirActivityDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'purpose') then PurposeElement := asMarkdown(new){5b}
  else if (propName = 'usage') then UsageElement := asString(new){5b}
  else if (propName = 'approvalDate') then ApprovalDateElement := asDate(new){5b}
  else if (propName = 'lastReviewDate') then LastReviewDateElement := asDate(new){5b}
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := new as TFhirPeriod{4}
  else if (propName = 'topic') then replacePropertyValue('topic', TopicList, existing, new) {2}
  else if (propName = 'contributor') then replacePropertyValue('contributor', ContributorList, existing, new) {2}
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new){5b}
  else if (propName = 'relatedArtifact') then replacePropertyValue('relatedArtifact', RelatedArtifactList, existing, new) {2}
  else if (propName = 'library') then replacePropertyValue('library', Library_List, existing, new) {2}
  else if (propName = 'kind') then KindElement := asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, new){4}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'timing', ['Timing', 'DateTime', 'Period', 'Range'])) then TimingElement := new as TFhirType{4x}
  else if (propName = 'location') then LocationElement := new as TFhirReference{TFhirLocation}{4}
  else if (propName = 'participant') then replacePropertyValue('participant', ParticipantList, existing, new) {2}
  else if (isMatchingName(propName, 'product', ['Reference', 'CodeableConcept'])) then ProductElement := new as TFhirType{4x}
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity{4}
  else if (propName = 'dosage') then replacePropertyValue('dosage', DosageList, existing, new) {2}
  else if (propName = 'bodySite') then replacePropertyValue('bodySite', BodySiteList, existing, new) {2}
  else if (propName = 'transform') then TransformElement := new as TFhirReference{TFhirStructureMap}{4}
  else if (propName = 'dynamicValue') then replacePropertyValue('dynamicValue', DynamicValueList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirActivityDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'topic') then TopicList.move(source, destination){2a}
  else if (propName = 'contributor') then ContributorList.move(source, destination){2a}
  else if (propName = 'relatedArtifact') then RelatedArtifactList.move(source, destination){2a}
  else if (propName = 'library') then Library_List.move(source, destination){2a}
  else if (propName = 'participant') then ParticipantList.move(source, destination){2a}
  else if (propName = 'dosage') then DosageList.move(source, destination){2a}
  else if (propName = 'bodySite') then BodySiteList.move(source, destination){2a}
  else if (propName = 'dynamicValue') then DynamicValueList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirActivityDefinition.fhirType : string;
begin
  result := 'ActivityDefinition';
end;

function TFhirActivityDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FPurpose) and isEmptyProp(FUsage) and isEmptyProp(FApprovalDate) and isEmptyProp(FLastReviewDate) and isEmptyProp(FEffectivePeriod) and isEmptyProp(FtopicList) and isEmptyProp(FcontributorList) and isEmptyProp(FCopyright) and isEmptyProp(FrelatedArtifactList) and isEmptyProp(Flibrary_List) and isEmptyProp(FKind) and isEmptyProp(FCode) and isEmptyProp(FTiming) and isEmptyProp(FLocation) and isEmptyProp(FparticipantList) and isEmptyProp(FProduct) and isEmptyProp(FQuantity) and isEmptyProp(FdosageList) and isEmptyProp(FbodySiteList) and isEmptyProp(FTransform) and isEmptyProp(FdynamicValueList);
end;

function TFhirActivityDefinition.equals(other : TObject) : boolean;
var
  o : TFhirActivityDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirActivityDefinition)) then
    result := false
  else
  begin
    o := TFhirActivityDefinition(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(purposeElement, o.purposeElement, true) and
      compareDeep(usageElement, o.usageElement, true) and compareDeep(approvalDateElement, o.approvalDateElement, true) and
      compareDeep(lastReviewDateElement, o.lastReviewDateElement, true) and compareDeep(effectivePeriodElement, o.effectivePeriodElement, true) and
      compareDeep(topicList, o.topicList, true) and compareDeep(contributorList, o.contributorList, true) and
      compareDeep(copyrightElement, o.copyrightElement, true) and compareDeep(relatedArtifactList, o.relatedArtifactList, true) and
      compareDeep(library_List, o.library_List, true) and compareDeep(kindElement, o.kindElement, true) and
      compareDeep(codeElement, o.codeElement, true) and compareDeep(timingElement, o.timingElement, true) and
      compareDeep(locationElement, o.locationElement, true) and compareDeep(participantList, o.participantList, true) and
      compareDeep(productElement, o.productElement, true) and compareDeep(quantityElement, o.quantityElement, true) and
      compareDeep(dosageList, o.dosageList, true) and compareDeep(bodySiteList, o.bodySiteList, true) and
      compareDeep(transformElement, o.transformElement, true) and compareDeep(dynamicValueList, o.dynamicValueList, true);
  end;
end;

function TFhirActivityDefinition.Link : TFhirActivityDefinition;
begin
  result := TFhirActivityDefinition(inherited Link);
end;

function TFhirActivityDefinition.Clone : TFhirActivityDefinition;
begin
  result := TFhirActivityDefinition(inherited Clone);
end;

procedure TFhirActivityDefinition.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('status');
  fields.add('experimental');
  fields.add('date');
  fields.add('publisher');
  fields.add('description');
  fields.add('purpose');
  fields.add('usage');
  fields.add('approvalDate');
  fields.add('lastReviewDate');
  fields.add('effectivePeriod');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('topic');
  fields.add('contributor');
  fields.add('contact');
  fields.add('copyright');
  fields.add('relatedArtifact');
  fields.add('library');
  fields.add('kind');
  fields.add('code');
  fields.add('timing[x]');
  fields.add('location');
  fields.add('participant');
  fields.add('product[x]');
  fields.add('quantity');
  fields.add('dosage');
  fields.add('bodySite');
  fields.add('transform');
  fields.add('dynamicValue');
end;

{ TFhirActivityDefinition }

Function TFhirActivityDefinition.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirActivityDefinition.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirActivityDefinition.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

Function TFhirActivityDefinition.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

Procedure TFhirActivityDefinition.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

Procedure TFhirActivityDefinition.SetUsage(value : TFhirString);
begin
  FUsage.free;
  FUsage := value;
end;

Function TFhirActivityDefinition.GetUsageST : String;
begin
  if FUsage = nil then
    result := ''
  else
    result := FUsage.value;
end;

Procedure TFhirActivityDefinition.SetUsageST(value : String);
begin
  if value <> '' then
  begin
    if FUsage = nil then
      FUsage := TFhirString.create;
    FUsage.value := value
  end
  else if FUsage <> nil then
    FUsage.value := '';
end;

Procedure TFhirActivityDefinition.SetApprovalDate(value : TFhirDate);
begin
  FApprovalDate.free;
  FApprovalDate := value;
end;

Function TFhirActivityDefinition.GetApprovalDateST : TFslDateTime;
begin
  if FApprovalDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FApprovalDate.value;
end;

Procedure TFhirActivityDefinition.SetApprovalDateST(value : TFslDateTime);
begin
  if FApprovalDate = nil then
    FApprovalDate := TFhirDate.create;
  FApprovalDate.value := value
end;

Procedure TFhirActivityDefinition.SetLastReviewDate(value : TFhirDate);
begin
  FLastReviewDate.free;
  FLastReviewDate := value;
end;

Function TFhirActivityDefinition.GetLastReviewDateST : TFslDateTime;
begin
  if FLastReviewDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastReviewDate.value;
end;

Procedure TFhirActivityDefinition.SetLastReviewDateST(value : TFslDateTime);
begin
  if FLastReviewDate = nil then
    FLastReviewDate := TFhirDate.create;
  FLastReviewDate.value := value
end;

Procedure TFhirActivityDefinition.SetEffectivePeriod(value : TFhirPeriod);
begin
  FEffectivePeriod.free;
  FEffectivePeriod := value;
end;

Function TFhirActivityDefinition.GetTopicList : TFhirCodeableConceptList;
begin
  if FTopicList = nil then
    FTopicList := TFhirCodeableConceptList.Create;
  result := FTopicList;
end;

Function TFhirActivityDefinition.GetHasTopicList : boolean;
begin
  result := (FTopicList <> nil) and (FTopicList.count > 0);
end;

Function TFhirActivityDefinition.GetContributorList : TFhirContributorList;
begin
  if FContributorList = nil then
    FContributorList := TFhirContributorList.Create;
  result := FContributorList;
end;

Function TFhirActivityDefinition.GetHasContributorList : boolean;
begin
  result := (FContributorList <> nil) and (FContributorList.count > 0);
end;

Procedure TFhirActivityDefinition.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

Function TFhirActivityDefinition.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

Procedure TFhirActivityDefinition.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

Function TFhirActivityDefinition.GetRelatedArtifactList : TFhirRelatedArtifactList;
begin
  if FRelatedArtifactList = nil then
    FRelatedArtifactList := TFhirRelatedArtifactList.Create;
  result := FRelatedArtifactList;
end;

Function TFhirActivityDefinition.GetHasRelatedArtifactList : boolean;
begin
  result := (FRelatedArtifactList <> nil) and (FRelatedArtifactList.count > 0);
end;

Function TFhirActivityDefinition.GetLibrary_List : TFhirReferenceList{TFhirLibrary};
begin
  if FLibrary_List = nil then
    FLibrary_List := TFhirReferenceList{TFhirLibrary}.Create;
  result := FLibrary_List;
end;

Function TFhirActivityDefinition.GetHasLibrary_List : boolean;
begin
  result := (FLibrary_List <> nil) and (FLibrary_List.count > 0);
end;

Procedure TFhirActivityDefinition.SetKind(value : TFhirEnum);
begin
  FKind.free;
  FKind := value;
end;

Function TFhirActivityDefinition.GetKindST : TFhirResourceTypesEnum;
begin
  if FKind = nil then
    result := TFhirResourceTypesEnum(0)
  else
    result := TFhirResourceTypesEnum(StringArrayIndexOfSensitive(CODES_TFhirResourceTypesEnum, FKind.value));
end;

Procedure TFhirActivityDefinition.SetKindST(value : TFhirResourceTypesEnum);
begin
  if ord(value) = 0 then
    KindElement := nil
  else
    KindElement := TFhirEnum.create(SYSTEMS_TFhirResourceTypesEnum[value], CODES_TFhirResourceTypesEnum[value]);
end;

Procedure TFhirActivityDefinition.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirActivityDefinition.SetTiming(value : TFhirType);
begin
  FTiming.free;
  FTiming := value;
end;

Procedure TFhirActivityDefinition.SetLocation(value : TFhirReference{TFhirLocation});
begin
  FLocation.free;
  FLocation := value;
end;

Function TFhirActivityDefinition.GetParticipantList : TFhirActivityDefinitionParticipantList;
begin
  if FParticipantList = nil then
    FParticipantList := TFhirActivityDefinitionParticipantList.Create;
  result := FParticipantList;
end;

Function TFhirActivityDefinition.GetHasParticipantList : boolean;
begin
  result := (FParticipantList <> nil) and (FParticipantList.count > 0);
end;

Procedure TFhirActivityDefinition.SetProduct(value : TFhirType);
begin
  FProduct.free;
  FProduct := value;
end;

Procedure TFhirActivityDefinition.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

Function TFhirActivityDefinition.GetDosageList : TFhirDosageList;
begin
  if FDosageList = nil then
    FDosageList := TFhirDosageList.Create;
  result := FDosageList;
end;

Function TFhirActivityDefinition.GetHasDosageList : boolean;
begin
  result := (FDosageList <> nil) and (FDosageList.count > 0);
end;

Function TFhirActivityDefinition.GetBodySiteList : TFhirCodeableConceptList;
begin
  if FBodySiteList = nil then
    FBodySiteList := TFhirCodeableConceptList.Create;
  result := FBodySiteList;
end;

Function TFhirActivityDefinition.GetHasBodySiteList : boolean;
begin
  result := (FBodySiteList <> nil) and (FBodySiteList.count > 0);
end;

Procedure TFhirActivityDefinition.SetTransform(value : TFhirReference{TFhirStructureMap});
begin
  FTransform.free;
  FTransform := value;
end;

Function TFhirActivityDefinition.GetDynamicValueList : TFhirActivityDefinitionDynamicValueList;
begin
  if FDynamicValueList = nil then
    FDynamicValueList := TFhirActivityDefinitionDynamicValueList.Create;
  result := FDynamicValueList;
end;

Function TFhirActivityDefinition.GetHasDynamicValueList : boolean;
begin
  result := (FDynamicValueList <> nil) and (FDynamicValueList.count > 0);
end;

function TFhirActivityDefinition.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FPurpose.sizeInBytes);
  inc(result, FUsage.sizeInBytes);
  inc(result, FApprovalDate.sizeInBytes);
  inc(result, FLastReviewDate.sizeInBytes);
  inc(result, FEffectivePeriod.sizeInBytes);
  inc(result, FtopicList.sizeInBytes);
  inc(result, FcontributorList.sizeInBytes);
  inc(result, FCopyright.sizeInBytes);
  inc(result, FrelatedArtifactList.sizeInBytes);
  inc(result, Flibrary_List.sizeInBytes);
  inc(result, FKind.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FTiming.sizeInBytes);
  inc(result, FLocation.sizeInBytes);
  inc(result, FparticipantList.sizeInBytes);
  inc(result, FProduct.sizeInBytes);
  inc(result, FQuantity.sizeInBytes);
  inc(result, FdosageList.sizeInBytes);
  inc(result, FbodySiteList.sizeInBytes);
  inc(result, FTransform.sizeInBytes);
  inc(result, FdynamicValueList.sizeInBytes);
end;

{ TFhirActivityDefinitionListEnumerator }

Constructor TFhirActivityDefinitionListEnumerator.Create(list : TFhirActivityDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirActivityDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirActivityDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirActivityDefinitionListEnumerator.GetCurrent : TFhirActivityDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirActivityDefinitionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirActivityDefinitionList }
procedure TFhirActivityDefinitionList.AddItem(value: TFhirActivityDefinition);
begin
  assert(value.ClassName = 'TFhirActivityDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirActivityDefinition');
  add(value);
end;

function TFhirActivityDefinitionList.Append: TFhirActivityDefinition;
begin
  result := TFhirActivityDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirActivityDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirActivityDefinitionList.GetEnumerator : TFhirActivityDefinitionListEnumerator;
begin
  result := TFhirActivityDefinitionListEnumerator.Create(self.link);
end;

function TFhirActivityDefinitionList.Clone: TFhirActivityDefinitionList;
begin
  result := TFhirActivityDefinitionList(inherited Clone);
end;

function TFhirActivityDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirActivityDefinitionList.GetItemN(index: Integer): TFhirActivityDefinition;
begin
  result := TFhirActivityDefinition(ObjectByIndex[index]);
end;

function TFhirActivityDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirActivityDefinition;
end;
function TFhirActivityDefinitionList.IndexOf(value: TFhirActivityDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirActivityDefinitionList.Insert(index: Integer): TFhirActivityDefinition;
begin
  result := TFhirActivityDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirActivityDefinitionList.InsertItem(index: Integer; value: TFhirActivityDefinition);
begin
  assert(value is TFhirActivityDefinition);
  Inherited Insert(index, value);
end;

function TFhirActivityDefinitionList.Item(index: Integer): TFhirActivityDefinition;
begin
  result := TFhirActivityDefinition(ObjectByIndex[index]);
end;

function TFhirActivityDefinitionList.Link: TFhirActivityDefinitionList;
begin
  result := TFhirActivityDefinitionList(inherited Link);
end;

procedure TFhirActivityDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirActivityDefinitionList.SetItemByIndex(index: Integer; value: TFhirActivityDefinition);
begin
  assert(value is TFhirActivityDefinition);
  FhirActivityDefinitions[index] := value;
end;

procedure TFhirActivityDefinitionList.SetItemN(index: Integer; value: TFhirActivityDefinition);
begin
  assert(value is TFhirActivityDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ACTIVITYDEFINITION}

{$IFDEF FHIR_CAPABILITYSTATEMENT}

{ TFhirCapabilityStatementSoftware }

constructor TFhirCapabilityStatementSoftware.Create;
begin
  inherited;
end;

destructor TFhirCapabilityStatementSoftware.Destroy;
begin
  FName.free;
  FVersion.free;
  FReleaseDate.free;
  inherited;
end;

procedure TFhirCapabilityStatementSoftware.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirCapabilityStatementSoftware(oSource).nameElement.Clone;
  versionElement := TFhirCapabilityStatementSoftware(oSource).versionElement.Clone;
  releaseDateElement := TFhirCapabilityStatementSoftware(oSource).releaseDateElement.Clone;
end;

procedure TFhirCapabilityStatementSoftware.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'releaseDate') Then
     list.add(self.link, 'releaseDate', FReleaseDate.Link);
end;

procedure TFhirCapabilityStatementSoftware.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));{2}
  oList.add(TFHIRProperty.create(self, 'releaseDate', 'dateTime', false, TFhirDateTime, FReleaseDate.Link));{2}
end;

function TFhirCapabilityStatementSoftware.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'releaseDate') then
  begin
    ReleaseDateElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCapabilityStatementSoftware.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCapabilityStatementSoftware.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'version') then result := TFhirString.create() {5b}
  else if (propName = 'releaseDate') then result := TFhirDateTime.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCapabilityStatementSoftware.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'releaseDate') then result := 'dateTime'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCapabilityStatementSoftware.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'releaseDate') then ReleaseDateElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCapabilityStatementSoftware.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'version') then VersionElement := asString(new){5b}
  else if (propName = 'releaseDate') then ReleaseDateElement := asDateTime(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCapabilityStatementSoftware.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCapabilityStatementSoftware.fhirType : string;
begin
  result := 'software';
end;

function TFhirCapabilityStatementSoftware.Link : TFhirCapabilityStatementSoftware;
begin
  result := TFhirCapabilityStatementSoftware(inherited Link);
end;

function TFhirCapabilityStatementSoftware.Clone : TFhirCapabilityStatementSoftware;
begin
  result := TFhirCapabilityStatementSoftware(inherited Clone);
end;

function TFhirCapabilityStatementSoftware.equals(other : TObject) : boolean;
var
  o : TFhirCapabilityStatementSoftware;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCapabilityStatementSoftware)) then
    result := false
  else
  begin
    o := TFhirCapabilityStatementSoftware(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(versionElement, o.versionElement, true) and
      compareDeep(releaseDateElement, o.releaseDateElement, true);
  end;
end;

function TFhirCapabilityStatementSoftware.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FVersion) and isEmptyProp(FReleaseDate);
end;

procedure TFhirCapabilityStatementSoftware.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('version');
  fields.add('releaseDate');
end;

{ TFhirCapabilityStatementSoftware }

Procedure TFhirCapabilityStatementSoftware.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirCapabilityStatementSoftware.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirCapabilityStatementSoftware.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirCapabilityStatementSoftware.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

Function TFhirCapabilityStatementSoftware.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

Procedure TFhirCapabilityStatementSoftware.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

Procedure TFhirCapabilityStatementSoftware.SetReleaseDate(value : TFhirDateTime);
begin
  FReleaseDate.free;
  FReleaseDate := value;
end;

Function TFhirCapabilityStatementSoftware.GetReleaseDateST : TFslDateTime;
begin
  if FReleaseDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FReleaseDate.value;
end;

Procedure TFhirCapabilityStatementSoftware.SetReleaseDateST(value : TFslDateTime);
begin
  if FReleaseDate = nil then
    FReleaseDate := TFhirDateTime.create;
  FReleaseDate.value := value
end;

function TFhirCapabilityStatementSoftware.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FVersion.sizeInBytes);
  inc(result, FReleaseDate.sizeInBytes);
end;

{ TFhirCapabilityStatementSoftwareListEnumerator }

Constructor TFhirCapabilityStatementSoftwareListEnumerator.Create(list : TFhirCapabilityStatementSoftwareList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCapabilityStatementSoftwareListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCapabilityStatementSoftwareListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCapabilityStatementSoftwareListEnumerator.GetCurrent : TFhirCapabilityStatementSoftware;
begin
  Result := FList[FIndex];
end;

function TFhirCapabilityStatementSoftwareListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCapabilityStatementSoftwareList }
procedure TFhirCapabilityStatementSoftwareList.AddItem(value: TFhirCapabilityStatementSoftware);
begin
  assert(value.ClassName = 'TFhirCapabilityStatementSoftware', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCapabilityStatementSoftware');
  add(value);
end;

function TFhirCapabilityStatementSoftwareList.Append: TFhirCapabilityStatementSoftware;
begin
  result := TFhirCapabilityStatementSoftware.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementSoftwareList.ClearItems;
begin
  Clear;
end;

function TFhirCapabilityStatementSoftwareList.GetEnumerator : TFhirCapabilityStatementSoftwareListEnumerator;
begin
  result := TFhirCapabilityStatementSoftwareListEnumerator.Create(self.link);
end;

function TFhirCapabilityStatementSoftwareList.Clone: TFhirCapabilityStatementSoftwareList;
begin
  result := TFhirCapabilityStatementSoftwareList(inherited Clone);
end;

function TFhirCapabilityStatementSoftwareList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCapabilityStatementSoftwareList.GetItemN(index: Integer): TFhirCapabilityStatementSoftware;
begin
  result := TFhirCapabilityStatementSoftware(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementSoftwareList.ItemClass: TFslObjectClass;
begin
  result := TFhirCapabilityStatementSoftware;
end;
function TFhirCapabilityStatementSoftwareList.IndexOf(value: TFhirCapabilityStatementSoftware): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCapabilityStatementSoftwareList.Insert(index: Integer): TFhirCapabilityStatementSoftware;
begin
  result := TFhirCapabilityStatementSoftware.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementSoftwareList.InsertItem(index: Integer; value: TFhirCapabilityStatementSoftware);
begin
  assert(value is TFhirCapabilityStatementSoftware);
  Inherited Insert(index, value);
end;

function TFhirCapabilityStatementSoftwareList.Item(index: Integer): TFhirCapabilityStatementSoftware;
begin
  result := TFhirCapabilityStatementSoftware(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementSoftwareList.Link: TFhirCapabilityStatementSoftwareList;
begin
  result := TFhirCapabilityStatementSoftwareList(inherited Link);
end;

procedure TFhirCapabilityStatementSoftwareList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCapabilityStatementSoftwareList.SetItemByIndex(index: Integer; value: TFhirCapabilityStatementSoftware);
begin
  assert(value is TFhirCapabilityStatementSoftware);
  FhirCapabilityStatementSoftwares[index] := value;
end;

procedure TFhirCapabilityStatementSoftwareList.SetItemN(index: Integer; value: TFhirCapabilityStatementSoftware);
begin
  assert(value is TFhirCapabilityStatementSoftware);
  ObjectByIndex[index] := value;
end;

{ TFhirCapabilityStatementImplementation }

constructor TFhirCapabilityStatementImplementation.Create;
begin
  inherited;
end;

destructor TFhirCapabilityStatementImplementation.Destroy;
begin
  FDescription.free;
  FUrl.free;
  inherited;
end;

procedure TFhirCapabilityStatementImplementation.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirCapabilityStatementImplementation(oSource).descriptionElement.Clone;
  urlElement := TFhirCapabilityStatementImplementation(oSource).urlElement.Clone;
end;

procedure TFhirCapabilityStatementImplementation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
end;

procedure TFhirCapabilityStatementImplementation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));{2}
end;

function TFhirCapabilityStatementImplementation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'url') then
  begin
    UrlElement := asUri(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCapabilityStatementImplementation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCapabilityStatementImplementation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'url') then result := TFhirUri.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCapabilityStatementImplementation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'url') then result := 'uri'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCapabilityStatementImplementation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'url') then UrlElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCapabilityStatementImplementation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'url') then UrlElement := asUri(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCapabilityStatementImplementation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCapabilityStatementImplementation.fhirType : string;
begin
  result := 'implementation';
end;

function TFhirCapabilityStatementImplementation.Link : TFhirCapabilityStatementImplementation;
begin
  result := TFhirCapabilityStatementImplementation(inherited Link);
end;

function TFhirCapabilityStatementImplementation.Clone : TFhirCapabilityStatementImplementation;
begin
  result := TFhirCapabilityStatementImplementation(inherited Clone);
end;

function TFhirCapabilityStatementImplementation.equals(other : TObject) : boolean;
var
  o : TFhirCapabilityStatementImplementation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCapabilityStatementImplementation)) then
    result := false
  else
  begin
    o := TFhirCapabilityStatementImplementation(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(urlElement, o.urlElement, true);
  end;
end;

function TFhirCapabilityStatementImplementation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FUrl);
end;

procedure TFhirCapabilityStatementImplementation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('description');
  fields.add('url');
end;

{ TFhirCapabilityStatementImplementation }

Procedure TFhirCapabilityStatementImplementation.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirCapabilityStatementImplementation.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirCapabilityStatementImplementation.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirCapabilityStatementImplementation.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirCapabilityStatementImplementation.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

Procedure TFhirCapabilityStatementImplementation.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

function TFhirCapabilityStatementImplementation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDescription.sizeInBytes);
  inc(result, FUrl.sizeInBytes);
end;

{ TFhirCapabilityStatementImplementationListEnumerator }

Constructor TFhirCapabilityStatementImplementationListEnumerator.Create(list : TFhirCapabilityStatementImplementationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCapabilityStatementImplementationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCapabilityStatementImplementationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCapabilityStatementImplementationListEnumerator.GetCurrent : TFhirCapabilityStatementImplementation;
begin
  Result := FList[FIndex];
end;

function TFhirCapabilityStatementImplementationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCapabilityStatementImplementationList }
procedure TFhirCapabilityStatementImplementationList.AddItem(value: TFhirCapabilityStatementImplementation);
begin
  assert(value.ClassName = 'TFhirCapabilityStatementImplementation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCapabilityStatementImplementation');
  add(value);
end;

function TFhirCapabilityStatementImplementationList.Append: TFhirCapabilityStatementImplementation;
begin
  result := TFhirCapabilityStatementImplementation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementImplementationList.ClearItems;
begin
  Clear;
end;

function TFhirCapabilityStatementImplementationList.GetEnumerator : TFhirCapabilityStatementImplementationListEnumerator;
begin
  result := TFhirCapabilityStatementImplementationListEnumerator.Create(self.link);
end;

function TFhirCapabilityStatementImplementationList.Clone: TFhirCapabilityStatementImplementationList;
begin
  result := TFhirCapabilityStatementImplementationList(inherited Clone);
end;

function TFhirCapabilityStatementImplementationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCapabilityStatementImplementationList.GetItemN(index: Integer): TFhirCapabilityStatementImplementation;
begin
  result := TFhirCapabilityStatementImplementation(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementImplementationList.ItemClass: TFslObjectClass;
begin
  result := TFhirCapabilityStatementImplementation;
end;
function TFhirCapabilityStatementImplementationList.IndexOf(value: TFhirCapabilityStatementImplementation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCapabilityStatementImplementationList.Insert(index: Integer): TFhirCapabilityStatementImplementation;
begin
  result := TFhirCapabilityStatementImplementation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementImplementationList.InsertItem(index: Integer; value: TFhirCapabilityStatementImplementation);
begin
  assert(value is TFhirCapabilityStatementImplementation);
  Inherited Insert(index, value);
end;

function TFhirCapabilityStatementImplementationList.Item(index: Integer): TFhirCapabilityStatementImplementation;
begin
  result := TFhirCapabilityStatementImplementation(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementImplementationList.Link: TFhirCapabilityStatementImplementationList;
begin
  result := TFhirCapabilityStatementImplementationList(inherited Link);
end;

procedure TFhirCapabilityStatementImplementationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCapabilityStatementImplementationList.SetItemByIndex(index: Integer; value: TFhirCapabilityStatementImplementation);
begin
  assert(value is TFhirCapabilityStatementImplementation);
  FhirCapabilityStatementImplementations[index] := value;
end;

procedure TFhirCapabilityStatementImplementationList.SetItemN(index: Integer; value: TFhirCapabilityStatementImplementation);
begin
  assert(value is TFhirCapabilityStatementImplementation);
  ObjectByIndex[index] := value;
end;

{ TFhirCapabilityStatementRest }

constructor TFhirCapabilityStatementRest.Create;
begin
  inherited;
end;

destructor TFhirCapabilityStatementRest.Destroy;
begin
  FMode.free;
  FDocumentation.free;
  FSecurity.free;
  FResourceList.Free;
  FInteractionList.Free;
  FSearchParamList.Free;
  FOperationList.Free;
  FCompartmentList.Free;
  inherited;
end;

procedure TFhirCapabilityStatementRest.Assign(oSource : TFslObject);
begin
  inherited;
  FMode := TFhirCapabilityStatementRest(oSource).FMode.Link;
  documentationElement := TFhirCapabilityStatementRest(oSource).documentationElement.Clone;
  security := TFhirCapabilityStatementRest(oSource).security.Clone;
  if (TFhirCapabilityStatementRest(oSource).FResourceList = nil) then
  begin
    FResourceList.free;
    FResourceList := nil;
  end
  else
  begin
    if FResourceList = nil then
      FResourceList := TFhirCapabilityStatementRestResourceList.Create;
    FResourceList.Assign(TFhirCapabilityStatementRest(oSource).FResourceList);
  end;
  if (TFhirCapabilityStatementRest(oSource).FInteractionList = nil) then
  begin
    FInteractionList.free;
    FInteractionList := nil;
  end
  else
  begin
    if FInteractionList = nil then
      FInteractionList := TFhirCapabilityStatementRestInteractionList.Create;
    FInteractionList.Assign(TFhirCapabilityStatementRest(oSource).FInteractionList);
  end;
  if (TFhirCapabilityStatementRest(oSource).FSearchParamList = nil) then
  begin
    FSearchParamList.free;
    FSearchParamList := nil;
  end
  else
  begin
    if FSearchParamList = nil then
      FSearchParamList := TFhirCapabilityStatementRestResourceSearchParamList.Create;
    FSearchParamList.Assign(TFhirCapabilityStatementRest(oSource).FSearchParamList);
  end;
  if (TFhirCapabilityStatementRest(oSource).FOperationList = nil) then
  begin
    FOperationList.free;
    FOperationList := nil;
  end
  else
  begin
    if FOperationList = nil then
      FOperationList := TFhirCapabilityStatementRestOperationList.Create;
    FOperationList.Assign(TFhirCapabilityStatementRest(oSource).FOperationList);
  end;
  if (TFhirCapabilityStatementRest(oSource).FCompartmentList = nil) then
  begin
    FCompartmentList.free;
    FCompartmentList := nil;
  end
  else
  begin
    if FCompartmentList = nil then
      FCompartmentList := TFhirUriList.Create;
    FCompartmentList.Assign(TFhirCapabilityStatementRest(oSource).FCompartmentList);
  end;
end;

procedure TFhirCapabilityStatementRest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'mode') Then
     list.add(self.link, 'mode', FMode.Link);
  if (child_name = 'documentation') Then
     list.add(self.link, 'documentation', FDocumentation.Link);
  if (child_name = 'security') Then
     list.add(self.link, 'security', FSecurity.Link);
  if (child_name = 'resource') Then
    list.addAll(self, 'resource', FResourceList);
  if (child_name = 'interaction') Then
    list.addAll(self, 'interaction', FInteractionList);
  if (child_name = 'searchParam') Then
    list.addAll(self, 'searchParam', FSearchParamList);
  if (child_name = 'operation') Then
    list.addAll(self, 'operation', FOperationList);
  if (child_name = 'compartment') Then
    list.addAll(self, 'compartment', FCompartmentList);
end;

procedure TFhirCapabilityStatementRest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'mode', 'code', false, TFHIREnum, FMode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', false, TFhirString, FDocumentation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'security', '', false, TFhirCapabilityStatementRestSecurity, FSecurity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'resource', '', true, TFhirCapabilityStatementRestResource, FResourceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'interaction', '', true, TFhirCapabilityStatementRestInteraction, FInteractionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'searchParam', '@CapabilityStatement.rest.resource.searchParam', true, TFhirCapabilityStatementRestResourceSearchParam, FSearchParamList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'operation', '', true, TFhirCapabilityStatementRestOperation, FOperationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'compartment', 'uri', true, TFhirUri, FCompartmentList.Link)){3};
end;

function TFhirCapabilityStatementRest.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'mode') then
  begin
    ModeElement := asEnum(SYSTEMS_TFhirRestfulCapabilityModeEnum, CODES_TFhirRestfulCapabilityModeEnum, propValue);
    result := propValue
  end
  else if (propName = 'documentation') then
  begin
    DocumentationElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'security') then
  begin
    Security := propValue as TFhirCapabilityStatementRestSecurity{4b};
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    ResourceList.add(propValue as TFhirCapabilityStatementRestResource){2a};
    result := propValue;
  end
  else if (propName = 'interaction') then
  begin
    InteractionList.add(propValue as TFhirCapabilityStatementRestInteraction){2a};
    result := propValue;
  end
  else if (propName = 'searchParam') then
  begin
    SearchParamList.add(propValue as TFhirCapabilityStatementRestResourceSearchParam){2a};
    result := propValue;
  end
  else if (propName = 'operation') then
  begin
    OperationList.add(propValue as TFhirCapabilityStatementRestOperation){2a};
    result := propValue;
  end
  else if (propName = 'compartment') then
  begin
    CompartmentList.add(asUri(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCapabilityStatementRest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'resource') then ResourceList.insertItem(index, propValue as TFhirCapabilityStatementRestResource){2a}
  else if (propName = 'interaction') then InteractionList.insertItem(index, propValue as TFhirCapabilityStatementRestInteraction){2a}
  else if (propName = 'searchParam') then SearchParamList.insertItem(index, propValue as TFhirCapabilityStatementRestResourceSearchParam){2a}
  else if (propName = 'operation') then OperationList.insertItem(index, propValue as TFhirCapabilityStatementRestOperation){2a}
  else if (propName = 'compartment') then CompartmentList.insertItem(index, asUri(propValue)){2}
  else inherited;
end;

function TFhirCapabilityStatementRest.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'documentation') then result := TFhirString.create() {5b}
  else if (propName = 'security') then result := TFhirCapabilityStatementRestSecurity.create(){4b}
  else if (propName = 'resource') then result := ResourceList.new(){2}
  else if (propName = 'interaction') then result := InteractionList.new(){2}
  else if (propName = 'searchParam') then result := SearchParamList.new(){2}
  else if (propName = 'operation') then result := OperationList.new(){2}
  else if (propName = 'compartment') then result := CompartmentList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCapabilityStatementRest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'mode') then result := 'code'
  else if (propName = 'documentation') then result := 'string'
  else if (propName = 'security') then result := ''
  else if (propName = 'resource') then result := ''
  else if (propName = 'interaction') then result := ''
  else if (propName = 'searchParam') then result := '@CapabilityStatement.rest.resource.searchParam'
  else if (propName = 'operation') then result := ''
  else if (propName = 'compartment') then result := 'uri'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCapabilityStatementRest.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'mode') then ModeElement := nil
  else if (propName = 'documentation') then DocumentationElement := nil
  else if (propName = 'security') then SecurityElement := nil
  else if (propName = 'resource') then deletePropertyValue('resource', ResourceList, value) {2}
  else if (propName = 'interaction') then deletePropertyValue('interaction', InteractionList, value) {2}
  else if (propName = 'searchParam') then deletePropertyValue('searchParam', SearchParamList, value) {2}
  else if (propName = 'operation') then deletePropertyValue('operation', OperationList, value) {2}
  else if (propName = 'compartment') then deletePropertyValue('compartment', CompartmentList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCapabilityStatementRest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'mode') then ModeElement := asEnum(SYSTEMS_TFhirRestfulCapabilityModeEnum, CODES_TFhirRestfulCapabilityModeEnum, new){4}
  else if (propName = 'documentation') then DocumentationElement := asString(new){5b}
  else if (propName = 'security') then SecurityElement := new as TFhirCapabilityStatementRestSecurity{4}
  else if (propName = 'resource') then replacePropertyValue('resource', ResourceList, existing, new) {2}
  else if (propName = 'interaction') then replacePropertyValue('interaction', InteractionList, existing, new) {2}
  else if (propName = 'searchParam') then replacePropertyValue('searchParam', SearchParamList, existing, new) {2}
  else if (propName = 'operation') then replacePropertyValue('operation', OperationList, existing, new) {2}
  else if (propName = 'compartment') then replacePropertyValue('compartment', CompartmentList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCapabilityStatementRest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'resource') then ResourceList.move(source, destination){2a}
  else if (propName = 'interaction') then InteractionList.move(source, destination){2a}
  else if (propName = 'searchParam') then SearchParamList.move(source, destination){2a}
  else if (propName = 'operation') then OperationList.move(source, destination){2a}
  else if (propName = 'compartment') then CompartmentList.move(source, destination){2}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCapabilityStatementRest.fhirType : string;
begin
  result := 'rest';
end;

function TFhirCapabilityStatementRest.Link : TFhirCapabilityStatementRest;
begin
  result := TFhirCapabilityStatementRest(inherited Link);
end;

function TFhirCapabilityStatementRest.Clone : TFhirCapabilityStatementRest;
begin
  result := TFhirCapabilityStatementRest(inherited Clone);
end;

function TFhirCapabilityStatementRest.equals(other : TObject) : boolean;
var
  o : TFhirCapabilityStatementRest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCapabilityStatementRest)) then
    result := false
  else
  begin
    o := TFhirCapabilityStatementRest(other);
    result := compareDeep(modeElement, o.modeElement, true) and compareDeep(documentationElement, o.documentationElement, true) and
      compareDeep(securityElement, o.securityElement, true) and compareDeep(resourceList, o.resourceList, true) and
      compareDeep(interactionList, o.interactionList, true) and compareDeep(searchParamList, o.searchParamList, true) and
      compareDeep(operationList, o.operationList, true) and compareDeep(compartmentList, o.compartmentList, true);
  end;
end;

function TFhirCapabilityStatementRest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMode) and isEmptyProp(FDocumentation) and isEmptyProp(FSecurity) and isEmptyProp(FresourceList) and isEmptyProp(FinteractionList) and isEmptyProp(FsearchParamList) and isEmptyProp(FoperationList) and isEmptyProp(FcompartmentList);
end;

procedure TFhirCapabilityStatementRest.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('mode');
  fields.add('documentation');
  fields.add('security');
  fields.add('resource');
  fields.add('interaction');
  fields.add('searchParam');
  fields.add('operation');
  fields.add('compartment');
end;

{ TFhirCapabilityStatementRest }

Procedure TFhirCapabilityStatementRest.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

Function TFhirCapabilityStatementRest.GetModeST : TFhirRestfulCapabilityModeEnum;
begin
  if FMode = nil then
    result := TFhirRestfulCapabilityModeEnum(0)
  else
    result := TFhirRestfulCapabilityModeEnum(StringArrayIndexOfSensitive(CODES_TFhirRestfulCapabilityModeEnum, FMode.value));
end;

Procedure TFhirCapabilityStatementRest.SetModeST(value : TFhirRestfulCapabilityModeEnum);
begin
  if ord(value) = 0 then
    ModeElement := nil
  else
    ModeElement := TFhirEnum.create(SYSTEMS_TFhirRestfulCapabilityModeEnum[value], CODES_TFhirRestfulCapabilityModeEnum[value]);
end;

Procedure TFhirCapabilityStatementRest.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirCapabilityStatementRest.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

Procedure TFhirCapabilityStatementRest.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

Procedure TFhirCapabilityStatementRest.SetSecurity(value : TFhirCapabilityStatementRestSecurity);
begin
  FSecurity.free;
  FSecurity := value;
end;

Function TFhirCapabilityStatementRest.GetResourceList : TFhirCapabilityStatementRestResourceList;
begin
  if FResourceList = nil then
    FResourceList := TFhirCapabilityStatementRestResourceList.Create;
  result := FResourceList;
end;

Function TFhirCapabilityStatementRest.GetHasResourceList : boolean;
begin
  result := (FResourceList <> nil) and (FResourceList.count > 0);
end;

Function TFhirCapabilityStatementRest.GetInteractionList : TFhirCapabilityStatementRestInteractionList;
begin
  if FInteractionList = nil then
    FInteractionList := TFhirCapabilityStatementRestInteractionList.Create;
  result := FInteractionList;
end;

Function TFhirCapabilityStatementRest.GetHasInteractionList : boolean;
begin
  result := (FInteractionList <> nil) and (FInteractionList.count > 0);
end;

Function TFhirCapabilityStatementRest.GetSearchParamList : TFhirCapabilityStatementRestResourceSearchParamList;
begin
  if FSearchParamList = nil then
    FSearchParamList := TFhirCapabilityStatementRestResourceSearchParamList.Create;
  result := FSearchParamList;
end;

Function TFhirCapabilityStatementRest.GetHasSearchParamList : boolean;
begin
  result := (FSearchParamList <> nil) and (FSearchParamList.count > 0);
end;

Function TFhirCapabilityStatementRest.GetOperationList : TFhirCapabilityStatementRestOperationList;
begin
  if FOperationList = nil then
    FOperationList := TFhirCapabilityStatementRestOperationList.Create;
  result := FOperationList;
end;

Function TFhirCapabilityStatementRest.GetHasOperationList : boolean;
begin
  result := (FOperationList <> nil) and (FOperationList.count > 0);
end;

Function TFhirCapabilityStatementRest.GetCompartmentList : TFhirUriList;
begin
  if FCompartmentList = nil then
    FCompartmentList := TFhirUriList.Create;
  result := FCompartmentList;
end;

Function TFhirCapabilityStatementRest.GetHasCompartmentList : boolean;
begin
  result := (FCompartmentList <> nil) and (FCompartmentList.count > 0);
end;

function TFhirCapabilityStatementRest.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FMode.sizeInBytes);
  inc(result, FDocumentation.sizeInBytes);
  inc(result, FSecurity.sizeInBytes);
  inc(result, FresourceList.sizeInBytes);
  inc(result, FinteractionList.sizeInBytes);
  inc(result, FsearchParamList.sizeInBytes);
  inc(result, FoperationList.sizeInBytes);
  inc(result, FcompartmentList.sizeInBytes);
end;

{ TFhirCapabilityStatementRestListEnumerator }

Constructor TFhirCapabilityStatementRestListEnumerator.Create(list : TFhirCapabilityStatementRestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCapabilityStatementRestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCapabilityStatementRestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCapabilityStatementRestListEnumerator.GetCurrent : TFhirCapabilityStatementRest;
begin
  Result := FList[FIndex];
end;

function TFhirCapabilityStatementRestListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCapabilityStatementRestList }
procedure TFhirCapabilityStatementRestList.AddItem(value: TFhirCapabilityStatementRest);
begin
  assert(value.ClassName = 'TFhirCapabilityStatementRest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCapabilityStatementRest');
  add(value);
end;

function TFhirCapabilityStatementRestList.Append: TFhirCapabilityStatementRest;
begin
  result := TFhirCapabilityStatementRest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementRestList.ClearItems;
begin
  Clear;
end;

function TFhirCapabilityStatementRestList.GetEnumerator : TFhirCapabilityStatementRestListEnumerator;
begin
  result := TFhirCapabilityStatementRestListEnumerator.Create(self.link);
end;

function TFhirCapabilityStatementRestList.Clone: TFhirCapabilityStatementRestList;
begin
  result := TFhirCapabilityStatementRestList(inherited Clone);
end;

function TFhirCapabilityStatementRestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCapabilityStatementRestList.GetItemN(index: Integer): TFhirCapabilityStatementRest;
begin
  result := TFhirCapabilityStatementRest(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementRestList.ItemClass: TFslObjectClass;
begin
  result := TFhirCapabilityStatementRest;
end;
function TFhirCapabilityStatementRestList.IndexOf(value: TFhirCapabilityStatementRest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCapabilityStatementRestList.Insert(index: Integer): TFhirCapabilityStatementRest;
begin
  result := TFhirCapabilityStatementRest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementRestList.InsertItem(index: Integer; value: TFhirCapabilityStatementRest);
begin
  assert(value is TFhirCapabilityStatementRest);
  Inherited Insert(index, value);
end;

function TFhirCapabilityStatementRestList.Item(index: Integer): TFhirCapabilityStatementRest;
begin
  result := TFhirCapabilityStatementRest(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementRestList.Link: TFhirCapabilityStatementRestList;
begin
  result := TFhirCapabilityStatementRestList(inherited Link);
end;

procedure TFhirCapabilityStatementRestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCapabilityStatementRestList.SetItemByIndex(index: Integer; value: TFhirCapabilityStatementRest);
begin
  assert(value is TFhirCapabilityStatementRest);
  FhirCapabilityStatementRests[index] := value;
end;

procedure TFhirCapabilityStatementRestList.SetItemN(index: Integer; value: TFhirCapabilityStatementRest);
begin
  assert(value is TFhirCapabilityStatementRest);
  ObjectByIndex[index] := value;
end;

{ TFhirCapabilityStatementRestSecurity }

constructor TFhirCapabilityStatementRestSecurity.Create;
begin
  inherited;
end;

destructor TFhirCapabilityStatementRestSecurity.Destroy;
begin
  FCors.free;
  FServiceList.Free;
  FDescription.free;
  FCertificateList.Free;
  inherited;
end;

procedure TFhirCapabilityStatementRestSecurity.Assign(oSource : TFslObject);
begin
  inherited;
  corsElement := TFhirCapabilityStatementRestSecurity(oSource).corsElement.Clone;
  if (TFhirCapabilityStatementRestSecurity(oSource).FServiceList = nil) then
  begin
    FServiceList.free;
    FServiceList := nil;
  end
  else
  begin
    if FServiceList = nil then
      FServiceList := TFhirCodeableConceptList.Create;
    FServiceList.Assign(TFhirCapabilityStatementRestSecurity(oSource).FServiceList);
  end;
  descriptionElement := TFhirCapabilityStatementRestSecurity(oSource).descriptionElement.Clone;
  if (TFhirCapabilityStatementRestSecurity(oSource).FCertificateList = nil) then
  begin
    FCertificateList.free;
    FCertificateList := nil;
  end
  else
  begin
    if FCertificateList = nil then
      FCertificateList := TFhirCapabilityStatementRestSecurityCertificateList.Create;
    FCertificateList.Assign(TFhirCapabilityStatementRestSecurity(oSource).FCertificateList);
  end;
end;

procedure TFhirCapabilityStatementRestSecurity.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'cors') Then
     list.add(self.link, 'cors', FCors.Link);
  if (child_name = 'service') Then
    list.addAll(self, 'service', FServiceList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'certificate') Then
    list.addAll(self, 'certificate', FCertificateList);
end;

procedure TFhirCapabilityStatementRestSecurity.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'cors', 'boolean', false, TFhirBoolean, FCors.Link));{2}
  oList.add(TFHIRProperty.create(self, 'service', 'CodeableConcept', true, TFhirCodeableConcept, FServiceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'certificate', '', true, TFhirCapabilityStatementRestSecurityCertificate, FCertificateList.Link)){3};
end;

function TFhirCapabilityStatementRestSecurity.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'cors') then
  begin
    CorsElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'service') then
  begin
    ServiceList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'certificate') then
  begin
    CertificateList.add(propValue as TFhirCapabilityStatementRestSecurityCertificate){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCapabilityStatementRestSecurity.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'service') then ServiceList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'certificate') then CertificateList.insertItem(index, propValue as TFhirCapabilityStatementRestSecurityCertificate){2a}
  else inherited;
end;

function TFhirCapabilityStatementRestSecurity.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'cors') then result := TFhirBoolean.create() {5b}
  else if (propName = 'service') then result := ServiceList.new(){2}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'certificate') then result := CertificateList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCapabilityStatementRestSecurity.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'cors') then result := 'boolean'
  else if (propName = 'service') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'certificate') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCapabilityStatementRestSecurity.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'cors') then CorsElement := nil
  else if (propName = 'service') then deletePropertyValue('service', ServiceList, value) {2}
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'certificate') then deletePropertyValue('certificate', CertificateList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCapabilityStatementRestSecurity.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'cors') then CorsElement := asBoolean(new){5b}
  else if (propName = 'service') then replacePropertyValue('service', ServiceList, existing, new) {2}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'certificate') then replacePropertyValue('certificate', CertificateList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCapabilityStatementRestSecurity.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'service') then ServiceList.move(source, destination){2a}
  else if (propName = 'certificate') then CertificateList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCapabilityStatementRestSecurity.fhirType : string;
begin
  result := 'security';
end;

function TFhirCapabilityStatementRestSecurity.Link : TFhirCapabilityStatementRestSecurity;
begin
  result := TFhirCapabilityStatementRestSecurity(inherited Link);
end;

function TFhirCapabilityStatementRestSecurity.Clone : TFhirCapabilityStatementRestSecurity;
begin
  result := TFhirCapabilityStatementRestSecurity(inherited Clone);
end;

function TFhirCapabilityStatementRestSecurity.equals(other : TObject) : boolean;
var
  o : TFhirCapabilityStatementRestSecurity;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCapabilityStatementRestSecurity)) then
    result := false
  else
  begin
    o := TFhirCapabilityStatementRestSecurity(other);
    result := compareDeep(corsElement, o.corsElement, true) and compareDeep(serviceList, o.serviceList, true) and
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(certificateList, o.certificateList, true);
  end;
end;

function TFhirCapabilityStatementRestSecurity.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCors) and isEmptyProp(FserviceList) and isEmptyProp(FDescription) and isEmptyProp(FcertificateList);
end;

procedure TFhirCapabilityStatementRestSecurity.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('cors');
  fields.add('service');
  fields.add('description');
  fields.add('certificate');
end;

{ TFhirCapabilityStatementRestSecurity }

Procedure TFhirCapabilityStatementRestSecurity.SetCors(value : TFhirBoolean);
begin
  FCors.free;
  FCors := value;
end;

Function TFhirCapabilityStatementRestSecurity.GetCorsST : Boolean;
begin
  if FCors = nil then
    result := false
  else
    result := FCors.value;
end;

Procedure TFhirCapabilityStatementRestSecurity.SetCorsST(value : Boolean);
begin
  if FCors = nil then
    FCors := TFhirBoolean.create;
  FCors.value := value
end;

Function TFhirCapabilityStatementRestSecurity.GetServiceList : TFhirCodeableConceptList;
begin
  if FServiceList = nil then
    FServiceList := TFhirCodeableConceptList.Create;
  result := FServiceList;
end;

Function TFhirCapabilityStatementRestSecurity.GetHasServiceList : boolean;
begin
  result := (FServiceList <> nil) and (FServiceList.count > 0);
end;

Procedure TFhirCapabilityStatementRestSecurity.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirCapabilityStatementRestSecurity.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirCapabilityStatementRestSecurity.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Function TFhirCapabilityStatementRestSecurity.GetCertificateList : TFhirCapabilityStatementRestSecurityCertificateList;
begin
  if FCertificateList = nil then
    FCertificateList := TFhirCapabilityStatementRestSecurityCertificateList.Create;
  result := FCertificateList;
end;

Function TFhirCapabilityStatementRestSecurity.GetHasCertificateList : boolean;
begin
  result := (FCertificateList <> nil) and (FCertificateList.count > 0);
end;

function TFhirCapabilityStatementRestSecurity.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCors.sizeInBytes);
  inc(result, FserviceList.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FcertificateList.sizeInBytes);
end;

{ TFhirCapabilityStatementRestSecurityListEnumerator }

Constructor TFhirCapabilityStatementRestSecurityListEnumerator.Create(list : TFhirCapabilityStatementRestSecurityList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCapabilityStatementRestSecurityListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCapabilityStatementRestSecurityListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCapabilityStatementRestSecurityListEnumerator.GetCurrent : TFhirCapabilityStatementRestSecurity;
begin
  Result := FList[FIndex];
end;

function TFhirCapabilityStatementRestSecurityListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCapabilityStatementRestSecurityList }
procedure TFhirCapabilityStatementRestSecurityList.AddItem(value: TFhirCapabilityStatementRestSecurity);
begin
  assert(value.ClassName = 'TFhirCapabilityStatementRestSecurity', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCapabilityStatementRestSecurity');
  add(value);
end;

function TFhirCapabilityStatementRestSecurityList.Append: TFhirCapabilityStatementRestSecurity;
begin
  result := TFhirCapabilityStatementRestSecurity.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementRestSecurityList.ClearItems;
begin
  Clear;
end;

function TFhirCapabilityStatementRestSecurityList.GetEnumerator : TFhirCapabilityStatementRestSecurityListEnumerator;
begin
  result := TFhirCapabilityStatementRestSecurityListEnumerator.Create(self.link);
end;

function TFhirCapabilityStatementRestSecurityList.Clone: TFhirCapabilityStatementRestSecurityList;
begin
  result := TFhirCapabilityStatementRestSecurityList(inherited Clone);
end;

function TFhirCapabilityStatementRestSecurityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCapabilityStatementRestSecurityList.GetItemN(index: Integer): TFhirCapabilityStatementRestSecurity;
begin
  result := TFhirCapabilityStatementRestSecurity(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementRestSecurityList.ItemClass: TFslObjectClass;
begin
  result := TFhirCapabilityStatementRestSecurity;
end;
function TFhirCapabilityStatementRestSecurityList.IndexOf(value: TFhirCapabilityStatementRestSecurity): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCapabilityStatementRestSecurityList.Insert(index: Integer): TFhirCapabilityStatementRestSecurity;
begin
  result := TFhirCapabilityStatementRestSecurity.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementRestSecurityList.InsertItem(index: Integer; value: TFhirCapabilityStatementRestSecurity);
begin
  assert(value is TFhirCapabilityStatementRestSecurity);
  Inherited Insert(index, value);
end;

function TFhirCapabilityStatementRestSecurityList.Item(index: Integer): TFhirCapabilityStatementRestSecurity;
begin
  result := TFhirCapabilityStatementRestSecurity(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementRestSecurityList.Link: TFhirCapabilityStatementRestSecurityList;
begin
  result := TFhirCapabilityStatementRestSecurityList(inherited Link);
end;

procedure TFhirCapabilityStatementRestSecurityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCapabilityStatementRestSecurityList.SetItemByIndex(index: Integer; value: TFhirCapabilityStatementRestSecurity);
begin
  assert(value is TFhirCapabilityStatementRestSecurity);
  FhirCapabilityStatementRestSecurities[index] := value;
end;

procedure TFhirCapabilityStatementRestSecurityList.SetItemN(index: Integer; value: TFhirCapabilityStatementRestSecurity);
begin
  assert(value is TFhirCapabilityStatementRestSecurity);
  ObjectByIndex[index] := value;
end;

{ TFhirCapabilityStatementRestSecurityCertificate }

constructor TFhirCapabilityStatementRestSecurityCertificate.Create;
begin
  inherited;
end;

destructor TFhirCapabilityStatementRestSecurityCertificate.Destroy;
begin
  FType_.free;
  FBlob.free;
  inherited;
end;

procedure TFhirCapabilityStatementRestSecurityCertificate.Assign(oSource : TFslObject);
begin
  inherited;
  type_Element := TFhirCapabilityStatementRestSecurityCertificate(oSource).type_Element.Clone;
  blobElement := TFhirCapabilityStatementRestSecurityCertificate(oSource).blobElement.Clone;
end;

procedure TFhirCapabilityStatementRestSecurityCertificate.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'blob') Then
     list.add(self.link, 'blob', FBlob.Link);
end;

procedure TFhirCapabilityStatementRestSecurityCertificate.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirCode, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'blob', 'base64Binary', false, TFhirBase64Binary, FBlob.Link));{2}
end;

function TFhirCapabilityStatementRestSecurityCertificate.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'blob') then
  begin
    BlobElement := asBase64Binary(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCapabilityStatementRestSecurityCertificate.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCapabilityStatementRestSecurityCertificate.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCode.create() {5b}
  else if (propName = 'blob') then result := TFhirBase64Binary.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCapabilityStatementRestSecurityCertificate.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'blob') then result := 'base64Binary'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCapabilityStatementRestSecurityCertificate.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'blob') then BlobElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCapabilityStatementRestSecurityCertificate.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asCode(new){5b}
  else if (propName = 'blob') then BlobElement := asBase64Binary(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCapabilityStatementRestSecurityCertificate.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCapabilityStatementRestSecurityCertificate.fhirType : string;
begin
  result := 'certificate';
end;

function TFhirCapabilityStatementRestSecurityCertificate.Link : TFhirCapabilityStatementRestSecurityCertificate;
begin
  result := TFhirCapabilityStatementRestSecurityCertificate(inherited Link);
end;

function TFhirCapabilityStatementRestSecurityCertificate.Clone : TFhirCapabilityStatementRestSecurityCertificate;
begin
  result := TFhirCapabilityStatementRestSecurityCertificate(inherited Clone);
end;

function TFhirCapabilityStatementRestSecurityCertificate.equals(other : TObject) : boolean;
var
  o : TFhirCapabilityStatementRestSecurityCertificate;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCapabilityStatementRestSecurityCertificate)) then
    result := false
  else
  begin
    o := TFhirCapabilityStatementRestSecurityCertificate(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(blobElement, o.blobElement, true);
  end;
end;

function TFhirCapabilityStatementRestSecurityCertificate.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FBlob);
end;

procedure TFhirCapabilityStatementRestSecurityCertificate.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('blob');
end;

{ TFhirCapabilityStatementRestSecurityCertificate }

Procedure TFhirCapabilityStatementRestSecurityCertificate.SetType_(value : TFhirCode);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirCapabilityStatementRestSecurityCertificate.GetType_ST : String;
begin
  if FType_ = nil then
    result := ''
  else
    result := FType_.value;
end;

Procedure TFhirCapabilityStatementRestSecurityCertificate.SetType_ST(value : String);
begin
  if value <> '' then
  begin
    if FType_ = nil then
      FType_ := TFhirCode.create;
    FType_.value := value
  end
  else if FType_ <> nil then
    FType_.value := '';
end;

Procedure TFhirCapabilityStatementRestSecurityCertificate.SetBlob(value : TFhirBase64Binary);
begin
  FBlob.free;
  FBlob := value;
end;

Function TFhirCapabilityStatementRestSecurityCertificate.GetBlobST : TBytes;
begin
  if FBlob = nil then
    result := nil
  else
    result := FBlob.value;
end;

Procedure TFhirCapabilityStatementRestSecurityCertificate.SetBlobST(value : TBytes);
begin
  if value <> nil then
  begin
    if FBlob = nil then
      FBlob := TFhirBase64Binary.create;
    FBlob.value := value
  end
  else if FBlob <> nil then
    FBlob.value := nil;
end;

function TFhirCapabilityStatementRestSecurityCertificate.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FBlob.sizeInBytes);
end;

{ TFhirCapabilityStatementRestSecurityCertificateListEnumerator }

Constructor TFhirCapabilityStatementRestSecurityCertificateListEnumerator.Create(list : TFhirCapabilityStatementRestSecurityCertificateList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCapabilityStatementRestSecurityCertificateListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCapabilityStatementRestSecurityCertificateListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCapabilityStatementRestSecurityCertificateListEnumerator.GetCurrent : TFhirCapabilityStatementRestSecurityCertificate;
begin
  Result := FList[FIndex];
end;

function TFhirCapabilityStatementRestSecurityCertificateListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCapabilityStatementRestSecurityCertificateList }
procedure TFhirCapabilityStatementRestSecurityCertificateList.AddItem(value: TFhirCapabilityStatementRestSecurityCertificate);
begin
  assert(value.ClassName = 'TFhirCapabilityStatementRestSecurityCertificate', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCapabilityStatementRestSecurityCertificate');
  add(value);
end;

function TFhirCapabilityStatementRestSecurityCertificateList.Append: TFhirCapabilityStatementRestSecurityCertificate;
begin
  result := TFhirCapabilityStatementRestSecurityCertificate.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementRestSecurityCertificateList.ClearItems;
begin
  Clear;
end;

function TFhirCapabilityStatementRestSecurityCertificateList.GetEnumerator : TFhirCapabilityStatementRestSecurityCertificateListEnumerator;
begin
  result := TFhirCapabilityStatementRestSecurityCertificateListEnumerator.Create(self.link);
end;

function TFhirCapabilityStatementRestSecurityCertificateList.Clone: TFhirCapabilityStatementRestSecurityCertificateList;
begin
  result := TFhirCapabilityStatementRestSecurityCertificateList(inherited Clone);
end;

function TFhirCapabilityStatementRestSecurityCertificateList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCapabilityStatementRestSecurityCertificateList.GetItemN(index: Integer): TFhirCapabilityStatementRestSecurityCertificate;
begin
  result := TFhirCapabilityStatementRestSecurityCertificate(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementRestSecurityCertificateList.ItemClass: TFslObjectClass;
begin
  result := TFhirCapabilityStatementRestSecurityCertificate;
end;
function TFhirCapabilityStatementRestSecurityCertificateList.IndexOf(value: TFhirCapabilityStatementRestSecurityCertificate): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCapabilityStatementRestSecurityCertificateList.Insert(index: Integer): TFhirCapabilityStatementRestSecurityCertificate;
begin
  result := TFhirCapabilityStatementRestSecurityCertificate.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementRestSecurityCertificateList.InsertItem(index: Integer; value: TFhirCapabilityStatementRestSecurityCertificate);
begin
  assert(value is TFhirCapabilityStatementRestSecurityCertificate);
  Inherited Insert(index, value);
end;

function TFhirCapabilityStatementRestSecurityCertificateList.Item(index: Integer): TFhirCapabilityStatementRestSecurityCertificate;
begin
  result := TFhirCapabilityStatementRestSecurityCertificate(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementRestSecurityCertificateList.Link: TFhirCapabilityStatementRestSecurityCertificateList;
begin
  result := TFhirCapabilityStatementRestSecurityCertificateList(inherited Link);
end;

procedure TFhirCapabilityStatementRestSecurityCertificateList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCapabilityStatementRestSecurityCertificateList.SetItemByIndex(index: Integer; value: TFhirCapabilityStatementRestSecurityCertificate);
begin
  assert(value is TFhirCapabilityStatementRestSecurityCertificate);
  FhirCapabilityStatementRestSecurityCertificates[index] := value;
end;

procedure TFhirCapabilityStatementRestSecurityCertificateList.SetItemN(index: Integer; value: TFhirCapabilityStatementRestSecurityCertificate);
begin
  assert(value is TFhirCapabilityStatementRestSecurityCertificate);
  ObjectByIndex[index] := value;
end;

{ TFhirCapabilityStatementRestResource }

constructor TFhirCapabilityStatementRestResource.Create;
begin
  inherited;
end;

destructor TFhirCapabilityStatementRestResource.Destroy;
begin
  FType_.free;
  FProfile.free;
  FDocumentation.free;
  FInteractionList.Free;
  FVersioning.free;
  FReadHistory.free;
  FUpdateCreate.free;
  FConditionalCreate.free;
  FConditionalRead.free;
  FConditionalUpdate.free;
  FConditionalDelete.free;
  FReferencePolicy.Free;
  FSearchIncludeList.Free;
  FSearchRevIncludeList.Free;
  FSearchParamList.Free;
  inherited;
end;

procedure TFhirCapabilityStatementRestResource.Assign(oSource : TFslObject);
begin
  inherited;
  FType_ := TFhirCapabilityStatementRestResource(oSource).FType_.Link;
  profile := TFhirCapabilityStatementRestResource(oSource).profile.Clone;
  documentationElement := TFhirCapabilityStatementRestResource(oSource).documentationElement.Clone;
  if (TFhirCapabilityStatementRestResource(oSource).FInteractionList = nil) then
  begin
    FInteractionList.free;
    FInteractionList := nil;
  end
  else
  begin
    if FInteractionList = nil then
      FInteractionList := TFhirCapabilityStatementRestResourceInteractionList.Create;
    FInteractionList.Assign(TFhirCapabilityStatementRestResource(oSource).FInteractionList);
  end;
  FVersioning := TFhirCapabilityStatementRestResource(oSource).FVersioning.Link;
  readHistoryElement := TFhirCapabilityStatementRestResource(oSource).readHistoryElement.Clone;
  updateCreateElement := TFhirCapabilityStatementRestResource(oSource).updateCreateElement.Clone;
  conditionalCreateElement := TFhirCapabilityStatementRestResource(oSource).conditionalCreateElement.Clone;
  FConditionalRead := TFhirCapabilityStatementRestResource(oSource).FConditionalRead.Link;
  conditionalUpdateElement := TFhirCapabilityStatementRestResource(oSource).conditionalUpdateElement.Clone;
  FConditionalDelete := TFhirCapabilityStatementRestResource(oSource).FConditionalDelete.Link;
  if (TFhirCapabilityStatementRestResource(oSource).FReferencePolicy = nil) then
  begin
    FReferencePolicy.free;
    FReferencePolicy := nil;
  end
  else
  begin
    FReferencePolicy := TFHIREnumList.Create(SYSTEMS_TFhirReferenceHandlingPolicyEnum, CODES_TFhirReferenceHandlingPolicyEnum);
    FReferencePolicy.Assign(TFhirCapabilityStatementRestResource(oSource).FReferencePolicy);
  end;
  if (TFhirCapabilityStatementRestResource(oSource).FSearchIncludeList = nil) then
  begin
    FSearchIncludeList.free;
    FSearchIncludeList := nil;
  end
  else
  begin
    if FSearchIncludeList = nil then
      FSearchIncludeList := TFhirStringList.Create;
    FSearchIncludeList.Assign(TFhirCapabilityStatementRestResource(oSource).FSearchIncludeList);
  end;
  if (TFhirCapabilityStatementRestResource(oSource).FSearchRevIncludeList = nil) then
  begin
    FSearchRevIncludeList.free;
    FSearchRevIncludeList := nil;
  end
  else
  begin
    if FSearchRevIncludeList = nil then
      FSearchRevIncludeList := TFhirStringList.Create;
    FSearchRevIncludeList.Assign(TFhirCapabilityStatementRestResource(oSource).FSearchRevIncludeList);
  end;
  if (TFhirCapabilityStatementRestResource(oSource).FSearchParamList = nil) then
  begin
    FSearchParamList.free;
    FSearchParamList := nil;
  end
  else
  begin
    if FSearchParamList = nil then
      FSearchParamList := TFhirCapabilityStatementRestResourceSearchParamList.Create;
    FSearchParamList.Assign(TFhirCapabilityStatementRestResource(oSource).FSearchParamList);
  end;
end;

procedure TFhirCapabilityStatementRestResource.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'profile') Then
     list.add(self.link, 'profile', FProfile.Link);
  if (child_name = 'documentation') Then
     list.add(self.link, 'documentation', FDocumentation.Link);
  if (child_name = 'interaction') Then
    list.addAll(self, 'interaction', FInteractionList);
  if (child_name = 'versioning') Then
     list.add(self.link, 'versioning', FVersioning.Link);
  if (child_name = 'readHistory') Then
     list.add(self.link, 'readHistory', FReadHistory.Link);
  if (child_name = 'updateCreate') Then
     list.add(self.link, 'updateCreate', FUpdateCreate.Link);
  if (child_name = 'conditionalCreate') Then
     list.add(self.link, 'conditionalCreate', FConditionalCreate.Link);
  if (child_name = 'conditionalRead') Then
     list.add(self.link, 'conditionalRead', FConditionalRead.Link);
  if (child_name = 'conditionalUpdate') Then
     list.add(self.link, 'conditionalUpdate', FConditionalUpdate.Link);
  if (child_name = 'conditionalDelete') Then
     list.add(self.link, 'conditionalDelete', FConditionalDelete.Link);
  if (child_name = 'referencePolicy') Then
     list.addAll(self, 'referencePolicy', FReferencePolicy);
  if (child_name = 'searchInclude') Then
    list.addAll(self, 'searchInclude', FSearchIncludeList);
  if (child_name = 'searchRevInclude') Then
    list.addAll(self, 'searchRevInclude', FSearchRevIncludeList);
  if (child_name = 'searchParam') Then
    list.addAll(self, 'searchParam', FSearchParamList);
end;

procedure TFhirCapabilityStatementRestResource.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'profile', 'Reference(StructureDefinition)', false, TFhirReference{TFhirStructureDefinition}, FProfile.Link));{2}
  oList.add(TFHIRProperty.create(self, 'documentation', 'markdown', false, TFhirMarkdown, FDocumentation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'interaction', '', true, TFhirCapabilityStatementRestResourceInteraction, FInteractionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'versioning', 'code', false, TFHIREnum, FVersioning.Link));{1}
  oList.add(TFHIRProperty.create(self, 'readHistory', 'boolean', false, TFhirBoolean, FReadHistory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'updateCreate', 'boolean', false, TFhirBoolean, FUpdateCreate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'conditionalCreate', 'boolean', false, TFhirBoolean, FConditionalCreate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'conditionalRead', 'code', false, TFHIREnum, FConditionalRead.Link));{1}
  oList.add(TFHIRProperty.create(self, 'conditionalUpdate', 'boolean', false, TFhirBoolean, FConditionalUpdate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'conditionalDelete', 'code', false, TFHIREnum, FConditionalDelete.Link));{1}
  oList.add(TFHIRProperty.create(self, 'referencePolicy', 'code', true, TFHIREnum, FReferencePolicy.Link)){3};
  oList.add(TFHIRProperty.create(self, 'searchInclude', 'string', true, TFhirString, FSearchIncludeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'searchRevInclude', 'string', true, TFhirString, FSearchRevIncludeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'searchParam', '', true, TFhirCapabilityStatementRestResourceSearchParam, FSearchParamList.Link)){3};
end;

function TFhirCapabilityStatementRestResource.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue);
    result := propValue
  end
  else if (propName = 'profile') then
  begin
    Profile := propValue as TFhirReference{TFhirStructureDefinition}{4b};
    result := propValue;
  end
  else if (propName = 'documentation') then
  begin
    DocumentationElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'interaction') then
  begin
    InteractionList.add(propValue as TFhirCapabilityStatementRestResourceInteraction){2a};
    result := propValue;
  end
  else if (propName = 'versioning') then
  begin
    VersioningElement := asEnum(SYSTEMS_TFhirVersioningPolicyEnum, CODES_TFhirVersioningPolicyEnum, propValue);
    result := propValue
  end
  else if (propName = 'readHistory') then
  begin
    ReadHistoryElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'updateCreate') then
  begin
    UpdateCreateElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'conditionalCreate') then
  begin
    ConditionalCreateElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'conditionalRead') then
  begin
    ConditionalReadElement := asEnum(SYSTEMS_TFhirConditionalReadStatusEnum, CODES_TFhirConditionalReadStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'conditionalUpdate') then
  begin
    ConditionalUpdateElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'conditionalDelete') then
  begin
    ConditionalDeleteElement := asEnum(SYSTEMS_TFhirConditionalDeleteStatusEnum, CODES_TFhirConditionalDeleteStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'referencePolicy') then
  begin
    ReferencePolicyList.add(asEnum(SYSTEMS_TFhirReferenceHandlingPolicyEnum, CODES_TFhirReferenceHandlingPolicyEnum, propValue)); {1}
    result := propValue;
  end
  else if (propName = 'searchInclude') then
  begin
    SearchIncludeList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'searchRevInclude') then
  begin
    SearchRevIncludeList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'searchParam') then
  begin
    SearchParamList.add(propValue as TFhirCapabilityStatementRestResourceSearchParam){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCapabilityStatementRestResource.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'interaction') then InteractionList.insertItem(index, propValue as TFhirCapabilityStatementRestResourceInteraction){2a}
  else if (propName = 'referencePolicy') then FReferencePolicy.insertItem(index, asEnum(SYSTEMS_TFhirReferenceHandlingPolicyEnum, CODES_TFhirReferenceHandlingPolicyEnum, propValue)) {1}
  else if (propName = 'searchInclude') then SearchIncludeList.insertItem(index, asString(propValue)){2}
  else if (propName = 'searchRevInclude') then SearchRevIncludeList.insertItem(index, asString(propValue)){2}
  else if (propName = 'searchParam') then SearchParamList.insertItem(index, propValue as TFhirCapabilityStatementRestResourceSearchParam){2a}
  else inherited;
end;

function TFhirCapabilityStatementRestResource.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'profile') then result := TFhirReference{TFhirStructureDefinition}.create(){4b}
  else if (propName = 'documentation') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'interaction') then result := InteractionList.new(){2}
  else if (propName = 'readHistory') then result := TFhirBoolean.create() {5b}
  else if (propName = 'updateCreate') then result := TFhirBoolean.create() {5b}
  else if (propName = 'conditionalCreate') then result := TFhirBoolean.create() {5b}
  else if (propName = 'conditionalUpdate') then result := TFhirBoolean.create() {5b}
  else if (propName = 'searchInclude') then result := SearchIncludeList.new(){2}
  else if (propName = 'searchRevInclude') then result := SearchRevIncludeList.new(){2}
  else if (propName = 'searchParam') then result := SearchParamList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCapabilityStatementRestResource.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'profile') then result := 'Reference'
  else if (propName = 'documentation') then result := 'markdown'
  else if (propName = 'interaction') then result := ''
  else if (propName = 'versioning') then result := 'code'
  else if (propName = 'readHistory') then result := 'boolean'
  else if (propName = 'updateCreate') then result := 'boolean'
  else if (propName = 'conditionalCreate') then result := 'boolean'
  else if (propName = 'conditionalRead') then result := 'code'
  else if (propName = 'conditionalUpdate') then result := 'boolean'
  else if (propName = 'conditionalDelete') then result := 'code'
  else if (propName = 'referencePolicy') then result := 'code'
  else if (propName = 'searchInclude') then result := 'string'
  else if (propName = 'searchRevInclude') then result := 'string'
  else if (propName = 'searchParam') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCapabilityStatementRestResource.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'profile') then ProfileElement := nil
  else if (propName = 'documentation') then DocumentationElement := nil
  else if (propName = 'interaction') then deletePropertyValue('interaction', InteractionList, value) {2}
  else if (propName = 'versioning') then VersioningElement := nil
  else if (propName = 'readHistory') then ReadHistoryElement := nil
  else if (propName = 'updateCreate') then UpdateCreateElement := nil
  else if (propName = 'conditionalCreate') then ConditionalCreateElement := nil
  else if (propName = 'conditionalRead') then ConditionalReadElement := nil
  else if (propName = 'conditionalUpdate') then ConditionalUpdateElement := nil
  else if (propName = 'conditionalDelete') then ConditionalDeleteElement := nil
  else if (propName = 'searchInclude') then deletePropertyValue('searchInclude', SearchIncludeList, value) {2}
  else if (propName = 'searchRevInclude') then deletePropertyValue('searchRevInclude', SearchRevIncludeList, value) {2}
  else if (propName = 'searchParam') then deletePropertyValue('searchParam', SearchParamList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCapabilityStatementRestResource.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, new){4}
  else if (propName = 'profile') then ProfileElement := new as TFhirReference{TFhirStructureDefinition}{4}
  else if (propName = 'documentation') then DocumentationElement := asMarkdown(new){5b}
  else if (propName = 'interaction') then replacePropertyValue('interaction', InteractionList, existing, new) {2}
  else if (propName = 'versioning') then VersioningElement := asEnum(SYSTEMS_TFhirVersioningPolicyEnum, CODES_TFhirVersioningPolicyEnum, new){4}
  else if (propName = 'readHistory') then ReadHistoryElement := asBoolean(new){5b}
  else if (propName = 'updateCreate') then UpdateCreateElement := asBoolean(new){5b}
  else if (propName = 'conditionalCreate') then ConditionalCreateElement := asBoolean(new){5b}
  else if (propName = 'conditionalRead') then ConditionalReadElement := asEnum(SYSTEMS_TFhirConditionalReadStatusEnum, CODES_TFhirConditionalReadStatusEnum, new){4}
  else if (propName = 'conditionalUpdate') then ConditionalUpdateElement := asBoolean(new){5b}
  else if (propName = 'conditionalDelete') then ConditionalDeleteElement := asEnum(SYSTEMS_TFhirConditionalDeleteStatusEnum, CODES_TFhirConditionalDeleteStatusEnum, new){4}
  else if (propName = 'searchInclude') then replacePropertyValue('searchInclude', SearchIncludeList, existing, new) {2}
  else if (propName = 'searchRevInclude') then replacePropertyValue('searchRevInclude', SearchRevIncludeList, existing, new) {2}
  else if (propName = 'searchParam') then replacePropertyValue('searchParam', SearchParamList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCapabilityStatementRestResource.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'interaction') then InteractionList.move(source, destination){2a}
  else if (propName = 'referencePolicy') then FReferencePolicy.move(source, destination) {1}
  else if (propName = 'searchInclude') then SearchIncludeList.move(source, destination){2}
  else if (propName = 'searchRevInclude') then SearchRevIncludeList.move(source, destination){2}
  else if (propName = 'searchParam') then SearchParamList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCapabilityStatementRestResource.fhirType : string;
begin
  result := 'resource';
end;

function TFhirCapabilityStatementRestResource.Link : TFhirCapabilityStatementRestResource;
begin
  result := TFhirCapabilityStatementRestResource(inherited Link);
end;

function TFhirCapabilityStatementRestResource.Clone : TFhirCapabilityStatementRestResource;
begin
  result := TFhirCapabilityStatementRestResource(inherited Clone);
end;

function TFhirCapabilityStatementRestResource.equals(other : TObject) : boolean;
var
  o : TFhirCapabilityStatementRestResource;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCapabilityStatementRestResource)) then
    result := false
  else
  begin
    o := TFhirCapabilityStatementRestResource(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(profileElement, o.profileElement, true) and
      compareDeep(documentationElement, o.documentationElement, true) and compareDeep(interactionList, o.interactionList, true) and
      compareDeep(versioningElement, o.versioningElement, true) and compareDeep(readHistoryElement, o.readHistoryElement, true) and
      compareDeep(updateCreateElement, o.updateCreateElement, true) and compareDeep(conditionalCreateElement, o.conditionalCreateElement, true) and
      compareDeep(conditionalReadElement, o.conditionalReadElement, true) and compareDeep(conditionalUpdateElement, o.conditionalUpdateElement, true) and
      compareDeep(conditionalDeleteElement, o.conditionalDeleteElement, true) and compareDeep(referencePolicyList, o.referencePolicyList, true) and
      compareDeep(searchIncludeList, o.searchIncludeList, true) and compareDeep(searchRevIncludeList, o.searchRevIncludeList, true) and
      compareDeep(searchParamList, o.searchParamList, true);
  end;
end;

function TFhirCapabilityStatementRestResource.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FProfile) and isEmptyProp(FDocumentation) and isEmptyProp(FinteractionList) and isEmptyProp(FVersioning) and isEmptyProp(FReadHistory) and isEmptyProp(FUpdateCreate) and isEmptyProp(FConditionalCreate) and isEmptyProp(FConditionalRead) and isEmptyProp(FConditionalUpdate) and isEmptyProp(FConditionalDelete) and isEmptyProp(FReferencePolicy) and isEmptyProp(FsearchIncludeList) and isEmptyProp(FsearchRevIncludeList) and isEmptyProp(FsearchParamList);
end;

procedure TFhirCapabilityStatementRestResource.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('profile');
  fields.add('documentation');
  fields.add('interaction');
  fields.add('versioning');
  fields.add('readHistory');
  fields.add('updateCreate');
  fields.add('conditionalCreate');
  fields.add('conditionalRead');
  fields.add('conditionalUpdate');
  fields.add('conditionalDelete');
  fields.add('referencePolicy');
  fields.add('searchInclude');
  fields.add('searchRevInclude');
  fields.add('searchParam');
end;

{ TFhirCapabilityStatementRestResource }

Procedure TFhirCapabilityStatementRestResource.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirCapabilityStatementRestResource.GetType_ST : TFhirResourceTypesEnum;
begin
  if FType_ = nil then
    result := TFhirResourceTypesEnum(0)
  else
    result := TFhirResourceTypesEnum(StringArrayIndexOfSensitive(CODES_TFhirResourceTypesEnum, FType_.value));
end;

Procedure TFhirCapabilityStatementRestResource.SetType_ST(value : TFhirResourceTypesEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirResourceTypesEnum[value], CODES_TFhirResourceTypesEnum[value]);
end;

Procedure TFhirCapabilityStatementRestResource.SetProfile(value : TFhirReference{TFhirStructureDefinition});
begin
  FProfile.free;
  FProfile := value;
end;

Procedure TFhirCapabilityStatementRestResource.SetDocumentation(value : TFhirMarkdown);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirCapabilityStatementRestResource.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

Procedure TFhirCapabilityStatementRestResource.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirMarkdown.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

Function TFhirCapabilityStatementRestResource.GetInteractionList : TFhirCapabilityStatementRestResourceInteractionList;
begin
  if FInteractionList = nil then
    FInteractionList := TFhirCapabilityStatementRestResourceInteractionList.Create;
  result := FInteractionList;
end;

Function TFhirCapabilityStatementRestResource.GetHasInteractionList : boolean;
begin
  result := (FInteractionList <> nil) and (FInteractionList.count > 0);
end;

Procedure TFhirCapabilityStatementRestResource.SetVersioning(value : TFhirEnum);
begin
  FVersioning.free;
  FVersioning := value;
end;

Function TFhirCapabilityStatementRestResource.GetVersioningST : TFhirVersioningPolicyEnum;
begin
  if FVersioning = nil then
    result := TFhirVersioningPolicyEnum(0)
  else
    result := TFhirVersioningPolicyEnum(StringArrayIndexOfSensitive(CODES_TFhirVersioningPolicyEnum, FVersioning.value));
end;

Procedure TFhirCapabilityStatementRestResource.SetVersioningST(value : TFhirVersioningPolicyEnum);
begin
  if ord(value) = 0 then
    VersioningElement := nil
  else
    VersioningElement := TFhirEnum.create(SYSTEMS_TFhirVersioningPolicyEnum[value], CODES_TFhirVersioningPolicyEnum[value]);
end;

Procedure TFhirCapabilityStatementRestResource.SetReadHistory(value : TFhirBoolean);
begin
  FReadHistory.free;
  FReadHistory := value;
end;

Function TFhirCapabilityStatementRestResource.GetReadHistoryST : Boolean;
begin
  if FReadHistory = nil then
    result := false
  else
    result := FReadHistory.value;
end;

Procedure TFhirCapabilityStatementRestResource.SetReadHistoryST(value : Boolean);
begin
  if FReadHistory = nil then
    FReadHistory := TFhirBoolean.create;
  FReadHistory.value := value
end;

Procedure TFhirCapabilityStatementRestResource.SetUpdateCreate(value : TFhirBoolean);
begin
  FUpdateCreate.free;
  FUpdateCreate := value;
end;

Function TFhirCapabilityStatementRestResource.GetUpdateCreateST : Boolean;
begin
  if FUpdateCreate = nil then
    result := false
  else
    result := FUpdateCreate.value;
end;

Procedure TFhirCapabilityStatementRestResource.SetUpdateCreateST(value : Boolean);
begin
  if FUpdateCreate = nil then
    FUpdateCreate := TFhirBoolean.create;
  FUpdateCreate.value := value
end;

Procedure TFhirCapabilityStatementRestResource.SetConditionalCreate(value : TFhirBoolean);
begin
  FConditionalCreate.free;
  FConditionalCreate := value;
end;

Function TFhirCapabilityStatementRestResource.GetConditionalCreateST : Boolean;
begin
  if FConditionalCreate = nil then
    result := false
  else
    result := FConditionalCreate.value;
end;

Procedure TFhirCapabilityStatementRestResource.SetConditionalCreateST(value : Boolean);
begin
  if FConditionalCreate = nil then
    FConditionalCreate := TFhirBoolean.create;
  FConditionalCreate.value := value
end;

Procedure TFhirCapabilityStatementRestResource.SetConditionalRead(value : TFhirEnum);
begin
  FConditionalRead.free;
  FConditionalRead := value;
end;

Function TFhirCapabilityStatementRestResource.GetConditionalReadST : TFhirConditionalReadStatusEnum;
begin
  if FConditionalRead = nil then
    result := TFhirConditionalReadStatusEnum(0)
  else
    result := TFhirConditionalReadStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirConditionalReadStatusEnum, FConditionalRead.value));
end;

Procedure TFhirCapabilityStatementRestResource.SetConditionalReadST(value : TFhirConditionalReadStatusEnum);
begin
  if ord(value) = 0 then
    ConditionalReadElement := nil
  else
    ConditionalReadElement := TFhirEnum.create(SYSTEMS_TFhirConditionalReadStatusEnum[value], CODES_TFhirConditionalReadStatusEnum[value]);
end;

Procedure TFhirCapabilityStatementRestResource.SetConditionalUpdate(value : TFhirBoolean);
begin
  FConditionalUpdate.free;
  FConditionalUpdate := value;
end;

Function TFhirCapabilityStatementRestResource.GetConditionalUpdateST : Boolean;
begin
  if FConditionalUpdate = nil then
    result := false
  else
    result := FConditionalUpdate.value;
end;

Procedure TFhirCapabilityStatementRestResource.SetConditionalUpdateST(value : Boolean);
begin
  if FConditionalUpdate = nil then
    FConditionalUpdate := TFhirBoolean.create;
  FConditionalUpdate.value := value
end;

Procedure TFhirCapabilityStatementRestResource.SetConditionalDelete(value : TFhirEnum);
begin
  FConditionalDelete.free;
  FConditionalDelete := value;
end;

Function TFhirCapabilityStatementRestResource.GetConditionalDeleteST : TFhirConditionalDeleteStatusEnum;
begin
  if FConditionalDelete = nil then
    result := TFhirConditionalDeleteStatusEnum(0)
  else
    result := TFhirConditionalDeleteStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirConditionalDeleteStatusEnum, FConditionalDelete.value));
end;

Procedure TFhirCapabilityStatementRestResource.SetConditionalDeleteST(value : TFhirConditionalDeleteStatusEnum);
begin
  if ord(value) = 0 then
    ConditionalDeleteElement := nil
  else
    ConditionalDeleteElement := TFhirEnum.create(SYSTEMS_TFhirConditionalDeleteStatusEnum[value], CODES_TFhirConditionalDeleteStatusEnum[value]);
end;

Function TFhirCapabilityStatementRestResource.GetReferencePolicy : TFhirEnumList;
begin
  if FReferencePolicy = nil then
    FReferencePolicy := TFHIREnumList.Create(SYSTEMS_TFhirReferenceHandlingPolicyEnum, CODES_TFhirReferenceHandlingPolicyEnum);
  result := FReferencePolicy;
end;

Function TFhirCapabilityStatementRestResource.GetHasReferencePolicy : boolean;
begin
  result := (FReferencePolicy <> nil) and (FReferencePolicy.count > 0);
end;

Function TFhirCapabilityStatementRestResource.GetReferencePolicyST : TFhirReferenceHandlingPolicyEnumList;
  var i : integer;
begin
  result := [];
  if FreferencePolicy <> nil then
    for i := 0 to FreferencePolicy.count - 1 do
      result := result + [TFhirReferenceHandlingPolicyEnum(StringArrayIndexOfSensitive(CODES_TFhirReferenceHandlingPolicyEnum, FreferencePolicy[i].value))];
end;

Procedure TFhirCapabilityStatementRestResource.SetReferencePolicyST(value : TFhirReferenceHandlingPolicyEnumList);
var a : TFhirReferenceHandlingPolicyEnum;
begin
  if FreferencePolicy = nil then
    FreferencePolicy := TFhirEnumList.create(SYSTEMS_TFhirReferenceHandlingPolicyEnum, CODES_TFhirReferenceHandlingPolicyEnum);
  FreferencePolicy.clear;
  for a := low(TFhirReferenceHandlingPolicyEnum) to high(TFhirReferenceHandlingPolicyEnum) do
    if a in value then
      begin
         if FreferencePolicy = nil then
           FreferencePolicy := TFhirEnumList.create(SYSTEMS_TFhirReferenceHandlingPolicyEnum, CODES_TFhirReferenceHandlingPolicyEnum);
         FreferencePolicy.add(TFhirEnum.create(SYSTEMS_TFhirReferenceHandlingPolicyEnum[a], CODES_TFhirReferenceHandlingPolicyEnum[a]));
      end;
end;

Function TFhirCapabilityStatementRestResource.GetSearchIncludeList : TFhirStringList;
begin
  if FSearchIncludeList = nil then
    FSearchIncludeList := TFhirStringList.Create;
  result := FSearchIncludeList;
end;

Function TFhirCapabilityStatementRestResource.GetHasSearchIncludeList : boolean;
begin
  result := (FSearchIncludeList <> nil) and (FSearchIncludeList.count > 0);
end;

Function TFhirCapabilityStatementRestResource.GetSearchRevIncludeList : TFhirStringList;
begin
  if FSearchRevIncludeList = nil then
    FSearchRevIncludeList := TFhirStringList.Create;
  result := FSearchRevIncludeList;
end;

Function TFhirCapabilityStatementRestResource.GetHasSearchRevIncludeList : boolean;
begin
  result := (FSearchRevIncludeList <> nil) and (FSearchRevIncludeList.count > 0);
end;

Function TFhirCapabilityStatementRestResource.GetSearchParamList : TFhirCapabilityStatementRestResourceSearchParamList;
begin
  if FSearchParamList = nil then
    FSearchParamList := TFhirCapabilityStatementRestResourceSearchParamList.Create;
  result := FSearchParamList;
end;

Function TFhirCapabilityStatementRestResource.GetHasSearchParamList : boolean;
begin
  result := (FSearchParamList <> nil) and (FSearchParamList.count > 0);
end;

function TFhirCapabilityStatementRestResource.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FProfile.sizeInBytes);
  inc(result, FDocumentation.sizeInBytes);
  inc(result, FinteractionList.sizeInBytes);
  inc(result, FVersioning.sizeInBytes);
  inc(result, FReadHistory.sizeInBytes);
  inc(result, FUpdateCreate.sizeInBytes);
  inc(result, FConditionalCreate.sizeInBytes);
  inc(result, FConditionalRead.sizeInBytes);
  inc(result, FConditionalUpdate.sizeInBytes);
  inc(result, FConditionalDelete.sizeInBytes);
  inc(result, FReferencePolicy.sizeInBytes);
  inc(result, FsearchIncludeList.sizeInBytes);
  inc(result, FsearchRevIncludeList.sizeInBytes);
  inc(result, FsearchParamList.sizeInBytes);
end;

{ TFhirCapabilityStatementRestResourceListEnumerator }

Constructor TFhirCapabilityStatementRestResourceListEnumerator.Create(list : TFhirCapabilityStatementRestResourceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCapabilityStatementRestResourceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCapabilityStatementRestResourceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCapabilityStatementRestResourceListEnumerator.GetCurrent : TFhirCapabilityStatementRestResource;
begin
  Result := FList[FIndex];
end;

function TFhirCapabilityStatementRestResourceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCapabilityStatementRestResourceList }
procedure TFhirCapabilityStatementRestResourceList.AddItem(value: TFhirCapabilityStatementRestResource);
begin
  assert(value.ClassName = 'TFhirCapabilityStatementRestResource', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCapabilityStatementRestResource');
  add(value);
end;

function TFhirCapabilityStatementRestResourceList.Append: TFhirCapabilityStatementRestResource;
begin
  result := TFhirCapabilityStatementRestResource.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementRestResourceList.ClearItems;
begin
  Clear;
end;

function TFhirCapabilityStatementRestResourceList.GetEnumerator : TFhirCapabilityStatementRestResourceListEnumerator;
begin
  result := TFhirCapabilityStatementRestResourceListEnumerator.Create(self.link);
end;

function TFhirCapabilityStatementRestResourceList.Clone: TFhirCapabilityStatementRestResourceList;
begin
  result := TFhirCapabilityStatementRestResourceList(inherited Clone);
end;

function TFhirCapabilityStatementRestResourceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCapabilityStatementRestResourceList.GetItemN(index: Integer): TFhirCapabilityStatementRestResource;
begin
  result := TFhirCapabilityStatementRestResource(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementRestResourceList.ItemClass: TFslObjectClass;
begin
  result := TFhirCapabilityStatementRestResource;
end;
function TFhirCapabilityStatementRestResourceList.IndexOf(value: TFhirCapabilityStatementRestResource): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCapabilityStatementRestResourceList.Insert(index: Integer): TFhirCapabilityStatementRestResource;
begin
  result := TFhirCapabilityStatementRestResource.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementRestResourceList.InsertItem(index: Integer; value: TFhirCapabilityStatementRestResource);
begin
  assert(value is TFhirCapabilityStatementRestResource);
  Inherited Insert(index, value);
end;

function TFhirCapabilityStatementRestResourceList.Item(index: Integer): TFhirCapabilityStatementRestResource;
begin
  result := TFhirCapabilityStatementRestResource(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementRestResourceList.Link: TFhirCapabilityStatementRestResourceList;
begin
  result := TFhirCapabilityStatementRestResourceList(inherited Link);
end;

procedure TFhirCapabilityStatementRestResourceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCapabilityStatementRestResourceList.SetItemByIndex(index: Integer; value: TFhirCapabilityStatementRestResource);
begin
  assert(value is TFhirCapabilityStatementRestResource);
  FhirCapabilityStatementRestResources[index] := value;
end;

procedure TFhirCapabilityStatementRestResourceList.SetItemN(index: Integer; value: TFhirCapabilityStatementRestResource);
begin
  assert(value is TFhirCapabilityStatementRestResource);
  ObjectByIndex[index] := value;
end;

{ TFhirCapabilityStatementRestResourceInteraction }

constructor TFhirCapabilityStatementRestResourceInteraction.Create;
begin
  inherited;
end;

destructor TFhirCapabilityStatementRestResourceInteraction.Destroy;
begin
  FCode.free;
  FDocumentation.free;
  inherited;
end;

procedure TFhirCapabilityStatementRestResourceInteraction.Assign(oSource : TFslObject);
begin
  inherited;
  FCode := TFhirCapabilityStatementRestResourceInteraction(oSource).FCode.Link;
  documentationElement := TFhirCapabilityStatementRestResourceInteraction(oSource).documentationElement.Clone;
end;

procedure TFhirCapabilityStatementRestResourceInteraction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'documentation') Then
     list.add(self.link, 'documentation', FDocumentation.Link);
end;

procedure TFhirCapabilityStatementRestResourceInteraction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFHIREnum, FCode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', false, TFhirString, FDocumentation.Link));{2}
end;

function TFhirCapabilityStatementRestResourceInteraction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asEnum(SYSTEMS_TFhirTypeRestfulInteractionEnum, CODES_TFhirTypeRestfulInteractionEnum, propValue);
    result := propValue
  end
  else if (propName = 'documentation') then
  begin
    DocumentationElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCapabilityStatementRestResourceInteraction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCapabilityStatementRestResourceInteraction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'documentation') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCapabilityStatementRestResourceInteraction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'code'
  else if (propName = 'documentation') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCapabilityStatementRestResourceInteraction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'documentation') then DocumentationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCapabilityStatementRestResourceInteraction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asEnum(SYSTEMS_TFhirTypeRestfulInteractionEnum, CODES_TFhirTypeRestfulInteractionEnum, new){4}
  else if (propName = 'documentation') then DocumentationElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCapabilityStatementRestResourceInteraction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCapabilityStatementRestResourceInteraction.fhirType : string;
begin
  result := 'interaction';
end;

function TFhirCapabilityStatementRestResourceInteraction.Link : TFhirCapabilityStatementRestResourceInteraction;
begin
  result := TFhirCapabilityStatementRestResourceInteraction(inherited Link);
end;

function TFhirCapabilityStatementRestResourceInteraction.Clone : TFhirCapabilityStatementRestResourceInteraction;
begin
  result := TFhirCapabilityStatementRestResourceInteraction(inherited Clone);
end;

function TFhirCapabilityStatementRestResourceInteraction.equals(other : TObject) : boolean;
var
  o : TFhirCapabilityStatementRestResourceInteraction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCapabilityStatementRestResourceInteraction)) then
    result := false
  else
  begin
    o := TFhirCapabilityStatementRestResourceInteraction(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(documentationElement, o.documentationElement, true);
  end;
end;

function TFhirCapabilityStatementRestResourceInteraction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FDocumentation);
end;

procedure TFhirCapabilityStatementRestResourceInteraction.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('documentation');
end;

{ TFhirCapabilityStatementRestResourceInteraction }

Procedure TFhirCapabilityStatementRestResourceInteraction.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirCapabilityStatementRestResourceInteraction.GetCodeST : TFhirTypeRestfulInteractionEnum;
begin
  if FCode = nil then
    result := TFhirTypeRestfulInteractionEnum(0)
  else
    result := TFhirTypeRestfulInteractionEnum(StringArrayIndexOfSensitive(CODES_TFhirTypeRestfulInteractionEnum, FCode.value));
end;

Procedure TFhirCapabilityStatementRestResourceInteraction.SetCodeST(value : TFhirTypeRestfulInteractionEnum);
begin
  if ord(value) = 0 then
    CodeElement := nil
  else
    CodeElement := TFhirEnum.create(SYSTEMS_TFhirTypeRestfulInteractionEnum[value], CODES_TFhirTypeRestfulInteractionEnum[value]);
end;

Procedure TFhirCapabilityStatementRestResourceInteraction.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirCapabilityStatementRestResourceInteraction.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

Procedure TFhirCapabilityStatementRestResourceInteraction.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

function TFhirCapabilityStatementRestResourceInteraction.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FDocumentation.sizeInBytes);
end;

{ TFhirCapabilityStatementRestResourceInteractionListEnumerator }

Constructor TFhirCapabilityStatementRestResourceInteractionListEnumerator.Create(list : TFhirCapabilityStatementRestResourceInteractionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCapabilityStatementRestResourceInteractionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCapabilityStatementRestResourceInteractionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCapabilityStatementRestResourceInteractionListEnumerator.GetCurrent : TFhirCapabilityStatementRestResourceInteraction;
begin
  Result := FList[FIndex];
end;

function TFhirCapabilityStatementRestResourceInteractionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCapabilityStatementRestResourceInteractionList }
procedure TFhirCapabilityStatementRestResourceInteractionList.AddItem(value: TFhirCapabilityStatementRestResourceInteraction);
begin
  assert(value.ClassName = 'TFhirCapabilityStatementRestResourceInteraction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCapabilityStatementRestResourceInteraction');
  add(value);
end;

function TFhirCapabilityStatementRestResourceInteractionList.Append: TFhirCapabilityStatementRestResourceInteraction;
begin
  result := TFhirCapabilityStatementRestResourceInteraction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementRestResourceInteractionList.ClearItems;
begin
  Clear;
end;

function TFhirCapabilityStatementRestResourceInteractionList.GetEnumerator : TFhirCapabilityStatementRestResourceInteractionListEnumerator;
begin
  result := TFhirCapabilityStatementRestResourceInteractionListEnumerator.Create(self.link);
end;

function TFhirCapabilityStatementRestResourceInteractionList.Clone: TFhirCapabilityStatementRestResourceInteractionList;
begin
  result := TFhirCapabilityStatementRestResourceInteractionList(inherited Clone);
end;

function TFhirCapabilityStatementRestResourceInteractionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCapabilityStatementRestResourceInteractionList.GetItemN(index: Integer): TFhirCapabilityStatementRestResourceInteraction;
begin
  result := TFhirCapabilityStatementRestResourceInteraction(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementRestResourceInteractionList.ItemClass: TFslObjectClass;
begin
  result := TFhirCapabilityStatementRestResourceInteraction;
end;
function TFhirCapabilityStatementRestResourceInteractionList.IndexOf(value: TFhirCapabilityStatementRestResourceInteraction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCapabilityStatementRestResourceInteractionList.Insert(index: Integer): TFhirCapabilityStatementRestResourceInteraction;
begin
  result := TFhirCapabilityStatementRestResourceInteraction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementRestResourceInteractionList.InsertItem(index: Integer; value: TFhirCapabilityStatementRestResourceInteraction);
begin
  assert(value is TFhirCapabilityStatementRestResourceInteraction);
  Inherited Insert(index, value);
end;

function TFhirCapabilityStatementRestResourceInteractionList.Item(index: Integer): TFhirCapabilityStatementRestResourceInteraction;
begin
  result := TFhirCapabilityStatementRestResourceInteraction(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementRestResourceInteractionList.Link: TFhirCapabilityStatementRestResourceInteractionList;
begin
  result := TFhirCapabilityStatementRestResourceInteractionList(inherited Link);
end;

procedure TFhirCapabilityStatementRestResourceInteractionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCapabilityStatementRestResourceInteractionList.SetItemByIndex(index: Integer; value: TFhirCapabilityStatementRestResourceInteraction);
begin
  assert(value is TFhirCapabilityStatementRestResourceInteraction);
  FhirCapabilityStatementRestResourceInteractions[index] := value;
end;

procedure TFhirCapabilityStatementRestResourceInteractionList.SetItemN(index: Integer; value: TFhirCapabilityStatementRestResourceInteraction);
begin
  assert(value is TFhirCapabilityStatementRestResourceInteraction);
  ObjectByIndex[index] := value;
end;

{ TFhirCapabilityStatementRestResourceSearchParam }

constructor TFhirCapabilityStatementRestResourceSearchParam.Create;
begin
  inherited;
end;

destructor TFhirCapabilityStatementRestResourceSearchParam.Destroy;
begin
  FName.free;
  FDefinition.free;
  FType_.free;
  FDocumentation.free;
  inherited;
end;

procedure TFhirCapabilityStatementRestResourceSearchParam.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirCapabilityStatementRestResourceSearchParam(oSource).nameElement.Clone;
  definitionElement := TFhirCapabilityStatementRestResourceSearchParam(oSource).definitionElement.Clone;
  FType_ := TFhirCapabilityStatementRestResourceSearchParam(oSource).FType_.Link;
  documentationElement := TFhirCapabilityStatementRestResourceSearchParam(oSource).documentationElement.Clone;
end;

procedure TFhirCapabilityStatementRestResourceSearchParam.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'definition') Then
     list.add(self.link, 'definition', FDefinition.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'documentation') Then
     list.add(self.link, 'documentation', FDocumentation.Link);
end;

procedure TFhirCapabilityStatementRestResourceSearchParam.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'definition', 'uri', false, TFhirUri, FDefinition.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', false, TFhirString, FDocumentation.Link));{2}
end;

function TFhirCapabilityStatementRestResourceSearchParam.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'definition') then
  begin
    DefinitionElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirSearchParamTypeEnum, CODES_TFhirSearchParamTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'documentation') then
  begin
    DocumentationElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCapabilityStatementRestResourceSearchParam.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCapabilityStatementRestResourceSearchParam.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'definition') then result := TFhirUri.create() {5b}
  else if (propName = 'documentation') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCapabilityStatementRestResourceSearchParam.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'definition') then result := 'uri'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'documentation') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCapabilityStatementRestResourceSearchParam.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'definition') then DefinitionElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'documentation') then DocumentationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCapabilityStatementRestResourceSearchParam.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'definition') then DefinitionElement := asUri(new){5b}
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirSearchParamTypeEnum, CODES_TFhirSearchParamTypeEnum, new){4}
  else if (propName = 'documentation') then DocumentationElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCapabilityStatementRestResourceSearchParam.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCapabilityStatementRestResourceSearchParam.fhirType : string;
begin
  result := 'searchParam';
end;

function TFhirCapabilityStatementRestResourceSearchParam.Link : TFhirCapabilityStatementRestResourceSearchParam;
begin
  result := TFhirCapabilityStatementRestResourceSearchParam(inherited Link);
end;

function TFhirCapabilityStatementRestResourceSearchParam.Clone : TFhirCapabilityStatementRestResourceSearchParam;
begin
  result := TFhirCapabilityStatementRestResourceSearchParam(inherited Clone);
end;

function TFhirCapabilityStatementRestResourceSearchParam.equals(other : TObject) : boolean;
var
  o : TFhirCapabilityStatementRestResourceSearchParam;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCapabilityStatementRestResourceSearchParam)) then
    result := false
  else
  begin
    o := TFhirCapabilityStatementRestResourceSearchParam(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(definitionElement, o.definitionElement, true) and
      compareDeep(type_Element, o.type_Element, true) and compareDeep(documentationElement, o.documentationElement, true);
  end;
end;

function TFhirCapabilityStatementRestResourceSearchParam.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FDefinition) and isEmptyProp(FType_) and isEmptyProp(FDocumentation);
end;

procedure TFhirCapabilityStatementRestResourceSearchParam.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('definition');
  fields.add('type');
  fields.add('documentation');
end;

{ TFhirCapabilityStatementRestResourceSearchParam }

Procedure TFhirCapabilityStatementRestResourceSearchParam.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirCapabilityStatementRestResourceSearchParam.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirCapabilityStatementRestResourceSearchParam.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirCapabilityStatementRestResourceSearchParam.SetDefinition(value : TFhirUri);
begin
  FDefinition.free;
  FDefinition := value;
end;

Function TFhirCapabilityStatementRestResourceSearchParam.GetDefinitionST : String;
begin
  if FDefinition = nil then
    result := ''
  else
    result := FDefinition.value;
end;

Procedure TFhirCapabilityStatementRestResourceSearchParam.SetDefinitionST(value : String);
begin
  if value <> '' then
  begin
    if FDefinition = nil then
      FDefinition := TFhirUri.create;
    FDefinition.value := value
  end
  else if FDefinition <> nil then
    FDefinition.value := '';
end;

Procedure TFhirCapabilityStatementRestResourceSearchParam.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirCapabilityStatementRestResourceSearchParam.GetType_ST : TFhirSearchParamTypeEnum;
begin
  if FType_ = nil then
    result := TFhirSearchParamTypeEnum(0)
  else
    result := TFhirSearchParamTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirSearchParamTypeEnum, FType_.value));
end;

Procedure TFhirCapabilityStatementRestResourceSearchParam.SetType_ST(value : TFhirSearchParamTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirSearchParamTypeEnum[value], CODES_TFhirSearchParamTypeEnum[value]);
end;

Procedure TFhirCapabilityStatementRestResourceSearchParam.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirCapabilityStatementRestResourceSearchParam.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

Procedure TFhirCapabilityStatementRestResourceSearchParam.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

function TFhirCapabilityStatementRestResourceSearchParam.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FDefinition.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FDocumentation.sizeInBytes);
end;

{ TFhirCapabilityStatementRestResourceSearchParamListEnumerator }

Constructor TFhirCapabilityStatementRestResourceSearchParamListEnumerator.Create(list : TFhirCapabilityStatementRestResourceSearchParamList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCapabilityStatementRestResourceSearchParamListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCapabilityStatementRestResourceSearchParamListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCapabilityStatementRestResourceSearchParamListEnumerator.GetCurrent : TFhirCapabilityStatementRestResourceSearchParam;
begin
  Result := FList[FIndex];
end;

function TFhirCapabilityStatementRestResourceSearchParamListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCapabilityStatementRestResourceSearchParamList }
procedure TFhirCapabilityStatementRestResourceSearchParamList.AddItem(value: TFhirCapabilityStatementRestResourceSearchParam);
begin
  assert(value.ClassName = 'TFhirCapabilityStatementRestResourceSearchParam', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCapabilityStatementRestResourceSearchParam');
  add(value);
end;

function TFhirCapabilityStatementRestResourceSearchParamList.Append: TFhirCapabilityStatementRestResourceSearchParam;
begin
  result := TFhirCapabilityStatementRestResourceSearchParam.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementRestResourceSearchParamList.ClearItems;
begin
  Clear;
end;

function TFhirCapabilityStatementRestResourceSearchParamList.GetEnumerator : TFhirCapabilityStatementRestResourceSearchParamListEnumerator;
begin
  result := TFhirCapabilityStatementRestResourceSearchParamListEnumerator.Create(self.link);
end;

function TFhirCapabilityStatementRestResourceSearchParamList.Clone: TFhirCapabilityStatementRestResourceSearchParamList;
begin
  result := TFhirCapabilityStatementRestResourceSearchParamList(inherited Clone);
end;

function TFhirCapabilityStatementRestResourceSearchParamList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCapabilityStatementRestResourceSearchParamList.GetItemN(index: Integer): TFhirCapabilityStatementRestResourceSearchParam;
begin
  result := TFhirCapabilityStatementRestResourceSearchParam(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementRestResourceSearchParamList.ItemClass: TFslObjectClass;
begin
  result := TFhirCapabilityStatementRestResourceSearchParam;
end;
function TFhirCapabilityStatementRestResourceSearchParamList.IndexOf(value: TFhirCapabilityStatementRestResourceSearchParam): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCapabilityStatementRestResourceSearchParamList.Insert(index: Integer): TFhirCapabilityStatementRestResourceSearchParam;
begin
  result := TFhirCapabilityStatementRestResourceSearchParam.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementRestResourceSearchParamList.InsertItem(index: Integer; value: TFhirCapabilityStatementRestResourceSearchParam);
begin
  assert(value is TFhirCapabilityStatementRestResourceSearchParam);
  Inherited Insert(index, value);
end;

function TFhirCapabilityStatementRestResourceSearchParamList.Item(index: Integer): TFhirCapabilityStatementRestResourceSearchParam;
begin
  result := TFhirCapabilityStatementRestResourceSearchParam(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementRestResourceSearchParamList.Link: TFhirCapabilityStatementRestResourceSearchParamList;
begin
  result := TFhirCapabilityStatementRestResourceSearchParamList(inherited Link);
end;

procedure TFhirCapabilityStatementRestResourceSearchParamList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCapabilityStatementRestResourceSearchParamList.SetItemByIndex(index: Integer; value: TFhirCapabilityStatementRestResourceSearchParam);
begin
  assert(value is TFhirCapabilityStatementRestResourceSearchParam);
  FhirCapabilityStatementRestResourceSearchParams[index] := value;
end;

procedure TFhirCapabilityStatementRestResourceSearchParamList.SetItemN(index: Integer; value: TFhirCapabilityStatementRestResourceSearchParam);
begin
  assert(value is TFhirCapabilityStatementRestResourceSearchParam);
  ObjectByIndex[index] := value;
end;

{ TFhirCapabilityStatementRestInteraction }

constructor TFhirCapabilityStatementRestInteraction.Create;
begin
  inherited;
end;

destructor TFhirCapabilityStatementRestInteraction.Destroy;
begin
  FCode.free;
  FDocumentation.free;
  inherited;
end;

procedure TFhirCapabilityStatementRestInteraction.Assign(oSource : TFslObject);
begin
  inherited;
  FCode := TFhirCapabilityStatementRestInteraction(oSource).FCode.Link;
  documentationElement := TFhirCapabilityStatementRestInteraction(oSource).documentationElement.Clone;
end;

procedure TFhirCapabilityStatementRestInteraction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'documentation') Then
     list.add(self.link, 'documentation', FDocumentation.Link);
end;

procedure TFhirCapabilityStatementRestInteraction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFHIREnum, FCode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', false, TFhirString, FDocumentation.Link));{2}
end;

function TFhirCapabilityStatementRestInteraction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asEnum(SYSTEMS_TFhirSystemRestfulInteractionEnum, CODES_TFhirSystemRestfulInteractionEnum, propValue);
    result := propValue
  end
  else if (propName = 'documentation') then
  begin
    DocumentationElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCapabilityStatementRestInteraction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCapabilityStatementRestInteraction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'documentation') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCapabilityStatementRestInteraction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'code'
  else if (propName = 'documentation') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCapabilityStatementRestInteraction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'documentation') then DocumentationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCapabilityStatementRestInteraction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asEnum(SYSTEMS_TFhirSystemRestfulInteractionEnum, CODES_TFhirSystemRestfulInteractionEnum, new){4}
  else if (propName = 'documentation') then DocumentationElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCapabilityStatementRestInteraction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCapabilityStatementRestInteraction.fhirType : string;
begin
  result := 'interaction';
end;

function TFhirCapabilityStatementRestInteraction.Link : TFhirCapabilityStatementRestInteraction;
begin
  result := TFhirCapabilityStatementRestInteraction(inherited Link);
end;

function TFhirCapabilityStatementRestInteraction.Clone : TFhirCapabilityStatementRestInteraction;
begin
  result := TFhirCapabilityStatementRestInteraction(inherited Clone);
end;

function TFhirCapabilityStatementRestInteraction.equals(other : TObject) : boolean;
var
  o : TFhirCapabilityStatementRestInteraction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCapabilityStatementRestInteraction)) then
    result := false
  else
  begin
    o := TFhirCapabilityStatementRestInteraction(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(documentationElement, o.documentationElement, true);
  end;
end;

function TFhirCapabilityStatementRestInteraction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FDocumentation);
end;

procedure TFhirCapabilityStatementRestInteraction.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('documentation');
end;

{ TFhirCapabilityStatementRestInteraction }

Procedure TFhirCapabilityStatementRestInteraction.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirCapabilityStatementRestInteraction.GetCodeST : TFhirSystemRestfulInteractionEnum;
begin
  if FCode = nil then
    result := TFhirSystemRestfulInteractionEnum(0)
  else
    result := TFhirSystemRestfulInteractionEnum(StringArrayIndexOfSensitive(CODES_TFhirSystemRestfulInteractionEnum, FCode.value));
end;

Procedure TFhirCapabilityStatementRestInteraction.SetCodeST(value : TFhirSystemRestfulInteractionEnum);
begin
  if ord(value) = 0 then
    CodeElement := nil
  else
    CodeElement := TFhirEnum.create(SYSTEMS_TFhirSystemRestfulInteractionEnum[value], CODES_TFhirSystemRestfulInteractionEnum[value]);
end;

Procedure TFhirCapabilityStatementRestInteraction.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirCapabilityStatementRestInteraction.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

Procedure TFhirCapabilityStatementRestInteraction.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

function TFhirCapabilityStatementRestInteraction.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FDocumentation.sizeInBytes);
end;

{ TFhirCapabilityStatementRestInteractionListEnumerator }

Constructor TFhirCapabilityStatementRestInteractionListEnumerator.Create(list : TFhirCapabilityStatementRestInteractionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCapabilityStatementRestInteractionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCapabilityStatementRestInteractionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCapabilityStatementRestInteractionListEnumerator.GetCurrent : TFhirCapabilityStatementRestInteraction;
begin
  Result := FList[FIndex];
end;

function TFhirCapabilityStatementRestInteractionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCapabilityStatementRestInteractionList }
procedure TFhirCapabilityStatementRestInteractionList.AddItem(value: TFhirCapabilityStatementRestInteraction);
begin
  assert(value.ClassName = 'TFhirCapabilityStatementRestInteraction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCapabilityStatementRestInteraction');
  add(value);
end;

function TFhirCapabilityStatementRestInteractionList.Append: TFhirCapabilityStatementRestInteraction;
begin
  result := TFhirCapabilityStatementRestInteraction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementRestInteractionList.ClearItems;
begin
  Clear;
end;

function TFhirCapabilityStatementRestInteractionList.GetEnumerator : TFhirCapabilityStatementRestInteractionListEnumerator;
begin
  result := TFhirCapabilityStatementRestInteractionListEnumerator.Create(self.link);
end;

function TFhirCapabilityStatementRestInteractionList.Clone: TFhirCapabilityStatementRestInteractionList;
begin
  result := TFhirCapabilityStatementRestInteractionList(inherited Clone);
end;

function TFhirCapabilityStatementRestInteractionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCapabilityStatementRestInteractionList.GetItemN(index: Integer): TFhirCapabilityStatementRestInteraction;
begin
  result := TFhirCapabilityStatementRestInteraction(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementRestInteractionList.ItemClass: TFslObjectClass;
begin
  result := TFhirCapabilityStatementRestInteraction;
end;
function TFhirCapabilityStatementRestInteractionList.IndexOf(value: TFhirCapabilityStatementRestInteraction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCapabilityStatementRestInteractionList.Insert(index: Integer): TFhirCapabilityStatementRestInteraction;
begin
  result := TFhirCapabilityStatementRestInteraction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementRestInteractionList.InsertItem(index: Integer; value: TFhirCapabilityStatementRestInteraction);
begin
  assert(value is TFhirCapabilityStatementRestInteraction);
  Inherited Insert(index, value);
end;

function TFhirCapabilityStatementRestInteractionList.Item(index: Integer): TFhirCapabilityStatementRestInteraction;
begin
  result := TFhirCapabilityStatementRestInteraction(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementRestInteractionList.Link: TFhirCapabilityStatementRestInteractionList;
begin
  result := TFhirCapabilityStatementRestInteractionList(inherited Link);
end;

procedure TFhirCapabilityStatementRestInteractionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCapabilityStatementRestInteractionList.SetItemByIndex(index: Integer; value: TFhirCapabilityStatementRestInteraction);
begin
  assert(value is TFhirCapabilityStatementRestInteraction);
  FhirCapabilityStatementRestInteractions[index] := value;
end;

procedure TFhirCapabilityStatementRestInteractionList.SetItemN(index: Integer; value: TFhirCapabilityStatementRestInteraction);
begin
  assert(value is TFhirCapabilityStatementRestInteraction);
  ObjectByIndex[index] := value;
end;

{ TFhirCapabilityStatementRestOperation }

constructor TFhirCapabilityStatementRestOperation.Create;
begin
  inherited;
end;

destructor TFhirCapabilityStatementRestOperation.Destroy;
begin
  FName.free;
  FDefinition.free;
  inherited;
end;

procedure TFhirCapabilityStatementRestOperation.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirCapabilityStatementRestOperation(oSource).nameElement.Clone;
  definition := TFhirCapabilityStatementRestOperation(oSource).definition.Clone;
end;

procedure TFhirCapabilityStatementRestOperation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'definition') Then
     list.add(self.link, 'definition', FDefinition.Link);
end;

procedure TFhirCapabilityStatementRestOperation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'definition', 'Reference(OperationDefinition)', false, TFhirReference{TFhirOperationDefinition}, FDefinition.Link));{2}
end;

function TFhirCapabilityStatementRestOperation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'definition') then
  begin
    Definition := propValue as TFhirReference{TFhirOperationDefinition}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCapabilityStatementRestOperation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCapabilityStatementRestOperation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'definition') then result := TFhirReference{TFhirOperationDefinition}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCapabilityStatementRestOperation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'definition') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCapabilityStatementRestOperation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'definition') then DefinitionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCapabilityStatementRestOperation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'definition') then DefinitionElement := new as TFhirReference{TFhirOperationDefinition}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCapabilityStatementRestOperation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCapabilityStatementRestOperation.fhirType : string;
begin
  result := 'operation';
end;

function TFhirCapabilityStatementRestOperation.Link : TFhirCapabilityStatementRestOperation;
begin
  result := TFhirCapabilityStatementRestOperation(inherited Link);
end;

function TFhirCapabilityStatementRestOperation.Clone : TFhirCapabilityStatementRestOperation;
begin
  result := TFhirCapabilityStatementRestOperation(inherited Clone);
end;

function TFhirCapabilityStatementRestOperation.equals(other : TObject) : boolean;
var
  o : TFhirCapabilityStatementRestOperation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCapabilityStatementRestOperation)) then
    result := false
  else
  begin
    o := TFhirCapabilityStatementRestOperation(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(definitionElement, o.definitionElement, true);
  end;
end;

function TFhirCapabilityStatementRestOperation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FDefinition);
end;

procedure TFhirCapabilityStatementRestOperation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('definition');
end;

{ TFhirCapabilityStatementRestOperation }

Procedure TFhirCapabilityStatementRestOperation.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirCapabilityStatementRestOperation.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirCapabilityStatementRestOperation.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirCapabilityStatementRestOperation.SetDefinition(value : TFhirReference{TFhirOperationDefinition});
begin
  FDefinition.free;
  FDefinition := value;
end;

function TFhirCapabilityStatementRestOperation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FDefinition.sizeInBytes);
end;

{ TFhirCapabilityStatementRestOperationListEnumerator }

Constructor TFhirCapabilityStatementRestOperationListEnumerator.Create(list : TFhirCapabilityStatementRestOperationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCapabilityStatementRestOperationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCapabilityStatementRestOperationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCapabilityStatementRestOperationListEnumerator.GetCurrent : TFhirCapabilityStatementRestOperation;
begin
  Result := FList[FIndex];
end;

function TFhirCapabilityStatementRestOperationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCapabilityStatementRestOperationList }
procedure TFhirCapabilityStatementRestOperationList.AddItem(value: TFhirCapabilityStatementRestOperation);
begin
  assert(value.ClassName = 'TFhirCapabilityStatementRestOperation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCapabilityStatementRestOperation');
  add(value);
end;

function TFhirCapabilityStatementRestOperationList.Append: TFhirCapabilityStatementRestOperation;
begin
  result := TFhirCapabilityStatementRestOperation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementRestOperationList.ClearItems;
begin
  Clear;
end;

function TFhirCapabilityStatementRestOperationList.GetEnumerator : TFhirCapabilityStatementRestOperationListEnumerator;
begin
  result := TFhirCapabilityStatementRestOperationListEnumerator.Create(self.link);
end;

function TFhirCapabilityStatementRestOperationList.Clone: TFhirCapabilityStatementRestOperationList;
begin
  result := TFhirCapabilityStatementRestOperationList(inherited Clone);
end;

function TFhirCapabilityStatementRestOperationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCapabilityStatementRestOperationList.GetItemN(index: Integer): TFhirCapabilityStatementRestOperation;
begin
  result := TFhirCapabilityStatementRestOperation(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementRestOperationList.ItemClass: TFslObjectClass;
begin
  result := TFhirCapabilityStatementRestOperation;
end;
function TFhirCapabilityStatementRestOperationList.IndexOf(value: TFhirCapabilityStatementRestOperation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCapabilityStatementRestOperationList.Insert(index: Integer): TFhirCapabilityStatementRestOperation;
begin
  result := TFhirCapabilityStatementRestOperation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementRestOperationList.InsertItem(index: Integer; value: TFhirCapabilityStatementRestOperation);
begin
  assert(value is TFhirCapabilityStatementRestOperation);
  Inherited Insert(index, value);
end;

function TFhirCapabilityStatementRestOperationList.Item(index: Integer): TFhirCapabilityStatementRestOperation;
begin
  result := TFhirCapabilityStatementRestOperation(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementRestOperationList.Link: TFhirCapabilityStatementRestOperationList;
begin
  result := TFhirCapabilityStatementRestOperationList(inherited Link);
end;

procedure TFhirCapabilityStatementRestOperationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCapabilityStatementRestOperationList.SetItemByIndex(index: Integer; value: TFhirCapabilityStatementRestOperation);
begin
  assert(value is TFhirCapabilityStatementRestOperation);
  FhirCapabilityStatementRestOperations[index] := value;
end;

procedure TFhirCapabilityStatementRestOperationList.SetItemN(index: Integer; value: TFhirCapabilityStatementRestOperation);
begin
  assert(value is TFhirCapabilityStatementRestOperation);
  ObjectByIndex[index] := value;
end;

{ TFhirCapabilityStatementMessaging }

constructor TFhirCapabilityStatementMessaging.Create;
begin
  inherited;
end;

destructor TFhirCapabilityStatementMessaging.Destroy;
begin
  FEndpointList.Free;
  FReliableCache.free;
  FDocumentation.free;
  FSupportedMessageList.Free;
  FEventList.Free;
  inherited;
end;

procedure TFhirCapabilityStatementMessaging.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCapabilityStatementMessaging(oSource).FEndpointList = nil) then
  begin
    FEndpointList.free;
    FEndpointList := nil;
  end
  else
  begin
    if FEndpointList = nil then
      FEndpointList := TFhirCapabilityStatementMessagingEndpointList.Create;
    FEndpointList.Assign(TFhirCapabilityStatementMessaging(oSource).FEndpointList);
  end;
  reliableCacheElement := TFhirCapabilityStatementMessaging(oSource).reliableCacheElement.Clone;
  documentationElement := TFhirCapabilityStatementMessaging(oSource).documentationElement.Clone;
  if (TFhirCapabilityStatementMessaging(oSource).FSupportedMessageList = nil) then
  begin
    FSupportedMessageList.free;
    FSupportedMessageList := nil;
  end
  else
  begin
    if FSupportedMessageList = nil then
      FSupportedMessageList := TFhirCapabilityStatementMessagingSupportedMessageList.Create;
    FSupportedMessageList.Assign(TFhirCapabilityStatementMessaging(oSource).FSupportedMessageList);
  end;
  if (TFhirCapabilityStatementMessaging(oSource).FEventList = nil) then
  begin
    FEventList.free;
    FEventList := nil;
  end
  else
  begin
    if FEventList = nil then
      FEventList := TFhirCapabilityStatementMessagingEventList.Create;
    FEventList.Assign(TFhirCapabilityStatementMessaging(oSource).FEventList);
  end;
end;

procedure TFhirCapabilityStatementMessaging.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'endpoint') Then
    list.addAll(self, 'endpoint', FEndpointList);
  if (child_name = 'reliableCache') Then
     list.add(self.link, 'reliableCache', FReliableCache.Link);
  if (child_name = 'documentation') Then
     list.add(self.link, 'documentation', FDocumentation.Link);
  if (child_name = 'supportedMessage') Then
    list.addAll(self, 'supportedMessage', FSupportedMessageList);
  if (child_name = 'event') Then
    list.addAll(self, 'event', FEventList);
end;

procedure TFhirCapabilityStatementMessaging.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'endpoint', '', true, TFhirCapabilityStatementMessagingEndpoint, FEndpointList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reliableCache', 'unsignedInt', false, TFhirUnsignedInt, FReliableCache.Link));{2}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', false, TFhirString, FDocumentation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'supportedMessage', '', true, TFhirCapabilityStatementMessagingSupportedMessage, FSupportedMessageList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'event', '', true, TFhirCapabilityStatementMessagingEvent, FEventList.Link)){3};
end;

function TFhirCapabilityStatementMessaging.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'endpoint') then
  begin
    EndpointList.add(propValue as TFhirCapabilityStatementMessagingEndpoint){2a};
    result := propValue;
  end
  else if (propName = 'reliableCache') then
  begin
    ReliableCacheElement := asUnsignedInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'documentation') then
  begin
    DocumentationElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'supportedMessage') then
  begin
    SupportedMessageList.add(propValue as TFhirCapabilityStatementMessagingSupportedMessage){2a};
    result := propValue;
  end
  else if (propName = 'event') then
  begin
    EventList.add(propValue as TFhirCapabilityStatementMessagingEvent){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCapabilityStatementMessaging.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'endpoint') then EndpointList.insertItem(index, propValue as TFhirCapabilityStatementMessagingEndpoint){2a}
  else if (propName = 'supportedMessage') then SupportedMessageList.insertItem(index, propValue as TFhirCapabilityStatementMessagingSupportedMessage){2a}
  else if (propName = 'event') then EventList.insertItem(index, propValue as TFhirCapabilityStatementMessagingEvent){2a}
  else inherited;
end;

function TFhirCapabilityStatementMessaging.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'endpoint') then result := EndpointList.new(){2}
  else if (propName = 'reliableCache') then result := TFhirUnsignedInt.create() {5b}
  else if (propName = 'documentation') then result := TFhirString.create() {5b}
  else if (propName = 'supportedMessage') then result := SupportedMessageList.new(){2}
  else if (propName = 'event') then result := EventList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCapabilityStatementMessaging.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'endpoint') then result := ''
  else if (propName = 'reliableCache') then result := 'unsignedInt'
  else if (propName = 'documentation') then result := 'string'
  else if (propName = 'supportedMessage') then result := ''
  else if (propName = 'event') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCapabilityStatementMessaging.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'endpoint') then deletePropertyValue('endpoint', EndpointList, value) {2}
  else if (propName = 'reliableCache') then ReliableCacheElement := nil
  else if (propName = 'documentation') then DocumentationElement := nil
  else if (propName = 'supportedMessage') then deletePropertyValue('supportedMessage', SupportedMessageList, value) {2}
  else if (propName = 'event') then deletePropertyValue('event', EventList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCapabilityStatementMessaging.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'endpoint') then replacePropertyValue('endpoint', EndpointList, existing, new) {2}
  else if (propName = 'reliableCache') then ReliableCacheElement := asUnsignedInt(new){5b}
  else if (propName = 'documentation') then DocumentationElement := asString(new){5b}
  else if (propName = 'supportedMessage') then replacePropertyValue('supportedMessage', SupportedMessageList, existing, new) {2}
  else if (propName = 'event') then replacePropertyValue('event', EventList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCapabilityStatementMessaging.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'endpoint') then EndpointList.move(source, destination){2a}
  else if (propName = 'supportedMessage') then SupportedMessageList.move(source, destination){2a}
  else if (propName = 'event') then EventList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCapabilityStatementMessaging.fhirType : string;
begin
  result := 'messaging';
end;

function TFhirCapabilityStatementMessaging.Link : TFhirCapabilityStatementMessaging;
begin
  result := TFhirCapabilityStatementMessaging(inherited Link);
end;

function TFhirCapabilityStatementMessaging.Clone : TFhirCapabilityStatementMessaging;
begin
  result := TFhirCapabilityStatementMessaging(inherited Clone);
end;

function TFhirCapabilityStatementMessaging.equals(other : TObject) : boolean;
var
  o : TFhirCapabilityStatementMessaging;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCapabilityStatementMessaging)) then
    result := false
  else
  begin
    o := TFhirCapabilityStatementMessaging(other);
    result := compareDeep(endpointList, o.endpointList, true) and compareDeep(reliableCacheElement, o.reliableCacheElement, true) and
      compareDeep(documentationElement, o.documentationElement, true) and compareDeep(supportedMessageList, o.supportedMessageList, true) and
      compareDeep(eventList, o.eventList, true);
  end;
end;

function TFhirCapabilityStatementMessaging.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FendpointList) and isEmptyProp(FReliableCache) and isEmptyProp(FDocumentation) and isEmptyProp(FsupportedMessageList) and isEmptyProp(FeventList);
end;

procedure TFhirCapabilityStatementMessaging.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('endpoint');
  fields.add('reliableCache');
  fields.add('documentation');
  fields.add('supportedMessage');
  fields.add('event');
end;

{ TFhirCapabilityStatementMessaging }

Function TFhirCapabilityStatementMessaging.GetEndpointList : TFhirCapabilityStatementMessagingEndpointList;
begin
  if FEndpointList = nil then
    FEndpointList := TFhirCapabilityStatementMessagingEndpointList.Create;
  result := FEndpointList;
end;

Function TFhirCapabilityStatementMessaging.GetHasEndpointList : boolean;
begin
  result := (FEndpointList <> nil) and (FEndpointList.count > 0);
end;

Procedure TFhirCapabilityStatementMessaging.SetReliableCache(value : TFhirUnsignedInt);
begin
  FReliableCache.free;
  FReliableCache := value;
end;

Function TFhirCapabilityStatementMessaging.GetReliableCacheST : String;
begin
  if FReliableCache = nil then
    result := ''
  else
    result := FReliableCache.value;
end;

Procedure TFhirCapabilityStatementMessaging.SetReliableCacheST(value : String);
begin
  if value <> '' then
  begin
    if FReliableCache = nil then
      FReliableCache := TFhirUnsignedInt.create;
    FReliableCache.value := value
  end
  else if FReliableCache <> nil then
    FReliableCache.value := '';
end;

Procedure TFhirCapabilityStatementMessaging.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirCapabilityStatementMessaging.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

Procedure TFhirCapabilityStatementMessaging.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

Function TFhirCapabilityStatementMessaging.GetSupportedMessageList : TFhirCapabilityStatementMessagingSupportedMessageList;
begin
  if FSupportedMessageList = nil then
    FSupportedMessageList := TFhirCapabilityStatementMessagingSupportedMessageList.Create;
  result := FSupportedMessageList;
end;

Function TFhirCapabilityStatementMessaging.GetHasSupportedMessageList : boolean;
begin
  result := (FSupportedMessageList <> nil) and (FSupportedMessageList.count > 0);
end;

Function TFhirCapabilityStatementMessaging.GetEventList : TFhirCapabilityStatementMessagingEventList;
begin
  if FEventList = nil then
    FEventList := TFhirCapabilityStatementMessagingEventList.Create;
  result := FEventList;
end;

Function TFhirCapabilityStatementMessaging.GetHasEventList : boolean;
begin
  result := (FEventList <> nil) and (FEventList.count > 0);
end;

function TFhirCapabilityStatementMessaging.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FendpointList.sizeInBytes);
  inc(result, FReliableCache.sizeInBytes);
  inc(result, FDocumentation.sizeInBytes);
  inc(result, FsupportedMessageList.sizeInBytes);
  inc(result, FeventList.sizeInBytes);
end;

{ TFhirCapabilityStatementMessagingListEnumerator }

Constructor TFhirCapabilityStatementMessagingListEnumerator.Create(list : TFhirCapabilityStatementMessagingList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCapabilityStatementMessagingListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCapabilityStatementMessagingListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCapabilityStatementMessagingListEnumerator.GetCurrent : TFhirCapabilityStatementMessaging;
begin
  Result := FList[FIndex];
end;

function TFhirCapabilityStatementMessagingListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCapabilityStatementMessagingList }
procedure TFhirCapabilityStatementMessagingList.AddItem(value: TFhirCapabilityStatementMessaging);
begin
  assert(value.ClassName = 'TFhirCapabilityStatementMessaging', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCapabilityStatementMessaging');
  add(value);
end;

function TFhirCapabilityStatementMessagingList.Append: TFhirCapabilityStatementMessaging;
begin
  result := TFhirCapabilityStatementMessaging.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementMessagingList.ClearItems;
begin
  Clear;
end;

function TFhirCapabilityStatementMessagingList.GetEnumerator : TFhirCapabilityStatementMessagingListEnumerator;
begin
  result := TFhirCapabilityStatementMessagingListEnumerator.Create(self.link);
end;

function TFhirCapabilityStatementMessagingList.Clone: TFhirCapabilityStatementMessagingList;
begin
  result := TFhirCapabilityStatementMessagingList(inherited Clone);
end;

function TFhirCapabilityStatementMessagingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCapabilityStatementMessagingList.GetItemN(index: Integer): TFhirCapabilityStatementMessaging;
begin
  result := TFhirCapabilityStatementMessaging(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementMessagingList.ItemClass: TFslObjectClass;
begin
  result := TFhirCapabilityStatementMessaging;
end;
function TFhirCapabilityStatementMessagingList.IndexOf(value: TFhirCapabilityStatementMessaging): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCapabilityStatementMessagingList.Insert(index: Integer): TFhirCapabilityStatementMessaging;
begin
  result := TFhirCapabilityStatementMessaging.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementMessagingList.InsertItem(index: Integer; value: TFhirCapabilityStatementMessaging);
begin
  assert(value is TFhirCapabilityStatementMessaging);
  Inherited Insert(index, value);
end;

function TFhirCapabilityStatementMessagingList.Item(index: Integer): TFhirCapabilityStatementMessaging;
begin
  result := TFhirCapabilityStatementMessaging(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementMessagingList.Link: TFhirCapabilityStatementMessagingList;
begin
  result := TFhirCapabilityStatementMessagingList(inherited Link);
end;

procedure TFhirCapabilityStatementMessagingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCapabilityStatementMessagingList.SetItemByIndex(index: Integer; value: TFhirCapabilityStatementMessaging);
begin
  assert(value is TFhirCapabilityStatementMessaging);
  FhirCapabilityStatementMessagings[index] := value;
end;

procedure TFhirCapabilityStatementMessagingList.SetItemN(index: Integer; value: TFhirCapabilityStatementMessaging);
begin
  assert(value is TFhirCapabilityStatementMessaging);
  ObjectByIndex[index] := value;
end;

{ TFhirCapabilityStatementMessagingEndpoint }

constructor TFhirCapabilityStatementMessagingEndpoint.Create;
begin
  inherited;
end;

destructor TFhirCapabilityStatementMessagingEndpoint.Destroy;
begin
  FProtocol.free;
  FAddress.free;
  inherited;
end;

procedure TFhirCapabilityStatementMessagingEndpoint.Assign(oSource : TFslObject);
begin
  inherited;
  protocol := TFhirCapabilityStatementMessagingEndpoint(oSource).protocol.Clone;
  addressElement := TFhirCapabilityStatementMessagingEndpoint(oSource).addressElement.Clone;
end;

procedure TFhirCapabilityStatementMessagingEndpoint.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'protocol') Then
     list.add(self.link, 'protocol', FProtocol.Link);
  if (child_name = 'address') Then
     list.add(self.link, 'address', FAddress.Link);
end;

procedure TFhirCapabilityStatementMessagingEndpoint.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'protocol', 'Coding', false, TFhirCoding, FProtocol.Link));{2}
  oList.add(TFHIRProperty.create(self, 'address', 'uri', false, TFhirUri, FAddress.Link));{2}
end;

function TFhirCapabilityStatementMessagingEndpoint.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'protocol') then
  begin
    Protocol := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'address') then
  begin
    AddressElement := asUri(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCapabilityStatementMessagingEndpoint.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCapabilityStatementMessagingEndpoint.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'protocol') then result := TFhirCoding.create(){4b}
  else if (propName = 'address') then result := TFhirUri.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCapabilityStatementMessagingEndpoint.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'protocol') then result := 'Coding'
  else if (propName = 'address') then result := 'uri'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCapabilityStatementMessagingEndpoint.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'protocol') then ProtocolElement := nil
  else if (propName = 'address') then AddressElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCapabilityStatementMessagingEndpoint.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'protocol') then ProtocolElement := new as TFhirCoding{4}
  else if (propName = 'address') then AddressElement := asUri(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCapabilityStatementMessagingEndpoint.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCapabilityStatementMessagingEndpoint.fhirType : string;
begin
  result := 'endpoint';
end;

function TFhirCapabilityStatementMessagingEndpoint.Link : TFhirCapabilityStatementMessagingEndpoint;
begin
  result := TFhirCapabilityStatementMessagingEndpoint(inherited Link);
end;

function TFhirCapabilityStatementMessagingEndpoint.Clone : TFhirCapabilityStatementMessagingEndpoint;
begin
  result := TFhirCapabilityStatementMessagingEndpoint(inherited Clone);
end;

function TFhirCapabilityStatementMessagingEndpoint.equals(other : TObject) : boolean;
var
  o : TFhirCapabilityStatementMessagingEndpoint;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCapabilityStatementMessagingEndpoint)) then
    result := false
  else
  begin
    o := TFhirCapabilityStatementMessagingEndpoint(other);
    result := compareDeep(protocolElement, o.protocolElement, true) and compareDeep(addressElement, o.addressElement, true);
  end;
end;

function TFhirCapabilityStatementMessagingEndpoint.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FProtocol) and isEmptyProp(FAddress);
end;

procedure TFhirCapabilityStatementMessagingEndpoint.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('protocol');
  fields.add('address');
end;

{ TFhirCapabilityStatementMessagingEndpoint }

Procedure TFhirCapabilityStatementMessagingEndpoint.SetProtocol(value : TFhirCoding);
begin
  FProtocol.free;
  FProtocol := value;
end;

Procedure TFhirCapabilityStatementMessagingEndpoint.SetAddress(value : TFhirUri);
begin
  FAddress.free;
  FAddress := value;
end;

Function TFhirCapabilityStatementMessagingEndpoint.GetAddressST : String;
begin
  if FAddress = nil then
    result := ''
  else
    result := FAddress.value;
end;

Procedure TFhirCapabilityStatementMessagingEndpoint.SetAddressST(value : String);
begin
  if value <> '' then
  begin
    if FAddress = nil then
      FAddress := TFhirUri.create;
    FAddress.value := value
  end
  else if FAddress <> nil then
    FAddress.value := '';
end;

function TFhirCapabilityStatementMessagingEndpoint.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FProtocol.sizeInBytes);
  inc(result, FAddress.sizeInBytes);
end;

{ TFhirCapabilityStatementMessagingEndpointListEnumerator }

Constructor TFhirCapabilityStatementMessagingEndpointListEnumerator.Create(list : TFhirCapabilityStatementMessagingEndpointList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCapabilityStatementMessagingEndpointListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCapabilityStatementMessagingEndpointListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCapabilityStatementMessagingEndpointListEnumerator.GetCurrent : TFhirCapabilityStatementMessagingEndpoint;
begin
  Result := FList[FIndex];
end;

function TFhirCapabilityStatementMessagingEndpointListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCapabilityStatementMessagingEndpointList }
procedure TFhirCapabilityStatementMessagingEndpointList.AddItem(value: TFhirCapabilityStatementMessagingEndpoint);
begin
  assert(value.ClassName = 'TFhirCapabilityStatementMessagingEndpoint', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCapabilityStatementMessagingEndpoint');
  add(value);
end;

function TFhirCapabilityStatementMessagingEndpointList.Append: TFhirCapabilityStatementMessagingEndpoint;
begin
  result := TFhirCapabilityStatementMessagingEndpoint.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementMessagingEndpointList.ClearItems;
begin
  Clear;
end;

function TFhirCapabilityStatementMessagingEndpointList.GetEnumerator : TFhirCapabilityStatementMessagingEndpointListEnumerator;
begin
  result := TFhirCapabilityStatementMessagingEndpointListEnumerator.Create(self.link);
end;

function TFhirCapabilityStatementMessagingEndpointList.Clone: TFhirCapabilityStatementMessagingEndpointList;
begin
  result := TFhirCapabilityStatementMessagingEndpointList(inherited Clone);
end;

function TFhirCapabilityStatementMessagingEndpointList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCapabilityStatementMessagingEndpointList.GetItemN(index: Integer): TFhirCapabilityStatementMessagingEndpoint;
begin
  result := TFhirCapabilityStatementMessagingEndpoint(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementMessagingEndpointList.ItemClass: TFslObjectClass;
begin
  result := TFhirCapabilityStatementMessagingEndpoint;
end;
function TFhirCapabilityStatementMessagingEndpointList.IndexOf(value: TFhirCapabilityStatementMessagingEndpoint): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCapabilityStatementMessagingEndpointList.Insert(index: Integer): TFhirCapabilityStatementMessagingEndpoint;
begin
  result := TFhirCapabilityStatementMessagingEndpoint.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementMessagingEndpointList.InsertItem(index: Integer; value: TFhirCapabilityStatementMessagingEndpoint);
begin
  assert(value is TFhirCapabilityStatementMessagingEndpoint);
  Inherited Insert(index, value);
end;

function TFhirCapabilityStatementMessagingEndpointList.Item(index: Integer): TFhirCapabilityStatementMessagingEndpoint;
begin
  result := TFhirCapabilityStatementMessagingEndpoint(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementMessagingEndpointList.Link: TFhirCapabilityStatementMessagingEndpointList;
begin
  result := TFhirCapabilityStatementMessagingEndpointList(inherited Link);
end;

procedure TFhirCapabilityStatementMessagingEndpointList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCapabilityStatementMessagingEndpointList.SetItemByIndex(index: Integer; value: TFhirCapabilityStatementMessagingEndpoint);
begin
  assert(value is TFhirCapabilityStatementMessagingEndpoint);
  FhirCapabilityStatementMessagingEndpoints[index] := value;
end;

procedure TFhirCapabilityStatementMessagingEndpointList.SetItemN(index: Integer; value: TFhirCapabilityStatementMessagingEndpoint);
begin
  assert(value is TFhirCapabilityStatementMessagingEndpoint);
  ObjectByIndex[index] := value;
end;

{ TFhirCapabilityStatementMessagingSupportedMessage }

constructor TFhirCapabilityStatementMessagingSupportedMessage.Create;
begin
  inherited;
end;

destructor TFhirCapabilityStatementMessagingSupportedMessage.Destroy;
begin
  FMode.free;
  FDefinition.free;
  inherited;
end;

procedure TFhirCapabilityStatementMessagingSupportedMessage.Assign(oSource : TFslObject);
begin
  inherited;
  FMode := TFhirCapabilityStatementMessagingSupportedMessage(oSource).FMode.Link;
  definition := TFhirCapabilityStatementMessagingSupportedMessage(oSource).definition.Clone;
end;

procedure TFhirCapabilityStatementMessagingSupportedMessage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'mode') Then
     list.add(self.link, 'mode', FMode.Link);
  if (child_name = 'definition') Then
     list.add(self.link, 'definition', FDefinition.Link);
end;

procedure TFhirCapabilityStatementMessagingSupportedMessage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'mode', 'code', false, TFHIREnum, FMode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'definition', 'Reference(MessageDefinition)', false, TFhirReference{TFhirMessageDefinition}, FDefinition.Link));{2}
end;

function TFhirCapabilityStatementMessagingSupportedMessage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'mode') then
  begin
    ModeElement := asEnum(SYSTEMS_TFhirEventCapabilityModeEnum, CODES_TFhirEventCapabilityModeEnum, propValue);
    result := propValue
  end
  else if (propName = 'definition') then
  begin
    Definition := propValue as TFhirReference{TFhirMessageDefinition}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCapabilityStatementMessagingSupportedMessage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCapabilityStatementMessagingSupportedMessage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'definition') then result := TFhirReference{TFhirMessageDefinition}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCapabilityStatementMessagingSupportedMessage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'mode') then result := 'code'
  else if (propName = 'definition') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCapabilityStatementMessagingSupportedMessage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'mode') then ModeElement := nil
  else if (propName = 'definition') then DefinitionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCapabilityStatementMessagingSupportedMessage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'mode') then ModeElement := asEnum(SYSTEMS_TFhirEventCapabilityModeEnum, CODES_TFhirEventCapabilityModeEnum, new){4}
  else if (propName = 'definition') then DefinitionElement := new as TFhirReference{TFhirMessageDefinition}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCapabilityStatementMessagingSupportedMessage.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCapabilityStatementMessagingSupportedMessage.fhirType : string;
begin
  result := 'supportedMessage';
end;

function TFhirCapabilityStatementMessagingSupportedMessage.Link : TFhirCapabilityStatementMessagingSupportedMessage;
begin
  result := TFhirCapabilityStatementMessagingSupportedMessage(inherited Link);
end;

function TFhirCapabilityStatementMessagingSupportedMessage.Clone : TFhirCapabilityStatementMessagingSupportedMessage;
begin
  result := TFhirCapabilityStatementMessagingSupportedMessage(inherited Clone);
end;

function TFhirCapabilityStatementMessagingSupportedMessage.equals(other : TObject) : boolean;
var
  o : TFhirCapabilityStatementMessagingSupportedMessage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCapabilityStatementMessagingSupportedMessage)) then
    result := false
  else
  begin
    o := TFhirCapabilityStatementMessagingSupportedMessage(other);
    result := compareDeep(modeElement, o.modeElement, true) and compareDeep(definitionElement, o.definitionElement, true);
  end;
end;

function TFhirCapabilityStatementMessagingSupportedMessage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMode) and isEmptyProp(FDefinition);
end;

procedure TFhirCapabilityStatementMessagingSupportedMessage.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('mode');
  fields.add('definition');
end;

{ TFhirCapabilityStatementMessagingSupportedMessage }

Procedure TFhirCapabilityStatementMessagingSupportedMessage.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

Function TFhirCapabilityStatementMessagingSupportedMessage.GetModeST : TFhirEventCapabilityModeEnum;
begin
  if FMode = nil then
    result := TFhirEventCapabilityModeEnum(0)
  else
    result := TFhirEventCapabilityModeEnum(StringArrayIndexOfSensitive(CODES_TFhirEventCapabilityModeEnum, FMode.value));
end;

Procedure TFhirCapabilityStatementMessagingSupportedMessage.SetModeST(value : TFhirEventCapabilityModeEnum);
begin
  if ord(value) = 0 then
    ModeElement := nil
  else
    ModeElement := TFhirEnum.create(SYSTEMS_TFhirEventCapabilityModeEnum[value], CODES_TFhirEventCapabilityModeEnum[value]);
end;

Procedure TFhirCapabilityStatementMessagingSupportedMessage.SetDefinition(value : TFhirReference{TFhirMessageDefinition});
begin
  FDefinition.free;
  FDefinition := value;
end;

function TFhirCapabilityStatementMessagingSupportedMessage.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FMode.sizeInBytes);
  inc(result, FDefinition.sizeInBytes);
end;

{ TFhirCapabilityStatementMessagingSupportedMessageListEnumerator }

Constructor TFhirCapabilityStatementMessagingSupportedMessageListEnumerator.Create(list : TFhirCapabilityStatementMessagingSupportedMessageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCapabilityStatementMessagingSupportedMessageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCapabilityStatementMessagingSupportedMessageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCapabilityStatementMessagingSupportedMessageListEnumerator.GetCurrent : TFhirCapabilityStatementMessagingSupportedMessage;
begin
  Result := FList[FIndex];
end;

function TFhirCapabilityStatementMessagingSupportedMessageListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCapabilityStatementMessagingSupportedMessageList }
procedure TFhirCapabilityStatementMessagingSupportedMessageList.AddItem(value: TFhirCapabilityStatementMessagingSupportedMessage);
begin
  assert(value.ClassName = 'TFhirCapabilityStatementMessagingSupportedMessage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCapabilityStatementMessagingSupportedMessage');
  add(value);
end;

function TFhirCapabilityStatementMessagingSupportedMessageList.Append: TFhirCapabilityStatementMessagingSupportedMessage;
begin
  result := TFhirCapabilityStatementMessagingSupportedMessage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementMessagingSupportedMessageList.ClearItems;
begin
  Clear;
end;

function TFhirCapabilityStatementMessagingSupportedMessageList.GetEnumerator : TFhirCapabilityStatementMessagingSupportedMessageListEnumerator;
begin
  result := TFhirCapabilityStatementMessagingSupportedMessageListEnumerator.Create(self.link);
end;

function TFhirCapabilityStatementMessagingSupportedMessageList.Clone: TFhirCapabilityStatementMessagingSupportedMessageList;
begin
  result := TFhirCapabilityStatementMessagingSupportedMessageList(inherited Clone);
end;

function TFhirCapabilityStatementMessagingSupportedMessageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCapabilityStatementMessagingSupportedMessageList.GetItemN(index: Integer): TFhirCapabilityStatementMessagingSupportedMessage;
begin
  result := TFhirCapabilityStatementMessagingSupportedMessage(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementMessagingSupportedMessageList.ItemClass: TFslObjectClass;
begin
  result := TFhirCapabilityStatementMessagingSupportedMessage;
end;
function TFhirCapabilityStatementMessagingSupportedMessageList.IndexOf(value: TFhirCapabilityStatementMessagingSupportedMessage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCapabilityStatementMessagingSupportedMessageList.Insert(index: Integer): TFhirCapabilityStatementMessagingSupportedMessage;
begin
  result := TFhirCapabilityStatementMessagingSupportedMessage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementMessagingSupportedMessageList.InsertItem(index: Integer; value: TFhirCapabilityStatementMessagingSupportedMessage);
begin
  assert(value is TFhirCapabilityStatementMessagingSupportedMessage);
  Inherited Insert(index, value);
end;

function TFhirCapabilityStatementMessagingSupportedMessageList.Item(index: Integer): TFhirCapabilityStatementMessagingSupportedMessage;
begin
  result := TFhirCapabilityStatementMessagingSupportedMessage(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementMessagingSupportedMessageList.Link: TFhirCapabilityStatementMessagingSupportedMessageList;
begin
  result := TFhirCapabilityStatementMessagingSupportedMessageList(inherited Link);
end;

procedure TFhirCapabilityStatementMessagingSupportedMessageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCapabilityStatementMessagingSupportedMessageList.SetItemByIndex(index: Integer; value: TFhirCapabilityStatementMessagingSupportedMessage);
begin
  assert(value is TFhirCapabilityStatementMessagingSupportedMessage);
  FhirCapabilityStatementMessagingSupportedMessages[index] := value;
end;

procedure TFhirCapabilityStatementMessagingSupportedMessageList.SetItemN(index: Integer; value: TFhirCapabilityStatementMessagingSupportedMessage);
begin
  assert(value is TFhirCapabilityStatementMessagingSupportedMessage);
  ObjectByIndex[index] := value;
end;

{ TFhirCapabilityStatementMessagingEvent }

constructor TFhirCapabilityStatementMessagingEvent.Create;
begin
  inherited;
end;

destructor TFhirCapabilityStatementMessagingEvent.Destroy;
begin
  FCode.free;
  FCategory.free;
  FMode.free;
  FFocus.free;
  FRequest.free;
  FResponse.free;
  FDocumentation.free;
  inherited;
end;

procedure TFhirCapabilityStatementMessagingEvent.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirCapabilityStatementMessagingEvent(oSource).code.Clone;
  FCategory := TFhirCapabilityStatementMessagingEvent(oSource).FCategory.Link;
  FMode := TFhirCapabilityStatementMessagingEvent(oSource).FMode.Link;
  FFocus := TFhirCapabilityStatementMessagingEvent(oSource).FFocus.Link;
  request := TFhirCapabilityStatementMessagingEvent(oSource).request.Clone;
  response := TFhirCapabilityStatementMessagingEvent(oSource).response.Clone;
  documentationElement := TFhirCapabilityStatementMessagingEvent(oSource).documentationElement.Clone;
end;

procedure TFhirCapabilityStatementMessagingEvent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'mode') Then
     list.add(self.link, 'mode', FMode.Link);
  if (child_name = 'focus') Then
     list.add(self.link, 'focus', FFocus.Link);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'response') Then
     list.add(self.link, 'response', FResponse.Link);
  if (child_name = 'documentation') Then
     list.add(self.link, 'documentation', FDocumentation.Link);
end;

procedure TFhirCapabilityStatementMessagingEvent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'Coding', false, TFhirCoding, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'category', 'code', false, TFHIREnum, FCategory.Link));{1}
  oList.add(TFHIRProperty.create(self, 'mode', 'code', false, TFHIREnum, FMode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'focus', 'code', false, TFHIREnum, FFocus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'request', 'Reference(StructureDefinition)', false, TFhirReference{TFhirStructureDefinition}, FRequest.Link));{2}
  oList.add(TFHIRProperty.create(self, 'response', 'Reference(StructureDefinition)', false, TFhirReference{TFhirStructureDefinition}, FResponse.Link));{2}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', false, TFhirString, FDocumentation.Link));{2}
end;

function TFhirCapabilityStatementMessagingEvent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryElement := asEnum(SYSTEMS_TFhirMessageSignificanceCategoryEnum, CODES_TFhirMessageSignificanceCategoryEnum, propValue);
    result := propValue
  end
  else if (propName = 'mode') then
  begin
    ModeElement := asEnum(SYSTEMS_TFhirEventCapabilityModeEnum, CODES_TFhirEventCapabilityModeEnum, propValue);
    result := propValue
  end
  else if (propName = 'focus') then
  begin
    FocusElement := asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue);
    result := propValue
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirReference{TFhirStructureDefinition}{4b};
    result := propValue;
  end
  else if (propName = 'response') then
  begin
    Response := propValue as TFhirReference{TFhirStructureDefinition}{4b};
    result := propValue;
  end
  else if (propName = 'documentation') then
  begin
    DocumentationElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCapabilityStatementMessagingEvent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCapabilityStatementMessagingEvent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCoding.create(){4b}
  else if (propName = 'request') then result := TFhirReference{TFhirStructureDefinition}.create(){4b}
  else if (propName = 'response') then result := TFhirReference{TFhirStructureDefinition}.create(){4b}
  else if (propName = 'documentation') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCapabilityStatementMessagingEvent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'Coding'
  else if (propName = 'category') then result := 'code'
  else if (propName = 'mode') then result := 'code'
  else if (propName = 'focus') then result := 'code'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'response') then result := 'Reference'
  else if (propName = 'documentation') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCapabilityStatementMessagingEvent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'mode') then ModeElement := nil
  else if (propName = 'focus') then FocusElement := nil
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'response') then ResponseElement := nil
  else if (propName = 'documentation') then DocumentationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCapabilityStatementMessagingEvent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCoding{4}
  else if (propName = 'category') then CategoryElement := asEnum(SYSTEMS_TFhirMessageSignificanceCategoryEnum, CODES_TFhirMessageSignificanceCategoryEnum, new){4}
  else if (propName = 'mode') then ModeElement := asEnum(SYSTEMS_TFhirEventCapabilityModeEnum, CODES_TFhirEventCapabilityModeEnum, new){4}
  else if (propName = 'focus') then FocusElement := asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, new){4}
  else if (propName = 'request') then RequestElement := new as TFhirReference{TFhirStructureDefinition}{4}
  else if (propName = 'response') then ResponseElement := new as TFhirReference{TFhirStructureDefinition}{4}
  else if (propName = 'documentation') then DocumentationElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCapabilityStatementMessagingEvent.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCapabilityStatementMessagingEvent.fhirType : string;
begin
  result := 'event';
end;

function TFhirCapabilityStatementMessagingEvent.Link : TFhirCapabilityStatementMessagingEvent;
begin
  result := TFhirCapabilityStatementMessagingEvent(inherited Link);
end;

function TFhirCapabilityStatementMessagingEvent.Clone : TFhirCapabilityStatementMessagingEvent;
begin
  result := TFhirCapabilityStatementMessagingEvent(inherited Clone);
end;

function TFhirCapabilityStatementMessagingEvent.equals(other : TObject) : boolean;
var
  o : TFhirCapabilityStatementMessagingEvent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCapabilityStatementMessagingEvent)) then
    result := false
  else
  begin
    o := TFhirCapabilityStatementMessagingEvent(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(categoryElement, o.categoryElement, true) and
      compareDeep(modeElement, o.modeElement, true) and compareDeep(focusElement, o.focusElement, true) and
      compareDeep(requestElement, o.requestElement, true) and compareDeep(responseElement, o.responseElement, true) and
      compareDeep(documentationElement, o.documentationElement, true);
  end;
end;

function TFhirCapabilityStatementMessagingEvent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FCategory) and isEmptyProp(FMode) and isEmptyProp(FFocus) and isEmptyProp(FRequest) and isEmptyProp(FResponse) and isEmptyProp(FDocumentation);
end;

procedure TFhirCapabilityStatementMessagingEvent.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('category');
  fields.add('mode');
  fields.add('focus');
  fields.add('request');
  fields.add('response');
  fields.add('documentation');
end;

{ TFhirCapabilityStatementMessagingEvent }

Procedure TFhirCapabilityStatementMessagingEvent.SetCode(value : TFhirCoding);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirCapabilityStatementMessagingEvent.SetCategory(value : TFhirEnum);
begin
  FCategory.free;
  FCategory := value;
end;

Function TFhirCapabilityStatementMessagingEvent.GetCategoryST : TFhirMessageSignificanceCategoryEnum;
begin
  if FCategory = nil then
    result := TFhirMessageSignificanceCategoryEnum(0)
  else
    result := TFhirMessageSignificanceCategoryEnum(StringArrayIndexOfSensitive(CODES_TFhirMessageSignificanceCategoryEnum, FCategory.value));
end;

Procedure TFhirCapabilityStatementMessagingEvent.SetCategoryST(value : TFhirMessageSignificanceCategoryEnum);
begin
  if ord(value) = 0 then
    CategoryElement := nil
  else
    CategoryElement := TFhirEnum.create(SYSTEMS_TFhirMessageSignificanceCategoryEnum[value], CODES_TFhirMessageSignificanceCategoryEnum[value]);
end;

Procedure TFhirCapabilityStatementMessagingEvent.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

Function TFhirCapabilityStatementMessagingEvent.GetModeST : TFhirEventCapabilityModeEnum;
begin
  if FMode = nil then
    result := TFhirEventCapabilityModeEnum(0)
  else
    result := TFhirEventCapabilityModeEnum(StringArrayIndexOfSensitive(CODES_TFhirEventCapabilityModeEnum, FMode.value));
end;

Procedure TFhirCapabilityStatementMessagingEvent.SetModeST(value : TFhirEventCapabilityModeEnum);
begin
  if ord(value) = 0 then
    ModeElement := nil
  else
    ModeElement := TFhirEnum.create(SYSTEMS_TFhirEventCapabilityModeEnum[value], CODES_TFhirEventCapabilityModeEnum[value]);
end;

Procedure TFhirCapabilityStatementMessagingEvent.SetFocus(value : TFhirEnum);
begin
  FFocus.free;
  FFocus := value;
end;

Function TFhirCapabilityStatementMessagingEvent.GetFocusST : TFhirResourceTypesEnum;
begin
  if FFocus = nil then
    result := TFhirResourceTypesEnum(0)
  else
    result := TFhirResourceTypesEnum(StringArrayIndexOfSensitive(CODES_TFhirResourceTypesEnum, FFocus.value));
end;

Procedure TFhirCapabilityStatementMessagingEvent.SetFocusST(value : TFhirResourceTypesEnum);
begin
  if ord(value) = 0 then
    FocusElement := nil
  else
    FocusElement := TFhirEnum.create(SYSTEMS_TFhirResourceTypesEnum[value], CODES_TFhirResourceTypesEnum[value]);
end;

Procedure TFhirCapabilityStatementMessagingEvent.SetRequest(value : TFhirReference{TFhirStructureDefinition});
begin
  FRequest.free;
  FRequest := value;
end;

Procedure TFhirCapabilityStatementMessagingEvent.SetResponse(value : TFhirReference{TFhirStructureDefinition});
begin
  FResponse.free;
  FResponse := value;
end;

Procedure TFhirCapabilityStatementMessagingEvent.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirCapabilityStatementMessagingEvent.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

Procedure TFhirCapabilityStatementMessagingEvent.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

function TFhirCapabilityStatementMessagingEvent.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FMode.sizeInBytes);
  inc(result, FFocus.sizeInBytes);
  inc(result, FRequest.sizeInBytes);
  inc(result, FResponse.sizeInBytes);
  inc(result, FDocumentation.sizeInBytes);
end;

{ TFhirCapabilityStatementMessagingEventListEnumerator }

Constructor TFhirCapabilityStatementMessagingEventListEnumerator.Create(list : TFhirCapabilityStatementMessagingEventList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCapabilityStatementMessagingEventListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCapabilityStatementMessagingEventListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCapabilityStatementMessagingEventListEnumerator.GetCurrent : TFhirCapabilityStatementMessagingEvent;
begin
  Result := FList[FIndex];
end;

function TFhirCapabilityStatementMessagingEventListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCapabilityStatementMessagingEventList }
procedure TFhirCapabilityStatementMessagingEventList.AddItem(value: TFhirCapabilityStatementMessagingEvent);
begin
  assert(value.ClassName = 'TFhirCapabilityStatementMessagingEvent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCapabilityStatementMessagingEvent');
  add(value);
end;

function TFhirCapabilityStatementMessagingEventList.Append: TFhirCapabilityStatementMessagingEvent;
begin
  result := TFhirCapabilityStatementMessagingEvent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementMessagingEventList.ClearItems;
begin
  Clear;
end;

function TFhirCapabilityStatementMessagingEventList.GetEnumerator : TFhirCapabilityStatementMessagingEventListEnumerator;
begin
  result := TFhirCapabilityStatementMessagingEventListEnumerator.Create(self.link);
end;

function TFhirCapabilityStatementMessagingEventList.Clone: TFhirCapabilityStatementMessagingEventList;
begin
  result := TFhirCapabilityStatementMessagingEventList(inherited Clone);
end;

function TFhirCapabilityStatementMessagingEventList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCapabilityStatementMessagingEventList.GetItemN(index: Integer): TFhirCapabilityStatementMessagingEvent;
begin
  result := TFhirCapabilityStatementMessagingEvent(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementMessagingEventList.ItemClass: TFslObjectClass;
begin
  result := TFhirCapabilityStatementMessagingEvent;
end;
function TFhirCapabilityStatementMessagingEventList.IndexOf(value: TFhirCapabilityStatementMessagingEvent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCapabilityStatementMessagingEventList.Insert(index: Integer): TFhirCapabilityStatementMessagingEvent;
begin
  result := TFhirCapabilityStatementMessagingEvent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementMessagingEventList.InsertItem(index: Integer; value: TFhirCapabilityStatementMessagingEvent);
begin
  assert(value is TFhirCapabilityStatementMessagingEvent);
  Inherited Insert(index, value);
end;

function TFhirCapabilityStatementMessagingEventList.Item(index: Integer): TFhirCapabilityStatementMessagingEvent;
begin
  result := TFhirCapabilityStatementMessagingEvent(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementMessagingEventList.Link: TFhirCapabilityStatementMessagingEventList;
begin
  result := TFhirCapabilityStatementMessagingEventList(inherited Link);
end;

procedure TFhirCapabilityStatementMessagingEventList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCapabilityStatementMessagingEventList.SetItemByIndex(index: Integer; value: TFhirCapabilityStatementMessagingEvent);
begin
  assert(value is TFhirCapabilityStatementMessagingEvent);
  FhirCapabilityStatementMessagingEvents[index] := value;
end;

procedure TFhirCapabilityStatementMessagingEventList.SetItemN(index: Integer; value: TFhirCapabilityStatementMessagingEvent);
begin
  assert(value is TFhirCapabilityStatementMessagingEvent);
  ObjectByIndex[index] := value;
end;

{ TFhirCapabilityStatementDocument }

constructor TFhirCapabilityStatementDocument.Create;
begin
  inherited;
end;

destructor TFhirCapabilityStatementDocument.Destroy;
begin
  FMode.free;
  FDocumentation.free;
  FProfile.free;
  inherited;
end;

procedure TFhirCapabilityStatementDocument.Assign(oSource : TFslObject);
begin
  inherited;
  FMode := TFhirCapabilityStatementDocument(oSource).FMode.Link;
  documentationElement := TFhirCapabilityStatementDocument(oSource).documentationElement.Clone;
  profile := TFhirCapabilityStatementDocument(oSource).profile.Clone;
end;

procedure TFhirCapabilityStatementDocument.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'mode') Then
     list.add(self.link, 'mode', FMode.Link);
  if (child_name = 'documentation') Then
     list.add(self.link, 'documentation', FDocumentation.Link);
  if (child_name = 'profile') Then
     list.add(self.link, 'profile', FProfile.Link);
end;

procedure TFhirCapabilityStatementDocument.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'mode', 'code', false, TFHIREnum, FMode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', false, TFhirString, FDocumentation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'profile', 'Reference(StructureDefinition)', false, TFhirReference{TFhirStructureDefinition}, FProfile.Link));{2}
end;

function TFhirCapabilityStatementDocument.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'mode') then
  begin
    ModeElement := asEnum(SYSTEMS_TFhirDocumentModeEnum, CODES_TFhirDocumentModeEnum, propValue);
    result := propValue
  end
  else if (propName = 'documentation') then
  begin
    DocumentationElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'profile') then
  begin
    Profile := propValue as TFhirReference{TFhirStructureDefinition}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCapabilityStatementDocument.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCapabilityStatementDocument.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'documentation') then result := TFhirString.create() {5b}
  else if (propName = 'profile') then result := TFhirReference{TFhirStructureDefinition}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCapabilityStatementDocument.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'mode') then result := 'code'
  else if (propName = 'documentation') then result := 'string'
  else if (propName = 'profile') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCapabilityStatementDocument.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'mode') then ModeElement := nil
  else if (propName = 'documentation') then DocumentationElement := nil
  else if (propName = 'profile') then ProfileElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCapabilityStatementDocument.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'mode') then ModeElement := asEnum(SYSTEMS_TFhirDocumentModeEnum, CODES_TFhirDocumentModeEnum, new){4}
  else if (propName = 'documentation') then DocumentationElement := asString(new){5b}
  else if (propName = 'profile') then ProfileElement := new as TFhirReference{TFhirStructureDefinition}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCapabilityStatementDocument.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCapabilityStatementDocument.fhirType : string;
begin
  result := 'document';
end;

function TFhirCapabilityStatementDocument.Link : TFhirCapabilityStatementDocument;
begin
  result := TFhirCapabilityStatementDocument(inherited Link);
end;

function TFhirCapabilityStatementDocument.Clone : TFhirCapabilityStatementDocument;
begin
  result := TFhirCapabilityStatementDocument(inherited Clone);
end;

function TFhirCapabilityStatementDocument.equals(other : TObject) : boolean;
var
  o : TFhirCapabilityStatementDocument;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCapabilityStatementDocument)) then
    result := false
  else
  begin
    o := TFhirCapabilityStatementDocument(other);
    result := compareDeep(modeElement, o.modeElement, true) and compareDeep(documentationElement, o.documentationElement, true) and
      compareDeep(profileElement, o.profileElement, true);
  end;
end;

function TFhirCapabilityStatementDocument.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMode) and isEmptyProp(FDocumentation) and isEmptyProp(FProfile);
end;

procedure TFhirCapabilityStatementDocument.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('mode');
  fields.add('documentation');
  fields.add('profile');
end;

{ TFhirCapabilityStatementDocument }

Procedure TFhirCapabilityStatementDocument.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

Function TFhirCapabilityStatementDocument.GetModeST : TFhirDocumentModeEnum;
begin
  if FMode = nil then
    result := TFhirDocumentModeEnum(0)
  else
    result := TFhirDocumentModeEnum(StringArrayIndexOfSensitive(CODES_TFhirDocumentModeEnum, FMode.value));
end;

Procedure TFhirCapabilityStatementDocument.SetModeST(value : TFhirDocumentModeEnum);
begin
  if ord(value) = 0 then
    ModeElement := nil
  else
    ModeElement := TFhirEnum.create(SYSTEMS_TFhirDocumentModeEnum[value], CODES_TFhirDocumentModeEnum[value]);
end;

Procedure TFhirCapabilityStatementDocument.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirCapabilityStatementDocument.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

Procedure TFhirCapabilityStatementDocument.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

Procedure TFhirCapabilityStatementDocument.SetProfile(value : TFhirReference{TFhirStructureDefinition});
begin
  FProfile.free;
  FProfile := value;
end;

function TFhirCapabilityStatementDocument.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FMode.sizeInBytes);
  inc(result, FDocumentation.sizeInBytes);
  inc(result, FProfile.sizeInBytes);
end;

{ TFhirCapabilityStatementDocumentListEnumerator }

Constructor TFhirCapabilityStatementDocumentListEnumerator.Create(list : TFhirCapabilityStatementDocumentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCapabilityStatementDocumentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCapabilityStatementDocumentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCapabilityStatementDocumentListEnumerator.GetCurrent : TFhirCapabilityStatementDocument;
begin
  Result := FList[FIndex];
end;

function TFhirCapabilityStatementDocumentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCapabilityStatementDocumentList }
procedure TFhirCapabilityStatementDocumentList.AddItem(value: TFhirCapabilityStatementDocument);
begin
  assert(value.ClassName = 'TFhirCapabilityStatementDocument', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCapabilityStatementDocument');
  add(value);
end;

function TFhirCapabilityStatementDocumentList.Append: TFhirCapabilityStatementDocument;
begin
  result := TFhirCapabilityStatementDocument.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementDocumentList.ClearItems;
begin
  Clear;
end;

function TFhirCapabilityStatementDocumentList.GetEnumerator : TFhirCapabilityStatementDocumentListEnumerator;
begin
  result := TFhirCapabilityStatementDocumentListEnumerator.Create(self.link);
end;

function TFhirCapabilityStatementDocumentList.Clone: TFhirCapabilityStatementDocumentList;
begin
  result := TFhirCapabilityStatementDocumentList(inherited Clone);
end;

function TFhirCapabilityStatementDocumentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCapabilityStatementDocumentList.GetItemN(index: Integer): TFhirCapabilityStatementDocument;
begin
  result := TFhirCapabilityStatementDocument(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementDocumentList.ItemClass: TFslObjectClass;
begin
  result := TFhirCapabilityStatementDocument;
end;
function TFhirCapabilityStatementDocumentList.IndexOf(value: TFhirCapabilityStatementDocument): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCapabilityStatementDocumentList.Insert(index: Integer): TFhirCapabilityStatementDocument;
begin
  result := TFhirCapabilityStatementDocument.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementDocumentList.InsertItem(index: Integer; value: TFhirCapabilityStatementDocument);
begin
  assert(value is TFhirCapabilityStatementDocument);
  Inherited Insert(index, value);
end;

function TFhirCapabilityStatementDocumentList.Item(index: Integer): TFhirCapabilityStatementDocument;
begin
  result := TFhirCapabilityStatementDocument(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementDocumentList.Link: TFhirCapabilityStatementDocumentList;
begin
  result := TFhirCapabilityStatementDocumentList(inherited Link);
end;

procedure TFhirCapabilityStatementDocumentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCapabilityStatementDocumentList.SetItemByIndex(index: Integer; value: TFhirCapabilityStatementDocument);
begin
  assert(value is TFhirCapabilityStatementDocument);
  FhirCapabilityStatementDocuments[index] := value;
end;

procedure TFhirCapabilityStatementDocumentList.SetItemN(index: Integer; value: TFhirCapabilityStatementDocument);
begin
  assert(value is TFhirCapabilityStatementDocument);
  ObjectByIndex[index] := value;
end;

{ TFhirCapabilityStatement }

constructor TFhirCapabilityStatement.Create;
begin
  inherited;
end;

destructor TFhirCapabilityStatement.Destroy;
begin
  FPurpose.free;
  FCopyright.free;
  FKind.free;
  FInstantiatesList.Free;
  FSoftware.free;
  FImplementation_.free;
  FFhirVersion.free;
  FAcceptUnknown.free;
  FFormatList.Free;
  FPatchFormatList.Free;
  FImplementationGuideList.Free;
  FProfileList.Free;
  FRestList.Free;
  FMessagingList.Free;
  FDocumentList.Free;
  inherited;
end;

function TFhirCapabilityStatement.GetResourceType : TFhirResourceType;
begin
  result := frtCapabilityStatement;
end;

procedure TFhirCapabilityStatement.Assign(oSource : TFslObject);
begin
  inherited;
  purposeElement := TFhirCapabilityStatement(oSource).purposeElement.Clone;
  copyrightElement := TFhirCapabilityStatement(oSource).copyrightElement.Clone;
  FKind := TFhirCapabilityStatement(oSource).FKind.Link;
  if (TFhirCapabilityStatement(oSource).FInstantiatesList = nil) then
  begin
    FInstantiatesList.free;
    FInstantiatesList := nil;
  end
  else
  begin
    if FInstantiatesList = nil then
      FInstantiatesList := TFhirUriList.Create;
    FInstantiatesList.Assign(TFhirCapabilityStatement(oSource).FInstantiatesList);
  end;
  software := TFhirCapabilityStatement(oSource).software.Clone;
  implementation_ := TFhirCapabilityStatement(oSource).implementation_.Clone;
  fhirVersionElement := TFhirCapabilityStatement(oSource).fhirVersionElement.Clone;
  FAcceptUnknown := TFhirCapabilityStatement(oSource).FAcceptUnknown.Link;
  if (TFhirCapabilityStatement(oSource).FFormatList = nil) then
  begin
    FFormatList.free;
    FFormatList := nil;
  end
  else
  begin
    if FFormatList = nil then
      FFormatList := TFhirCodeList.Create;
    FFormatList.Assign(TFhirCapabilityStatement(oSource).FFormatList);
  end;
  if (TFhirCapabilityStatement(oSource).FPatchFormatList = nil) then
  begin
    FPatchFormatList.free;
    FPatchFormatList := nil;
  end
  else
  begin
    if FPatchFormatList = nil then
      FPatchFormatList := TFhirCodeList.Create;
    FPatchFormatList.Assign(TFhirCapabilityStatement(oSource).FPatchFormatList);
  end;
  if (TFhirCapabilityStatement(oSource).FImplementationGuideList = nil) then
  begin
    FImplementationGuideList.free;
    FImplementationGuideList := nil;
  end
  else
  begin
    if FImplementationGuideList = nil then
      FImplementationGuideList := TFhirUriList.Create;
    FImplementationGuideList.Assign(TFhirCapabilityStatement(oSource).FImplementationGuideList);
  end;
  if (TFhirCapabilityStatement(oSource).FProfileList = nil) then
  begin
    FProfileList.free;
    FProfileList := nil;
  end
  else
  begin
    if FProfileList = nil then
      FProfileList := TFhirReferenceList{TFhirStructureDefinition}.Create;
    FProfileList.Assign(TFhirCapabilityStatement(oSource).FProfileList);
  end;
  if (TFhirCapabilityStatement(oSource).FRestList = nil) then
  begin
    FRestList.free;
    FRestList := nil;
  end
  else
  begin
    if FRestList = nil then
      FRestList := TFhirCapabilityStatementRestList.Create;
    FRestList.Assign(TFhirCapabilityStatement(oSource).FRestList);
  end;
  if (TFhirCapabilityStatement(oSource).FMessagingList = nil) then
  begin
    FMessagingList.free;
    FMessagingList := nil;
  end
  else
  begin
    if FMessagingList = nil then
      FMessagingList := TFhirCapabilityStatementMessagingList.Create;
    FMessagingList.Assign(TFhirCapabilityStatement(oSource).FMessagingList);
  end;
  if (TFhirCapabilityStatement(oSource).FDocumentList = nil) then
  begin
    FDocumentList.free;
    FDocumentList := nil;
  end
  else
  begin
    if FDocumentList = nil then
      FDocumentList := TFhirCapabilityStatementDocumentList.Create;
    FDocumentList.Assign(TFhirCapabilityStatement(oSource).FDocumentList);
  end;
end;

procedure TFhirCapabilityStatement.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'kind') Then
     list.add(self.link, 'kind', FKind.Link);
  if (child_name = 'instantiates') Then
    list.addAll(self, 'instantiates', FInstantiatesList);
  if (child_name = 'software') Then
     list.add(self.link, 'software', FSoftware.Link);
  if (child_name = 'implementation') Then
     list.add(self.link, 'implementation', FImplementation_.Link);
  if (child_name = 'fhirVersion') Then
     list.add(self.link, 'fhirVersion', FFhirVersion.Link);
  if (child_name = 'acceptUnknown') Then
     list.add(self.link, 'acceptUnknown', FAcceptUnknown.Link);
  if (child_name = 'format') Then
    list.addAll(self, 'format', FFormatList);
  if (child_name = 'patchFormat') Then
    list.addAll(self, 'patchFormat', FPatchFormatList);
  if (child_name = 'implementationGuide') Then
    list.addAll(self, 'implementationGuide', FImplementationGuideList);
  if (child_name = 'profile') Then
    list.addAll(self, 'profile', FProfileList);
  if (child_name = 'rest') Then
    list.addAll(self, 'rest', FRestList);
  if (child_name = 'messaging') Then
    list.addAll(self, 'messaging', FMessagingList);
  if (child_name = 'document') Then
    list.addAll(self, 'document', FDocumentList);
end;

procedure TFhirCapabilityStatement.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));{2}
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));{2}
  oList.add(TFHIRProperty.create(self, 'kind', 'code', false, TFHIREnum, FKind.Link));{1}
  oList.add(TFHIRProperty.create(self, 'instantiates', 'uri', true, TFhirUri, FInstantiatesList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'software', '', false, TFhirCapabilityStatementSoftware, FSoftware.Link));{2}
  oList.add(TFHIRProperty.create(self, 'implementation', '', false, TFhirCapabilityStatementImplementation, FImplementation_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'fhirVersion', 'id', false, TFhirId, FFhirVersion.Link));{2}
  oList.add(TFHIRProperty.create(self, 'acceptUnknown', 'code', false, TFHIREnum, FAcceptUnknown.Link));{1}
  oList.add(TFHIRProperty.create(self, 'format', 'code', true, TFhirCode, FFormatList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'patchFormat', 'code', true, TFhirCode, FPatchFormatList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'implementationGuide', 'uri', true, TFhirUri, FImplementationGuideList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'profile', 'Reference(StructureDefinition)', true, TFhirReference{TFhirStructureDefinition}, FProfileList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'rest', '', true, TFhirCapabilityStatementRest, FRestList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'messaging', '', true, TFhirCapabilityStatementMessaging, FMessagingList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'document', '', true, TFhirCapabilityStatementDocument, FDocumentList.Link)){3};
end;

function TFhirCapabilityStatement.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'kind') then
  begin
    KindElement := asEnum(SYSTEMS_TFhirCapabilityStatementKindEnum, CODES_TFhirCapabilityStatementKindEnum, propValue);
    result := propValue
  end
  else if (propName = 'instantiates') then
  begin
    InstantiatesList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'software') then
  begin
    Software := propValue as TFhirCapabilityStatementSoftware{4b};
    result := propValue;
  end
  else if (propName = 'implementation') then
  begin
    Implementation_ := propValue as TFhirCapabilityStatementImplementation{4b};
    result := propValue;
  end
  else if (propName = 'fhirVersion') then
  begin
    FhirVersionElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'acceptUnknown') then
  begin
    AcceptUnknownElement := asEnum(SYSTEMS_TFhirUnknownContentCodeEnum, CODES_TFhirUnknownContentCodeEnum, propValue);
    result := propValue
  end
  else if (propName = 'format') then
  begin
    FormatList.add(asCode(propValue)){2};     result := propValue;

  end
  else if (propName = 'patchFormat') then
  begin
    PatchFormatList.add(asCode(propValue)){2};     result := propValue;

  end
  else if (propName = 'implementationGuide') then
  begin
    ImplementationGuideList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'profile') then
  begin
    ProfileList.add(propValue as TFhirReference{TFhirStructureDefinition}){2a};
    result := propValue;
  end
  else if (propName = 'rest') then
  begin
    RestList.add(propValue as TFhirCapabilityStatementRest){2a};
    result := propValue;
  end
  else if (propName = 'messaging') then
  begin
    MessagingList.add(propValue as TFhirCapabilityStatementMessaging){2a};
    result := propValue;
  end
  else if (propName = 'document') then
  begin
    DocumentList.add(propValue as TFhirCapabilityStatementDocument){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirCapabilityStatement.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'instantiates') then InstantiatesList.insertItem(index, asUri(propValue)){2}
  else if (propName = 'format') then FormatList.insertItem(index, asCode(propValue)){2}
  else if (propName = 'patchFormat') then PatchFormatList.insertItem(index, asCode(propValue)){2}
  else if (propName = 'implementationGuide') then ImplementationGuideList.insertItem(index, asUri(propValue)){2}
  else if (propName = 'profile') then ProfileList.insertItem(index, propValue as TFhirReference{TFhirStructureDefinition}){2a}
  else if (propName = 'rest') then RestList.insertItem(index, propValue as TFhirCapabilityStatementRest){2a}
  else if (propName = 'messaging') then MessagingList.insertItem(index, propValue as TFhirCapabilityStatementMessaging){2a}
  else if (propName = 'document') then DocumentList.insertItem(index, propValue as TFhirCapabilityStatementDocument){2a}
  else inherited;
end;

function TFhirCapabilityStatement.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'purpose') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'copyright') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'instantiates') then result := InstantiatesList.new(){2}
  else if (propName = 'software') then result := TFhirCapabilityStatementSoftware.create(){4b}
  else if (propName = 'implementation') then result := TFhirCapabilityStatementImplementation.create(){4b}
  else if (propName = 'fhirVersion') then result := TFhirId.create() {5b}
  else if (propName = 'format') then result := FormatList.new(){2}
  else if (propName = 'patchFormat') then result := PatchFormatList.new(){2}
  else if (propName = 'implementationGuide') then result := ImplementationGuideList.new(){2}
  else if (propName = 'profile') then result := ProfileList.new(){2}
  else if (propName = 'rest') then result := RestList.new(){2}
  else if (propName = 'messaging') then result := MessagingList.new(){2}
  else if (propName = 'document') then result := DocumentList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCapabilityStatement.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'kind') then result := 'code'
  else if (propName = 'instantiates') then result := 'uri'
  else if (propName = 'software') then result := ''
  else if (propName = 'implementation') then result := ''
  else if (propName = 'fhirVersion') then result := 'id'
  else if (propName = 'acceptUnknown') then result := 'code'
  else if (propName = 'format') then result := 'code'
  else if (propName = 'patchFormat') then result := 'code'
  else if (propName = 'implementationGuide') then result := 'uri'
  else if (propName = 'profile') then result := 'Reference'
  else if (propName = 'rest') then result := ''
  else if (propName = 'messaging') then result := ''
  else if (propName = 'document') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCapabilityStatement.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'kind') then KindElement := nil
  else if (propName = 'instantiates') then deletePropertyValue('instantiates', InstantiatesList, value) {2}
  else if (propName = 'software') then SoftwareElement := nil
  else if (propName = 'implementation') then Implementation_Element := nil
  else if (propName = 'fhirVersion') then FhirVersionElement := nil
  else if (propName = 'acceptUnknown') then AcceptUnknownElement := nil
  else if (propName = 'format') then deletePropertyValue('format', FormatList, value) {2}
  else if (propName = 'patchFormat') then deletePropertyValue('patchFormat', PatchFormatList, value) {2}
  else if (propName = 'implementationGuide') then deletePropertyValue('implementationGuide', ImplementationGuideList, value) {2}
  else if (propName = 'profile') then deletePropertyValue('profile', ProfileList, value) {2}
  else if (propName = 'rest') then deletePropertyValue('rest', RestList, value) {2}
  else if (propName = 'messaging') then deletePropertyValue('messaging', MessagingList, value) {2}
  else if (propName = 'document') then deletePropertyValue('document', DocumentList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCapabilityStatement.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'purpose') then PurposeElement := asMarkdown(new){5b}
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new){5b}
  else if (propName = 'kind') then KindElement := asEnum(SYSTEMS_TFhirCapabilityStatementKindEnum, CODES_TFhirCapabilityStatementKindEnum, new){4}
  else if (propName = 'instantiates') then replacePropertyValue('instantiates', InstantiatesList, existing, new) {2}
  else if (propName = 'software') then SoftwareElement := new as TFhirCapabilityStatementSoftware{4}
  else if (propName = 'implementation') then Implementation_Element := new as TFhirCapabilityStatementImplementation{4}
  else if (propName = 'fhirVersion') then FhirVersionElement := asId(new){5b}
  else if (propName = 'acceptUnknown') then AcceptUnknownElement := asEnum(SYSTEMS_TFhirUnknownContentCodeEnum, CODES_TFhirUnknownContentCodeEnum, new){4}
  else if (propName = 'format') then replacePropertyValue('format', FormatList, existing, new) {2}
  else if (propName = 'patchFormat') then replacePropertyValue('patchFormat', PatchFormatList, existing, new) {2}
  else if (propName = 'implementationGuide') then replacePropertyValue('implementationGuide', ImplementationGuideList, existing, new) {2}
  else if (propName = 'profile') then replacePropertyValue('profile', ProfileList, existing, new) {2}
  else if (propName = 'rest') then replacePropertyValue('rest', RestList, existing, new) {2}
  else if (propName = 'messaging') then replacePropertyValue('messaging', MessagingList, existing, new) {2}
  else if (propName = 'document') then replacePropertyValue('document', DocumentList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCapabilityStatement.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'instantiates') then InstantiatesList.move(source, destination){2}
  else if (propName = 'format') then FormatList.move(source, destination){2}
  else if (propName = 'patchFormat') then PatchFormatList.move(source, destination){2}
  else if (propName = 'implementationGuide') then ImplementationGuideList.move(source, destination){2}
  else if (propName = 'profile') then ProfileList.move(source, destination){2a}
  else if (propName = 'rest') then RestList.move(source, destination){2a}
  else if (propName = 'messaging') then MessagingList.move(source, destination){2a}
  else if (propName = 'document') then DocumentList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCapabilityStatement.fhirType : string;
begin
  result := 'CapabilityStatement';
end;

function TFhirCapabilityStatement.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPurpose) and isEmptyProp(FCopyright) and isEmptyProp(FKind) and isEmptyProp(FinstantiatesList) and isEmptyProp(FSoftware) and isEmptyProp(FImplementation_) and isEmptyProp(FFhirVersion) and isEmptyProp(FAcceptUnknown) and isEmptyProp(FformatList) and isEmptyProp(FpatchFormatList) and isEmptyProp(FimplementationGuideList) and isEmptyProp(FprofileList) and isEmptyProp(FrestList) and isEmptyProp(FmessagingList) and isEmptyProp(FdocumentList);
end;

function TFhirCapabilityStatement.equals(other : TObject) : boolean;
var
  o : TFhirCapabilityStatement;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCapabilityStatement)) then
    result := false
  else
  begin
    o := TFhirCapabilityStatement(other);
    result := compareDeep(purposeElement, o.purposeElement, true) and compareDeep(copyrightElement, o.copyrightElement, true) and
      compareDeep(kindElement, o.kindElement, true) and compareDeep(instantiatesList, o.instantiatesList, true) and
      compareDeep(softwareElement, o.softwareElement, true) and compareDeep(implementation_Element, o.implementation_Element, true) and
      compareDeep(fhirVersionElement, o.fhirVersionElement, true) and compareDeep(acceptUnknownElement, o.acceptUnknownElement, true) and
      compareDeep(formatList, o.formatList, true) and compareDeep(patchFormatList, o.patchFormatList, true) and
      compareDeep(implementationGuideList, o.implementationGuideList, true) and compareDeep(profileList, o.profileList, true) and
      compareDeep(restList, o.restList, true) and compareDeep(messagingList, o.messagingList, true) and
      compareDeep(documentList, o.documentList, true);
  end;
end;

function TFhirCapabilityStatement.Link : TFhirCapabilityStatement;
begin
  result := TFhirCapabilityStatement(inherited Link);
end;

function TFhirCapabilityStatement.Clone : TFhirCapabilityStatement;
begin
  result := TFhirCapabilityStatement(inherited Clone);
end;

procedure TFhirCapabilityStatement.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('url');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('status');
  fields.add('experimental');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('purpose');
  fields.add('copyright');
  fields.add('kind');
  fields.add('instantiates');
  fields.add('software');
  fields.add('implementation');
  fields.add('fhirVersion');
  fields.add('acceptUnknown');
  fields.add('format');
  fields.add('patchFormat');
  fields.add('implementationGuide');
  fields.add('profile');
  fields.add('rest');
  fields.add('messaging');
  fields.add('document');
end;

{ TFhirCapabilityStatement }

Procedure TFhirCapabilityStatement.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

Function TFhirCapabilityStatement.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

Procedure TFhirCapabilityStatement.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

Procedure TFhirCapabilityStatement.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

Function TFhirCapabilityStatement.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

Procedure TFhirCapabilityStatement.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

Procedure TFhirCapabilityStatement.SetKind(value : TFhirEnum);
begin
  FKind.free;
  FKind := value;
end;

Function TFhirCapabilityStatement.GetKindST : TFhirCapabilityStatementKindEnum;
begin
  if FKind = nil then
    result := TFhirCapabilityStatementKindEnum(0)
  else
    result := TFhirCapabilityStatementKindEnum(StringArrayIndexOfSensitive(CODES_TFhirCapabilityStatementKindEnum, FKind.value));
end;

Procedure TFhirCapabilityStatement.SetKindST(value : TFhirCapabilityStatementKindEnum);
begin
  if ord(value) = 0 then
    KindElement := nil
  else
    KindElement := TFhirEnum.create(SYSTEMS_TFhirCapabilityStatementKindEnum[value], CODES_TFhirCapabilityStatementKindEnum[value]);
end;

Function TFhirCapabilityStatement.GetInstantiatesList : TFhirUriList;
begin
  if FInstantiatesList = nil then
    FInstantiatesList := TFhirUriList.Create;
  result := FInstantiatesList;
end;

Function TFhirCapabilityStatement.GetHasInstantiatesList : boolean;
begin
  result := (FInstantiatesList <> nil) and (FInstantiatesList.count > 0);
end;

Procedure TFhirCapabilityStatement.SetSoftware(value : TFhirCapabilityStatementSoftware);
begin
  FSoftware.free;
  FSoftware := value;
end;

Procedure TFhirCapabilityStatement.SetImplementation_(value : TFhirCapabilityStatementImplementation);
begin
  FImplementation_.free;
  FImplementation_ := value;
end;

Procedure TFhirCapabilityStatement.SetFhirVersion(value : TFhirId);
begin
  FFhirVersion.free;
  FFhirVersion := value;
end;

Function TFhirCapabilityStatement.GetFhirVersionST : String;
begin
  if FFhirVersion = nil then
    result := ''
  else
    result := FFhirVersion.value;
end;

Procedure TFhirCapabilityStatement.SetFhirVersionST(value : String);
begin
  if value <> '' then
  begin
    if FFhirVersion = nil then
      FFhirVersion := TFhirId.create;
    FFhirVersion.value := value
  end
  else if FFhirVersion <> nil then
    FFhirVersion.value := '';
end;

Procedure TFhirCapabilityStatement.SetAcceptUnknown(value : TFhirEnum);
begin
  FAcceptUnknown.free;
  FAcceptUnknown := value;
end;

Function TFhirCapabilityStatement.GetAcceptUnknownST : TFhirUnknownContentCodeEnum;
begin
  if FAcceptUnknown = nil then
    result := TFhirUnknownContentCodeEnum(0)
  else
    result := TFhirUnknownContentCodeEnum(StringArrayIndexOfSensitive(CODES_TFhirUnknownContentCodeEnum, FAcceptUnknown.value));
end;

Procedure TFhirCapabilityStatement.SetAcceptUnknownST(value : TFhirUnknownContentCodeEnum);
begin
  if ord(value) = 0 then
    AcceptUnknownElement := nil
  else
    AcceptUnknownElement := TFhirEnum.create(SYSTEMS_TFhirUnknownContentCodeEnum[value], CODES_TFhirUnknownContentCodeEnum[value]);
end;

Function TFhirCapabilityStatement.GetFormatList : TFhirCodeList;
begin
  if FFormatList = nil then
    FFormatList := TFhirCodeList.Create;
  result := FFormatList;
end;

Function TFhirCapabilityStatement.GetHasFormatList : boolean;
begin
  result := (FFormatList <> nil) and (FFormatList.count > 0);
end;

Function TFhirCapabilityStatement.GetPatchFormatList : TFhirCodeList;
begin
  if FPatchFormatList = nil then
    FPatchFormatList := TFhirCodeList.Create;
  result := FPatchFormatList;
end;

Function TFhirCapabilityStatement.GetHasPatchFormatList : boolean;
begin
  result := (FPatchFormatList <> nil) and (FPatchFormatList.count > 0);
end;

Function TFhirCapabilityStatement.GetImplementationGuideList : TFhirUriList;
begin
  if FImplementationGuideList = nil then
    FImplementationGuideList := TFhirUriList.Create;
  result := FImplementationGuideList;
end;

Function TFhirCapabilityStatement.GetHasImplementationGuideList : boolean;
begin
  result := (FImplementationGuideList <> nil) and (FImplementationGuideList.count > 0);
end;

Function TFhirCapabilityStatement.GetProfileList : TFhirReferenceList{TFhirStructureDefinition};
begin
  if FProfileList = nil then
    FProfileList := TFhirReferenceList{TFhirStructureDefinition}.Create;
  result := FProfileList;
end;

Function TFhirCapabilityStatement.GetHasProfileList : boolean;
begin
  result := (FProfileList <> nil) and (FProfileList.count > 0);
end;

Function TFhirCapabilityStatement.GetRestList : TFhirCapabilityStatementRestList;
begin
  if FRestList = nil then
    FRestList := TFhirCapabilityStatementRestList.Create;
  result := FRestList;
end;

Function TFhirCapabilityStatement.GetHasRestList : boolean;
begin
  result := (FRestList <> nil) and (FRestList.count > 0);
end;

Function TFhirCapabilityStatement.GetMessagingList : TFhirCapabilityStatementMessagingList;
begin
  if FMessagingList = nil then
    FMessagingList := TFhirCapabilityStatementMessagingList.Create;
  result := FMessagingList;
end;

Function TFhirCapabilityStatement.GetHasMessagingList : boolean;
begin
  result := (FMessagingList <> nil) and (FMessagingList.count > 0);
end;

Function TFhirCapabilityStatement.GetDocumentList : TFhirCapabilityStatementDocumentList;
begin
  if FDocumentList = nil then
    FDocumentList := TFhirCapabilityStatementDocumentList.Create;
  result := FDocumentList;
end;

Function TFhirCapabilityStatement.GetHasDocumentList : boolean;
begin
  result := (FDocumentList <> nil) and (FDocumentList.count > 0);
end;

function TFhirCapabilityStatement.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FPurpose.sizeInBytes);
  inc(result, FCopyright.sizeInBytes);
  inc(result, FKind.sizeInBytes);
  inc(result, FinstantiatesList.sizeInBytes);
  inc(result, FSoftware.sizeInBytes);
  inc(result, FImplementation_.sizeInBytes);
  inc(result, FFhirVersion.sizeInBytes);
  inc(result, FAcceptUnknown.sizeInBytes);
  inc(result, FformatList.sizeInBytes);
  inc(result, FpatchFormatList.sizeInBytes);
  inc(result, FimplementationGuideList.sizeInBytes);
  inc(result, FprofileList.sizeInBytes);
  inc(result, FrestList.sizeInBytes);
  inc(result, FmessagingList.sizeInBytes);
  inc(result, FdocumentList.sizeInBytes);
end;

{ TFhirCapabilityStatementListEnumerator }

Constructor TFhirCapabilityStatementListEnumerator.Create(list : TFhirCapabilityStatementList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCapabilityStatementListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCapabilityStatementListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCapabilityStatementListEnumerator.GetCurrent : TFhirCapabilityStatement;
begin
  Result := FList[FIndex];
end;

function TFhirCapabilityStatementListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCapabilityStatementList }
procedure TFhirCapabilityStatementList.AddItem(value: TFhirCapabilityStatement);
begin
  assert(value.ClassName = 'TFhirCapabilityStatement', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCapabilityStatement');
  add(value);
end;

function TFhirCapabilityStatementList.Append: TFhirCapabilityStatement;
begin
  result := TFhirCapabilityStatement.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementList.ClearItems;
begin
  Clear;
end;

function TFhirCapabilityStatementList.GetEnumerator : TFhirCapabilityStatementListEnumerator;
begin
  result := TFhirCapabilityStatementListEnumerator.Create(self.link);
end;

function TFhirCapabilityStatementList.Clone: TFhirCapabilityStatementList;
begin
  result := TFhirCapabilityStatementList(inherited Clone);
end;

function TFhirCapabilityStatementList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCapabilityStatementList.GetItemN(index: Integer): TFhirCapabilityStatement;
begin
  result := TFhirCapabilityStatement(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementList.ItemClass: TFslObjectClass;
begin
  result := TFhirCapabilityStatement;
end;
function TFhirCapabilityStatementList.IndexOf(value: TFhirCapabilityStatement): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCapabilityStatementList.Insert(index: Integer): TFhirCapabilityStatement;
begin
  result := TFhirCapabilityStatement.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCapabilityStatementList.InsertItem(index: Integer; value: TFhirCapabilityStatement);
begin
  assert(value is TFhirCapabilityStatement);
  Inherited Insert(index, value);
end;

function TFhirCapabilityStatementList.Item(index: Integer): TFhirCapabilityStatement;
begin
  result := TFhirCapabilityStatement(ObjectByIndex[index]);
end;

function TFhirCapabilityStatementList.Link: TFhirCapabilityStatementList;
begin
  result := TFhirCapabilityStatementList(inherited Link);
end;

procedure TFhirCapabilityStatementList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCapabilityStatementList.SetItemByIndex(index: Integer; value: TFhirCapabilityStatement);
begin
  assert(value is TFhirCapabilityStatement);
  FhirCapabilityStatements[index] := value;
end;

procedure TFhirCapabilityStatementList.SetItemN(index: Integer; value: TFhirCapabilityStatement);
begin
  assert(value is TFhirCapabilityStatement);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CAPABILITYSTATEMENT}

{$IFDEF FHIR_CODESYSTEM}

{ TFhirCodeSystemFilter }

constructor TFhirCodeSystemFilter.Create;
begin
  inherited;
end;

destructor TFhirCodeSystemFilter.Destroy;
begin
  FCode.free;
  FDescription.free;
  FOperator.Free;
  FValue.free;
  inherited;
end;

procedure TFhirCodeSystemFilter.Assign(oSource : TFslObject);
begin
  inherited;
  codeElement := TFhirCodeSystemFilter(oSource).codeElement.Clone;
  descriptionElement := TFhirCodeSystemFilter(oSource).descriptionElement.Clone;
  if (TFhirCodeSystemFilter(oSource).FOperator = nil) then
  begin
    FOperator.free;
    FOperator := nil;
  end
  else
  begin
    FOperator := TFHIREnumList.Create(SYSTEMS_TFhirFilterOperatorEnum, CODES_TFhirFilterOperatorEnum);
    FOperator.Assign(TFhirCodeSystemFilter(oSource).FOperator);
  end;
  valueElement := TFhirCodeSystemFilter(oSource).valueElement.Clone;
end;

procedure TFhirCodeSystemFilter.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'operator') Then
     list.addAll(self, 'operator', FOperator);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirCodeSystemFilter.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirCode, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'operator', 'code', true, TFHIREnum, FOperator.Link)){3};
  oList.add(TFHIRProperty.create(self, 'value', 'string', false, TFhirString, FValue.Link));{2}
end;

function TFhirCodeSystemFilter.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'operator') then
  begin
    OperatorList.add(asEnum(SYSTEMS_TFhirFilterOperatorEnum, CODES_TFhirFilterOperatorEnum, propValue)); {1}
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCodeSystemFilter.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'operator') then FOperator.insertItem(index, asEnum(SYSTEMS_TFhirFilterOperatorEnum, CODES_TFhirFilterOperatorEnum, propValue)) {1}
  else inherited;
end;

function TFhirCodeSystemFilter.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCode.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'value') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCodeSystemFilter.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'code'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'operator') then result := 'code'
  else if (propName = 'value') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCodeSystemFilter.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCodeSystemFilter.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asCode(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'value') then ValueElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCodeSystemFilter.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'operator') then FOperator.move(source, destination) {1}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCodeSystemFilter.fhirType : string;
begin
  result := 'filter';
end;

function TFhirCodeSystemFilter.Link : TFhirCodeSystemFilter;
begin
  result := TFhirCodeSystemFilter(inherited Link);
end;

function TFhirCodeSystemFilter.Clone : TFhirCodeSystemFilter;
begin
  result := TFhirCodeSystemFilter(inherited Clone);
end;

function TFhirCodeSystemFilter.equals(other : TObject) : boolean;
var
  o : TFhirCodeSystemFilter;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCodeSystemFilter)) then
    result := false
  else
  begin
    o := TFhirCodeSystemFilter(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and
      compareDeep(operatorList, o.operatorList, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirCodeSystemFilter.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FDescription) and isEmptyProp(FOperator) and isEmptyProp(FValue);
end;

procedure TFhirCodeSystemFilter.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('description');
  fields.add('operator');
  fields.add('value');
end;

{ TFhirCodeSystemFilter }

Procedure TFhirCodeSystemFilter.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirCodeSystemFilter.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

Procedure TFhirCodeSystemFilter.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

Procedure TFhirCodeSystemFilter.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirCodeSystemFilter.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirCodeSystemFilter.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Function TFhirCodeSystemFilter.GetOperator : TFhirEnumList;
begin
  if FOperator = nil then
    FOperator := TFHIREnumList.Create(SYSTEMS_TFhirFilterOperatorEnum, CODES_TFhirFilterOperatorEnum);
  result := FOperator;
end;

Function TFhirCodeSystemFilter.GetHasOperator : boolean;
begin
  result := (FOperator <> nil) and (FOperator.count > 0);
end;

Function TFhirCodeSystemFilter.GetOperatorST : TFhirFilterOperatorEnumList;
  var i : integer;
begin
  result := [];
  if Foperator <> nil then
    for i := 0 to Foperator.count - 1 do
      result := result + [TFhirFilterOperatorEnum(StringArrayIndexOfSensitive(CODES_TFhirFilterOperatorEnum, Foperator[i].value))];
end;

Procedure TFhirCodeSystemFilter.SetOperatorST(value : TFhirFilterOperatorEnumList);
var a : TFhirFilterOperatorEnum;
begin
  if Foperator = nil then
    Foperator := TFhirEnumList.create(SYSTEMS_TFhirFilterOperatorEnum, CODES_TFhirFilterOperatorEnum);
  Foperator.clear;
  for a := low(TFhirFilterOperatorEnum) to high(TFhirFilterOperatorEnum) do
    if a in value then
      begin
         if Foperator = nil then
           Foperator := TFhirEnumList.create(SYSTEMS_TFhirFilterOperatorEnum, CODES_TFhirFilterOperatorEnum);
         Foperator.add(TFhirEnum.create(SYSTEMS_TFhirFilterOperatorEnum[a], CODES_TFhirFilterOperatorEnum[a]));
      end;
end;

Procedure TFhirCodeSystemFilter.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirCodeSystemFilter.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

Procedure TFhirCodeSystemFilter.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

function TFhirCodeSystemFilter.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FOperator.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirCodeSystemFilterListEnumerator }

Constructor TFhirCodeSystemFilterListEnumerator.Create(list : TFhirCodeSystemFilterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCodeSystemFilterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCodeSystemFilterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCodeSystemFilterListEnumerator.GetCurrent : TFhirCodeSystemFilter;
begin
  Result := FList[FIndex];
end;

function TFhirCodeSystemFilterListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCodeSystemFilterList }
procedure TFhirCodeSystemFilterList.AddItem(value: TFhirCodeSystemFilter);
begin
  assert(value.ClassName = 'TFhirCodeSystemFilter', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCodeSystemFilter');
  add(value);
end;

function TFhirCodeSystemFilterList.Append: TFhirCodeSystemFilter;
begin
  result := TFhirCodeSystemFilter.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCodeSystemFilterList.ClearItems;
begin
  Clear;
end;

function TFhirCodeSystemFilterList.GetEnumerator : TFhirCodeSystemFilterListEnumerator;
begin
  result := TFhirCodeSystemFilterListEnumerator.Create(self.link);
end;

function TFhirCodeSystemFilterList.Clone: TFhirCodeSystemFilterList;
begin
  result := TFhirCodeSystemFilterList(inherited Clone);
end;

function TFhirCodeSystemFilterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCodeSystemFilterList.GetItemN(index: Integer): TFhirCodeSystemFilter;
begin
  result := TFhirCodeSystemFilter(ObjectByIndex[index]);
end;

function TFhirCodeSystemFilterList.ItemClass: TFslObjectClass;
begin
  result := TFhirCodeSystemFilter;
end;
function TFhirCodeSystemFilterList.IndexOf(value: TFhirCodeSystemFilter): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCodeSystemFilterList.Insert(index: Integer): TFhirCodeSystemFilter;
begin
  result := TFhirCodeSystemFilter.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCodeSystemFilterList.InsertItem(index: Integer; value: TFhirCodeSystemFilter);
begin
  assert(value is TFhirCodeSystemFilter);
  Inherited Insert(index, value);
end;

function TFhirCodeSystemFilterList.Item(index: Integer): TFhirCodeSystemFilter;
begin
  result := TFhirCodeSystemFilter(ObjectByIndex[index]);
end;

function TFhirCodeSystemFilterList.Link: TFhirCodeSystemFilterList;
begin
  result := TFhirCodeSystemFilterList(inherited Link);
end;

procedure TFhirCodeSystemFilterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCodeSystemFilterList.SetItemByIndex(index: Integer; value: TFhirCodeSystemFilter);
begin
  assert(value is TFhirCodeSystemFilter);
  FhirCodeSystemFilters[index] := value;
end;

procedure TFhirCodeSystemFilterList.SetItemN(index: Integer; value: TFhirCodeSystemFilter);
begin
  assert(value is TFhirCodeSystemFilter);
  ObjectByIndex[index] := value;
end;

{ TFhirCodeSystemProperty }

constructor TFhirCodeSystemProperty.Create;
begin
  inherited;
end;

destructor TFhirCodeSystemProperty.Destroy;
begin
  FCode.free;
  FUri.free;
  FDescription.free;
  FType_.free;
  inherited;
end;

procedure TFhirCodeSystemProperty.Assign(oSource : TFslObject);
begin
  inherited;
  codeElement := TFhirCodeSystemProperty(oSource).codeElement.Clone;
  uriElement := TFhirCodeSystemProperty(oSource).uriElement.Clone;
  descriptionElement := TFhirCodeSystemProperty(oSource).descriptionElement.Clone;
  FType_ := TFhirCodeSystemProperty(oSource).FType_.Link;
end;

procedure TFhirCodeSystemProperty.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'uri') Then
     list.add(self.link, 'uri', FUri.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
end;

procedure TFhirCodeSystemProperty.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirCode, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'uri', 'uri', false, TFhirUri, FUri.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
end;

function TFhirCodeSystemProperty.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'uri') then
  begin
    UriElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirConceptPropertyTypeEnum, CODES_TFhirConceptPropertyTypeEnum, propValue);
    result := propValue
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCodeSystemProperty.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCodeSystemProperty.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCode.create() {5b}
  else if (propName = 'uri') then result := TFhirUri.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCodeSystemProperty.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'code'
  else if (propName = 'uri') then result := 'uri'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'type') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCodeSystemProperty.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'uri') then UriElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'type') then Type_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCodeSystemProperty.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asCode(new){5b}
  else if (propName = 'uri') then UriElement := asUri(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirConceptPropertyTypeEnum, CODES_TFhirConceptPropertyTypeEnum, new){4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCodeSystemProperty.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCodeSystemProperty.fhirType : string;
begin
  result := 'property';
end;

function TFhirCodeSystemProperty.Link : TFhirCodeSystemProperty;
begin
  result := TFhirCodeSystemProperty(inherited Link);
end;

function TFhirCodeSystemProperty.Clone : TFhirCodeSystemProperty;
begin
  result := TFhirCodeSystemProperty(inherited Clone);
end;

function TFhirCodeSystemProperty.equals(other : TObject) : boolean;
var
  o : TFhirCodeSystemProperty;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCodeSystemProperty)) then
    result := false
  else
  begin
    o := TFhirCodeSystemProperty(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(uriElement, o.uriElement, true) and
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(type_Element, o.type_Element, true);
  end;
end;

function TFhirCodeSystemProperty.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FUri) and isEmptyProp(FDescription) and isEmptyProp(FType_);
end;

procedure TFhirCodeSystemProperty.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('uri');
  fields.add('description');
  fields.add('type');
end;

{ TFhirCodeSystemProperty }

Procedure TFhirCodeSystemProperty.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirCodeSystemProperty.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

Procedure TFhirCodeSystemProperty.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

Procedure TFhirCodeSystemProperty.SetUri(value : TFhirUri);
begin
  FUri.free;
  FUri := value;
end;

Function TFhirCodeSystemProperty.GetUriST : String;
begin
  if FUri = nil then
    result := ''
  else
    result := FUri.value;
end;

Procedure TFhirCodeSystemProperty.SetUriST(value : String);
begin
  if value <> '' then
  begin
    if FUri = nil then
      FUri := TFhirUri.create;
    FUri.value := value
  end
  else if FUri <> nil then
    FUri.value := '';
end;

Procedure TFhirCodeSystemProperty.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirCodeSystemProperty.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirCodeSystemProperty.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirCodeSystemProperty.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirCodeSystemProperty.GetType_ST : TFhirConceptPropertyTypeEnum;
begin
  if FType_ = nil then
    result := TFhirConceptPropertyTypeEnum(0)
  else
    result := TFhirConceptPropertyTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirConceptPropertyTypeEnum, FType_.value));
end;

Procedure TFhirCodeSystemProperty.SetType_ST(value : TFhirConceptPropertyTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirConceptPropertyTypeEnum[value], CODES_TFhirConceptPropertyTypeEnum[value]);
end;

function TFhirCodeSystemProperty.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FUri.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FType_.sizeInBytes);
end;

{ TFhirCodeSystemPropertyListEnumerator }

Constructor TFhirCodeSystemPropertyListEnumerator.Create(list : TFhirCodeSystemPropertyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCodeSystemPropertyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCodeSystemPropertyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCodeSystemPropertyListEnumerator.GetCurrent : TFhirCodeSystemProperty;
begin
  Result := FList[FIndex];
end;

function TFhirCodeSystemPropertyListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCodeSystemPropertyList }
procedure TFhirCodeSystemPropertyList.AddItem(value: TFhirCodeSystemProperty);
begin
  assert(value.ClassName = 'TFhirCodeSystemProperty', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCodeSystemProperty');
  add(value);
end;

function TFhirCodeSystemPropertyList.Append: TFhirCodeSystemProperty;
begin
  result := TFhirCodeSystemProperty.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCodeSystemPropertyList.ClearItems;
begin
  Clear;
end;

function TFhirCodeSystemPropertyList.GetEnumerator : TFhirCodeSystemPropertyListEnumerator;
begin
  result := TFhirCodeSystemPropertyListEnumerator.Create(self.link);
end;

function TFhirCodeSystemPropertyList.Clone: TFhirCodeSystemPropertyList;
begin
  result := TFhirCodeSystemPropertyList(inherited Clone);
end;

function TFhirCodeSystemPropertyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCodeSystemPropertyList.GetItemN(index: Integer): TFhirCodeSystemProperty;
begin
  result := TFhirCodeSystemProperty(ObjectByIndex[index]);
end;

function TFhirCodeSystemPropertyList.ItemClass: TFslObjectClass;
begin
  result := TFhirCodeSystemProperty;
end;
function TFhirCodeSystemPropertyList.IndexOf(value: TFhirCodeSystemProperty): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCodeSystemPropertyList.Insert(index: Integer): TFhirCodeSystemProperty;
begin
  result := TFhirCodeSystemProperty.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCodeSystemPropertyList.InsertItem(index: Integer; value: TFhirCodeSystemProperty);
begin
  assert(value is TFhirCodeSystemProperty);
  Inherited Insert(index, value);
end;

function TFhirCodeSystemPropertyList.Item(index: Integer): TFhirCodeSystemProperty;
begin
  result := TFhirCodeSystemProperty(ObjectByIndex[index]);
end;

function TFhirCodeSystemPropertyList.Link: TFhirCodeSystemPropertyList;
begin
  result := TFhirCodeSystemPropertyList(inherited Link);
end;

procedure TFhirCodeSystemPropertyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCodeSystemPropertyList.SetItemByIndex(index: Integer; value: TFhirCodeSystemProperty);
begin
  assert(value is TFhirCodeSystemProperty);
  FhirCodeSystemProperties[index] := value;
end;

procedure TFhirCodeSystemPropertyList.SetItemN(index: Integer; value: TFhirCodeSystemProperty);
begin
  assert(value is TFhirCodeSystemProperty);
  ObjectByIndex[index] := value;
end;

{ TFhirCodeSystemConcept }

constructor TFhirCodeSystemConcept.Create;
begin
  inherited;
end;

destructor TFhirCodeSystemConcept.Destroy;
begin
  FCode.free;
  FDisplay.free;
  FDefinition.free;
  FDesignationList.Free;
  FProperty_List.Free;
  FConceptList.Free;
  inherited;
end;

procedure TFhirCodeSystemConcept.Assign(oSource : TFslObject);
begin
  inherited;
  codeElement := TFhirCodeSystemConcept(oSource).codeElement.Clone;
  displayElement := TFhirCodeSystemConcept(oSource).displayElement.Clone;
  definitionElement := TFhirCodeSystemConcept(oSource).definitionElement.Clone;
  if (TFhirCodeSystemConcept(oSource).FDesignationList = nil) then
  begin
    FDesignationList.free;
    FDesignationList := nil;
  end
  else
  begin
    if FDesignationList = nil then
      FDesignationList := TFhirCodeSystemConceptDesignationList.Create;
    FDesignationList.Assign(TFhirCodeSystemConcept(oSource).FDesignationList);
  end;
  if (TFhirCodeSystemConcept(oSource).FProperty_List = nil) then
  begin
    FProperty_List.free;
    FProperty_List := nil;
  end
  else
  begin
    if FProperty_List = nil then
      FProperty_List := TFhirCodeSystemConceptPropertyList.Create;
    FProperty_List.Assign(TFhirCodeSystemConcept(oSource).FProperty_List);
  end;
  if (TFhirCodeSystemConcept(oSource).FConceptList = nil) then
  begin
    FConceptList.free;
    FConceptList := nil;
  end
  else
  begin
    if FConceptList = nil then
      FConceptList := TFhirCodeSystemConceptList.Create;
    FConceptList.Assign(TFhirCodeSystemConcept(oSource).FConceptList);
  end;
end;

procedure TFhirCodeSystemConcept.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'display') Then
     list.add(self.link, 'display', FDisplay.Link);
  if (child_name = 'definition') Then
     list.add(self.link, 'definition', FDefinition.Link);
  if (child_name = 'designation') Then
    list.addAll(self, 'designation', FDesignationList);
  if (child_name = 'property') Then
    list.addAll(self, 'property', FProperty_List);
  if (child_name = 'concept') Then
    list.addAll(self, 'concept', FConceptList);
end;

procedure TFhirCodeSystemConcept.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirCode, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'display', 'string', false, TFhirString, FDisplay.Link));{2}
  oList.add(TFHIRProperty.create(self, 'definition', 'string', false, TFhirString, FDefinition.Link));{2}
  oList.add(TFHIRProperty.create(self, 'designation', '', true, TFhirCodeSystemConceptDesignation, FDesignationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'property', '', true, TFhirCodeSystemConceptProperty, FProperty_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'concept', '@CodeSystem.concept', true, TFhirCodeSystemConcept, FConceptList.Link)){3};
end;

function TFhirCodeSystemConcept.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'display') then
  begin
    DisplayElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'definition') then
  begin
    DefinitionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'designation') then
  begin
    DesignationList.add(propValue as TFhirCodeSystemConceptDesignation){2a};
    result := propValue;
  end
  else if (propName = 'property') then
  begin
    Property_List.add(propValue as TFhirCodeSystemConceptProperty){2a};
    result := propValue;
  end
  else if (propName = 'concept') then
  begin
    ConceptList.add(propValue as TFhirCodeSystemConcept){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCodeSystemConcept.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'designation') then DesignationList.insertItem(index, propValue as TFhirCodeSystemConceptDesignation){2a}
  else if (propName = 'property') then Property_List.insertItem(index, propValue as TFhirCodeSystemConceptProperty){2a}
  else if (propName = 'concept') then ConceptList.insertItem(index, propValue as TFhirCodeSystemConcept){2a}
  else inherited;
end;

function TFhirCodeSystemConcept.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCode.create() {5b}
  else if (propName = 'display') then result := TFhirString.create() {5b}
  else if (propName = 'definition') then result := TFhirString.create() {5b}
  else if (propName = 'designation') then result := DesignationList.new(){2}
  else if (propName = 'property') then result := Property_List.new(){2}
  else if (propName = 'concept') then result := ConceptList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCodeSystemConcept.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'code'
  else if (propName = 'display') then result := 'string'
  else if (propName = 'definition') then result := 'string'
  else if (propName = 'designation') then result := ''
  else if (propName = 'property') then result := ''
  else if (propName = 'concept') then result := '@CodeSystem.concept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCodeSystemConcept.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'display') then DisplayElement := nil
  else if (propName = 'definition') then DefinitionElement := nil
  else if (propName = 'designation') then deletePropertyValue('designation', DesignationList, value) {2}
  else if (propName = 'property') then deletePropertyValue('property', Property_List, value) {2}
  else if (propName = 'concept') then deletePropertyValue('concept', ConceptList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCodeSystemConcept.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asCode(new){5b}
  else if (propName = 'display') then DisplayElement := asString(new){5b}
  else if (propName = 'definition') then DefinitionElement := asString(new){5b}
  else if (propName = 'designation') then replacePropertyValue('designation', DesignationList, existing, new) {2}
  else if (propName = 'property') then replacePropertyValue('property', Property_List, existing, new) {2}
  else if (propName = 'concept') then replacePropertyValue('concept', ConceptList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCodeSystemConcept.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'designation') then DesignationList.move(source, destination){2a}
  else if (propName = 'property') then Property_List.move(source, destination){2a}
  else if (propName = 'concept') then ConceptList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCodeSystemConcept.fhirType : string;
begin
  result := 'concept';
end;

function TFhirCodeSystemConcept.Link : TFhirCodeSystemConcept;
begin
  result := TFhirCodeSystemConcept(inherited Link);
end;

function TFhirCodeSystemConcept.Clone : TFhirCodeSystemConcept;
begin
  result := TFhirCodeSystemConcept(inherited Clone);
end;

function TFhirCodeSystemConcept.equals(other : TObject) : boolean;
var
  o : TFhirCodeSystemConcept;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCodeSystemConcept)) then
    result := false
  else
  begin
    o := TFhirCodeSystemConcept(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(displayElement, o.displayElement, true) and
      compareDeep(definitionElement, o.definitionElement, true) and compareDeep(designationList, o.designationList, true) and
      compareDeep(property_List, o.property_List, true) and compareDeep(conceptList, o.conceptList, true);
  end;
end;

function TFhirCodeSystemConcept.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FDisplay) and isEmptyProp(FDefinition) and isEmptyProp(FdesignationList) and isEmptyProp(Fproperty_List) and isEmptyProp(FconceptList);
end;

procedure TFhirCodeSystemConcept.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('display');
  fields.add('definition');
  fields.add('designation');
  fields.add('property');
  fields.add('concept');
end;

{ TFhirCodeSystemConcept }

Procedure TFhirCodeSystemConcept.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirCodeSystemConcept.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

Procedure TFhirCodeSystemConcept.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

Procedure TFhirCodeSystemConcept.SetDisplay(value : TFhirString);
begin
  FDisplay.free;
  FDisplay := value;
end;

Function TFhirCodeSystemConcept.GetDisplayST : String;
begin
  if FDisplay = nil then
    result := ''
  else
    result := FDisplay.value;
end;

Procedure TFhirCodeSystemConcept.SetDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FDisplay = nil then
      FDisplay := TFhirString.create;
    FDisplay.value := value
  end
  else if FDisplay <> nil then
    FDisplay.value := '';
end;

Procedure TFhirCodeSystemConcept.SetDefinition(value : TFhirString);
begin
  FDefinition.free;
  FDefinition := value;
end;

Function TFhirCodeSystemConcept.GetDefinitionST : String;
begin
  if FDefinition = nil then
    result := ''
  else
    result := FDefinition.value;
end;

Procedure TFhirCodeSystemConcept.SetDefinitionST(value : String);
begin
  if value <> '' then
  begin
    if FDefinition = nil then
      FDefinition := TFhirString.create;
    FDefinition.value := value
  end
  else if FDefinition <> nil then
    FDefinition.value := '';
end;

Function TFhirCodeSystemConcept.GetDesignationList : TFhirCodeSystemConceptDesignationList;
begin
  if FDesignationList = nil then
    FDesignationList := TFhirCodeSystemConceptDesignationList.Create;
  result := FDesignationList;
end;

Function TFhirCodeSystemConcept.GetHasDesignationList : boolean;
begin
  result := (FDesignationList <> nil) and (FDesignationList.count > 0);
end;

Function TFhirCodeSystemConcept.GetProperty_List : TFhirCodeSystemConceptPropertyList;
begin
  if FProperty_List = nil then
    FProperty_List := TFhirCodeSystemConceptPropertyList.Create;
  result := FProperty_List;
end;

Function TFhirCodeSystemConcept.GetHasProperty_List : boolean;
begin
  result := (FProperty_List <> nil) and (FProperty_List.count > 0);
end;

Function TFhirCodeSystemConcept.GetConceptList : TFhirCodeSystemConceptList;
begin
  if FConceptList = nil then
    FConceptList := TFhirCodeSystemConceptList.Create;
  result := FConceptList;
end;

Function TFhirCodeSystemConcept.GetHasConceptList : boolean;
begin
  result := (FConceptList <> nil) and (FConceptList.count > 0);
end;

function TFhirCodeSystemConcept.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FDisplay.sizeInBytes);
  inc(result, FDefinition.sizeInBytes);
  inc(result, FdesignationList.sizeInBytes);
  inc(result, Fproperty_List.sizeInBytes);
  inc(result, FconceptList.sizeInBytes);
end;

{ TFhirCodeSystemConceptListEnumerator }

Constructor TFhirCodeSystemConceptListEnumerator.Create(list : TFhirCodeSystemConceptList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCodeSystemConceptListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCodeSystemConceptListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCodeSystemConceptListEnumerator.GetCurrent : TFhirCodeSystemConcept;
begin
  Result := FList[FIndex];
end;

function TFhirCodeSystemConceptListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCodeSystemConceptList }
procedure TFhirCodeSystemConceptList.AddItem(value: TFhirCodeSystemConcept);
begin
  assert(value.ClassName = 'TFhirCodeSystemConcept', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCodeSystemConcept');
  add(value);
end;

function TFhirCodeSystemConceptList.Append: TFhirCodeSystemConcept;
begin
  result := TFhirCodeSystemConcept.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCodeSystemConceptList.ClearItems;
begin
  Clear;
end;

function TFhirCodeSystemConceptList.GetEnumerator : TFhirCodeSystemConceptListEnumerator;
begin
  result := TFhirCodeSystemConceptListEnumerator.Create(self.link);
end;

function TFhirCodeSystemConceptList.Clone: TFhirCodeSystemConceptList;
begin
  result := TFhirCodeSystemConceptList(inherited Clone);
end;

function TFhirCodeSystemConceptList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCodeSystemConceptList.GetItemN(index: Integer): TFhirCodeSystemConcept;
begin
  result := TFhirCodeSystemConcept(ObjectByIndex[index]);
end;

function TFhirCodeSystemConceptList.ItemClass: TFslObjectClass;
begin
  result := TFhirCodeSystemConcept;
end;
function TFhirCodeSystemConceptList.IndexOf(value: TFhirCodeSystemConcept): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCodeSystemConceptList.Insert(index: Integer): TFhirCodeSystemConcept;
begin
  result := TFhirCodeSystemConcept.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCodeSystemConceptList.InsertItem(index: Integer; value: TFhirCodeSystemConcept);
begin
  assert(value is TFhirCodeSystemConcept);
  Inherited Insert(index, value);
end;

function TFhirCodeSystemConceptList.Item(index: Integer): TFhirCodeSystemConcept;
begin
  result := TFhirCodeSystemConcept(ObjectByIndex[index]);
end;

function TFhirCodeSystemConceptList.Link: TFhirCodeSystemConceptList;
begin
  result := TFhirCodeSystemConceptList(inherited Link);
end;

procedure TFhirCodeSystemConceptList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCodeSystemConceptList.SetItemByIndex(index: Integer; value: TFhirCodeSystemConcept);
begin
  assert(value is TFhirCodeSystemConcept);
  FhirCodeSystemConcepts[index] := value;
end;

procedure TFhirCodeSystemConceptList.SetItemN(index: Integer; value: TFhirCodeSystemConcept);
begin
  assert(value is TFhirCodeSystemConcept);
  ObjectByIndex[index] := value;
end;

{ TFhirCodeSystemConceptDesignation }

constructor TFhirCodeSystemConceptDesignation.Create;
begin
  inherited;
end;

destructor TFhirCodeSystemConceptDesignation.Destroy;
begin
  FLanguage.free;
  FUse.free;
  FValue.free;
  inherited;
end;

procedure TFhirCodeSystemConceptDesignation.Assign(oSource : TFslObject);
begin
  inherited;
  languageElement := TFhirCodeSystemConceptDesignation(oSource).languageElement.Clone;
  use := TFhirCodeSystemConceptDesignation(oSource).use.Clone;
  valueElement := TFhirCodeSystemConceptDesignation(oSource).valueElement.Clone;
end;

procedure TFhirCodeSystemConceptDesignation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'language') Then
     list.add(self.link, 'language', FLanguage.Link);
  if (child_name = 'use') Then
     list.add(self.link, 'use', FUse.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirCodeSystemConceptDesignation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'language', 'code', false, TFhirCode, FLanguage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'use', 'Coding', false, TFhirCoding, FUse.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value', 'string', false, TFhirString, FValue.Link));{2}
end;

function TFhirCodeSystemConceptDesignation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'language') then
  begin
    LanguageElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'use') then
  begin
    Use := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCodeSystemConceptDesignation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCodeSystemConceptDesignation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'language') then result := TFhirCode.create() {5b}
  else if (propName = 'use') then result := TFhirCoding.create(){4b}
  else if (propName = 'value') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCodeSystemConceptDesignation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'language') then result := 'code'
  else if (propName = 'use') then result := 'Coding'
  else if (propName = 'value') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCodeSystemConceptDesignation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'language') then LanguageElement := nil
  else if (propName = 'use') then UseElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCodeSystemConceptDesignation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'language') then LanguageElement := asCode(new){5b}
  else if (propName = 'use') then UseElement := new as TFhirCoding{4}
  else if (propName = 'value') then ValueElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCodeSystemConceptDesignation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCodeSystemConceptDesignation.fhirType : string;
begin
  result := 'designation';
end;

function TFhirCodeSystemConceptDesignation.Link : TFhirCodeSystemConceptDesignation;
begin
  result := TFhirCodeSystemConceptDesignation(inherited Link);
end;

function TFhirCodeSystemConceptDesignation.Clone : TFhirCodeSystemConceptDesignation;
begin
  result := TFhirCodeSystemConceptDesignation(inherited Clone);
end;

function TFhirCodeSystemConceptDesignation.equals(other : TObject) : boolean;
var
  o : TFhirCodeSystemConceptDesignation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCodeSystemConceptDesignation)) then
    result := false
  else
  begin
    o := TFhirCodeSystemConceptDesignation(other);
    result := compareDeep(languageElement, o.languageElement, true) and compareDeep(useElement, o.useElement, true) and
      compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirCodeSystemConceptDesignation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLanguage) and isEmptyProp(FUse) and isEmptyProp(FValue);
end;

procedure TFhirCodeSystemConceptDesignation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('language');
  fields.add('use');
  fields.add('value');
end;

{ TFhirCodeSystemConceptDesignation }

Procedure TFhirCodeSystemConceptDesignation.SetLanguage(value : TFhirCode);
begin
  FLanguage.free;
  FLanguage := value;
end;

Function TFhirCodeSystemConceptDesignation.GetLanguageST : String;
begin
  if FLanguage = nil then
    result := ''
  else
    result := FLanguage.value;
end;

Procedure TFhirCodeSystemConceptDesignation.SetLanguageST(value : String);
begin
  if value <> '' then
  begin
    if FLanguage = nil then
      FLanguage := TFhirCode.create;
    FLanguage.value := value
  end
  else if FLanguage <> nil then
    FLanguage.value := '';
end;

Procedure TFhirCodeSystemConceptDesignation.SetUse(value : TFhirCoding);
begin
  FUse.free;
  FUse := value;
end;

Procedure TFhirCodeSystemConceptDesignation.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirCodeSystemConceptDesignation.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

Procedure TFhirCodeSystemConceptDesignation.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

function TFhirCodeSystemConceptDesignation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FLanguage.sizeInBytes);
  inc(result, FUse.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirCodeSystemConceptDesignationListEnumerator }

Constructor TFhirCodeSystemConceptDesignationListEnumerator.Create(list : TFhirCodeSystemConceptDesignationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCodeSystemConceptDesignationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCodeSystemConceptDesignationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCodeSystemConceptDesignationListEnumerator.GetCurrent : TFhirCodeSystemConceptDesignation;
begin
  Result := FList[FIndex];
end;

function TFhirCodeSystemConceptDesignationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCodeSystemConceptDesignationList }
procedure TFhirCodeSystemConceptDesignationList.AddItem(value: TFhirCodeSystemConceptDesignation);
begin
  assert(value.ClassName = 'TFhirCodeSystemConceptDesignation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCodeSystemConceptDesignation');
  add(value);
end;

function TFhirCodeSystemConceptDesignationList.Append: TFhirCodeSystemConceptDesignation;
begin
  result := TFhirCodeSystemConceptDesignation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCodeSystemConceptDesignationList.ClearItems;
begin
  Clear;
end;

function TFhirCodeSystemConceptDesignationList.GetEnumerator : TFhirCodeSystemConceptDesignationListEnumerator;
begin
  result := TFhirCodeSystemConceptDesignationListEnumerator.Create(self.link);
end;

function TFhirCodeSystemConceptDesignationList.Clone: TFhirCodeSystemConceptDesignationList;
begin
  result := TFhirCodeSystemConceptDesignationList(inherited Clone);
end;

function TFhirCodeSystemConceptDesignationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCodeSystemConceptDesignationList.GetItemN(index: Integer): TFhirCodeSystemConceptDesignation;
begin
  result := TFhirCodeSystemConceptDesignation(ObjectByIndex[index]);
end;

function TFhirCodeSystemConceptDesignationList.ItemClass: TFslObjectClass;
begin
  result := TFhirCodeSystemConceptDesignation;
end;
function TFhirCodeSystemConceptDesignationList.IndexOf(value: TFhirCodeSystemConceptDesignation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCodeSystemConceptDesignationList.Insert(index: Integer): TFhirCodeSystemConceptDesignation;
begin
  result := TFhirCodeSystemConceptDesignation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCodeSystemConceptDesignationList.InsertItem(index: Integer; value: TFhirCodeSystemConceptDesignation);
begin
  assert(value is TFhirCodeSystemConceptDesignation);
  Inherited Insert(index, value);
end;

function TFhirCodeSystemConceptDesignationList.Item(index: Integer): TFhirCodeSystemConceptDesignation;
begin
  result := TFhirCodeSystemConceptDesignation(ObjectByIndex[index]);
end;

function TFhirCodeSystemConceptDesignationList.Link: TFhirCodeSystemConceptDesignationList;
begin
  result := TFhirCodeSystemConceptDesignationList(inherited Link);
end;

procedure TFhirCodeSystemConceptDesignationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCodeSystemConceptDesignationList.SetItemByIndex(index: Integer; value: TFhirCodeSystemConceptDesignation);
begin
  assert(value is TFhirCodeSystemConceptDesignation);
  FhirCodeSystemConceptDesignations[index] := value;
end;

procedure TFhirCodeSystemConceptDesignationList.SetItemN(index: Integer; value: TFhirCodeSystemConceptDesignation);
begin
  assert(value is TFhirCodeSystemConceptDesignation);
  ObjectByIndex[index] := value;
end;

{ TFhirCodeSystemConceptProperty }

constructor TFhirCodeSystemConceptProperty.Create;
begin
  inherited;
end;

destructor TFhirCodeSystemConceptProperty.Destroy;
begin
  FCode.free;
  FValue.free;
  inherited;
end;

procedure TFhirCodeSystemConceptProperty.Assign(oSource : TFslObject);
begin
  inherited;
  codeElement := TFhirCodeSystemConceptProperty(oSource).codeElement.Clone;
  value := TFhirCodeSystemConceptProperty(oSource).value.Clone;
end;

procedure TFhirCodeSystemConceptProperty.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirCodeSystemConceptProperty.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirCode, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value[x]', 'code|Coding|string|integer|boolean|dateTime', false, TFhirType, FValue.Link));{2}
end;

function TFhirCodeSystemConceptProperty.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asCode(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['Code', 'Coding', 'String', 'Integer', 'Boolean', 'DateTime'])) then
  begin
    Value := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCodeSystemConceptProperty.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCodeSystemConceptProperty.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCode.create() {5b}
  else if (isMatchingName(propName, 'value', ['Code', 'Coding', 'String', 'Integer', 'Boolean', 'DateTime'])) then raise EFHIRException.create('Cannot make property Value'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCodeSystemConceptProperty.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'code'
  else if (propName = 'value[x]') then result := 'code|Coding|string|integer|boolean|dateTime'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCodeSystemConceptProperty.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (isMatchingName(propName, 'value', ['Code', 'Coding', 'String', 'Integer', 'Boolean', 'DateTime'])) then ValueElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCodeSystemConceptProperty.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asCode(new){5b}
  else if (isMatchingName(propName, 'value', ['Code', 'Coding', 'String', 'Integer', 'Boolean', 'DateTime'])) then ValueElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCodeSystemConceptProperty.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCodeSystemConceptProperty.fhirType : string;
begin
  result := 'property';
end;

function TFhirCodeSystemConceptProperty.Link : TFhirCodeSystemConceptProperty;
begin
  result := TFhirCodeSystemConceptProperty(inherited Link);
end;

function TFhirCodeSystemConceptProperty.Clone : TFhirCodeSystemConceptProperty;
begin
  result := TFhirCodeSystemConceptProperty(inherited Clone);
end;

function TFhirCodeSystemConceptProperty.equals(other : TObject) : boolean;
var
  o : TFhirCodeSystemConceptProperty;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCodeSystemConceptProperty)) then
    result := false
  else
  begin
    o := TFhirCodeSystemConceptProperty(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirCodeSystemConceptProperty.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FValue);
end;

procedure TFhirCodeSystemConceptProperty.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('value[x]');
end;

{ TFhirCodeSystemConceptProperty }

Procedure TFhirCodeSystemConceptProperty.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirCodeSystemConceptProperty.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

Procedure TFhirCodeSystemConceptProperty.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

Procedure TFhirCodeSystemConceptProperty.SetValue(value : TFhirType);
begin
  FValue.free;
  FValue := value;
end;

function TFhirCodeSystemConceptProperty.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirCodeSystemConceptPropertyListEnumerator }

Constructor TFhirCodeSystemConceptPropertyListEnumerator.Create(list : TFhirCodeSystemConceptPropertyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCodeSystemConceptPropertyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCodeSystemConceptPropertyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCodeSystemConceptPropertyListEnumerator.GetCurrent : TFhirCodeSystemConceptProperty;
begin
  Result := FList[FIndex];
end;

function TFhirCodeSystemConceptPropertyListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCodeSystemConceptPropertyList }
procedure TFhirCodeSystemConceptPropertyList.AddItem(value: TFhirCodeSystemConceptProperty);
begin
  assert(value.ClassName = 'TFhirCodeSystemConceptProperty', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCodeSystemConceptProperty');
  add(value);
end;

function TFhirCodeSystemConceptPropertyList.Append: TFhirCodeSystemConceptProperty;
begin
  result := TFhirCodeSystemConceptProperty.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCodeSystemConceptPropertyList.ClearItems;
begin
  Clear;
end;

function TFhirCodeSystemConceptPropertyList.GetEnumerator : TFhirCodeSystemConceptPropertyListEnumerator;
begin
  result := TFhirCodeSystemConceptPropertyListEnumerator.Create(self.link);
end;

function TFhirCodeSystemConceptPropertyList.Clone: TFhirCodeSystemConceptPropertyList;
begin
  result := TFhirCodeSystemConceptPropertyList(inherited Clone);
end;

function TFhirCodeSystemConceptPropertyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCodeSystemConceptPropertyList.GetItemN(index: Integer): TFhirCodeSystemConceptProperty;
begin
  result := TFhirCodeSystemConceptProperty(ObjectByIndex[index]);
end;

function TFhirCodeSystemConceptPropertyList.ItemClass: TFslObjectClass;
begin
  result := TFhirCodeSystemConceptProperty;
end;
function TFhirCodeSystemConceptPropertyList.IndexOf(value: TFhirCodeSystemConceptProperty): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCodeSystemConceptPropertyList.Insert(index: Integer): TFhirCodeSystemConceptProperty;
begin
  result := TFhirCodeSystemConceptProperty.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCodeSystemConceptPropertyList.InsertItem(index: Integer; value: TFhirCodeSystemConceptProperty);
begin
  assert(value is TFhirCodeSystemConceptProperty);
  Inherited Insert(index, value);
end;

function TFhirCodeSystemConceptPropertyList.Item(index: Integer): TFhirCodeSystemConceptProperty;
begin
  result := TFhirCodeSystemConceptProperty(ObjectByIndex[index]);
end;

function TFhirCodeSystemConceptPropertyList.Link: TFhirCodeSystemConceptPropertyList;
begin
  result := TFhirCodeSystemConceptPropertyList(inherited Link);
end;

procedure TFhirCodeSystemConceptPropertyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCodeSystemConceptPropertyList.SetItemByIndex(index: Integer; value: TFhirCodeSystemConceptProperty);
begin
  assert(value is TFhirCodeSystemConceptProperty);
  FhirCodeSystemConceptProperties[index] := value;
end;

procedure TFhirCodeSystemConceptPropertyList.SetItemN(index: Integer; value: TFhirCodeSystemConceptProperty);
begin
  assert(value is TFhirCodeSystemConceptProperty);
  ObjectByIndex[index] := value;
end;

{ TFhirCodeSystem }

constructor TFhirCodeSystem.Create;
begin
  inherited;
end;

destructor TFhirCodeSystem.Destroy;
begin
  FIdentifier.free;
  FPurpose.free;
  FCopyright.free;
  FCaseSensitive.free;
  FValueSet.free;
  FHierarchyMeaning.free;
  FCompositional.free;
  FVersionNeeded.free;
  FContent.free;
  FCount.free;
  FFilterList.Free;
  FProperty_List.Free;
  FConceptList.Free;
  inherited;
end;

function TFhirCodeSystem.GetResourceType : TFhirResourceType;
begin
  result := frtCodeSystem;
end;

procedure TFhirCodeSystem.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirCodeSystem(oSource).identifier.Clone;
  purposeElement := TFhirCodeSystem(oSource).purposeElement.Clone;
  copyrightElement := TFhirCodeSystem(oSource).copyrightElement.Clone;
  caseSensitiveElement := TFhirCodeSystem(oSource).caseSensitiveElement.Clone;
  valueSetElement := TFhirCodeSystem(oSource).valueSetElement.Clone;
  FHierarchyMeaning := TFhirCodeSystem(oSource).FHierarchyMeaning.Link;
  compositionalElement := TFhirCodeSystem(oSource).compositionalElement.Clone;
  versionNeededElement := TFhirCodeSystem(oSource).versionNeededElement.Clone;
  FContent := TFhirCodeSystem(oSource).FContent.Link;
  countElement := TFhirCodeSystem(oSource).countElement.Clone;
  if (TFhirCodeSystem(oSource).FFilterList = nil) then
  begin
    FFilterList.free;
    FFilterList := nil;
  end
  else
  begin
    if FFilterList = nil then
      FFilterList := TFhirCodeSystemFilterList.Create;
    FFilterList.Assign(TFhirCodeSystem(oSource).FFilterList);
  end;
  if (TFhirCodeSystem(oSource).FProperty_List = nil) then
  begin
    FProperty_List.free;
    FProperty_List := nil;
  end
  else
  begin
    if FProperty_List = nil then
      FProperty_List := TFhirCodeSystemPropertyList.Create;
    FProperty_List.Assign(TFhirCodeSystem(oSource).FProperty_List);
  end;
  if (TFhirCodeSystem(oSource).FConceptList = nil) then
  begin
    FConceptList.free;
    FConceptList := nil;
  end
  else
  begin
    if FConceptList = nil then
      FConceptList := TFhirCodeSystemConceptList.Create;
    FConceptList.Assign(TFhirCodeSystem(oSource).FConceptList);
  end;
end;

procedure TFhirCodeSystem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'caseSensitive') Then
     list.add(self.link, 'caseSensitive', FCaseSensitive.Link);
  if (child_name = 'valueSet') Then
     list.add(self.link, 'valueSet', FValueSet.Link);
  if (child_name = 'hierarchyMeaning') Then
     list.add(self.link, 'hierarchyMeaning', FHierarchyMeaning.Link);
  if (child_name = 'compositional') Then
     list.add(self.link, 'compositional', FCompositional.Link);
  if (child_name = 'versionNeeded') Then
     list.add(self.link, 'versionNeeded', FVersionNeeded.Link);
  if (child_name = 'content') Then
     list.add(self.link, 'content', FContent.Link);
  if (child_name = 'count') Then
     list.add(self.link, 'count', FCount.Link);
  if (child_name = 'filter') Then
    list.addAll(self, 'filter', FFilterList);
  if (child_name = 'property') Then
    list.addAll(self, 'property', FProperty_List);
  if (child_name = 'concept') Then
    list.addAll(self, 'concept', FConceptList);
end;

procedure TFhirCodeSystem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));{2}
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));{2}
  oList.add(TFHIRProperty.create(self, 'caseSensitive', 'boolean', false, TFhirBoolean, FCaseSensitive.Link));{2}
  oList.add(TFHIRProperty.create(self, 'valueSet', 'uri', false, TFhirUri, FValueSet.Link));{2}
  oList.add(TFHIRProperty.create(self, 'hierarchyMeaning', 'code', false, TFHIREnum, FHierarchyMeaning.Link));{1}
  oList.add(TFHIRProperty.create(self, 'compositional', 'boolean', false, TFhirBoolean, FCompositional.Link));{2}
  oList.add(TFHIRProperty.create(self, 'versionNeeded', 'boolean', false, TFhirBoolean, FVersionNeeded.Link));{2}
  oList.add(TFHIRProperty.create(self, 'content', 'code', false, TFHIREnum, FContent.Link));{1}
  oList.add(TFHIRProperty.create(self, 'count', 'unsignedInt', false, TFhirUnsignedInt, FCount.Link));{2}
  oList.add(TFHIRProperty.create(self, 'filter', '', true, TFhirCodeSystemFilter, FFilterList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'property', '', true, TFhirCodeSystemProperty, FProperty_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'concept', '', true, TFhirCodeSystemConcept, FConceptList.Link)){3};
end;

function TFhirCodeSystem.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'caseSensitive') then
  begin
    CaseSensitiveElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'valueSet') then
  begin
    ValueSetElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'hierarchyMeaning') then
  begin
    HierarchyMeaningElement := asEnum(SYSTEMS_TFhirCodesystemHierarchyMeaningEnum, CODES_TFhirCodesystemHierarchyMeaningEnum, propValue);
    result := propValue
  end
  else if (propName = 'compositional') then
  begin
    CompositionalElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'versionNeeded') then
  begin
    VersionNeededElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'content') then
  begin
    ContentElement := asEnum(SYSTEMS_TFhirCodesystemContentModeEnum, CODES_TFhirCodesystemContentModeEnum, propValue);
    result := propValue
  end
  else if (propName = 'count') then
  begin
    CountElement := asUnsignedInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'filter') then
  begin
    FilterList.add(propValue as TFhirCodeSystemFilter){2a};
    result := propValue;
  end
  else if (propName = 'property') then
  begin
    Property_List.add(propValue as TFhirCodeSystemProperty){2a};
    result := propValue;
  end
  else if (propName = 'concept') then
  begin
    ConceptList.add(propValue as TFhirCodeSystemConcept){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirCodeSystem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'filter') then FilterList.insertItem(index, propValue as TFhirCodeSystemFilter){2a}
  else if (propName = 'property') then Property_List.insertItem(index, propValue as TFhirCodeSystemProperty){2a}
  else if (propName = 'concept') then ConceptList.insertItem(index, propValue as TFhirCodeSystemConcept){2a}
  else inherited;
end;

function TFhirCodeSystem.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'purpose') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'copyright') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'caseSensitive') then result := TFhirBoolean.create() {5b}
  else if (propName = 'valueSet') then result := TFhirUri.create() {5b}
  else if (propName = 'compositional') then result := TFhirBoolean.create() {5b}
  else if (propName = 'versionNeeded') then result := TFhirBoolean.create() {5b}
  else if (propName = 'count') then result := TFhirUnsignedInt.create() {5b}
  else if (propName = 'filter') then result := FilterList.new(){2}
  else if (propName = 'property') then result := Property_List.new(){2}
  else if (propName = 'concept') then result := ConceptList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCodeSystem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'caseSensitive') then result := 'boolean'
  else if (propName = 'valueSet') then result := 'uri'
  else if (propName = 'hierarchyMeaning') then result := 'code'
  else if (propName = 'compositional') then result := 'boolean'
  else if (propName = 'versionNeeded') then result := 'boolean'
  else if (propName = 'content') then result := 'code'
  else if (propName = 'count') then result := 'unsignedInt'
  else if (propName = 'filter') then result := ''
  else if (propName = 'property') then result := ''
  else if (propName = 'concept') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCodeSystem.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'caseSensitive') then CaseSensitiveElement := nil
  else if (propName = 'valueSet') then ValueSetElement := nil
  else if (propName = 'hierarchyMeaning') then HierarchyMeaningElement := nil
  else if (propName = 'compositional') then CompositionalElement := nil
  else if (propName = 'versionNeeded') then VersionNeededElement := nil
  else if (propName = 'content') then ContentElement := nil
  else if (propName = 'count') then CountElement := nil
  else if (propName = 'filter') then deletePropertyValue('filter', FilterList, value) {2}
  else if (propName = 'property') then deletePropertyValue('property', Property_List, value) {2}
  else if (propName = 'concept') then deletePropertyValue('concept', ConceptList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCodeSystem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'purpose') then PurposeElement := asMarkdown(new){5b}
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new){5b}
  else if (propName = 'caseSensitive') then CaseSensitiveElement := asBoolean(new){5b}
  else if (propName = 'valueSet') then ValueSetElement := asUri(new){5b}
  else if (propName = 'hierarchyMeaning') then HierarchyMeaningElement := asEnum(SYSTEMS_TFhirCodesystemHierarchyMeaningEnum, CODES_TFhirCodesystemHierarchyMeaningEnum, new){4}
  else if (propName = 'compositional') then CompositionalElement := asBoolean(new){5b}
  else if (propName = 'versionNeeded') then VersionNeededElement := asBoolean(new){5b}
  else if (propName = 'content') then ContentElement := asEnum(SYSTEMS_TFhirCodesystemContentModeEnum, CODES_TFhirCodesystemContentModeEnum, new){4}
  else if (propName = 'count') then CountElement := asUnsignedInt(new){5b}
  else if (propName = 'filter') then replacePropertyValue('filter', FilterList, existing, new) {2}
  else if (propName = 'property') then replacePropertyValue('property', Property_List, existing, new) {2}
  else if (propName = 'concept') then replacePropertyValue('concept', ConceptList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCodeSystem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'filter') then FilterList.move(source, destination){2a}
  else if (propName = 'property') then Property_List.move(source, destination){2a}
  else if (propName = 'concept') then ConceptList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCodeSystem.fhirType : string;
begin
  result := 'CodeSystem';
end;

function TFhirCodeSystem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FPurpose) and isEmptyProp(FCopyright) and isEmptyProp(FCaseSensitive) and isEmptyProp(FValueSet) and isEmptyProp(FHierarchyMeaning) and isEmptyProp(FCompositional) and isEmptyProp(FVersionNeeded) and isEmptyProp(FContent) and isEmptyProp(FCount) and isEmptyProp(FfilterList) and isEmptyProp(Fproperty_List) and isEmptyProp(FconceptList);
end;

function TFhirCodeSystem.equals(other : TObject) : boolean;
var
  o : TFhirCodeSystem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCodeSystem)) then
    result := false
  else
  begin
    o := TFhirCodeSystem(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(purposeElement, o.purposeElement, true) and
      compareDeep(copyrightElement, o.copyrightElement, true) and compareDeep(caseSensitiveElement, o.caseSensitiveElement, true) and
      compareDeep(valueSetElement, o.valueSetElement, true) and compareDeep(hierarchyMeaningElement, o.hierarchyMeaningElement, true) and
      compareDeep(compositionalElement, o.compositionalElement, true) and compareDeep(versionNeededElement, o.versionNeededElement, true) and
      compareDeep(contentElement, o.contentElement, true) and compareDeep(countElement, o.countElement, true) and
      compareDeep(filterList, o.filterList, true) and compareDeep(property_List, o.property_List, true) and
      compareDeep(conceptList, o.conceptList, true);
  end;
end;

function TFhirCodeSystem.Link : TFhirCodeSystem;
begin
  result := TFhirCodeSystem(inherited Link);
end;

function TFhirCodeSystem.Clone : TFhirCodeSystem;
begin
  result := TFhirCodeSystem(inherited Clone);
end;

procedure TFhirCodeSystem.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('status');
  fields.add('experimental');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('purpose');
  fields.add('copyright');
  fields.add('caseSensitive');
  fields.add('valueSet');
  fields.add('hierarchyMeaning');
  fields.add('compositional');
  fields.add('versionNeeded');
  fields.add('content');
  fields.add('count');
  fields.add('filter');
  fields.add('property');
  fields.add('concept');
end;

{ TFhirCodeSystem }

Procedure TFhirCodeSystem.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirCodeSystem.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

Function TFhirCodeSystem.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

Procedure TFhirCodeSystem.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

Procedure TFhirCodeSystem.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

Function TFhirCodeSystem.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

Procedure TFhirCodeSystem.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

Procedure TFhirCodeSystem.SetCaseSensitive(value : TFhirBoolean);
begin
  FCaseSensitive.free;
  FCaseSensitive := value;
end;

Function TFhirCodeSystem.GetCaseSensitiveST : Boolean;
begin
  if FCaseSensitive = nil then
    result := false
  else
    result := FCaseSensitive.value;
end;

Procedure TFhirCodeSystem.SetCaseSensitiveST(value : Boolean);
begin
  if FCaseSensitive = nil then
    FCaseSensitive := TFhirBoolean.create;
  FCaseSensitive.value := value
end;

Procedure TFhirCodeSystem.SetValueSet(value : TFhirUri);
begin
  FValueSet.free;
  FValueSet := value;
end;

Function TFhirCodeSystem.GetValueSetST : String;
begin
  if FValueSet = nil then
    result := ''
  else
    result := FValueSet.value;
end;

Procedure TFhirCodeSystem.SetValueSetST(value : String);
begin
  if value <> '' then
  begin
    if FValueSet = nil then
      FValueSet := TFhirUri.create;
    FValueSet.value := value
  end
  else if FValueSet <> nil then
    FValueSet.value := '';
end;

Procedure TFhirCodeSystem.SetHierarchyMeaning(value : TFhirEnum);
begin
  FHierarchyMeaning.free;
  FHierarchyMeaning := value;
end;

Function TFhirCodeSystem.GetHierarchyMeaningST : TFhirCodesystemHierarchyMeaningEnum;
begin
  if FHierarchyMeaning = nil then
    result := TFhirCodesystemHierarchyMeaningEnum(0)
  else
    result := TFhirCodesystemHierarchyMeaningEnum(StringArrayIndexOfSensitive(CODES_TFhirCodesystemHierarchyMeaningEnum, FHierarchyMeaning.value));
end;

Procedure TFhirCodeSystem.SetHierarchyMeaningST(value : TFhirCodesystemHierarchyMeaningEnum);
begin
  if ord(value) = 0 then
    HierarchyMeaningElement := nil
  else
    HierarchyMeaningElement := TFhirEnum.create(SYSTEMS_TFhirCodesystemHierarchyMeaningEnum[value], CODES_TFhirCodesystemHierarchyMeaningEnum[value]);
end;

Procedure TFhirCodeSystem.SetCompositional(value : TFhirBoolean);
begin
  FCompositional.free;
  FCompositional := value;
end;

Function TFhirCodeSystem.GetCompositionalST : Boolean;
begin
  if FCompositional = nil then
    result := false
  else
    result := FCompositional.value;
end;

Procedure TFhirCodeSystem.SetCompositionalST(value : Boolean);
begin
  if FCompositional = nil then
    FCompositional := TFhirBoolean.create;
  FCompositional.value := value
end;

Procedure TFhirCodeSystem.SetVersionNeeded(value : TFhirBoolean);
begin
  FVersionNeeded.free;
  FVersionNeeded := value;
end;

Function TFhirCodeSystem.GetVersionNeededST : Boolean;
begin
  if FVersionNeeded = nil then
    result := false
  else
    result := FVersionNeeded.value;
end;

Procedure TFhirCodeSystem.SetVersionNeededST(value : Boolean);
begin
  if FVersionNeeded = nil then
    FVersionNeeded := TFhirBoolean.create;
  FVersionNeeded.value := value
end;

Procedure TFhirCodeSystem.SetContent(value : TFhirEnum);
begin
  FContent.free;
  FContent := value;
end;

Function TFhirCodeSystem.GetContentST : TFhirCodesystemContentModeEnum;
begin
  if FContent = nil then
    result := TFhirCodesystemContentModeEnum(0)
  else
    result := TFhirCodesystemContentModeEnum(StringArrayIndexOfSensitive(CODES_TFhirCodesystemContentModeEnum, FContent.value));
end;

Procedure TFhirCodeSystem.SetContentST(value : TFhirCodesystemContentModeEnum);
begin
  if ord(value) = 0 then
    ContentElement := nil
  else
    ContentElement := TFhirEnum.create(SYSTEMS_TFhirCodesystemContentModeEnum[value], CODES_TFhirCodesystemContentModeEnum[value]);
end;

Procedure TFhirCodeSystem.SetCount(value : TFhirUnsignedInt);
begin
  FCount.free;
  FCount := value;
end;

Function TFhirCodeSystem.GetCountST : String;
begin
  if FCount = nil then
    result := ''
  else
    result := FCount.value;
end;

Procedure TFhirCodeSystem.SetCountST(value : String);
begin
  if value <> '' then
  begin
    if FCount = nil then
      FCount := TFhirUnsignedInt.create;
    FCount.value := value
  end
  else if FCount <> nil then
    FCount.value := '';
end;

Function TFhirCodeSystem.GetFilterList : TFhirCodeSystemFilterList;
begin
  if FFilterList = nil then
    FFilterList := TFhirCodeSystemFilterList.Create;
  result := FFilterList;
end;

Function TFhirCodeSystem.GetHasFilterList : boolean;
begin
  result := (FFilterList <> nil) and (FFilterList.count > 0);
end;

Function TFhirCodeSystem.GetProperty_List : TFhirCodeSystemPropertyList;
begin
  if FProperty_List = nil then
    FProperty_List := TFhirCodeSystemPropertyList.Create;
  result := FProperty_List;
end;

Function TFhirCodeSystem.GetHasProperty_List : boolean;
begin
  result := (FProperty_List <> nil) and (FProperty_List.count > 0);
end;

Function TFhirCodeSystem.GetConceptList : TFhirCodeSystemConceptList;
begin
  if FConceptList = nil then
    FConceptList := TFhirCodeSystemConceptList.Create;
  result := FConceptList;
end;

Function TFhirCodeSystem.GetHasConceptList : boolean;
begin
  result := (FConceptList <> nil) and (FConceptList.count > 0);
end;

function TFhirCodeSystem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FPurpose.sizeInBytes);
  inc(result, FCopyright.sizeInBytes);
  inc(result, FCaseSensitive.sizeInBytes);
  inc(result, FValueSet.sizeInBytes);
  inc(result, FHierarchyMeaning.sizeInBytes);
  inc(result, FCompositional.sizeInBytes);
  inc(result, FVersionNeeded.sizeInBytes);
  inc(result, FContent.sizeInBytes);
  inc(result, FCount.sizeInBytes);
  inc(result, FfilterList.sizeInBytes);
  inc(result, Fproperty_List.sizeInBytes);
  inc(result, FconceptList.sizeInBytes);
end;

{ TFhirCodeSystemListEnumerator }

Constructor TFhirCodeSystemListEnumerator.Create(list : TFhirCodeSystemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCodeSystemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCodeSystemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCodeSystemListEnumerator.GetCurrent : TFhirCodeSystem;
begin
  Result := FList[FIndex];
end;

function TFhirCodeSystemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCodeSystemList }
procedure TFhirCodeSystemList.AddItem(value: TFhirCodeSystem);
begin
  assert(value.ClassName = 'TFhirCodeSystem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCodeSystem');
  add(value);
end;

function TFhirCodeSystemList.Append: TFhirCodeSystem;
begin
  result := TFhirCodeSystem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCodeSystemList.ClearItems;
begin
  Clear;
end;

function TFhirCodeSystemList.GetEnumerator : TFhirCodeSystemListEnumerator;
begin
  result := TFhirCodeSystemListEnumerator.Create(self.link);
end;

function TFhirCodeSystemList.Clone: TFhirCodeSystemList;
begin
  result := TFhirCodeSystemList(inherited Clone);
end;

function TFhirCodeSystemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCodeSystemList.GetItemN(index: Integer): TFhirCodeSystem;
begin
  result := TFhirCodeSystem(ObjectByIndex[index]);
end;

function TFhirCodeSystemList.ItemClass: TFslObjectClass;
begin
  result := TFhirCodeSystem;
end;
function TFhirCodeSystemList.IndexOf(value: TFhirCodeSystem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCodeSystemList.Insert(index: Integer): TFhirCodeSystem;
begin
  result := TFhirCodeSystem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCodeSystemList.InsertItem(index: Integer; value: TFhirCodeSystem);
begin
  assert(value is TFhirCodeSystem);
  Inherited Insert(index, value);
end;

function TFhirCodeSystemList.Item(index: Integer): TFhirCodeSystem;
begin
  result := TFhirCodeSystem(ObjectByIndex[index]);
end;

function TFhirCodeSystemList.Link: TFhirCodeSystemList;
begin
  result := TFhirCodeSystemList(inherited Link);
end;

procedure TFhirCodeSystemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCodeSystemList.SetItemByIndex(index: Integer; value: TFhirCodeSystem);
begin
  assert(value is TFhirCodeSystem);
  FhirCodeSystems[index] := value;
end;

procedure TFhirCodeSystemList.SetItemN(index: Integer; value: TFhirCodeSystem);
begin
  assert(value is TFhirCodeSystem);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CODESYSTEM}

{$IFDEF FHIR_COMPARTMENTDEFINITION}

{ TFhirCompartmentDefinitionResource }

constructor TFhirCompartmentDefinitionResource.Create;
begin
  inherited;
end;

destructor TFhirCompartmentDefinitionResource.Destroy;
begin
  FCode.free;
  FParamList.Free;
  FDocumentation.free;
  inherited;
end;

procedure TFhirCompartmentDefinitionResource.Assign(oSource : TFslObject);
begin
  inherited;
  FCode := TFhirCompartmentDefinitionResource(oSource).FCode.Link;
  if (TFhirCompartmentDefinitionResource(oSource).FParamList = nil) then
  begin
    FParamList.free;
    FParamList := nil;
  end
  else
  begin
    if FParamList = nil then
      FParamList := TFhirStringList.Create;
    FParamList.Assign(TFhirCompartmentDefinitionResource(oSource).FParamList);
  end;
  documentationElement := TFhirCompartmentDefinitionResource(oSource).documentationElement.Clone;
end;

procedure TFhirCompartmentDefinitionResource.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'param') Then
    list.addAll(self, 'param', FParamList);
  if (child_name = 'documentation') Then
     list.add(self.link, 'documentation', FDocumentation.Link);
end;

procedure TFhirCompartmentDefinitionResource.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFHIREnum, FCode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'param', 'string', true, TFhirString, FParamList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', false, TFhirString, FDocumentation.Link));{2}
end;

function TFhirCompartmentDefinitionResource.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue);
    result := propValue
  end
  else if (propName = 'param') then
  begin
    ParamList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'documentation') then
  begin
    DocumentationElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCompartmentDefinitionResource.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'param') then ParamList.insertItem(index, asString(propValue)){2}
  else inherited;
end;

function TFhirCompartmentDefinitionResource.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'param') then result := ParamList.new(){2}
  else if (propName = 'documentation') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCompartmentDefinitionResource.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'code'
  else if (propName = 'param') then result := 'string'
  else if (propName = 'documentation') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCompartmentDefinitionResource.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'param') then deletePropertyValue('param', ParamList, value) {2}
  else if (propName = 'documentation') then DocumentationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCompartmentDefinitionResource.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, new){4}
  else if (propName = 'param') then replacePropertyValue('param', ParamList, existing, new) {2}
  else if (propName = 'documentation') then DocumentationElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCompartmentDefinitionResource.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'param') then ParamList.move(source, destination){2}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCompartmentDefinitionResource.fhirType : string;
begin
  result := 'resource';
end;

function TFhirCompartmentDefinitionResource.Link : TFhirCompartmentDefinitionResource;
begin
  result := TFhirCompartmentDefinitionResource(inherited Link);
end;

function TFhirCompartmentDefinitionResource.Clone : TFhirCompartmentDefinitionResource;
begin
  result := TFhirCompartmentDefinitionResource(inherited Clone);
end;

function TFhirCompartmentDefinitionResource.equals(other : TObject) : boolean;
var
  o : TFhirCompartmentDefinitionResource;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCompartmentDefinitionResource)) then
    result := false
  else
  begin
    o := TFhirCompartmentDefinitionResource(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(paramList, o.paramList, true) and
      compareDeep(documentationElement, o.documentationElement, true);
  end;
end;

function TFhirCompartmentDefinitionResource.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FparamList) and isEmptyProp(FDocumentation);
end;

procedure TFhirCompartmentDefinitionResource.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('param');
  fields.add('documentation');
end;

{ TFhirCompartmentDefinitionResource }

Procedure TFhirCompartmentDefinitionResource.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirCompartmentDefinitionResource.GetCodeST : TFhirResourceTypesEnum;
begin
  if FCode = nil then
    result := TFhirResourceTypesEnum(0)
  else
    result := TFhirResourceTypesEnum(StringArrayIndexOfSensitive(CODES_TFhirResourceTypesEnum, FCode.value));
end;

Procedure TFhirCompartmentDefinitionResource.SetCodeST(value : TFhirResourceTypesEnum);
begin
  if ord(value) = 0 then
    CodeElement := nil
  else
    CodeElement := TFhirEnum.create(SYSTEMS_TFhirResourceTypesEnum[value], CODES_TFhirResourceTypesEnum[value]);
end;

Function TFhirCompartmentDefinitionResource.GetParamList : TFhirStringList;
begin
  if FParamList = nil then
    FParamList := TFhirStringList.Create;
  result := FParamList;
end;

Function TFhirCompartmentDefinitionResource.GetHasParamList : boolean;
begin
  result := (FParamList <> nil) and (FParamList.count > 0);
end;

Procedure TFhirCompartmentDefinitionResource.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirCompartmentDefinitionResource.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

Procedure TFhirCompartmentDefinitionResource.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

function TFhirCompartmentDefinitionResource.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FparamList.sizeInBytes);
  inc(result, FDocumentation.sizeInBytes);
end;

{ TFhirCompartmentDefinitionResourceListEnumerator }

Constructor TFhirCompartmentDefinitionResourceListEnumerator.Create(list : TFhirCompartmentDefinitionResourceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCompartmentDefinitionResourceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCompartmentDefinitionResourceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCompartmentDefinitionResourceListEnumerator.GetCurrent : TFhirCompartmentDefinitionResource;
begin
  Result := FList[FIndex];
end;

function TFhirCompartmentDefinitionResourceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCompartmentDefinitionResourceList }
procedure TFhirCompartmentDefinitionResourceList.AddItem(value: TFhirCompartmentDefinitionResource);
begin
  assert(value.ClassName = 'TFhirCompartmentDefinitionResource', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCompartmentDefinitionResource');
  add(value);
end;

function TFhirCompartmentDefinitionResourceList.Append: TFhirCompartmentDefinitionResource;
begin
  result := TFhirCompartmentDefinitionResource.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompartmentDefinitionResourceList.ClearItems;
begin
  Clear;
end;

function TFhirCompartmentDefinitionResourceList.GetEnumerator : TFhirCompartmentDefinitionResourceListEnumerator;
begin
  result := TFhirCompartmentDefinitionResourceListEnumerator.Create(self.link);
end;

function TFhirCompartmentDefinitionResourceList.Clone: TFhirCompartmentDefinitionResourceList;
begin
  result := TFhirCompartmentDefinitionResourceList(inherited Clone);
end;

function TFhirCompartmentDefinitionResourceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCompartmentDefinitionResourceList.GetItemN(index: Integer): TFhirCompartmentDefinitionResource;
begin
  result := TFhirCompartmentDefinitionResource(ObjectByIndex[index]);
end;

function TFhirCompartmentDefinitionResourceList.ItemClass: TFslObjectClass;
begin
  result := TFhirCompartmentDefinitionResource;
end;
function TFhirCompartmentDefinitionResourceList.IndexOf(value: TFhirCompartmentDefinitionResource): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCompartmentDefinitionResourceList.Insert(index: Integer): TFhirCompartmentDefinitionResource;
begin
  result := TFhirCompartmentDefinitionResource.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompartmentDefinitionResourceList.InsertItem(index: Integer; value: TFhirCompartmentDefinitionResource);
begin
  assert(value is TFhirCompartmentDefinitionResource);
  Inherited Insert(index, value);
end;

function TFhirCompartmentDefinitionResourceList.Item(index: Integer): TFhirCompartmentDefinitionResource;
begin
  result := TFhirCompartmentDefinitionResource(ObjectByIndex[index]);
end;

function TFhirCompartmentDefinitionResourceList.Link: TFhirCompartmentDefinitionResourceList;
begin
  result := TFhirCompartmentDefinitionResourceList(inherited Link);
end;

procedure TFhirCompartmentDefinitionResourceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCompartmentDefinitionResourceList.SetItemByIndex(index: Integer; value: TFhirCompartmentDefinitionResource);
begin
  assert(value is TFhirCompartmentDefinitionResource);
  FhirCompartmentDefinitionResources[index] := value;
end;

procedure TFhirCompartmentDefinitionResourceList.SetItemN(index: Integer; value: TFhirCompartmentDefinitionResource);
begin
  assert(value is TFhirCompartmentDefinitionResource);
  ObjectByIndex[index] := value;
end;

{ TFhirCompartmentDefinition }

constructor TFhirCompartmentDefinition.Create;
begin
  inherited;
end;

destructor TFhirCompartmentDefinition.Destroy;
begin
  FPurpose.free;
  FCode.free;
  FSearch.free;
  FResourceList.Free;
  inherited;
end;

function TFhirCompartmentDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtCompartmentDefinition;
end;

procedure TFhirCompartmentDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  purposeElement := TFhirCompartmentDefinition(oSource).purposeElement.Clone;
  FCode := TFhirCompartmentDefinition(oSource).FCode.Link;
  searchElement := TFhirCompartmentDefinition(oSource).searchElement.Clone;
  if (TFhirCompartmentDefinition(oSource).FResourceList = nil) then
  begin
    FResourceList.free;
    FResourceList := nil;
  end
  else
  begin
    if FResourceList = nil then
      FResourceList := TFhirCompartmentDefinitionResourceList.Create;
    FResourceList.Assign(TFhirCompartmentDefinition(oSource).FResourceList);
  end;
end;

procedure TFhirCompartmentDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'search') Then
     list.add(self.link, 'search', FSearch.Link);
  if (child_name = 'resource') Then
    list.addAll(self, 'resource', FResourceList);
end;

procedure TFhirCompartmentDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFHIREnum, FCode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'search', 'boolean', false, TFhirBoolean, FSearch.Link));{2}
  oList.add(TFHIRProperty.create(self, 'resource', '', true, TFhirCompartmentDefinitionResource, FResourceList.Link)){3};
end;

function TFhirCompartmentDefinition.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeElement := asEnum(SYSTEMS_TFhirCompartmentTypeEnum, CODES_TFhirCompartmentTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'search') then
  begin
    SearchElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    ResourceList.add(propValue as TFhirCompartmentDefinitionResource){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirCompartmentDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'resource') then ResourceList.insertItem(index, propValue as TFhirCompartmentDefinitionResource){2a}
  else inherited;
end;

function TFhirCompartmentDefinition.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'purpose') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'search') then result := TFhirBoolean.create() {5b}
  else if (propName = 'resource') then result := ResourceList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirCompartmentDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'code') then result := 'code'
  else if (propName = 'search') then result := 'boolean'
  else if (propName = 'resource') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCompartmentDefinition.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'search') then SearchElement := nil
  else if (propName = 'resource') then deletePropertyValue('resource', ResourceList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCompartmentDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'purpose') then PurposeElement := asMarkdown(new){5b}
  else if (propName = 'code') then CodeElement := asEnum(SYSTEMS_TFhirCompartmentTypeEnum, CODES_TFhirCompartmentTypeEnum, new){4}
  else if (propName = 'search') then SearchElement := asBoolean(new){5b}
  else if (propName = 'resource') then replacePropertyValue('resource', ResourceList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCompartmentDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'resource') then ResourceList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCompartmentDefinition.fhirType : string;
begin
  result := 'CompartmentDefinition';
end;

function TFhirCompartmentDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPurpose) and isEmptyProp(FCode) and isEmptyProp(FSearch) and isEmptyProp(FresourceList);
end;

function TFhirCompartmentDefinition.equals(other : TObject) : boolean;
var
  o : TFhirCompartmentDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCompartmentDefinition)) then
    result := false
  else
  begin
    o := TFhirCompartmentDefinition(other);
    result := compareDeep(purposeElement, o.purposeElement, true) and compareDeep(codeElement, o.codeElement, true) and
      compareDeep(searchElement, o.searchElement, true) and compareDeep(resourceList, o.resourceList, true);
  end;
end;

function TFhirCompartmentDefinition.Link : TFhirCompartmentDefinition;
begin
  result := TFhirCompartmentDefinition(inherited Link);
end;

function TFhirCompartmentDefinition.Clone : TFhirCompartmentDefinition;
begin
  result := TFhirCompartmentDefinition(inherited Clone);
end;

procedure TFhirCompartmentDefinition.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('url');
  fields.add('name');
  fields.add('title');
  fields.add('status');
  fields.add('experimental');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('purpose');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('code');
  fields.add('search');
  fields.add('resource');
end;

{ TFhirCompartmentDefinition }

Procedure TFhirCompartmentDefinition.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

Function TFhirCompartmentDefinition.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

Procedure TFhirCompartmentDefinition.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

Procedure TFhirCompartmentDefinition.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirCompartmentDefinition.GetCodeST : TFhirCompartmentTypeEnum;
begin
  if FCode = nil then
    result := TFhirCompartmentTypeEnum(0)
  else
    result := TFhirCompartmentTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirCompartmentTypeEnum, FCode.value));
end;

Procedure TFhirCompartmentDefinition.SetCodeST(value : TFhirCompartmentTypeEnum);
begin
  if ord(value) = 0 then
    CodeElement := nil
  else
    CodeElement := TFhirEnum.create(SYSTEMS_TFhirCompartmentTypeEnum[value], CODES_TFhirCompartmentTypeEnum[value]);
end;

Procedure TFhirCompartmentDefinition.SetSearch(value : TFhirBoolean);
begin
  FSearch.free;
  FSearch := value;
end;

Function TFhirCompartmentDefinition.GetSearchST : Boolean;
begin
  if FSearch = nil then
    result := false
  else
    result := FSearch.value;
end;

Procedure TFhirCompartmentDefinition.SetSearchST(value : Boolean);
begin
  if FSearch = nil then
    FSearch := TFhirBoolean.create;
  FSearch.value := value
end;

Function TFhirCompartmentDefinition.GetResourceList : TFhirCompartmentDefinitionResourceList;
begin
  if FResourceList = nil then
    FResourceList := TFhirCompartmentDefinitionResourceList.Create;
  result := FResourceList;
end;

Function TFhirCompartmentDefinition.GetHasResourceList : boolean;
begin
  result := (FResourceList <> nil) and (FResourceList.count > 0);
end;

function TFhirCompartmentDefinition.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FPurpose.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FSearch.sizeInBytes);
  inc(result, FresourceList.sizeInBytes);
end;

{ TFhirCompartmentDefinitionListEnumerator }

Constructor TFhirCompartmentDefinitionListEnumerator.Create(list : TFhirCompartmentDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCompartmentDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCompartmentDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCompartmentDefinitionListEnumerator.GetCurrent : TFhirCompartmentDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirCompartmentDefinitionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirCompartmentDefinitionList }
procedure TFhirCompartmentDefinitionList.AddItem(value: TFhirCompartmentDefinition);
begin
  assert(value.ClassName = 'TFhirCompartmentDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCompartmentDefinition');
  add(value);
end;

function TFhirCompartmentDefinitionList.Append: TFhirCompartmentDefinition;
begin
  result := TFhirCompartmentDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompartmentDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirCompartmentDefinitionList.GetEnumerator : TFhirCompartmentDefinitionListEnumerator;
begin
  result := TFhirCompartmentDefinitionListEnumerator.Create(self.link);
end;

function TFhirCompartmentDefinitionList.Clone: TFhirCompartmentDefinitionList;
begin
  result := TFhirCompartmentDefinitionList(inherited Clone);
end;

function TFhirCompartmentDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCompartmentDefinitionList.GetItemN(index: Integer): TFhirCompartmentDefinition;
begin
  result := TFhirCompartmentDefinition(ObjectByIndex[index]);
end;

function TFhirCompartmentDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirCompartmentDefinition;
end;
function TFhirCompartmentDefinitionList.IndexOf(value: TFhirCompartmentDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCompartmentDefinitionList.Insert(index: Integer): TFhirCompartmentDefinition;
begin
  result := TFhirCompartmentDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompartmentDefinitionList.InsertItem(index: Integer; value: TFhirCompartmentDefinition);
begin
  assert(value is TFhirCompartmentDefinition);
  Inherited Insert(index, value);
end;

function TFhirCompartmentDefinitionList.Item(index: Integer): TFhirCompartmentDefinition;
begin
  result := TFhirCompartmentDefinition(ObjectByIndex[index]);
end;

function TFhirCompartmentDefinitionList.Link: TFhirCompartmentDefinitionList;
begin
  result := TFhirCompartmentDefinitionList(inherited Link);
end;

procedure TFhirCompartmentDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCompartmentDefinitionList.SetItemByIndex(index: Integer; value: TFhirCompartmentDefinition);
begin
  assert(value is TFhirCompartmentDefinition);
  FhirCompartmentDefinitions[index] := value;
end;

procedure TFhirCompartmentDefinitionList.SetItemN(index: Integer; value: TFhirCompartmentDefinition);
begin
  assert(value is TFhirCompartmentDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_COMPARTMENTDEFINITION}

{$IFDEF FHIR_CONCEPTMAP}

{ TFhirConceptMapGroup }

constructor TFhirConceptMapGroup.Create;
begin
  inherited;
end;

destructor TFhirConceptMapGroup.Destroy;
begin
  FSource.free;
  FSourceVersion.free;
  FTarget.free;
  FTargetVersion.free;
  FElementList.Free;
  FUnmapped.free;
  inherited;
end;

procedure TFhirConceptMapGroup.Assign(oSource : TFslObject);
begin
  inherited;
  sourceElement := TFhirConceptMapGroup(oSource).sourceElement.Clone;
  sourceVersionElement := TFhirConceptMapGroup(oSource).sourceVersionElement.Clone;
  targetElement := TFhirConceptMapGroup(oSource).targetElement.Clone;
  targetVersionElement := TFhirConceptMapGroup(oSource).targetVersionElement.Clone;
  if (TFhirConceptMapGroup(oSource).FElementList = nil) then
  begin
    FElementList.free;
    FElementList := nil;
  end
  else
  begin
    if FElementList = nil then
      FElementList := TFhirConceptMapGroupElementList.Create;
    FElementList.Assign(TFhirConceptMapGroup(oSource).FElementList);
  end;
  unmapped := TFhirConceptMapGroup(oSource).unmapped.Clone;
end;

procedure TFhirConceptMapGroup.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'sourceVersion') Then
     list.add(self.link, 'sourceVersion', FSourceVersion.Link);
  if (child_name = 'target') Then
     list.add(self.link, 'target', FTarget.Link);
  if (child_name = 'targetVersion') Then
     list.add(self.link, 'targetVersion', FTargetVersion.Link);
  if (child_name = 'element') Then
    list.addAll(self, 'element', FElementList);
  if (child_name = 'unmapped') Then
     list.add(self.link, 'unmapped', FUnmapped.Link);
end;

procedure TFhirConceptMapGroup.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'source', 'uri', false, TFhirUri, FSource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sourceVersion', 'string', false, TFhirString, FSourceVersion.Link));{2}
  oList.add(TFHIRProperty.create(self, 'target', 'uri', false, TFhirUri, FTarget.Link));{2}
  oList.add(TFHIRProperty.create(self, 'targetVersion', 'string', false, TFhirString, FTargetVersion.Link));{2}
  oList.add(TFHIRProperty.create(self, 'element', '', true, TFhirConceptMapGroupElement, FElementList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'unmapped', '', false, TFhirConceptMapGroupUnmapped, FUnmapped.Link));{2}
end;

function TFhirConceptMapGroup.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'source') then
  begin
    SourceElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'sourceVersion') then
  begin
    SourceVersionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'target') then
  begin
    TargetElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'targetVersion') then
  begin
    TargetVersionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'element') then
  begin
    ElementList.add(propValue as TFhirConceptMapGroupElement){2a};
    result := propValue;
  end
  else if (propName = 'unmapped') then
  begin
    Unmapped := propValue as TFhirConceptMapGroupUnmapped{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConceptMapGroup.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'element') then ElementList.insertItem(index, propValue as TFhirConceptMapGroupElement){2a}
  else inherited;
end;

function TFhirConceptMapGroup.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'source') then result := TFhirUri.create() {5b}
  else if (propName = 'sourceVersion') then result := TFhirString.create() {5b}
  else if (propName = 'target') then result := TFhirUri.create() {5b}
  else if (propName = 'targetVersion') then result := TFhirString.create() {5b}
  else if (propName = 'element') then result := ElementList.new(){2}
  else if (propName = 'unmapped') then result := TFhirConceptMapGroupUnmapped.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConceptMapGroup.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'source') then result := 'uri'
  else if (propName = 'sourceVersion') then result := 'string'
  else if (propName = 'target') then result := 'uri'
  else if (propName = 'targetVersion') then result := 'string'
  else if (propName = 'element') then result := ''
  else if (propName = 'unmapped') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConceptMapGroup.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'source') then SourceElement := nil
  else if (propName = 'sourceVersion') then SourceVersionElement := nil
  else if (propName = 'target') then TargetElement := nil
  else if (propName = 'targetVersion') then TargetVersionElement := nil
  else if (propName = 'element') then deletePropertyValue('element', ElementList, value) {2}
  else if (propName = 'unmapped') then UnmappedElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConceptMapGroup.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'source') then SourceElement := asUri(new){5b}
  else if (propName = 'sourceVersion') then SourceVersionElement := asString(new){5b}
  else if (propName = 'target') then TargetElement := asUri(new){5b}
  else if (propName = 'targetVersion') then TargetVersionElement := asString(new){5b}
  else if (propName = 'element') then replacePropertyValue('element', ElementList, existing, new) {2}
  else if (propName = 'unmapped') then UnmappedElement := new as TFhirConceptMapGroupUnmapped{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConceptMapGroup.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'element') then ElementList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirConceptMapGroup.fhirType : string;
begin
  result := 'group';
end;

function TFhirConceptMapGroup.Link : TFhirConceptMapGroup;
begin
  result := TFhirConceptMapGroup(inherited Link);
end;

function TFhirConceptMapGroup.Clone : TFhirConceptMapGroup;
begin
  result := TFhirConceptMapGroup(inherited Clone);
end;

function TFhirConceptMapGroup.equals(other : TObject) : boolean;
var
  o : TFhirConceptMapGroup;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConceptMapGroup)) then
    result := false
  else
  begin
    o := TFhirConceptMapGroup(other);
    result := compareDeep(sourceElement, o.sourceElement, true) and compareDeep(sourceVersionElement, o.sourceVersionElement, true) and
      compareDeep(targetElement, o.targetElement, true) and compareDeep(targetVersionElement, o.targetVersionElement, true) and
      compareDeep(elementList, o.elementList, true) and compareDeep(unmappedElement, o.unmappedElement, true);
  end;
end;

function TFhirConceptMapGroup.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSource) and isEmptyProp(FSourceVersion) and isEmptyProp(FTarget) and isEmptyProp(FTargetVersion) and isEmptyProp(FelementList) and isEmptyProp(FUnmapped);
end;

procedure TFhirConceptMapGroup.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('source');
  fields.add('sourceVersion');
  fields.add('target');
  fields.add('targetVersion');
  fields.add('element');
  fields.add('unmapped');
end;

{ TFhirConceptMapGroup }

Procedure TFhirConceptMapGroup.SetSource(value : TFhirUri);
begin
  FSource.free;
  FSource := value;
end;

Function TFhirConceptMapGroup.GetSourceST : String;
begin
  if FSource = nil then
    result := ''
  else
    result := FSource.value;
end;

Procedure TFhirConceptMapGroup.SetSourceST(value : String);
begin
  if value <> '' then
  begin
    if FSource = nil then
      FSource := TFhirUri.create;
    FSource.value := value
  end
  else if FSource <> nil then
    FSource.value := '';
end;

Procedure TFhirConceptMapGroup.SetSourceVersion(value : TFhirString);
begin
  FSourceVersion.free;
  FSourceVersion := value;
end;

Function TFhirConceptMapGroup.GetSourceVersionST : String;
begin
  if FSourceVersion = nil then
    result := ''
  else
    result := FSourceVersion.value;
end;

Procedure TFhirConceptMapGroup.SetSourceVersionST(value : String);
begin
  if value <> '' then
  begin
    if FSourceVersion = nil then
      FSourceVersion := TFhirString.create;
    FSourceVersion.value := value
  end
  else if FSourceVersion <> nil then
    FSourceVersion.value := '';
end;

Procedure TFhirConceptMapGroup.SetTarget(value : TFhirUri);
begin
  FTarget.free;
  FTarget := value;
end;

Function TFhirConceptMapGroup.GetTargetST : String;
begin
  if FTarget = nil then
    result := ''
  else
    result := FTarget.value;
end;

Procedure TFhirConceptMapGroup.SetTargetST(value : String);
begin
  if value <> '' then
  begin
    if FTarget = nil then
      FTarget := TFhirUri.create;
    FTarget.value := value
  end
  else if FTarget <> nil then
    FTarget.value := '';
end;

Procedure TFhirConceptMapGroup.SetTargetVersion(value : TFhirString);
begin
  FTargetVersion.free;
  FTargetVersion := value;
end;

Function TFhirConceptMapGroup.GetTargetVersionST : String;
begin
  if FTargetVersion = nil then
    result := ''
  else
    result := FTargetVersion.value;
end;

Procedure TFhirConceptMapGroup.SetTargetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FTargetVersion = nil then
      FTargetVersion := TFhirString.create;
    FTargetVersion.value := value
  end
  else if FTargetVersion <> nil then
    FTargetVersion.value := '';
end;

Function TFhirConceptMapGroup.GetElementList : TFhirConceptMapGroupElementList;
begin
  if FElementList = nil then
    FElementList := TFhirConceptMapGroupElementList.Create;
  result := FElementList;
end;

Function TFhirConceptMapGroup.GetHasElementList : boolean;
begin
  result := (FElementList <> nil) and (FElementList.count > 0);
end;

Procedure TFhirConceptMapGroup.SetUnmapped(value : TFhirConceptMapGroupUnmapped);
begin
  FUnmapped.free;
  FUnmapped := value;
end;

function TFhirConceptMapGroup.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSource.sizeInBytes);
  inc(result, FSourceVersion.sizeInBytes);
  inc(result, FTarget.sizeInBytes);
  inc(result, FTargetVersion.sizeInBytes);
  inc(result, FelementList.sizeInBytes);
  inc(result, FUnmapped.sizeInBytes);
end;

{ TFhirConceptMapGroupListEnumerator }

Constructor TFhirConceptMapGroupListEnumerator.Create(list : TFhirConceptMapGroupList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConceptMapGroupListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConceptMapGroupListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConceptMapGroupListEnumerator.GetCurrent : TFhirConceptMapGroup;
begin
  Result := FList[FIndex];
end;

function TFhirConceptMapGroupListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConceptMapGroupList }
procedure TFhirConceptMapGroupList.AddItem(value: TFhirConceptMapGroup);
begin
  assert(value.ClassName = 'TFhirConceptMapGroup', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConceptMapGroup');
  add(value);
end;

function TFhirConceptMapGroupList.Append: TFhirConceptMapGroup;
begin
  result := TFhirConceptMapGroup.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConceptMapGroupList.ClearItems;
begin
  Clear;
end;

function TFhirConceptMapGroupList.GetEnumerator : TFhirConceptMapGroupListEnumerator;
begin
  result := TFhirConceptMapGroupListEnumerator.Create(self.link);
end;

function TFhirConceptMapGroupList.Clone: TFhirConceptMapGroupList;
begin
  result := TFhirConceptMapGroupList(inherited Clone);
end;

function TFhirConceptMapGroupList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConceptMapGroupList.GetItemN(index: Integer): TFhirConceptMapGroup;
begin
  result := TFhirConceptMapGroup(ObjectByIndex[index]);
end;

function TFhirConceptMapGroupList.ItemClass: TFslObjectClass;
begin
  result := TFhirConceptMapGroup;
end;
function TFhirConceptMapGroupList.IndexOf(value: TFhirConceptMapGroup): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConceptMapGroupList.Insert(index: Integer): TFhirConceptMapGroup;
begin
  result := TFhirConceptMapGroup.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConceptMapGroupList.InsertItem(index: Integer; value: TFhirConceptMapGroup);
begin
  assert(value is TFhirConceptMapGroup);
  Inherited Insert(index, value);
end;

function TFhirConceptMapGroupList.Item(index: Integer): TFhirConceptMapGroup;
begin
  result := TFhirConceptMapGroup(ObjectByIndex[index]);
end;

function TFhirConceptMapGroupList.Link: TFhirConceptMapGroupList;
begin
  result := TFhirConceptMapGroupList(inherited Link);
end;

procedure TFhirConceptMapGroupList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConceptMapGroupList.SetItemByIndex(index: Integer; value: TFhirConceptMapGroup);
begin
  assert(value is TFhirConceptMapGroup);
  FhirConceptMapGroups[index] := value;
end;

procedure TFhirConceptMapGroupList.SetItemN(index: Integer; value: TFhirConceptMapGroup);
begin
  assert(value is TFhirConceptMapGroup);
  ObjectByIndex[index] := value;
end;

{ TFhirConceptMapGroupElement }

constructor TFhirConceptMapGroupElement.Create;
begin
  inherited;
end;

destructor TFhirConceptMapGroupElement.Destroy;
begin
  FCode.free;
  FDisplay.free;
  FTargetList.Free;
  inherited;
end;

procedure TFhirConceptMapGroupElement.Assign(oSource : TFslObject);
begin
  inherited;
  codeElement := TFhirConceptMapGroupElement(oSource).codeElement.Clone;
  displayElement := TFhirConceptMapGroupElement(oSource).displayElement.Clone;
  if (TFhirConceptMapGroupElement(oSource).FTargetList = nil) then
  begin
    FTargetList.free;
    FTargetList := nil;
  end
  else
  begin
    if FTargetList = nil then
      FTargetList := TFhirConceptMapGroupElementTargetList.Create;
    FTargetList.Assign(TFhirConceptMapGroupElement(oSource).FTargetList);
  end;
end;

procedure TFhirConceptMapGroupElement.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'display') Then
     list.add(self.link, 'display', FDisplay.Link);
  if (child_name = 'target') Then
    list.addAll(self, 'target', FTargetList);
end;

procedure TFhirConceptMapGroupElement.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirCode, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'display', 'string', false, TFhirString, FDisplay.Link));{2}
  oList.add(TFHIRProperty.create(self, 'target', '', true, TFhirConceptMapGroupElementTarget, FTargetList.Link)){3};
end;

function TFhirConceptMapGroupElement.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'display') then
  begin
    DisplayElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'target') then
  begin
    TargetList.add(propValue as TFhirConceptMapGroupElementTarget){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConceptMapGroupElement.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'target') then TargetList.insertItem(index, propValue as TFhirConceptMapGroupElementTarget){2a}
  else inherited;
end;

function TFhirConceptMapGroupElement.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCode.create() {5b}
  else if (propName = 'display') then result := TFhirString.create() {5b}
  else if (propName = 'target') then result := TargetList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConceptMapGroupElement.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'code'
  else if (propName = 'display') then result := 'string'
  else if (propName = 'target') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConceptMapGroupElement.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'display') then DisplayElement := nil
  else if (propName = 'target') then deletePropertyValue('target', TargetList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConceptMapGroupElement.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asCode(new){5b}
  else if (propName = 'display') then DisplayElement := asString(new){5b}
  else if (propName = 'target') then replacePropertyValue('target', TargetList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConceptMapGroupElement.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'target') then TargetList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirConceptMapGroupElement.fhirType : string;
begin
  result := 'element';
end;

function TFhirConceptMapGroupElement.Link : TFhirConceptMapGroupElement;
begin
  result := TFhirConceptMapGroupElement(inherited Link);
end;

function TFhirConceptMapGroupElement.Clone : TFhirConceptMapGroupElement;
begin
  result := TFhirConceptMapGroupElement(inherited Clone);
end;

function TFhirConceptMapGroupElement.equals(other : TObject) : boolean;
var
  o : TFhirConceptMapGroupElement;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConceptMapGroupElement)) then
    result := false
  else
  begin
    o := TFhirConceptMapGroupElement(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(displayElement, o.displayElement, true) and
      compareDeep(targetList, o.targetList, true);
  end;
end;

function TFhirConceptMapGroupElement.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FDisplay) and isEmptyProp(FtargetList);
end;

procedure TFhirConceptMapGroupElement.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('display');
  fields.add('target');
end;

{ TFhirConceptMapGroupElement }

Procedure TFhirConceptMapGroupElement.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirConceptMapGroupElement.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

Procedure TFhirConceptMapGroupElement.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

Procedure TFhirConceptMapGroupElement.SetDisplay(value : TFhirString);
begin
  FDisplay.free;
  FDisplay := value;
end;

Function TFhirConceptMapGroupElement.GetDisplayST : String;
begin
  if FDisplay = nil then
    result := ''
  else
    result := FDisplay.value;
end;

Procedure TFhirConceptMapGroupElement.SetDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FDisplay = nil then
      FDisplay := TFhirString.create;
    FDisplay.value := value
  end
  else if FDisplay <> nil then
    FDisplay.value := '';
end;

Function TFhirConceptMapGroupElement.GetTargetList : TFhirConceptMapGroupElementTargetList;
begin
  if FTargetList = nil then
    FTargetList := TFhirConceptMapGroupElementTargetList.Create;
  result := FTargetList;
end;

Function TFhirConceptMapGroupElement.GetHasTargetList : boolean;
begin
  result := (FTargetList <> nil) and (FTargetList.count > 0);
end;

function TFhirConceptMapGroupElement.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FDisplay.sizeInBytes);
  inc(result, FtargetList.sizeInBytes);
end;

{ TFhirConceptMapGroupElementListEnumerator }

Constructor TFhirConceptMapGroupElementListEnumerator.Create(list : TFhirConceptMapGroupElementList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConceptMapGroupElementListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConceptMapGroupElementListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConceptMapGroupElementListEnumerator.GetCurrent : TFhirConceptMapGroupElement;
begin
  Result := FList[FIndex];
end;

function TFhirConceptMapGroupElementListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConceptMapGroupElementList }
procedure TFhirConceptMapGroupElementList.AddItem(value: TFhirConceptMapGroupElement);
begin
  assert(value.ClassName = 'TFhirConceptMapGroupElement', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConceptMapGroupElement');
  add(value);
end;

function TFhirConceptMapGroupElementList.Append: TFhirConceptMapGroupElement;
begin
  result := TFhirConceptMapGroupElement.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConceptMapGroupElementList.ClearItems;
begin
  Clear;
end;

function TFhirConceptMapGroupElementList.GetEnumerator : TFhirConceptMapGroupElementListEnumerator;
begin
  result := TFhirConceptMapGroupElementListEnumerator.Create(self.link);
end;

function TFhirConceptMapGroupElementList.Clone: TFhirConceptMapGroupElementList;
begin
  result := TFhirConceptMapGroupElementList(inherited Clone);
end;

function TFhirConceptMapGroupElementList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConceptMapGroupElementList.GetItemN(index: Integer): TFhirConceptMapGroupElement;
begin
  result := TFhirConceptMapGroupElement(ObjectByIndex[index]);
end;

function TFhirConceptMapGroupElementList.ItemClass: TFslObjectClass;
begin
  result := TFhirConceptMapGroupElement;
end;
function TFhirConceptMapGroupElementList.IndexOf(value: TFhirConceptMapGroupElement): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConceptMapGroupElementList.Insert(index: Integer): TFhirConceptMapGroupElement;
begin
  result := TFhirConceptMapGroupElement.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConceptMapGroupElementList.InsertItem(index: Integer; value: TFhirConceptMapGroupElement);
begin
  assert(value is TFhirConceptMapGroupElement);
  Inherited Insert(index, value);
end;

function TFhirConceptMapGroupElementList.Item(index: Integer): TFhirConceptMapGroupElement;
begin
  result := TFhirConceptMapGroupElement(ObjectByIndex[index]);
end;

function TFhirConceptMapGroupElementList.Link: TFhirConceptMapGroupElementList;
begin
  result := TFhirConceptMapGroupElementList(inherited Link);
end;

procedure TFhirConceptMapGroupElementList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConceptMapGroupElementList.SetItemByIndex(index: Integer; value: TFhirConceptMapGroupElement);
begin
  assert(value is TFhirConceptMapGroupElement);
  FhirConceptMapGroupElements[index] := value;
end;

procedure TFhirConceptMapGroupElementList.SetItemN(index: Integer; value: TFhirConceptMapGroupElement);
begin
  assert(value is TFhirConceptMapGroupElement);
  ObjectByIndex[index] := value;
end;

{ TFhirConceptMapGroupElementTarget }

constructor TFhirConceptMapGroupElementTarget.Create;
begin
  inherited;
end;

destructor TFhirConceptMapGroupElementTarget.Destroy;
begin
  FCode.free;
  FDisplay.free;
  FEquivalence.free;
  FComment.free;
  FDependsOnList.Free;
  FProductList.Free;
  inherited;
end;

procedure TFhirConceptMapGroupElementTarget.Assign(oSource : TFslObject);
begin
  inherited;
  codeElement := TFhirConceptMapGroupElementTarget(oSource).codeElement.Clone;
  displayElement := TFhirConceptMapGroupElementTarget(oSource).displayElement.Clone;
  FEquivalence := TFhirConceptMapGroupElementTarget(oSource).FEquivalence.Link;
  commentElement := TFhirConceptMapGroupElementTarget(oSource).commentElement.Clone;
  if (TFhirConceptMapGroupElementTarget(oSource).FDependsOnList = nil) then
  begin
    FDependsOnList.free;
    FDependsOnList := nil;
  end
  else
  begin
    if FDependsOnList = nil then
      FDependsOnList := TFhirConceptMapGroupElementTargetDependsOnList.Create;
    FDependsOnList.Assign(TFhirConceptMapGroupElementTarget(oSource).FDependsOnList);
  end;
  if (TFhirConceptMapGroupElementTarget(oSource).FProductList = nil) then
  begin
    FProductList.free;
    FProductList := nil;
  end
  else
  begin
    if FProductList = nil then
      FProductList := TFhirConceptMapGroupElementTargetDependsOnList.Create;
    FProductList.Assign(TFhirConceptMapGroupElementTarget(oSource).FProductList);
  end;
end;

procedure TFhirConceptMapGroupElementTarget.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'display') Then
     list.add(self.link, 'display', FDisplay.Link);
  if (child_name = 'equivalence') Then
     list.add(self.link, 'equivalence', FEquivalence.Link);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
  if (child_name = 'dependsOn') Then
    list.addAll(self, 'dependsOn', FDependsOnList);
  if (child_name = 'product') Then
    list.addAll(self, 'product', FProductList);
end;

procedure TFhirConceptMapGroupElementTarget.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirCode, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'display', 'string', false, TFhirString, FDisplay.Link));{2}
  oList.add(TFHIRProperty.create(self, 'equivalence', 'code', false, TFHIREnum, FEquivalence.Link));{1}
  oList.add(TFHIRProperty.create(self, 'comment', 'string', false, TFhirString, FComment.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dependsOn', '', true, TFhirConceptMapGroupElementTargetDependsOn, FDependsOnList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'product', '@ConceptMap.group.element.target.dependsOn', true, TFhirConceptMapGroupElementTargetDependsOn, FProductList.Link)){3};
end;

function TFhirConceptMapGroupElementTarget.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'display') then
  begin
    DisplayElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'equivalence') then
  begin
    EquivalenceElement := asEnum(SYSTEMS_TFhirConceptMapEquivalenceEnum, CODES_TFhirConceptMapEquivalenceEnum, propValue);
    result := propValue
  end
  else if (propName = 'comment') then
  begin
    CommentElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'dependsOn') then
  begin
    DependsOnList.add(propValue as TFhirConceptMapGroupElementTargetDependsOn){2a};
    result := propValue;
  end
  else if (propName = 'product') then
  begin
    ProductList.add(propValue as TFhirConceptMapGroupElementTargetDependsOn){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConceptMapGroupElementTarget.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'dependsOn') then DependsOnList.insertItem(index, propValue as TFhirConceptMapGroupElementTargetDependsOn){2a}
  else if (propName = 'product') then ProductList.insertItem(index, propValue as TFhirConceptMapGroupElementTargetDependsOn){2a}
  else inherited;
end;

function TFhirConceptMapGroupElementTarget.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCode.create() {5b}
  else if (propName = 'display') then result := TFhirString.create() {5b}
  else if (propName = 'comment') then result := TFhirString.create() {5b}
  else if (propName = 'dependsOn') then result := DependsOnList.new(){2}
  else if (propName = 'product') then result := ProductList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConceptMapGroupElementTarget.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'code'
  else if (propName = 'display') then result := 'string'
  else if (propName = 'equivalence') then result := 'code'
  else if (propName = 'comment') then result := 'string'
  else if (propName = 'dependsOn') then result := ''
  else if (propName = 'product') then result := '@ConceptMap.group.element.target.dependsOn'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConceptMapGroupElementTarget.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'display') then DisplayElement := nil
  else if (propName = 'equivalence') then EquivalenceElement := nil
  else if (propName = 'comment') then CommentElement := nil
  else if (propName = 'dependsOn') then deletePropertyValue('dependsOn', DependsOnList, value) {2}
  else if (propName = 'product') then deletePropertyValue('product', ProductList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConceptMapGroupElementTarget.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asCode(new){5b}
  else if (propName = 'display') then DisplayElement := asString(new){5b}
  else if (propName = 'equivalence') then EquivalenceElement := asEnum(SYSTEMS_TFhirConceptMapEquivalenceEnum, CODES_TFhirConceptMapEquivalenceEnum, new){4}
  else if (propName = 'comment') then CommentElement := asString(new){5b}
  else if (propName = 'dependsOn') then replacePropertyValue('dependsOn', DependsOnList, existing, new) {2}
  else if (propName = 'product') then replacePropertyValue('product', ProductList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConceptMapGroupElementTarget.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'dependsOn') then DependsOnList.move(source, destination){2a}
  else if (propName = 'product') then ProductList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirConceptMapGroupElementTarget.fhirType : string;
begin
  result := 'target';
end;

function TFhirConceptMapGroupElementTarget.Link : TFhirConceptMapGroupElementTarget;
begin
  result := TFhirConceptMapGroupElementTarget(inherited Link);
end;

function TFhirConceptMapGroupElementTarget.Clone : TFhirConceptMapGroupElementTarget;
begin
  result := TFhirConceptMapGroupElementTarget(inherited Clone);
end;

function TFhirConceptMapGroupElementTarget.equals(other : TObject) : boolean;
var
  o : TFhirConceptMapGroupElementTarget;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConceptMapGroupElementTarget)) then
    result := false
  else
  begin
    o := TFhirConceptMapGroupElementTarget(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(displayElement, o.displayElement, true) and
      compareDeep(equivalenceElement, o.equivalenceElement, true) and compareDeep(commentElement, o.commentElement, true) and
      compareDeep(dependsOnList, o.dependsOnList, true) and compareDeep(productList, o.productList, true);
  end;
end;

function TFhirConceptMapGroupElementTarget.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FDisplay) and isEmptyProp(FEquivalence) and isEmptyProp(FComment) and isEmptyProp(FdependsOnList) and isEmptyProp(FproductList);
end;

procedure TFhirConceptMapGroupElementTarget.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('display');
  fields.add('equivalence');
  fields.add('comment');
  fields.add('dependsOn');
  fields.add('product');
end;

{ TFhirConceptMapGroupElementTarget }

Procedure TFhirConceptMapGroupElementTarget.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirConceptMapGroupElementTarget.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

Procedure TFhirConceptMapGroupElementTarget.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

Procedure TFhirConceptMapGroupElementTarget.SetDisplay(value : TFhirString);
begin
  FDisplay.free;
  FDisplay := value;
end;

Function TFhirConceptMapGroupElementTarget.GetDisplayST : String;
begin
  if FDisplay = nil then
    result := ''
  else
    result := FDisplay.value;
end;

Procedure TFhirConceptMapGroupElementTarget.SetDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FDisplay = nil then
      FDisplay := TFhirString.create;
    FDisplay.value := value
  end
  else if FDisplay <> nil then
    FDisplay.value := '';
end;

Procedure TFhirConceptMapGroupElementTarget.SetEquivalence(value : TFhirEnum);
begin
  FEquivalence.free;
  FEquivalence := value;
end;

Function TFhirConceptMapGroupElementTarget.GetEquivalenceST : TFhirConceptMapEquivalenceEnum;
begin
  if FEquivalence = nil then
    result := TFhirConceptMapEquivalenceEnum(0)
  else
    result := TFhirConceptMapEquivalenceEnum(StringArrayIndexOfSensitive(CODES_TFhirConceptMapEquivalenceEnum, FEquivalence.value));
end;

Procedure TFhirConceptMapGroupElementTarget.SetEquivalenceST(value : TFhirConceptMapEquivalenceEnum);
begin
  if ord(value) = 0 then
    EquivalenceElement := nil
  else
    EquivalenceElement := TFhirEnum.create(SYSTEMS_TFhirConceptMapEquivalenceEnum[value], CODES_TFhirConceptMapEquivalenceEnum[value]);
end;

Procedure TFhirConceptMapGroupElementTarget.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value;
end;

Function TFhirConceptMapGroupElementTarget.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

Procedure TFhirConceptMapGroupElementTarget.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

Function TFhirConceptMapGroupElementTarget.GetDependsOnList : TFhirConceptMapGroupElementTargetDependsOnList;
begin
  if FDependsOnList = nil then
    FDependsOnList := TFhirConceptMapGroupElementTargetDependsOnList.Create;
  result := FDependsOnList;
end;

Function TFhirConceptMapGroupElementTarget.GetHasDependsOnList : boolean;
begin
  result := (FDependsOnList <> nil) and (FDependsOnList.count > 0);
end;

Function TFhirConceptMapGroupElementTarget.GetProductList : TFhirConceptMapGroupElementTargetDependsOnList;
begin
  if FProductList = nil then
    FProductList := TFhirConceptMapGroupElementTargetDependsOnList.Create;
  result := FProductList;
end;

Function TFhirConceptMapGroupElementTarget.GetHasProductList : boolean;
begin
  result := (FProductList <> nil) and (FProductList.count > 0);
end;

function TFhirConceptMapGroupElementTarget.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FDisplay.sizeInBytes);
  inc(result, FEquivalence.sizeInBytes);
  inc(result, FComment.sizeInBytes);
  inc(result, FdependsOnList.sizeInBytes);
  inc(result, FproductList.sizeInBytes);
end;

{ TFhirConceptMapGroupElementTargetListEnumerator }

Constructor TFhirConceptMapGroupElementTargetListEnumerator.Create(list : TFhirConceptMapGroupElementTargetList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConceptMapGroupElementTargetListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConceptMapGroupElementTargetListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConceptMapGroupElementTargetListEnumerator.GetCurrent : TFhirConceptMapGroupElementTarget;
begin
  Result := FList[FIndex];
end;

function TFhirConceptMapGroupElementTargetListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConceptMapGroupElementTargetList }
procedure TFhirConceptMapGroupElementTargetList.AddItem(value: TFhirConceptMapGroupElementTarget);
begin
  assert(value.ClassName = 'TFhirConceptMapGroupElementTarget', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConceptMapGroupElementTarget');
  add(value);
end;

function TFhirConceptMapGroupElementTargetList.Append: TFhirConceptMapGroupElementTarget;
begin
  result := TFhirConceptMapGroupElementTarget.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConceptMapGroupElementTargetList.ClearItems;
begin
  Clear;
end;

function TFhirConceptMapGroupElementTargetList.GetEnumerator : TFhirConceptMapGroupElementTargetListEnumerator;
begin
  result := TFhirConceptMapGroupElementTargetListEnumerator.Create(self.link);
end;

function TFhirConceptMapGroupElementTargetList.Clone: TFhirConceptMapGroupElementTargetList;
begin
  result := TFhirConceptMapGroupElementTargetList(inherited Clone);
end;

function TFhirConceptMapGroupElementTargetList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConceptMapGroupElementTargetList.GetItemN(index: Integer): TFhirConceptMapGroupElementTarget;
begin
  result := TFhirConceptMapGroupElementTarget(ObjectByIndex[index]);
end;

function TFhirConceptMapGroupElementTargetList.ItemClass: TFslObjectClass;
begin
  result := TFhirConceptMapGroupElementTarget;
end;
function TFhirConceptMapGroupElementTargetList.IndexOf(value: TFhirConceptMapGroupElementTarget): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConceptMapGroupElementTargetList.Insert(index: Integer): TFhirConceptMapGroupElementTarget;
begin
  result := TFhirConceptMapGroupElementTarget.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConceptMapGroupElementTargetList.InsertItem(index: Integer; value: TFhirConceptMapGroupElementTarget);
begin
  assert(value is TFhirConceptMapGroupElementTarget);
  Inherited Insert(index, value);
end;

function TFhirConceptMapGroupElementTargetList.Item(index: Integer): TFhirConceptMapGroupElementTarget;
begin
  result := TFhirConceptMapGroupElementTarget(ObjectByIndex[index]);
end;

function TFhirConceptMapGroupElementTargetList.Link: TFhirConceptMapGroupElementTargetList;
begin
  result := TFhirConceptMapGroupElementTargetList(inherited Link);
end;

procedure TFhirConceptMapGroupElementTargetList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConceptMapGroupElementTargetList.SetItemByIndex(index: Integer; value: TFhirConceptMapGroupElementTarget);
begin
  assert(value is TFhirConceptMapGroupElementTarget);
  FhirConceptMapGroupElementTargets[index] := value;
end;

procedure TFhirConceptMapGroupElementTargetList.SetItemN(index: Integer; value: TFhirConceptMapGroupElementTarget);
begin
  assert(value is TFhirConceptMapGroupElementTarget);
  ObjectByIndex[index] := value;
end;

{ TFhirConceptMapGroupElementTargetDependsOn }

constructor TFhirConceptMapGroupElementTargetDependsOn.Create;
begin
  inherited;
end;

destructor TFhirConceptMapGroupElementTargetDependsOn.Destroy;
begin
  FProperty_.free;
  FSystem.free;
  FCode.free;
  FDisplay.free;
  inherited;
end;

procedure TFhirConceptMapGroupElementTargetDependsOn.Assign(oSource : TFslObject);
begin
  inherited;
  property_Element := TFhirConceptMapGroupElementTargetDependsOn(oSource).property_Element.Clone;
  systemElement := TFhirConceptMapGroupElementTargetDependsOn(oSource).systemElement.Clone;
  codeElement := TFhirConceptMapGroupElementTargetDependsOn(oSource).codeElement.Clone;
  displayElement := TFhirConceptMapGroupElementTargetDependsOn(oSource).displayElement.Clone;
end;

procedure TFhirConceptMapGroupElementTargetDependsOn.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'property') Then
     list.add(self.link, 'property', FProperty_.Link);
  if (child_name = 'system') Then
     list.add(self.link, 'system', FSystem.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'display') Then
     list.add(self.link, 'display', FDisplay.Link);
end;

procedure TFhirConceptMapGroupElementTargetDependsOn.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'property', 'uri', false, TFhirUri, FProperty_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'system', 'uri', false, TFhirUri, FSystem.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'string', false, TFhirString, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'display', 'string', false, TFhirString, FDisplay.Link));{2}
end;

function TFhirConceptMapGroupElementTargetDependsOn.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'property') then
  begin
    Property_Element := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'system') then
  begin
    SystemElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'display') then
  begin
    DisplayElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConceptMapGroupElementTargetDependsOn.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirConceptMapGroupElementTargetDependsOn.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'property') then result := TFhirUri.create() {5b}
  else if (propName = 'system') then result := TFhirUri.create() {5b}
  else if (propName = 'code') then result := TFhirString.create() {5b}
  else if (propName = 'display') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConceptMapGroupElementTargetDependsOn.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'property') then result := 'uri'
  else if (propName = 'system') then result := 'uri'
  else if (propName = 'code') then result := 'string'
  else if (propName = 'display') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConceptMapGroupElementTargetDependsOn.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'property') then Property_Element := nil
  else if (propName = 'system') then SystemElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'display') then DisplayElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConceptMapGroupElementTargetDependsOn.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'property') then Property_Element := asUri(new){5b}
  else if (propName = 'system') then SystemElement := asUri(new){5b}
  else if (propName = 'code') then CodeElement := asString(new){5b}
  else if (propName = 'display') then DisplayElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConceptMapGroupElementTargetDependsOn.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirConceptMapGroupElementTargetDependsOn.fhirType : string;
begin
  result := 'dependsOn';
end;

function TFhirConceptMapGroupElementTargetDependsOn.Link : TFhirConceptMapGroupElementTargetDependsOn;
begin
  result := TFhirConceptMapGroupElementTargetDependsOn(inherited Link);
end;

function TFhirConceptMapGroupElementTargetDependsOn.Clone : TFhirConceptMapGroupElementTargetDependsOn;
begin
  result := TFhirConceptMapGroupElementTargetDependsOn(inherited Clone);
end;

function TFhirConceptMapGroupElementTargetDependsOn.equals(other : TObject) : boolean;
var
  o : TFhirConceptMapGroupElementTargetDependsOn;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConceptMapGroupElementTargetDependsOn)) then
    result := false
  else
  begin
    o := TFhirConceptMapGroupElementTargetDependsOn(other);
    result := compareDeep(property_Element, o.property_Element, true) and compareDeep(systemElement, o.systemElement, true) and
      compareDeep(codeElement, o.codeElement, true) and compareDeep(displayElement, o.displayElement, true);
  end;
end;

function TFhirConceptMapGroupElementTargetDependsOn.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FProperty_) and isEmptyProp(FSystem) and isEmptyProp(FCode) and isEmptyProp(FDisplay);
end;

procedure TFhirConceptMapGroupElementTargetDependsOn.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('property');
  fields.add('system');
  fields.add('code');
  fields.add('display');
end;

{ TFhirConceptMapGroupElementTargetDependsOn }

Procedure TFhirConceptMapGroupElementTargetDependsOn.SetProperty_(value : TFhirUri);
begin
  FProperty_.free;
  FProperty_ := value;
end;

Function TFhirConceptMapGroupElementTargetDependsOn.GetProperty_ST : String;
begin
  if FProperty_ = nil then
    result := ''
  else
    result := FProperty_.value;
end;

Procedure TFhirConceptMapGroupElementTargetDependsOn.SetProperty_ST(value : String);
begin
  if value <> '' then
  begin
    if FProperty_ = nil then
      FProperty_ := TFhirUri.create;
    FProperty_.value := value
  end
  else if FProperty_ <> nil then
    FProperty_.value := '';
end;

Procedure TFhirConceptMapGroupElementTargetDependsOn.SetSystem(value : TFhirUri);
begin
  FSystem.free;
  FSystem := value;
end;

Function TFhirConceptMapGroupElementTargetDependsOn.GetSystemST : String;
begin
  if FSystem = nil then
    result := ''
  else
    result := FSystem.value;
end;

Procedure TFhirConceptMapGroupElementTargetDependsOn.SetSystemST(value : String);
begin
  if value <> '' then
  begin
    if FSystem = nil then
      FSystem := TFhirUri.create;
    FSystem.value := value
  end
  else if FSystem <> nil then
    FSystem.value := '';
end;

Procedure TFhirConceptMapGroupElementTargetDependsOn.SetCode(value : TFhirString);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirConceptMapGroupElementTargetDependsOn.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

Procedure TFhirConceptMapGroupElementTargetDependsOn.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirString.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

Procedure TFhirConceptMapGroupElementTargetDependsOn.SetDisplay(value : TFhirString);
begin
  FDisplay.free;
  FDisplay := value;
end;

Function TFhirConceptMapGroupElementTargetDependsOn.GetDisplayST : String;
begin
  if FDisplay = nil then
    result := ''
  else
    result := FDisplay.value;
end;

Procedure TFhirConceptMapGroupElementTargetDependsOn.SetDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FDisplay = nil then
      FDisplay := TFhirString.create;
    FDisplay.value := value
  end
  else if FDisplay <> nil then
    FDisplay.value := '';
end;

function TFhirConceptMapGroupElementTargetDependsOn.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FProperty_.sizeInBytes);
  inc(result, FSystem.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FDisplay.sizeInBytes);
end;

{ TFhirConceptMapGroupElementTargetDependsOnListEnumerator }

Constructor TFhirConceptMapGroupElementTargetDependsOnListEnumerator.Create(list : TFhirConceptMapGroupElementTargetDependsOnList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConceptMapGroupElementTargetDependsOnListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConceptMapGroupElementTargetDependsOnListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConceptMapGroupElementTargetDependsOnListEnumerator.GetCurrent : TFhirConceptMapGroupElementTargetDependsOn;
begin
  Result := FList[FIndex];
end;

function TFhirConceptMapGroupElementTargetDependsOnListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConceptMapGroupElementTargetDependsOnList }
procedure TFhirConceptMapGroupElementTargetDependsOnList.AddItem(value: TFhirConceptMapGroupElementTargetDependsOn);
begin
  assert(value.ClassName = 'TFhirConceptMapGroupElementTargetDependsOn', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConceptMapGroupElementTargetDependsOn');
  add(value);
end;

function TFhirConceptMapGroupElementTargetDependsOnList.Append: TFhirConceptMapGroupElementTargetDependsOn;
begin
  result := TFhirConceptMapGroupElementTargetDependsOn.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConceptMapGroupElementTargetDependsOnList.ClearItems;
begin
  Clear;
end;

function TFhirConceptMapGroupElementTargetDependsOnList.GetEnumerator : TFhirConceptMapGroupElementTargetDependsOnListEnumerator;
begin
  result := TFhirConceptMapGroupElementTargetDependsOnListEnumerator.Create(self.link);
end;

function TFhirConceptMapGroupElementTargetDependsOnList.Clone: TFhirConceptMapGroupElementTargetDependsOnList;
begin
  result := TFhirConceptMapGroupElementTargetDependsOnList(inherited Clone);
end;

function TFhirConceptMapGroupElementTargetDependsOnList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConceptMapGroupElementTargetDependsOnList.GetItemN(index: Integer): TFhirConceptMapGroupElementTargetDependsOn;
begin
  result := TFhirConceptMapGroupElementTargetDependsOn(ObjectByIndex[index]);
end;

function TFhirConceptMapGroupElementTargetDependsOnList.ItemClass: TFslObjectClass;
begin
  result := TFhirConceptMapGroupElementTargetDependsOn;
end;
function TFhirConceptMapGroupElementTargetDependsOnList.IndexOf(value: TFhirConceptMapGroupElementTargetDependsOn): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConceptMapGroupElementTargetDependsOnList.Insert(index: Integer): TFhirConceptMapGroupElementTargetDependsOn;
begin
  result := TFhirConceptMapGroupElementTargetDependsOn.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConceptMapGroupElementTargetDependsOnList.InsertItem(index: Integer; value: TFhirConceptMapGroupElementTargetDependsOn);
begin
  assert(value is TFhirConceptMapGroupElementTargetDependsOn);
  Inherited Insert(index, value);
end;

function TFhirConceptMapGroupElementTargetDependsOnList.Item(index: Integer): TFhirConceptMapGroupElementTargetDependsOn;
begin
  result := TFhirConceptMapGroupElementTargetDependsOn(ObjectByIndex[index]);
end;

function TFhirConceptMapGroupElementTargetDependsOnList.Link: TFhirConceptMapGroupElementTargetDependsOnList;
begin
  result := TFhirConceptMapGroupElementTargetDependsOnList(inherited Link);
end;

procedure TFhirConceptMapGroupElementTargetDependsOnList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConceptMapGroupElementTargetDependsOnList.SetItemByIndex(index: Integer; value: TFhirConceptMapGroupElementTargetDependsOn);
begin
  assert(value is TFhirConceptMapGroupElementTargetDependsOn);
  FhirConceptMapGroupElementTargetDependsOns[index] := value;
end;

procedure TFhirConceptMapGroupElementTargetDependsOnList.SetItemN(index: Integer; value: TFhirConceptMapGroupElementTargetDependsOn);
begin
  assert(value is TFhirConceptMapGroupElementTargetDependsOn);
  ObjectByIndex[index] := value;
end;

{ TFhirConceptMapGroupUnmapped }

constructor TFhirConceptMapGroupUnmapped.Create;
begin
  inherited;
end;

destructor TFhirConceptMapGroupUnmapped.Destroy;
begin
  FMode.free;
  FCode.free;
  FDisplay.free;
  FUrl.free;
  inherited;
end;

procedure TFhirConceptMapGroupUnmapped.Assign(oSource : TFslObject);
begin
  inherited;
  FMode := TFhirConceptMapGroupUnmapped(oSource).FMode.Link;
  codeElement := TFhirConceptMapGroupUnmapped(oSource).codeElement.Clone;
  displayElement := TFhirConceptMapGroupUnmapped(oSource).displayElement.Clone;
  urlElement := TFhirConceptMapGroupUnmapped(oSource).urlElement.Clone;
end;

procedure TFhirConceptMapGroupUnmapped.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'mode') Then
     list.add(self.link, 'mode', FMode.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'display') Then
     list.add(self.link, 'display', FDisplay.Link);
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
end;

procedure TFhirConceptMapGroupUnmapped.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'mode', 'code', false, TFHIREnum, FMode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirCode, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'display', 'string', false, TFhirString, FDisplay.Link));{2}
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));{2}
end;

function TFhirConceptMapGroupUnmapped.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'mode') then
  begin
    ModeElement := asEnum(SYSTEMS_TFhirConceptmapUnmappedModeEnum, CODES_TFhirConceptmapUnmappedModeEnum, propValue);
    result := propValue
  end
  else if (propName = 'code') then
  begin
    CodeElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'display') then
  begin
    DisplayElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'url') then
  begin
    UrlElement := asUri(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConceptMapGroupUnmapped.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirConceptMapGroupUnmapped.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCode.create() {5b}
  else if (propName = 'display') then result := TFhirString.create() {5b}
  else if (propName = 'url') then result := TFhirUri.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConceptMapGroupUnmapped.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'mode') then result := 'code'
  else if (propName = 'code') then result := 'code'
  else if (propName = 'display') then result := 'string'
  else if (propName = 'url') then result := 'uri'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConceptMapGroupUnmapped.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'mode') then ModeElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'display') then DisplayElement := nil
  else if (propName = 'url') then UrlElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConceptMapGroupUnmapped.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'mode') then ModeElement := asEnum(SYSTEMS_TFhirConceptmapUnmappedModeEnum, CODES_TFhirConceptmapUnmappedModeEnum, new){4}
  else if (propName = 'code') then CodeElement := asCode(new){5b}
  else if (propName = 'display') then DisplayElement := asString(new){5b}
  else if (propName = 'url') then UrlElement := asUri(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConceptMapGroupUnmapped.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirConceptMapGroupUnmapped.fhirType : string;
begin
  result := 'unmapped';
end;

function TFhirConceptMapGroupUnmapped.Link : TFhirConceptMapGroupUnmapped;
begin
  result := TFhirConceptMapGroupUnmapped(inherited Link);
end;

function TFhirConceptMapGroupUnmapped.Clone : TFhirConceptMapGroupUnmapped;
begin
  result := TFhirConceptMapGroupUnmapped(inherited Clone);
end;

function TFhirConceptMapGroupUnmapped.equals(other : TObject) : boolean;
var
  o : TFhirConceptMapGroupUnmapped;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConceptMapGroupUnmapped)) then
    result := false
  else
  begin
    o := TFhirConceptMapGroupUnmapped(other);
    result := compareDeep(modeElement, o.modeElement, true) and compareDeep(codeElement, o.codeElement, true) and
      compareDeep(displayElement, o.displayElement, true) and compareDeep(urlElement, o.urlElement, true);
  end;
end;

function TFhirConceptMapGroupUnmapped.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMode) and isEmptyProp(FCode) and isEmptyProp(FDisplay) and isEmptyProp(FUrl);
end;

procedure TFhirConceptMapGroupUnmapped.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('mode');
  fields.add('code');
  fields.add('display');
  fields.add('url');
end;

{ TFhirConceptMapGroupUnmapped }

Procedure TFhirConceptMapGroupUnmapped.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

Function TFhirConceptMapGroupUnmapped.GetModeST : TFhirConceptmapUnmappedModeEnum;
begin
  if FMode = nil then
    result := TFhirConceptmapUnmappedModeEnum(0)
  else
    result := TFhirConceptmapUnmappedModeEnum(StringArrayIndexOfSensitive(CODES_TFhirConceptmapUnmappedModeEnum, FMode.value));
end;

Procedure TFhirConceptMapGroupUnmapped.SetModeST(value : TFhirConceptmapUnmappedModeEnum);
begin
  if ord(value) = 0 then
    ModeElement := nil
  else
    ModeElement := TFhirEnum.create(SYSTEMS_TFhirConceptmapUnmappedModeEnum[value], CODES_TFhirConceptmapUnmappedModeEnum[value]);
end;

Procedure TFhirConceptMapGroupUnmapped.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirConceptMapGroupUnmapped.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

Procedure TFhirConceptMapGroupUnmapped.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

Procedure TFhirConceptMapGroupUnmapped.SetDisplay(value : TFhirString);
begin
  FDisplay.free;
  FDisplay := value;
end;

Function TFhirConceptMapGroupUnmapped.GetDisplayST : String;
begin
  if FDisplay = nil then
    result := ''
  else
    result := FDisplay.value;
end;

Procedure TFhirConceptMapGroupUnmapped.SetDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FDisplay = nil then
      FDisplay := TFhirString.create;
    FDisplay.value := value
  end
  else if FDisplay <> nil then
    FDisplay.value := '';
end;

Procedure TFhirConceptMapGroupUnmapped.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirConceptMapGroupUnmapped.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

Procedure TFhirConceptMapGroupUnmapped.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

function TFhirConceptMapGroupUnmapped.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FMode.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FDisplay.sizeInBytes);
  inc(result, FUrl.sizeInBytes);
end;

{ TFhirConceptMapGroupUnmappedListEnumerator }

Constructor TFhirConceptMapGroupUnmappedListEnumerator.Create(list : TFhirConceptMapGroupUnmappedList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConceptMapGroupUnmappedListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConceptMapGroupUnmappedListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConceptMapGroupUnmappedListEnumerator.GetCurrent : TFhirConceptMapGroupUnmapped;
begin
  Result := FList[FIndex];
end;

function TFhirConceptMapGroupUnmappedListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConceptMapGroupUnmappedList }
procedure TFhirConceptMapGroupUnmappedList.AddItem(value: TFhirConceptMapGroupUnmapped);
begin
  assert(value.ClassName = 'TFhirConceptMapGroupUnmapped', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConceptMapGroupUnmapped');
  add(value);
end;

function TFhirConceptMapGroupUnmappedList.Append: TFhirConceptMapGroupUnmapped;
begin
  result := TFhirConceptMapGroupUnmapped.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConceptMapGroupUnmappedList.ClearItems;
begin
  Clear;
end;

function TFhirConceptMapGroupUnmappedList.GetEnumerator : TFhirConceptMapGroupUnmappedListEnumerator;
begin
  result := TFhirConceptMapGroupUnmappedListEnumerator.Create(self.link);
end;

function TFhirConceptMapGroupUnmappedList.Clone: TFhirConceptMapGroupUnmappedList;
begin
  result := TFhirConceptMapGroupUnmappedList(inherited Clone);
end;

function TFhirConceptMapGroupUnmappedList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConceptMapGroupUnmappedList.GetItemN(index: Integer): TFhirConceptMapGroupUnmapped;
begin
  result := TFhirConceptMapGroupUnmapped(ObjectByIndex[index]);
end;

function TFhirConceptMapGroupUnmappedList.ItemClass: TFslObjectClass;
begin
  result := TFhirConceptMapGroupUnmapped;
end;
function TFhirConceptMapGroupUnmappedList.IndexOf(value: TFhirConceptMapGroupUnmapped): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConceptMapGroupUnmappedList.Insert(index: Integer): TFhirConceptMapGroupUnmapped;
begin
  result := TFhirConceptMapGroupUnmapped.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConceptMapGroupUnmappedList.InsertItem(index: Integer; value: TFhirConceptMapGroupUnmapped);
begin
  assert(value is TFhirConceptMapGroupUnmapped);
  Inherited Insert(index, value);
end;

function TFhirConceptMapGroupUnmappedList.Item(index: Integer): TFhirConceptMapGroupUnmapped;
begin
  result := TFhirConceptMapGroupUnmapped(ObjectByIndex[index]);
end;

function TFhirConceptMapGroupUnmappedList.Link: TFhirConceptMapGroupUnmappedList;
begin
  result := TFhirConceptMapGroupUnmappedList(inherited Link);
end;

procedure TFhirConceptMapGroupUnmappedList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConceptMapGroupUnmappedList.SetItemByIndex(index: Integer; value: TFhirConceptMapGroupUnmapped);
begin
  assert(value is TFhirConceptMapGroupUnmapped);
  FhirConceptMapGroupUnmappeds[index] := value;
end;

procedure TFhirConceptMapGroupUnmappedList.SetItemN(index: Integer; value: TFhirConceptMapGroupUnmapped);
begin
  assert(value is TFhirConceptMapGroupUnmapped);
  ObjectByIndex[index] := value;
end;

{ TFhirConceptMap }

constructor TFhirConceptMap.Create;
begin
  inherited;
end;

destructor TFhirConceptMap.Destroy;
begin
  FIdentifier.free;
  FPurpose.free;
  FCopyright.free;
  FSource.free;
  FTarget.free;
  FGroupList.Free;
  inherited;
end;

function TFhirConceptMap.GetResourceType : TFhirResourceType;
begin
  result := frtConceptMap;
end;

procedure TFhirConceptMap.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirConceptMap(oSource).identifier.Clone;
  purposeElement := TFhirConceptMap(oSource).purposeElement.Clone;
  copyrightElement := TFhirConceptMap(oSource).copyrightElement.Clone;
  source := TFhirConceptMap(oSource).source.Clone;
  target := TFhirConceptMap(oSource).target.Clone;
  if (TFhirConceptMap(oSource).FGroupList = nil) then
  begin
    FGroupList.free;
    FGroupList := nil;
  end
  else
  begin
    if FGroupList = nil then
      FGroupList := TFhirConceptMapGroupList.Create;
    FGroupList.Assign(TFhirConceptMap(oSource).FGroupList);
  end;
end;

procedure TFhirConceptMap.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'source[x]') or (child_name = 'source') Then
     list.add(self.link, 'source[x]', FSource.Link);
  if (child_name = 'target[x]') or (child_name = 'target') Then
     list.add(self.link, 'target[x]', FTarget.Link);
  if (child_name = 'group') Then
    list.addAll(self, 'group', FGroupList);
end;

procedure TFhirConceptMap.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));{2}
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));{2}
  oList.add(TFHIRProperty.create(self, 'source[x]', 'uri|Reference(ValueSet)', false, TFhirType, FSource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'target[x]', 'uri|Reference(ValueSet)', false, TFhirType, FTarget.Link));{2}
  oList.add(TFHIRProperty.create(self, 'group', '', true, TFhirConceptMapGroup, FGroupList.Link)){3};
end;

function TFhirConceptMap.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'source', ['Uri', 'Reference'])) then
  begin
    Source := propValue as TFhirType{4};
    result := propValue;
  end
  else if (isMatchingName(propName, 'target', ['Uri', 'Reference'])) then
  begin
    Target := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'group') then
  begin
    GroupList.add(propValue as TFhirConceptMapGroup){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirConceptMap.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'group') then GroupList.insertItem(index, propValue as TFhirConceptMapGroup){2a}
  else inherited;
end;

function TFhirConceptMap.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'purpose') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'copyright') then result := TFhirMarkdown.create() {5b}
  else if (isMatchingName(propName, 'source', ['Uri', 'Reference'])) then raise EFHIRException.create('Cannot make property Source'){4x}
  else if (isMatchingName(propName, 'target', ['Uri', 'Reference'])) then raise EFHIRException.create('Cannot make property Target'){4x}
  else if (propName = 'group') then result := GroupList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirConceptMap.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'source[x]') then result := 'uri|Reference'
  else if (propName = 'target[x]') then result := 'uri|Reference'
  else if (propName = 'group') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConceptMap.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (isMatchingName(propName, 'source', ['Uri', 'Reference'])) then SourceElement := nil{4x}
  else if (isMatchingName(propName, 'target', ['Uri', 'Reference'])) then TargetElement := nil{4x}
  else if (propName = 'group') then deletePropertyValue('group', GroupList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConceptMap.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'purpose') then PurposeElement := asMarkdown(new){5b}
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new){5b}
  else if (isMatchingName(propName, 'source', ['Uri', 'Reference'])) then SourceElement := new as TFhirType{4x}
  else if (isMatchingName(propName, 'target', ['Uri', 'Reference'])) then TargetElement := new as TFhirType{4x}
  else if (propName = 'group') then replacePropertyValue('group', GroupList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConceptMap.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'group') then GroupList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirConceptMap.fhirType : string;
begin
  result := 'ConceptMap';
end;

function TFhirConceptMap.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FPurpose) and isEmptyProp(FCopyright) and isEmptyProp(FSource) and isEmptyProp(FTarget) and isEmptyProp(FgroupList);
end;

function TFhirConceptMap.equals(other : TObject) : boolean;
var
  o : TFhirConceptMap;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConceptMap)) then
    result := false
  else
  begin
    o := TFhirConceptMap(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(purposeElement, o.purposeElement, true) and
      compareDeep(copyrightElement, o.copyrightElement, true) and compareDeep(sourceElement, o.sourceElement, true) and
      compareDeep(targetElement, o.targetElement, true) and compareDeep(groupList, o.groupList, true);
  end;
end;

function TFhirConceptMap.Link : TFhirConceptMap;
begin
  result := TFhirConceptMap(inherited Link);
end;

function TFhirConceptMap.Clone : TFhirConceptMap;
begin
  result := TFhirConceptMap(inherited Clone);
end;

procedure TFhirConceptMap.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('status');
  fields.add('experimental');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('purpose');
  fields.add('copyright');
  fields.add('source[x]');
  fields.add('target[x]');
  fields.add('group');
end;

{ TFhirConceptMap }

Procedure TFhirConceptMap.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirConceptMap.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

Function TFhirConceptMap.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

Procedure TFhirConceptMap.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

Procedure TFhirConceptMap.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

Function TFhirConceptMap.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

Procedure TFhirConceptMap.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

Procedure TFhirConceptMap.SetSource(value : TFhirType);
begin
  FSource.free;
  FSource := value;
end;

Procedure TFhirConceptMap.SetTarget(value : TFhirType);
begin
  FTarget.free;
  FTarget := value;
end;

Function TFhirConceptMap.GetGroupList : TFhirConceptMapGroupList;
begin
  if FGroupList = nil then
    FGroupList := TFhirConceptMapGroupList.Create;
  result := FGroupList;
end;

Function TFhirConceptMap.GetHasGroupList : boolean;
begin
  result := (FGroupList <> nil) and (FGroupList.count > 0);
end;

function TFhirConceptMap.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FPurpose.sizeInBytes);
  inc(result, FCopyright.sizeInBytes);
  inc(result, FSource.sizeInBytes);
  inc(result, FTarget.sizeInBytes);
  inc(result, FgroupList.sizeInBytes);
end;

{ TFhirConceptMapListEnumerator }

Constructor TFhirConceptMapListEnumerator.Create(list : TFhirConceptMapList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConceptMapListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConceptMapListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConceptMapListEnumerator.GetCurrent : TFhirConceptMap;
begin
  Result := FList[FIndex];
end;

function TFhirConceptMapListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirConceptMapList }
procedure TFhirConceptMapList.AddItem(value: TFhirConceptMap);
begin
  assert(value.ClassName = 'TFhirConceptMap', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConceptMap');
  add(value);
end;

function TFhirConceptMapList.Append: TFhirConceptMap;
begin
  result := TFhirConceptMap.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConceptMapList.ClearItems;
begin
  Clear;
end;

function TFhirConceptMapList.GetEnumerator : TFhirConceptMapListEnumerator;
begin
  result := TFhirConceptMapListEnumerator.Create(self.link);
end;

function TFhirConceptMapList.Clone: TFhirConceptMapList;
begin
  result := TFhirConceptMapList(inherited Clone);
end;

function TFhirConceptMapList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConceptMapList.GetItemN(index: Integer): TFhirConceptMap;
begin
  result := TFhirConceptMap(ObjectByIndex[index]);
end;

function TFhirConceptMapList.ItemClass: TFslObjectClass;
begin
  result := TFhirConceptMap;
end;
function TFhirConceptMapList.IndexOf(value: TFhirConceptMap): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConceptMapList.Insert(index: Integer): TFhirConceptMap;
begin
  result := TFhirConceptMap.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConceptMapList.InsertItem(index: Integer; value: TFhirConceptMap);
begin
  assert(value is TFhirConceptMap);
  Inherited Insert(index, value);
end;

function TFhirConceptMapList.Item(index: Integer): TFhirConceptMap;
begin
  result := TFhirConceptMap(ObjectByIndex[index]);
end;

function TFhirConceptMapList.Link: TFhirConceptMapList;
begin
  result := TFhirConceptMapList(inherited Link);
end;

procedure TFhirConceptMapList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConceptMapList.SetItemByIndex(index: Integer; value: TFhirConceptMap);
begin
  assert(value is TFhirConceptMap);
  FhirConceptMaps[index] := value;
end;

procedure TFhirConceptMapList.SetItemN(index: Integer; value: TFhirConceptMap);
begin
  assert(value is TFhirConceptMap);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CONCEPTMAP}

{$IFDEF FHIR_DATAELEMENT}

{ TFhirDataElementMapping }

constructor TFhirDataElementMapping.Create;
begin
  inherited;
end;

destructor TFhirDataElementMapping.Destroy;
begin
  FIdentity.free;
  FUri.free;
  FName.free;
  FComment.free;
  inherited;
end;

procedure TFhirDataElementMapping.Assign(oSource : TFslObject);
begin
  inherited;
  identityElement := TFhirDataElementMapping(oSource).identityElement.Clone;
  uriElement := TFhirDataElementMapping(oSource).uriElement.Clone;
  nameElement := TFhirDataElementMapping(oSource).nameElement.Clone;
  commentElement := TFhirDataElementMapping(oSource).commentElement.Clone;
end;

procedure TFhirDataElementMapping.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identity') Then
     list.add(self.link, 'identity', FIdentity.Link);
  if (child_name = 'uri') Then
     list.add(self.link, 'uri', FUri.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
end;

procedure TFhirDataElementMapping.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identity', 'id', false, TFhirId, FIdentity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'uri', 'uri', false, TFhirUri, FUri.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'comment', 'string', false, TFhirString, FComment.Link));{2}
end;

function TFhirDataElementMapping.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identity') then
  begin
    IdentityElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'uri') then
  begin
    UriElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDataElementMapping.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDataElementMapping.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identity') then result := TFhirId.create() {5b}
  else if (propName = 'uri') then result := TFhirUri.create() {5b}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'comment') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDataElementMapping.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identity') then result := 'id'
  else if (propName = 'uri') then result := 'uri'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'comment') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDataElementMapping.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identity') then IdentityElement := nil
  else if (propName = 'uri') then UriElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'comment') then CommentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDataElementMapping.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identity') then IdentityElement := asId(new){5b}
  else if (propName = 'uri') then UriElement := asUri(new){5b}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'comment') then CommentElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDataElementMapping.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDataElementMapping.fhirType : string;
begin
  result := 'mapping';
end;

function TFhirDataElementMapping.Link : TFhirDataElementMapping;
begin
  result := TFhirDataElementMapping(inherited Link);
end;

function TFhirDataElementMapping.Clone : TFhirDataElementMapping;
begin
  result := TFhirDataElementMapping(inherited Clone);
end;

function TFhirDataElementMapping.equals(other : TObject) : boolean;
var
  o : TFhirDataElementMapping;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDataElementMapping)) then
    result := false
  else
  begin
    o := TFhirDataElementMapping(other);
    result := compareDeep(identityElement, o.identityElement, true) and compareDeep(uriElement, o.uriElement, true) and
      compareDeep(nameElement, o.nameElement, true) and compareDeep(commentElement, o.commentElement, true);
  end;
end;

function TFhirDataElementMapping.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentity) and isEmptyProp(FUri) and isEmptyProp(FName) and isEmptyProp(FComment);
end;

procedure TFhirDataElementMapping.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identity');
  fields.add('uri');
  fields.add('name');
  fields.add('comment');
end;

{ TFhirDataElementMapping }

Procedure TFhirDataElementMapping.SetIdentity(value : TFhirId);
begin
  FIdentity.free;
  FIdentity := value;
end;

Function TFhirDataElementMapping.GetIdentityST : String;
begin
  if FIdentity = nil then
    result := ''
  else
    result := FIdentity.value;
end;

Procedure TFhirDataElementMapping.SetIdentityST(value : String);
begin
  if value <> '' then
  begin
    if FIdentity = nil then
      FIdentity := TFhirId.create;
    FIdentity.value := value
  end
  else if FIdentity <> nil then
    FIdentity.value := '';
end;

Procedure TFhirDataElementMapping.SetUri(value : TFhirUri);
begin
  FUri.free;
  FUri := value;
end;

Function TFhirDataElementMapping.GetUriST : String;
begin
  if FUri = nil then
    result := ''
  else
    result := FUri.value;
end;

Procedure TFhirDataElementMapping.SetUriST(value : String);
begin
  if value <> '' then
  begin
    if FUri = nil then
      FUri := TFhirUri.create;
    FUri.value := value
  end
  else if FUri <> nil then
    FUri.value := '';
end;

Procedure TFhirDataElementMapping.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirDataElementMapping.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirDataElementMapping.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirDataElementMapping.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value;
end;

Function TFhirDataElementMapping.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

Procedure TFhirDataElementMapping.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

function TFhirDataElementMapping.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentity.sizeInBytes);
  inc(result, FUri.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FComment.sizeInBytes);
end;

{ TFhirDataElementMappingListEnumerator }

Constructor TFhirDataElementMappingListEnumerator.Create(list : TFhirDataElementMappingList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDataElementMappingListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDataElementMappingListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDataElementMappingListEnumerator.GetCurrent : TFhirDataElementMapping;
begin
  Result := FList[FIndex];
end;

function TFhirDataElementMappingListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDataElementMappingList }
procedure TFhirDataElementMappingList.AddItem(value: TFhirDataElementMapping);
begin
  assert(value.ClassName = 'TFhirDataElementMapping', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDataElementMapping');
  add(value);
end;

function TFhirDataElementMappingList.Append: TFhirDataElementMapping;
begin
  result := TFhirDataElementMapping.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDataElementMappingList.ClearItems;
begin
  Clear;
end;

function TFhirDataElementMappingList.GetEnumerator : TFhirDataElementMappingListEnumerator;
begin
  result := TFhirDataElementMappingListEnumerator.Create(self.link);
end;

function TFhirDataElementMappingList.Clone: TFhirDataElementMappingList;
begin
  result := TFhirDataElementMappingList(inherited Clone);
end;

function TFhirDataElementMappingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDataElementMappingList.GetItemN(index: Integer): TFhirDataElementMapping;
begin
  result := TFhirDataElementMapping(ObjectByIndex[index]);
end;

function TFhirDataElementMappingList.ItemClass: TFslObjectClass;
begin
  result := TFhirDataElementMapping;
end;
function TFhirDataElementMappingList.IndexOf(value: TFhirDataElementMapping): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDataElementMappingList.Insert(index: Integer): TFhirDataElementMapping;
begin
  result := TFhirDataElementMapping.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDataElementMappingList.InsertItem(index: Integer; value: TFhirDataElementMapping);
begin
  assert(value is TFhirDataElementMapping);
  Inherited Insert(index, value);
end;

function TFhirDataElementMappingList.Item(index: Integer): TFhirDataElementMapping;
begin
  result := TFhirDataElementMapping(ObjectByIndex[index]);
end;

function TFhirDataElementMappingList.Link: TFhirDataElementMappingList;
begin
  result := TFhirDataElementMappingList(inherited Link);
end;

procedure TFhirDataElementMappingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDataElementMappingList.SetItemByIndex(index: Integer; value: TFhirDataElementMapping);
begin
  assert(value is TFhirDataElementMapping);
  FhirDataElementMappings[index] := value;
end;

procedure TFhirDataElementMappingList.SetItemN(index: Integer; value: TFhirDataElementMapping);
begin
  assert(value is TFhirDataElementMapping);
  ObjectByIndex[index] := value;
end;

{ TFhirDataElement }

constructor TFhirDataElement.Create;
begin
  inherited;
end;

destructor TFhirDataElement.Destroy;
begin
  FIdentifierList.Free;
  FCopyright.free;
  FStringency.free;
  FMappingList.Free;
  FElementList.Free;
  inherited;
end;

function TFhirDataElement.GetResourceType : TFhirResourceType;
begin
  result := frtDataElement;
end;

procedure TFhirDataElement.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirDataElement(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirDataElement(oSource).FIdentifierList);
  end;
  copyrightElement := TFhirDataElement(oSource).copyrightElement.Clone;
  FStringency := TFhirDataElement(oSource).FStringency.Link;
  if (TFhirDataElement(oSource).FMappingList = nil) then
  begin
    FMappingList.free;
    FMappingList := nil;
  end
  else
  begin
    if FMappingList = nil then
      FMappingList := TFhirDataElementMappingList.Create;
    FMappingList.Assign(TFhirDataElement(oSource).FMappingList);
  end;
  if (TFhirDataElement(oSource).FElementList = nil) then
  begin
    FElementList.free;
    FElementList := nil;
  end
  else
  begin
    if FElementList = nil then
      FElementList := TFhirElementDefinitionList.Create;
    FElementList.Assign(TFhirDataElement(oSource).FElementList);
  end;
end;

procedure TFhirDataElement.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'stringency') Then
     list.add(self.link, 'stringency', FStringency.Link);
  if (child_name = 'mapping') Then
    list.addAll(self, 'mapping', FMappingList);
  if (child_name = 'element') Then
    list.addAll(self, 'element', FElementList);
end;

procedure TFhirDataElement.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));{2}
  oList.add(TFHIRProperty.create(self, 'stringency', 'code', false, TFHIREnum, FStringency.Link));{1}
  oList.add(TFHIRProperty.create(self, 'mapping', '', true, TFhirDataElementMapping, FMappingList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'element', 'ElementDefinition', true, TFhirElementDefinition, FElementList.Link)){3};
end;

function TFhirDataElement.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'stringency') then
  begin
    StringencyElement := asEnum(SYSTEMS_TFhirDataelementStringencyEnum, CODES_TFhirDataelementStringencyEnum, propValue);
    result := propValue
  end
  else if (propName = 'mapping') then
  begin
    MappingList.add(propValue as TFhirDataElementMapping){2a};
    result := propValue;
  end
  else if (propName = 'element') then
  begin
    ElementList.add(propValue as TFhirElementDefinition){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirDataElement.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'mapping') then MappingList.insertItem(index, propValue as TFhirDataElementMapping){2a}
  else if (propName = 'element') then ElementList.insertItem(index, propValue as TFhirElementDefinition){2a}
  else inherited;
end;

function TFhirDataElement.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'copyright') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'mapping') then result := MappingList.new(){2}
  else if (propName = 'element') then result := ElementList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirDataElement.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'stringency') then result := 'code'
  else if (propName = 'mapping') then result := ''
  else if (propName = 'element') then result := 'ElementDefinition'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDataElement.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'stringency') then StringencyElement := nil
  else if (propName = 'mapping') then deletePropertyValue('mapping', MappingList, value) {2}
  else if (propName = 'element') then deletePropertyValue('element', ElementList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDataElement.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new){5b}
  else if (propName = 'stringency') then StringencyElement := asEnum(SYSTEMS_TFhirDataelementStringencyEnum, CODES_TFhirDataelementStringencyEnum, new){4}
  else if (propName = 'mapping') then replacePropertyValue('mapping', MappingList, existing, new) {2}
  else if (propName = 'element') then replacePropertyValue('element', ElementList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDataElement.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'mapping') then MappingList.move(source, destination){2a}
  else if (propName = 'element') then ElementList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDataElement.fhirType : string;
begin
  result := 'DataElement';
end;

function TFhirDataElement.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FCopyright) and isEmptyProp(FStringency) and isEmptyProp(FmappingList) and isEmptyProp(FelementList);
end;

function TFhirDataElement.equals(other : TObject) : boolean;
var
  o : TFhirDataElement;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDataElement)) then
    result := false
  else
  begin
    o := TFhirDataElement(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(copyrightElement, o.copyrightElement, true) and
      compareDeep(stringencyElement, o.stringencyElement, true) and compareDeep(mappingList, o.mappingList, true) and
      compareDeep(elementList, o.elementList, true);
  end;
end;

function TFhirDataElement.Link : TFhirDataElement;
begin
  result := TFhirDataElement(inherited Link);
end;

function TFhirDataElement.Clone : TFhirDataElement;
begin
  result := TFhirDataElement(inherited Clone);
end;

procedure TFhirDataElement.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('status');
  fields.add('experimental');
  fields.add('date');
  fields.add('publisher');
  fields.add('name');
  fields.add('title');
  fields.add('contact');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('copyright');
  fields.add('stringency');
  fields.add('mapping');
  fields.add('element');
end;

{ TFhirDataElement }

Function TFhirDataElement.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirDataElement.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirDataElement.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

Function TFhirDataElement.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

Procedure TFhirDataElement.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

Procedure TFhirDataElement.SetStringency(value : TFhirEnum);
begin
  FStringency.free;
  FStringency := value;
end;

Function TFhirDataElement.GetStringencyST : TFhirDataelementStringencyEnum;
begin
  if FStringency = nil then
    result := TFhirDataelementStringencyEnum(0)
  else
    result := TFhirDataelementStringencyEnum(StringArrayIndexOfSensitive(CODES_TFhirDataelementStringencyEnum, FStringency.value));
end;

Procedure TFhirDataElement.SetStringencyST(value : TFhirDataelementStringencyEnum);
begin
  if ord(value) = 0 then
    StringencyElement := nil
  else
    StringencyElement := TFhirEnum.create(SYSTEMS_TFhirDataelementStringencyEnum[value], CODES_TFhirDataelementStringencyEnum[value]);
end;

Function TFhirDataElement.GetMappingList : TFhirDataElementMappingList;
begin
  if FMappingList = nil then
    FMappingList := TFhirDataElementMappingList.Create;
  result := FMappingList;
end;

Function TFhirDataElement.GetHasMappingList : boolean;
begin
  result := (FMappingList <> nil) and (FMappingList.count > 0);
end;

Function TFhirDataElement.GetElementList : TFhirElementDefinitionList;
begin
  if FElementList = nil then
    FElementList := TFhirElementDefinitionList.Create;
  result := FElementList;
end;

Function TFhirDataElement.GetHasElementList : boolean;
begin
  result := (FElementList <> nil) and (FElementList.count > 0);
end;

function TFhirDataElement.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FCopyright.sizeInBytes);
  inc(result, FStringency.sizeInBytes);
  inc(result, FmappingList.sizeInBytes);
  inc(result, FelementList.sizeInBytes);
end;

{ TFhirDataElementListEnumerator }

Constructor TFhirDataElementListEnumerator.Create(list : TFhirDataElementList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDataElementListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDataElementListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDataElementListEnumerator.GetCurrent : TFhirDataElement;
begin
  Result := FList[FIndex];
end;

function TFhirDataElementListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirDataElementList }
procedure TFhirDataElementList.AddItem(value: TFhirDataElement);
begin
  assert(value.ClassName = 'TFhirDataElement', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDataElement');
  add(value);
end;

function TFhirDataElementList.Append: TFhirDataElement;
begin
  result := TFhirDataElement.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDataElementList.ClearItems;
begin
  Clear;
end;

function TFhirDataElementList.GetEnumerator : TFhirDataElementListEnumerator;
begin
  result := TFhirDataElementListEnumerator.Create(self.link);
end;

function TFhirDataElementList.Clone: TFhirDataElementList;
begin
  result := TFhirDataElementList(inherited Clone);
end;

function TFhirDataElementList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDataElementList.GetItemN(index: Integer): TFhirDataElement;
begin
  result := TFhirDataElement(ObjectByIndex[index]);
end;

function TFhirDataElementList.ItemClass: TFslObjectClass;
begin
  result := TFhirDataElement;
end;
function TFhirDataElementList.IndexOf(value: TFhirDataElement): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDataElementList.Insert(index: Integer): TFhirDataElement;
begin
  result := TFhirDataElement.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDataElementList.InsertItem(index: Integer; value: TFhirDataElement);
begin
  assert(value is TFhirDataElement);
  Inherited Insert(index, value);
end;

function TFhirDataElementList.Item(index: Integer): TFhirDataElement;
begin
  result := TFhirDataElement(ObjectByIndex[index]);
end;

function TFhirDataElementList.Link: TFhirDataElementList;
begin
  result := TFhirDataElementList(inherited Link);
end;

procedure TFhirDataElementList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDataElementList.SetItemByIndex(index: Integer; value: TFhirDataElement);
begin
  assert(value is TFhirDataElement);
  FhirDataElements[index] := value;
end;

procedure TFhirDataElementList.SetItemN(index: Integer; value: TFhirDataElement);
begin
  assert(value is TFhirDataElement);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_DATAELEMENT}

{$IFDEF FHIR_EXPANSIONPROFILE}

{ TFhirExpansionProfileFixedVersion }

constructor TFhirExpansionProfileFixedVersion.Create;
begin
  inherited;
end;

destructor TFhirExpansionProfileFixedVersion.Destroy;
begin
  FSystem.free;
  FVersion.free;
  FMode.free;
  inherited;
end;

procedure TFhirExpansionProfileFixedVersion.Assign(oSource : TFslObject);
begin
  inherited;
  systemElement := TFhirExpansionProfileFixedVersion(oSource).systemElement.Clone;
  versionElement := TFhirExpansionProfileFixedVersion(oSource).versionElement.Clone;
  FMode := TFhirExpansionProfileFixedVersion(oSource).FMode.Link;
end;

procedure TFhirExpansionProfileFixedVersion.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'system') Then
     list.add(self.link, 'system', FSystem.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'mode') Then
     list.add(self.link, 'mode', FMode.Link);
end;

procedure TFhirExpansionProfileFixedVersion.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'system', 'uri', false, TFhirUri, FSystem.Link));{2}
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));{2}
  oList.add(TFHIRProperty.create(self, 'mode', 'code', false, TFHIREnum, FMode.Link));{1}
end;

function TFhirExpansionProfileFixedVersion.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'system') then
  begin
    SystemElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'mode') then
  begin
    ModeElement := asEnum(SYSTEMS_TFhirSystemVersionProcessingModeEnum, CODES_TFhirSystemVersionProcessingModeEnum, propValue);
    result := propValue
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExpansionProfileFixedVersion.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExpansionProfileFixedVersion.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'system') then result := TFhirUri.create() {5b}
  else if (propName = 'version') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExpansionProfileFixedVersion.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'system') then result := 'uri'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'mode') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExpansionProfileFixedVersion.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'system') then SystemElement := nil
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'mode') then ModeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExpansionProfileFixedVersion.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'system') then SystemElement := asUri(new){5b}
  else if (propName = 'version') then VersionElement := asString(new){5b}
  else if (propName = 'mode') then ModeElement := asEnum(SYSTEMS_TFhirSystemVersionProcessingModeEnum, CODES_TFhirSystemVersionProcessingModeEnum, new){4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExpansionProfileFixedVersion.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExpansionProfileFixedVersion.fhirType : string;
begin
  result := 'fixedVersion';
end;

function TFhirExpansionProfileFixedVersion.Link : TFhirExpansionProfileFixedVersion;
begin
  result := TFhirExpansionProfileFixedVersion(inherited Link);
end;

function TFhirExpansionProfileFixedVersion.Clone : TFhirExpansionProfileFixedVersion;
begin
  result := TFhirExpansionProfileFixedVersion(inherited Clone);
end;

function TFhirExpansionProfileFixedVersion.equals(other : TObject) : boolean;
var
  o : TFhirExpansionProfileFixedVersion;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExpansionProfileFixedVersion)) then
    result := false
  else
  begin
    o := TFhirExpansionProfileFixedVersion(other);
    result := compareDeep(systemElement, o.systemElement, true) and compareDeep(versionElement, o.versionElement, true) and
      compareDeep(modeElement, o.modeElement, true);
  end;
end;

function TFhirExpansionProfileFixedVersion.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSystem) and isEmptyProp(FVersion) and isEmptyProp(FMode);
end;

procedure TFhirExpansionProfileFixedVersion.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('system');
  fields.add('version');
  fields.add('mode');
end;

{ TFhirExpansionProfileFixedVersion }

Procedure TFhirExpansionProfileFixedVersion.SetSystem(value : TFhirUri);
begin
  FSystem.free;
  FSystem := value;
end;

Function TFhirExpansionProfileFixedVersion.GetSystemST : String;
begin
  if FSystem = nil then
    result := ''
  else
    result := FSystem.value;
end;

Procedure TFhirExpansionProfileFixedVersion.SetSystemST(value : String);
begin
  if value <> '' then
  begin
    if FSystem = nil then
      FSystem := TFhirUri.create;
    FSystem.value := value
  end
  else if FSystem <> nil then
    FSystem.value := '';
end;

Procedure TFhirExpansionProfileFixedVersion.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

Function TFhirExpansionProfileFixedVersion.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

Procedure TFhirExpansionProfileFixedVersion.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

Procedure TFhirExpansionProfileFixedVersion.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

Function TFhirExpansionProfileFixedVersion.GetModeST : TFhirSystemVersionProcessingModeEnum;
begin
  if FMode = nil then
    result := TFhirSystemVersionProcessingModeEnum(0)
  else
    result := TFhirSystemVersionProcessingModeEnum(StringArrayIndexOfSensitive(CODES_TFhirSystemVersionProcessingModeEnum, FMode.value));
end;

Procedure TFhirExpansionProfileFixedVersion.SetModeST(value : TFhirSystemVersionProcessingModeEnum);
begin
  if ord(value) = 0 then
    ModeElement := nil
  else
    ModeElement := TFhirEnum.create(SYSTEMS_TFhirSystemVersionProcessingModeEnum[value], CODES_TFhirSystemVersionProcessingModeEnum[value]);
end;

function TFhirExpansionProfileFixedVersion.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSystem.sizeInBytes);
  inc(result, FVersion.sizeInBytes);
  inc(result, FMode.sizeInBytes);
end;

{ TFhirExpansionProfileFixedVersionListEnumerator }

Constructor TFhirExpansionProfileFixedVersionListEnumerator.Create(list : TFhirExpansionProfileFixedVersionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExpansionProfileFixedVersionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExpansionProfileFixedVersionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExpansionProfileFixedVersionListEnumerator.GetCurrent : TFhirExpansionProfileFixedVersion;
begin
  Result := FList[FIndex];
end;

function TFhirExpansionProfileFixedVersionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExpansionProfileFixedVersionList }
procedure TFhirExpansionProfileFixedVersionList.AddItem(value: TFhirExpansionProfileFixedVersion);
begin
  assert(value.ClassName = 'TFhirExpansionProfileFixedVersion', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExpansionProfileFixedVersion');
  add(value);
end;

function TFhirExpansionProfileFixedVersionList.Append: TFhirExpansionProfileFixedVersion;
begin
  result := TFhirExpansionProfileFixedVersion.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExpansionProfileFixedVersionList.ClearItems;
begin
  Clear;
end;

function TFhirExpansionProfileFixedVersionList.GetEnumerator : TFhirExpansionProfileFixedVersionListEnumerator;
begin
  result := TFhirExpansionProfileFixedVersionListEnumerator.Create(self.link);
end;

function TFhirExpansionProfileFixedVersionList.Clone: TFhirExpansionProfileFixedVersionList;
begin
  result := TFhirExpansionProfileFixedVersionList(inherited Clone);
end;

function TFhirExpansionProfileFixedVersionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExpansionProfileFixedVersionList.GetItemN(index: Integer): TFhirExpansionProfileFixedVersion;
begin
  result := TFhirExpansionProfileFixedVersion(ObjectByIndex[index]);
end;

function TFhirExpansionProfileFixedVersionList.ItemClass: TFslObjectClass;
begin
  result := TFhirExpansionProfileFixedVersion;
end;
function TFhirExpansionProfileFixedVersionList.IndexOf(value: TFhirExpansionProfileFixedVersion): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExpansionProfileFixedVersionList.Insert(index: Integer): TFhirExpansionProfileFixedVersion;
begin
  result := TFhirExpansionProfileFixedVersion.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExpansionProfileFixedVersionList.InsertItem(index: Integer; value: TFhirExpansionProfileFixedVersion);
begin
  assert(value is TFhirExpansionProfileFixedVersion);
  Inherited Insert(index, value);
end;

function TFhirExpansionProfileFixedVersionList.Item(index: Integer): TFhirExpansionProfileFixedVersion;
begin
  result := TFhirExpansionProfileFixedVersion(ObjectByIndex[index]);
end;

function TFhirExpansionProfileFixedVersionList.Link: TFhirExpansionProfileFixedVersionList;
begin
  result := TFhirExpansionProfileFixedVersionList(inherited Link);
end;

procedure TFhirExpansionProfileFixedVersionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExpansionProfileFixedVersionList.SetItemByIndex(index: Integer; value: TFhirExpansionProfileFixedVersion);
begin
  assert(value is TFhirExpansionProfileFixedVersion);
  FhirExpansionProfileFixedVersions[index] := value;
end;

procedure TFhirExpansionProfileFixedVersionList.SetItemN(index: Integer; value: TFhirExpansionProfileFixedVersion);
begin
  assert(value is TFhirExpansionProfileFixedVersion);
  ObjectByIndex[index] := value;
end;

{ TFhirExpansionProfileExcludedSystem }

constructor TFhirExpansionProfileExcludedSystem.Create;
begin
  inherited;
end;

destructor TFhirExpansionProfileExcludedSystem.Destroy;
begin
  FSystem.free;
  FVersion.free;
  inherited;
end;

procedure TFhirExpansionProfileExcludedSystem.Assign(oSource : TFslObject);
begin
  inherited;
  systemElement := TFhirExpansionProfileExcludedSystem(oSource).systemElement.Clone;
  versionElement := TFhirExpansionProfileExcludedSystem(oSource).versionElement.Clone;
end;

procedure TFhirExpansionProfileExcludedSystem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'system') Then
     list.add(self.link, 'system', FSystem.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
end;

procedure TFhirExpansionProfileExcludedSystem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'system', 'uri', false, TFhirUri, FSystem.Link));{2}
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));{2}
end;

function TFhirExpansionProfileExcludedSystem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'system') then
  begin
    SystemElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExpansionProfileExcludedSystem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExpansionProfileExcludedSystem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'system') then result := TFhirUri.create() {5b}
  else if (propName = 'version') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExpansionProfileExcludedSystem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'system') then result := 'uri'
  else if (propName = 'version') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExpansionProfileExcludedSystem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'system') then SystemElement := nil
  else if (propName = 'version') then VersionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExpansionProfileExcludedSystem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'system') then SystemElement := asUri(new){5b}
  else if (propName = 'version') then VersionElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExpansionProfileExcludedSystem.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExpansionProfileExcludedSystem.fhirType : string;
begin
  result := 'excludedSystem';
end;

function TFhirExpansionProfileExcludedSystem.Link : TFhirExpansionProfileExcludedSystem;
begin
  result := TFhirExpansionProfileExcludedSystem(inherited Link);
end;

function TFhirExpansionProfileExcludedSystem.Clone : TFhirExpansionProfileExcludedSystem;
begin
  result := TFhirExpansionProfileExcludedSystem(inherited Clone);
end;

function TFhirExpansionProfileExcludedSystem.equals(other : TObject) : boolean;
var
  o : TFhirExpansionProfileExcludedSystem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExpansionProfileExcludedSystem)) then
    result := false
  else
  begin
    o := TFhirExpansionProfileExcludedSystem(other);
    result := compareDeep(systemElement, o.systemElement, true) and compareDeep(versionElement, o.versionElement, true);
  end;
end;

function TFhirExpansionProfileExcludedSystem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSystem) and isEmptyProp(FVersion);
end;

procedure TFhirExpansionProfileExcludedSystem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('system');
  fields.add('version');
end;

{ TFhirExpansionProfileExcludedSystem }

Procedure TFhirExpansionProfileExcludedSystem.SetSystem(value : TFhirUri);
begin
  FSystem.free;
  FSystem := value;
end;

Function TFhirExpansionProfileExcludedSystem.GetSystemST : String;
begin
  if FSystem = nil then
    result := ''
  else
    result := FSystem.value;
end;

Procedure TFhirExpansionProfileExcludedSystem.SetSystemST(value : String);
begin
  if value <> '' then
  begin
    if FSystem = nil then
      FSystem := TFhirUri.create;
    FSystem.value := value
  end
  else if FSystem <> nil then
    FSystem.value := '';
end;

Procedure TFhirExpansionProfileExcludedSystem.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

Function TFhirExpansionProfileExcludedSystem.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

Procedure TFhirExpansionProfileExcludedSystem.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

function TFhirExpansionProfileExcludedSystem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSystem.sizeInBytes);
  inc(result, FVersion.sizeInBytes);
end;

{ TFhirExpansionProfileExcludedSystemListEnumerator }

Constructor TFhirExpansionProfileExcludedSystemListEnumerator.Create(list : TFhirExpansionProfileExcludedSystemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExpansionProfileExcludedSystemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExpansionProfileExcludedSystemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExpansionProfileExcludedSystemListEnumerator.GetCurrent : TFhirExpansionProfileExcludedSystem;
begin
  Result := FList[FIndex];
end;

function TFhirExpansionProfileExcludedSystemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExpansionProfileExcludedSystemList }
procedure TFhirExpansionProfileExcludedSystemList.AddItem(value: TFhirExpansionProfileExcludedSystem);
begin
  assert(value.ClassName = 'TFhirExpansionProfileExcludedSystem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExpansionProfileExcludedSystem');
  add(value);
end;

function TFhirExpansionProfileExcludedSystemList.Append: TFhirExpansionProfileExcludedSystem;
begin
  result := TFhirExpansionProfileExcludedSystem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExpansionProfileExcludedSystemList.ClearItems;
begin
  Clear;
end;

function TFhirExpansionProfileExcludedSystemList.GetEnumerator : TFhirExpansionProfileExcludedSystemListEnumerator;
begin
  result := TFhirExpansionProfileExcludedSystemListEnumerator.Create(self.link);
end;

function TFhirExpansionProfileExcludedSystemList.Clone: TFhirExpansionProfileExcludedSystemList;
begin
  result := TFhirExpansionProfileExcludedSystemList(inherited Clone);
end;

function TFhirExpansionProfileExcludedSystemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExpansionProfileExcludedSystemList.GetItemN(index: Integer): TFhirExpansionProfileExcludedSystem;
begin
  result := TFhirExpansionProfileExcludedSystem(ObjectByIndex[index]);
end;

function TFhirExpansionProfileExcludedSystemList.ItemClass: TFslObjectClass;
begin
  result := TFhirExpansionProfileExcludedSystem;
end;
function TFhirExpansionProfileExcludedSystemList.IndexOf(value: TFhirExpansionProfileExcludedSystem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExpansionProfileExcludedSystemList.Insert(index: Integer): TFhirExpansionProfileExcludedSystem;
begin
  result := TFhirExpansionProfileExcludedSystem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExpansionProfileExcludedSystemList.InsertItem(index: Integer; value: TFhirExpansionProfileExcludedSystem);
begin
  assert(value is TFhirExpansionProfileExcludedSystem);
  Inherited Insert(index, value);
end;

function TFhirExpansionProfileExcludedSystemList.Item(index: Integer): TFhirExpansionProfileExcludedSystem;
begin
  result := TFhirExpansionProfileExcludedSystem(ObjectByIndex[index]);
end;

function TFhirExpansionProfileExcludedSystemList.Link: TFhirExpansionProfileExcludedSystemList;
begin
  result := TFhirExpansionProfileExcludedSystemList(inherited Link);
end;

procedure TFhirExpansionProfileExcludedSystemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExpansionProfileExcludedSystemList.SetItemByIndex(index: Integer; value: TFhirExpansionProfileExcludedSystem);
begin
  assert(value is TFhirExpansionProfileExcludedSystem);
  FhirExpansionProfileExcludedSystems[index] := value;
end;

procedure TFhirExpansionProfileExcludedSystemList.SetItemN(index: Integer; value: TFhirExpansionProfileExcludedSystem);
begin
  assert(value is TFhirExpansionProfileExcludedSystem);
  ObjectByIndex[index] := value;
end;

{ TFhirExpansionProfileDesignation }

constructor TFhirExpansionProfileDesignation.Create;
begin
  inherited;
end;

destructor TFhirExpansionProfileDesignation.Destroy;
begin
  FInclude.free;
  FExclude.free;
  inherited;
end;

procedure TFhirExpansionProfileDesignation.Assign(oSource : TFslObject);
begin
  inherited;
  include := TFhirExpansionProfileDesignation(oSource).include.Clone;
  exclude := TFhirExpansionProfileDesignation(oSource).exclude.Clone;
end;

procedure TFhirExpansionProfileDesignation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'include') Then
     list.add(self.link, 'include', FInclude.Link);
  if (child_name = 'exclude') Then
     list.add(self.link, 'exclude', FExclude.Link);
end;

procedure TFhirExpansionProfileDesignation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'include', '', false, TFhirExpansionProfileDesignationInclude, FInclude.Link));{2}
  oList.add(TFHIRProperty.create(self, 'exclude', '', false, TFhirExpansionProfileDesignationExclude, FExclude.Link));{2}
end;

function TFhirExpansionProfileDesignation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'include') then
  begin
    Include := propValue as TFhirExpansionProfileDesignationInclude{4b};
    result := propValue;
  end
  else if (propName = 'exclude') then
  begin
    Exclude := propValue as TFhirExpansionProfileDesignationExclude{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExpansionProfileDesignation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExpansionProfileDesignation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'include') then result := TFhirExpansionProfileDesignationInclude.create(){4b}
  else if (propName = 'exclude') then result := TFhirExpansionProfileDesignationExclude.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExpansionProfileDesignation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'include') then result := ''
  else if (propName = 'exclude') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExpansionProfileDesignation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'include') then IncludeElement := nil
  else if (propName = 'exclude') then ExcludeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExpansionProfileDesignation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'include') then IncludeElement := new as TFhirExpansionProfileDesignationInclude{4}
  else if (propName = 'exclude') then ExcludeElement := new as TFhirExpansionProfileDesignationExclude{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExpansionProfileDesignation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExpansionProfileDesignation.fhirType : string;
begin
  result := 'designation';
end;

function TFhirExpansionProfileDesignation.Link : TFhirExpansionProfileDesignation;
begin
  result := TFhirExpansionProfileDesignation(inherited Link);
end;

function TFhirExpansionProfileDesignation.Clone : TFhirExpansionProfileDesignation;
begin
  result := TFhirExpansionProfileDesignation(inherited Clone);
end;

function TFhirExpansionProfileDesignation.equals(other : TObject) : boolean;
var
  o : TFhirExpansionProfileDesignation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExpansionProfileDesignation)) then
    result := false
  else
  begin
    o := TFhirExpansionProfileDesignation(other);
    result := compareDeep(includeElement, o.includeElement, true) and compareDeep(excludeElement, o.excludeElement, true);
  end;
end;

function TFhirExpansionProfileDesignation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FInclude) and isEmptyProp(FExclude);
end;

procedure TFhirExpansionProfileDesignation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('include');
  fields.add('exclude');
end;

{ TFhirExpansionProfileDesignation }

Procedure TFhirExpansionProfileDesignation.SetInclude(value : TFhirExpansionProfileDesignationInclude);
begin
  FInclude.free;
  FInclude := value;
end;

Procedure TFhirExpansionProfileDesignation.SetExclude(value : TFhirExpansionProfileDesignationExclude);
begin
  FExclude.free;
  FExclude := value;
end;

function TFhirExpansionProfileDesignation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FInclude.sizeInBytes);
  inc(result, FExclude.sizeInBytes);
end;

{ TFhirExpansionProfileDesignationListEnumerator }

Constructor TFhirExpansionProfileDesignationListEnumerator.Create(list : TFhirExpansionProfileDesignationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExpansionProfileDesignationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExpansionProfileDesignationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExpansionProfileDesignationListEnumerator.GetCurrent : TFhirExpansionProfileDesignation;
begin
  Result := FList[FIndex];
end;

function TFhirExpansionProfileDesignationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExpansionProfileDesignationList }
procedure TFhirExpansionProfileDesignationList.AddItem(value: TFhirExpansionProfileDesignation);
begin
  assert(value.ClassName = 'TFhirExpansionProfileDesignation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExpansionProfileDesignation');
  add(value);
end;

function TFhirExpansionProfileDesignationList.Append: TFhirExpansionProfileDesignation;
begin
  result := TFhirExpansionProfileDesignation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExpansionProfileDesignationList.ClearItems;
begin
  Clear;
end;

function TFhirExpansionProfileDesignationList.GetEnumerator : TFhirExpansionProfileDesignationListEnumerator;
begin
  result := TFhirExpansionProfileDesignationListEnumerator.Create(self.link);
end;

function TFhirExpansionProfileDesignationList.Clone: TFhirExpansionProfileDesignationList;
begin
  result := TFhirExpansionProfileDesignationList(inherited Clone);
end;

function TFhirExpansionProfileDesignationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExpansionProfileDesignationList.GetItemN(index: Integer): TFhirExpansionProfileDesignation;
begin
  result := TFhirExpansionProfileDesignation(ObjectByIndex[index]);
end;

function TFhirExpansionProfileDesignationList.ItemClass: TFslObjectClass;
begin
  result := TFhirExpansionProfileDesignation;
end;
function TFhirExpansionProfileDesignationList.IndexOf(value: TFhirExpansionProfileDesignation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExpansionProfileDesignationList.Insert(index: Integer): TFhirExpansionProfileDesignation;
begin
  result := TFhirExpansionProfileDesignation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExpansionProfileDesignationList.InsertItem(index: Integer; value: TFhirExpansionProfileDesignation);
begin
  assert(value is TFhirExpansionProfileDesignation);
  Inherited Insert(index, value);
end;

function TFhirExpansionProfileDesignationList.Item(index: Integer): TFhirExpansionProfileDesignation;
begin
  result := TFhirExpansionProfileDesignation(ObjectByIndex[index]);
end;

function TFhirExpansionProfileDesignationList.Link: TFhirExpansionProfileDesignationList;
begin
  result := TFhirExpansionProfileDesignationList(inherited Link);
end;

procedure TFhirExpansionProfileDesignationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExpansionProfileDesignationList.SetItemByIndex(index: Integer; value: TFhirExpansionProfileDesignation);
begin
  assert(value is TFhirExpansionProfileDesignation);
  FhirExpansionProfileDesignations[index] := value;
end;

procedure TFhirExpansionProfileDesignationList.SetItemN(index: Integer; value: TFhirExpansionProfileDesignation);
begin
  assert(value is TFhirExpansionProfileDesignation);
  ObjectByIndex[index] := value;
end;

{ TFhirExpansionProfileDesignationInclude }

constructor TFhirExpansionProfileDesignationInclude.Create;
begin
  inherited;
end;

destructor TFhirExpansionProfileDesignationInclude.Destroy;
begin
  FDesignationList.Free;
  inherited;
end;

procedure TFhirExpansionProfileDesignationInclude.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirExpansionProfileDesignationInclude(oSource).FDesignationList = nil) then
  begin
    FDesignationList.free;
    FDesignationList := nil;
  end
  else
  begin
    if FDesignationList = nil then
      FDesignationList := TFhirExpansionProfileDesignationIncludeDesignationList.Create;
    FDesignationList.Assign(TFhirExpansionProfileDesignationInclude(oSource).FDesignationList);
  end;
end;

procedure TFhirExpansionProfileDesignationInclude.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'designation') Then
    list.addAll(self, 'designation', FDesignationList);
end;

procedure TFhirExpansionProfileDesignationInclude.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'designation', '', true, TFhirExpansionProfileDesignationIncludeDesignation, FDesignationList.Link)){3};
end;

function TFhirExpansionProfileDesignationInclude.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'designation') then
  begin
    DesignationList.add(propValue as TFhirExpansionProfileDesignationIncludeDesignation){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExpansionProfileDesignationInclude.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'designation') then DesignationList.insertItem(index, propValue as TFhirExpansionProfileDesignationIncludeDesignation){2a}
  else inherited;
end;

function TFhirExpansionProfileDesignationInclude.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'designation') then result := DesignationList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExpansionProfileDesignationInclude.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'designation') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExpansionProfileDesignationInclude.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'designation') then deletePropertyValue('designation', DesignationList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExpansionProfileDesignationInclude.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'designation') then replacePropertyValue('designation', DesignationList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExpansionProfileDesignationInclude.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'designation') then DesignationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExpansionProfileDesignationInclude.fhirType : string;
begin
  result := 'include';
end;

function TFhirExpansionProfileDesignationInclude.Link : TFhirExpansionProfileDesignationInclude;
begin
  result := TFhirExpansionProfileDesignationInclude(inherited Link);
end;

function TFhirExpansionProfileDesignationInclude.Clone : TFhirExpansionProfileDesignationInclude;
begin
  result := TFhirExpansionProfileDesignationInclude(inherited Clone);
end;

function TFhirExpansionProfileDesignationInclude.equals(other : TObject) : boolean;
var
  o : TFhirExpansionProfileDesignationInclude;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExpansionProfileDesignationInclude)) then
    result := false
  else
  begin
    o := TFhirExpansionProfileDesignationInclude(other);
    result := compareDeep(designationList, o.designationList, true);
  end;
end;

function TFhirExpansionProfileDesignationInclude.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FdesignationList);
end;

procedure TFhirExpansionProfileDesignationInclude.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('designation');
end;

{ TFhirExpansionProfileDesignationInclude }

Function TFhirExpansionProfileDesignationInclude.GetDesignationList : TFhirExpansionProfileDesignationIncludeDesignationList;
begin
  if FDesignationList = nil then
    FDesignationList := TFhirExpansionProfileDesignationIncludeDesignationList.Create;
  result := FDesignationList;
end;

Function TFhirExpansionProfileDesignationInclude.GetHasDesignationList : boolean;
begin
  result := (FDesignationList <> nil) and (FDesignationList.count > 0);
end;

function TFhirExpansionProfileDesignationInclude.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FdesignationList.sizeInBytes);
end;

{ TFhirExpansionProfileDesignationIncludeListEnumerator }

Constructor TFhirExpansionProfileDesignationIncludeListEnumerator.Create(list : TFhirExpansionProfileDesignationIncludeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExpansionProfileDesignationIncludeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExpansionProfileDesignationIncludeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExpansionProfileDesignationIncludeListEnumerator.GetCurrent : TFhirExpansionProfileDesignationInclude;
begin
  Result := FList[FIndex];
end;

function TFhirExpansionProfileDesignationIncludeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExpansionProfileDesignationIncludeList }
procedure TFhirExpansionProfileDesignationIncludeList.AddItem(value: TFhirExpansionProfileDesignationInclude);
begin
  assert(value.ClassName = 'TFhirExpansionProfileDesignationInclude', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExpansionProfileDesignationInclude');
  add(value);
end;

function TFhirExpansionProfileDesignationIncludeList.Append: TFhirExpansionProfileDesignationInclude;
begin
  result := TFhirExpansionProfileDesignationInclude.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExpansionProfileDesignationIncludeList.ClearItems;
begin
  Clear;
end;

function TFhirExpansionProfileDesignationIncludeList.GetEnumerator : TFhirExpansionProfileDesignationIncludeListEnumerator;
begin
  result := TFhirExpansionProfileDesignationIncludeListEnumerator.Create(self.link);
end;

function TFhirExpansionProfileDesignationIncludeList.Clone: TFhirExpansionProfileDesignationIncludeList;
begin
  result := TFhirExpansionProfileDesignationIncludeList(inherited Clone);
end;

function TFhirExpansionProfileDesignationIncludeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExpansionProfileDesignationIncludeList.GetItemN(index: Integer): TFhirExpansionProfileDesignationInclude;
begin
  result := TFhirExpansionProfileDesignationInclude(ObjectByIndex[index]);
end;

function TFhirExpansionProfileDesignationIncludeList.ItemClass: TFslObjectClass;
begin
  result := TFhirExpansionProfileDesignationInclude;
end;
function TFhirExpansionProfileDesignationIncludeList.IndexOf(value: TFhirExpansionProfileDesignationInclude): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExpansionProfileDesignationIncludeList.Insert(index: Integer): TFhirExpansionProfileDesignationInclude;
begin
  result := TFhirExpansionProfileDesignationInclude.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExpansionProfileDesignationIncludeList.InsertItem(index: Integer; value: TFhirExpansionProfileDesignationInclude);
begin
  assert(value is TFhirExpansionProfileDesignationInclude);
  Inherited Insert(index, value);
end;

function TFhirExpansionProfileDesignationIncludeList.Item(index: Integer): TFhirExpansionProfileDesignationInclude;
begin
  result := TFhirExpansionProfileDesignationInclude(ObjectByIndex[index]);
end;

function TFhirExpansionProfileDesignationIncludeList.Link: TFhirExpansionProfileDesignationIncludeList;
begin
  result := TFhirExpansionProfileDesignationIncludeList(inherited Link);
end;

procedure TFhirExpansionProfileDesignationIncludeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExpansionProfileDesignationIncludeList.SetItemByIndex(index: Integer; value: TFhirExpansionProfileDesignationInclude);
begin
  assert(value is TFhirExpansionProfileDesignationInclude);
  FhirExpansionProfileDesignationIncludes[index] := value;
end;

procedure TFhirExpansionProfileDesignationIncludeList.SetItemN(index: Integer; value: TFhirExpansionProfileDesignationInclude);
begin
  assert(value is TFhirExpansionProfileDesignationInclude);
  ObjectByIndex[index] := value;
end;

{ TFhirExpansionProfileDesignationIncludeDesignation }

constructor TFhirExpansionProfileDesignationIncludeDesignation.Create;
begin
  inherited;
end;

destructor TFhirExpansionProfileDesignationIncludeDesignation.Destroy;
begin
  FLanguage.free;
  FUse.free;
  inherited;
end;

procedure TFhirExpansionProfileDesignationIncludeDesignation.Assign(oSource : TFslObject);
begin
  inherited;
  languageElement := TFhirExpansionProfileDesignationIncludeDesignation(oSource).languageElement.Clone;
  use := TFhirExpansionProfileDesignationIncludeDesignation(oSource).use.Clone;
end;

procedure TFhirExpansionProfileDesignationIncludeDesignation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'language') Then
     list.add(self.link, 'language', FLanguage.Link);
  if (child_name = 'use') Then
     list.add(self.link, 'use', FUse.Link);
end;

procedure TFhirExpansionProfileDesignationIncludeDesignation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'language', 'code', false, TFhirCode, FLanguage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'use', 'Coding', false, TFhirCoding, FUse.Link));{2}
end;

function TFhirExpansionProfileDesignationIncludeDesignation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'language') then
  begin
    LanguageElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'use') then
  begin
    Use := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExpansionProfileDesignationIncludeDesignation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExpansionProfileDesignationIncludeDesignation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'language') then result := TFhirCode.create() {5b}
  else if (propName = 'use') then result := TFhirCoding.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExpansionProfileDesignationIncludeDesignation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'language') then result := 'code'
  else if (propName = 'use') then result := 'Coding'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExpansionProfileDesignationIncludeDesignation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'language') then LanguageElement := nil
  else if (propName = 'use') then UseElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExpansionProfileDesignationIncludeDesignation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'language') then LanguageElement := asCode(new){5b}
  else if (propName = 'use') then UseElement := new as TFhirCoding{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExpansionProfileDesignationIncludeDesignation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExpansionProfileDesignationIncludeDesignation.fhirType : string;
begin
  result := 'designation';
end;

function TFhirExpansionProfileDesignationIncludeDesignation.Link : TFhirExpansionProfileDesignationIncludeDesignation;
begin
  result := TFhirExpansionProfileDesignationIncludeDesignation(inherited Link);
end;

function TFhirExpansionProfileDesignationIncludeDesignation.Clone : TFhirExpansionProfileDesignationIncludeDesignation;
begin
  result := TFhirExpansionProfileDesignationIncludeDesignation(inherited Clone);
end;

function TFhirExpansionProfileDesignationIncludeDesignation.equals(other : TObject) : boolean;
var
  o : TFhirExpansionProfileDesignationIncludeDesignation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExpansionProfileDesignationIncludeDesignation)) then
    result := false
  else
  begin
    o := TFhirExpansionProfileDesignationIncludeDesignation(other);
    result := compareDeep(languageElement, o.languageElement, true) and compareDeep(useElement, o.useElement, true);
  end;
end;

function TFhirExpansionProfileDesignationIncludeDesignation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLanguage) and isEmptyProp(FUse);
end;

procedure TFhirExpansionProfileDesignationIncludeDesignation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('language');
  fields.add('use');
end;

{ TFhirExpansionProfileDesignationIncludeDesignation }

Procedure TFhirExpansionProfileDesignationIncludeDesignation.SetLanguage(value : TFhirCode);
begin
  FLanguage.free;
  FLanguage := value;
end;

Function TFhirExpansionProfileDesignationIncludeDesignation.GetLanguageST : String;
begin
  if FLanguage = nil then
    result := ''
  else
    result := FLanguage.value;
end;

Procedure TFhirExpansionProfileDesignationIncludeDesignation.SetLanguageST(value : String);
begin
  if value <> '' then
  begin
    if FLanguage = nil then
      FLanguage := TFhirCode.create;
    FLanguage.value := value
  end
  else if FLanguage <> nil then
    FLanguage.value := '';
end;

Procedure TFhirExpansionProfileDesignationIncludeDesignation.SetUse(value : TFhirCoding);
begin
  FUse.free;
  FUse := value;
end;

function TFhirExpansionProfileDesignationIncludeDesignation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FLanguage.sizeInBytes);
  inc(result, FUse.sizeInBytes);
end;

{ TFhirExpansionProfileDesignationIncludeDesignationListEnumerator }

Constructor TFhirExpansionProfileDesignationIncludeDesignationListEnumerator.Create(list : TFhirExpansionProfileDesignationIncludeDesignationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExpansionProfileDesignationIncludeDesignationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExpansionProfileDesignationIncludeDesignationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExpansionProfileDesignationIncludeDesignationListEnumerator.GetCurrent : TFhirExpansionProfileDesignationIncludeDesignation;
begin
  Result := FList[FIndex];
end;

function TFhirExpansionProfileDesignationIncludeDesignationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExpansionProfileDesignationIncludeDesignationList }
procedure TFhirExpansionProfileDesignationIncludeDesignationList.AddItem(value: TFhirExpansionProfileDesignationIncludeDesignation);
begin
  assert(value.ClassName = 'TFhirExpansionProfileDesignationIncludeDesignation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExpansionProfileDesignationIncludeDesignation');
  add(value);
end;

function TFhirExpansionProfileDesignationIncludeDesignationList.Append: TFhirExpansionProfileDesignationIncludeDesignation;
begin
  result := TFhirExpansionProfileDesignationIncludeDesignation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExpansionProfileDesignationIncludeDesignationList.ClearItems;
begin
  Clear;
end;

function TFhirExpansionProfileDesignationIncludeDesignationList.GetEnumerator : TFhirExpansionProfileDesignationIncludeDesignationListEnumerator;
begin
  result := TFhirExpansionProfileDesignationIncludeDesignationListEnumerator.Create(self.link);
end;

function TFhirExpansionProfileDesignationIncludeDesignationList.Clone: TFhirExpansionProfileDesignationIncludeDesignationList;
begin
  result := TFhirExpansionProfileDesignationIncludeDesignationList(inherited Clone);
end;

function TFhirExpansionProfileDesignationIncludeDesignationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExpansionProfileDesignationIncludeDesignationList.GetItemN(index: Integer): TFhirExpansionProfileDesignationIncludeDesignation;
begin
  result := TFhirExpansionProfileDesignationIncludeDesignation(ObjectByIndex[index]);
end;

function TFhirExpansionProfileDesignationIncludeDesignationList.ItemClass: TFslObjectClass;
begin
  result := TFhirExpansionProfileDesignationIncludeDesignation;
end;
function TFhirExpansionProfileDesignationIncludeDesignationList.IndexOf(value: TFhirExpansionProfileDesignationIncludeDesignation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExpansionProfileDesignationIncludeDesignationList.Insert(index: Integer): TFhirExpansionProfileDesignationIncludeDesignation;
begin
  result := TFhirExpansionProfileDesignationIncludeDesignation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExpansionProfileDesignationIncludeDesignationList.InsertItem(index: Integer; value: TFhirExpansionProfileDesignationIncludeDesignation);
begin
  assert(value is TFhirExpansionProfileDesignationIncludeDesignation);
  Inherited Insert(index, value);
end;

function TFhirExpansionProfileDesignationIncludeDesignationList.Item(index: Integer): TFhirExpansionProfileDesignationIncludeDesignation;
begin
  result := TFhirExpansionProfileDesignationIncludeDesignation(ObjectByIndex[index]);
end;

function TFhirExpansionProfileDesignationIncludeDesignationList.Link: TFhirExpansionProfileDesignationIncludeDesignationList;
begin
  result := TFhirExpansionProfileDesignationIncludeDesignationList(inherited Link);
end;

procedure TFhirExpansionProfileDesignationIncludeDesignationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExpansionProfileDesignationIncludeDesignationList.SetItemByIndex(index: Integer; value: TFhirExpansionProfileDesignationIncludeDesignation);
begin
  assert(value is TFhirExpansionProfileDesignationIncludeDesignation);
  FhirExpansionProfileDesignationIncludeDesignations[index] := value;
end;

procedure TFhirExpansionProfileDesignationIncludeDesignationList.SetItemN(index: Integer; value: TFhirExpansionProfileDesignationIncludeDesignation);
begin
  assert(value is TFhirExpansionProfileDesignationIncludeDesignation);
  ObjectByIndex[index] := value;
end;

{ TFhirExpansionProfileDesignationExclude }

constructor TFhirExpansionProfileDesignationExclude.Create;
begin
  inherited;
end;

destructor TFhirExpansionProfileDesignationExclude.Destroy;
begin
  FDesignationList.Free;
  inherited;
end;

procedure TFhirExpansionProfileDesignationExclude.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirExpansionProfileDesignationExclude(oSource).FDesignationList = nil) then
  begin
    FDesignationList.free;
    FDesignationList := nil;
  end
  else
  begin
    if FDesignationList = nil then
      FDesignationList := TFhirExpansionProfileDesignationExcludeDesignationList.Create;
    FDesignationList.Assign(TFhirExpansionProfileDesignationExclude(oSource).FDesignationList);
  end;
end;

procedure TFhirExpansionProfileDesignationExclude.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'designation') Then
    list.addAll(self, 'designation', FDesignationList);
end;

procedure TFhirExpansionProfileDesignationExclude.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'designation', '', true, TFhirExpansionProfileDesignationExcludeDesignation, FDesignationList.Link)){3};
end;

function TFhirExpansionProfileDesignationExclude.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'designation') then
  begin
    DesignationList.add(propValue as TFhirExpansionProfileDesignationExcludeDesignation){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExpansionProfileDesignationExclude.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'designation') then DesignationList.insertItem(index, propValue as TFhirExpansionProfileDesignationExcludeDesignation){2a}
  else inherited;
end;

function TFhirExpansionProfileDesignationExclude.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'designation') then result := DesignationList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExpansionProfileDesignationExclude.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'designation') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExpansionProfileDesignationExclude.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'designation') then deletePropertyValue('designation', DesignationList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExpansionProfileDesignationExclude.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'designation') then replacePropertyValue('designation', DesignationList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExpansionProfileDesignationExclude.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'designation') then DesignationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExpansionProfileDesignationExclude.fhirType : string;
begin
  result := 'exclude';
end;

function TFhirExpansionProfileDesignationExclude.Link : TFhirExpansionProfileDesignationExclude;
begin
  result := TFhirExpansionProfileDesignationExclude(inherited Link);
end;

function TFhirExpansionProfileDesignationExclude.Clone : TFhirExpansionProfileDesignationExclude;
begin
  result := TFhirExpansionProfileDesignationExclude(inherited Clone);
end;

function TFhirExpansionProfileDesignationExclude.equals(other : TObject) : boolean;
var
  o : TFhirExpansionProfileDesignationExclude;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExpansionProfileDesignationExclude)) then
    result := false
  else
  begin
    o := TFhirExpansionProfileDesignationExclude(other);
    result := compareDeep(designationList, o.designationList, true);
  end;
end;

function TFhirExpansionProfileDesignationExclude.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FdesignationList);
end;

procedure TFhirExpansionProfileDesignationExclude.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('designation');
end;

{ TFhirExpansionProfileDesignationExclude }

Function TFhirExpansionProfileDesignationExclude.GetDesignationList : TFhirExpansionProfileDesignationExcludeDesignationList;
begin
  if FDesignationList = nil then
    FDesignationList := TFhirExpansionProfileDesignationExcludeDesignationList.Create;
  result := FDesignationList;
end;

Function TFhirExpansionProfileDesignationExclude.GetHasDesignationList : boolean;
begin
  result := (FDesignationList <> nil) and (FDesignationList.count > 0);
end;

function TFhirExpansionProfileDesignationExclude.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FdesignationList.sizeInBytes);
end;

{ TFhirExpansionProfileDesignationExcludeListEnumerator }

Constructor TFhirExpansionProfileDesignationExcludeListEnumerator.Create(list : TFhirExpansionProfileDesignationExcludeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExpansionProfileDesignationExcludeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExpansionProfileDesignationExcludeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExpansionProfileDesignationExcludeListEnumerator.GetCurrent : TFhirExpansionProfileDesignationExclude;
begin
  Result := FList[FIndex];
end;

function TFhirExpansionProfileDesignationExcludeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExpansionProfileDesignationExcludeList }
procedure TFhirExpansionProfileDesignationExcludeList.AddItem(value: TFhirExpansionProfileDesignationExclude);
begin
  assert(value.ClassName = 'TFhirExpansionProfileDesignationExclude', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExpansionProfileDesignationExclude');
  add(value);
end;

function TFhirExpansionProfileDesignationExcludeList.Append: TFhirExpansionProfileDesignationExclude;
begin
  result := TFhirExpansionProfileDesignationExclude.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExpansionProfileDesignationExcludeList.ClearItems;
begin
  Clear;
end;

function TFhirExpansionProfileDesignationExcludeList.GetEnumerator : TFhirExpansionProfileDesignationExcludeListEnumerator;
begin
  result := TFhirExpansionProfileDesignationExcludeListEnumerator.Create(self.link);
end;

function TFhirExpansionProfileDesignationExcludeList.Clone: TFhirExpansionProfileDesignationExcludeList;
begin
  result := TFhirExpansionProfileDesignationExcludeList(inherited Clone);
end;

function TFhirExpansionProfileDesignationExcludeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExpansionProfileDesignationExcludeList.GetItemN(index: Integer): TFhirExpansionProfileDesignationExclude;
begin
  result := TFhirExpansionProfileDesignationExclude(ObjectByIndex[index]);
end;

function TFhirExpansionProfileDesignationExcludeList.ItemClass: TFslObjectClass;
begin
  result := TFhirExpansionProfileDesignationExclude;
end;
function TFhirExpansionProfileDesignationExcludeList.IndexOf(value: TFhirExpansionProfileDesignationExclude): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExpansionProfileDesignationExcludeList.Insert(index: Integer): TFhirExpansionProfileDesignationExclude;
begin
  result := TFhirExpansionProfileDesignationExclude.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExpansionProfileDesignationExcludeList.InsertItem(index: Integer; value: TFhirExpansionProfileDesignationExclude);
begin
  assert(value is TFhirExpansionProfileDesignationExclude);
  Inherited Insert(index, value);
end;

function TFhirExpansionProfileDesignationExcludeList.Item(index: Integer): TFhirExpansionProfileDesignationExclude;
begin
  result := TFhirExpansionProfileDesignationExclude(ObjectByIndex[index]);
end;

function TFhirExpansionProfileDesignationExcludeList.Link: TFhirExpansionProfileDesignationExcludeList;
begin
  result := TFhirExpansionProfileDesignationExcludeList(inherited Link);
end;

procedure TFhirExpansionProfileDesignationExcludeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExpansionProfileDesignationExcludeList.SetItemByIndex(index: Integer; value: TFhirExpansionProfileDesignationExclude);
begin
  assert(value is TFhirExpansionProfileDesignationExclude);
  FhirExpansionProfileDesignationExcludes[index] := value;
end;

procedure TFhirExpansionProfileDesignationExcludeList.SetItemN(index: Integer; value: TFhirExpansionProfileDesignationExclude);
begin
  assert(value is TFhirExpansionProfileDesignationExclude);
  ObjectByIndex[index] := value;
end;

{ TFhirExpansionProfileDesignationExcludeDesignation }

constructor TFhirExpansionProfileDesignationExcludeDesignation.Create;
begin
  inherited;
end;

destructor TFhirExpansionProfileDesignationExcludeDesignation.Destroy;
begin
  FLanguage.free;
  FUse.free;
  inherited;
end;

procedure TFhirExpansionProfileDesignationExcludeDesignation.Assign(oSource : TFslObject);
begin
  inherited;
  languageElement := TFhirExpansionProfileDesignationExcludeDesignation(oSource).languageElement.Clone;
  use := TFhirExpansionProfileDesignationExcludeDesignation(oSource).use.Clone;
end;

procedure TFhirExpansionProfileDesignationExcludeDesignation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'language') Then
     list.add(self.link, 'language', FLanguage.Link);
  if (child_name = 'use') Then
     list.add(self.link, 'use', FUse.Link);
end;

procedure TFhirExpansionProfileDesignationExcludeDesignation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'language', 'code', false, TFhirCode, FLanguage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'use', 'Coding', false, TFhirCoding, FUse.Link));{2}
end;

function TFhirExpansionProfileDesignationExcludeDesignation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'language') then
  begin
    LanguageElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'use') then
  begin
    Use := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirExpansionProfileDesignationExcludeDesignation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirExpansionProfileDesignationExcludeDesignation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'language') then result := TFhirCode.create() {5b}
  else if (propName = 'use') then result := TFhirCoding.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExpansionProfileDesignationExcludeDesignation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'language') then result := 'code'
  else if (propName = 'use') then result := 'Coding'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExpansionProfileDesignationExcludeDesignation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'language') then LanguageElement := nil
  else if (propName = 'use') then UseElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExpansionProfileDesignationExcludeDesignation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'language') then LanguageElement := asCode(new){5b}
  else if (propName = 'use') then UseElement := new as TFhirCoding{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExpansionProfileDesignationExcludeDesignation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirExpansionProfileDesignationExcludeDesignation.fhirType : string;
begin
  result := 'designation';
end;

function TFhirExpansionProfileDesignationExcludeDesignation.Link : TFhirExpansionProfileDesignationExcludeDesignation;
begin
  result := TFhirExpansionProfileDesignationExcludeDesignation(inherited Link);
end;

function TFhirExpansionProfileDesignationExcludeDesignation.Clone : TFhirExpansionProfileDesignationExcludeDesignation;
begin
  result := TFhirExpansionProfileDesignationExcludeDesignation(inherited Clone);
end;

function TFhirExpansionProfileDesignationExcludeDesignation.equals(other : TObject) : boolean;
var
  o : TFhirExpansionProfileDesignationExcludeDesignation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExpansionProfileDesignationExcludeDesignation)) then
    result := false
  else
  begin
    o := TFhirExpansionProfileDesignationExcludeDesignation(other);
    result := compareDeep(languageElement, o.languageElement, true) and compareDeep(useElement, o.useElement, true);
  end;
end;

function TFhirExpansionProfileDesignationExcludeDesignation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLanguage) and isEmptyProp(FUse);
end;

procedure TFhirExpansionProfileDesignationExcludeDesignation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('language');
  fields.add('use');
end;

{ TFhirExpansionProfileDesignationExcludeDesignation }

Procedure TFhirExpansionProfileDesignationExcludeDesignation.SetLanguage(value : TFhirCode);
begin
  FLanguage.free;
  FLanguage := value;
end;

Function TFhirExpansionProfileDesignationExcludeDesignation.GetLanguageST : String;
begin
  if FLanguage = nil then
    result := ''
  else
    result := FLanguage.value;
end;

Procedure TFhirExpansionProfileDesignationExcludeDesignation.SetLanguageST(value : String);
begin
  if value <> '' then
  begin
    if FLanguage = nil then
      FLanguage := TFhirCode.create;
    FLanguage.value := value
  end
  else if FLanguage <> nil then
    FLanguage.value := '';
end;

Procedure TFhirExpansionProfileDesignationExcludeDesignation.SetUse(value : TFhirCoding);
begin
  FUse.free;
  FUse := value;
end;

function TFhirExpansionProfileDesignationExcludeDesignation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FLanguage.sizeInBytes);
  inc(result, FUse.sizeInBytes);
end;

{ TFhirExpansionProfileDesignationExcludeDesignationListEnumerator }

Constructor TFhirExpansionProfileDesignationExcludeDesignationListEnumerator.Create(list : TFhirExpansionProfileDesignationExcludeDesignationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExpansionProfileDesignationExcludeDesignationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExpansionProfileDesignationExcludeDesignationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExpansionProfileDesignationExcludeDesignationListEnumerator.GetCurrent : TFhirExpansionProfileDesignationExcludeDesignation;
begin
  Result := FList[FIndex];
end;

function TFhirExpansionProfileDesignationExcludeDesignationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExpansionProfileDesignationExcludeDesignationList }
procedure TFhirExpansionProfileDesignationExcludeDesignationList.AddItem(value: TFhirExpansionProfileDesignationExcludeDesignation);
begin
  assert(value.ClassName = 'TFhirExpansionProfileDesignationExcludeDesignation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExpansionProfileDesignationExcludeDesignation');
  add(value);
end;

function TFhirExpansionProfileDesignationExcludeDesignationList.Append: TFhirExpansionProfileDesignationExcludeDesignation;
begin
  result := TFhirExpansionProfileDesignationExcludeDesignation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExpansionProfileDesignationExcludeDesignationList.ClearItems;
begin
  Clear;
end;

function TFhirExpansionProfileDesignationExcludeDesignationList.GetEnumerator : TFhirExpansionProfileDesignationExcludeDesignationListEnumerator;
begin
  result := TFhirExpansionProfileDesignationExcludeDesignationListEnumerator.Create(self.link);
end;

function TFhirExpansionProfileDesignationExcludeDesignationList.Clone: TFhirExpansionProfileDesignationExcludeDesignationList;
begin
  result := TFhirExpansionProfileDesignationExcludeDesignationList(inherited Clone);
end;

function TFhirExpansionProfileDesignationExcludeDesignationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExpansionProfileDesignationExcludeDesignationList.GetItemN(index: Integer): TFhirExpansionProfileDesignationExcludeDesignation;
begin
  result := TFhirExpansionProfileDesignationExcludeDesignation(ObjectByIndex[index]);
end;

function TFhirExpansionProfileDesignationExcludeDesignationList.ItemClass: TFslObjectClass;
begin
  result := TFhirExpansionProfileDesignationExcludeDesignation;
end;
function TFhirExpansionProfileDesignationExcludeDesignationList.IndexOf(value: TFhirExpansionProfileDesignationExcludeDesignation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExpansionProfileDesignationExcludeDesignationList.Insert(index: Integer): TFhirExpansionProfileDesignationExcludeDesignation;
begin
  result := TFhirExpansionProfileDesignationExcludeDesignation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExpansionProfileDesignationExcludeDesignationList.InsertItem(index: Integer; value: TFhirExpansionProfileDesignationExcludeDesignation);
begin
  assert(value is TFhirExpansionProfileDesignationExcludeDesignation);
  Inherited Insert(index, value);
end;

function TFhirExpansionProfileDesignationExcludeDesignationList.Item(index: Integer): TFhirExpansionProfileDesignationExcludeDesignation;
begin
  result := TFhirExpansionProfileDesignationExcludeDesignation(ObjectByIndex[index]);
end;

function TFhirExpansionProfileDesignationExcludeDesignationList.Link: TFhirExpansionProfileDesignationExcludeDesignationList;
begin
  result := TFhirExpansionProfileDesignationExcludeDesignationList(inherited Link);
end;

procedure TFhirExpansionProfileDesignationExcludeDesignationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExpansionProfileDesignationExcludeDesignationList.SetItemByIndex(index: Integer; value: TFhirExpansionProfileDesignationExcludeDesignation);
begin
  assert(value is TFhirExpansionProfileDesignationExcludeDesignation);
  FhirExpansionProfileDesignationExcludeDesignations[index] := value;
end;

procedure TFhirExpansionProfileDesignationExcludeDesignationList.SetItemN(index: Integer; value: TFhirExpansionProfileDesignationExcludeDesignation);
begin
  assert(value is TFhirExpansionProfileDesignationExcludeDesignation);
  ObjectByIndex[index] := value;
end;

{ TFhirExpansionProfile }

constructor TFhirExpansionProfile.Create;
begin
  inherited;
end;

destructor TFhirExpansionProfile.Destroy;
begin
  FIdentifier.free;
  FFixedVersionList.Free;
  FExcludedSystem.free;
  FIncludeDesignations.free;
  FDesignation.free;
  FIncludeDefinition.free;
  FActiveOnly.free;
  FExcludeNested.free;
  FExcludeNotForUI.free;
  FExcludePostCoordinated.free;
  FDisplayLanguage.free;
  FLimitedExpansion.free;
  inherited;
end;

function TFhirExpansionProfile.GetResourceType : TFhirResourceType;
begin
  result := frtExpansionProfile;
end;

procedure TFhirExpansionProfile.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirExpansionProfile(oSource).identifier.Clone;
  if (TFhirExpansionProfile(oSource).FFixedVersionList = nil) then
  begin
    FFixedVersionList.free;
    FFixedVersionList := nil;
  end
  else
  begin
    if FFixedVersionList = nil then
      FFixedVersionList := TFhirExpansionProfileFixedVersionList.Create;
    FFixedVersionList.Assign(TFhirExpansionProfile(oSource).FFixedVersionList);
  end;
  excludedSystem := TFhirExpansionProfile(oSource).excludedSystem.Clone;
  includeDesignationsElement := TFhirExpansionProfile(oSource).includeDesignationsElement.Clone;
  designation := TFhirExpansionProfile(oSource).designation.Clone;
  includeDefinitionElement := TFhirExpansionProfile(oSource).includeDefinitionElement.Clone;
  activeOnlyElement := TFhirExpansionProfile(oSource).activeOnlyElement.Clone;
  excludeNestedElement := TFhirExpansionProfile(oSource).excludeNestedElement.Clone;
  excludeNotForUIElement := TFhirExpansionProfile(oSource).excludeNotForUIElement.Clone;
  excludePostCoordinatedElement := TFhirExpansionProfile(oSource).excludePostCoordinatedElement.Clone;
  displayLanguageElement := TFhirExpansionProfile(oSource).displayLanguageElement.Clone;
  limitedExpansionElement := TFhirExpansionProfile(oSource).limitedExpansionElement.Clone;
end;

procedure TFhirExpansionProfile.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'fixedVersion') Then
    list.addAll(self, 'fixedVersion', FFixedVersionList);
  if (child_name = 'excludedSystem') Then
     list.add(self.link, 'excludedSystem', FExcludedSystem.Link);
  if (child_name = 'includeDesignations') Then
     list.add(self.link, 'includeDesignations', FIncludeDesignations.Link);
  if (child_name = 'designation') Then
     list.add(self.link, 'designation', FDesignation.Link);
  if (child_name = 'includeDefinition') Then
     list.add(self.link, 'includeDefinition', FIncludeDefinition.Link);
  if (child_name = 'activeOnly') Then
     list.add(self.link, 'activeOnly', FActiveOnly.Link);
  if (child_name = 'excludeNested') Then
     list.add(self.link, 'excludeNested', FExcludeNested.Link);
  if (child_name = 'excludeNotForUI') Then
     list.add(self.link, 'excludeNotForUI', FExcludeNotForUI.Link);
  if (child_name = 'excludePostCoordinated') Then
     list.add(self.link, 'excludePostCoordinated', FExcludePostCoordinated.Link);
  if (child_name = 'displayLanguage') Then
     list.add(self.link, 'displayLanguage', FDisplayLanguage.Link);
  if (child_name = 'limitedExpansion') Then
     list.add(self.link, 'limitedExpansion', FLimitedExpansion.Link);
end;

procedure TFhirExpansionProfile.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'fixedVersion', '', true, TFhirExpansionProfileFixedVersion, FFixedVersionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'excludedSystem', '', false, TFhirExpansionProfileExcludedSystem, FExcludedSystem.Link));{2}
  oList.add(TFHIRProperty.create(self, 'includeDesignations', 'boolean', false, TFhirBoolean, FIncludeDesignations.Link));{2}
  oList.add(TFHIRProperty.create(self, 'designation', '', false, TFhirExpansionProfileDesignation, FDesignation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'includeDefinition', 'boolean', false, TFhirBoolean, FIncludeDefinition.Link));{2}
  oList.add(TFHIRProperty.create(self, 'activeOnly', 'boolean', false, TFhirBoolean, FActiveOnly.Link));{2}
  oList.add(TFHIRProperty.create(self, 'excludeNested', 'boolean', false, TFhirBoolean, FExcludeNested.Link));{2}
  oList.add(TFHIRProperty.create(self, 'excludeNotForUI', 'boolean', false, TFhirBoolean, FExcludeNotForUI.Link));{2}
  oList.add(TFHIRProperty.create(self, 'excludePostCoordinated', 'boolean', false, TFhirBoolean, FExcludePostCoordinated.Link));{2}
  oList.add(TFHIRProperty.create(self, 'displayLanguage', 'code', false, TFhirCode, FDisplayLanguage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'limitedExpansion', 'boolean', false, TFhirBoolean, FLimitedExpansion.Link));{2}
end;

function TFhirExpansionProfile.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'fixedVersion') then
  begin
    FixedVersionList.add(propValue as TFhirExpansionProfileFixedVersion){2a};
    result := propValue;
  end
  else if (propName = 'excludedSystem') then
  begin
    ExcludedSystem := propValue as TFhirExpansionProfileExcludedSystem{4b};
    result := propValue;
  end
  else if (propName = 'includeDesignations') then
  begin
    IncludeDesignationsElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'designation') then
  begin
    Designation := propValue as TFhirExpansionProfileDesignation{4b};
    result := propValue;
  end
  else if (propName = 'includeDefinition') then
  begin
    IncludeDefinitionElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'activeOnly') then
  begin
    ActiveOnlyElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'excludeNested') then
  begin
    ExcludeNestedElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'excludeNotForUI') then
  begin
    ExcludeNotForUIElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'excludePostCoordinated') then
  begin
    ExcludePostCoordinatedElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'displayLanguage') then
  begin
    DisplayLanguageElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'limitedExpansion') then
  begin
    LimitedExpansionElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirExpansionProfile.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'fixedVersion') then FixedVersionList.insertItem(index, propValue as TFhirExpansionProfileFixedVersion){2a}
  else inherited;
end;

function TFhirExpansionProfile.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'fixedVersion') then result := FixedVersionList.new(){2}
  else if (propName = 'excludedSystem') then result := TFhirExpansionProfileExcludedSystem.create(){4b}
  else if (propName = 'includeDesignations') then result := TFhirBoolean.create() {5b}
  else if (propName = 'designation') then result := TFhirExpansionProfileDesignation.create(){4b}
  else if (propName = 'includeDefinition') then result := TFhirBoolean.create() {5b}
  else if (propName = 'activeOnly') then result := TFhirBoolean.create() {5b}
  else if (propName = 'excludeNested') then result := TFhirBoolean.create() {5b}
  else if (propName = 'excludeNotForUI') then result := TFhirBoolean.create() {5b}
  else if (propName = 'excludePostCoordinated') then result := TFhirBoolean.create() {5b}
  else if (propName = 'displayLanguage') then result := TFhirCode.create() {5b}
  else if (propName = 'limitedExpansion') then result := TFhirBoolean.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirExpansionProfile.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'fixedVersion') then result := ''
  else if (propName = 'excludedSystem') then result := ''
  else if (propName = 'includeDesignations') then result := 'boolean'
  else if (propName = 'designation') then result := ''
  else if (propName = 'includeDefinition') then result := 'boolean'
  else if (propName = 'activeOnly') then result := 'boolean'
  else if (propName = 'excludeNested') then result := 'boolean'
  else if (propName = 'excludeNotForUI') then result := 'boolean'
  else if (propName = 'excludePostCoordinated') then result := 'boolean'
  else if (propName = 'displayLanguage') then result := 'code'
  else if (propName = 'limitedExpansion') then result := 'boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirExpansionProfile.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'fixedVersion') then deletePropertyValue('fixedVersion', FixedVersionList, value) {2}
  else if (propName = 'excludedSystem') then ExcludedSystemElement := nil
  else if (propName = 'includeDesignations') then IncludeDesignationsElement := nil
  else if (propName = 'designation') then DesignationElement := nil
  else if (propName = 'includeDefinition') then IncludeDefinitionElement := nil
  else if (propName = 'activeOnly') then ActiveOnlyElement := nil
  else if (propName = 'excludeNested') then ExcludeNestedElement := nil
  else if (propName = 'excludeNotForUI') then ExcludeNotForUIElement := nil
  else if (propName = 'excludePostCoordinated') then ExcludePostCoordinatedElement := nil
  else if (propName = 'displayLanguage') then DisplayLanguageElement := nil
  else if (propName = 'limitedExpansion') then LimitedExpansionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirExpansionProfile.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'fixedVersion') then replacePropertyValue('fixedVersion', FixedVersionList, existing, new) {2}
  else if (propName = 'excludedSystem') then ExcludedSystemElement := new as TFhirExpansionProfileExcludedSystem{4}
  else if (propName = 'includeDesignations') then IncludeDesignationsElement := asBoolean(new){5b}
  else if (propName = 'designation') then DesignationElement := new as TFhirExpansionProfileDesignation{4}
  else if (propName = 'includeDefinition') then IncludeDefinitionElement := asBoolean(new){5b}
  else if (propName = 'activeOnly') then ActiveOnlyElement := asBoolean(new){5b}
  else if (propName = 'excludeNested') then ExcludeNestedElement := asBoolean(new){5b}
  else if (propName = 'excludeNotForUI') then ExcludeNotForUIElement := asBoolean(new){5b}
  else if (propName = 'excludePostCoordinated') then ExcludePostCoordinatedElement := asBoolean(new){5b}
  else if (propName = 'displayLanguage') then DisplayLanguageElement := asCode(new){5b}
  else if (propName = 'limitedExpansion') then LimitedExpansionElement := asBoolean(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirExpansionProfile.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'fixedVersion') then FixedVersionList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirExpansionProfile.fhirType : string;
begin
  result := 'ExpansionProfile';
end;

function TFhirExpansionProfile.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FfixedVersionList) and isEmptyProp(FExcludedSystem) and isEmptyProp(FIncludeDesignations) and isEmptyProp(FDesignation) and isEmptyProp(FIncludeDefinition) and isEmptyProp(FActiveOnly) and isEmptyProp(FExcludeNested) and isEmptyProp(FExcludeNotForUI) and isEmptyProp(FExcludePostCoordinated) and isEmptyProp(FDisplayLanguage) and isEmptyProp(FLimitedExpansion);
end;

function TFhirExpansionProfile.equals(other : TObject) : boolean;
var
  o : TFhirExpansionProfile;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirExpansionProfile)) then
    result := false
  else
  begin
    o := TFhirExpansionProfile(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(fixedVersionList, o.fixedVersionList, true) and
      compareDeep(excludedSystemElement, o.excludedSystemElement, true) and compareDeep(includeDesignationsElement, o.includeDesignationsElement, true) and
      compareDeep(designationElement, o.designationElement, true) and compareDeep(includeDefinitionElement, o.includeDefinitionElement, true) and
      compareDeep(activeOnlyElement, o.activeOnlyElement, true) and compareDeep(excludeNestedElement, o.excludeNestedElement, true) and
      compareDeep(excludeNotForUIElement, o.excludeNotForUIElement, true) and compareDeep(excludePostCoordinatedElement, o.excludePostCoordinatedElement, true) and
      compareDeep(displayLanguageElement, o.displayLanguageElement, true) and compareDeep(limitedExpansionElement, o.limitedExpansionElement, true);
  end;
end;

function TFhirExpansionProfile.Link : TFhirExpansionProfile;
begin
  result := TFhirExpansionProfile(inherited Link);
end;

function TFhirExpansionProfile.Clone : TFhirExpansionProfile;
begin
  result := TFhirExpansionProfile(inherited Clone);
end;

procedure TFhirExpansionProfile.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('status');
  fields.add('experimental');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('fixedVersion');
  fields.add('excludedSystem');
  fields.add('includeDesignations');
  fields.add('designation');
  fields.add('includeDefinition');
  fields.add('activeOnly');
  fields.add('excludeNested');
  fields.add('excludeNotForUI');
  fields.add('excludePostCoordinated');
  fields.add('displayLanguage');
  fields.add('limitedExpansion');
end;

{ TFhirExpansionProfile }

Procedure TFhirExpansionProfile.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Function TFhirExpansionProfile.GetFixedVersionList : TFhirExpansionProfileFixedVersionList;
begin
  if FFixedVersionList = nil then
    FFixedVersionList := TFhirExpansionProfileFixedVersionList.Create;
  result := FFixedVersionList;
end;

Function TFhirExpansionProfile.GetHasFixedVersionList : boolean;
begin
  result := (FFixedVersionList <> nil) and (FFixedVersionList.count > 0);
end;

Procedure TFhirExpansionProfile.SetExcludedSystem(value : TFhirExpansionProfileExcludedSystem);
begin
  FExcludedSystem.free;
  FExcludedSystem := value;
end;

Procedure TFhirExpansionProfile.SetIncludeDesignations(value : TFhirBoolean);
begin
  FIncludeDesignations.free;
  FIncludeDesignations := value;
end;

Function TFhirExpansionProfile.GetIncludeDesignationsST : Boolean;
begin
  if FIncludeDesignations = nil then
    result := false
  else
    result := FIncludeDesignations.value;
end;

Procedure TFhirExpansionProfile.SetIncludeDesignationsST(value : Boolean);
begin
  if FIncludeDesignations = nil then
    FIncludeDesignations := TFhirBoolean.create;
  FIncludeDesignations.value := value
end;

Procedure TFhirExpansionProfile.SetDesignation(value : TFhirExpansionProfileDesignation);
begin
  FDesignation.free;
  FDesignation := value;
end;

Procedure TFhirExpansionProfile.SetIncludeDefinition(value : TFhirBoolean);
begin
  FIncludeDefinition.free;
  FIncludeDefinition := value;
end;

Function TFhirExpansionProfile.GetIncludeDefinitionST : Boolean;
begin
  if FIncludeDefinition = nil then
    result := false
  else
    result := FIncludeDefinition.value;
end;

Procedure TFhirExpansionProfile.SetIncludeDefinitionST(value : Boolean);
begin
  if FIncludeDefinition = nil then
    FIncludeDefinition := TFhirBoolean.create;
  FIncludeDefinition.value := value
end;

Procedure TFhirExpansionProfile.SetActiveOnly(value : TFhirBoolean);
begin
  FActiveOnly.free;
  FActiveOnly := value;
end;

Function TFhirExpansionProfile.GetActiveOnlyST : Boolean;
begin
  if FActiveOnly = nil then
    result := false
  else
    result := FActiveOnly.value;
end;

Procedure TFhirExpansionProfile.SetActiveOnlyST(value : Boolean);
begin
  if FActiveOnly = nil then
    FActiveOnly := TFhirBoolean.create;
  FActiveOnly.value := value
end;

Procedure TFhirExpansionProfile.SetExcludeNested(value : TFhirBoolean);
begin
  FExcludeNested.free;
  FExcludeNested := value;
end;

Function TFhirExpansionProfile.GetExcludeNestedST : Boolean;
begin
  if FExcludeNested = nil then
    result := false
  else
    result := FExcludeNested.value;
end;

Procedure TFhirExpansionProfile.SetExcludeNestedST(value : Boolean);
begin
  if FExcludeNested = nil then
    FExcludeNested := TFhirBoolean.create;
  FExcludeNested.value := value
end;

Procedure TFhirExpansionProfile.SetExcludeNotForUI(value : TFhirBoolean);
begin
  FExcludeNotForUI.free;
  FExcludeNotForUI := value;
end;

Function TFhirExpansionProfile.GetExcludeNotForUIST : Boolean;
begin
  if FExcludeNotForUI = nil then
    result := false
  else
    result := FExcludeNotForUI.value;
end;

Procedure TFhirExpansionProfile.SetExcludeNotForUIST(value : Boolean);
begin
  if FExcludeNotForUI = nil then
    FExcludeNotForUI := TFhirBoolean.create;
  FExcludeNotForUI.value := value
end;

Procedure TFhirExpansionProfile.SetExcludePostCoordinated(value : TFhirBoolean);
begin
  FExcludePostCoordinated.free;
  FExcludePostCoordinated := value;
end;

Function TFhirExpansionProfile.GetExcludePostCoordinatedST : Boolean;
begin
  if FExcludePostCoordinated = nil then
    result := false
  else
    result := FExcludePostCoordinated.value;
end;

Procedure TFhirExpansionProfile.SetExcludePostCoordinatedST(value : Boolean);
begin
  if FExcludePostCoordinated = nil then
    FExcludePostCoordinated := TFhirBoolean.create;
  FExcludePostCoordinated.value := value
end;

Procedure TFhirExpansionProfile.SetDisplayLanguage(value : TFhirCode);
begin
  FDisplayLanguage.free;
  FDisplayLanguage := value;
end;

Function TFhirExpansionProfile.GetDisplayLanguageST : String;
begin
  if FDisplayLanguage = nil then
    result := ''
  else
    result := FDisplayLanguage.value;
end;

Procedure TFhirExpansionProfile.SetDisplayLanguageST(value : String);
begin
  if value <> '' then
  begin
    if FDisplayLanguage = nil then
      FDisplayLanguage := TFhirCode.create;
    FDisplayLanguage.value := value
  end
  else if FDisplayLanguage <> nil then
    FDisplayLanguage.value := '';
end;

Procedure TFhirExpansionProfile.SetLimitedExpansion(value : TFhirBoolean);
begin
  FLimitedExpansion.free;
  FLimitedExpansion := value;
end;

Function TFhirExpansionProfile.GetLimitedExpansionST : Boolean;
begin
  if FLimitedExpansion = nil then
    result := false
  else
    result := FLimitedExpansion.value;
end;

Procedure TFhirExpansionProfile.SetLimitedExpansionST(value : Boolean);
begin
  if FLimitedExpansion = nil then
    FLimitedExpansion := TFhirBoolean.create;
  FLimitedExpansion.value := value
end;

function TFhirExpansionProfile.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FfixedVersionList.sizeInBytes);
  inc(result, FExcludedSystem.sizeInBytes);
  inc(result, FIncludeDesignations.sizeInBytes);
  inc(result, FDesignation.sizeInBytes);
  inc(result, FIncludeDefinition.sizeInBytes);
  inc(result, FActiveOnly.sizeInBytes);
  inc(result, FExcludeNested.sizeInBytes);
  inc(result, FExcludeNotForUI.sizeInBytes);
  inc(result, FExcludePostCoordinated.sizeInBytes);
  inc(result, FDisplayLanguage.sizeInBytes);
  inc(result, FLimitedExpansion.sizeInBytes);
end;

{ TFhirExpansionProfileListEnumerator }

Constructor TFhirExpansionProfileListEnumerator.Create(list : TFhirExpansionProfileList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirExpansionProfileListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirExpansionProfileListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirExpansionProfileListEnumerator.GetCurrent : TFhirExpansionProfile;
begin
  Result := FList[FIndex];
end;

function TFhirExpansionProfileListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirExpansionProfileList }
procedure TFhirExpansionProfileList.AddItem(value: TFhirExpansionProfile);
begin
  assert(value.ClassName = 'TFhirExpansionProfile', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirExpansionProfile');
  add(value);
end;

function TFhirExpansionProfileList.Append: TFhirExpansionProfile;
begin
  result := TFhirExpansionProfile.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExpansionProfileList.ClearItems;
begin
  Clear;
end;

function TFhirExpansionProfileList.GetEnumerator : TFhirExpansionProfileListEnumerator;
begin
  result := TFhirExpansionProfileListEnumerator.Create(self.link);
end;

function TFhirExpansionProfileList.Clone: TFhirExpansionProfileList;
begin
  result := TFhirExpansionProfileList(inherited Clone);
end;

function TFhirExpansionProfileList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirExpansionProfileList.GetItemN(index: Integer): TFhirExpansionProfile;
begin
  result := TFhirExpansionProfile(ObjectByIndex[index]);
end;

function TFhirExpansionProfileList.ItemClass: TFslObjectClass;
begin
  result := TFhirExpansionProfile;
end;
function TFhirExpansionProfileList.IndexOf(value: TFhirExpansionProfile): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirExpansionProfileList.Insert(index: Integer): TFhirExpansionProfile;
begin
  result := TFhirExpansionProfile.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirExpansionProfileList.InsertItem(index: Integer; value: TFhirExpansionProfile);
begin
  assert(value is TFhirExpansionProfile);
  Inherited Insert(index, value);
end;

function TFhirExpansionProfileList.Item(index: Integer): TFhirExpansionProfile;
begin
  result := TFhirExpansionProfile(ObjectByIndex[index]);
end;

function TFhirExpansionProfileList.Link: TFhirExpansionProfileList;
begin
  result := TFhirExpansionProfileList(inherited Link);
end;

procedure TFhirExpansionProfileList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirExpansionProfileList.SetItemByIndex(index: Integer; value: TFhirExpansionProfile);
begin
  assert(value is TFhirExpansionProfile);
  FhirExpansionProfiles[index] := value;
end;

procedure TFhirExpansionProfileList.SetItemN(index: Integer; value: TFhirExpansionProfile);
begin
  assert(value is TFhirExpansionProfile);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_EXPANSIONPROFILE}

{$IFDEF FHIR_GRAPHDEFINITION}

{ TFhirGraphDefinitionLink }

constructor TFhirGraphDefinitionLink.Create;
begin
  inherited;
end;

destructor TFhirGraphDefinitionLink.Destroy;
begin
  FPath.free;
  FSliceName.free;
  FMin.free;
  FMax.free;
  FDescription.free;
  FTargetList.Free;
  inherited;
end;

procedure TFhirGraphDefinitionLink.Assign(oSource : TFslObject);
begin
  inherited;
  pathElement := TFhirGraphDefinitionLink(oSource).pathElement.Clone;
  sliceNameElement := TFhirGraphDefinitionLink(oSource).sliceNameElement.Clone;
  minElement := TFhirGraphDefinitionLink(oSource).minElement.Clone;
  maxElement := TFhirGraphDefinitionLink(oSource).maxElement.Clone;
  descriptionElement := TFhirGraphDefinitionLink(oSource).descriptionElement.Clone;
  if (TFhirGraphDefinitionLink(oSource).FTargetList = nil) then
  begin
    FTargetList.free;
    FTargetList := nil;
  end
  else
  begin
    if FTargetList = nil then
      FTargetList := TFhirGraphDefinitionLinkTargetList.Create;
    FTargetList.Assign(TFhirGraphDefinitionLink(oSource).FTargetList);
  end;
end;

procedure TFhirGraphDefinitionLink.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'path') Then
     list.add(self.link, 'path', FPath.Link);
  if (child_name = 'sliceName') Then
     list.add(self.link, 'sliceName', FSliceName.Link);
  if (child_name = 'min') Then
     list.add(self.link, 'min', FMin.Link);
  if (child_name = 'max') Then
     list.add(self.link, 'max', FMax.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'target') Then
    list.addAll(self, 'target', FTargetList);
end;

procedure TFhirGraphDefinitionLink.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'path', 'string', false, TFhirString, FPath.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sliceName', 'string', false, TFhirString, FSliceName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'min', 'integer', false, TFhirInteger, FMin.Link));{2}
  oList.add(TFHIRProperty.create(self, 'max', 'string', false, TFhirString, FMax.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'target', '', true, TFhirGraphDefinitionLinkTarget, FTargetList.Link)){3};
end;

function TFhirGraphDefinitionLink.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'path') then
  begin
    PathElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'sliceName') then
  begin
    SliceNameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'min') then
  begin
    MinElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'max') then
  begin
    MaxElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'target') then
  begin
    TargetList.add(propValue as TFhirGraphDefinitionLinkTarget){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirGraphDefinitionLink.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'target') then TargetList.insertItem(index, propValue as TFhirGraphDefinitionLinkTarget){2a}
  else inherited;
end;

function TFhirGraphDefinitionLink.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'path') then result := TFhirString.create() {5b}
  else if (propName = 'sliceName') then result := TFhirString.create() {5b}
  else if (propName = 'min') then result := TFhirInteger.create() {5b}
  else if (propName = 'max') then result := TFhirString.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'target') then result := TargetList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirGraphDefinitionLink.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'path') then result := 'string'
  else if (propName = 'sliceName') then result := 'string'
  else if (propName = 'min') then result := 'integer'
  else if (propName = 'max') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'target') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirGraphDefinitionLink.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'path') then PathElement := nil
  else if (propName = 'sliceName') then SliceNameElement := nil
  else if (propName = 'min') then MinElement := nil
  else if (propName = 'max') then MaxElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'target') then deletePropertyValue('target', TargetList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirGraphDefinitionLink.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'path') then PathElement := asString(new){5b}
  else if (propName = 'sliceName') then SliceNameElement := asString(new){5b}
  else if (propName = 'min') then MinElement := asInteger(new){5b}
  else if (propName = 'max') then MaxElement := asString(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'target') then replacePropertyValue('target', TargetList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirGraphDefinitionLink.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'target') then TargetList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirGraphDefinitionLink.fhirType : string;
begin
  result := 'link';
end;

function TFhirGraphDefinitionLink.Link : TFhirGraphDefinitionLink;
begin
  result := TFhirGraphDefinitionLink(inherited Link);
end;

function TFhirGraphDefinitionLink.Clone : TFhirGraphDefinitionLink;
begin
  result := TFhirGraphDefinitionLink(inherited Clone);
end;

function TFhirGraphDefinitionLink.equals(other : TObject) : boolean;
var
  o : TFhirGraphDefinitionLink;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirGraphDefinitionLink)) then
    result := false
  else
  begin
    o := TFhirGraphDefinitionLink(other);
    result := compareDeep(pathElement, o.pathElement, true) and compareDeep(sliceNameElement, o.sliceNameElement, true) and
      compareDeep(minElement, o.minElement, true) and compareDeep(maxElement, o.maxElement, true) and
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(targetList, o.targetList, true);
  end;
end;

function TFhirGraphDefinitionLink.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPath) and isEmptyProp(FSliceName) and isEmptyProp(FMin) and isEmptyProp(FMax) and isEmptyProp(FDescription) and isEmptyProp(FtargetList);
end;

procedure TFhirGraphDefinitionLink.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('path');
  fields.add('sliceName');
  fields.add('min');
  fields.add('max');
  fields.add('description');
  fields.add('target');
end;

{ TFhirGraphDefinitionLink }

Procedure TFhirGraphDefinitionLink.SetPath(value : TFhirString);
begin
  FPath.free;
  FPath := value;
end;

Function TFhirGraphDefinitionLink.GetPathST : String;
begin
  if FPath = nil then
    result := ''
  else
    result := FPath.value;
end;

Procedure TFhirGraphDefinitionLink.SetPathST(value : String);
begin
  if value <> '' then
  begin
    if FPath = nil then
      FPath := TFhirString.create;
    FPath.value := value
  end
  else if FPath <> nil then
    FPath.value := '';
end;

Procedure TFhirGraphDefinitionLink.SetSliceName(value : TFhirString);
begin
  FSliceName.free;
  FSliceName := value;
end;

Function TFhirGraphDefinitionLink.GetSliceNameST : String;
begin
  if FSliceName = nil then
    result := ''
  else
    result := FSliceName.value;
end;

Procedure TFhirGraphDefinitionLink.SetSliceNameST(value : String);
begin
  if value <> '' then
  begin
    if FSliceName = nil then
      FSliceName := TFhirString.create;
    FSliceName.value := value
  end
  else if FSliceName <> nil then
    FSliceName.value := '';
end;

Procedure TFhirGraphDefinitionLink.SetMin(value : TFhirInteger);
begin
  FMin.free;
  FMin := value;
end;

Function TFhirGraphDefinitionLink.GetMinST : String;
begin
  if FMin = nil then
    result := ''
  else
    result := FMin.value;
end;

Procedure TFhirGraphDefinitionLink.SetMinST(value : String);
begin
  if value <> '' then
  begin
    if FMin = nil then
      FMin := TFhirInteger.create;
    FMin.value := value
  end
  else if FMin <> nil then
    FMin.value := '';
end;

Procedure TFhirGraphDefinitionLink.SetMax(value : TFhirString);
begin
  FMax.free;
  FMax := value;
end;

Function TFhirGraphDefinitionLink.GetMaxST : String;
begin
  if FMax = nil then
    result := ''
  else
    result := FMax.value;
end;

Procedure TFhirGraphDefinitionLink.SetMaxST(value : String);
begin
  if value <> '' then
  begin
    if FMax = nil then
      FMax := TFhirString.create;
    FMax.value := value
  end
  else if FMax <> nil then
    FMax.value := '';
end;

Procedure TFhirGraphDefinitionLink.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirGraphDefinitionLink.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirGraphDefinitionLink.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Function TFhirGraphDefinitionLink.GetTargetList : TFhirGraphDefinitionLinkTargetList;
begin
  if FTargetList = nil then
    FTargetList := TFhirGraphDefinitionLinkTargetList.Create;
  result := FTargetList;
end;

Function TFhirGraphDefinitionLink.GetHasTargetList : boolean;
begin
  result := (FTargetList <> nil) and (FTargetList.count > 0);
end;

function TFhirGraphDefinitionLink.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FPath.sizeInBytes);
  inc(result, FSliceName.sizeInBytes);
  inc(result, FMin.sizeInBytes);
  inc(result, FMax.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FtargetList.sizeInBytes);
end;

{ TFhirGraphDefinitionLinkListEnumerator }

Constructor TFhirGraphDefinitionLinkListEnumerator.Create(list : TFhirGraphDefinitionLinkList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirGraphDefinitionLinkListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirGraphDefinitionLinkListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirGraphDefinitionLinkListEnumerator.GetCurrent : TFhirGraphDefinitionLink;
begin
  Result := FList[FIndex];
end;

function TFhirGraphDefinitionLinkListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirGraphDefinitionLinkList }
procedure TFhirGraphDefinitionLinkList.AddItem(value: TFhirGraphDefinitionLink);
begin
  assert(value.ClassName = 'TFhirGraphDefinitionLink', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirGraphDefinitionLink');
  add(value);
end;

function TFhirGraphDefinitionLinkList.Append: TFhirGraphDefinitionLink;
begin
  result := TFhirGraphDefinitionLink.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGraphDefinitionLinkList.ClearItems;
begin
  Clear;
end;

function TFhirGraphDefinitionLinkList.GetEnumerator : TFhirGraphDefinitionLinkListEnumerator;
begin
  result := TFhirGraphDefinitionLinkListEnumerator.Create(self.link);
end;

function TFhirGraphDefinitionLinkList.Clone: TFhirGraphDefinitionLinkList;
begin
  result := TFhirGraphDefinitionLinkList(inherited Clone);
end;

function TFhirGraphDefinitionLinkList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirGraphDefinitionLinkList.GetItemN(index: Integer): TFhirGraphDefinitionLink;
begin
  result := TFhirGraphDefinitionLink(ObjectByIndex[index]);
end;

function TFhirGraphDefinitionLinkList.ItemClass: TFslObjectClass;
begin
  result := TFhirGraphDefinitionLink;
end;
function TFhirGraphDefinitionLinkList.IndexOf(value: TFhirGraphDefinitionLink): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirGraphDefinitionLinkList.Insert(index: Integer): TFhirGraphDefinitionLink;
begin
  result := TFhirGraphDefinitionLink.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGraphDefinitionLinkList.InsertItem(index: Integer; value: TFhirGraphDefinitionLink);
begin
  assert(value is TFhirGraphDefinitionLink);
  Inherited Insert(index, value);
end;

function TFhirGraphDefinitionLinkList.Item(index: Integer): TFhirGraphDefinitionLink;
begin
  result := TFhirGraphDefinitionLink(ObjectByIndex[index]);
end;

function TFhirGraphDefinitionLinkList.Link: TFhirGraphDefinitionLinkList;
begin
  result := TFhirGraphDefinitionLinkList(inherited Link);
end;

procedure TFhirGraphDefinitionLinkList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirGraphDefinitionLinkList.SetItemByIndex(index: Integer; value: TFhirGraphDefinitionLink);
begin
  assert(value is TFhirGraphDefinitionLink);
  FhirGraphDefinitionLinks[index] := value;
end;

procedure TFhirGraphDefinitionLinkList.SetItemN(index: Integer; value: TFhirGraphDefinitionLink);
begin
  assert(value is TFhirGraphDefinitionLink);
  ObjectByIndex[index] := value;
end;

{ TFhirGraphDefinitionLinkTarget }

constructor TFhirGraphDefinitionLinkTarget.Create;
begin
  inherited;
end;

destructor TFhirGraphDefinitionLinkTarget.Destroy;
begin
  FType_.free;
  FProfile.free;
  FCompartmentList.Free;
  FLink_List.Free;
  inherited;
end;

procedure TFhirGraphDefinitionLinkTarget.Assign(oSource : TFslObject);
begin
  inherited;
  FType_ := TFhirGraphDefinitionLinkTarget(oSource).FType_.Link;
  profileElement := TFhirGraphDefinitionLinkTarget(oSource).profileElement.Clone;
  if (TFhirGraphDefinitionLinkTarget(oSource).FCompartmentList = nil) then
  begin
    FCompartmentList.free;
    FCompartmentList := nil;
  end
  else
  begin
    if FCompartmentList = nil then
      FCompartmentList := TFhirGraphDefinitionLinkTargetCompartmentList.Create;
    FCompartmentList.Assign(TFhirGraphDefinitionLinkTarget(oSource).FCompartmentList);
  end;
  if (TFhirGraphDefinitionLinkTarget(oSource).FLink_List = nil) then
  begin
    FLink_List.free;
    FLink_List := nil;
  end
  else
  begin
    if FLink_List = nil then
      FLink_List := TFhirGraphDefinitionLinkList.Create;
    FLink_List.Assign(TFhirGraphDefinitionLinkTarget(oSource).FLink_List);
  end;
end;

procedure TFhirGraphDefinitionLinkTarget.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'profile') Then
     list.add(self.link, 'profile', FProfile.Link);
  if (child_name = 'compartment') Then
    list.addAll(self, 'compartment', FCompartmentList);
  if (child_name = 'link') Then
    list.addAll(self, 'link', FLink_List);
end;

procedure TFhirGraphDefinitionLinkTarget.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'profile', 'uri', false, TFhirUri, FProfile.Link));{2}
  oList.add(TFHIRProperty.create(self, 'compartment', '', true, TFhirGraphDefinitionLinkTargetCompartment, FCompartmentList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'link', '@GraphDefinition.link', true, TFhirGraphDefinitionLink, FLink_List.Link)){3};
end;

function TFhirGraphDefinitionLinkTarget.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue);
    result := propValue
  end
  else if (propName = 'profile') then
  begin
    ProfileElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'compartment') then
  begin
    CompartmentList.add(propValue as TFhirGraphDefinitionLinkTargetCompartment){2a};
    result := propValue;
  end
  else if (propName = 'link') then
  begin
    Link_List.add(propValue as TFhirGraphDefinitionLink){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirGraphDefinitionLinkTarget.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'compartment') then CompartmentList.insertItem(index, propValue as TFhirGraphDefinitionLinkTargetCompartment){2a}
  else if (propName = 'link') then Link_List.insertItem(index, propValue as TFhirGraphDefinitionLink){2a}
  else inherited;
end;

function TFhirGraphDefinitionLinkTarget.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'profile') then result := TFhirUri.create() {5b}
  else if (propName = 'compartment') then result := CompartmentList.new(){2}
  else if (propName = 'link') then result := Link_List.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirGraphDefinitionLinkTarget.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'profile') then result := 'uri'
  else if (propName = 'compartment') then result := ''
  else if (propName = 'link') then result := '@GraphDefinition.link'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirGraphDefinitionLinkTarget.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'profile') then ProfileElement := nil
  else if (propName = 'compartment') then deletePropertyValue('compartment', CompartmentList, value) {2}
  else if (propName = 'link') then deletePropertyValue('link', Link_List, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirGraphDefinitionLinkTarget.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, new){4}
  else if (propName = 'profile') then ProfileElement := asUri(new){5b}
  else if (propName = 'compartment') then replacePropertyValue('compartment', CompartmentList, existing, new) {2}
  else if (propName = 'link') then replacePropertyValue('link', Link_List, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirGraphDefinitionLinkTarget.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'compartment') then CompartmentList.move(source, destination){2a}
  else if (propName = 'link') then Link_List.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirGraphDefinitionLinkTarget.fhirType : string;
begin
  result := 'target';
end;

function TFhirGraphDefinitionLinkTarget.Link : TFhirGraphDefinitionLinkTarget;
begin
  result := TFhirGraphDefinitionLinkTarget(inherited Link);
end;

function TFhirGraphDefinitionLinkTarget.Clone : TFhirGraphDefinitionLinkTarget;
begin
  result := TFhirGraphDefinitionLinkTarget(inherited Clone);
end;

function TFhirGraphDefinitionLinkTarget.equals(other : TObject) : boolean;
var
  o : TFhirGraphDefinitionLinkTarget;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirGraphDefinitionLinkTarget)) then
    result := false
  else
  begin
    o := TFhirGraphDefinitionLinkTarget(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(profileElement, o.profileElement, true) and
      compareDeep(compartmentList, o.compartmentList, true) and compareDeep(link_List, o.link_List, true);
  end;
end;

function TFhirGraphDefinitionLinkTarget.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FProfile) and isEmptyProp(FcompartmentList) and isEmptyProp(Flink_List);
end;

procedure TFhirGraphDefinitionLinkTarget.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('profile');
  fields.add('compartment');
  fields.add('link');
end;

{ TFhirGraphDefinitionLinkTarget }

Procedure TFhirGraphDefinitionLinkTarget.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirGraphDefinitionLinkTarget.GetType_ST : TFhirResourceTypesEnum;
begin
  if FType_ = nil then
    result := TFhirResourceTypesEnum(0)
  else
    result := TFhirResourceTypesEnum(StringArrayIndexOfSensitive(CODES_TFhirResourceTypesEnum, FType_.value));
end;

Procedure TFhirGraphDefinitionLinkTarget.SetType_ST(value : TFhirResourceTypesEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirResourceTypesEnum[value], CODES_TFhirResourceTypesEnum[value]);
end;

Procedure TFhirGraphDefinitionLinkTarget.SetProfile(value : TFhirUri);
begin
  FProfile.free;
  FProfile := value;
end;

Function TFhirGraphDefinitionLinkTarget.GetProfileST : String;
begin
  if FProfile = nil then
    result := ''
  else
    result := FProfile.value;
end;

Procedure TFhirGraphDefinitionLinkTarget.SetProfileST(value : String);
begin
  if value <> '' then
  begin
    if FProfile = nil then
      FProfile := TFhirUri.create;
    FProfile.value := value
  end
  else if FProfile <> nil then
    FProfile.value := '';
end;

Function TFhirGraphDefinitionLinkTarget.GetCompartmentList : TFhirGraphDefinitionLinkTargetCompartmentList;
begin
  if FCompartmentList = nil then
    FCompartmentList := TFhirGraphDefinitionLinkTargetCompartmentList.Create;
  result := FCompartmentList;
end;

Function TFhirGraphDefinitionLinkTarget.GetHasCompartmentList : boolean;
begin
  result := (FCompartmentList <> nil) and (FCompartmentList.count > 0);
end;

Function TFhirGraphDefinitionLinkTarget.GetLink_List : TFhirGraphDefinitionLinkList;
begin
  if FLink_List = nil then
    FLink_List := TFhirGraphDefinitionLinkList.Create;
  result := FLink_List;
end;

Function TFhirGraphDefinitionLinkTarget.GetHasLink_List : boolean;
begin
  result := (FLink_List <> nil) and (FLink_List.count > 0);
end;

function TFhirGraphDefinitionLinkTarget.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FProfile.sizeInBytes);
  inc(result, FcompartmentList.sizeInBytes);
  inc(result, Flink_List.sizeInBytes);
end;

{ TFhirGraphDefinitionLinkTargetListEnumerator }

Constructor TFhirGraphDefinitionLinkTargetListEnumerator.Create(list : TFhirGraphDefinitionLinkTargetList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirGraphDefinitionLinkTargetListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirGraphDefinitionLinkTargetListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirGraphDefinitionLinkTargetListEnumerator.GetCurrent : TFhirGraphDefinitionLinkTarget;
begin
  Result := FList[FIndex];
end;

function TFhirGraphDefinitionLinkTargetListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirGraphDefinitionLinkTargetList }
procedure TFhirGraphDefinitionLinkTargetList.AddItem(value: TFhirGraphDefinitionLinkTarget);
begin
  assert(value.ClassName = 'TFhirGraphDefinitionLinkTarget', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirGraphDefinitionLinkTarget');
  add(value);
end;

function TFhirGraphDefinitionLinkTargetList.Append: TFhirGraphDefinitionLinkTarget;
begin
  result := TFhirGraphDefinitionLinkTarget.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGraphDefinitionLinkTargetList.ClearItems;
begin
  Clear;
end;

function TFhirGraphDefinitionLinkTargetList.GetEnumerator : TFhirGraphDefinitionLinkTargetListEnumerator;
begin
  result := TFhirGraphDefinitionLinkTargetListEnumerator.Create(self.link);
end;

function TFhirGraphDefinitionLinkTargetList.Clone: TFhirGraphDefinitionLinkTargetList;
begin
  result := TFhirGraphDefinitionLinkTargetList(inherited Clone);
end;

function TFhirGraphDefinitionLinkTargetList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirGraphDefinitionLinkTargetList.GetItemN(index: Integer): TFhirGraphDefinitionLinkTarget;
begin
  result := TFhirGraphDefinitionLinkTarget(ObjectByIndex[index]);
end;

function TFhirGraphDefinitionLinkTargetList.ItemClass: TFslObjectClass;
begin
  result := TFhirGraphDefinitionLinkTarget;
end;
function TFhirGraphDefinitionLinkTargetList.IndexOf(value: TFhirGraphDefinitionLinkTarget): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirGraphDefinitionLinkTargetList.Insert(index: Integer): TFhirGraphDefinitionLinkTarget;
begin
  result := TFhirGraphDefinitionLinkTarget.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGraphDefinitionLinkTargetList.InsertItem(index: Integer; value: TFhirGraphDefinitionLinkTarget);
begin
  assert(value is TFhirGraphDefinitionLinkTarget);
  Inherited Insert(index, value);
end;

function TFhirGraphDefinitionLinkTargetList.Item(index: Integer): TFhirGraphDefinitionLinkTarget;
begin
  result := TFhirGraphDefinitionLinkTarget(ObjectByIndex[index]);
end;

function TFhirGraphDefinitionLinkTargetList.Link: TFhirGraphDefinitionLinkTargetList;
begin
  result := TFhirGraphDefinitionLinkTargetList(inherited Link);
end;

procedure TFhirGraphDefinitionLinkTargetList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirGraphDefinitionLinkTargetList.SetItemByIndex(index: Integer; value: TFhirGraphDefinitionLinkTarget);
begin
  assert(value is TFhirGraphDefinitionLinkTarget);
  FhirGraphDefinitionLinkTargets[index] := value;
end;

procedure TFhirGraphDefinitionLinkTargetList.SetItemN(index: Integer; value: TFhirGraphDefinitionLinkTarget);
begin
  assert(value is TFhirGraphDefinitionLinkTarget);
  ObjectByIndex[index] := value;
end;

{ TFhirGraphDefinitionLinkTargetCompartment }

constructor TFhirGraphDefinitionLinkTargetCompartment.Create;
begin
  inherited;
end;

destructor TFhirGraphDefinitionLinkTargetCompartment.Destroy;
begin
  FCode.free;
  FRule.free;
  FExpression.free;
  FDescription.free;
  inherited;
end;

procedure TFhirGraphDefinitionLinkTargetCompartment.Assign(oSource : TFslObject);
begin
  inherited;
  FCode := TFhirGraphDefinitionLinkTargetCompartment(oSource).FCode.Link;
  FRule := TFhirGraphDefinitionLinkTargetCompartment(oSource).FRule.Link;
  expressionElement := TFhirGraphDefinitionLinkTargetCompartment(oSource).expressionElement.Clone;
  descriptionElement := TFhirGraphDefinitionLinkTargetCompartment(oSource).descriptionElement.Clone;
end;

procedure TFhirGraphDefinitionLinkTargetCompartment.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'rule') Then
     list.add(self.link, 'rule', FRule.Link);
  if (child_name = 'expression') Then
     list.add(self.link, 'expression', FExpression.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
end;

procedure TFhirGraphDefinitionLinkTargetCompartment.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFHIREnum, FCode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'rule', 'code', false, TFHIREnum, FRule.Link));{1}
  oList.add(TFHIRProperty.create(self, 'expression', 'string', false, TFhirString, FExpression.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
end;

function TFhirGraphDefinitionLinkTargetCompartment.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asEnum(SYSTEMS_TFhirCompartmentTypeEnum, CODES_TFhirCompartmentTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'rule') then
  begin
    RuleElement := asEnum(SYSTEMS_TFhirGraphCompartmentRuleEnum, CODES_TFhirGraphCompartmentRuleEnum, propValue);
    result := propValue
  end
  else if (propName = 'expression') then
  begin
    ExpressionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirGraphDefinitionLinkTargetCompartment.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirGraphDefinitionLinkTargetCompartment.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'expression') then result := TFhirString.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirGraphDefinitionLinkTargetCompartment.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'code'
  else if (propName = 'rule') then result := 'code'
  else if (propName = 'expression') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirGraphDefinitionLinkTargetCompartment.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'rule') then RuleElement := nil
  else if (propName = 'expression') then ExpressionElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirGraphDefinitionLinkTargetCompartment.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asEnum(SYSTEMS_TFhirCompartmentTypeEnum, CODES_TFhirCompartmentTypeEnum, new){4}
  else if (propName = 'rule') then RuleElement := asEnum(SYSTEMS_TFhirGraphCompartmentRuleEnum, CODES_TFhirGraphCompartmentRuleEnum, new){4}
  else if (propName = 'expression') then ExpressionElement := asString(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirGraphDefinitionLinkTargetCompartment.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirGraphDefinitionLinkTargetCompartment.fhirType : string;
begin
  result := 'compartment';
end;

function TFhirGraphDefinitionLinkTargetCompartment.Link : TFhirGraphDefinitionLinkTargetCompartment;
begin
  result := TFhirGraphDefinitionLinkTargetCompartment(inherited Link);
end;

function TFhirGraphDefinitionLinkTargetCompartment.Clone : TFhirGraphDefinitionLinkTargetCompartment;
begin
  result := TFhirGraphDefinitionLinkTargetCompartment(inherited Clone);
end;

function TFhirGraphDefinitionLinkTargetCompartment.equals(other : TObject) : boolean;
var
  o : TFhirGraphDefinitionLinkTargetCompartment;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirGraphDefinitionLinkTargetCompartment)) then
    result := false
  else
  begin
    o := TFhirGraphDefinitionLinkTargetCompartment(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(ruleElement, o.ruleElement, true) and
      compareDeep(expressionElement, o.expressionElement, true) and compareDeep(descriptionElement, o.descriptionElement, true);
  end;
end;

function TFhirGraphDefinitionLinkTargetCompartment.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FRule) and isEmptyProp(FExpression) and isEmptyProp(FDescription);
end;

procedure TFhirGraphDefinitionLinkTargetCompartment.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('rule');
  fields.add('expression');
  fields.add('description');
end;

{ TFhirGraphDefinitionLinkTargetCompartment }

Procedure TFhirGraphDefinitionLinkTargetCompartment.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirGraphDefinitionLinkTargetCompartment.GetCodeST : TFhirCompartmentTypeEnum;
begin
  if FCode = nil then
    result := TFhirCompartmentTypeEnum(0)
  else
    result := TFhirCompartmentTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirCompartmentTypeEnum, FCode.value));
end;

Procedure TFhirGraphDefinitionLinkTargetCompartment.SetCodeST(value : TFhirCompartmentTypeEnum);
begin
  if ord(value) = 0 then
    CodeElement := nil
  else
    CodeElement := TFhirEnum.create(SYSTEMS_TFhirCompartmentTypeEnum[value], CODES_TFhirCompartmentTypeEnum[value]);
end;

Procedure TFhirGraphDefinitionLinkTargetCompartment.SetRule(value : TFhirEnum);
begin
  FRule.free;
  FRule := value;
end;

Function TFhirGraphDefinitionLinkTargetCompartment.GetRuleST : TFhirGraphCompartmentRuleEnum;
begin
  if FRule = nil then
    result := TFhirGraphCompartmentRuleEnum(0)
  else
    result := TFhirGraphCompartmentRuleEnum(StringArrayIndexOfSensitive(CODES_TFhirGraphCompartmentRuleEnum, FRule.value));
end;

Procedure TFhirGraphDefinitionLinkTargetCompartment.SetRuleST(value : TFhirGraphCompartmentRuleEnum);
begin
  if ord(value) = 0 then
    RuleElement := nil
  else
    RuleElement := TFhirEnum.create(SYSTEMS_TFhirGraphCompartmentRuleEnum[value], CODES_TFhirGraphCompartmentRuleEnum[value]);
end;

Procedure TFhirGraphDefinitionLinkTargetCompartment.SetExpression(value : TFhirString);
begin
  FExpression.free;
  FExpression := value;
end;

Function TFhirGraphDefinitionLinkTargetCompartment.GetExpressionST : String;
begin
  if FExpression = nil then
    result := ''
  else
    result := FExpression.value;
end;

Procedure TFhirGraphDefinitionLinkTargetCompartment.SetExpressionST(value : String);
begin
  if value <> '' then
  begin
    if FExpression = nil then
      FExpression := TFhirString.create;
    FExpression.value := value
  end
  else if FExpression <> nil then
    FExpression.value := '';
end;

Procedure TFhirGraphDefinitionLinkTargetCompartment.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirGraphDefinitionLinkTargetCompartment.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirGraphDefinitionLinkTargetCompartment.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirGraphDefinitionLinkTargetCompartment.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FRule.sizeInBytes);
  inc(result, FExpression.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
end;

{ TFhirGraphDefinitionLinkTargetCompartmentListEnumerator }

Constructor TFhirGraphDefinitionLinkTargetCompartmentListEnumerator.Create(list : TFhirGraphDefinitionLinkTargetCompartmentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirGraphDefinitionLinkTargetCompartmentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirGraphDefinitionLinkTargetCompartmentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirGraphDefinitionLinkTargetCompartmentListEnumerator.GetCurrent : TFhirGraphDefinitionLinkTargetCompartment;
begin
  Result := FList[FIndex];
end;

function TFhirGraphDefinitionLinkTargetCompartmentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirGraphDefinitionLinkTargetCompartmentList }
procedure TFhirGraphDefinitionLinkTargetCompartmentList.AddItem(value: TFhirGraphDefinitionLinkTargetCompartment);
begin
  assert(value.ClassName = 'TFhirGraphDefinitionLinkTargetCompartment', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirGraphDefinitionLinkTargetCompartment');
  add(value);
end;

function TFhirGraphDefinitionLinkTargetCompartmentList.Append: TFhirGraphDefinitionLinkTargetCompartment;
begin
  result := TFhirGraphDefinitionLinkTargetCompartment.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGraphDefinitionLinkTargetCompartmentList.ClearItems;
begin
  Clear;
end;

function TFhirGraphDefinitionLinkTargetCompartmentList.GetEnumerator : TFhirGraphDefinitionLinkTargetCompartmentListEnumerator;
begin
  result := TFhirGraphDefinitionLinkTargetCompartmentListEnumerator.Create(self.link);
end;

function TFhirGraphDefinitionLinkTargetCompartmentList.Clone: TFhirGraphDefinitionLinkTargetCompartmentList;
begin
  result := TFhirGraphDefinitionLinkTargetCompartmentList(inherited Clone);
end;

function TFhirGraphDefinitionLinkTargetCompartmentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirGraphDefinitionLinkTargetCompartmentList.GetItemN(index: Integer): TFhirGraphDefinitionLinkTargetCompartment;
begin
  result := TFhirGraphDefinitionLinkTargetCompartment(ObjectByIndex[index]);
end;

function TFhirGraphDefinitionLinkTargetCompartmentList.ItemClass: TFslObjectClass;
begin
  result := TFhirGraphDefinitionLinkTargetCompartment;
end;
function TFhirGraphDefinitionLinkTargetCompartmentList.IndexOf(value: TFhirGraphDefinitionLinkTargetCompartment): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirGraphDefinitionLinkTargetCompartmentList.Insert(index: Integer): TFhirGraphDefinitionLinkTargetCompartment;
begin
  result := TFhirGraphDefinitionLinkTargetCompartment.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGraphDefinitionLinkTargetCompartmentList.InsertItem(index: Integer; value: TFhirGraphDefinitionLinkTargetCompartment);
begin
  assert(value is TFhirGraphDefinitionLinkTargetCompartment);
  Inherited Insert(index, value);
end;

function TFhirGraphDefinitionLinkTargetCompartmentList.Item(index: Integer): TFhirGraphDefinitionLinkTargetCompartment;
begin
  result := TFhirGraphDefinitionLinkTargetCompartment(ObjectByIndex[index]);
end;

function TFhirGraphDefinitionLinkTargetCompartmentList.Link: TFhirGraphDefinitionLinkTargetCompartmentList;
begin
  result := TFhirGraphDefinitionLinkTargetCompartmentList(inherited Link);
end;

procedure TFhirGraphDefinitionLinkTargetCompartmentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirGraphDefinitionLinkTargetCompartmentList.SetItemByIndex(index: Integer; value: TFhirGraphDefinitionLinkTargetCompartment);
begin
  assert(value is TFhirGraphDefinitionLinkTargetCompartment);
  FhirGraphDefinitionLinkTargetCompartments[index] := value;
end;

procedure TFhirGraphDefinitionLinkTargetCompartmentList.SetItemN(index: Integer; value: TFhirGraphDefinitionLinkTargetCompartment);
begin
  assert(value is TFhirGraphDefinitionLinkTargetCompartment);
  ObjectByIndex[index] := value;
end;

{ TFhirGraphDefinition }

constructor TFhirGraphDefinition.Create;
begin
  inherited;
end;

destructor TFhirGraphDefinition.Destroy;
begin
  FPurpose.free;
  FStart.free;
  FProfile.free;
  FLink_List.Free;
  inherited;
end;

function TFhirGraphDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtGraphDefinition;
end;

procedure TFhirGraphDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  purposeElement := TFhirGraphDefinition(oSource).purposeElement.Clone;
  FStart := TFhirGraphDefinition(oSource).FStart.Link;
  profileElement := TFhirGraphDefinition(oSource).profileElement.Clone;
  if (TFhirGraphDefinition(oSource).FLink_List = nil) then
  begin
    FLink_List.free;
    FLink_List := nil;
  end
  else
  begin
    if FLink_List = nil then
      FLink_List := TFhirGraphDefinitionLinkList.Create;
    FLink_List.Assign(TFhirGraphDefinition(oSource).FLink_List);
  end;
end;

procedure TFhirGraphDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'start') Then
     list.add(self.link, 'start', FStart.Link);
  if (child_name = 'profile') Then
     list.add(self.link, 'profile', FProfile.Link);
  if (child_name = 'link') Then
    list.addAll(self, 'link', FLink_List);
end;

procedure TFhirGraphDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));{2}
  oList.add(TFHIRProperty.create(self, 'start', 'code', false, TFHIREnum, FStart.Link));{1}
  oList.add(TFHIRProperty.create(self, 'profile', 'uri', false, TFhirUri, FProfile.Link));{2}
  oList.add(TFHIRProperty.create(self, 'link', '', true, TFhirGraphDefinitionLink, FLink_List.Link)){3};
end;

function TFhirGraphDefinition.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'start') then
  begin
    StartElement := asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue);
    result := propValue
  end
  else if (propName = 'profile') then
  begin
    ProfileElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'link') then
  begin
    Link_List.add(propValue as TFhirGraphDefinitionLink){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirGraphDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'link') then Link_List.insertItem(index, propValue as TFhirGraphDefinitionLink){2a}
  else inherited;
end;

function TFhirGraphDefinition.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'purpose') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'profile') then result := TFhirUri.create() {5b}
  else if (propName = 'link') then result := Link_List.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirGraphDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'start') then result := 'code'
  else if (propName = 'profile') then result := 'uri'
  else if (propName = 'link') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirGraphDefinition.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'start') then StartElement := nil
  else if (propName = 'profile') then ProfileElement := nil
  else if (propName = 'link') then deletePropertyValue('link', Link_List, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirGraphDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'purpose') then PurposeElement := asMarkdown(new){5b}
  else if (propName = 'start') then StartElement := asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, new){4}
  else if (propName = 'profile') then ProfileElement := asUri(new){5b}
  else if (propName = 'link') then replacePropertyValue('link', Link_List, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirGraphDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'link') then Link_List.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirGraphDefinition.fhirType : string;
begin
  result := 'GraphDefinition';
end;

function TFhirGraphDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPurpose) and isEmptyProp(FStart) and isEmptyProp(FProfile) and isEmptyProp(Flink_List);
end;

function TFhirGraphDefinition.equals(other : TObject) : boolean;
var
  o : TFhirGraphDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirGraphDefinition)) then
    result := false
  else
  begin
    o := TFhirGraphDefinition(other);
    result := compareDeep(purposeElement, o.purposeElement, true) and compareDeep(startElement, o.startElement, true) and
      compareDeep(profileElement, o.profileElement, true) and compareDeep(link_List, o.link_List, true);
  end;
end;

function TFhirGraphDefinition.Link : TFhirGraphDefinition;
begin
  result := TFhirGraphDefinition(inherited Link);
end;

function TFhirGraphDefinition.Clone : TFhirGraphDefinition;
begin
  result := TFhirGraphDefinition(inherited Clone);
end;

procedure TFhirGraphDefinition.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('url');
  fields.add('version');
  fields.add('name');
  fields.add('status');
  fields.add('experimental');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('purpose');
  fields.add('start');
  fields.add('profile');
  fields.add('link');
end;

{ TFhirGraphDefinition }

Procedure TFhirGraphDefinition.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

Function TFhirGraphDefinition.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

Procedure TFhirGraphDefinition.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

Procedure TFhirGraphDefinition.SetStart(value : TFhirEnum);
begin
  FStart.free;
  FStart := value;
end;

Function TFhirGraphDefinition.GetStartST : TFhirResourceTypesEnum;
begin
  if FStart = nil then
    result := TFhirResourceTypesEnum(0)
  else
    result := TFhirResourceTypesEnum(StringArrayIndexOfSensitive(CODES_TFhirResourceTypesEnum, FStart.value));
end;

Procedure TFhirGraphDefinition.SetStartST(value : TFhirResourceTypesEnum);
begin
  if ord(value) = 0 then
    StartElement := nil
  else
    StartElement := TFhirEnum.create(SYSTEMS_TFhirResourceTypesEnum[value], CODES_TFhirResourceTypesEnum[value]);
end;

Procedure TFhirGraphDefinition.SetProfile(value : TFhirUri);
begin
  FProfile.free;
  FProfile := value;
end;

Function TFhirGraphDefinition.GetProfileST : String;
begin
  if FProfile = nil then
    result := ''
  else
    result := FProfile.value;
end;

Procedure TFhirGraphDefinition.SetProfileST(value : String);
begin
  if value <> '' then
  begin
    if FProfile = nil then
      FProfile := TFhirUri.create;
    FProfile.value := value
  end
  else if FProfile <> nil then
    FProfile.value := '';
end;

Function TFhirGraphDefinition.GetLink_List : TFhirGraphDefinitionLinkList;
begin
  if FLink_List = nil then
    FLink_List := TFhirGraphDefinitionLinkList.Create;
  result := FLink_List;
end;

Function TFhirGraphDefinition.GetHasLink_List : boolean;
begin
  result := (FLink_List <> nil) and (FLink_List.count > 0);
end;

function TFhirGraphDefinition.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FPurpose.sizeInBytes);
  inc(result, FStart.sizeInBytes);
  inc(result, FProfile.sizeInBytes);
  inc(result, Flink_List.sizeInBytes);
end;

{ TFhirGraphDefinitionListEnumerator }

Constructor TFhirGraphDefinitionListEnumerator.Create(list : TFhirGraphDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirGraphDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirGraphDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirGraphDefinitionListEnumerator.GetCurrent : TFhirGraphDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirGraphDefinitionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirGraphDefinitionList }
procedure TFhirGraphDefinitionList.AddItem(value: TFhirGraphDefinition);
begin
  assert(value.ClassName = 'TFhirGraphDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirGraphDefinition');
  add(value);
end;

function TFhirGraphDefinitionList.Append: TFhirGraphDefinition;
begin
  result := TFhirGraphDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGraphDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirGraphDefinitionList.GetEnumerator : TFhirGraphDefinitionListEnumerator;
begin
  result := TFhirGraphDefinitionListEnumerator.Create(self.link);
end;

function TFhirGraphDefinitionList.Clone: TFhirGraphDefinitionList;
begin
  result := TFhirGraphDefinitionList(inherited Clone);
end;

function TFhirGraphDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirGraphDefinitionList.GetItemN(index: Integer): TFhirGraphDefinition;
begin
  result := TFhirGraphDefinition(ObjectByIndex[index]);
end;

function TFhirGraphDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirGraphDefinition;
end;
function TFhirGraphDefinitionList.IndexOf(value: TFhirGraphDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirGraphDefinitionList.Insert(index: Integer): TFhirGraphDefinition;
begin
  result := TFhirGraphDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGraphDefinitionList.InsertItem(index: Integer; value: TFhirGraphDefinition);
begin
  assert(value is TFhirGraphDefinition);
  Inherited Insert(index, value);
end;

function TFhirGraphDefinitionList.Item(index: Integer): TFhirGraphDefinition;
begin
  result := TFhirGraphDefinition(ObjectByIndex[index]);
end;

function TFhirGraphDefinitionList.Link: TFhirGraphDefinitionList;
begin
  result := TFhirGraphDefinitionList(inherited Link);
end;

procedure TFhirGraphDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirGraphDefinitionList.SetItemByIndex(index: Integer; value: TFhirGraphDefinition);
begin
  assert(value is TFhirGraphDefinition);
  FhirGraphDefinitions[index] := value;
end;

procedure TFhirGraphDefinitionList.SetItemN(index: Integer; value: TFhirGraphDefinition);
begin
  assert(value is TFhirGraphDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_GRAPHDEFINITION}

{$IFDEF FHIR_IMPLEMENTATIONGUIDE}

{ TFhirImplementationGuideDependency }

constructor TFhirImplementationGuideDependency.Create;
begin
  inherited;
end;

destructor TFhirImplementationGuideDependency.Destroy;
begin
  FType_.free;
  FUri.free;
  inherited;
end;

procedure TFhirImplementationGuideDependency.Assign(oSource : TFslObject);
begin
  inherited;
  FType_ := TFhirImplementationGuideDependency(oSource).FType_.Link;
  uriElement := TFhirImplementationGuideDependency(oSource).uriElement.Clone;
end;

procedure TFhirImplementationGuideDependency.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'uri') Then
     list.add(self.link, 'uri', FUri.Link);
end;

procedure TFhirImplementationGuideDependency.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'uri', 'uri', false, TFhirUri, FUri.Link));{2}
end;

function TFhirImplementationGuideDependency.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirGuideDependencyTypeEnum, CODES_TFhirGuideDependencyTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'uri') then
  begin
    UriElement := asUri(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImplementationGuideDependency.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirImplementationGuideDependency.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'uri') then result := TFhirUri.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImplementationGuideDependency.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'uri') then result := 'uri'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImplementationGuideDependency.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'uri') then UriElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImplementationGuideDependency.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirGuideDependencyTypeEnum, CODES_TFhirGuideDependencyTypeEnum, new){4}
  else if (propName = 'uri') then UriElement := asUri(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImplementationGuideDependency.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirImplementationGuideDependency.fhirType : string;
begin
  result := 'dependency';
end;

function TFhirImplementationGuideDependency.Link : TFhirImplementationGuideDependency;
begin
  result := TFhirImplementationGuideDependency(inherited Link);
end;

function TFhirImplementationGuideDependency.Clone : TFhirImplementationGuideDependency;
begin
  result := TFhirImplementationGuideDependency(inherited Clone);
end;

function TFhirImplementationGuideDependency.equals(other : TObject) : boolean;
var
  o : TFhirImplementationGuideDependency;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImplementationGuideDependency)) then
    result := false
  else
  begin
    o := TFhirImplementationGuideDependency(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(uriElement, o.uriElement, true);
  end;
end;

function TFhirImplementationGuideDependency.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FUri);
end;

procedure TFhirImplementationGuideDependency.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('uri');
end;

{ TFhirImplementationGuideDependency }

Procedure TFhirImplementationGuideDependency.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirImplementationGuideDependency.GetType_ST : TFhirGuideDependencyTypeEnum;
begin
  if FType_ = nil then
    result := TFhirGuideDependencyTypeEnum(0)
  else
    result := TFhirGuideDependencyTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirGuideDependencyTypeEnum, FType_.value));
end;

Procedure TFhirImplementationGuideDependency.SetType_ST(value : TFhirGuideDependencyTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirGuideDependencyTypeEnum[value], CODES_TFhirGuideDependencyTypeEnum[value]);
end;

Procedure TFhirImplementationGuideDependency.SetUri(value : TFhirUri);
begin
  FUri.free;
  FUri := value;
end;

Function TFhirImplementationGuideDependency.GetUriST : String;
begin
  if FUri = nil then
    result := ''
  else
    result := FUri.value;
end;

Procedure TFhirImplementationGuideDependency.SetUriST(value : String);
begin
  if value <> '' then
  begin
    if FUri = nil then
      FUri := TFhirUri.create;
    FUri.value := value
  end
  else if FUri <> nil then
    FUri.value := '';
end;

function TFhirImplementationGuideDependency.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FUri.sizeInBytes);
end;

{ TFhirImplementationGuideDependencyListEnumerator }

Constructor TFhirImplementationGuideDependencyListEnumerator.Create(list : TFhirImplementationGuideDependencyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImplementationGuideDependencyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImplementationGuideDependencyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImplementationGuideDependencyListEnumerator.GetCurrent : TFhirImplementationGuideDependency;
begin
  Result := FList[FIndex];
end;

function TFhirImplementationGuideDependencyListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImplementationGuideDependencyList }
procedure TFhirImplementationGuideDependencyList.AddItem(value: TFhirImplementationGuideDependency);
begin
  assert(value.ClassName = 'TFhirImplementationGuideDependency', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImplementationGuideDependency');
  add(value);
end;

function TFhirImplementationGuideDependencyList.Append: TFhirImplementationGuideDependency;
begin
  result := TFhirImplementationGuideDependency.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuideDependencyList.ClearItems;
begin
  Clear;
end;

function TFhirImplementationGuideDependencyList.GetEnumerator : TFhirImplementationGuideDependencyListEnumerator;
begin
  result := TFhirImplementationGuideDependencyListEnumerator.Create(self.link);
end;

function TFhirImplementationGuideDependencyList.Clone: TFhirImplementationGuideDependencyList;
begin
  result := TFhirImplementationGuideDependencyList(inherited Clone);
end;

function TFhirImplementationGuideDependencyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImplementationGuideDependencyList.GetItemN(index: Integer): TFhirImplementationGuideDependency;
begin
  result := TFhirImplementationGuideDependency(ObjectByIndex[index]);
end;

function TFhirImplementationGuideDependencyList.ItemClass: TFslObjectClass;
begin
  result := TFhirImplementationGuideDependency;
end;
function TFhirImplementationGuideDependencyList.IndexOf(value: TFhirImplementationGuideDependency): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImplementationGuideDependencyList.Insert(index: Integer): TFhirImplementationGuideDependency;
begin
  result := TFhirImplementationGuideDependency.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuideDependencyList.InsertItem(index: Integer; value: TFhirImplementationGuideDependency);
begin
  assert(value is TFhirImplementationGuideDependency);
  Inherited Insert(index, value);
end;

function TFhirImplementationGuideDependencyList.Item(index: Integer): TFhirImplementationGuideDependency;
begin
  result := TFhirImplementationGuideDependency(ObjectByIndex[index]);
end;

function TFhirImplementationGuideDependencyList.Link: TFhirImplementationGuideDependencyList;
begin
  result := TFhirImplementationGuideDependencyList(inherited Link);
end;

procedure TFhirImplementationGuideDependencyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImplementationGuideDependencyList.SetItemByIndex(index: Integer; value: TFhirImplementationGuideDependency);
begin
  assert(value is TFhirImplementationGuideDependency);
  FhirImplementationGuideDependencies[index] := value;
end;

procedure TFhirImplementationGuideDependencyList.SetItemN(index: Integer; value: TFhirImplementationGuideDependency);
begin
  assert(value is TFhirImplementationGuideDependency);
  ObjectByIndex[index] := value;
end;

{ TFhirImplementationGuidePackage }

constructor TFhirImplementationGuidePackage.Create;
begin
  inherited;
end;

destructor TFhirImplementationGuidePackage.Destroy;
begin
  FName.free;
  FDescription.free;
  FResourceList.Free;
  inherited;
end;

procedure TFhirImplementationGuidePackage.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirImplementationGuidePackage(oSource).nameElement.Clone;
  descriptionElement := TFhirImplementationGuidePackage(oSource).descriptionElement.Clone;
  if (TFhirImplementationGuidePackage(oSource).FResourceList = nil) then
  begin
    FResourceList.free;
    FResourceList := nil;
  end
  else
  begin
    if FResourceList = nil then
      FResourceList := TFhirImplementationGuidePackageResourceList.Create;
    FResourceList.Assign(TFhirImplementationGuidePackage(oSource).FResourceList);
  end;
end;

procedure TFhirImplementationGuidePackage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'resource') Then
    list.addAll(self, 'resource', FResourceList);
end;

procedure TFhirImplementationGuidePackage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'resource', '', true, TFhirImplementationGuidePackageResource, FResourceList.Link)){3};
end;

function TFhirImplementationGuidePackage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    ResourceList.add(propValue as TFhirImplementationGuidePackageResource){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImplementationGuidePackage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'resource') then ResourceList.insertItem(index, propValue as TFhirImplementationGuidePackageResource){2a}
  else inherited;
end;

function TFhirImplementationGuidePackage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'resource') then result := ResourceList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImplementationGuidePackage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'resource') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImplementationGuidePackage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'resource') then deletePropertyValue('resource', ResourceList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImplementationGuidePackage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'resource') then replacePropertyValue('resource', ResourceList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImplementationGuidePackage.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'resource') then ResourceList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImplementationGuidePackage.fhirType : string;
begin
  result := 'package';
end;

function TFhirImplementationGuidePackage.Link : TFhirImplementationGuidePackage;
begin
  result := TFhirImplementationGuidePackage(inherited Link);
end;

function TFhirImplementationGuidePackage.Clone : TFhirImplementationGuidePackage;
begin
  result := TFhirImplementationGuidePackage(inherited Clone);
end;

function TFhirImplementationGuidePackage.equals(other : TObject) : boolean;
var
  o : TFhirImplementationGuidePackage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImplementationGuidePackage)) then
    result := false
  else
  begin
    o := TFhirImplementationGuidePackage(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and
      compareDeep(resourceList, o.resourceList, true);
  end;
end;

function TFhirImplementationGuidePackage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FDescription) and isEmptyProp(FresourceList);
end;

procedure TFhirImplementationGuidePackage.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('description');
  fields.add('resource');
end;

{ TFhirImplementationGuidePackage }

Procedure TFhirImplementationGuidePackage.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirImplementationGuidePackage.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirImplementationGuidePackage.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirImplementationGuidePackage.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirImplementationGuidePackage.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirImplementationGuidePackage.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Function TFhirImplementationGuidePackage.GetResourceList : TFhirImplementationGuidePackageResourceList;
begin
  if FResourceList = nil then
    FResourceList := TFhirImplementationGuidePackageResourceList.Create;
  result := FResourceList;
end;

Function TFhirImplementationGuidePackage.GetHasResourceList : boolean;
begin
  result := (FResourceList <> nil) and (FResourceList.count > 0);
end;

function TFhirImplementationGuidePackage.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FresourceList.sizeInBytes);
end;

{ TFhirImplementationGuidePackageListEnumerator }

Constructor TFhirImplementationGuidePackageListEnumerator.Create(list : TFhirImplementationGuidePackageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImplementationGuidePackageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImplementationGuidePackageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImplementationGuidePackageListEnumerator.GetCurrent : TFhirImplementationGuidePackage;
begin
  Result := FList[FIndex];
end;

function TFhirImplementationGuidePackageListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImplementationGuidePackageList }
procedure TFhirImplementationGuidePackageList.AddItem(value: TFhirImplementationGuidePackage);
begin
  assert(value.ClassName = 'TFhirImplementationGuidePackage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImplementationGuidePackage');
  add(value);
end;

function TFhirImplementationGuidePackageList.Append: TFhirImplementationGuidePackage;
begin
  result := TFhirImplementationGuidePackage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuidePackageList.ClearItems;
begin
  Clear;
end;

function TFhirImplementationGuidePackageList.GetEnumerator : TFhirImplementationGuidePackageListEnumerator;
begin
  result := TFhirImplementationGuidePackageListEnumerator.Create(self.link);
end;

function TFhirImplementationGuidePackageList.Clone: TFhirImplementationGuidePackageList;
begin
  result := TFhirImplementationGuidePackageList(inherited Clone);
end;

function TFhirImplementationGuidePackageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImplementationGuidePackageList.GetItemN(index: Integer): TFhirImplementationGuidePackage;
begin
  result := TFhirImplementationGuidePackage(ObjectByIndex[index]);
end;

function TFhirImplementationGuidePackageList.ItemClass: TFslObjectClass;
begin
  result := TFhirImplementationGuidePackage;
end;
function TFhirImplementationGuidePackageList.IndexOf(value: TFhirImplementationGuidePackage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImplementationGuidePackageList.Insert(index: Integer): TFhirImplementationGuidePackage;
begin
  result := TFhirImplementationGuidePackage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuidePackageList.InsertItem(index: Integer; value: TFhirImplementationGuidePackage);
begin
  assert(value is TFhirImplementationGuidePackage);
  Inherited Insert(index, value);
end;

function TFhirImplementationGuidePackageList.Item(index: Integer): TFhirImplementationGuidePackage;
begin
  result := TFhirImplementationGuidePackage(ObjectByIndex[index]);
end;

function TFhirImplementationGuidePackageList.Link: TFhirImplementationGuidePackageList;
begin
  result := TFhirImplementationGuidePackageList(inherited Link);
end;

procedure TFhirImplementationGuidePackageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImplementationGuidePackageList.SetItemByIndex(index: Integer; value: TFhirImplementationGuidePackage);
begin
  assert(value is TFhirImplementationGuidePackage);
  FhirImplementationGuidePackages[index] := value;
end;

procedure TFhirImplementationGuidePackageList.SetItemN(index: Integer; value: TFhirImplementationGuidePackage);
begin
  assert(value is TFhirImplementationGuidePackage);
  ObjectByIndex[index] := value;
end;

{ TFhirImplementationGuidePackageResource }

constructor TFhirImplementationGuidePackageResource.Create;
begin
  inherited;
end;

destructor TFhirImplementationGuidePackageResource.Destroy;
begin
  FExample.free;
  FName.free;
  FDescription.free;
  FAcronym.free;
  FSource.free;
  FExampleFor.free;
  inherited;
end;

procedure TFhirImplementationGuidePackageResource.Assign(oSource : TFslObject);
begin
  inherited;
  exampleElement := TFhirImplementationGuidePackageResource(oSource).exampleElement.Clone;
  nameElement := TFhirImplementationGuidePackageResource(oSource).nameElement.Clone;
  descriptionElement := TFhirImplementationGuidePackageResource(oSource).descriptionElement.Clone;
  acronymElement := TFhirImplementationGuidePackageResource(oSource).acronymElement.Clone;
  source := TFhirImplementationGuidePackageResource(oSource).source.Clone;
  exampleFor := TFhirImplementationGuidePackageResource(oSource).exampleFor.Clone;
end;

procedure TFhirImplementationGuidePackageResource.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'example') Then
     list.add(self.link, 'example', FExample.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'acronym') Then
     list.add(self.link, 'acronym', FAcronym.Link);
  if (child_name = 'source[x]') or (child_name = 'source') Then
     list.add(self.link, 'source[x]', FSource.Link);
  if (child_name = 'exampleFor') Then
     list.add(self.link, 'exampleFor', FExampleFor.Link);
end;

procedure TFhirImplementationGuidePackageResource.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'example', 'boolean', false, TFhirBoolean, FExample.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'acronym', 'string', false, TFhirString, FAcronym.Link));{2}
  oList.add(TFHIRProperty.create(self, 'source[x]', 'uri|Reference(Any)', false, TFhirType, FSource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'exampleFor', 'Reference(StructureDefinition)', false, TFhirReference{TFhirStructureDefinition}, FExampleFor.Link));{2}
end;

function TFhirImplementationGuidePackageResource.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'example') then
  begin
    ExampleElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'acronym') then
  begin
    AcronymElement := asString(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'source', ['Uri', 'Reference'])) then
  begin
    Source := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'exampleFor') then
  begin
    ExampleFor := propValue as TFhirReference{TFhirStructureDefinition}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImplementationGuidePackageResource.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirImplementationGuidePackageResource.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'example') then result := TFhirBoolean.create() {5b}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'acronym') then result := TFhirString.create() {5b}
  else if (isMatchingName(propName, 'source', ['Uri', 'Reference'])) then raise EFHIRException.create('Cannot make property Source'){4x}
  else if (propName = 'exampleFor') then result := TFhirReference{TFhirStructureDefinition}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImplementationGuidePackageResource.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'example') then result := 'boolean'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'acronym') then result := 'string'
  else if (propName = 'source[x]') then result := 'uri|Reference'
  else if (propName = 'exampleFor') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImplementationGuidePackageResource.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'example') then ExampleElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'acronym') then AcronymElement := nil
  else if (isMatchingName(propName, 'source', ['Uri', 'Reference'])) then SourceElement := nil{4x}
  else if (propName = 'exampleFor') then ExampleForElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImplementationGuidePackageResource.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'example') then ExampleElement := asBoolean(new){5b}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'acronym') then AcronymElement := asString(new){5b}
  else if (isMatchingName(propName, 'source', ['Uri', 'Reference'])) then SourceElement := new as TFhirType{4x}
  else if (propName = 'exampleFor') then ExampleForElement := new as TFhirReference{TFhirStructureDefinition}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImplementationGuidePackageResource.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirImplementationGuidePackageResource.fhirType : string;
begin
  result := 'resource';
end;

function TFhirImplementationGuidePackageResource.Link : TFhirImplementationGuidePackageResource;
begin
  result := TFhirImplementationGuidePackageResource(inherited Link);
end;

function TFhirImplementationGuidePackageResource.Clone : TFhirImplementationGuidePackageResource;
begin
  result := TFhirImplementationGuidePackageResource(inherited Clone);
end;

function TFhirImplementationGuidePackageResource.equals(other : TObject) : boolean;
var
  o : TFhirImplementationGuidePackageResource;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImplementationGuidePackageResource)) then
    result := false
  else
  begin
    o := TFhirImplementationGuidePackageResource(other);
    result := compareDeep(exampleElement, o.exampleElement, true) and compareDeep(nameElement, o.nameElement, true) and
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(acronymElement, o.acronymElement, true) and
      compareDeep(sourceElement, o.sourceElement, true) and compareDeep(exampleForElement, o.exampleForElement, true);
  end;
end;

function TFhirImplementationGuidePackageResource.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FExample) and isEmptyProp(FName) and isEmptyProp(FDescription) and isEmptyProp(FAcronym) and isEmptyProp(FSource) and isEmptyProp(FExampleFor);
end;

procedure TFhirImplementationGuidePackageResource.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('example');
  fields.add('name');
  fields.add('description');
  fields.add('acronym');
  fields.add('source[x]');
  fields.add('exampleFor');
end;

{ TFhirImplementationGuidePackageResource }

Procedure TFhirImplementationGuidePackageResource.SetExample(value : TFhirBoolean);
begin
  FExample.free;
  FExample := value;
end;

Function TFhirImplementationGuidePackageResource.GetExampleST : Boolean;
begin
  if FExample = nil then
    result := false
  else
    result := FExample.value;
end;

Procedure TFhirImplementationGuidePackageResource.SetExampleST(value : Boolean);
begin
  if FExample = nil then
    FExample := TFhirBoolean.create;
  FExample.value := value
end;

Procedure TFhirImplementationGuidePackageResource.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirImplementationGuidePackageResource.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirImplementationGuidePackageResource.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirImplementationGuidePackageResource.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirImplementationGuidePackageResource.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirImplementationGuidePackageResource.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirImplementationGuidePackageResource.SetAcronym(value : TFhirString);
begin
  FAcronym.free;
  FAcronym := value;
end;

Function TFhirImplementationGuidePackageResource.GetAcronymST : String;
begin
  if FAcronym = nil then
    result := ''
  else
    result := FAcronym.value;
end;

Procedure TFhirImplementationGuidePackageResource.SetAcronymST(value : String);
begin
  if value <> '' then
  begin
    if FAcronym = nil then
      FAcronym := TFhirString.create;
    FAcronym.value := value
  end
  else if FAcronym <> nil then
    FAcronym.value := '';
end;

Procedure TFhirImplementationGuidePackageResource.SetSource(value : TFhirType);
begin
  FSource.free;
  FSource := value;
end;

Procedure TFhirImplementationGuidePackageResource.SetExampleFor(value : TFhirReference{TFhirStructureDefinition});
begin
  FExampleFor.free;
  FExampleFor := value;
end;

function TFhirImplementationGuidePackageResource.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FExample.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FAcronym.sizeInBytes);
  inc(result, FSource.sizeInBytes);
  inc(result, FExampleFor.sizeInBytes);
end;

{ TFhirImplementationGuidePackageResourceListEnumerator }

Constructor TFhirImplementationGuidePackageResourceListEnumerator.Create(list : TFhirImplementationGuidePackageResourceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImplementationGuidePackageResourceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImplementationGuidePackageResourceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImplementationGuidePackageResourceListEnumerator.GetCurrent : TFhirImplementationGuidePackageResource;
begin
  Result := FList[FIndex];
end;

function TFhirImplementationGuidePackageResourceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImplementationGuidePackageResourceList }
procedure TFhirImplementationGuidePackageResourceList.AddItem(value: TFhirImplementationGuidePackageResource);
begin
  assert(value.ClassName = 'TFhirImplementationGuidePackageResource', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImplementationGuidePackageResource');
  add(value);
end;

function TFhirImplementationGuidePackageResourceList.Append: TFhirImplementationGuidePackageResource;
begin
  result := TFhirImplementationGuidePackageResource.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuidePackageResourceList.ClearItems;
begin
  Clear;
end;

function TFhirImplementationGuidePackageResourceList.GetEnumerator : TFhirImplementationGuidePackageResourceListEnumerator;
begin
  result := TFhirImplementationGuidePackageResourceListEnumerator.Create(self.link);
end;

function TFhirImplementationGuidePackageResourceList.Clone: TFhirImplementationGuidePackageResourceList;
begin
  result := TFhirImplementationGuidePackageResourceList(inherited Clone);
end;

function TFhirImplementationGuidePackageResourceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImplementationGuidePackageResourceList.GetItemN(index: Integer): TFhirImplementationGuidePackageResource;
begin
  result := TFhirImplementationGuidePackageResource(ObjectByIndex[index]);
end;

function TFhirImplementationGuidePackageResourceList.ItemClass: TFslObjectClass;
begin
  result := TFhirImplementationGuidePackageResource;
end;
function TFhirImplementationGuidePackageResourceList.IndexOf(value: TFhirImplementationGuidePackageResource): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImplementationGuidePackageResourceList.Insert(index: Integer): TFhirImplementationGuidePackageResource;
begin
  result := TFhirImplementationGuidePackageResource.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuidePackageResourceList.InsertItem(index: Integer; value: TFhirImplementationGuidePackageResource);
begin
  assert(value is TFhirImplementationGuidePackageResource);
  Inherited Insert(index, value);
end;

function TFhirImplementationGuidePackageResourceList.Item(index: Integer): TFhirImplementationGuidePackageResource;
begin
  result := TFhirImplementationGuidePackageResource(ObjectByIndex[index]);
end;

function TFhirImplementationGuidePackageResourceList.Link: TFhirImplementationGuidePackageResourceList;
begin
  result := TFhirImplementationGuidePackageResourceList(inherited Link);
end;

procedure TFhirImplementationGuidePackageResourceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImplementationGuidePackageResourceList.SetItemByIndex(index: Integer; value: TFhirImplementationGuidePackageResource);
begin
  assert(value is TFhirImplementationGuidePackageResource);
  FhirImplementationGuidePackageResources[index] := value;
end;

procedure TFhirImplementationGuidePackageResourceList.SetItemN(index: Integer; value: TFhirImplementationGuidePackageResource);
begin
  assert(value is TFhirImplementationGuidePackageResource);
  ObjectByIndex[index] := value;
end;

{ TFhirImplementationGuideGlobal }

constructor TFhirImplementationGuideGlobal.Create;
begin
  inherited;
end;

destructor TFhirImplementationGuideGlobal.Destroy;
begin
  FType_.free;
  FProfile.free;
  inherited;
end;

procedure TFhirImplementationGuideGlobal.Assign(oSource : TFslObject);
begin
  inherited;
  FType_ := TFhirImplementationGuideGlobal(oSource).FType_.Link;
  profile := TFhirImplementationGuideGlobal(oSource).profile.Clone;
end;

procedure TFhirImplementationGuideGlobal.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'profile') Then
     list.add(self.link, 'profile', FProfile.Link);
end;

procedure TFhirImplementationGuideGlobal.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'profile', 'Reference(StructureDefinition)', false, TFhirReference{TFhirStructureDefinition}, FProfile.Link));{2}
end;

function TFhirImplementationGuideGlobal.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue);
    result := propValue
  end
  else if (propName = 'profile') then
  begin
    Profile := propValue as TFhirReference{TFhirStructureDefinition}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImplementationGuideGlobal.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirImplementationGuideGlobal.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'profile') then result := TFhirReference{TFhirStructureDefinition}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImplementationGuideGlobal.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'profile') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImplementationGuideGlobal.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'profile') then ProfileElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImplementationGuideGlobal.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, new){4}
  else if (propName = 'profile') then ProfileElement := new as TFhirReference{TFhirStructureDefinition}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImplementationGuideGlobal.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirImplementationGuideGlobal.fhirType : string;
begin
  result := 'global';
end;

function TFhirImplementationGuideGlobal.Link : TFhirImplementationGuideGlobal;
begin
  result := TFhirImplementationGuideGlobal(inherited Link);
end;

function TFhirImplementationGuideGlobal.Clone : TFhirImplementationGuideGlobal;
begin
  result := TFhirImplementationGuideGlobal(inherited Clone);
end;

function TFhirImplementationGuideGlobal.equals(other : TObject) : boolean;
var
  o : TFhirImplementationGuideGlobal;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImplementationGuideGlobal)) then
    result := false
  else
  begin
    o := TFhirImplementationGuideGlobal(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(profileElement, o.profileElement, true);
  end;
end;

function TFhirImplementationGuideGlobal.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FProfile);
end;

procedure TFhirImplementationGuideGlobal.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('profile');
end;

{ TFhirImplementationGuideGlobal }

Procedure TFhirImplementationGuideGlobal.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirImplementationGuideGlobal.GetType_ST : TFhirResourceTypesEnum;
begin
  if FType_ = nil then
    result := TFhirResourceTypesEnum(0)
  else
    result := TFhirResourceTypesEnum(StringArrayIndexOfSensitive(CODES_TFhirResourceTypesEnum, FType_.value));
end;

Procedure TFhirImplementationGuideGlobal.SetType_ST(value : TFhirResourceTypesEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirResourceTypesEnum[value], CODES_TFhirResourceTypesEnum[value]);
end;

Procedure TFhirImplementationGuideGlobal.SetProfile(value : TFhirReference{TFhirStructureDefinition});
begin
  FProfile.free;
  FProfile := value;
end;

function TFhirImplementationGuideGlobal.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FProfile.sizeInBytes);
end;

{ TFhirImplementationGuideGlobalListEnumerator }

Constructor TFhirImplementationGuideGlobalListEnumerator.Create(list : TFhirImplementationGuideGlobalList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImplementationGuideGlobalListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImplementationGuideGlobalListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImplementationGuideGlobalListEnumerator.GetCurrent : TFhirImplementationGuideGlobal;
begin
  Result := FList[FIndex];
end;

function TFhirImplementationGuideGlobalListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImplementationGuideGlobalList }
procedure TFhirImplementationGuideGlobalList.AddItem(value: TFhirImplementationGuideGlobal);
begin
  assert(value.ClassName = 'TFhirImplementationGuideGlobal', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImplementationGuideGlobal');
  add(value);
end;

function TFhirImplementationGuideGlobalList.Append: TFhirImplementationGuideGlobal;
begin
  result := TFhirImplementationGuideGlobal.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuideGlobalList.ClearItems;
begin
  Clear;
end;

function TFhirImplementationGuideGlobalList.GetEnumerator : TFhirImplementationGuideGlobalListEnumerator;
begin
  result := TFhirImplementationGuideGlobalListEnumerator.Create(self.link);
end;

function TFhirImplementationGuideGlobalList.Clone: TFhirImplementationGuideGlobalList;
begin
  result := TFhirImplementationGuideGlobalList(inherited Clone);
end;

function TFhirImplementationGuideGlobalList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImplementationGuideGlobalList.GetItemN(index: Integer): TFhirImplementationGuideGlobal;
begin
  result := TFhirImplementationGuideGlobal(ObjectByIndex[index]);
end;

function TFhirImplementationGuideGlobalList.ItemClass: TFslObjectClass;
begin
  result := TFhirImplementationGuideGlobal;
end;
function TFhirImplementationGuideGlobalList.IndexOf(value: TFhirImplementationGuideGlobal): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImplementationGuideGlobalList.Insert(index: Integer): TFhirImplementationGuideGlobal;
begin
  result := TFhirImplementationGuideGlobal.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuideGlobalList.InsertItem(index: Integer; value: TFhirImplementationGuideGlobal);
begin
  assert(value is TFhirImplementationGuideGlobal);
  Inherited Insert(index, value);
end;

function TFhirImplementationGuideGlobalList.Item(index: Integer): TFhirImplementationGuideGlobal;
begin
  result := TFhirImplementationGuideGlobal(ObjectByIndex[index]);
end;

function TFhirImplementationGuideGlobalList.Link: TFhirImplementationGuideGlobalList;
begin
  result := TFhirImplementationGuideGlobalList(inherited Link);
end;

procedure TFhirImplementationGuideGlobalList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImplementationGuideGlobalList.SetItemByIndex(index: Integer; value: TFhirImplementationGuideGlobal);
begin
  assert(value is TFhirImplementationGuideGlobal);
  FhirImplementationGuideGlobals[index] := value;
end;

procedure TFhirImplementationGuideGlobalList.SetItemN(index: Integer; value: TFhirImplementationGuideGlobal);
begin
  assert(value is TFhirImplementationGuideGlobal);
  ObjectByIndex[index] := value;
end;

{ TFhirImplementationGuidePage }

constructor TFhirImplementationGuidePage.Create;
begin
  inherited;
end;

destructor TFhirImplementationGuidePage.Destroy;
begin
  FSource.free;
  FTitle.free;
  FKind.free;
  FType_.Free;
  FPackageList.Free;
  FFormat.free;
  FPageList.Free;
  inherited;
end;

procedure TFhirImplementationGuidePage.Assign(oSource : TFslObject);
begin
  inherited;
  sourceElement := TFhirImplementationGuidePage(oSource).sourceElement.Clone;
  titleElement := TFhirImplementationGuidePage(oSource).titleElement.Clone;
  FKind := TFhirImplementationGuidePage(oSource).FKind.Link;
  if (TFhirImplementationGuidePage(oSource).FType_ = nil) then
  begin
    FType_.free;
    FType_ := nil;
  end
  else
  begin
    FType_ := TFHIREnumList.Create(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum);
    FType_.Assign(TFhirImplementationGuidePage(oSource).FType_);
  end;
  if (TFhirImplementationGuidePage(oSource).FPackageList = nil) then
  begin
    FPackageList.free;
    FPackageList := nil;
  end
  else
  begin
    if FPackageList = nil then
      FPackageList := TFhirStringList.Create;
    FPackageList.Assign(TFhirImplementationGuidePage(oSource).FPackageList);
  end;
  formatElement := TFhirImplementationGuidePage(oSource).formatElement.Clone;
  if (TFhirImplementationGuidePage(oSource).FPageList = nil) then
  begin
    FPageList.free;
    FPageList := nil;
  end
  else
  begin
    if FPageList = nil then
      FPageList := TFhirImplementationGuidePageList.Create;
    FPageList.Assign(TFhirImplementationGuidePage(oSource).FPageList);
  end;
end;

procedure TFhirImplementationGuidePage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'kind') Then
     list.add(self.link, 'kind', FKind.Link);
  if (child_name = 'type') Then
     list.addAll(self, 'type', FType_);
  if (child_name = 'package') Then
    list.addAll(self, 'package', FPackageList);
  if (child_name = 'format') Then
     list.add(self.link, 'format', FFormat.Link);
  if (child_name = 'page') Then
    list.addAll(self, 'page', FPageList);
end;

procedure TFhirImplementationGuidePage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'source', 'uri', false, TFhirUri, FSource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));{2}
  oList.add(TFHIRProperty.create(self, 'kind', 'code', false, TFHIREnum, FKind.Link));{1}
  oList.add(TFHIRProperty.create(self, 'type', 'code', true, TFHIREnum, FType_.Link)){3};
  oList.add(TFHIRProperty.create(self, 'package', 'string', true, TFhirString, FPackageList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'format', 'code', false, TFhirCode, FFormat.Link));{2}
  oList.add(TFHIRProperty.create(self, 'page', '@ImplementationGuide.page', true, TFhirImplementationGuidePage, FPageList.Link)){3};
end;

function TFhirImplementationGuidePage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'source') then
  begin
    SourceElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'kind') then
  begin
    KindElement := asEnum(SYSTEMS_TFhirGuidePageKindEnum, CODES_TFhirGuidePageKindEnum, propValue);
    result := propValue
  end
  else if (propName = 'type') then
  begin
    Type_List.add(asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue)); {1}
    result := propValue;
  end
  else if (propName = 'package') then
  begin
    PackageList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'format') then
  begin
    FormatElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'page') then
  begin
    PageList.add(propValue as TFhirImplementationGuidePage){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImplementationGuidePage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'type') then FType_.insertItem(index, asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue)) {1}
  else if (propName = 'package') then PackageList.insertItem(index, asString(propValue)){2}
  else if (propName = 'page') then PageList.insertItem(index, propValue as TFhirImplementationGuidePage){2a}
  else inherited;
end;

function TFhirImplementationGuidePage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'source') then result := TFhirUri.create() {5b}
  else if (propName = 'title') then result := TFhirString.create() {5b}
  else if (propName = 'package') then result := PackageList.new(){2}
  else if (propName = 'format') then result := TFhirCode.create() {5b}
  else if (propName = 'page') then result := PageList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImplementationGuidePage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'source') then result := 'uri'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'kind') then result := 'code'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'package') then result := 'string'
  else if (propName = 'format') then result := 'code'
  else if (propName = 'page') then result := '@ImplementationGuide.page'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImplementationGuidePage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'source') then SourceElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'kind') then KindElement := nil
  else if (propName = 'package') then deletePropertyValue('package', PackageList, value) {2}
  else if (propName = 'format') then FormatElement := nil
  else if (propName = 'page') then deletePropertyValue('page', PageList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImplementationGuidePage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'source') then SourceElement := asUri(new){5b}
  else if (propName = 'title') then TitleElement := asString(new){5b}
  else if (propName = 'kind') then KindElement := asEnum(SYSTEMS_TFhirGuidePageKindEnum, CODES_TFhirGuidePageKindEnum, new){4}
  else if (propName = 'package') then replacePropertyValue('package', PackageList, existing, new) {2}
  else if (propName = 'format') then FormatElement := asCode(new){5b}
  else if (propName = 'page') then replacePropertyValue('page', PageList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImplementationGuidePage.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'type') then FType_.move(source, destination) {1}
  else if (propName = 'package') then PackageList.move(source, destination){2}
  else if (propName = 'page') then PageList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImplementationGuidePage.fhirType : string;
begin
  result := 'page';
end;

function TFhirImplementationGuidePage.Link : TFhirImplementationGuidePage;
begin
  result := TFhirImplementationGuidePage(inherited Link);
end;

function TFhirImplementationGuidePage.Clone : TFhirImplementationGuidePage;
begin
  result := TFhirImplementationGuidePage(inherited Clone);
end;

function TFhirImplementationGuidePage.equals(other : TObject) : boolean;
var
  o : TFhirImplementationGuidePage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImplementationGuidePage)) then
    result := false
  else
  begin
    o := TFhirImplementationGuidePage(other);
    result := compareDeep(sourceElement, o.sourceElement, true) and compareDeep(titleElement, o.titleElement, true) and
      compareDeep(kindElement, o.kindElement, true) and compareDeep(type_List, o.type_List, true) and
      compareDeep(packageList, o.packageList, true) and compareDeep(formatElement, o.formatElement, true) and
      compareDeep(pageList, o.pageList, true);
  end;
end;

function TFhirImplementationGuidePage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSource) and isEmptyProp(FTitle) and isEmptyProp(FKind) and isEmptyProp(FType_) and isEmptyProp(FpackageList) and isEmptyProp(FFormat) and isEmptyProp(FpageList);
end;

procedure TFhirImplementationGuidePage.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('source');
  fields.add('title');
  fields.add('kind');
  fields.add('type');
  fields.add('package');
  fields.add('format');
  fields.add('page');
end;

{ TFhirImplementationGuidePage }

Procedure TFhirImplementationGuidePage.SetSource(value : TFhirUri);
begin
  FSource.free;
  FSource := value;
end;

Function TFhirImplementationGuidePage.GetSourceST : String;
begin
  if FSource = nil then
    result := ''
  else
    result := FSource.value;
end;

Procedure TFhirImplementationGuidePage.SetSourceST(value : String);
begin
  if value <> '' then
  begin
    if FSource = nil then
      FSource := TFhirUri.create;
    FSource.value := value
  end
  else if FSource <> nil then
    FSource.value := '';
end;

Procedure TFhirImplementationGuidePage.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

Function TFhirImplementationGuidePage.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

Procedure TFhirImplementationGuidePage.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

Procedure TFhirImplementationGuidePage.SetKind(value : TFhirEnum);
begin
  FKind.free;
  FKind := value;
end;

Function TFhirImplementationGuidePage.GetKindST : TFhirGuidePageKindEnum;
begin
  if FKind = nil then
    result := TFhirGuidePageKindEnum(0)
  else
    result := TFhirGuidePageKindEnum(StringArrayIndexOfSensitive(CODES_TFhirGuidePageKindEnum, FKind.value));
end;

Procedure TFhirImplementationGuidePage.SetKindST(value : TFhirGuidePageKindEnum);
begin
  if ord(value) = 0 then
    KindElement := nil
  else
    KindElement := TFhirEnum.create(SYSTEMS_TFhirGuidePageKindEnum[value], CODES_TFhirGuidePageKindEnum[value]);
end;

Function TFhirImplementationGuidePage.GetType_ : TFhirEnumList;
begin
  if FType_ = nil then
    FType_ := TFHIREnumList.Create(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum);
  result := FType_;
end;

Function TFhirImplementationGuidePage.GetHasType_ : boolean;
begin
  result := (FType_ <> nil) and (FType_.count > 0);
end;

Function TFhirImplementationGuidePage.GetPackageList : TFhirStringList;
begin
  if FPackageList = nil then
    FPackageList := TFhirStringList.Create;
  result := FPackageList;
end;

Function TFhirImplementationGuidePage.GetHasPackageList : boolean;
begin
  result := (FPackageList <> nil) and (FPackageList.count > 0);
end;

Procedure TFhirImplementationGuidePage.SetFormat(value : TFhirCode);
begin
  FFormat.free;
  FFormat := value;
end;

Function TFhirImplementationGuidePage.GetFormatST : String;
begin
  if FFormat = nil then
    result := ''
  else
    result := FFormat.value;
end;

Procedure TFhirImplementationGuidePage.SetFormatST(value : String);
begin
  if value <> '' then
  begin
    if FFormat = nil then
      FFormat := TFhirCode.create;
    FFormat.value := value
  end
  else if FFormat <> nil then
    FFormat.value := '';
end;

Function TFhirImplementationGuidePage.GetPageList : TFhirImplementationGuidePageList;
begin
  if FPageList = nil then
    FPageList := TFhirImplementationGuidePageList.Create;
  result := FPageList;
end;

Function TFhirImplementationGuidePage.GetHasPageList : boolean;
begin
  result := (FPageList <> nil) and (FPageList.count > 0);
end;

function TFhirImplementationGuidePage.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSource.sizeInBytes);
  inc(result, FTitle.sizeInBytes);
  inc(result, FKind.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FpackageList.sizeInBytes);
  inc(result, FFormat.sizeInBytes);
  inc(result, FpageList.sizeInBytes);
end;

{ TFhirImplementationGuidePageListEnumerator }

Constructor TFhirImplementationGuidePageListEnumerator.Create(list : TFhirImplementationGuidePageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImplementationGuidePageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImplementationGuidePageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImplementationGuidePageListEnumerator.GetCurrent : TFhirImplementationGuidePage;
begin
  Result := FList[FIndex];
end;

function TFhirImplementationGuidePageListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImplementationGuidePageList }
procedure TFhirImplementationGuidePageList.AddItem(value: TFhirImplementationGuidePage);
begin
  assert(value.ClassName = 'TFhirImplementationGuidePage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImplementationGuidePage');
  add(value);
end;

function TFhirImplementationGuidePageList.Append: TFhirImplementationGuidePage;
begin
  result := TFhirImplementationGuidePage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuidePageList.ClearItems;
begin
  Clear;
end;

function TFhirImplementationGuidePageList.GetEnumerator : TFhirImplementationGuidePageListEnumerator;
begin
  result := TFhirImplementationGuidePageListEnumerator.Create(self.link);
end;

function TFhirImplementationGuidePageList.Clone: TFhirImplementationGuidePageList;
begin
  result := TFhirImplementationGuidePageList(inherited Clone);
end;

function TFhirImplementationGuidePageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImplementationGuidePageList.GetItemN(index: Integer): TFhirImplementationGuidePage;
begin
  result := TFhirImplementationGuidePage(ObjectByIndex[index]);
end;

function TFhirImplementationGuidePageList.ItemClass: TFslObjectClass;
begin
  result := TFhirImplementationGuidePage;
end;
function TFhirImplementationGuidePageList.IndexOf(value: TFhirImplementationGuidePage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImplementationGuidePageList.Insert(index: Integer): TFhirImplementationGuidePage;
begin
  result := TFhirImplementationGuidePage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuidePageList.InsertItem(index: Integer; value: TFhirImplementationGuidePage);
begin
  assert(value is TFhirImplementationGuidePage);
  Inherited Insert(index, value);
end;

function TFhirImplementationGuidePageList.Item(index: Integer): TFhirImplementationGuidePage;
begin
  result := TFhirImplementationGuidePage(ObjectByIndex[index]);
end;

function TFhirImplementationGuidePageList.Link: TFhirImplementationGuidePageList;
begin
  result := TFhirImplementationGuidePageList(inherited Link);
end;

procedure TFhirImplementationGuidePageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImplementationGuidePageList.SetItemByIndex(index: Integer; value: TFhirImplementationGuidePage);
begin
  assert(value is TFhirImplementationGuidePage);
  FhirImplementationGuidePages[index] := value;
end;

procedure TFhirImplementationGuidePageList.SetItemN(index: Integer; value: TFhirImplementationGuidePage);
begin
  assert(value is TFhirImplementationGuidePage);
  ObjectByIndex[index] := value;
end;

{ TFhirImplementationGuide }

constructor TFhirImplementationGuide.Create;
begin
  inherited;
end;

destructor TFhirImplementationGuide.Destroy;
begin
  FCopyright.free;
  FFhirVersion.free;
  FDependencyList.Free;
  FPackageList.Free;
  FGlobalList.Free;
  FBinaryList.Free;
  FPage.free;
  inherited;
end;

function TFhirImplementationGuide.GetResourceType : TFhirResourceType;
begin
  result := frtImplementationGuide;
end;

procedure TFhirImplementationGuide.Assign(oSource : TFslObject);
begin
  inherited;
  copyrightElement := TFhirImplementationGuide(oSource).copyrightElement.Clone;
  fhirVersionElement := TFhirImplementationGuide(oSource).fhirVersionElement.Clone;
  if (TFhirImplementationGuide(oSource).FDependencyList = nil) then
  begin
    FDependencyList.free;
    FDependencyList := nil;
  end
  else
  begin
    if FDependencyList = nil then
      FDependencyList := TFhirImplementationGuideDependencyList.Create;
    FDependencyList.Assign(TFhirImplementationGuide(oSource).FDependencyList);
  end;
  if (TFhirImplementationGuide(oSource).FPackageList = nil) then
  begin
    FPackageList.free;
    FPackageList := nil;
  end
  else
  begin
    if FPackageList = nil then
      FPackageList := TFhirImplementationGuidePackageList.Create;
    FPackageList.Assign(TFhirImplementationGuide(oSource).FPackageList);
  end;
  if (TFhirImplementationGuide(oSource).FGlobalList = nil) then
  begin
    FGlobalList.free;
    FGlobalList := nil;
  end
  else
  begin
    if FGlobalList = nil then
      FGlobalList := TFhirImplementationGuideGlobalList.Create;
    FGlobalList.Assign(TFhirImplementationGuide(oSource).FGlobalList);
  end;
  if (TFhirImplementationGuide(oSource).FBinaryList = nil) then
  begin
    FBinaryList.free;
    FBinaryList := nil;
  end
  else
  begin
    if FBinaryList = nil then
      FBinaryList := TFhirUriList.Create;
    FBinaryList.Assign(TFhirImplementationGuide(oSource).FBinaryList);
  end;
  page := TFhirImplementationGuide(oSource).page.Clone;
end;

procedure TFhirImplementationGuide.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'fhirVersion') Then
     list.add(self.link, 'fhirVersion', FFhirVersion.Link);
  if (child_name = 'dependency') Then
    list.addAll(self, 'dependency', FDependencyList);
  if (child_name = 'package') Then
    list.addAll(self, 'package', FPackageList);
  if (child_name = 'global') Then
    list.addAll(self, 'global', FGlobalList);
  if (child_name = 'binary') Then
    list.addAll(self, 'binary', FBinaryList);
  if (child_name = 'page') Then
     list.add(self.link, 'page', FPage.Link);
end;

procedure TFhirImplementationGuide.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));{2}
  oList.add(TFHIRProperty.create(self, 'fhirVersion', 'id', false, TFhirId, FFhirVersion.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dependency', '', true, TFhirImplementationGuideDependency, FDependencyList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'package', '', true, TFhirImplementationGuidePackage, FPackageList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'global', '', true, TFhirImplementationGuideGlobal, FGlobalList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'binary', 'uri', true, TFhirUri, FBinaryList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'page', '', false, TFhirImplementationGuidePage, FPage.Link));{2}
end;

function TFhirImplementationGuide.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'fhirVersion') then
  begin
    FhirVersionElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'dependency') then
  begin
    DependencyList.add(propValue as TFhirImplementationGuideDependency){2a};
    result := propValue;
  end
  else if (propName = 'package') then
  begin
    PackageList.add(propValue as TFhirImplementationGuidePackage){2a};
    result := propValue;
  end
  else if (propName = 'global') then
  begin
    GlobalList.add(propValue as TFhirImplementationGuideGlobal){2a};
    result := propValue;
  end
  else if (propName = 'binary') then
  begin
    BinaryList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'page') then
  begin
    Page := propValue as TFhirImplementationGuidePage{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirImplementationGuide.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'dependency') then DependencyList.insertItem(index, propValue as TFhirImplementationGuideDependency){2a}
  else if (propName = 'package') then PackageList.insertItem(index, propValue as TFhirImplementationGuidePackage){2a}
  else if (propName = 'global') then GlobalList.insertItem(index, propValue as TFhirImplementationGuideGlobal){2a}
  else if (propName = 'binary') then BinaryList.insertItem(index, asUri(propValue)){2}
  else inherited;
end;

function TFhirImplementationGuide.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'copyright') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'fhirVersion') then result := TFhirId.create() {5b}
  else if (propName = 'dependency') then result := DependencyList.new(){2}
  else if (propName = 'package') then result := PackageList.new(){2}
  else if (propName = 'global') then result := GlobalList.new(){2}
  else if (propName = 'binary') then result := BinaryList.new(){2}
  else if (propName = 'page') then result := TFhirImplementationGuidePage.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirImplementationGuide.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'fhirVersion') then result := 'id'
  else if (propName = 'dependency') then result := ''
  else if (propName = 'package') then result := ''
  else if (propName = 'global') then result := ''
  else if (propName = 'binary') then result := 'uri'
  else if (propName = 'page') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImplementationGuide.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'fhirVersion') then FhirVersionElement := nil
  else if (propName = 'dependency') then deletePropertyValue('dependency', DependencyList, value) {2}
  else if (propName = 'package') then deletePropertyValue('package', PackageList, value) {2}
  else if (propName = 'global') then deletePropertyValue('global', GlobalList, value) {2}
  else if (propName = 'binary') then deletePropertyValue('binary', BinaryList, value) {2}
  else if (propName = 'page') then PageElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImplementationGuide.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'copyright') then CopyrightElement := asMarkdown(new){5b}
  else if (propName = 'fhirVersion') then FhirVersionElement := asId(new){5b}
  else if (propName = 'dependency') then replacePropertyValue('dependency', DependencyList, existing, new) {2}
  else if (propName = 'package') then replacePropertyValue('package', PackageList, existing, new) {2}
  else if (propName = 'global') then replacePropertyValue('global', GlobalList, existing, new) {2}
  else if (propName = 'binary') then replacePropertyValue('binary', BinaryList, existing, new) {2}
  else if (propName = 'page') then PageElement := new as TFhirImplementationGuidePage{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImplementationGuide.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'dependency') then DependencyList.move(source, destination){2a}
  else if (propName = 'package') then PackageList.move(source, destination){2a}
  else if (propName = 'global') then GlobalList.move(source, destination){2a}
  else if (propName = 'binary') then BinaryList.move(source, destination){2}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImplementationGuide.fhirType : string;
begin
  result := 'ImplementationGuide';
end;

function TFhirImplementationGuide.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCopyright) and isEmptyProp(FFhirVersion) and isEmptyProp(FdependencyList) and isEmptyProp(FpackageList) and isEmptyProp(FglobalList) and isEmptyProp(FbinaryList) and isEmptyProp(FPage);
end;

function TFhirImplementationGuide.equals(other : TObject) : boolean;
var
  o : TFhirImplementationGuide;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImplementationGuide)) then
    result := false
  else
  begin
    o := TFhirImplementationGuide(other);
    result := compareDeep(copyrightElement, o.copyrightElement, true) and compareDeep(fhirVersionElement, o.fhirVersionElement, true) and
      compareDeep(dependencyList, o.dependencyList, true) and compareDeep(packageList, o.packageList, true) and
      compareDeep(globalList, o.globalList, true) and compareDeep(binaryList, o.binaryList, true) and
      compareDeep(pageElement, o.pageElement, true);
  end;
end;

function TFhirImplementationGuide.Link : TFhirImplementationGuide;
begin
  result := TFhirImplementationGuide(inherited Link);
end;

function TFhirImplementationGuide.Clone : TFhirImplementationGuide;
begin
  result := TFhirImplementationGuide(inherited Clone);
end;

procedure TFhirImplementationGuide.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('url');
  fields.add('version');
  fields.add('name');
  fields.add('status');
  fields.add('experimental');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('copyright');
  fields.add('fhirVersion');
  fields.add('dependency');
  fields.add('package');
  fields.add('global');
  fields.add('binary');
  fields.add('page');
end;

{ TFhirImplementationGuide }

Procedure TFhirImplementationGuide.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

Function TFhirImplementationGuide.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

Procedure TFhirImplementationGuide.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

Procedure TFhirImplementationGuide.SetFhirVersion(value : TFhirId);
begin
  FFhirVersion.free;
  FFhirVersion := value;
end;

Function TFhirImplementationGuide.GetFhirVersionST : String;
begin
  if FFhirVersion = nil then
    result := ''
  else
    result := FFhirVersion.value;
end;

Procedure TFhirImplementationGuide.SetFhirVersionST(value : String);
begin
  if value <> '' then
  begin
    if FFhirVersion = nil then
      FFhirVersion := TFhirId.create;
    FFhirVersion.value := value
  end
  else if FFhirVersion <> nil then
    FFhirVersion.value := '';
end;

Function TFhirImplementationGuide.GetDependencyList : TFhirImplementationGuideDependencyList;
begin
  if FDependencyList = nil then
    FDependencyList := TFhirImplementationGuideDependencyList.Create;
  result := FDependencyList;
end;

Function TFhirImplementationGuide.GetHasDependencyList : boolean;
begin
  result := (FDependencyList <> nil) and (FDependencyList.count > 0);
end;

Function TFhirImplementationGuide.GetPackageList : TFhirImplementationGuidePackageList;
begin
  if FPackageList = nil then
    FPackageList := TFhirImplementationGuidePackageList.Create;
  result := FPackageList;
end;

Function TFhirImplementationGuide.GetHasPackageList : boolean;
begin
  result := (FPackageList <> nil) and (FPackageList.count > 0);
end;

Function TFhirImplementationGuide.GetGlobalList : TFhirImplementationGuideGlobalList;
begin
  if FGlobalList = nil then
    FGlobalList := TFhirImplementationGuideGlobalList.Create;
  result := FGlobalList;
end;

Function TFhirImplementationGuide.GetHasGlobalList : boolean;
begin
  result := (FGlobalList <> nil) and (FGlobalList.count > 0);
end;

Function TFhirImplementationGuide.GetBinaryList : TFhirUriList;
begin
  if FBinaryList = nil then
    FBinaryList := TFhirUriList.Create;
  result := FBinaryList;
end;

Function TFhirImplementationGuide.GetHasBinaryList : boolean;
begin
  result := (FBinaryList <> nil) and (FBinaryList.count > 0);
end;

Procedure TFhirImplementationGuide.SetPage(value : TFhirImplementationGuidePage);
begin
  FPage.free;
  FPage := value;
end;

function TFhirImplementationGuide.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCopyright.sizeInBytes);
  inc(result, FFhirVersion.sizeInBytes);
  inc(result, FdependencyList.sizeInBytes);
  inc(result, FpackageList.sizeInBytes);
  inc(result, FglobalList.sizeInBytes);
  inc(result, FbinaryList.sizeInBytes);
  inc(result, FPage.sizeInBytes);
end;

{ TFhirImplementationGuideListEnumerator }

Constructor TFhirImplementationGuideListEnumerator.Create(list : TFhirImplementationGuideList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImplementationGuideListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImplementationGuideListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImplementationGuideListEnumerator.GetCurrent : TFhirImplementationGuide;
begin
  Result := FList[FIndex];
end;

function TFhirImplementationGuideListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirImplementationGuideList }
procedure TFhirImplementationGuideList.AddItem(value: TFhirImplementationGuide);
begin
  assert(value.ClassName = 'TFhirImplementationGuide', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImplementationGuide');
  add(value);
end;

function TFhirImplementationGuideList.Append: TFhirImplementationGuide;
begin
  result := TFhirImplementationGuide.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuideList.ClearItems;
begin
  Clear;
end;

function TFhirImplementationGuideList.GetEnumerator : TFhirImplementationGuideListEnumerator;
begin
  result := TFhirImplementationGuideListEnumerator.Create(self.link);
end;

function TFhirImplementationGuideList.Clone: TFhirImplementationGuideList;
begin
  result := TFhirImplementationGuideList(inherited Clone);
end;

function TFhirImplementationGuideList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImplementationGuideList.GetItemN(index: Integer): TFhirImplementationGuide;
begin
  result := TFhirImplementationGuide(ObjectByIndex[index]);
end;

function TFhirImplementationGuideList.ItemClass: TFslObjectClass;
begin
  result := TFhirImplementationGuide;
end;
function TFhirImplementationGuideList.IndexOf(value: TFhirImplementationGuide): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImplementationGuideList.Insert(index: Integer): TFhirImplementationGuide;
begin
  result := TFhirImplementationGuide.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImplementationGuideList.InsertItem(index: Integer; value: TFhirImplementationGuide);
begin
  assert(value is TFhirImplementationGuide);
  Inherited Insert(index, value);
end;

function TFhirImplementationGuideList.Item(index: Integer): TFhirImplementationGuide;
begin
  result := TFhirImplementationGuide(ObjectByIndex[index]);
end;

function TFhirImplementationGuideList.Link: TFhirImplementationGuideList;
begin
  result := TFhirImplementationGuideList(inherited Link);
end;

procedure TFhirImplementationGuideList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImplementationGuideList.SetItemByIndex(index: Integer; value: TFhirImplementationGuide);
begin
  assert(value is TFhirImplementationGuide);
  FhirImplementationGuides[index] := value;
end;

procedure TFhirImplementationGuideList.SetItemN(index: Integer; value: TFhirImplementationGuide);
begin
  assert(value is TFhirImplementationGuide);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_IMPLEMENTATIONGUIDE}

{$IFDEF FHIR_LIBRARY}

{ TFhirLibrary }

constructor TFhirLibrary.Create;
begin
  inherited;
end;

destructor TFhirLibrary.Destroy;
begin
  FIdentifierList.Free;
  FType_.free;
  FPurpose.free;
  FUsage.free;
  FApprovalDate.free;
  FLastReviewDate.free;
  FEffectivePeriod.free;
  FTopicList.Free;
  FContributorList.Free;
  FCopyright.free;
  FRelatedArtifactList.Free;
  FParameterList.Free;
  FDataRequirementList.Free;
  FContentList.Free;
  inherited;
end;

function TFhirLibrary.GetResourceType : TFhirResourceType;
begin
  result := frtLibrary;
end;

procedure TFhirLibrary.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirLibrary(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirLibrary(oSource).FIdentifierList);
  end;
  type_ := TFhirLibrary(oSource).type_.Clone;
  purposeElement := TFhirLibrary(oSource).purposeElement.Clone;
  usageElement := TFhirLibrary(oSource).usageElement.Clone;
  approvalDateElement := TFhirLibrary(oSource).approvalDateElement.Clone;
  lastReviewDateElement := TFhirLibrary(oSource).lastReviewDateElement.Clone;
  effectivePeriod := TFhirLibrary(oSource).effectivePeriod.Clone;
  if (TFhirLibrary(oSource).FTopicList = nil) then
  begin
    FTopicList.free;
    FTopicList := nil;
  end
  else
  begin
    if FTopicList = nil then
      FTopicList := TFhirCodeableConceptList.Create;
    FTopicList.Assign(TFhirLibrary(oSource).FTopicList);
  end;
  if (TFhirLibrary(oSource).FContributorList = nil) then
  begin
    FContributorList.free;
    FContributorList := nil;
  end
  else
  begin
    if FContributorList = nil then
      FContributorList := TFhirContributorList.Create;
    FContributorList.Assign(TFhirLibrary(oSource).FContributorList);
  end;
  copyrightElement := TFhirLibrary(oSource).copyrightElement.Clone;
  if (TFhirLibrary(oSource).FRelatedArtifactList = nil) then
  begin
    FRelatedArtifactList.free;
    FRelatedArtifactList := nil;
  end
  else
  begin
    if FRelatedArtifactList = nil then
      FRelatedArtifactList := TFhirRelatedArtifactList.Create;
    FRelatedArtifactList.Assign(TFhirLibrary(oSource).FRelatedArtifactList);
  end;
  if (TFhirLibrary(oSource).FParameterList = nil) then
  begin
    FParameterList.free;
    FParameterList := nil;
  end
  else
  begin
    if FParameterList = nil then
      FParameterList := TFhirParameterDefinitionList.Create;
    FParameterList.Assign(TFhirLibrary(oSource).FParameterList);
  end;
  if (TFhirLibrary(oSource).FDataRequirementList = nil) then
  begin
    FDataRequirementList.free;
    FDataRequirementList := nil;
  end
  else
  begin
    if FDataRequirementList = nil then
      FDataRequirementList := TFhirDataRequirementList.Create;
    FDataRequirementList.Assign(TFhirLibrary(oSource).FDataRequirementList);
  end;
  if (TFhirLibrary(oSource).FContentList = nil) then
  begin
    FContentList.free;
    FContentList := nil;
  end
  else
  begin
    if FContentList = nil then
      FContentList := TFhirAttachmentList.Create;
    FContentList.Assign(TFhirLibrary(oSource).FContentList);
  end;
end;

procedure TFhirLibrary.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'usage') Then
     list.add(self.link, 'usage', FUsage.Link);
  if (child_name = 'approvalDate') Then
     list.add(self.link, 'approvalDate', FApprovalDate.Link);
  if (child_name = 'lastReviewDate') Then
     list.add(self.link, 'lastReviewDate', FLastReviewDate.Link);
  if (child_name = 'effectivePeriod') Then
     list.add(self.link, 'effectivePeriod', FEffectivePeriod.Link);
  if (child_name = 'topic') Then
    list.addAll(self, 'topic', FTopicList);
  if (child_name = 'contributor') Then
    list.addAll(self, 'contributor', FContributorList);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'relatedArtifact') Then
    list.addAll(self, 'relatedArtifact', FRelatedArtifactList);
  if (child_name = 'parameter') Then
    list.addAll(self, 'parameter', FParameterList);
  if (child_name = 'dataRequirement') Then
    list.addAll(self, 'dataRequirement', FDataRequirementList);
  if (child_name = 'content') Then
    list.addAll(self, 'content', FContentList);
end;

procedure TFhirLibrary.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));{2}
  oList.add(TFHIRProperty.create(self, 'usage', 'string', false, TFhirString, FUsage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'approvalDate', 'date', false, TFhirDate, FApprovalDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'lastReviewDate', 'date', false, TFhirDate, FLastReviewDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'effectivePeriod', 'Period', false, TFhirPeriod, FEffectivePeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'topic', 'CodeableConcept', true, TFhirCodeableConcept, FTopicList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'contributor', 'Contributor', true, TFhirContributor, FContributorList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));{2}
  oList.add(TFHIRProperty.create(self, 'relatedArtifact', 'RelatedArtifact', true, TFhirRelatedArtifact, FRelatedArtifactList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'parameter', 'ParameterDefinition', true, TFhirParameterDefinition, FParameterList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'dataRequirement', 'DataRequirement', true, TFhirDataRequirement, FDataRequirementList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'content', 'Attachment', true, TFhirAttachment, FContentList.Link)){3};
end;

function TFhirLibrary.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'usage') then
  begin
    UsageElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'approvalDate') then
  begin
    ApprovalDateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'lastReviewDate') then
  begin
    LastReviewDateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'effectivePeriod') then
  begin
    EffectivePeriod := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'topic') then
  begin
    TopicList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'contributor') then
  begin
    ContributorList.add(propValue as TFhirContributor){2a};
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'relatedArtifact') then
  begin
    RelatedArtifactList.add(propValue as TFhirRelatedArtifact){2a};
    result := propValue;
  end
  else if (propName = 'parameter') then
  begin
    ParameterList.add(propValue as TFhirParameterDefinition){2a};
    result := propValue;
  end
  else if (propName = 'dataRequirement') then
  begin
    DataRequirementList.add(propValue as TFhirDataRequirement){2a};
    result := propValue;
  end
  else if (propName = 'content') then
  begin
    ContentList.add(propValue as TFhirAttachment){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirLibrary.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'topic') then TopicList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'contributor') then ContributorList.insertItem(index, propValue as TFhirContributor){2a}
  else if (propName = 'relatedArtifact') then RelatedArtifactList.insertItem(index, propValue as TFhirRelatedArtifact){2a}
  else if (propName = 'parameter') then ParameterList.insertItem(index, propValue as TFhirParameterDefinition){2a}
  else if (propName = 'dataRequirement') then DataRequirementList.insertItem(index, propValue as TFhirDataRequirement){2a}
  else if (propName = 'content') then ContentList.insertItem(index, propValue as TFhirAttachment){2a}
  else inherited;
end;

function TFhirLibrary.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'purpose') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'usage') then result := TFhirString.create() {5b}
  else if (propName = 'approvalDate') then result := TFhirDate.create() {5b}
  else if (propName = 'lastReviewDate') then result := TFhirDate.create() {5b}
  else if (propName = 'effectivePeriod') then result := TFhirPeriod.create(){4b}
  else if (propName = 'topic') then result := TopicList.new(){2}
  else if (propName = 'contributor') then result := ContributorList.new(){2}
  else if (propName = 'copyright') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'relatedArtifact') then result := RelatedArtifactList.new(){2}
  else if (propName = 'parameter') then result := ParameterList.new(){2}
  else if (propName = 'dataRequirement') then result := DataRequirementList.new(){2}
  else if (propName = 'content') then result := ContentList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirLibrary.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'usage') then result := 'string'
  else if (propName = 'approvalDate') then result := 'date'
  else if (propName = 'lastReviewDate') then result := 'date'
  else if (propName = 'effectivePeriod') then result := 'Period'
  else if (propName = 'topic') then result := 'CodeableConcept'
  else if (propName = 'contributor') then result := 'Contributor'
  else if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'relatedArtifact') then result := 'RelatedArtifact'
  else if (propName = 'parameter') then result := 'ParameterDefinition'
  else if (propName = 'dataRequirement') then result := 'DataRequirement'
  else if (propName = 'content') then result := 'Attachment'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirLibrary.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'usage') then UsageElement := nil
  else if (propName = 'approvalDate') then ApprovalDateElement := nil
  else if (propName = 'lastReviewDate') then LastReviewDateElement := nil
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := nil
  else if (propName = 'topic') then deletePropertyValue('topic', TopicList, value) {2}
  else if (propName = 'contributor') then deletePropertyValue('contributor', ContributorList, value) {2}
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'relatedArtifact') then deletePropertyValue('relatedArtifact', RelatedArtifactList, value) {2}
  else if (propName = 'parameter') then deletePropertyValue('parameter', ParameterList, value) {2}
  else if (propName = 'dataRequirement') then deletePropertyValue('dataRequirement', DataRequirementList, value) {2}
  else if (propName = 'content') then deletePropertyValue('content', ContentList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirLibrary.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'purpose') then PurposeElement := asMarkdown(new){5b}
  else if (propName = 'usage') then UsageElement := asString(new){5b}
  else if (propName = 'approvalDate') then ApprovalDateElement := asDate(new){5b}
  else if (propName = 'lastReviewDate') then LastReviewDateElement := asDate(new){5b}
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := new as TFhirPeriod{4}
  else if (propName = 'topic') then replacePropertyValue('topic', TopicList, existing, new) {2}
  else if (propName = 'contributor') then replacePropertyValue('contributor', ContributorList, existing, new) {2}
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new){5b}
  else if (propName = 'relatedArtifact') then replacePropertyValue('relatedArtifact', RelatedArtifactList, existing, new) {2}
  else if (propName = 'parameter') then replacePropertyValue('parameter', ParameterList, existing, new) {2}
  else if (propName = 'dataRequirement') then replacePropertyValue('dataRequirement', DataRequirementList, existing, new) {2}
  else if (propName = 'content') then replacePropertyValue('content', ContentList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirLibrary.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'topic') then TopicList.move(source, destination){2a}
  else if (propName = 'contributor') then ContributorList.move(source, destination){2a}
  else if (propName = 'relatedArtifact') then RelatedArtifactList.move(source, destination){2a}
  else if (propName = 'parameter') then ParameterList.move(source, destination){2a}
  else if (propName = 'dataRequirement') then DataRequirementList.move(source, destination){2a}
  else if (propName = 'content') then ContentList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirLibrary.fhirType : string;
begin
  result := 'Library';
end;

function TFhirLibrary.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FType_) and isEmptyProp(FPurpose) and isEmptyProp(FUsage) and isEmptyProp(FApprovalDate) and isEmptyProp(FLastReviewDate) and isEmptyProp(FEffectivePeriod) and isEmptyProp(FtopicList) and isEmptyProp(FcontributorList) and isEmptyProp(FCopyright) and isEmptyProp(FrelatedArtifactList) and isEmptyProp(FparameterList) and isEmptyProp(FdataRequirementList) and isEmptyProp(FcontentList);
end;

function TFhirLibrary.equals(other : TObject) : boolean;
var
  o : TFhirLibrary;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirLibrary)) then
    result := false
  else
  begin
    o := TFhirLibrary(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(type_Element, o.type_Element, true) and
      compareDeep(purposeElement, o.purposeElement, true) and compareDeep(usageElement, o.usageElement, true) and
      compareDeep(approvalDateElement, o.approvalDateElement, true) and compareDeep(lastReviewDateElement, o.lastReviewDateElement, true) and
      compareDeep(effectivePeriodElement, o.effectivePeriodElement, true) and compareDeep(topicList, o.topicList, true) and
      compareDeep(contributorList, o.contributorList, true) and compareDeep(copyrightElement, o.copyrightElement, true) and
      compareDeep(relatedArtifactList, o.relatedArtifactList, true) and compareDeep(parameterList, o.parameterList, true) and
      compareDeep(dataRequirementList, o.dataRequirementList, true) and compareDeep(contentList, o.contentList, true);
  end;
end;

function TFhirLibrary.Link : TFhirLibrary;
begin
  result := TFhirLibrary(inherited Link);
end;

function TFhirLibrary.Clone : TFhirLibrary;
begin
  result := TFhirLibrary(inherited Clone);
end;

procedure TFhirLibrary.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('status');
  fields.add('experimental');
  fields.add('type');
  fields.add('date');
  fields.add('publisher');
  fields.add('description');
  fields.add('purpose');
  fields.add('usage');
  fields.add('approvalDate');
  fields.add('lastReviewDate');
  fields.add('effectivePeriod');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('topic');
  fields.add('contributor');
  fields.add('contact');
  fields.add('copyright');
  fields.add('relatedArtifact');
  fields.add('parameter');
  fields.add('dataRequirement');
  fields.add('content');
end;

{ TFhirLibrary }

Function TFhirLibrary.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirLibrary.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirLibrary.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirLibrary.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

Function TFhirLibrary.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

Procedure TFhirLibrary.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

Procedure TFhirLibrary.SetUsage(value : TFhirString);
begin
  FUsage.free;
  FUsage := value;
end;

Function TFhirLibrary.GetUsageST : String;
begin
  if FUsage = nil then
    result := ''
  else
    result := FUsage.value;
end;

Procedure TFhirLibrary.SetUsageST(value : String);
begin
  if value <> '' then
  begin
    if FUsage = nil then
      FUsage := TFhirString.create;
    FUsage.value := value
  end
  else if FUsage <> nil then
    FUsage.value := '';
end;

Procedure TFhirLibrary.SetApprovalDate(value : TFhirDate);
begin
  FApprovalDate.free;
  FApprovalDate := value;
end;

Function TFhirLibrary.GetApprovalDateST : TFslDateTime;
begin
  if FApprovalDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FApprovalDate.value;
end;

Procedure TFhirLibrary.SetApprovalDateST(value : TFslDateTime);
begin
  if FApprovalDate = nil then
    FApprovalDate := TFhirDate.create;
  FApprovalDate.value := value
end;

Procedure TFhirLibrary.SetLastReviewDate(value : TFhirDate);
begin
  FLastReviewDate.free;
  FLastReviewDate := value;
end;

Function TFhirLibrary.GetLastReviewDateST : TFslDateTime;
begin
  if FLastReviewDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastReviewDate.value;
end;

Procedure TFhirLibrary.SetLastReviewDateST(value : TFslDateTime);
begin
  if FLastReviewDate = nil then
    FLastReviewDate := TFhirDate.create;
  FLastReviewDate.value := value
end;

Procedure TFhirLibrary.SetEffectivePeriod(value : TFhirPeriod);
begin
  FEffectivePeriod.free;
  FEffectivePeriod := value;
end;

Function TFhirLibrary.GetTopicList : TFhirCodeableConceptList;
begin
  if FTopicList = nil then
    FTopicList := TFhirCodeableConceptList.Create;
  result := FTopicList;
end;

Function TFhirLibrary.GetHasTopicList : boolean;
begin
  result := (FTopicList <> nil) and (FTopicList.count > 0);
end;

Function TFhirLibrary.GetContributorList : TFhirContributorList;
begin
  if FContributorList = nil then
    FContributorList := TFhirContributorList.Create;
  result := FContributorList;
end;

Function TFhirLibrary.GetHasContributorList : boolean;
begin
  result := (FContributorList <> nil) and (FContributorList.count > 0);
end;

Procedure TFhirLibrary.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

Function TFhirLibrary.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

Procedure TFhirLibrary.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

Function TFhirLibrary.GetRelatedArtifactList : TFhirRelatedArtifactList;
begin
  if FRelatedArtifactList = nil then
    FRelatedArtifactList := TFhirRelatedArtifactList.Create;
  result := FRelatedArtifactList;
end;

Function TFhirLibrary.GetHasRelatedArtifactList : boolean;
begin
  result := (FRelatedArtifactList <> nil) and (FRelatedArtifactList.count > 0);
end;

Function TFhirLibrary.GetParameterList : TFhirParameterDefinitionList;
begin
  if FParameterList = nil then
    FParameterList := TFhirParameterDefinitionList.Create;
  result := FParameterList;
end;

Function TFhirLibrary.GetHasParameterList : boolean;
begin
  result := (FParameterList <> nil) and (FParameterList.count > 0);
end;

Function TFhirLibrary.GetDataRequirementList : TFhirDataRequirementList;
begin
  if FDataRequirementList = nil then
    FDataRequirementList := TFhirDataRequirementList.Create;
  result := FDataRequirementList;
end;

Function TFhirLibrary.GetHasDataRequirementList : boolean;
begin
  result := (FDataRequirementList <> nil) and (FDataRequirementList.count > 0);
end;

Function TFhirLibrary.GetContentList : TFhirAttachmentList;
begin
  if FContentList = nil then
    FContentList := TFhirAttachmentList.Create;
  result := FContentList;
end;

Function TFhirLibrary.GetHasContentList : boolean;
begin
  result := (FContentList <> nil) and (FContentList.count > 0);
end;

function TFhirLibrary.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FPurpose.sizeInBytes);
  inc(result, FUsage.sizeInBytes);
  inc(result, FApprovalDate.sizeInBytes);
  inc(result, FLastReviewDate.sizeInBytes);
  inc(result, FEffectivePeriod.sizeInBytes);
  inc(result, FtopicList.sizeInBytes);
  inc(result, FcontributorList.sizeInBytes);
  inc(result, FCopyright.sizeInBytes);
  inc(result, FrelatedArtifactList.sizeInBytes);
  inc(result, FparameterList.sizeInBytes);
  inc(result, FdataRequirementList.sizeInBytes);
  inc(result, FcontentList.sizeInBytes);
end;

{ TFhirLibraryListEnumerator }

Constructor TFhirLibraryListEnumerator.Create(list : TFhirLibraryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirLibraryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirLibraryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirLibraryListEnumerator.GetCurrent : TFhirLibrary;
begin
  Result := FList[FIndex];
end;

function TFhirLibraryListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirLibraryList }
procedure TFhirLibraryList.AddItem(value: TFhirLibrary);
begin
  assert(value.ClassName = 'TFhirLibrary', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirLibrary');
  add(value);
end;

function TFhirLibraryList.Append: TFhirLibrary;
begin
  result := TFhirLibrary.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirLibraryList.ClearItems;
begin
  Clear;
end;

function TFhirLibraryList.GetEnumerator : TFhirLibraryListEnumerator;
begin
  result := TFhirLibraryListEnumerator.Create(self.link);
end;

function TFhirLibraryList.Clone: TFhirLibraryList;
begin
  result := TFhirLibraryList(inherited Clone);
end;

function TFhirLibraryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirLibraryList.GetItemN(index: Integer): TFhirLibrary;
begin
  result := TFhirLibrary(ObjectByIndex[index]);
end;

function TFhirLibraryList.ItemClass: TFslObjectClass;
begin
  result := TFhirLibrary;
end;
function TFhirLibraryList.IndexOf(value: TFhirLibrary): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirLibraryList.Insert(index: Integer): TFhirLibrary;
begin
  result := TFhirLibrary.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirLibraryList.InsertItem(index: Integer; value: TFhirLibrary);
begin
  assert(value is TFhirLibrary);
  Inherited Insert(index, value);
end;

function TFhirLibraryList.Item(index: Integer): TFhirLibrary;
begin
  result := TFhirLibrary(ObjectByIndex[index]);
end;

function TFhirLibraryList.Link: TFhirLibraryList;
begin
  result := TFhirLibraryList(inherited Link);
end;

procedure TFhirLibraryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirLibraryList.SetItemByIndex(index: Integer; value: TFhirLibrary);
begin
  assert(value is TFhirLibrary);
  FhirLibraries[index] := value;
end;

procedure TFhirLibraryList.SetItemN(index: Integer; value: TFhirLibrary);
begin
  assert(value is TFhirLibrary);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_LIBRARY}

{$IFDEF FHIR_MEASURE}

{ TFhirMeasureGroup }

constructor TFhirMeasureGroup.Create;
begin
  inherited;
end;

destructor TFhirMeasureGroup.Destroy;
begin
  FIdentifier.free;
  FName.free;
  FDescription.free;
  FPopulationList.Free;
  FStratifierList.Free;
  inherited;
end;

procedure TFhirMeasureGroup.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirMeasureGroup(oSource).identifier.Clone;
  nameElement := TFhirMeasureGroup(oSource).nameElement.Clone;
  descriptionElement := TFhirMeasureGroup(oSource).descriptionElement.Clone;
  if (TFhirMeasureGroup(oSource).FPopulationList = nil) then
  begin
    FPopulationList.free;
    FPopulationList := nil;
  end
  else
  begin
    if FPopulationList = nil then
      FPopulationList := TFhirMeasureGroupPopulationList.Create;
    FPopulationList.Assign(TFhirMeasureGroup(oSource).FPopulationList);
  end;
  if (TFhirMeasureGroup(oSource).FStratifierList = nil) then
  begin
    FStratifierList.free;
    FStratifierList := nil;
  end
  else
  begin
    if FStratifierList = nil then
      FStratifierList := TFhirMeasureGroupStratifierList.Create;
    FStratifierList.Assign(TFhirMeasureGroup(oSource).FStratifierList);
  end;
end;

procedure TFhirMeasureGroup.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'population') Then
    list.addAll(self, 'population', FPopulationList);
  if (child_name = 'stratifier') Then
    list.addAll(self, 'stratifier', FStratifierList);
end;

procedure TFhirMeasureGroup.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'population', '', true, TFhirMeasureGroupPopulation, FPopulationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'stratifier', '', true, TFhirMeasureGroupStratifier, FStratifierList.Link)){3};
end;

function TFhirMeasureGroup.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'population') then
  begin
    PopulationList.add(propValue as TFhirMeasureGroupPopulation){2a};
    result := propValue;
  end
  else if (propName = 'stratifier') then
  begin
    StratifierList.add(propValue as TFhirMeasureGroupStratifier){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMeasureGroup.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'population') then PopulationList.insertItem(index, propValue as TFhirMeasureGroupPopulation){2a}
  else if (propName = 'stratifier') then StratifierList.insertItem(index, propValue as TFhirMeasureGroupStratifier){2a}
  else inherited;
end;

function TFhirMeasureGroup.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'population') then result := PopulationList.new(){2}
  else if (propName = 'stratifier') then result := StratifierList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMeasureGroup.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'population') then result := ''
  else if (propName = 'stratifier') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMeasureGroup.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'population') then deletePropertyValue('population', PopulationList, value) {2}
  else if (propName = 'stratifier') then deletePropertyValue('stratifier', StratifierList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMeasureGroup.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'population') then replacePropertyValue('population', PopulationList, existing, new) {2}
  else if (propName = 'stratifier') then replacePropertyValue('stratifier', StratifierList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMeasureGroup.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'population') then PopulationList.move(source, destination){2a}
  else if (propName = 'stratifier') then StratifierList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMeasureGroup.fhirType : string;
begin
  result := 'group';
end;

function TFhirMeasureGroup.Link : TFhirMeasureGroup;
begin
  result := TFhirMeasureGroup(inherited Link);
end;

function TFhirMeasureGroup.Clone : TFhirMeasureGroup;
begin
  result := TFhirMeasureGroup(inherited Clone);
end;

function TFhirMeasureGroup.equals(other : TObject) : boolean;
var
  o : TFhirMeasureGroup;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMeasureGroup)) then
    result := false
  else
  begin
    o := TFhirMeasureGroup(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(nameElement, o.nameElement, true) and
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(populationList, o.populationList, true) and
      compareDeep(stratifierList, o.stratifierList, true);
  end;
end;

function TFhirMeasureGroup.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FName) and isEmptyProp(FDescription) and isEmptyProp(FpopulationList) and isEmptyProp(FstratifierList);
end;

procedure TFhirMeasureGroup.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('name');
  fields.add('description');
  fields.add('population');
  fields.add('stratifier');
end;

{ TFhirMeasureGroup }

Procedure TFhirMeasureGroup.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirMeasureGroup.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirMeasureGroup.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirMeasureGroup.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirMeasureGroup.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirMeasureGroup.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirMeasureGroup.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Function TFhirMeasureGroup.GetPopulationList : TFhirMeasureGroupPopulationList;
begin
  if FPopulationList = nil then
    FPopulationList := TFhirMeasureGroupPopulationList.Create;
  result := FPopulationList;
end;

Function TFhirMeasureGroup.GetHasPopulationList : boolean;
begin
  result := (FPopulationList <> nil) and (FPopulationList.count > 0);
end;

Function TFhirMeasureGroup.GetStratifierList : TFhirMeasureGroupStratifierList;
begin
  if FStratifierList = nil then
    FStratifierList := TFhirMeasureGroupStratifierList.Create;
  result := FStratifierList;
end;

Function TFhirMeasureGroup.GetHasStratifierList : boolean;
begin
  result := (FStratifierList <> nil) and (FStratifierList.count > 0);
end;

function TFhirMeasureGroup.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FpopulationList.sizeInBytes);
  inc(result, FstratifierList.sizeInBytes);
end;

{ TFhirMeasureGroupListEnumerator }

Constructor TFhirMeasureGroupListEnumerator.Create(list : TFhirMeasureGroupList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMeasureGroupListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMeasureGroupListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMeasureGroupListEnumerator.GetCurrent : TFhirMeasureGroup;
begin
  Result := FList[FIndex];
end;

function TFhirMeasureGroupListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMeasureGroupList }
procedure TFhirMeasureGroupList.AddItem(value: TFhirMeasureGroup);
begin
  assert(value.ClassName = 'TFhirMeasureGroup', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMeasureGroup');
  add(value);
end;

function TFhirMeasureGroupList.Append: TFhirMeasureGroup;
begin
  result := TFhirMeasureGroup.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureGroupList.ClearItems;
begin
  Clear;
end;

function TFhirMeasureGroupList.GetEnumerator : TFhirMeasureGroupListEnumerator;
begin
  result := TFhirMeasureGroupListEnumerator.Create(self.link);
end;

function TFhirMeasureGroupList.Clone: TFhirMeasureGroupList;
begin
  result := TFhirMeasureGroupList(inherited Clone);
end;

function TFhirMeasureGroupList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMeasureGroupList.GetItemN(index: Integer): TFhirMeasureGroup;
begin
  result := TFhirMeasureGroup(ObjectByIndex[index]);
end;

function TFhirMeasureGroupList.ItemClass: TFslObjectClass;
begin
  result := TFhirMeasureGroup;
end;
function TFhirMeasureGroupList.IndexOf(value: TFhirMeasureGroup): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMeasureGroupList.Insert(index: Integer): TFhirMeasureGroup;
begin
  result := TFhirMeasureGroup.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureGroupList.InsertItem(index: Integer; value: TFhirMeasureGroup);
begin
  assert(value is TFhirMeasureGroup);
  Inherited Insert(index, value);
end;

function TFhirMeasureGroupList.Item(index: Integer): TFhirMeasureGroup;
begin
  result := TFhirMeasureGroup(ObjectByIndex[index]);
end;

function TFhirMeasureGroupList.Link: TFhirMeasureGroupList;
begin
  result := TFhirMeasureGroupList(inherited Link);
end;

procedure TFhirMeasureGroupList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMeasureGroupList.SetItemByIndex(index: Integer; value: TFhirMeasureGroup);
begin
  assert(value is TFhirMeasureGroup);
  FhirMeasureGroups[index] := value;
end;

procedure TFhirMeasureGroupList.SetItemN(index: Integer; value: TFhirMeasureGroup);
begin
  assert(value is TFhirMeasureGroup);
  ObjectByIndex[index] := value;
end;

{ TFhirMeasureGroupPopulation }

constructor TFhirMeasureGroupPopulation.Create;
begin
  inherited;
end;

destructor TFhirMeasureGroupPopulation.Destroy;
begin
  FIdentifier.free;
  FCode.free;
  FName.free;
  FDescription.free;
  FCriteria.free;
  inherited;
end;

procedure TFhirMeasureGroupPopulation.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirMeasureGroupPopulation(oSource).identifier.Clone;
  code := TFhirMeasureGroupPopulation(oSource).code.Clone;
  nameElement := TFhirMeasureGroupPopulation(oSource).nameElement.Clone;
  descriptionElement := TFhirMeasureGroupPopulation(oSource).descriptionElement.Clone;
  criteriaElement := TFhirMeasureGroupPopulation(oSource).criteriaElement.Clone;
end;

procedure TFhirMeasureGroupPopulation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'criteria') Then
     list.add(self.link, 'criteria', FCriteria.Link);
end;

procedure TFhirMeasureGroupPopulation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'criteria', 'string', false, TFhirString, FCriteria.Link));{2}
end;

function TFhirMeasureGroupPopulation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'criteria') then
  begin
    CriteriaElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMeasureGroupPopulation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMeasureGroupPopulation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'code') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'criteria') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMeasureGroupPopulation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'criteria') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMeasureGroupPopulation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'criteria') then CriteriaElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMeasureGroupPopulation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept{4}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'criteria') then CriteriaElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMeasureGroupPopulation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMeasureGroupPopulation.fhirType : string;
begin
  result := 'population';
end;

function TFhirMeasureGroupPopulation.Link : TFhirMeasureGroupPopulation;
begin
  result := TFhirMeasureGroupPopulation(inherited Link);
end;

function TFhirMeasureGroupPopulation.Clone : TFhirMeasureGroupPopulation;
begin
  result := TFhirMeasureGroupPopulation(inherited Clone);
end;

function TFhirMeasureGroupPopulation.equals(other : TObject) : boolean;
var
  o : TFhirMeasureGroupPopulation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMeasureGroupPopulation)) then
    result := false
  else
  begin
    o := TFhirMeasureGroupPopulation(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(codeElement, o.codeElement, true) and
      compareDeep(nameElement, o.nameElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and
      compareDeep(criteriaElement, o.criteriaElement, true);
  end;
end;

function TFhirMeasureGroupPopulation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FCode) and isEmptyProp(FName) and isEmptyProp(FDescription) and isEmptyProp(FCriteria);
end;

procedure TFhirMeasureGroupPopulation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('code');
  fields.add('name');
  fields.add('description');
  fields.add('criteria');
end;

{ TFhirMeasureGroupPopulation }

Procedure TFhirMeasureGroupPopulation.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirMeasureGroupPopulation.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

Procedure TFhirMeasureGroupPopulation.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirMeasureGroupPopulation.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirMeasureGroupPopulation.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirMeasureGroupPopulation.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirMeasureGroupPopulation.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirMeasureGroupPopulation.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirMeasureGroupPopulation.SetCriteria(value : TFhirString);
begin
  FCriteria.free;
  FCriteria := value;
end;

Function TFhirMeasureGroupPopulation.GetCriteriaST : String;
begin
  if FCriteria = nil then
    result := ''
  else
    result := FCriteria.value;
end;

Procedure TFhirMeasureGroupPopulation.SetCriteriaST(value : String);
begin
  if value <> '' then
  begin
    if FCriteria = nil then
      FCriteria := TFhirString.create;
    FCriteria.value := value
  end
  else if FCriteria <> nil then
    FCriteria.value := '';
end;

function TFhirMeasureGroupPopulation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FCriteria.sizeInBytes);
end;

{ TFhirMeasureGroupPopulationListEnumerator }

Constructor TFhirMeasureGroupPopulationListEnumerator.Create(list : TFhirMeasureGroupPopulationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMeasureGroupPopulationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMeasureGroupPopulationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMeasureGroupPopulationListEnumerator.GetCurrent : TFhirMeasureGroupPopulation;
begin
  Result := FList[FIndex];
end;

function TFhirMeasureGroupPopulationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMeasureGroupPopulationList }
procedure TFhirMeasureGroupPopulationList.AddItem(value: TFhirMeasureGroupPopulation);
begin
  assert(value.ClassName = 'TFhirMeasureGroupPopulation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMeasureGroupPopulation');
  add(value);
end;

function TFhirMeasureGroupPopulationList.Append: TFhirMeasureGroupPopulation;
begin
  result := TFhirMeasureGroupPopulation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureGroupPopulationList.ClearItems;
begin
  Clear;
end;

function TFhirMeasureGroupPopulationList.GetEnumerator : TFhirMeasureGroupPopulationListEnumerator;
begin
  result := TFhirMeasureGroupPopulationListEnumerator.Create(self.link);
end;

function TFhirMeasureGroupPopulationList.Clone: TFhirMeasureGroupPopulationList;
begin
  result := TFhirMeasureGroupPopulationList(inherited Clone);
end;

function TFhirMeasureGroupPopulationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMeasureGroupPopulationList.GetItemN(index: Integer): TFhirMeasureGroupPopulation;
begin
  result := TFhirMeasureGroupPopulation(ObjectByIndex[index]);
end;

function TFhirMeasureGroupPopulationList.ItemClass: TFslObjectClass;
begin
  result := TFhirMeasureGroupPopulation;
end;
function TFhirMeasureGroupPopulationList.IndexOf(value: TFhirMeasureGroupPopulation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMeasureGroupPopulationList.Insert(index: Integer): TFhirMeasureGroupPopulation;
begin
  result := TFhirMeasureGroupPopulation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureGroupPopulationList.InsertItem(index: Integer; value: TFhirMeasureGroupPopulation);
begin
  assert(value is TFhirMeasureGroupPopulation);
  Inherited Insert(index, value);
end;

function TFhirMeasureGroupPopulationList.Item(index: Integer): TFhirMeasureGroupPopulation;
begin
  result := TFhirMeasureGroupPopulation(ObjectByIndex[index]);
end;

function TFhirMeasureGroupPopulationList.Link: TFhirMeasureGroupPopulationList;
begin
  result := TFhirMeasureGroupPopulationList(inherited Link);
end;

procedure TFhirMeasureGroupPopulationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMeasureGroupPopulationList.SetItemByIndex(index: Integer; value: TFhirMeasureGroupPopulation);
begin
  assert(value is TFhirMeasureGroupPopulation);
  FhirMeasureGroupPopulations[index] := value;
end;

procedure TFhirMeasureGroupPopulationList.SetItemN(index: Integer; value: TFhirMeasureGroupPopulation);
begin
  assert(value is TFhirMeasureGroupPopulation);
  ObjectByIndex[index] := value;
end;

{ TFhirMeasureGroupStratifier }

constructor TFhirMeasureGroupStratifier.Create;
begin
  inherited;
end;

destructor TFhirMeasureGroupStratifier.Destroy;
begin
  FIdentifier.free;
  FCriteria.free;
  FPath.free;
  inherited;
end;

procedure TFhirMeasureGroupStratifier.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirMeasureGroupStratifier(oSource).identifier.Clone;
  criteriaElement := TFhirMeasureGroupStratifier(oSource).criteriaElement.Clone;
  pathElement := TFhirMeasureGroupStratifier(oSource).pathElement.Clone;
end;

procedure TFhirMeasureGroupStratifier.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'criteria') Then
     list.add(self.link, 'criteria', FCriteria.Link);
  if (child_name = 'path') Then
     list.add(self.link, 'path', FPath.Link);
end;

procedure TFhirMeasureGroupStratifier.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'criteria', 'string', false, TFhirString, FCriteria.Link));{2}
  oList.add(TFHIRProperty.create(self, 'path', 'string', false, TFhirString, FPath.Link));{2}
end;

function TFhirMeasureGroupStratifier.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'criteria') then
  begin
    CriteriaElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'path') then
  begin
    PathElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMeasureGroupStratifier.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMeasureGroupStratifier.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'criteria') then result := TFhirString.create() {5b}
  else if (propName = 'path') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMeasureGroupStratifier.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'criteria') then result := 'string'
  else if (propName = 'path') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMeasureGroupStratifier.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'criteria') then CriteriaElement := nil
  else if (propName = 'path') then PathElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMeasureGroupStratifier.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'criteria') then CriteriaElement := asString(new){5b}
  else if (propName = 'path') then PathElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMeasureGroupStratifier.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMeasureGroupStratifier.fhirType : string;
begin
  result := 'stratifier';
end;

function TFhirMeasureGroupStratifier.Link : TFhirMeasureGroupStratifier;
begin
  result := TFhirMeasureGroupStratifier(inherited Link);
end;

function TFhirMeasureGroupStratifier.Clone : TFhirMeasureGroupStratifier;
begin
  result := TFhirMeasureGroupStratifier(inherited Clone);
end;

function TFhirMeasureGroupStratifier.equals(other : TObject) : boolean;
var
  o : TFhirMeasureGroupStratifier;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMeasureGroupStratifier)) then
    result := false
  else
  begin
    o := TFhirMeasureGroupStratifier(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(criteriaElement, o.criteriaElement, true) and
      compareDeep(pathElement, o.pathElement, true);
  end;
end;

function TFhirMeasureGroupStratifier.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FCriteria) and isEmptyProp(FPath);
end;

procedure TFhirMeasureGroupStratifier.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('criteria');
  fields.add('path');
end;

{ TFhirMeasureGroupStratifier }

Procedure TFhirMeasureGroupStratifier.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirMeasureGroupStratifier.SetCriteria(value : TFhirString);
begin
  FCriteria.free;
  FCriteria := value;
end;

Function TFhirMeasureGroupStratifier.GetCriteriaST : String;
begin
  if FCriteria = nil then
    result := ''
  else
    result := FCriteria.value;
end;

Procedure TFhirMeasureGroupStratifier.SetCriteriaST(value : String);
begin
  if value <> '' then
  begin
    if FCriteria = nil then
      FCriteria := TFhirString.create;
    FCriteria.value := value
  end
  else if FCriteria <> nil then
    FCriteria.value := '';
end;

Procedure TFhirMeasureGroupStratifier.SetPath(value : TFhirString);
begin
  FPath.free;
  FPath := value;
end;

Function TFhirMeasureGroupStratifier.GetPathST : String;
begin
  if FPath = nil then
    result := ''
  else
    result := FPath.value;
end;

Procedure TFhirMeasureGroupStratifier.SetPathST(value : String);
begin
  if value <> '' then
  begin
    if FPath = nil then
      FPath := TFhirString.create;
    FPath.value := value
  end
  else if FPath <> nil then
    FPath.value := '';
end;

function TFhirMeasureGroupStratifier.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FCriteria.sizeInBytes);
  inc(result, FPath.sizeInBytes);
end;

{ TFhirMeasureGroupStratifierListEnumerator }

Constructor TFhirMeasureGroupStratifierListEnumerator.Create(list : TFhirMeasureGroupStratifierList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMeasureGroupStratifierListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMeasureGroupStratifierListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMeasureGroupStratifierListEnumerator.GetCurrent : TFhirMeasureGroupStratifier;
begin
  Result := FList[FIndex];
end;

function TFhirMeasureGroupStratifierListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMeasureGroupStratifierList }
procedure TFhirMeasureGroupStratifierList.AddItem(value: TFhirMeasureGroupStratifier);
begin
  assert(value.ClassName = 'TFhirMeasureGroupStratifier', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMeasureGroupStratifier');
  add(value);
end;

function TFhirMeasureGroupStratifierList.Append: TFhirMeasureGroupStratifier;
begin
  result := TFhirMeasureGroupStratifier.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureGroupStratifierList.ClearItems;
begin
  Clear;
end;

function TFhirMeasureGroupStratifierList.GetEnumerator : TFhirMeasureGroupStratifierListEnumerator;
begin
  result := TFhirMeasureGroupStratifierListEnumerator.Create(self.link);
end;

function TFhirMeasureGroupStratifierList.Clone: TFhirMeasureGroupStratifierList;
begin
  result := TFhirMeasureGroupStratifierList(inherited Clone);
end;

function TFhirMeasureGroupStratifierList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMeasureGroupStratifierList.GetItemN(index: Integer): TFhirMeasureGroupStratifier;
begin
  result := TFhirMeasureGroupStratifier(ObjectByIndex[index]);
end;

function TFhirMeasureGroupStratifierList.ItemClass: TFslObjectClass;
begin
  result := TFhirMeasureGroupStratifier;
end;
function TFhirMeasureGroupStratifierList.IndexOf(value: TFhirMeasureGroupStratifier): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMeasureGroupStratifierList.Insert(index: Integer): TFhirMeasureGroupStratifier;
begin
  result := TFhirMeasureGroupStratifier.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureGroupStratifierList.InsertItem(index: Integer; value: TFhirMeasureGroupStratifier);
begin
  assert(value is TFhirMeasureGroupStratifier);
  Inherited Insert(index, value);
end;

function TFhirMeasureGroupStratifierList.Item(index: Integer): TFhirMeasureGroupStratifier;
begin
  result := TFhirMeasureGroupStratifier(ObjectByIndex[index]);
end;

function TFhirMeasureGroupStratifierList.Link: TFhirMeasureGroupStratifierList;
begin
  result := TFhirMeasureGroupStratifierList(inherited Link);
end;

procedure TFhirMeasureGroupStratifierList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMeasureGroupStratifierList.SetItemByIndex(index: Integer; value: TFhirMeasureGroupStratifier);
begin
  assert(value is TFhirMeasureGroupStratifier);
  FhirMeasureGroupStratifiers[index] := value;
end;

procedure TFhirMeasureGroupStratifierList.SetItemN(index: Integer; value: TFhirMeasureGroupStratifier);
begin
  assert(value is TFhirMeasureGroupStratifier);
  ObjectByIndex[index] := value;
end;

{ TFhirMeasureSupplementalData }

constructor TFhirMeasureSupplementalData.Create;
begin
  inherited;
end;

destructor TFhirMeasureSupplementalData.Destroy;
begin
  FIdentifier.free;
  FUsageList.Free;
  FCriteria.free;
  FPath.free;
  inherited;
end;

procedure TFhirMeasureSupplementalData.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirMeasureSupplementalData(oSource).identifier.Clone;
  if (TFhirMeasureSupplementalData(oSource).FUsageList = nil) then
  begin
    FUsageList.free;
    FUsageList := nil;
  end
  else
  begin
    if FUsageList = nil then
      FUsageList := TFhirCodeableConceptList.Create;
    FUsageList.Assign(TFhirMeasureSupplementalData(oSource).FUsageList);
  end;
  criteriaElement := TFhirMeasureSupplementalData(oSource).criteriaElement.Clone;
  pathElement := TFhirMeasureSupplementalData(oSource).pathElement.Clone;
end;

procedure TFhirMeasureSupplementalData.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'usage') Then
    list.addAll(self, 'usage', FUsageList);
  if (child_name = 'criteria') Then
     list.add(self.link, 'criteria', FCriteria.Link);
  if (child_name = 'path') Then
     list.add(self.link, 'path', FPath.Link);
end;

procedure TFhirMeasureSupplementalData.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'usage', 'CodeableConcept', true, TFhirCodeableConcept, FUsageList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'criteria', 'string', false, TFhirString, FCriteria.Link));{2}
  oList.add(TFHIRProperty.create(self, 'path', 'string', false, TFhirString, FPath.Link));{2}
end;

function TFhirMeasureSupplementalData.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'usage') then
  begin
    UsageList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'criteria') then
  begin
    CriteriaElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'path') then
  begin
    PathElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMeasureSupplementalData.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'usage') then UsageList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else inherited;
end;

function TFhirMeasureSupplementalData.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'usage') then result := UsageList.new(){2}
  else if (propName = 'criteria') then result := TFhirString.create() {5b}
  else if (propName = 'path') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMeasureSupplementalData.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'usage') then result := 'CodeableConcept'
  else if (propName = 'criteria') then result := 'string'
  else if (propName = 'path') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMeasureSupplementalData.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'usage') then deletePropertyValue('usage', UsageList, value) {2}
  else if (propName = 'criteria') then CriteriaElement := nil
  else if (propName = 'path') then PathElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMeasureSupplementalData.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'usage') then replacePropertyValue('usage', UsageList, existing, new) {2}
  else if (propName = 'criteria') then CriteriaElement := asString(new){5b}
  else if (propName = 'path') then PathElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMeasureSupplementalData.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'usage') then UsageList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMeasureSupplementalData.fhirType : string;
begin
  result := 'supplementalData';
end;

function TFhirMeasureSupplementalData.Link : TFhirMeasureSupplementalData;
begin
  result := TFhirMeasureSupplementalData(inherited Link);
end;

function TFhirMeasureSupplementalData.Clone : TFhirMeasureSupplementalData;
begin
  result := TFhirMeasureSupplementalData(inherited Clone);
end;

function TFhirMeasureSupplementalData.equals(other : TObject) : boolean;
var
  o : TFhirMeasureSupplementalData;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMeasureSupplementalData)) then
    result := false
  else
  begin
    o := TFhirMeasureSupplementalData(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(usageList, o.usageList, true) and
      compareDeep(criteriaElement, o.criteriaElement, true) and compareDeep(pathElement, o.pathElement, true);
  end;
end;

function TFhirMeasureSupplementalData.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FusageList) and isEmptyProp(FCriteria) and isEmptyProp(FPath);
end;

procedure TFhirMeasureSupplementalData.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('usage');
  fields.add('criteria');
  fields.add('path');
end;

{ TFhirMeasureSupplementalData }

Procedure TFhirMeasureSupplementalData.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Function TFhirMeasureSupplementalData.GetUsageList : TFhirCodeableConceptList;
begin
  if FUsageList = nil then
    FUsageList := TFhirCodeableConceptList.Create;
  result := FUsageList;
end;

Function TFhirMeasureSupplementalData.GetHasUsageList : boolean;
begin
  result := (FUsageList <> nil) and (FUsageList.count > 0);
end;

Procedure TFhirMeasureSupplementalData.SetCriteria(value : TFhirString);
begin
  FCriteria.free;
  FCriteria := value;
end;

Function TFhirMeasureSupplementalData.GetCriteriaST : String;
begin
  if FCriteria = nil then
    result := ''
  else
    result := FCriteria.value;
end;

Procedure TFhirMeasureSupplementalData.SetCriteriaST(value : String);
begin
  if value <> '' then
  begin
    if FCriteria = nil then
      FCriteria := TFhirString.create;
    FCriteria.value := value
  end
  else if FCriteria <> nil then
    FCriteria.value := '';
end;

Procedure TFhirMeasureSupplementalData.SetPath(value : TFhirString);
begin
  FPath.free;
  FPath := value;
end;

Function TFhirMeasureSupplementalData.GetPathST : String;
begin
  if FPath = nil then
    result := ''
  else
    result := FPath.value;
end;

Procedure TFhirMeasureSupplementalData.SetPathST(value : String);
begin
  if value <> '' then
  begin
    if FPath = nil then
      FPath := TFhirString.create;
    FPath.value := value
  end
  else if FPath <> nil then
    FPath.value := '';
end;

function TFhirMeasureSupplementalData.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FusageList.sizeInBytes);
  inc(result, FCriteria.sizeInBytes);
  inc(result, FPath.sizeInBytes);
end;

{ TFhirMeasureSupplementalDataListEnumerator }

Constructor TFhirMeasureSupplementalDataListEnumerator.Create(list : TFhirMeasureSupplementalDataList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMeasureSupplementalDataListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMeasureSupplementalDataListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMeasureSupplementalDataListEnumerator.GetCurrent : TFhirMeasureSupplementalData;
begin
  Result := FList[FIndex];
end;

function TFhirMeasureSupplementalDataListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMeasureSupplementalDataList }
procedure TFhirMeasureSupplementalDataList.AddItem(value: TFhirMeasureSupplementalData);
begin
  assert(value.ClassName = 'TFhirMeasureSupplementalData', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMeasureSupplementalData');
  add(value);
end;

function TFhirMeasureSupplementalDataList.Append: TFhirMeasureSupplementalData;
begin
  result := TFhirMeasureSupplementalData.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureSupplementalDataList.ClearItems;
begin
  Clear;
end;

function TFhirMeasureSupplementalDataList.GetEnumerator : TFhirMeasureSupplementalDataListEnumerator;
begin
  result := TFhirMeasureSupplementalDataListEnumerator.Create(self.link);
end;

function TFhirMeasureSupplementalDataList.Clone: TFhirMeasureSupplementalDataList;
begin
  result := TFhirMeasureSupplementalDataList(inherited Clone);
end;

function TFhirMeasureSupplementalDataList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMeasureSupplementalDataList.GetItemN(index: Integer): TFhirMeasureSupplementalData;
begin
  result := TFhirMeasureSupplementalData(ObjectByIndex[index]);
end;

function TFhirMeasureSupplementalDataList.ItemClass: TFslObjectClass;
begin
  result := TFhirMeasureSupplementalData;
end;
function TFhirMeasureSupplementalDataList.IndexOf(value: TFhirMeasureSupplementalData): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMeasureSupplementalDataList.Insert(index: Integer): TFhirMeasureSupplementalData;
begin
  result := TFhirMeasureSupplementalData.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureSupplementalDataList.InsertItem(index: Integer; value: TFhirMeasureSupplementalData);
begin
  assert(value is TFhirMeasureSupplementalData);
  Inherited Insert(index, value);
end;

function TFhirMeasureSupplementalDataList.Item(index: Integer): TFhirMeasureSupplementalData;
begin
  result := TFhirMeasureSupplementalData(ObjectByIndex[index]);
end;

function TFhirMeasureSupplementalDataList.Link: TFhirMeasureSupplementalDataList;
begin
  result := TFhirMeasureSupplementalDataList(inherited Link);
end;

procedure TFhirMeasureSupplementalDataList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMeasureSupplementalDataList.SetItemByIndex(index: Integer; value: TFhirMeasureSupplementalData);
begin
  assert(value is TFhirMeasureSupplementalData);
  FhirMeasureSupplementalData[index] := value;
end;

procedure TFhirMeasureSupplementalDataList.SetItemN(index: Integer; value: TFhirMeasureSupplementalData);
begin
  assert(value is TFhirMeasureSupplementalData);
  ObjectByIndex[index] := value;
end;

{ TFhirMeasure }

constructor TFhirMeasure.Create;
begin
  inherited;
end;

destructor TFhirMeasure.Destroy;
begin
  FIdentifierList.Free;
  FPurpose.free;
  FUsage.free;
  FApprovalDate.free;
  FLastReviewDate.free;
  FEffectivePeriod.free;
  FTopicList.Free;
  FContributorList.Free;
  FCopyright.free;
  FRelatedArtifactList.Free;
  FLibrary_List.Free;
  FDisclaimer.free;
  FScoring.free;
  FCompositeScoring.free;
  FType_List.Free;
  FRiskAdjustment.free;
  FRateAggregation.free;
  FRationale.free;
  FClinicalRecommendationStatement.free;
  FImprovementNotation.free;
  FDefinitionList.Free;
  FGuidance.free;
  FSet_.free;
  FGroupList.Free;
  FSupplementalDataList.Free;
  inherited;
end;

function TFhirMeasure.GetResourceType : TFhirResourceType;
begin
  result := frtMeasure;
end;

procedure TFhirMeasure.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMeasure(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirMeasure(oSource).FIdentifierList);
  end;
  purposeElement := TFhirMeasure(oSource).purposeElement.Clone;
  usageElement := TFhirMeasure(oSource).usageElement.Clone;
  approvalDateElement := TFhirMeasure(oSource).approvalDateElement.Clone;
  lastReviewDateElement := TFhirMeasure(oSource).lastReviewDateElement.Clone;
  effectivePeriod := TFhirMeasure(oSource).effectivePeriod.Clone;
  if (TFhirMeasure(oSource).FTopicList = nil) then
  begin
    FTopicList.free;
    FTopicList := nil;
  end
  else
  begin
    if FTopicList = nil then
      FTopicList := TFhirCodeableConceptList.Create;
    FTopicList.Assign(TFhirMeasure(oSource).FTopicList);
  end;
  if (TFhirMeasure(oSource).FContributorList = nil) then
  begin
    FContributorList.free;
    FContributorList := nil;
  end
  else
  begin
    if FContributorList = nil then
      FContributorList := TFhirContributorList.Create;
    FContributorList.Assign(TFhirMeasure(oSource).FContributorList);
  end;
  copyrightElement := TFhirMeasure(oSource).copyrightElement.Clone;
  if (TFhirMeasure(oSource).FRelatedArtifactList = nil) then
  begin
    FRelatedArtifactList.free;
    FRelatedArtifactList := nil;
  end
  else
  begin
    if FRelatedArtifactList = nil then
      FRelatedArtifactList := TFhirRelatedArtifactList.Create;
    FRelatedArtifactList.Assign(TFhirMeasure(oSource).FRelatedArtifactList);
  end;
  if (TFhirMeasure(oSource).FLibrary_List = nil) then
  begin
    FLibrary_List.free;
    FLibrary_List := nil;
  end
  else
  begin
    if FLibrary_List = nil then
      FLibrary_List := TFhirReferenceList{TFhirLibrary}.Create;
    FLibrary_List.Assign(TFhirMeasure(oSource).FLibrary_List);
  end;
  disclaimerElement := TFhirMeasure(oSource).disclaimerElement.Clone;
  scoring := TFhirMeasure(oSource).scoring.Clone;
  compositeScoring := TFhirMeasure(oSource).compositeScoring.Clone;
  if (TFhirMeasure(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirMeasure(oSource).FType_List);
  end;
  riskAdjustmentElement := TFhirMeasure(oSource).riskAdjustmentElement.Clone;
  rateAggregationElement := TFhirMeasure(oSource).rateAggregationElement.Clone;
  rationaleElement := TFhirMeasure(oSource).rationaleElement.Clone;
  clinicalRecommendationStatementElement := TFhirMeasure(oSource).clinicalRecommendationStatementElement.Clone;
  improvementNotationElement := TFhirMeasure(oSource).improvementNotationElement.Clone;
  if (TFhirMeasure(oSource).FDefinitionList = nil) then
  begin
    FDefinitionList.free;
    FDefinitionList := nil;
  end
  else
  begin
    if FDefinitionList = nil then
      FDefinitionList := TFhirMarkdownList.Create;
    FDefinitionList.Assign(TFhirMeasure(oSource).FDefinitionList);
  end;
  guidanceElement := TFhirMeasure(oSource).guidanceElement.Clone;
  set_Element := TFhirMeasure(oSource).set_Element.Clone;
  if (TFhirMeasure(oSource).FGroupList = nil) then
  begin
    FGroupList.free;
    FGroupList := nil;
  end
  else
  begin
    if FGroupList = nil then
      FGroupList := TFhirMeasureGroupList.Create;
    FGroupList.Assign(TFhirMeasure(oSource).FGroupList);
  end;
  if (TFhirMeasure(oSource).FSupplementalDataList = nil) then
  begin
    FSupplementalDataList.free;
    FSupplementalDataList := nil;
  end
  else
  begin
    if FSupplementalDataList = nil then
      FSupplementalDataList := TFhirMeasureSupplementalDataList.Create;
    FSupplementalDataList.Assign(TFhirMeasure(oSource).FSupplementalDataList);
  end;
end;

procedure TFhirMeasure.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'usage') Then
     list.add(self.link, 'usage', FUsage.Link);
  if (child_name = 'approvalDate') Then
     list.add(self.link, 'approvalDate', FApprovalDate.Link);
  if (child_name = 'lastReviewDate') Then
     list.add(self.link, 'lastReviewDate', FLastReviewDate.Link);
  if (child_name = 'effectivePeriod') Then
     list.add(self.link, 'effectivePeriod', FEffectivePeriod.Link);
  if (child_name = 'topic') Then
    list.addAll(self, 'topic', FTopicList);
  if (child_name = 'contributor') Then
    list.addAll(self, 'contributor', FContributorList);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'relatedArtifact') Then
    list.addAll(self, 'relatedArtifact', FRelatedArtifactList);
  if (child_name = 'library') Then
    list.addAll(self, 'library', FLibrary_List);
  if (child_name = 'disclaimer') Then
     list.add(self.link, 'disclaimer', FDisclaimer.Link);
  if (child_name = 'scoring') Then
     list.add(self.link, 'scoring', FScoring.Link);
  if (child_name = 'compositeScoring') Then
     list.add(self.link, 'compositeScoring', FCompositeScoring.Link);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'riskAdjustment') Then
     list.add(self.link, 'riskAdjustment', FRiskAdjustment.Link);
  if (child_name = 'rateAggregation') Then
     list.add(self.link, 'rateAggregation', FRateAggregation.Link);
  if (child_name = 'rationale') Then
     list.add(self.link, 'rationale', FRationale.Link);
  if (child_name = 'clinicalRecommendationStatement') Then
     list.add(self.link, 'clinicalRecommendationStatement', FClinicalRecommendationStatement.Link);
  if (child_name = 'improvementNotation') Then
     list.add(self.link, 'improvementNotation', FImprovementNotation.Link);
  if (child_name = 'definition') Then
    list.addAll(self, 'definition', FDefinitionList);
  if (child_name = 'guidance') Then
     list.add(self.link, 'guidance', FGuidance.Link);
  if (child_name = 'set') Then
     list.add(self.link, 'set', FSet_.Link);
  if (child_name = 'group') Then
    list.addAll(self, 'group', FGroupList);
  if (child_name = 'supplementalData') Then
    list.addAll(self, 'supplementalData', FSupplementalDataList);
end;

procedure TFhirMeasure.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));{2}
  oList.add(TFHIRProperty.create(self, 'usage', 'string', false, TFhirString, FUsage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'approvalDate', 'date', false, TFhirDate, FApprovalDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'lastReviewDate', 'date', false, TFhirDate, FLastReviewDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'effectivePeriod', 'Period', false, TFhirPeriod, FEffectivePeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'topic', 'CodeableConcept', true, TFhirCodeableConcept, FTopicList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'contributor', 'Contributor', true, TFhirContributor, FContributorList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));{2}
  oList.add(TFHIRProperty.create(self, 'relatedArtifact', 'RelatedArtifact', true, TFhirRelatedArtifact, FRelatedArtifactList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'library', 'Reference(Library)', true, TFhirReference{TFhirLibrary}, FLibrary_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'disclaimer', 'markdown', false, TFhirMarkdown, FDisclaimer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'scoring', 'CodeableConcept', false, TFhirCodeableConcept, FScoring.Link));{2}
  oList.add(TFHIRProperty.create(self, 'compositeScoring', 'CodeableConcept', false, TFhirCodeableConcept, FCompositeScoring.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'riskAdjustment', 'string', false, TFhirString, FRiskAdjustment.Link));{2}
  oList.add(TFHIRProperty.create(self, 'rateAggregation', 'string', false, TFhirString, FRateAggregation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'rationale', 'markdown', false, TFhirMarkdown, FRationale.Link));{2}
  oList.add(TFHIRProperty.create(self, 'clinicalRecommendationStatement', 'markdown', false, TFhirMarkdown, FClinicalRecommendationStatement.Link));{2}
  oList.add(TFHIRProperty.create(self, 'improvementNotation', 'string', false, TFhirString, FImprovementNotation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'definition', 'markdown', true, TFhirMarkdown, FDefinitionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'guidance', 'markdown', false, TFhirMarkdown, FGuidance.Link));{2}
  oList.add(TFHIRProperty.create(self, 'set', 'string', false, TFhirString, FSet_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'group', '', true, TFhirMeasureGroup, FGroupList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'supplementalData', '', true, TFhirMeasureSupplementalData, FSupplementalDataList.Link)){3};
end;

function TFhirMeasure.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'usage') then
  begin
    UsageElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'approvalDate') then
  begin
    ApprovalDateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'lastReviewDate') then
  begin
    LastReviewDateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'effectivePeriod') then
  begin
    EffectivePeriod := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'topic') then
  begin
    TopicList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'contributor') then
  begin
    ContributorList.add(propValue as TFhirContributor){2a};
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'relatedArtifact') then
  begin
    RelatedArtifactList.add(propValue as TFhirRelatedArtifact){2a};
    result := propValue;
  end
  else if (propName = 'library') then
  begin
    Library_List.add(propValue as TFhirReference{TFhirLibrary}){2a};
    result := propValue;
  end
  else if (propName = 'disclaimer') then
  begin
    DisclaimerElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'scoring') then
  begin
    Scoring := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'compositeScoring') then
  begin
    CompositeScoring := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'riskAdjustment') then
  begin
    RiskAdjustmentElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'rateAggregation') then
  begin
    RateAggregationElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'rationale') then
  begin
    RationaleElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'clinicalRecommendationStatement') then
  begin
    ClinicalRecommendationStatementElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'improvementNotation') then
  begin
    ImprovementNotationElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'definition') then
  begin
    DefinitionList.add(asMarkdown(propValue)){2};     result := propValue;

  end
  else if (propName = 'guidance') then
  begin
    GuidanceElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'set') then
  begin
    Set_Element := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'group') then
  begin
    GroupList.add(propValue as TFhirMeasureGroup){2a};
    result := propValue;
  end
  else if (propName = 'supplementalData') then
  begin
    SupplementalDataList.add(propValue as TFhirMeasureSupplementalData){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirMeasure.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'topic') then TopicList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'contributor') then ContributorList.insertItem(index, propValue as TFhirContributor){2a}
  else if (propName = 'relatedArtifact') then RelatedArtifactList.insertItem(index, propValue as TFhirRelatedArtifact){2a}
  else if (propName = 'library') then Library_List.insertItem(index, propValue as TFhirReference{TFhirLibrary}){2a}
  else if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'definition') then DefinitionList.insertItem(index, asMarkdown(propValue)){2}
  else if (propName = 'group') then GroupList.insertItem(index, propValue as TFhirMeasureGroup){2a}
  else if (propName = 'supplementalData') then SupplementalDataList.insertItem(index, propValue as TFhirMeasureSupplementalData){2a}
  else inherited;
end;

function TFhirMeasure.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'purpose') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'usage') then result := TFhirString.create() {5b}
  else if (propName = 'approvalDate') then result := TFhirDate.create() {5b}
  else if (propName = 'lastReviewDate') then result := TFhirDate.create() {5b}
  else if (propName = 'effectivePeriod') then result := TFhirPeriod.create(){4b}
  else if (propName = 'topic') then result := TopicList.new(){2}
  else if (propName = 'contributor') then result := ContributorList.new(){2}
  else if (propName = 'copyright') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'relatedArtifact') then result := RelatedArtifactList.new(){2}
  else if (propName = 'library') then result := Library_List.new(){2}
  else if (propName = 'disclaimer') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'scoring') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'compositeScoring') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'type') then result := Type_List.new(){2}
  else if (propName = 'riskAdjustment') then result := TFhirString.create() {5b}
  else if (propName = 'rateAggregation') then result := TFhirString.create() {5b}
  else if (propName = 'rationale') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'clinicalRecommendationStatement') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'improvementNotation') then result := TFhirString.create() {5b}
  else if (propName = 'definition') then result := DefinitionList.new(){2}
  else if (propName = 'guidance') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'set') then result := TFhirString.create() {5b}
  else if (propName = 'group') then result := GroupList.new(){2}
  else if (propName = 'supplementalData') then result := SupplementalDataList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMeasure.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'usage') then result := 'string'
  else if (propName = 'approvalDate') then result := 'date'
  else if (propName = 'lastReviewDate') then result := 'date'
  else if (propName = 'effectivePeriod') then result := 'Period'
  else if (propName = 'topic') then result := 'CodeableConcept'
  else if (propName = 'contributor') then result := 'Contributor'
  else if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'relatedArtifact') then result := 'RelatedArtifact'
  else if (propName = 'library') then result := 'Reference'
  else if (propName = 'disclaimer') then result := 'markdown'
  else if (propName = 'scoring') then result := 'CodeableConcept'
  else if (propName = 'compositeScoring') then result := 'CodeableConcept'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'riskAdjustment') then result := 'string'
  else if (propName = 'rateAggregation') then result := 'string'
  else if (propName = 'rationale') then result := 'markdown'
  else if (propName = 'clinicalRecommendationStatement') then result := 'markdown'
  else if (propName = 'improvementNotation') then result := 'string'
  else if (propName = 'definition') then result := 'markdown'
  else if (propName = 'guidance') then result := 'markdown'
  else if (propName = 'set') then result := 'string'
  else if (propName = 'group') then result := ''
  else if (propName = 'supplementalData') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMeasure.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'usage') then UsageElement := nil
  else if (propName = 'approvalDate') then ApprovalDateElement := nil
  else if (propName = 'lastReviewDate') then LastReviewDateElement := nil
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := nil
  else if (propName = 'topic') then deletePropertyValue('topic', TopicList, value) {2}
  else if (propName = 'contributor') then deletePropertyValue('contributor', ContributorList, value) {2}
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'relatedArtifact') then deletePropertyValue('relatedArtifact', RelatedArtifactList, value) {2}
  else if (propName = 'library') then deletePropertyValue('library', Library_List, value) {2}
  else if (propName = 'disclaimer') then DisclaimerElement := nil
  else if (propName = 'scoring') then ScoringElement := nil
  else if (propName = 'compositeScoring') then CompositeScoringElement := nil
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value) {2}
  else if (propName = 'riskAdjustment') then RiskAdjustmentElement := nil
  else if (propName = 'rateAggregation') then RateAggregationElement := nil
  else if (propName = 'rationale') then RationaleElement := nil
  else if (propName = 'clinicalRecommendationStatement') then ClinicalRecommendationStatementElement := nil
  else if (propName = 'improvementNotation') then ImprovementNotationElement := nil
  else if (propName = 'definition') then deletePropertyValue('definition', DefinitionList, value) {2}
  else if (propName = 'guidance') then GuidanceElement := nil
  else if (propName = 'set') then Set_Element := nil
  else if (propName = 'group') then deletePropertyValue('group', GroupList, value) {2}
  else if (propName = 'supplementalData') then deletePropertyValue('supplementalData', SupplementalDataList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMeasure.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'purpose') then PurposeElement := asMarkdown(new){5b}
  else if (propName = 'usage') then UsageElement := asString(new){5b}
  else if (propName = 'approvalDate') then ApprovalDateElement := asDate(new){5b}
  else if (propName = 'lastReviewDate') then LastReviewDateElement := asDate(new){5b}
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := new as TFhirPeriod{4}
  else if (propName = 'topic') then replacePropertyValue('topic', TopicList, existing, new) {2}
  else if (propName = 'contributor') then replacePropertyValue('contributor', ContributorList, existing, new) {2}
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new){5b}
  else if (propName = 'relatedArtifact') then replacePropertyValue('relatedArtifact', RelatedArtifactList, existing, new) {2}
  else if (propName = 'library') then replacePropertyValue('library', Library_List, existing, new) {2}
  else if (propName = 'disclaimer') then DisclaimerElement := asMarkdown(new){5b}
  else if (propName = 'scoring') then ScoringElement := new as TFhirCodeableConcept{4}
  else if (propName = 'compositeScoring') then CompositeScoringElement := new as TFhirCodeableConcept{4}
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new) {2}
  else if (propName = 'riskAdjustment') then RiskAdjustmentElement := asString(new){5b}
  else if (propName = 'rateAggregation') then RateAggregationElement := asString(new){5b}
  else if (propName = 'rationale') then RationaleElement := asMarkdown(new){5b}
  else if (propName = 'clinicalRecommendationStatement') then ClinicalRecommendationStatementElement := asMarkdown(new){5b}
  else if (propName = 'improvementNotation') then ImprovementNotationElement := asString(new){5b}
  else if (propName = 'definition') then replacePropertyValue('definition', DefinitionList, existing, new) {2}
  else if (propName = 'guidance') then GuidanceElement := asMarkdown(new){5b}
  else if (propName = 'set') then Set_Element := asString(new){5b}
  else if (propName = 'group') then replacePropertyValue('group', GroupList, existing, new) {2}
  else if (propName = 'supplementalData') then replacePropertyValue('supplementalData', SupplementalDataList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMeasure.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'topic') then TopicList.move(source, destination){2a}
  else if (propName = 'contributor') then ContributorList.move(source, destination){2a}
  else if (propName = 'relatedArtifact') then RelatedArtifactList.move(source, destination){2a}
  else if (propName = 'library') then Library_List.move(source, destination){2a}
  else if (propName = 'type') then Type_List.move(source, destination){2a}
  else if (propName = 'definition') then DefinitionList.move(source, destination){2}
  else if (propName = 'group') then GroupList.move(source, destination){2a}
  else if (propName = 'supplementalData') then SupplementalDataList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMeasure.fhirType : string;
begin
  result := 'Measure';
end;

function TFhirMeasure.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FPurpose) and isEmptyProp(FUsage) and isEmptyProp(FApprovalDate) and isEmptyProp(FLastReviewDate) and isEmptyProp(FEffectivePeriod) and isEmptyProp(FtopicList) and isEmptyProp(FcontributorList) and isEmptyProp(FCopyright) and isEmptyProp(FrelatedArtifactList) and isEmptyProp(Flibrary_List) and isEmptyProp(FDisclaimer) and isEmptyProp(FScoring) and isEmptyProp(FCompositeScoring) and isEmptyProp(Ftype_List) and isEmptyProp(FRiskAdjustment) and isEmptyProp(FRateAggregation) and isEmptyProp(FRationale) and isEmptyProp(FClinicalRecommendationStatement) and isEmptyProp(FImprovementNotation) and isEmptyProp(FdefinitionList) and isEmptyProp(FGuidance) and isEmptyProp(FSet_) and isEmptyProp(FgroupList) and isEmptyProp(FsupplementalDataList);
end;

function TFhirMeasure.equals(other : TObject) : boolean;
var
  o : TFhirMeasure;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMeasure)) then
    result := false
  else
  begin
    o := TFhirMeasure(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(purposeElement, o.purposeElement, true) and
      compareDeep(usageElement, o.usageElement, true) and compareDeep(approvalDateElement, o.approvalDateElement, true) and
      compareDeep(lastReviewDateElement, o.lastReviewDateElement, true) and compareDeep(effectivePeriodElement, o.effectivePeriodElement, true) and
      compareDeep(topicList, o.topicList, true) and compareDeep(contributorList, o.contributorList, true) and
      compareDeep(copyrightElement, o.copyrightElement, true) and compareDeep(relatedArtifactList, o.relatedArtifactList, true) and
      compareDeep(library_List, o.library_List, true) and compareDeep(disclaimerElement, o.disclaimerElement, true) and
      compareDeep(scoringElement, o.scoringElement, true) and compareDeep(compositeScoringElement, o.compositeScoringElement, true) and
      compareDeep(type_List, o.type_List, true) and compareDeep(riskAdjustmentElement, o.riskAdjustmentElement, true) and
      compareDeep(rateAggregationElement, o.rateAggregationElement, true) and compareDeep(rationaleElement, o.rationaleElement, true) and
      compareDeep(clinicalRecommendationStatementElement, o.clinicalRecommendationStatementElement, true) and
      compareDeep(improvementNotationElement, o.improvementNotationElement, true) and
      compareDeep(definitionList, o.definitionList, true) and compareDeep(guidanceElement, o.guidanceElement, true) and
      compareDeep(set_Element, o.set_Element, true) and compareDeep(groupList, o.groupList, true) and
      compareDeep(supplementalDataList, o.supplementalDataList, true);
  end;
end;

function TFhirMeasure.Link : TFhirMeasure;
begin
  result := TFhirMeasure(inherited Link);
end;

function TFhirMeasure.Clone : TFhirMeasure;
begin
  result := TFhirMeasure(inherited Clone);
end;

procedure TFhirMeasure.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('status');
  fields.add('experimental');
  fields.add('date');
  fields.add('publisher');
  fields.add('description');
  fields.add('purpose');
  fields.add('usage');
  fields.add('approvalDate');
  fields.add('lastReviewDate');
  fields.add('effectivePeriod');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('topic');
  fields.add('contributor');
  fields.add('contact');
  fields.add('copyright');
  fields.add('relatedArtifact');
  fields.add('library');
  fields.add('disclaimer');
  fields.add('scoring');
  fields.add('compositeScoring');
  fields.add('type');
  fields.add('riskAdjustment');
  fields.add('rateAggregation');
  fields.add('rationale');
  fields.add('clinicalRecommendationStatement');
  fields.add('improvementNotation');
  fields.add('definition');
  fields.add('guidance');
  fields.add('set');
  fields.add('group');
  fields.add('supplementalData');
end;

{ TFhirMeasure }

Function TFhirMeasure.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirMeasure.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirMeasure.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

Function TFhirMeasure.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

Procedure TFhirMeasure.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

Procedure TFhirMeasure.SetUsage(value : TFhirString);
begin
  FUsage.free;
  FUsage := value;
end;

Function TFhirMeasure.GetUsageST : String;
begin
  if FUsage = nil then
    result := ''
  else
    result := FUsage.value;
end;

Procedure TFhirMeasure.SetUsageST(value : String);
begin
  if value <> '' then
  begin
    if FUsage = nil then
      FUsage := TFhirString.create;
    FUsage.value := value
  end
  else if FUsage <> nil then
    FUsage.value := '';
end;

Procedure TFhirMeasure.SetApprovalDate(value : TFhirDate);
begin
  FApprovalDate.free;
  FApprovalDate := value;
end;

Function TFhirMeasure.GetApprovalDateST : TFslDateTime;
begin
  if FApprovalDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FApprovalDate.value;
end;

Procedure TFhirMeasure.SetApprovalDateST(value : TFslDateTime);
begin
  if FApprovalDate = nil then
    FApprovalDate := TFhirDate.create;
  FApprovalDate.value := value
end;

Procedure TFhirMeasure.SetLastReviewDate(value : TFhirDate);
begin
  FLastReviewDate.free;
  FLastReviewDate := value;
end;

Function TFhirMeasure.GetLastReviewDateST : TFslDateTime;
begin
  if FLastReviewDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastReviewDate.value;
end;

Procedure TFhirMeasure.SetLastReviewDateST(value : TFslDateTime);
begin
  if FLastReviewDate = nil then
    FLastReviewDate := TFhirDate.create;
  FLastReviewDate.value := value
end;

Procedure TFhirMeasure.SetEffectivePeriod(value : TFhirPeriod);
begin
  FEffectivePeriod.free;
  FEffectivePeriod := value;
end;

Function TFhirMeasure.GetTopicList : TFhirCodeableConceptList;
begin
  if FTopicList = nil then
    FTopicList := TFhirCodeableConceptList.Create;
  result := FTopicList;
end;

Function TFhirMeasure.GetHasTopicList : boolean;
begin
  result := (FTopicList <> nil) and (FTopicList.count > 0);
end;

Function TFhirMeasure.GetContributorList : TFhirContributorList;
begin
  if FContributorList = nil then
    FContributorList := TFhirContributorList.Create;
  result := FContributorList;
end;

Function TFhirMeasure.GetHasContributorList : boolean;
begin
  result := (FContributorList <> nil) and (FContributorList.count > 0);
end;

Procedure TFhirMeasure.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

Function TFhirMeasure.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

Procedure TFhirMeasure.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

Function TFhirMeasure.GetRelatedArtifactList : TFhirRelatedArtifactList;
begin
  if FRelatedArtifactList = nil then
    FRelatedArtifactList := TFhirRelatedArtifactList.Create;
  result := FRelatedArtifactList;
end;

Function TFhirMeasure.GetHasRelatedArtifactList : boolean;
begin
  result := (FRelatedArtifactList <> nil) and (FRelatedArtifactList.count > 0);
end;

Function TFhirMeasure.GetLibrary_List : TFhirReferenceList{TFhirLibrary};
begin
  if FLibrary_List = nil then
    FLibrary_List := TFhirReferenceList{TFhirLibrary}.Create;
  result := FLibrary_List;
end;

Function TFhirMeasure.GetHasLibrary_List : boolean;
begin
  result := (FLibrary_List <> nil) and (FLibrary_List.count > 0);
end;

Procedure TFhirMeasure.SetDisclaimer(value : TFhirMarkdown);
begin
  FDisclaimer.free;
  FDisclaimer := value;
end;

Function TFhirMeasure.GetDisclaimerST : String;
begin
  if FDisclaimer = nil then
    result := ''
  else
    result := FDisclaimer.value;
end;

Procedure TFhirMeasure.SetDisclaimerST(value : String);
begin
  if value <> '' then
  begin
    if FDisclaimer = nil then
      FDisclaimer := TFhirMarkdown.create;
    FDisclaimer.value := value
  end
  else if FDisclaimer <> nil then
    FDisclaimer.value := '';
end;

Procedure TFhirMeasure.SetScoring(value : TFhirCodeableConcept);
begin
  FScoring.free;
  FScoring := value;
end;

Procedure TFhirMeasure.SetCompositeScoring(value : TFhirCodeableConcept);
begin
  FCompositeScoring.free;
  FCompositeScoring := value;
end;

Function TFhirMeasure.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

Function TFhirMeasure.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

Procedure TFhirMeasure.SetRiskAdjustment(value : TFhirString);
begin
  FRiskAdjustment.free;
  FRiskAdjustment := value;
end;

Function TFhirMeasure.GetRiskAdjustmentST : String;
begin
  if FRiskAdjustment = nil then
    result := ''
  else
    result := FRiskAdjustment.value;
end;

Procedure TFhirMeasure.SetRiskAdjustmentST(value : String);
begin
  if value <> '' then
  begin
    if FRiskAdjustment = nil then
      FRiskAdjustment := TFhirString.create;
    FRiskAdjustment.value := value
  end
  else if FRiskAdjustment <> nil then
    FRiskAdjustment.value := '';
end;

Procedure TFhirMeasure.SetRateAggregation(value : TFhirString);
begin
  FRateAggregation.free;
  FRateAggregation := value;
end;

Function TFhirMeasure.GetRateAggregationST : String;
begin
  if FRateAggregation = nil then
    result := ''
  else
    result := FRateAggregation.value;
end;

Procedure TFhirMeasure.SetRateAggregationST(value : String);
begin
  if value <> '' then
  begin
    if FRateAggregation = nil then
      FRateAggregation := TFhirString.create;
    FRateAggregation.value := value
  end
  else if FRateAggregation <> nil then
    FRateAggregation.value := '';
end;

Procedure TFhirMeasure.SetRationale(value : TFhirMarkdown);
begin
  FRationale.free;
  FRationale := value;
end;

Function TFhirMeasure.GetRationaleST : String;
begin
  if FRationale = nil then
    result := ''
  else
    result := FRationale.value;
end;

Procedure TFhirMeasure.SetRationaleST(value : String);
begin
  if value <> '' then
  begin
    if FRationale = nil then
      FRationale := TFhirMarkdown.create;
    FRationale.value := value
  end
  else if FRationale <> nil then
    FRationale.value := '';
end;

Procedure TFhirMeasure.SetClinicalRecommendationStatement(value : TFhirMarkdown);
begin
  FClinicalRecommendationStatement.free;
  FClinicalRecommendationStatement := value;
end;

Function TFhirMeasure.GetClinicalRecommendationStatementST : String;
begin
  if FClinicalRecommendationStatement = nil then
    result := ''
  else
    result := FClinicalRecommendationStatement.value;
end;

Procedure TFhirMeasure.SetClinicalRecommendationStatementST(value : String);
begin
  if value <> '' then
  begin
    if FClinicalRecommendationStatement = nil then
      FClinicalRecommendationStatement := TFhirMarkdown.create;
    FClinicalRecommendationStatement.value := value
  end
  else if FClinicalRecommendationStatement <> nil then
    FClinicalRecommendationStatement.value := '';
end;

Procedure TFhirMeasure.SetImprovementNotation(value : TFhirString);
begin
  FImprovementNotation.free;
  FImprovementNotation := value;
end;

Function TFhirMeasure.GetImprovementNotationST : String;
begin
  if FImprovementNotation = nil then
    result := ''
  else
    result := FImprovementNotation.value;
end;

Procedure TFhirMeasure.SetImprovementNotationST(value : String);
begin
  if value <> '' then
  begin
    if FImprovementNotation = nil then
      FImprovementNotation := TFhirString.create;
    FImprovementNotation.value := value
  end
  else if FImprovementNotation <> nil then
    FImprovementNotation.value := '';
end;

Function TFhirMeasure.GetDefinitionList : TFhirMarkdownList;
begin
  if FDefinitionList = nil then
    FDefinitionList := TFhirMarkdownList.Create;
  result := FDefinitionList;
end;

Function TFhirMeasure.GetHasDefinitionList : boolean;
begin
  result := (FDefinitionList <> nil) and (FDefinitionList.count > 0);
end;

Procedure TFhirMeasure.SetGuidance(value : TFhirMarkdown);
begin
  FGuidance.free;
  FGuidance := value;
end;

Function TFhirMeasure.GetGuidanceST : String;
begin
  if FGuidance = nil then
    result := ''
  else
    result := FGuidance.value;
end;

Procedure TFhirMeasure.SetGuidanceST(value : String);
begin
  if value <> '' then
  begin
    if FGuidance = nil then
      FGuidance := TFhirMarkdown.create;
    FGuidance.value := value
  end
  else if FGuidance <> nil then
    FGuidance.value := '';
end;

Procedure TFhirMeasure.SetSet_(value : TFhirString);
begin
  FSet_.free;
  FSet_ := value;
end;

Function TFhirMeasure.GetSet_ST : String;
begin
  if FSet_ = nil then
    result := ''
  else
    result := FSet_.value;
end;

Procedure TFhirMeasure.SetSet_ST(value : String);
begin
  if value <> '' then
  begin
    if FSet_ = nil then
      FSet_ := TFhirString.create;
    FSet_.value := value
  end
  else if FSet_ <> nil then
    FSet_.value := '';
end;

Function TFhirMeasure.GetGroupList : TFhirMeasureGroupList;
begin
  if FGroupList = nil then
    FGroupList := TFhirMeasureGroupList.Create;
  result := FGroupList;
end;

Function TFhirMeasure.GetHasGroupList : boolean;
begin
  result := (FGroupList <> nil) and (FGroupList.count > 0);
end;

Function TFhirMeasure.GetSupplementalDataList : TFhirMeasureSupplementalDataList;
begin
  if FSupplementalDataList = nil then
    FSupplementalDataList := TFhirMeasureSupplementalDataList.Create;
  result := FSupplementalDataList;
end;

Function TFhirMeasure.GetHasSupplementalDataList : boolean;
begin
  result := (FSupplementalDataList <> nil) and (FSupplementalDataList.count > 0);
end;

function TFhirMeasure.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FPurpose.sizeInBytes);
  inc(result, FUsage.sizeInBytes);
  inc(result, FApprovalDate.sizeInBytes);
  inc(result, FLastReviewDate.sizeInBytes);
  inc(result, FEffectivePeriod.sizeInBytes);
  inc(result, FtopicList.sizeInBytes);
  inc(result, FcontributorList.sizeInBytes);
  inc(result, FCopyright.sizeInBytes);
  inc(result, FrelatedArtifactList.sizeInBytes);
  inc(result, Flibrary_List.sizeInBytes);
  inc(result, FDisclaimer.sizeInBytes);
  inc(result, FScoring.sizeInBytes);
  inc(result, FCompositeScoring.sizeInBytes);
  inc(result, Ftype_List.sizeInBytes);
  inc(result, FRiskAdjustment.sizeInBytes);
  inc(result, FRateAggregation.sizeInBytes);
  inc(result, FRationale.sizeInBytes);
  inc(result, FClinicalRecommendationStatement.sizeInBytes);
  inc(result, FImprovementNotation.sizeInBytes);
  inc(result, FdefinitionList.sizeInBytes);
  inc(result, FGuidance.sizeInBytes);
  inc(result, FSet_.sizeInBytes);
  inc(result, FgroupList.sizeInBytes);
  inc(result, FsupplementalDataList.sizeInBytes);
end;

{ TFhirMeasureListEnumerator }

Constructor TFhirMeasureListEnumerator.Create(list : TFhirMeasureList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMeasureListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMeasureListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMeasureListEnumerator.GetCurrent : TFhirMeasure;
begin
  Result := FList[FIndex];
end;

function TFhirMeasureListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMeasureList }
procedure TFhirMeasureList.AddItem(value: TFhirMeasure);
begin
  assert(value.ClassName = 'TFhirMeasure', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMeasure');
  add(value);
end;

function TFhirMeasureList.Append: TFhirMeasure;
begin
  result := TFhirMeasure.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureList.ClearItems;
begin
  Clear;
end;

function TFhirMeasureList.GetEnumerator : TFhirMeasureListEnumerator;
begin
  result := TFhirMeasureListEnumerator.Create(self.link);
end;

function TFhirMeasureList.Clone: TFhirMeasureList;
begin
  result := TFhirMeasureList(inherited Clone);
end;

function TFhirMeasureList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMeasureList.GetItemN(index: Integer): TFhirMeasure;
begin
  result := TFhirMeasure(ObjectByIndex[index]);
end;

function TFhirMeasureList.ItemClass: TFslObjectClass;
begin
  result := TFhirMeasure;
end;
function TFhirMeasureList.IndexOf(value: TFhirMeasure): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMeasureList.Insert(index: Integer): TFhirMeasure;
begin
  result := TFhirMeasure.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureList.InsertItem(index: Integer; value: TFhirMeasure);
begin
  assert(value is TFhirMeasure);
  Inherited Insert(index, value);
end;

function TFhirMeasureList.Item(index: Integer): TFhirMeasure;
begin
  result := TFhirMeasure(ObjectByIndex[index]);
end;

function TFhirMeasureList.Link: TFhirMeasureList;
begin
  result := TFhirMeasureList(inherited Link);
end;

procedure TFhirMeasureList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMeasureList.SetItemByIndex(index: Integer; value: TFhirMeasure);
begin
  assert(value is TFhirMeasure);
  FhirMeasures[index] := value;
end;

procedure TFhirMeasureList.SetItemN(index: Integer; value: TFhirMeasure);
begin
  assert(value is TFhirMeasure);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEASURE}

{$IFDEF FHIR_MESSAGEDEFINITION}

{ TFhirMessageDefinitionFocus }

constructor TFhirMessageDefinitionFocus.Create;
begin
  inherited;
end;

destructor TFhirMessageDefinitionFocus.Destroy;
begin
  FCode.free;
  FProfile.free;
  FMin.free;
  FMax.free;
  inherited;
end;

procedure TFhirMessageDefinitionFocus.Assign(oSource : TFslObject);
begin
  inherited;
  FCode := TFhirMessageDefinitionFocus(oSource).FCode.Link;
  profile := TFhirMessageDefinitionFocus(oSource).profile.Clone;
  minElement := TFhirMessageDefinitionFocus(oSource).minElement.Clone;
  maxElement := TFhirMessageDefinitionFocus(oSource).maxElement.Clone;
end;

procedure TFhirMessageDefinitionFocus.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'profile') Then
     list.add(self.link, 'profile', FProfile.Link);
  if (child_name = 'min') Then
     list.add(self.link, 'min', FMin.Link);
  if (child_name = 'max') Then
     list.add(self.link, 'max', FMax.Link);
end;

procedure TFhirMessageDefinitionFocus.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFHIREnum, FCode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'profile', 'Reference(StructureDefinition)', false, TFhirReference{TFhirStructureDefinition}, FProfile.Link));{2}
  oList.add(TFHIRProperty.create(self, 'min', 'unsignedInt', false, TFhirUnsignedInt, FMin.Link));{2}
  oList.add(TFHIRProperty.create(self, 'max', 'string', false, TFhirString, FMax.Link));{2}
end;

function TFhirMessageDefinitionFocus.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue);
    result := propValue
  end
  else if (propName = 'profile') then
  begin
    Profile := propValue as TFhirReference{TFhirStructureDefinition}{4b};
    result := propValue;
  end
  else if (propName = 'min') then
  begin
    MinElement := asUnsignedInt(propValue){5a};
    result := propValue;
  end
  else if (propName = 'max') then
  begin
    MaxElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMessageDefinitionFocus.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMessageDefinitionFocus.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'profile') then result := TFhirReference{TFhirStructureDefinition}.create(){4b}
  else if (propName = 'min') then result := TFhirUnsignedInt.create() {5b}
  else if (propName = 'max') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMessageDefinitionFocus.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'code'
  else if (propName = 'profile') then result := 'Reference'
  else if (propName = 'min') then result := 'unsignedInt'
  else if (propName = 'max') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMessageDefinitionFocus.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'profile') then ProfileElement := nil
  else if (propName = 'min') then MinElement := nil
  else if (propName = 'max') then MaxElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMessageDefinitionFocus.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, new){4}
  else if (propName = 'profile') then ProfileElement := new as TFhirReference{TFhirStructureDefinition}{4}
  else if (propName = 'min') then MinElement := asUnsignedInt(new){5b}
  else if (propName = 'max') then MaxElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMessageDefinitionFocus.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMessageDefinitionFocus.fhirType : string;
begin
  result := 'focus';
end;

function TFhirMessageDefinitionFocus.Link : TFhirMessageDefinitionFocus;
begin
  result := TFhirMessageDefinitionFocus(inherited Link);
end;

function TFhirMessageDefinitionFocus.Clone : TFhirMessageDefinitionFocus;
begin
  result := TFhirMessageDefinitionFocus(inherited Clone);
end;

function TFhirMessageDefinitionFocus.equals(other : TObject) : boolean;
var
  o : TFhirMessageDefinitionFocus;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMessageDefinitionFocus)) then
    result := false
  else
  begin
    o := TFhirMessageDefinitionFocus(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(profileElement, o.profileElement, true) and
      compareDeep(minElement, o.minElement, true) and compareDeep(maxElement, o.maxElement, true);
  end;
end;

function TFhirMessageDefinitionFocus.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FProfile) and isEmptyProp(FMin) and isEmptyProp(FMax);
end;

procedure TFhirMessageDefinitionFocus.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('profile');
  fields.add('min');
  fields.add('max');
end;

{ TFhirMessageDefinitionFocus }

Procedure TFhirMessageDefinitionFocus.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirMessageDefinitionFocus.GetCodeST : TFhirResourceTypesEnum;
begin
  if FCode = nil then
    result := TFhirResourceTypesEnum(0)
  else
    result := TFhirResourceTypesEnum(StringArrayIndexOfSensitive(CODES_TFhirResourceTypesEnum, FCode.value));
end;

Procedure TFhirMessageDefinitionFocus.SetCodeST(value : TFhirResourceTypesEnum);
begin
  if ord(value) = 0 then
    CodeElement := nil
  else
    CodeElement := TFhirEnum.create(SYSTEMS_TFhirResourceTypesEnum[value], CODES_TFhirResourceTypesEnum[value]);
end;

Procedure TFhirMessageDefinitionFocus.SetProfile(value : TFhirReference{TFhirStructureDefinition});
begin
  FProfile.free;
  FProfile := value;
end;

Procedure TFhirMessageDefinitionFocus.SetMin(value : TFhirUnsignedInt);
begin
  FMin.free;
  FMin := value;
end;

Function TFhirMessageDefinitionFocus.GetMinST : String;
begin
  if FMin = nil then
    result := ''
  else
    result := FMin.value;
end;

Procedure TFhirMessageDefinitionFocus.SetMinST(value : String);
begin
  if value <> '' then
  begin
    if FMin = nil then
      FMin := TFhirUnsignedInt.create;
    FMin.value := value
  end
  else if FMin <> nil then
    FMin.value := '';
end;

Procedure TFhirMessageDefinitionFocus.SetMax(value : TFhirString);
begin
  FMax.free;
  FMax := value;
end;

Function TFhirMessageDefinitionFocus.GetMaxST : String;
begin
  if FMax = nil then
    result := ''
  else
    result := FMax.value;
end;

Procedure TFhirMessageDefinitionFocus.SetMaxST(value : String);
begin
  if value <> '' then
  begin
    if FMax = nil then
      FMax := TFhirString.create;
    FMax.value := value
  end
  else if FMax <> nil then
    FMax.value := '';
end;

function TFhirMessageDefinitionFocus.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FProfile.sizeInBytes);
  inc(result, FMin.sizeInBytes);
  inc(result, FMax.sizeInBytes);
end;

{ TFhirMessageDefinitionFocusListEnumerator }

Constructor TFhirMessageDefinitionFocusListEnumerator.Create(list : TFhirMessageDefinitionFocusList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMessageDefinitionFocusListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMessageDefinitionFocusListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMessageDefinitionFocusListEnumerator.GetCurrent : TFhirMessageDefinitionFocus;
begin
  Result := FList[FIndex];
end;

function TFhirMessageDefinitionFocusListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMessageDefinitionFocusList }
procedure TFhirMessageDefinitionFocusList.AddItem(value: TFhirMessageDefinitionFocus);
begin
  assert(value.ClassName = 'TFhirMessageDefinitionFocus', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMessageDefinitionFocus');
  add(value);
end;

function TFhirMessageDefinitionFocusList.Append: TFhirMessageDefinitionFocus;
begin
  result := TFhirMessageDefinitionFocus.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageDefinitionFocusList.ClearItems;
begin
  Clear;
end;

function TFhirMessageDefinitionFocusList.GetEnumerator : TFhirMessageDefinitionFocusListEnumerator;
begin
  result := TFhirMessageDefinitionFocusListEnumerator.Create(self.link);
end;

function TFhirMessageDefinitionFocusList.Clone: TFhirMessageDefinitionFocusList;
begin
  result := TFhirMessageDefinitionFocusList(inherited Clone);
end;

function TFhirMessageDefinitionFocusList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMessageDefinitionFocusList.GetItemN(index: Integer): TFhirMessageDefinitionFocus;
begin
  result := TFhirMessageDefinitionFocus(ObjectByIndex[index]);
end;

function TFhirMessageDefinitionFocusList.ItemClass: TFslObjectClass;
begin
  result := TFhirMessageDefinitionFocus;
end;
function TFhirMessageDefinitionFocusList.IndexOf(value: TFhirMessageDefinitionFocus): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMessageDefinitionFocusList.Insert(index: Integer): TFhirMessageDefinitionFocus;
begin
  result := TFhirMessageDefinitionFocus.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageDefinitionFocusList.InsertItem(index: Integer; value: TFhirMessageDefinitionFocus);
begin
  assert(value is TFhirMessageDefinitionFocus);
  Inherited Insert(index, value);
end;

function TFhirMessageDefinitionFocusList.Item(index: Integer): TFhirMessageDefinitionFocus;
begin
  result := TFhirMessageDefinitionFocus(ObjectByIndex[index]);
end;

function TFhirMessageDefinitionFocusList.Link: TFhirMessageDefinitionFocusList;
begin
  result := TFhirMessageDefinitionFocusList(inherited Link);
end;

procedure TFhirMessageDefinitionFocusList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMessageDefinitionFocusList.SetItemByIndex(index: Integer; value: TFhirMessageDefinitionFocus);
begin
  assert(value is TFhirMessageDefinitionFocus);
  FhirMessageDefinitionFocus[index] := value;
end;

procedure TFhirMessageDefinitionFocusList.SetItemN(index: Integer; value: TFhirMessageDefinitionFocus);
begin
  assert(value is TFhirMessageDefinitionFocus);
  ObjectByIndex[index] := value;
end;

{ TFhirMessageDefinitionAllowedResponse }

constructor TFhirMessageDefinitionAllowedResponse.Create;
begin
  inherited;
end;

destructor TFhirMessageDefinitionAllowedResponse.Destroy;
begin
  FMessage.free;
  FSituation.free;
  inherited;
end;

procedure TFhirMessageDefinitionAllowedResponse.Assign(oSource : TFslObject);
begin
  inherited;
  message := TFhirMessageDefinitionAllowedResponse(oSource).message.Clone;
  situationElement := TFhirMessageDefinitionAllowedResponse(oSource).situationElement.Clone;
end;

procedure TFhirMessageDefinitionAllowedResponse.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'message') Then
     list.add(self.link, 'message', FMessage.Link);
  if (child_name = 'situation') Then
     list.add(self.link, 'situation', FSituation.Link);
end;

procedure TFhirMessageDefinitionAllowedResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'message', 'Reference(MessageDefinition)', false, TFhirReference{TFhirMessageDefinition}, FMessage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'situation', 'markdown', false, TFhirMarkdown, FSituation.Link));{2}
end;

function TFhirMessageDefinitionAllowedResponse.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'message') then
  begin
    Message := propValue as TFhirReference{TFhirMessageDefinition}{4b};
    result := propValue;
  end
  else if (propName = 'situation') then
  begin
    SituationElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMessageDefinitionAllowedResponse.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMessageDefinitionAllowedResponse.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'message') then result := TFhirReference{TFhirMessageDefinition}.create(){4b}
  else if (propName = 'situation') then result := TFhirMarkdown.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMessageDefinitionAllowedResponse.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'message') then result := 'Reference'
  else if (propName = 'situation') then result := 'markdown'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMessageDefinitionAllowedResponse.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'message') then MessageElement := nil
  else if (propName = 'situation') then SituationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMessageDefinitionAllowedResponse.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'message') then MessageElement := new as TFhirReference{TFhirMessageDefinition}{4}
  else if (propName = 'situation') then SituationElement := asMarkdown(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMessageDefinitionAllowedResponse.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMessageDefinitionAllowedResponse.fhirType : string;
begin
  result := 'allowedResponse';
end;

function TFhirMessageDefinitionAllowedResponse.Link : TFhirMessageDefinitionAllowedResponse;
begin
  result := TFhirMessageDefinitionAllowedResponse(inherited Link);
end;

function TFhirMessageDefinitionAllowedResponse.Clone : TFhirMessageDefinitionAllowedResponse;
begin
  result := TFhirMessageDefinitionAllowedResponse(inherited Clone);
end;

function TFhirMessageDefinitionAllowedResponse.equals(other : TObject) : boolean;
var
  o : TFhirMessageDefinitionAllowedResponse;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMessageDefinitionAllowedResponse)) then
    result := false
  else
  begin
    o := TFhirMessageDefinitionAllowedResponse(other);
    result := compareDeep(messageElement, o.messageElement, true) and compareDeep(situationElement, o.situationElement, true);
  end;
end;

function TFhirMessageDefinitionAllowedResponse.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMessage) and isEmptyProp(FSituation);
end;

procedure TFhirMessageDefinitionAllowedResponse.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('message');
  fields.add('situation');
end;

{ TFhirMessageDefinitionAllowedResponse }

Procedure TFhirMessageDefinitionAllowedResponse.SetMessage(value : TFhirReference{TFhirMessageDefinition});
begin
  FMessage.free;
  FMessage := value;
end;

Procedure TFhirMessageDefinitionAllowedResponse.SetSituation(value : TFhirMarkdown);
begin
  FSituation.free;
  FSituation := value;
end;

Function TFhirMessageDefinitionAllowedResponse.GetSituationST : String;
begin
  if FSituation = nil then
    result := ''
  else
    result := FSituation.value;
end;

Procedure TFhirMessageDefinitionAllowedResponse.SetSituationST(value : String);
begin
  if value <> '' then
  begin
    if FSituation = nil then
      FSituation := TFhirMarkdown.create;
    FSituation.value := value
  end
  else if FSituation <> nil then
    FSituation.value := '';
end;

function TFhirMessageDefinitionAllowedResponse.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FMessage.sizeInBytes);
  inc(result, FSituation.sizeInBytes);
end;

{ TFhirMessageDefinitionAllowedResponseListEnumerator }

Constructor TFhirMessageDefinitionAllowedResponseListEnumerator.Create(list : TFhirMessageDefinitionAllowedResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMessageDefinitionAllowedResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMessageDefinitionAllowedResponseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMessageDefinitionAllowedResponseListEnumerator.GetCurrent : TFhirMessageDefinitionAllowedResponse;
begin
  Result := FList[FIndex];
end;

function TFhirMessageDefinitionAllowedResponseListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMessageDefinitionAllowedResponseList }
procedure TFhirMessageDefinitionAllowedResponseList.AddItem(value: TFhirMessageDefinitionAllowedResponse);
begin
  assert(value.ClassName = 'TFhirMessageDefinitionAllowedResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMessageDefinitionAllowedResponse');
  add(value);
end;

function TFhirMessageDefinitionAllowedResponseList.Append: TFhirMessageDefinitionAllowedResponse;
begin
  result := TFhirMessageDefinitionAllowedResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageDefinitionAllowedResponseList.ClearItems;
begin
  Clear;
end;

function TFhirMessageDefinitionAllowedResponseList.GetEnumerator : TFhirMessageDefinitionAllowedResponseListEnumerator;
begin
  result := TFhirMessageDefinitionAllowedResponseListEnumerator.Create(self.link);
end;

function TFhirMessageDefinitionAllowedResponseList.Clone: TFhirMessageDefinitionAllowedResponseList;
begin
  result := TFhirMessageDefinitionAllowedResponseList(inherited Clone);
end;

function TFhirMessageDefinitionAllowedResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMessageDefinitionAllowedResponseList.GetItemN(index: Integer): TFhirMessageDefinitionAllowedResponse;
begin
  result := TFhirMessageDefinitionAllowedResponse(ObjectByIndex[index]);
end;

function TFhirMessageDefinitionAllowedResponseList.ItemClass: TFslObjectClass;
begin
  result := TFhirMessageDefinitionAllowedResponse;
end;
function TFhirMessageDefinitionAllowedResponseList.IndexOf(value: TFhirMessageDefinitionAllowedResponse): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMessageDefinitionAllowedResponseList.Insert(index: Integer): TFhirMessageDefinitionAllowedResponse;
begin
  result := TFhirMessageDefinitionAllowedResponse.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageDefinitionAllowedResponseList.InsertItem(index: Integer; value: TFhirMessageDefinitionAllowedResponse);
begin
  assert(value is TFhirMessageDefinitionAllowedResponse);
  Inherited Insert(index, value);
end;

function TFhirMessageDefinitionAllowedResponseList.Item(index: Integer): TFhirMessageDefinitionAllowedResponse;
begin
  result := TFhirMessageDefinitionAllowedResponse(ObjectByIndex[index]);
end;

function TFhirMessageDefinitionAllowedResponseList.Link: TFhirMessageDefinitionAllowedResponseList;
begin
  result := TFhirMessageDefinitionAllowedResponseList(inherited Link);
end;

procedure TFhirMessageDefinitionAllowedResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMessageDefinitionAllowedResponseList.SetItemByIndex(index: Integer; value: TFhirMessageDefinitionAllowedResponse);
begin
  assert(value is TFhirMessageDefinitionAllowedResponse);
  FhirMessageDefinitionAllowedResponses[index] := value;
end;

procedure TFhirMessageDefinitionAllowedResponseList.SetItemN(index: Integer; value: TFhirMessageDefinitionAllowedResponse);
begin
  assert(value is TFhirMessageDefinitionAllowedResponse);
  ObjectByIndex[index] := value;
end;

{ TFhirMessageDefinition }

constructor TFhirMessageDefinition.Create;
begin
  inherited;
end;

destructor TFhirMessageDefinition.Destroy;
begin
  FIdentifier.free;
  FPurpose.free;
  FCopyright.free;
  FBase.free;
  FParentList.Free;
  FReplacesList.Free;
  FEvent.free;
  FCategory.free;
  FFocusList.Free;
  FResponseRequired.free;
  FAllowedResponseList.Free;
  inherited;
end;

function TFhirMessageDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtMessageDefinition;
end;

procedure TFhirMessageDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirMessageDefinition(oSource).identifier.Clone;
  purposeElement := TFhirMessageDefinition(oSource).purposeElement.Clone;
  copyrightElement := TFhirMessageDefinition(oSource).copyrightElement.Clone;
  base := TFhirMessageDefinition(oSource).base.Clone;
  if (TFhirMessageDefinition(oSource).FParentList = nil) then
  begin
    FParentList.free;
    FParentList := nil;
  end
  else
  begin
    if FParentList = nil then
      FParentList := TFhirReferenceList{Resource}.Create;
    FParentList.Assign(TFhirMessageDefinition(oSource).FParentList);
  end;
  if (TFhirMessageDefinition(oSource).FReplacesList = nil) then
  begin
    FReplacesList.free;
    FReplacesList := nil;
  end
  else
  begin
    if FReplacesList = nil then
      FReplacesList := TFhirReferenceList{TFhirMessageDefinition}.Create;
    FReplacesList.Assign(TFhirMessageDefinition(oSource).FReplacesList);
  end;
  event := TFhirMessageDefinition(oSource).event.Clone;
  FCategory := TFhirMessageDefinition(oSource).FCategory.Link;
  if (TFhirMessageDefinition(oSource).FFocusList = nil) then
  begin
    FFocusList.free;
    FFocusList := nil;
  end
  else
  begin
    if FFocusList = nil then
      FFocusList := TFhirMessageDefinitionFocusList.Create;
    FFocusList.Assign(TFhirMessageDefinition(oSource).FFocusList);
  end;
  responseRequiredElement := TFhirMessageDefinition(oSource).responseRequiredElement.Clone;
  if (TFhirMessageDefinition(oSource).FAllowedResponseList = nil) then
  begin
    FAllowedResponseList.free;
    FAllowedResponseList := nil;
  end
  else
  begin
    if FAllowedResponseList = nil then
      FAllowedResponseList := TFhirMessageDefinitionAllowedResponseList.Create;
    FAllowedResponseList.Assign(TFhirMessageDefinition(oSource).FAllowedResponseList);
  end;
end;

procedure TFhirMessageDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'base') Then
     list.add(self.link, 'base', FBase.Link);
  if (child_name = 'parent') Then
    list.addAll(self, 'parent', FParentList);
  if (child_name = 'replaces') Then
    list.addAll(self, 'replaces', FReplacesList);
  if (child_name = 'event') Then
     list.add(self.link, 'event', FEvent.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'focus') Then
    list.addAll(self, 'focus', FFocusList);
  if (child_name = 'responseRequired') Then
     list.add(self.link, 'responseRequired', FResponseRequired.Link);
  if (child_name = 'allowedResponse') Then
    list.addAll(self, 'allowedResponse', FAllowedResponseList);
end;

procedure TFhirMessageDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));{2}
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));{2}
  oList.add(TFHIRProperty.create(self, 'base', 'Reference(MessageDefinition)', false, TFhirReference{TFhirMessageDefinition}, FBase.Link));{2}
  oList.add(TFHIRProperty.create(self, 'parent', 'Reference(ActivityDefinition|PlanDefinition)', true, TFhirReference{Resource}, FParentList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'replaces', 'Reference(MessageDefinition)', true, TFhirReference{TFhirMessageDefinition}, FReplacesList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'event', 'Coding', false, TFhirCoding, FEvent.Link));{2}
  oList.add(TFHIRProperty.create(self, 'category', 'code', false, TFHIREnum, FCategory.Link));{1}
  oList.add(TFHIRProperty.create(self, 'focus', '', true, TFhirMessageDefinitionFocus, FFocusList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'responseRequired', 'boolean', false, TFhirBoolean, FResponseRequired.Link));{2}
  oList.add(TFHIRProperty.create(self, 'allowedResponse', '', true, TFhirMessageDefinitionAllowedResponse, FAllowedResponseList.Link)){3};
end;

function TFhirMessageDefinition.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'base') then
  begin
    Base := propValue as TFhirReference{TFhirMessageDefinition}{4b};
    result := propValue;
  end
  else if (propName = 'parent') then
  begin
    ParentList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'replaces') then
  begin
    ReplacesList.add(propValue as TFhirReference{TFhirMessageDefinition}){2a};
    result := propValue;
  end
  else if (propName = 'event') then
  begin
    Event := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryElement := asEnum(SYSTEMS_TFhirMessageSignificanceCategoryEnum, CODES_TFhirMessageSignificanceCategoryEnum, propValue);
    result := propValue
  end
  else if (propName = 'focus') then
  begin
    FocusList.add(propValue as TFhirMessageDefinitionFocus){2a};
    result := propValue;
  end
  else if (propName = 'responseRequired') then
  begin
    ResponseRequiredElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'allowedResponse') then
  begin
    AllowedResponseList.add(propValue as TFhirMessageDefinitionAllowedResponse){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirMessageDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'parent') then ParentList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'replaces') then ReplacesList.insertItem(index, propValue as TFhirReference{TFhirMessageDefinition}){2a}
  else if (propName = 'focus') then FocusList.insertItem(index, propValue as TFhirMessageDefinitionFocus){2a}
  else if (propName = 'allowedResponse') then AllowedResponseList.insertItem(index, propValue as TFhirMessageDefinitionAllowedResponse){2a}
  else inherited;
end;

function TFhirMessageDefinition.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'purpose') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'copyright') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'base') then result := TFhirReference{TFhirMessageDefinition}.create(){4b}
  else if (propName = 'parent') then result := ParentList.new(){2}
  else if (propName = 'replaces') then result := ReplacesList.new(){2}
  else if (propName = 'event') then result := TFhirCoding.create(){4b}
  else if (propName = 'focus') then result := FocusList.new(){2}
  else if (propName = 'responseRequired') then result := TFhirBoolean.create() {5b}
  else if (propName = 'allowedResponse') then result := AllowedResponseList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirMessageDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'base') then result := 'Reference'
  else if (propName = 'parent') then result := 'Reference'
  else if (propName = 'replaces') then result := 'Reference'
  else if (propName = 'event') then result := 'Coding'
  else if (propName = 'category') then result := 'code'
  else if (propName = 'focus') then result := ''
  else if (propName = 'responseRequired') then result := 'boolean'
  else if (propName = 'allowedResponse') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMessageDefinition.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'base') then BaseElement := nil
  else if (propName = 'parent') then deletePropertyValue('parent', ParentList, value) {2}
  else if (propName = 'replaces') then deletePropertyValue('replaces', ReplacesList, value) {2}
  else if (propName = 'event') then EventElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'focus') then deletePropertyValue('focus', FocusList, value) {2}
  else if (propName = 'responseRequired') then ResponseRequiredElement := nil
  else if (propName = 'allowedResponse') then deletePropertyValue('allowedResponse', AllowedResponseList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMessageDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'purpose') then PurposeElement := asMarkdown(new){5b}
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new){5b}
  else if (propName = 'base') then BaseElement := new as TFhirReference{TFhirMessageDefinition}{4}
  else if (propName = 'parent') then replacePropertyValue('parent', ParentList, existing, new) {2}
  else if (propName = 'replaces') then replacePropertyValue('replaces', ReplacesList, existing, new) {2}
  else if (propName = 'event') then EventElement := new as TFhirCoding{4}
  else if (propName = 'category') then CategoryElement := asEnum(SYSTEMS_TFhirMessageSignificanceCategoryEnum, CODES_TFhirMessageSignificanceCategoryEnum, new){4}
  else if (propName = 'focus') then replacePropertyValue('focus', FocusList, existing, new) {2}
  else if (propName = 'responseRequired') then ResponseRequiredElement := asBoolean(new){5b}
  else if (propName = 'allowedResponse') then replacePropertyValue('allowedResponse', AllowedResponseList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMessageDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'parent') then ParentList.move(source, destination){2a}
  else if (propName = 'replaces') then ReplacesList.move(source, destination){2a}
  else if (propName = 'focus') then FocusList.move(source, destination){2a}
  else if (propName = 'allowedResponse') then AllowedResponseList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMessageDefinition.fhirType : string;
begin
  result := 'MessageDefinition';
end;

function TFhirMessageDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FPurpose) and isEmptyProp(FCopyright) and isEmptyProp(FBase) and isEmptyProp(FparentList) and isEmptyProp(FreplacesList) and isEmptyProp(FEvent) and isEmptyProp(FCategory) and isEmptyProp(FfocusList) and isEmptyProp(FResponseRequired) and isEmptyProp(FallowedResponseList);
end;

function TFhirMessageDefinition.equals(other : TObject) : boolean;
var
  o : TFhirMessageDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMessageDefinition)) then
    result := false
  else
  begin
    o := TFhirMessageDefinition(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(purposeElement, o.purposeElement, true) and
      compareDeep(copyrightElement, o.copyrightElement, true) and compareDeep(baseElement, o.baseElement, true) and
      compareDeep(parentList, o.parentList, true) and compareDeep(replacesList, o.replacesList, true) and
      compareDeep(eventElement, o.eventElement, true) and compareDeep(categoryElement, o.categoryElement, true) and
      compareDeep(focusList, o.focusList, true) and compareDeep(responseRequiredElement, o.responseRequiredElement, true) and
      compareDeep(allowedResponseList, o.allowedResponseList, true);
  end;
end;

function TFhirMessageDefinition.Link : TFhirMessageDefinition;
begin
  result := TFhirMessageDefinition(inherited Link);
end;

function TFhirMessageDefinition.Clone : TFhirMessageDefinition;
begin
  result := TFhirMessageDefinition(inherited Clone);
end;

procedure TFhirMessageDefinition.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('status');
  fields.add('experimental');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('purpose');
  fields.add('copyright');
  fields.add('base');
  fields.add('parent');
  fields.add('replaces');
  fields.add('event');
  fields.add('category');
  fields.add('focus');
  fields.add('responseRequired');
  fields.add('allowedResponse');
end;

{ TFhirMessageDefinition }

Procedure TFhirMessageDefinition.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirMessageDefinition.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

Function TFhirMessageDefinition.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

Procedure TFhirMessageDefinition.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

Procedure TFhirMessageDefinition.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

Function TFhirMessageDefinition.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

Procedure TFhirMessageDefinition.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

Procedure TFhirMessageDefinition.SetBase(value : TFhirReference{TFhirMessageDefinition});
begin
  FBase.free;
  FBase := value;
end;

Function TFhirMessageDefinition.GetParentList : TFhirReferenceList{Resource};
begin
  if FParentList = nil then
    FParentList := TFhirReferenceList{Resource}.Create;
  result := FParentList;
end;

Function TFhirMessageDefinition.GetHasParentList : boolean;
begin
  result := (FParentList <> nil) and (FParentList.count > 0);
end;

Function TFhirMessageDefinition.GetReplacesList : TFhirReferenceList{TFhirMessageDefinition};
begin
  if FReplacesList = nil then
    FReplacesList := TFhirReferenceList{TFhirMessageDefinition}.Create;
  result := FReplacesList;
end;

Function TFhirMessageDefinition.GetHasReplacesList : boolean;
begin
  result := (FReplacesList <> nil) and (FReplacesList.count > 0);
end;

Procedure TFhirMessageDefinition.SetEvent(value : TFhirCoding);
begin
  FEvent.free;
  FEvent := value;
end;

Procedure TFhirMessageDefinition.SetCategory(value : TFhirEnum);
begin
  FCategory.free;
  FCategory := value;
end;

Function TFhirMessageDefinition.GetCategoryST : TFhirMessageSignificanceCategoryEnum;
begin
  if FCategory = nil then
    result := TFhirMessageSignificanceCategoryEnum(0)
  else
    result := TFhirMessageSignificanceCategoryEnum(StringArrayIndexOfSensitive(CODES_TFhirMessageSignificanceCategoryEnum, FCategory.value));
end;

Procedure TFhirMessageDefinition.SetCategoryST(value : TFhirMessageSignificanceCategoryEnum);
begin
  if ord(value) = 0 then
    CategoryElement := nil
  else
    CategoryElement := TFhirEnum.create(SYSTEMS_TFhirMessageSignificanceCategoryEnum[value], CODES_TFhirMessageSignificanceCategoryEnum[value]);
end;

Function TFhirMessageDefinition.GetFocusList : TFhirMessageDefinitionFocusList;
begin
  if FFocusList = nil then
    FFocusList := TFhirMessageDefinitionFocusList.Create;
  result := FFocusList;
end;

Function TFhirMessageDefinition.GetHasFocusList : boolean;
begin
  result := (FFocusList <> nil) and (FFocusList.count > 0);
end;

Procedure TFhirMessageDefinition.SetResponseRequired(value : TFhirBoolean);
begin
  FResponseRequired.free;
  FResponseRequired := value;
end;

Function TFhirMessageDefinition.GetResponseRequiredST : Boolean;
begin
  if FResponseRequired = nil then
    result := false
  else
    result := FResponseRequired.value;
end;

Procedure TFhirMessageDefinition.SetResponseRequiredST(value : Boolean);
begin
  if FResponseRequired = nil then
    FResponseRequired := TFhirBoolean.create;
  FResponseRequired.value := value
end;

Function TFhirMessageDefinition.GetAllowedResponseList : TFhirMessageDefinitionAllowedResponseList;
begin
  if FAllowedResponseList = nil then
    FAllowedResponseList := TFhirMessageDefinitionAllowedResponseList.Create;
  result := FAllowedResponseList;
end;

Function TFhirMessageDefinition.GetHasAllowedResponseList : boolean;
begin
  result := (FAllowedResponseList <> nil) and (FAllowedResponseList.count > 0);
end;

function TFhirMessageDefinition.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FPurpose.sizeInBytes);
  inc(result, FCopyright.sizeInBytes);
  inc(result, FBase.sizeInBytes);
  inc(result, FparentList.sizeInBytes);
  inc(result, FreplacesList.sizeInBytes);
  inc(result, FEvent.sizeInBytes);
  inc(result, FCategory.sizeInBytes);
  inc(result, FfocusList.sizeInBytes);
  inc(result, FResponseRequired.sizeInBytes);
  inc(result, FallowedResponseList.sizeInBytes);
end;

{ TFhirMessageDefinitionListEnumerator }

Constructor TFhirMessageDefinitionListEnumerator.Create(list : TFhirMessageDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMessageDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMessageDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMessageDefinitionListEnumerator.GetCurrent : TFhirMessageDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirMessageDefinitionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirMessageDefinitionList }
procedure TFhirMessageDefinitionList.AddItem(value: TFhirMessageDefinition);
begin
  assert(value.ClassName = 'TFhirMessageDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMessageDefinition');
  add(value);
end;

function TFhirMessageDefinitionList.Append: TFhirMessageDefinition;
begin
  result := TFhirMessageDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirMessageDefinitionList.GetEnumerator : TFhirMessageDefinitionListEnumerator;
begin
  result := TFhirMessageDefinitionListEnumerator.Create(self.link);
end;

function TFhirMessageDefinitionList.Clone: TFhirMessageDefinitionList;
begin
  result := TFhirMessageDefinitionList(inherited Clone);
end;

function TFhirMessageDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMessageDefinitionList.GetItemN(index: Integer): TFhirMessageDefinition;
begin
  result := TFhirMessageDefinition(ObjectByIndex[index]);
end;

function TFhirMessageDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirMessageDefinition;
end;
function TFhirMessageDefinitionList.IndexOf(value: TFhirMessageDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMessageDefinitionList.Insert(index: Integer): TFhirMessageDefinition;
begin
  result := TFhirMessageDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageDefinitionList.InsertItem(index: Integer; value: TFhirMessageDefinition);
begin
  assert(value is TFhirMessageDefinition);
  Inherited Insert(index, value);
end;

function TFhirMessageDefinitionList.Item(index: Integer): TFhirMessageDefinition;
begin
  result := TFhirMessageDefinition(ObjectByIndex[index]);
end;

function TFhirMessageDefinitionList.Link: TFhirMessageDefinitionList;
begin
  result := TFhirMessageDefinitionList(inherited Link);
end;

procedure TFhirMessageDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMessageDefinitionList.SetItemByIndex(index: Integer; value: TFhirMessageDefinition);
begin
  assert(value is TFhirMessageDefinition);
  FhirMessageDefinitions[index] := value;
end;

procedure TFhirMessageDefinitionList.SetItemN(index: Integer; value: TFhirMessageDefinition);
begin
  assert(value is TFhirMessageDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MESSAGEDEFINITION}

{$IFDEF FHIR_NAMINGSYSTEM}

{ TFhirNamingSystemUniqueId }

constructor TFhirNamingSystemUniqueId.Create;
begin
  inherited;
end;

destructor TFhirNamingSystemUniqueId.Destroy;
begin
  FType_.free;
  FValue.free;
  FPreferred.free;
  FComment.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirNamingSystemUniqueId.Assign(oSource : TFslObject);
begin
  inherited;
  FType_ := TFhirNamingSystemUniqueId(oSource).FType_.Link;
  valueElement := TFhirNamingSystemUniqueId(oSource).valueElement.Clone;
  preferredElement := TFhirNamingSystemUniqueId(oSource).preferredElement.Clone;
  commentElement := TFhirNamingSystemUniqueId(oSource).commentElement.Clone;
  period := TFhirNamingSystemUniqueId(oSource).period.Clone;
end;

procedure TFhirNamingSystemUniqueId.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
  if (child_name = 'preferred') Then
     list.add(self.link, 'preferred', FPreferred.Link);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirNamingSystemUniqueId.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'value', 'string', false, TFhirString, FValue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'preferred', 'boolean', false, TFhirBoolean, FPreferred.Link));{2}
  oList.add(TFHIRProperty.create(self, 'comment', 'string', false, TFhirString, FComment.Link));{2}
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));{2}
end;

function TFhirNamingSystemUniqueId.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirNamingsystemIdentifierTypeEnum, CODES_TFhirNamingsystemIdentifierTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'value') then
  begin
    ValueElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'preferred') then
  begin
    PreferredElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNamingSystemUniqueId.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirNamingSystemUniqueId.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'value') then result := TFhirString.create() {5b}
  else if (propName = 'preferred') then result := TFhirBoolean.create() {5b}
  else if (propName = 'comment') then result := TFhirString.create() {5b}
  else if (propName = 'period') then result := TFhirPeriod.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirNamingSystemUniqueId.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'value') then result := 'string'
  else if (propName = 'preferred') then result := 'boolean'
  else if (propName = 'comment') then result := 'string'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNamingSystemUniqueId.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'value') then ValueElement := nil
  else if (propName = 'preferred') then PreferredElement := nil
  else if (propName = 'comment') then CommentElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNamingSystemUniqueId.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirNamingsystemIdentifierTypeEnum, CODES_TFhirNamingsystemIdentifierTypeEnum, new){4}
  else if (propName = 'value') then ValueElement := asString(new){5b}
  else if (propName = 'preferred') then PreferredElement := asBoolean(new){5b}
  else if (propName = 'comment') then CommentElement := asString(new){5b}
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNamingSystemUniqueId.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirNamingSystemUniqueId.fhirType : string;
begin
  result := 'uniqueId';
end;

function TFhirNamingSystemUniqueId.Link : TFhirNamingSystemUniqueId;
begin
  result := TFhirNamingSystemUniqueId(inherited Link);
end;

function TFhirNamingSystemUniqueId.Clone : TFhirNamingSystemUniqueId;
begin
  result := TFhirNamingSystemUniqueId(inherited Clone);
end;

function TFhirNamingSystemUniqueId.equals(other : TObject) : boolean;
var
  o : TFhirNamingSystemUniqueId;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNamingSystemUniqueId)) then
    result := false
  else
  begin
    o := TFhirNamingSystemUniqueId(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true) and
      compareDeep(preferredElement, o.preferredElement, true) and compareDeep(commentElement, o.commentElement, true) and
      compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirNamingSystemUniqueId.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue) and isEmptyProp(FPreferred) and isEmptyProp(FComment) and isEmptyProp(FPeriod);
end;

procedure TFhirNamingSystemUniqueId.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('value');
  fields.add('preferred');
  fields.add('comment');
  fields.add('period');
end;

{ TFhirNamingSystemUniqueId }

Procedure TFhirNamingSystemUniqueId.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirNamingSystemUniqueId.GetType_ST : TFhirNamingsystemIdentifierTypeEnum;
begin
  if FType_ = nil then
    result := TFhirNamingsystemIdentifierTypeEnum(0)
  else
    result := TFhirNamingsystemIdentifierTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirNamingsystemIdentifierTypeEnum, FType_.value));
end;

Procedure TFhirNamingSystemUniqueId.SetType_ST(value : TFhirNamingsystemIdentifierTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirNamingsystemIdentifierTypeEnum[value], CODES_TFhirNamingsystemIdentifierTypeEnum[value]);
end;

Procedure TFhirNamingSystemUniqueId.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirNamingSystemUniqueId.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

Procedure TFhirNamingSystemUniqueId.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

Procedure TFhirNamingSystemUniqueId.SetPreferred(value : TFhirBoolean);
begin
  FPreferred.free;
  FPreferred := value;
end;

Function TFhirNamingSystemUniqueId.GetPreferredST : Boolean;
begin
  if FPreferred = nil then
    result := false
  else
    result := FPreferred.value;
end;

Procedure TFhirNamingSystemUniqueId.SetPreferredST(value : Boolean);
begin
  if FPreferred = nil then
    FPreferred := TFhirBoolean.create;
  FPreferred.value := value
end;

Procedure TFhirNamingSystemUniqueId.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value;
end;

Function TFhirNamingSystemUniqueId.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

Procedure TFhirNamingSystemUniqueId.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

Procedure TFhirNamingSystemUniqueId.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

function TFhirNamingSystemUniqueId.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FValue.sizeInBytes);
  inc(result, FPreferred.sizeInBytes);
  inc(result, FComment.sizeInBytes);
  inc(result, FPeriod.sizeInBytes);
end;

{ TFhirNamingSystemUniqueIdListEnumerator }

Constructor TFhirNamingSystemUniqueIdListEnumerator.Create(list : TFhirNamingSystemUniqueIdList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNamingSystemUniqueIdListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNamingSystemUniqueIdListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNamingSystemUniqueIdListEnumerator.GetCurrent : TFhirNamingSystemUniqueId;
begin
  Result := FList[FIndex];
end;

function TFhirNamingSystemUniqueIdListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirNamingSystemUniqueIdList }
procedure TFhirNamingSystemUniqueIdList.AddItem(value: TFhirNamingSystemUniqueId);
begin
  assert(value.ClassName = 'TFhirNamingSystemUniqueId', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNamingSystemUniqueId');
  add(value);
end;

function TFhirNamingSystemUniqueIdList.Append: TFhirNamingSystemUniqueId;
begin
  result := TFhirNamingSystemUniqueId.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNamingSystemUniqueIdList.ClearItems;
begin
  Clear;
end;

function TFhirNamingSystemUniqueIdList.GetEnumerator : TFhirNamingSystemUniqueIdListEnumerator;
begin
  result := TFhirNamingSystemUniqueIdListEnumerator.Create(self.link);
end;

function TFhirNamingSystemUniqueIdList.Clone: TFhirNamingSystemUniqueIdList;
begin
  result := TFhirNamingSystemUniqueIdList(inherited Clone);
end;

function TFhirNamingSystemUniqueIdList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNamingSystemUniqueIdList.GetItemN(index: Integer): TFhirNamingSystemUniqueId;
begin
  result := TFhirNamingSystemUniqueId(ObjectByIndex[index]);
end;

function TFhirNamingSystemUniqueIdList.ItemClass: TFslObjectClass;
begin
  result := TFhirNamingSystemUniqueId;
end;
function TFhirNamingSystemUniqueIdList.IndexOf(value: TFhirNamingSystemUniqueId): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNamingSystemUniqueIdList.Insert(index: Integer): TFhirNamingSystemUniqueId;
begin
  result := TFhirNamingSystemUniqueId.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNamingSystemUniqueIdList.InsertItem(index: Integer; value: TFhirNamingSystemUniqueId);
begin
  assert(value is TFhirNamingSystemUniqueId);
  Inherited Insert(index, value);
end;

function TFhirNamingSystemUniqueIdList.Item(index: Integer): TFhirNamingSystemUniqueId;
begin
  result := TFhirNamingSystemUniqueId(ObjectByIndex[index]);
end;

function TFhirNamingSystemUniqueIdList.Link: TFhirNamingSystemUniqueIdList;
begin
  result := TFhirNamingSystemUniqueIdList(inherited Link);
end;

procedure TFhirNamingSystemUniqueIdList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNamingSystemUniqueIdList.SetItemByIndex(index: Integer; value: TFhirNamingSystemUniqueId);
begin
  assert(value is TFhirNamingSystemUniqueId);
  FhirNamingSystemUniqueIds[index] := value;
end;

procedure TFhirNamingSystemUniqueIdList.SetItemN(index: Integer; value: TFhirNamingSystemUniqueId);
begin
  assert(value is TFhirNamingSystemUniqueId);
  ObjectByIndex[index] := value;
end;

{ TFhirNamingSystem }

constructor TFhirNamingSystem.Create;
begin
  inherited;
end;

destructor TFhirNamingSystem.Destroy;
begin
  FKind.free;
  FResponsible.free;
  FType_.free;
  FUsage.free;
  FUniqueIdList.Free;
  FReplacedBy.free;
  inherited;
end;

function TFhirNamingSystem.GetResourceType : TFhirResourceType;
begin
  result := frtNamingSystem;
end;

procedure TFhirNamingSystem.Assign(oSource : TFslObject);
begin
  inherited;
  FKind := TFhirNamingSystem(oSource).FKind.Link;
  responsibleElement := TFhirNamingSystem(oSource).responsibleElement.Clone;
  type_ := TFhirNamingSystem(oSource).type_.Clone;
  usageElement := TFhirNamingSystem(oSource).usageElement.Clone;
  if (TFhirNamingSystem(oSource).FUniqueIdList = nil) then
  begin
    FUniqueIdList.free;
    FUniqueIdList := nil;
  end
  else
  begin
    if FUniqueIdList = nil then
      FUniqueIdList := TFhirNamingSystemUniqueIdList.Create;
    FUniqueIdList.Assign(TFhirNamingSystem(oSource).FUniqueIdList);
  end;
  replacedBy := TFhirNamingSystem(oSource).replacedBy.Clone;
end;

procedure TFhirNamingSystem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'kind') Then
     list.add(self.link, 'kind', FKind.Link);
  if (child_name = 'responsible') Then
     list.add(self.link, 'responsible', FResponsible.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'usage') Then
     list.add(self.link, 'usage', FUsage.Link);
  if (child_name = 'uniqueId') Then
    list.addAll(self, 'uniqueId', FUniqueIdList);
  if (child_name = 'replacedBy') Then
     list.add(self.link, 'replacedBy', FReplacedBy.Link);
end;

procedure TFhirNamingSystem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'kind', 'code', false, TFHIREnum, FKind.Link));{1}
  oList.add(TFHIRProperty.create(self, 'responsible', 'string', false, TFhirString, FResponsible.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'usage', 'string', false, TFhirString, FUsage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'uniqueId', '', true, TFhirNamingSystemUniqueId, FUniqueIdList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'replacedBy', 'Reference(NamingSystem)', false, TFhirReference{TFhirNamingSystem}, FReplacedBy.Link));{2}
end;

function TFhirNamingSystem.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'kind') then
  begin
    KindElement := asEnum(SYSTEMS_TFhirNamingsystemTypeEnum, CODES_TFhirNamingsystemTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'responsible') then
  begin
    ResponsibleElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'usage') then
  begin
    UsageElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'uniqueId') then
  begin
    UniqueIdList.add(propValue as TFhirNamingSystemUniqueId){2a};
    result := propValue;
  end
  else if (propName = 'replacedBy') then
  begin
    ReplacedBy := propValue as TFhirReference{TFhirNamingSystem}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirNamingSystem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'uniqueId') then UniqueIdList.insertItem(index, propValue as TFhirNamingSystemUniqueId){2a}
  else inherited;
end;

function TFhirNamingSystem.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'responsible') then result := TFhirString.create() {5b}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'usage') then result := TFhirString.create() {5b}
  else if (propName = 'uniqueId') then result := UniqueIdList.new(){2}
  else if (propName = 'replacedBy') then result := TFhirReference{TFhirNamingSystem}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirNamingSystem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'kind') then result := 'code'
  else if (propName = 'responsible') then result := 'string'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'usage') then result := 'string'
  else if (propName = 'uniqueId') then result := ''
  else if (propName = 'replacedBy') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNamingSystem.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'kind') then KindElement := nil
  else if (propName = 'responsible') then ResponsibleElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'usage') then UsageElement := nil
  else if (propName = 'uniqueId') then deletePropertyValue('uniqueId', UniqueIdList, value) {2}
  else if (propName = 'replacedBy') then ReplacedByElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNamingSystem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'kind') then KindElement := asEnum(SYSTEMS_TFhirNamingsystemTypeEnum, CODES_TFhirNamingsystemTypeEnum, new){4}
  else if (propName = 'responsible') then ResponsibleElement := asString(new){5b}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'usage') then UsageElement := asString(new){5b}
  else if (propName = 'uniqueId') then replacePropertyValue('uniqueId', UniqueIdList, existing, new) {2}
  else if (propName = 'replacedBy') then ReplacedByElement := new as TFhirReference{TFhirNamingSystem}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNamingSystem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'uniqueId') then UniqueIdList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirNamingSystem.fhirType : string;
begin
  result := 'NamingSystem';
end;

function TFhirNamingSystem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FKind) and isEmptyProp(FResponsible) and isEmptyProp(FType_) and isEmptyProp(FUsage) and isEmptyProp(FuniqueIdList) and isEmptyProp(FReplacedBy);
end;

function TFhirNamingSystem.equals(other : TObject) : boolean;
var
  o : TFhirNamingSystem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNamingSystem)) then
    result := false
  else
  begin
    o := TFhirNamingSystem(other);
    result := compareDeep(kindElement, o.kindElement, true) and compareDeep(responsibleElement, o.responsibleElement, true) and
      compareDeep(type_Element, o.type_Element, true) and compareDeep(usageElement, o.usageElement, true) and
      compareDeep(uniqueIdList, o.uniqueIdList, true) and compareDeep(replacedByElement, o.replacedByElement, true);
  end;
end;

function TFhirNamingSystem.Link : TFhirNamingSystem;
begin
  result := TFhirNamingSystem(inherited Link);
end;

function TFhirNamingSystem.Clone : TFhirNamingSystem;
begin
  result := TFhirNamingSystem(inherited Clone);
end;

procedure TFhirNamingSystem.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('name');
  fields.add('status');
  fields.add('kind');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('responsible');
  fields.add('type');
  fields.add('description');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('usage');
  fields.add('uniqueId');
  fields.add('replacedBy');
end;

{ TFhirNamingSystem }

Procedure TFhirNamingSystem.SetKind(value : TFhirEnum);
begin
  FKind.free;
  FKind := value;
end;

Function TFhirNamingSystem.GetKindST : TFhirNamingsystemTypeEnum;
begin
  if FKind = nil then
    result := TFhirNamingsystemTypeEnum(0)
  else
    result := TFhirNamingsystemTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirNamingsystemTypeEnum, FKind.value));
end;

Procedure TFhirNamingSystem.SetKindST(value : TFhirNamingsystemTypeEnum);
begin
  if ord(value) = 0 then
    KindElement := nil
  else
    KindElement := TFhirEnum.create(SYSTEMS_TFhirNamingsystemTypeEnum[value], CODES_TFhirNamingsystemTypeEnum[value]);
end;

Procedure TFhirNamingSystem.SetResponsible(value : TFhirString);
begin
  FResponsible.free;
  FResponsible := value;
end;

Function TFhirNamingSystem.GetResponsibleST : String;
begin
  if FResponsible = nil then
    result := ''
  else
    result := FResponsible.value;
end;

Procedure TFhirNamingSystem.SetResponsibleST(value : String);
begin
  if value <> '' then
  begin
    if FResponsible = nil then
      FResponsible := TFhirString.create;
    FResponsible.value := value
  end
  else if FResponsible <> nil then
    FResponsible.value := '';
end;

Procedure TFhirNamingSystem.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirNamingSystem.SetUsage(value : TFhirString);
begin
  FUsage.free;
  FUsage := value;
end;

Function TFhirNamingSystem.GetUsageST : String;
begin
  if FUsage = nil then
    result := ''
  else
    result := FUsage.value;
end;

Procedure TFhirNamingSystem.SetUsageST(value : String);
begin
  if value <> '' then
  begin
    if FUsage = nil then
      FUsage := TFhirString.create;
    FUsage.value := value
  end
  else if FUsage <> nil then
    FUsage.value := '';
end;

Function TFhirNamingSystem.GetUniqueIdList : TFhirNamingSystemUniqueIdList;
begin
  if FUniqueIdList = nil then
    FUniqueIdList := TFhirNamingSystemUniqueIdList.Create;
  result := FUniqueIdList;
end;

Function TFhirNamingSystem.GetHasUniqueIdList : boolean;
begin
  result := (FUniqueIdList <> nil) and (FUniqueIdList.count > 0);
end;

Procedure TFhirNamingSystem.SetReplacedBy(value : TFhirReference{TFhirNamingSystem});
begin
  FReplacedBy.free;
  FReplacedBy := value;
end;

function TFhirNamingSystem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FKind.sizeInBytes);
  inc(result, FResponsible.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FUsage.sizeInBytes);
  inc(result, FuniqueIdList.sizeInBytes);
  inc(result, FReplacedBy.sizeInBytes);
end;

{ TFhirNamingSystemListEnumerator }

Constructor TFhirNamingSystemListEnumerator.Create(list : TFhirNamingSystemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNamingSystemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNamingSystemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNamingSystemListEnumerator.GetCurrent : TFhirNamingSystem;
begin
  Result := FList[FIndex];
end;

function TFhirNamingSystemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirNamingSystemList }
procedure TFhirNamingSystemList.AddItem(value: TFhirNamingSystem);
begin
  assert(value.ClassName = 'TFhirNamingSystem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNamingSystem');
  add(value);
end;

function TFhirNamingSystemList.Append: TFhirNamingSystem;
begin
  result := TFhirNamingSystem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNamingSystemList.ClearItems;
begin
  Clear;
end;

function TFhirNamingSystemList.GetEnumerator : TFhirNamingSystemListEnumerator;
begin
  result := TFhirNamingSystemListEnumerator.Create(self.link);
end;

function TFhirNamingSystemList.Clone: TFhirNamingSystemList;
begin
  result := TFhirNamingSystemList(inherited Clone);
end;

function TFhirNamingSystemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNamingSystemList.GetItemN(index: Integer): TFhirNamingSystem;
begin
  result := TFhirNamingSystem(ObjectByIndex[index]);
end;

function TFhirNamingSystemList.ItemClass: TFslObjectClass;
begin
  result := TFhirNamingSystem;
end;
function TFhirNamingSystemList.IndexOf(value: TFhirNamingSystem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNamingSystemList.Insert(index: Integer): TFhirNamingSystem;
begin
  result := TFhirNamingSystem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNamingSystemList.InsertItem(index: Integer; value: TFhirNamingSystem);
begin
  assert(value is TFhirNamingSystem);
  Inherited Insert(index, value);
end;

function TFhirNamingSystemList.Item(index: Integer): TFhirNamingSystem;
begin
  result := TFhirNamingSystem(ObjectByIndex[index]);
end;

function TFhirNamingSystemList.Link: TFhirNamingSystemList;
begin
  result := TFhirNamingSystemList(inherited Link);
end;

procedure TFhirNamingSystemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNamingSystemList.SetItemByIndex(index: Integer; value: TFhirNamingSystem);
begin
  assert(value is TFhirNamingSystem);
  FhirNamingSystems[index] := value;
end;

procedure TFhirNamingSystemList.SetItemN(index: Integer; value: TFhirNamingSystem);
begin
  assert(value is TFhirNamingSystem);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_NAMINGSYSTEM}

{$IFDEF FHIR_OPERATIONDEFINITION}

{ TFhirOperationDefinitionParameter }

constructor TFhirOperationDefinitionParameter.Create;
begin
  inherited;
end;

destructor TFhirOperationDefinitionParameter.Destroy;
begin
  FName.free;
  FUse.free;
  FMin.free;
  FMax.free;
  FDocumentation.free;
  FType_.free;
  FSearchType.free;
  FProfile.free;
  FBinding.free;
  FPartList.Free;
  inherited;
end;

procedure TFhirOperationDefinitionParameter.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirOperationDefinitionParameter(oSource).nameElement.Clone;
  FUse := TFhirOperationDefinitionParameter(oSource).FUse.Link;
  minElement := TFhirOperationDefinitionParameter(oSource).minElement.Clone;
  maxElement := TFhirOperationDefinitionParameter(oSource).maxElement.Clone;
  documentationElement := TFhirOperationDefinitionParameter(oSource).documentationElement.Clone;
  FType_ := TFhirOperationDefinitionParameter(oSource).FType_.Link;
  FSearchType := TFhirOperationDefinitionParameter(oSource).FSearchType.Link;
  profile := TFhirOperationDefinitionParameter(oSource).profile.Clone;
  binding := TFhirOperationDefinitionParameter(oSource).binding.Clone;
  if (TFhirOperationDefinitionParameter(oSource).FPartList = nil) then
  begin
    FPartList.free;
    FPartList := nil;
  end
  else
  begin
    if FPartList = nil then
      FPartList := TFhirOperationDefinitionParameterList.Create;
    FPartList.Assign(TFhirOperationDefinitionParameter(oSource).FPartList);
  end;
end;

procedure TFhirOperationDefinitionParameter.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'use') Then
     list.add(self.link, 'use', FUse.Link);
  if (child_name = 'min') Then
     list.add(self.link, 'min', FMin.Link);
  if (child_name = 'max') Then
     list.add(self.link, 'max', FMax.Link);
  if (child_name = 'documentation') Then
     list.add(self.link, 'documentation', FDocumentation.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'searchType') Then
     list.add(self.link, 'searchType', FSearchType.Link);
  if (child_name = 'profile') Then
     list.add(self.link, 'profile', FProfile.Link);
  if (child_name = 'binding') Then
     list.add(self.link, 'binding', FBinding.Link);
  if (child_name = 'part') Then
    list.addAll(self, 'part', FPartList);
end;

procedure TFhirOperationDefinitionParameter.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'code', false, TFhirCode, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'use', 'code', false, TFHIREnum, FUse.Link));{1}
  oList.add(TFHIRProperty.create(self, 'min', 'integer', false, TFhirInteger, FMin.Link));{2}
  oList.add(TFHIRProperty.create(self, 'max', 'string', false, TFhirString, FMax.Link));{2}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', false, TFhirString, FDocumentation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'searchType', 'code', false, TFHIREnum, FSearchType.Link));{1}
  oList.add(TFHIRProperty.create(self, 'profile', 'Reference(StructureDefinition)', false, TFhirReference{TFhirStructureDefinition}, FProfile.Link));{2}
  oList.add(TFHIRProperty.create(self, 'binding', '', false, TFhirOperationDefinitionParameterBinding, FBinding.Link));{2}
  oList.add(TFHIRProperty.create(self, 'part', '@OperationDefinition.parameter', true, TFhirOperationDefinitionParameter, FPartList.Link)){3};
end;

function TFhirOperationDefinitionParameter.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'use') then
  begin
    UseElement := asEnum(SYSTEMS_TFhirOperationParameterUseEnum, CODES_TFhirOperationParameterUseEnum, propValue);
    result := propValue
  end
  else if (propName = 'min') then
  begin
    MinElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'max') then
  begin
    MaxElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'documentation') then
  begin
    DocumentationElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirAllTypesEnum, CODES_TFhirAllTypesEnum, propValue);
    result := propValue
  end
  else if (propName = 'searchType') then
  begin
    SearchTypeElement := asEnum(SYSTEMS_TFhirSearchParamTypeEnum, CODES_TFhirSearchParamTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'profile') then
  begin
    Profile := propValue as TFhirReference{TFhirStructureDefinition}{4b};
    result := propValue;
  end
  else if (propName = 'binding') then
  begin
    Binding := propValue as TFhirOperationDefinitionParameterBinding{4b};
    result := propValue;
  end
  else if (propName = 'part') then
  begin
    PartList.add(propValue as TFhirOperationDefinitionParameter){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirOperationDefinitionParameter.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'part') then PartList.insertItem(index, propValue as TFhirOperationDefinitionParameter){2a}
  else inherited;
end;

function TFhirOperationDefinitionParameter.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirCode.create() {5b}
  else if (propName = 'min') then result := TFhirInteger.create() {5b}
  else if (propName = 'max') then result := TFhirString.create() {5b}
  else if (propName = 'documentation') then result := TFhirString.create() {5b}
  else if (propName = 'profile') then result := TFhirReference{TFhirStructureDefinition}.create(){4b}
  else if (propName = 'binding') then result := TFhirOperationDefinitionParameterBinding.create(){4b}
  else if (propName = 'part') then result := PartList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirOperationDefinitionParameter.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'code'
  else if (propName = 'use') then result := 'code'
  else if (propName = 'min') then result := 'integer'
  else if (propName = 'max') then result := 'string'
  else if (propName = 'documentation') then result := 'string'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'searchType') then result := 'code'
  else if (propName = 'profile') then result := 'Reference'
  else if (propName = 'binding') then result := ''
  else if (propName = 'part') then result := '@OperationDefinition.parameter'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirOperationDefinitionParameter.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'use') then UseElement := nil
  else if (propName = 'min') then MinElement := nil
  else if (propName = 'max') then MaxElement := nil
  else if (propName = 'documentation') then DocumentationElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'searchType') then SearchTypeElement := nil
  else if (propName = 'profile') then ProfileElement := nil
  else if (propName = 'binding') then BindingElement := nil
  else if (propName = 'part') then deletePropertyValue('part', PartList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirOperationDefinitionParameter.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asCode(new){5b}
  else if (propName = 'use') then UseElement := asEnum(SYSTEMS_TFhirOperationParameterUseEnum, CODES_TFhirOperationParameterUseEnum, new){4}
  else if (propName = 'min') then MinElement := asInteger(new){5b}
  else if (propName = 'max') then MaxElement := asString(new){5b}
  else if (propName = 'documentation') then DocumentationElement := asString(new){5b}
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirAllTypesEnum, CODES_TFhirAllTypesEnum, new){4}
  else if (propName = 'searchType') then SearchTypeElement := asEnum(SYSTEMS_TFhirSearchParamTypeEnum, CODES_TFhirSearchParamTypeEnum, new){4}
  else if (propName = 'profile') then ProfileElement := new as TFhirReference{TFhirStructureDefinition}{4}
  else if (propName = 'binding') then BindingElement := new as TFhirOperationDefinitionParameterBinding{4}
  else if (propName = 'part') then replacePropertyValue('part', PartList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirOperationDefinitionParameter.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'part') then PartList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirOperationDefinitionParameter.fhirType : string;
begin
  result := 'parameter';
end;

function TFhirOperationDefinitionParameter.Link : TFhirOperationDefinitionParameter;
begin
  result := TFhirOperationDefinitionParameter(inherited Link);
end;

function TFhirOperationDefinitionParameter.Clone : TFhirOperationDefinitionParameter;
begin
  result := TFhirOperationDefinitionParameter(inherited Clone);
end;

function TFhirOperationDefinitionParameter.equals(other : TObject) : boolean;
var
  o : TFhirOperationDefinitionParameter;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirOperationDefinitionParameter)) then
    result := false
  else
  begin
    o := TFhirOperationDefinitionParameter(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(useElement, o.useElement, true) and
      compareDeep(minElement, o.minElement, true) and compareDeep(maxElement, o.maxElement, true) and
      compareDeep(documentationElement, o.documentationElement, true) and compareDeep(type_Element, o.type_Element, true) and
      compareDeep(searchTypeElement, o.searchTypeElement, true) and compareDeep(profileElement, o.profileElement, true) and
      compareDeep(bindingElement, o.bindingElement, true) and compareDeep(partList, o.partList, true);
  end;
end;

function TFhirOperationDefinitionParameter.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FUse) and isEmptyProp(FMin) and isEmptyProp(FMax) and isEmptyProp(FDocumentation) and isEmptyProp(FType_) and isEmptyProp(FSearchType) and isEmptyProp(FProfile) and isEmptyProp(FBinding) and isEmptyProp(FpartList);
end;

procedure TFhirOperationDefinitionParameter.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('use');
  fields.add('min');
  fields.add('max');
  fields.add('documentation');
  fields.add('type');
  fields.add('searchType');
  fields.add('profile');
  fields.add('binding');
  fields.add('part');
end;

{ TFhirOperationDefinitionParameter }

Procedure TFhirOperationDefinitionParameter.SetName(value : TFhirCode);
begin
  FName.free;
  FName := value;
end;

Function TFhirOperationDefinitionParameter.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirOperationDefinitionParameter.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirCode.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirOperationDefinitionParameter.SetUse(value : TFhirEnum);
begin
  FUse.free;
  FUse := value;
end;

Function TFhirOperationDefinitionParameter.GetUseST : TFhirOperationParameterUseEnum;
begin
  if FUse = nil then
    result := TFhirOperationParameterUseEnum(0)
  else
    result := TFhirOperationParameterUseEnum(StringArrayIndexOfSensitive(CODES_TFhirOperationParameterUseEnum, FUse.value));
end;

Procedure TFhirOperationDefinitionParameter.SetUseST(value : TFhirOperationParameterUseEnum);
begin
  if ord(value) = 0 then
    UseElement := nil
  else
    UseElement := TFhirEnum.create(SYSTEMS_TFhirOperationParameterUseEnum[value], CODES_TFhirOperationParameterUseEnum[value]);
end;

Procedure TFhirOperationDefinitionParameter.SetMin(value : TFhirInteger);
begin
  FMin.free;
  FMin := value;
end;

Function TFhirOperationDefinitionParameter.GetMinST : String;
begin
  if FMin = nil then
    result := ''
  else
    result := FMin.value;
end;

Procedure TFhirOperationDefinitionParameter.SetMinST(value : String);
begin
  if value <> '' then
  begin
    if FMin = nil then
      FMin := TFhirInteger.create;
    FMin.value := value
  end
  else if FMin <> nil then
    FMin.value := '';
end;

Procedure TFhirOperationDefinitionParameter.SetMax(value : TFhirString);
begin
  FMax.free;
  FMax := value;
end;

Function TFhirOperationDefinitionParameter.GetMaxST : String;
begin
  if FMax = nil then
    result := ''
  else
    result := FMax.value;
end;

Procedure TFhirOperationDefinitionParameter.SetMaxST(value : String);
begin
  if value <> '' then
  begin
    if FMax = nil then
      FMax := TFhirString.create;
    FMax.value := value
  end
  else if FMax <> nil then
    FMax.value := '';
end;

Procedure TFhirOperationDefinitionParameter.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirOperationDefinitionParameter.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

Procedure TFhirOperationDefinitionParameter.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

Procedure TFhirOperationDefinitionParameter.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirOperationDefinitionParameter.GetType_ST : TFhirAllTypesEnum;
begin
  if FType_ = nil then
    result := TFhirAllTypesEnum(0)
  else
    result := TFhirAllTypesEnum(StringArrayIndexOfSensitive(CODES_TFhirAllTypesEnum, FType_.value));
end;

Procedure TFhirOperationDefinitionParameter.SetType_ST(value : TFhirAllTypesEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirAllTypesEnum[value], CODES_TFhirAllTypesEnum[value]);
end;

Procedure TFhirOperationDefinitionParameter.SetSearchType(value : TFhirEnum);
begin
  FSearchType.free;
  FSearchType := value;
end;

Function TFhirOperationDefinitionParameter.GetSearchTypeST : TFhirSearchParamTypeEnum;
begin
  if FSearchType = nil then
    result := TFhirSearchParamTypeEnum(0)
  else
    result := TFhirSearchParamTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirSearchParamTypeEnum, FSearchType.value));
end;

Procedure TFhirOperationDefinitionParameter.SetSearchTypeST(value : TFhirSearchParamTypeEnum);
begin
  if ord(value) = 0 then
    SearchTypeElement := nil
  else
    SearchTypeElement := TFhirEnum.create(SYSTEMS_TFhirSearchParamTypeEnum[value], CODES_TFhirSearchParamTypeEnum[value]);
end;

Procedure TFhirOperationDefinitionParameter.SetProfile(value : TFhirReference{TFhirStructureDefinition});
begin
  FProfile.free;
  FProfile := value;
end;

Procedure TFhirOperationDefinitionParameter.SetBinding(value : TFhirOperationDefinitionParameterBinding);
begin
  FBinding.free;
  FBinding := value;
end;

Function TFhirOperationDefinitionParameter.GetPartList : TFhirOperationDefinitionParameterList;
begin
  if FPartList = nil then
    FPartList := TFhirOperationDefinitionParameterList.Create;
  result := FPartList;
end;

Function TFhirOperationDefinitionParameter.GetHasPartList : boolean;
begin
  result := (FPartList <> nil) and (FPartList.count > 0);
end;

function TFhirOperationDefinitionParameter.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FUse.sizeInBytes);
  inc(result, FMin.sizeInBytes);
  inc(result, FMax.sizeInBytes);
  inc(result, FDocumentation.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FSearchType.sizeInBytes);
  inc(result, FProfile.sizeInBytes);
  inc(result, FBinding.sizeInBytes);
  inc(result, FpartList.sizeInBytes);
end;

{ TFhirOperationDefinitionParameterListEnumerator }

Constructor TFhirOperationDefinitionParameterListEnumerator.Create(list : TFhirOperationDefinitionParameterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirOperationDefinitionParameterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirOperationDefinitionParameterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirOperationDefinitionParameterListEnumerator.GetCurrent : TFhirOperationDefinitionParameter;
begin
  Result := FList[FIndex];
end;

function TFhirOperationDefinitionParameterListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirOperationDefinitionParameterList }
procedure TFhirOperationDefinitionParameterList.AddItem(value: TFhirOperationDefinitionParameter);
begin
  assert(value.ClassName = 'TFhirOperationDefinitionParameter', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOperationDefinitionParameter');
  add(value);
end;

function TFhirOperationDefinitionParameterList.Append: TFhirOperationDefinitionParameter;
begin
  result := TFhirOperationDefinitionParameter.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationDefinitionParameterList.ClearItems;
begin
  Clear;
end;

function TFhirOperationDefinitionParameterList.GetEnumerator : TFhirOperationDefinitionParameterListEnumerator;
begin
  result := TFhirOperationDefinitionParameterListEnumerator.Create(self.link);
end;

function TFhirOperationDefinitionParameterList.Clone: TFhirOperationDefinitionParameterList;
begin
  result := TFhirOperationDefinitionParameterList(inherited Clone);
end;

function TFhirOperationDefinitionParameterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOperationDefinitionParameterList.GetItemN(index: Integer): TFhirOperationDefinitionParameter;
begin
  result := TFhirOperationDefinitionParameter(ObjectByIndex[index]);
end;

function TFhirOperationDefinitionParameterList.ItemClass: TFslObjectClass;
begin
  result := TFhirOperationDefinitionParameter;
end;
function TFhirOperationDefinitionParameterList.IndexOf(value: TFhirOperationDefinitionParameter): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirOperationDefinitionParameterList.Insert(index: Integer): TFhirOperationDefinitionParameter;
begin
  result := TFhirOperationDefinitionParameter.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationDefinitionParameterList.InsertItem(index: Integer; value: TFhirOperationDefinitionParameter);
begin
  assert(value is TFhirOperationDefinitionParameter);
  Inherited Insert(index, value);
end;

function TFhirOperationDefinitionParameterList.Item(index: Integer): TFhirOperationDefinitionParameter;
begin
  result := TFhirOperationDefinitionParameter(ObjectByIndex[index]);
end;

function TFhirOperationDefinitionParameterList.Link: TFhirOperationDefinitionParameterList;
begin
  result := TFhirOperationDefinitionParameterList(inherited Link);
end;

procedure TFhirOperationDefinitionParameterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOperationDefinitionParameterList.SetItemByIndex(index: Integer; value: TFhirOperationDefinitionParameter);
begin
  assert(value is TFhirOperationDefinitionParameter);
  FhirOperationDefinitionParameters[index] := value;
end;

procedure TFhirOperationDefinitionParameterList.SetItemN(index: Integer; value: TFhirOperationDefinitionParameter);
begin
  assert(value is TFhirOperationDefinitionParameter);
  ObjectByIndex[index] := value;
end;

{ TFhirOperationDefinitionParameterBinding }

constructor TFhirOperationDefinitionParameterBinding.Create;
begin
  inherited;
end;

destructor TFhirOperationDefinitionParameterBinding.Destroy;
begin
  FStrength.free;
  FValueSet.free;
  inherited;
end;

procedure TFhirOperationDefinitionParameterBinding.Assign(oSource : TFslObject);
begin
  inherited;
  FStrength := TFhirOperationDefinitionParameterBinding(oSource).FStrength.Link;
  valueSet := TFhirOperationDefinitionParameterBinding(oSource).valueSet.Clone;
end;

procedure TFhirOperationDefinitionParameterBinding.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'strength') Then
     list.add(self.link, 'strength', FStrength.Link);
  if (child_name = 'valueSet[x]') or (child_name = 'valueSet') Then
     list.add(self.link, 'valueSet[x]', FValueSet.Link);
end;

procedure TFhirOperationDefinitionParameterBinding.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'strength', 'code', false, TFHIREnum, FStrength.Link));{1}
  oList.add(TFHIRProperty.create(self, 'valueSet[x]', 'uri|Reference(ValueSet)', false, TFhirType, FValueSet.Link));{2}
end;

function TFhirOperationDefinitionParameterBinding.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'strength') then
  begin
    StrengthElement := asEnum(SYSTEMS_TFhirBindingStrengthEnum, CODES_TFhirBindingStrengthEnum, propValue);
    result := propValue
  end
  else if (isMatchingName(propName, 'valueSet', ['Uri', 'Reference'])) then
  begin
    ValueSet := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirOperationDefinitionParameterBinding.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirOperationDefinitionParameterBinding.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'valueSet', ['Uri', 'Reference'])) then raise EFHIRException.create('Cannot make property ValueSet'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirOperationDefinitionParameterBinding.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'strength') then result := 'code'
  else if (propName = 'valueSet[x]') then result := 'uri|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirOperationDefinitionParameterBinding.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'strength') then StrengthElement := nil
  else if (isMatchingName(propName, 'valueSet', ['Uri', 'Reference'])) then ValueSetElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirOperationDefinitionParameterBinding.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'strength') then StrengthElement := asEnum(SYSTEMS_TFhirBindingStrengthEnum, CODES_TFhirBindingStrengthEnum, new){4}
  else if (isMatchingName(propName, 'valueSet', ['Uri', 'Reference'])) then ValueSetElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirOperationDefinitionParameterBinding.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirOperationDefinitionParameterBinding.fhirType : string;
begin
  result := 'binding';
end;

function TFhirOperationDefinitionParameterBinding.Link : TFhirOperationDefinitionParameterBinding;
begin
  result := TFhirOperationDefinitionParameterBinding(inherited Link);
end;

function TFhirOperationDefinitionParameterBinding.Clone : TFhirOperationDefinitionParameterBinding;
begin
  result := TFhirOperationDefinitionParameterBinding(inherited Clone);
end;

function TFhirOperationDefinitionParameterBinding.equals(other : TObject) : boolean;
var
  o : TFhirOperationDefinitionParameterBinding;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirOperationDefinitionParameterBinding)) then
    result := false
  else
  begin
    o := TFhirOperationDefinitionParameterBinding(other);
    result := compareDeep(strengthElement, o.strengthElement, true) and compareDeep(valueSetElement, o.valueSetElement, true);
  end;
end;

function TFhirOperationDefinitionParameterBinding.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStrength) and isEmptyProp(FValueSet);
end;

procedure TFhirOperationDefinitionParameterBinding.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('strength');
  fields.add('valueSet[x]');
end;

{ TFhirOperationDefinitionParameterBinding }

Procedure TFhirOperationDefinitionParameterBinding.SetStrength(value : TFhirEnum);
begin
  FStrength.free;
  FStrength := value;
end;

Function TFhirOperationDefinitionParameterBinding.GetStrengthST : TFhirBindingStrengthEnum;
begin
  if FStrength = nil then
    result := TFhirBindingStrengthEnum(0)
  else
    result := TFhirBindingStrengthEnum(StringArrayIndexOfSensitive(CODES_TFhirBindingStrengthEnum, FStrength.value));
end;

Procedure TFhirOperationDefinitionParameterBinding.SetStrengthST(value : TFhirBindingStrengthEnum);
begin
  if ord(value) = 0 then
    StrengthElement := nil
  else
    StrengthElement := TFhirEnum.create(SYSTEMS_TFhirBindingStrengthEnum[value], CODES_TFhirBindingStrengthEnum[value]);
end;

Procedure TFhirOperationDefinitionParameterBinding.SetValueSet(value : TFhirType);
begin
  FValueSet.free;
  FValueSet := value;
end;

function TFhirOperationDefinitionParameterBinding.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FStrength.sizeInBytes);
  inc(result, FValueSet.sizeInBytes);
end;

{ TFhirOperationDefinitionParameterBindingListEnumerator }

Constructor TFhirOperationDefinitionParameterBindingListEnumerator.Create(list : TFhirOperationDefinitionParameterBindingList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirOperationDefinitionParameterBindingListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirOperationDefinitionParameterBindingListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirOperationDefinitionParameterBindingListEnumerator.GetCurrent : TFhirOperationDefinitionParameterBinding;
begin
  Result := FList[FIndex];
end;

function TFhirOperationDefinitionParameterBindingListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirOperationDefinitionParameterBindingList }
procedure TFhirOperationDefinitionParameterBindingList.AddItem(value: TFhirOperationDefinitionParameterBinding);
begin
  assert(value.ClassName = 'TFhirOperationDefinitionParameterBinding', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOperationDefinitionParameterBinding');
  add(value);
end;

function TFhirOperationDefinitionParameterBindingList.Append: TFhirOperationDefinitionParameterBinding;
begin
  result := TFhirOperationDefinitionParameterBinding.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationDefinitionParameterBindingList.ClearItems;
begin
  Clear;
end;

function TFhirOperationDefinitionParameterBindingList.GetEnumerator : TFhirOperationDefinitionParameterBindingListEnumerator;
begin
  result := TFhirOperationDefinitionParameterBindingListEnumerator.Create(self.link);
end;

function TFhirOperationDefinitionParameterBindingList.Clone: TFhirOperationDefinitionParameterBindingList;
begin
  result := TFhirOperationDefinitionParameterBindingList(inherited Clone);
end;

function TFhirOperationDefinitionParameterBindingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOperationDefinitionParameterBindingList.GetItemN(index: Integer): TFhirOperationDefinitionParameterBinding;
begin
  result := TFhirOperationDefinitionParameterBinding(ObjectByIndex[index]);
end;

function TFhirOperationDefinitionParameterBindingList.ItemClass: TFslObjectClass;
begin
  result := TFhirOperationDefinitionParameterBinding;
end;
function TFhirOperationDefinitionParameterBindingList.IndexOf(value: TFhirOperationDefinitionParameterBinding): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirOperationDefinitionParameterBindingList.Insert(index: Integer): TFhirOperationDefinitionParameterBinding;
begin
  result := TFhirOperationDefinitionParameterBinding.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationDefinitionParameterBindingList.InsertItem(index: Integer; value: TFhirOperationDefinitionParameterBinding);
begin
  assert(value is TFhirOperationDefinitionParameterBinding);
  Inherited Insert(index, value);
end;

function TFhirOperationDefinitionParameterBindingList.Item(index: Integer): TFhirOperationDefinitionParameterBinding;
begin
  result := TFhirOperationDefinitionParameterBinding(ObjectByIndex[index]);
end;

function TFhirOperationDefinitionParameterBindingList.Link: TFhirOperationDefinitionParameterBindingList;
begin
  result := TFhirOperationDefinitionParameterBindingList(inherited Link);
end;

procedure TFhirOperationDefinitionParameterBindingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOperationDefinitionParameterBindingList.SetItemByIndex(index: Integer; value: TFhirOperationDefinitionParameterBinding);
begin
  assert(value is TFhirOperationDefinitionParameterBinding);
  FhirOperationDefinitionParameterBindings[index] := value;
end;

procedure TFhirOperationDefinitionParameterBindingList.SetItemN(index: Integer; value: TFhirOperationDefinitionParameterBinding);
begin
  assert(value is TFhirOperationDefinitionParameterBinding);
  ObjectByIndex[index] := value;
end;

{ TFhirOperationDefinitionOverload }

constructor TFhirOperationDefinitionOverload.Create;
begin
  inherited;
end;

destructor TFhirOperationDefinitionOverload.Destroy;
begin
  FParameterNameList.Free;
  FComment.free;
  inherited;
end;

procedure TFhirOperationDefinitionOverload.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirOperationDefinitionOverload(oSource).FParameterNameList = nil) then
  begin
    FParameterNameList.free;
    FParameterNameList := nil;
  end
  else
  begin
    if FParameterNameList = nil then
      FParameterNameList := TFhirStringList.Create;
    FParameterNameList.Assign(TFhirOperationDefinitionOverload(oSource).FParameterNameList);
  end;
  commentElement := TFhirOperationDefinitionOverload(oSource).commentElement.Clone;
end;

procedure TFhirOperationDefinitionOverload.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'parameterName') Then
    list.addAll(self, 'parameterName', FParameterNameList);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
end;

procedure TFhirOperationDefinitionOverload.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'parameterName', 'string', true, TFhirString, FParameterNameList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'comment', 'string', false, TFhirString, FComment.Link));{2}
end;

function TFhirOperationDefinitionOverload.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'parameterName') then
  begin
    ParameterNameList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'comment') then
  begin
    CommentElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirOperationDefinitionOverload.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'parameterName') then ParameterNameList.insertItem(index, asString(propValue)){2}
  else inherited;
end;

function TFhirOperationDefinitionOverload.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'parameterName') then result := ParameterNameList.new(){2}
  else if (propName = 'comment') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirOperationDefinitionOverload.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'parameterName') then result := 'string'
  else if (propName = 'comment') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirOperationDefinitionOverload.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'parameterName') then deletePropertyValue('parameterName', ParameterNameList, value) {2}
  else if (propName = 'comment') then CommentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirOperationDefinitionOverload.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'parameterName') then replacePropertyValue('parameterName', ParameterNameList, existing, new) {2}
  else if (propName = 'comment') then CommentElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirOperationDefinitionOverload.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'parameterName') then ParameterNameList.move(source, destination){2}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirOperationDefinitionOverload.fhirType : string;
begin
  result := 'overload';
end;

function TFhirOperationDefinitionOverload.Link : TFhirOperationDefinitionOverload;
begin
  result := TFhirOperationDefinitionOverload(inherited Link);
end;

function TFhirOperationDefinitionOverload.Clone : TFhirOperationDefinitionOverload;
begin
  result := TFhirOperationDefinitionOverload(inherited Clone);
end;

function TFhirOperationDefinitionOverload.equals(other : TObject) : boolean;
var
  o : TFhirOperationDefinitionOverload;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirOperationDefinitionOverload)) then
    result := false
  else
  begin
    o := TFhirOperationDefinitionOverload(other);
    result := compareDeep(parameterNameList, o.parameterNameList, true) and compareDeep(commentElement, o.commentElement, true);
  end;
end;

function TFhirOperationDefinitionOverload.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FparameterNameList) and isEmptyProp(FComment);
end;

procedure TFhirOperationDefinitionOverload.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('parameterName');
  fields.add('comment');
end;

{ TFhirOperationDefinitionOverload }

Function TFhirOperationDefinitionOverload.GetParameterNameList : TFhirStringList;
begin
  if FParameterNameList = nil then
    FParameterNameList := TFhirStringList.Create;
  result := FParameterNameList;
end;

Function TFhirOperationDefinitionOverload.GetHasParameterNameList : boolean;
begin
  result := (FParameterNameList <> nil) and (FParameterNameList.count > 0);
end;

Procedure TFhirOperationDefinitionOverload.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value;
end;

Function TFhirOperationDefinitionOverload.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

Procedure TFhirOperationDefinitionOverload.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

function TFhirOperationDefinitionOverload.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FparameterNameList.sizeInBytes);
  inc(result, FComment.sizeInBytes);
end;

{ TFhirOperationDefinitionOverloadListEnumerator }

Constructor TFhirOperationDefinitionOverloadListEnumerator.Create(list : TFhirOperationDefinitionOverloadList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirOperationDefinitionOverloadListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirOperationDefinitionOverloadListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirOperationDefinitionOverloadListEnumerator.GetCurrent : TFhirOperationDefinitionOverload;
begin
  Result := FList[FIndex];
end;

function TFhirOperationDefinitionOverloadListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirOperationDefinitionOverloadList }
procedure TFhirOperationDefinitionOverloadList.AddItem(value: TFhirOperationDefinitionOverload);
begin
  assert(value.ClassName = 'TFhirOperationDefinitionOverload', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOperationDefinitionOverload');
  add(value);
end;

function TFhirOperationDefinitionOverloadList.Append: TFhirOperationDefinitionOverload;
begin
  result := TFhirOperationDefinitionOverload.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationDefinitionOverloadList.ClearItems;
begin
  Clear;
end;

function TFhirOperationDefinitionOverloadList.GetEnumerator : TFhirOperationDefinitionOverloadListEnumerator;
begin
  result := TFhirOperationDefinitionOverloadListEnumerator.Create(self.link);
end;

function TFhirOperationDefinitionOverloadList.Clone: TFhirOperationDefinitionOverloadList;
begin
  result := TFhirOperationDefinitionOverloadList(inherited Clone);
end;

function TFhirOperationDefinitionOverloadList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOperationDefinitionOverloadList.GetItemN(index: Integer): TFhirOperationDefinitionOverload;
begin
  result := TFhirOperationDefinitionOverload(ObjectByIndex[index]);
end;

function TFhirOperationDefinitionOverloadList.ItemClass: TFslObjectClass;
begin
  result := TFhirOperationDefinitionOverload;
end;
function TFhirOperationDefinitionOverloadList.IndexOf(value: TFhirOperationDefinitionOverload): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirOperationDefinitionOverloadList.Insert(index: Integer): TFhirOperationDefinitionOverload;
begin
  result := TFhirOperationDefinitionOverload.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationDefinitionOverloadList.InsertItem(index: Integer; value: TFhirOperationDefinitionOverload);
begin
  assert(value is TFhirOperationDefinitionOverload);
  Inherited Insert(index, value);
end;

function TFhirOperationDefinitionOverloadList.Item(index: Integer): TFhirOperationDefinitionOverload;
begin
  result := TFhirOperationDefinitionOverload(ObjectByIndex[index]);
end;

function TFhirOperationDefinitionOverloadList.Link: TFhirOperationDefinitionOverloadList;
begin
  result := TFhirOperationDefinitionOverloadList(inherited Link);
end;

procedure TFhirOperationDefinitionOverloadList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOperationDefinitionOverloadList.SetItemByIndex(index: Integer; value: TFhirOperationDefinitionOverload);
begin
  assert(value is TFhirOperationDefinitionOverload);
  FhirOperationDefinitionOverloads[index] := value;
end;

procedure TFhirOperationDefinitionOverloadList.SetItemN(index: Integer; value: TFhirOperationDefinitionOverload);
begin
  assert(value is TFhirOperationDefinitionOverload);
  ObjectByIndex[index] := value;
end;

{ TFhirOperationDefinition }

constructor TFhirOperationDefinition.Create;
begin
  inherited;
end;

destructor TFhirOperationDefinition.Destroy;
begin
  FKind.free;
  FPurpose.free;
  FIdempotent.free;
  FCode.free;
  FComment.free;
  FBase.free;
  FResource.Free;
  FSystem.free;
  FType_.free;
  FInstance.free;
  FParameterList.Free;
  FOverloadList.Free;
  inherited;
end;

function TFhirOperationDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtOperationDefinition;
end;

procedure TFhirOperationDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  FKind := TFhirOperationDefinition(oSource).FKind.Link;
  purposeElement := TFhirOperationDefinition(oSource).purposeElement.Clone;
  idempotentElement := TFhirOperationDefinition(oSource).idempotentElement.Clone;
  codeElement := TFhirOperationDefinition(oSource).codeElement.Clone;
  commentElement := TFhirOperationDefinition(oSource).commentElement.Clone;
  base := TFhirOperationDefinition(oSource).base.Clone;
  if (TFhirOperationDefinition(oSource).FResource = nil) then
  begin
    FResource.free;
    FResource := nil;
  end
  else
  begin
    FResource := TFHIREnumList.Create(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum);
    FResource.Assign(TFhirOperationDefinition(oSource).FResource);
  end;
  systemElement := TFhirOperationDefinition(oSource).systemElement.Clone;
  type_Element := TFhirOperationDefinition(oSource).type_Element.Clone;
  instanceElement := TFhirOperationDefinition(oSource).instanceElement.Clone;
  if (TFhirOperationDefinition(oSource).FParameterList = nil) then
  begin
    FParameterList.free;
    FParameterList := nil;
  end
  else
  begin
    if FParameterList = nil then
      FParameterList := TFhirOperationDefinitionParameterList.Create;
    FParameterList.Assign(TFhirOperationDefinition(oSource).FParameterList);
  end;
  if (TFhirOperationDefinition(oSource).FOverloadList = nil) then
  begin
    FOverloadList.free;
    FOverloadList := nil;
  end
  else
  begin
    if FOverloadList = nil then
      FOverloadList := TFhirOperationDefinitionOverloadList.Create;
    FOverloadList.Assign(TFhirOperationDefinition(oSource).FOverloadList);
  end;
end;

procedure TFhirOperationDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'kind') Then
     list.add(self.link, 'kind', FKind.Link);
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'idempotent') Then
     list.add(self.link, 'idempotent', FIdempotent.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
  if (child_name = 'base') Then
     list.add(self.link, 'base', FBase.Link);
  if (child_name = 'resource') Then
     list.addAll(self, 'resource', FResource);
  if (child_name = 'system') Then
     list.add(self.link, 'system', FSystem.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'instance') Then
     list.add(self.link, 'instance', FInstance.Link);
  if (child_name = 'parameter') Then
    list.addAll(self, 'parameter', FParameterList);
  if (child_name = 'overload') Then
    list.addAll(self, 'overload', FOverloadList);
end;

procedure TFhirOperationDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'kind', 'code', false, TFHIREnum, FKind.Link));{1}
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));{2}
  oList.add(TFHIRProperty.create(self, 'idempotent', 'boolean', false, TFhirBoolean, FIdempotent.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirCode, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'comment', 'string', false, TFhirString, FComment.Link));{2}
  oList.add(TFHIRProperty.create(self, 'base', 'Reference(OperationDefinition)', false, TFhirReference{TFhirOperationDefinition}, FBase.Link));{2}
  oList.add(TFHIRProperty.create(self, 'resource', 'code', true, TFHIREnum, FResource.Link)){3};
  oList.add(TFHIRProperty.create(self, 'system', 'boolean', false, TFhirBoolean, FSystem.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'boolean', false, TFhirBoolean, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'instance', 'boolean', false, TFhirBoolean, FInstance.Link));{2}
  oList.add(TFHIRProperty.create(self, 'parameter', '', true, TFhirOperationDefinitionParameter, FParameterList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'overload', '', true, TFhirOperationDefinitionOverload, FOverloadList.Link)){3};
end;

function TFhirOperationDefinition.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'kind') then
  begin
    KindElement := asEnum(SYSTEMS_TFhirOperationKindEnum, CODES_TFhirOperationKindEnum, propValue);
    result := propValue
  end
  else if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'idempotent') then
  begin
    IdempotentElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'base') then
  begin
    Base := propValue as TFhirReference{TFhirOperationDefinition}{4b};
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    ResourceList.add(asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue)); {1}
    result := propValue;
  end
  else if (propName = 'system') then
  begin
    SystemElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'instance') then
  begin
    InstanceElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'parameter') then
  begin
    ParameterList.add(propValue as TFhirOperationDefinitionParameter){2a};
    result := propValue;
  end
  else if (propName = 'overload') then
  begin
    OverloadList.add(propValue as TFhirOperationDefinitionOverload){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirOperationDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'resource') then FResource.insertItem(index, asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue)) {1}
  else if (propName = 'parameter') then ParameterList.insertItem(index, propValue as TFhirOperationDefinitionParameter){2a}
  else if (propName = 'overload') then OverloadList.insertItem(index, propValue as TFhirOperationDefinitionOverload){2a}
  else inherited;
end;

function TFhirOperationDefinition.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'purpose') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'idempotent') then result := TFhirBoolean.create() {5b}
  else if (propName = 'code') then result := TFhirCode.create() {5b}
  else if (propName = 'comment') then result := TFhirString.create() {5b}
  else if (propName = 'base') then result := TFhirReference{TFhirOperationDefinition}.create(){4b}
  else if (propName = 'system') then result := TFhirBoolean.create() {5b}
  else if (propName = 'type') then result := TFhirBoolean.create() {5b}
  else if (propName = 'instance') then result := TFhirBoolean.create() {5b}
  else if (propName = 'parameter') then result := ParameterList.new(){2}
  else if (propName = 'overload') then result := OverloadList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirOperationDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'kind') then result := 'code'
  else if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'idempotent') then result := 'boolean'
  else if (propName = 'code') then result := 'code'
  else if (propName = 'comment') then result := 'string'
  else if (propName = 'base') then result := 'Reference'
  else if (propName = 'resource') then result := 'code'
  else if (propName = 'system') then result := 'boolean'
  else if (propName = 'type') then result := 'boolean'
  else if (propName = 'instance') then result := 'boolean'
  else if (propName = 'parameter') then result := ''
  else if (propName = 'overload') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirOperationDefinition.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'kind') then KindElement := nil
  else if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'idempotent') then IdempotentElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'comment') then CommentElement := nil
  else if (propName = 'base') then BaseElement := nil
  else if (propName = 'system') then SystemElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'instance') then InstanceElement := nil
  else if (propName = 'parameter') then deletePropertyValue('parameter', ParameterList, value) {2}
  else if (propName = 'overload') then deletePropertyValue('overload', OverloadList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirOperationDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'kind') then KindElement := asEnum(SYSTEMS_TFhirOperationKindEnum, CODES_TFhirOperationKindEnum, new){4}
  else if (propName = 'purpose') then PurposeElement := asMarkdown(new){5b}
  else if (propName = 'idempotent') then IdempotentElement := asBoolean(new){5b}
  else if (propName = 'code') then CodeElement := asCode(new){5b}
  else if (propName = 'comment') then CommentElement := asString(new){5b}
  else if (propName = 'base') then BaseElement := new as TFhirReference{TFhirOperationDefinition}{4}
  else if (propName = 'system') then SystemElement := asBoolean(new){5b}
  else if (propName = 'type') then Type_Element := asBoolean(new){5b}
  else if (propName = 'instance') then InstanceElement := asBoolean(new){5b}
  else if (propName = 'parameter') then replacePropertyValue('parameter', ParameterList, existing, new) {2}
  else if (propName = 'overload') then replacePropertyValue('overload', OverloadList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirOperationDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'resource') then FResource.move(source, destination) {1}
  else if (propName = 'parameter') then ParameterList.move(source, destination){2a}
  else if (propName = 'overload') then OverloadList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirOperationDefinition.fhirType : string;
begin
  result := 'OperationDefinition';
end;

function TFhirOperationDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FKind) and isEmptyProp(FPurpose) and isEmptyProp(FIdempotent) and isEmptyProp(FCode) and isEmptyProp(FComment) and isEmptyProp(FBase) and isEmptyProp(FResource) and isEmptyProp(FSystem) and isEmptyProp(FType_) and isEmptyProp(FInstance) and isEmptyProp(FparameterList) and isEmptyProp(FoverloadList);
end;

function TFhirOperationDefinition.equals(other : TObject) : boolean;
var
  o : TFhirOperationDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirOperationDefinition)) then
    result := false
  else
  begin
    o := TFhirOperationDefinition(other);
    result := compareDeep(kindElement, o.kindElement, true) and compareDeep(purposeElement, o.purposeElement, true) and
      compareDeep(idempotentElement, o.idempotentElement, true) and compareDeep(codeElement, o.codeElement, true) and
      compareDeep(commentElement, o.commentElement, true) and compareDeep(baseElement, o.baseElement, true) and
      compareDeep(resourceList, o.resourceList, true) and compareDeep(systemElement, o.systemElement, true) and
      compareDeep(type_Element, o.type_Element, true) and compareDeep(instanceElement, o.instanceElement, true) and
      compareDeep(parameterList, o.parameterList, true) and compareDeep(overloadList, o.overloadList, true);
  end;
end;

function TFhirOperationDefinition.Link : TFhirOperationDefinition;
begin
  result := TFhirOperationDefinition(inherited Link);
end;

function TFhirOperationDefinition.Clone : TFhirOperationDefinition;
begin
  result := TFhirOperationDefinition(inherited Clone);
end;

procedure TFhirOperationDefinition.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('url');
  fields.add('version');
  fields.add('name');
  fields.add('status');
  fields.add('kind');
  fields.add('experimental');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('purpose');
  fields.add('idempotent');
  fields.add('code');
  fields.add('comment');
  fields.add('base');
  fields.add('resource');
  fields.add('system');
  fields.add('type');
  fields.add('instance');
  fields.add('parameter');
  fields.add('overload');
end;

{ TFhirOperationDefinition }

Procedure TFhirOperationDefinition.SetKind(value : TFhirEnum);
begin
  FKind.free;
  FKind := value;
end;

Function TFhirOperationDefinition.GetKindST : TFhirOperationKindEnum;
begin
  if FKind = nil then
    result := TFhirOperationKindEnum(0)
  else
    result := TFhirOperationKindEnum(StringArrayIndexOfSensitive(CODES_TFhirOperationKindEnum, FKind.value));
end;

Procedure TFhirOperationDefinition.SetKindST(value : TFhirOperationKindEnum);
begin
  if ord(value) = 0 then
    KindElement := nil
  else
    KindElement := TFhirEnum.create(SYSTEMS_TFhirOperationKindEnum[value], CODES_TFhirOperationKindEnum[value]);
end;

Procedure TFhirOperationDefinition.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

Function TFhirOperationDefinition.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

Procedure TFhirOperationDefinition.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

Procedure TFhirOperationDefinition.SetIdempotent(value : TFhirBoolean);
begin
  FIdempotent.free;
  FIdempotent := value;
end;

Function TFhirOperationDefinition.GetIdempotentST : Boolean;
begin
  if FIdempotent = nil then
    result := false
  else
    result := FIdempotent.value;
end;

Procedure TFhirOperationDefinition.SetIdempotentST(value : Boolean);
begin
  if FIdempotent = nil then
    FIdempotent := TFhirBoolean.create;
  FIdempotent.value := value
end;

Procedure TFhirOperationDefinition.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirOperationDefinition.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

Procedure TFhirOperationDefinition.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

Procedure TFhirOperationDefinition.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value;
end;

Function TFhirOperationDefinition.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

Procedure TFhirOperationDefinition.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

Procedure TFhirOperationDefinition.SetBase(value : TFhirReference{TFhirOperationDefinition});
begin
  FBase.free;
  FBase := value;
end;

Function TFhirOperationDefinition.GetResource : TFhirEnumList;
begin
  if FResource = nil then
    FResource := TFHIREnumList.Create(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum);
  result := FResource;
end;

Function TFhirOperationDefinition.GetHasResource : boolean;
begin
  result := (FResource <> nil) and (FResource.count > 0);
end;

Procedure TFhirOperationDefinition.SetSystem(value : TFhirBoolean);
begin
  FSystem.free;
  FSystem := value;
end;

Function TFhirOperationDefinition.GetSystemST : Boolean;
begin
  if FSystem = nil then
    result := false
  else
    result := FSystem.value;
end;

Procedure TFhirOperationDefinition.SetSystemST(value : Boolean);
begin
  if FSystem = nil then
    FSystem := TFhirBoolean.create;
  FSystem.value := value
end;

Procedure TFhirOperationDefinition.SetType_(value : TFhirBoolean);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirOperationDefinition.GetType_ST : Boolean;
begin
  if FType_ = nil then
    result := false
  else
    result := FType_.value;
end;

Procedure TFhirOperationDefinition.SetType_ST(value : Boolean);
begin
  if FType_ = nil then
    FType_ := TFhirBoolean.create;
  FType_.value := value
end;

Procedure TFhirOperationDefinition.SetInstance(value : TFhirBoolean);
begin
  FInstance.free;
  FInstance := value;
end;

Function TFhirOperationDefinition.GetInstanceST : Boolean;
begin
  if FInstance = nil then
    result := false
  else
    result := FInstance.value;
end;

Procedure TFhirOperationDefinition.SetInstanceST(value : Boolean);
begin
  if FInstance = nil then
    FInstance := TFhirBoolean.create;
  FInstance.value := value
end;

Function TFhirOperationDefinition.GetParameterList : TFhirOperationDefinitionParameterList;
begin
  if FParameterList = nil then
    FParameterList := TFhirOperationDefinitionParameterList.Create;
  result := FParameterList;
end;

Function TFhirOperationDefinition.GetHasParameterList : boolean;
begin
  result := (FParameterList <> nil) and (FParameterList.count > 0);
end;

Function TFhirOperationDefinition.GetOverloadList : TFhirOperationDefinitionOverloadList;
begin
  if FOverloadList = nil then
    FOverloadList := TFhirOperationDefinitionOverloadList.Create;
  result := FOverloadList;
end;

Function TFhirOperationDefinition.GetHasOverloadList : boolean;
begin
  result := (FOverloadList <> nil) and (FOverloadList.count > 0);
end;

function TFhirOperationDefinition.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FKind.sizeInBytes);
  inc(result, FPurpose.sizeInBytes);
  inc(result, FIdempotent.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FComment.sizeInBytes);
  inc(result, FBase.sizeInBytes);
  inc(result, FResource.sizeInBytes);
  inc(result, FSystem.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FInstance.sizeInBytes);
  inc(result, FparameterList.sizeInBytes);
  inc(result, FoverloadList.sizeInBytes);
end;

{ TFhirOperationDefinitionListEnumerator }

Constructor TFhirOperationDefinitionListEnumerator.Create(list : TFhirOperationDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirOperationDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirOperationDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirOperationDefinitionListEnumerator.GetCurrent : TFhirOperationDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirOperationDefinitionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirOperationDefinitionList }
procedure TFhirOperationDefinitionList.AddItem(value: TFhirOperationDefinition);
begin
  assert(value.ClassName = 'TFhirOperationDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOperationDefinition');
  add(value);
end;

function TFhirOperationDefinitionList.Append: TFhirOperationDefinition;
begin
  result := TFhirOperationDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirOperationDefinitionList.GetEnumerator : TFhirOperationDefinitionListEnumerator;
begin
  result := TFhirOperationDefinitionListEnumerator.Create(self.link);
end;

function TFhirOperationDefinitionList.Clone: TFhirOperationDefinitionList;
begin
  result := TFhirOperationDefinitionList(inherited Clone);
end;

function TFhirOperationDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOperationDefinitionList.GetItemN(index: Integer): TFhirOperationDefinition;
begin
  result := TFhirOperationDefinition(ObjectByIndex[index]);
end;

function TFhirOperationDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirOperationDefinition;
end;
function TFhirOperationDefinitionList.IndexOf(value: TFhirOperationDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirOperationDefinitionList.Insert(index: Integer): TFhirOperationDefinition;
begin
  result := TFhirOperationDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationDefinitionList.InsertItem(index: Integer; value: TFhirOperationDefinition);
begin
  assert(value is TFhirOperationDefinition);
  Inherited Insert(index, value);
end;

function TFhirOperationDefinitionList.Item(index: Integer): TFhirOperationDefinition;
begin
  result := TFhirOperationDefinition(ObjectByIndex[index]);
end;

function TFhirOperationDefinitionList.Link: TFhirOperationDefinitionList;
begin
  result := TFhirOperationDefinitionList(inherited Link);
end;

procedure TFhirOperationDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOperationDefinitionList.SetItemByIndex(index: Integer; value: TFhirOperationDefinition);
begin
  assert(value is TFhirOperationDefinition);
  FhirOperationDefinitions[index] := value;
end;

procedure TFhirOperationDefinitionList.SetItemN(index: Integer; value: TFhirOperationDefinition);
begin
  assert(value is TFhirOperationDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_OPERATIONDEFINITION}

{$IFDEF FHIR_PLANDEFINITION}

{ TFhirPlanDefinitionGoal }

constructor TFhirPlanDefinitionGoal.Create;
begin
  inherited;
end;

destructor TFhirPlanDefinitionGoal.Destroy;
begin
  FCategory.free;
  FDescription.free;
  FPriority.free;
  FStart.free;
  FAddressesList.Free;
  FDocumentationList.Free;
  FTargetList.Free;
  inherited;
end;

procedure TFhirPlanDefinitionGoal.Assign(oSource : TFslObject);
begin
  inherited;
  category := TFhirPlanDefinitionGoal(oSource).category.Clone;
  description := TFhirPlanDefinitionGoal(oSource).description.Clone;
  priority := TFhirPlanDefinitionGoal(oSource).priority.Clone;
  start := TFhirPlanDefinitionGoal(oSource).start.Clone;
  if (TFhirPlanDefinitionGoal(oSource).FAddressesList = nil) then
  begin
    FAddressesList.free;
    FAddressesList := nil;
  end
  else
  begin
    if FAddressesList = nil then
      FAddressesList := TFhirCodeableConceptList.Create;
    FAddressesList.Assign(TFhirPlanDefinitionGoal(oSource).FAddressesList);
  end;
  if (TFhirPlanDefinitionGoal(oSource).FDocumentationList = nil) then
  begin
    FDocumentationList.free;
    FDocumentationList := nil;
  end
  else
  begin
    if FDocumentationList = nil then
      FDocumentationList := TFhirRelatedArtifactList.Create;
    FDocumentationList.Assign(TFhirPlanDefinitionGoal(oSource).FDocumentationList);
  end;
  if (TFhirPlanDefinitionGoal(oSource).FTargetList = nil) then
  begin
    FTargetList.free;
    FTargetList := nil;
  end
  else
  begin
    if FTargetList = nil then
      FTargetList := TFhirPlanDefinitionGoalTargetList.Create;
    FTargetList.Assign(TFhirPlanDefinitionGoal(oSource).FTargetList);
  end;
end;

procedure TFhirPlanDefinitionGoal.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'start') Then
     list.add(self.link, 'start', FStart.Link);
  if (child_name = 'addresses') Then
    list.addAll(self, 'addresses', FAddressesList);
  if (child_name = 'documentation') Then
    list.addAll(self, 'documentation', FDocumentationList);
  if (child_name = 'target') Then
    list.addAll(self, 'target', FTargetList);
end;

procedure TFhirPlanDefinitionGoal.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'CodeableConcept', false, TFhirCodeableConcept, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'priority', 'CodeableConcept', false, TFhirCodeableConcept, FPriority.Link));{2}
  oList.add(TFHIRProperty.create(self, 'start', 'CodeableConcept', false, TFhirCodeableConcept, FStart.Link));{2}
  oList.add(TFHIRProperty.create(self, 'addresses', 'CodeableConcept', true, TFhirCodeableConcept, FAddressesList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'documentation', 'RelatedArtifact', true, TFhirRelatedArtifact, FDocumentationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'target', '', true, TFhirPlanDefinitionGoalTarget, FTargetList.Link)){3};
end;

function TFhirPlanDefinitionGoal.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    Description := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    Priority := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'start') then
  begin
    Start := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'addresses') then
  begin
    AddressesList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'documentation') then
  begin
    DocumentationList.add(propValue as TFhirRelatedArtifact){2a};
    result := propValue;
  end
  else if (propName = 'target') then
  begin
    TargetList.add(propValue as TFhirPlanDefinitionGoalTarget){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPlanDefinitionGoal.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'addresses') then AddressesList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'documentation') then DocumentationList.insertItem(index, propValue as TFhirRelatedArtifact){2a}
  else if (propName = 'target') then TargetList.insertItem(index, propValue as TFhirPlanDefinitionGoalTarget){2a}
  else inherited;
end;

function TFhirPlanDefinitionGoal.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'category') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'description') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'priority') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'start') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'addresses') then result := AddressesList.new(){2}
  else if (propName = 'documentation') then result := DocumentationList.new(){2}
  else if (propName = 'target') then result := TargetList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPlanDefinitionGoal.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'CodeableConcept'
  else if (propName = 'priority') then result := 'CodeableConcept'
  else if (propName = 'start') then result := 'CodeableConcept'
  else if (propName = 'addresses') then result := 'CodeableConcept'
  else if (propName = 'documentation') then result := 'RelatedArtifact'
  else if (propName = 'target') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPlanDefinitionGoal.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'start') then StartElement := nil
  else if (propName = 'addresses') then deletePropertyValue('addresses', AddressesList, value) {2}
  else if (propName = 'documentation') then deletePropertyValue('documentation', DocumentationList, value) {2}
  else if (propName = 'target') then deletePropertyValue('target', TargetList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPlanDefinitionGoal.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept{4}
  else if (propName = 'description') then DescriptionElement := new as TFhirCodeableConcept{4}
  else if (propName = 'priority') then PriorityElement := new as TFhirCodeableConcept{4}
  else if (propName = 'start') then StartElement := new as TFhirCodeableConcept{4}
  else if (propName = 'addresses') then replacePropertyValue('addresses', AddressesList, existing, new) {2}
  else if (propName = 'documentation') then replacePropertyValue('documentation', DocumentationList, existing, new) {2}
  else if (propName = 'target') then replacePropertyValue('target', TargetList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPlanDefinitionGoal.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'addresses') then AddressesList.move(source, destination){2a}
  else if (propName = 'documentation') then DocumentationList.move(source, destination){2a}
  else if (propName = 'target') then TargetList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPlanDefinitionGoal.fhirType : string;
begin
  result := 'goal';
end;

function TFhirPlanDefinitionGoal.Link : TFhirPlanDefinitionGoal;
begin
  result := TFhirPlanDefinitionGoal(inherited Link);
end;

function TFhirPlanDefinitionGoal.Clone : TFhirPlanDefinitionGoal;
begin
  result := TFhirPlanDefinitionGoal(inherited Clone);
end;

function TFhirPlanDefinitionGoal.equals(other : TObject) : boolean;
var
  o : TFhirPlanDefinitionGoal;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPlanDefinitionGoal)) then
    result := false
  else
  begin
    o := TFhirPlanDefinitionGoal(other);
    result := compareDeep(categoryElement, o.categoryElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and
      compareDeep(priorityElement, o.priorityElement, true) and compareDeep(startElement, o.startElement, true) and
      compareDeep(addressesList, o.addressesList, true) and compareDeep(documentationList, o.documentationList, true) and
      compareDeep(targetList, o.targetList, true);
  end;
end;

function TFhirPlanDefinitionGoal.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCategory) and isEmptyProp(FDescription) and isEmptyProp(FPriority) and isEmptyProp(FStart) and isEmptyProp(FaddressesList) and isEmptyProp(FdocumentationList) and isEmptyProp(FtargetList);
end;

procedure TFhirPlanDefinitionGoal.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('category');
  fields.add('description');
  fields.add('priority');
  fields.add('start');
  fields.add('addresses');
  fields.add('documentation');
  fields.add('target');
end;

{ TFhirPlanDefinitionGoal }

Procedure TFhirPlanDefinitionGoal.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

Procedure TFhirPlanDefinitionGoal.SetDescription(value : TFhirCodeableConcept);
begin
  FDescription.free;
  FDescription := value;
end;

Procedure TFhirPlanDefinitionGoal.SetPriority(value : TFhirCodeableConcept);
begin
  FPriority.free;
  FPriority := value;
end;

Procedure TFhirPlanDefinitionGoal.SetStart(value : TFhirCodeableConcept);
begin
  FStart.free;
  FStart := value;
end;

Function TFhirPlanDefinitionGoal.GetAddressesList : TFhirCodeableConceptList;
begin
  if FAddressesList = nil then
    FAddressesList := TFhirCodeableConceptList.Create;
  result := FAddressesList;
end;

Function TFhirPlanDefinitionGoal.GetHasAddressesList : boolean;
begin
  result := (FAddressesList <> nil) and (FAddressesList.count > 0);
end;

Function TFhirPlanDefinitionGoal.GetDocumentationList : TFhirRelatedArtifactList;
begin
  if FDocumentationList = nil then
    FDocumentationList := TFhirRelatedArtifactList.Create;
  result := FDocumentationList;
end;

Function TFhirPlanDefinitionGoal.GetHasDocumentationList : boolean;
begin
  result := (FDocumentationList <> nil) and (FDocumentationList.count > 0);
end;

Function TFhirPlanDefinitionGoal.GetTargetList : TFhirPlanDefinitionGoalTargetList;
begin
  if FTargetList = nil then
    FTargetList := TFhirPlanDefinitionGoalTargetList.Create;
  result := FTargetList;
end;

Function TFhirPlanDefinitionGoal.GetHasTargetList : boolean;
begin
  result := (FTargetList <> nil) and (FTargetList.count > 0);
end;

function TFhirPlanDefinitionGoal.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCategory.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FPriority.sizeInBytes);
  inc(result, FStart.sizeInBytes);
  inc(result, FaddressesList.sizeInBytes);
  inc(result, FdocumentationList.sizeInBytes);
  inc(result, FtargetList.sizeInBytes);
end;

{ TFhirPlanDefinitionGoalListEnumerator }

Constructor TFhirPlanDefinitionGoalListEnumerator.Create(list : TFhirPlanDefinitionGoalList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPlanDefinitionGoalListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPlanDefinitionGoalListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPlanDefinitionGoalListEnumerator.GetCurrent : TFhirPlanDefinitionGoal;
begin
  Result := FList[FIndex];
end;

function TFhirPlanDefinitionGoalListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPlanDefinitionGoalList }
procedure TFhirPlanDefinitionGoalList.AddItem(value: TFhirPlanDefinitionGoal);
begin
  assert(value.ClassName = 'TFhirPlanDefinitionGoal', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPlanDefinitionGoal');
  add(value);
end;

function TFhirPlanDefinitionGoalList.Append: TFhirPlanDefinitionGoal;
begin
  result := TFhirPlanDefinitionGoal.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionGoalList.ClearItems;
begin
  Clear;
end;

function TFhirPlanDefinitionGoalList.GetEnumerator : TFhirPlanDefinitionGoalListEnumerator;
begin
  result := TFhirPlanDefinitionGoalListEnumerator.Create(self.link);
end;

function TFhirPlanDefinitionGoalList.Clone: TFhirPlanDefinitionGoalList;
begin
  result := TFhirPlanDefinitionGoalList(inherited Clone);
end;

function TFhirPlanDefinitionGoalList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPlanDefinitionGoalList.GetItemN(index: Integer): TFhirPlanDefinitionGoal;
begin
  result := TFhirPlanDefinitionGoal(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionGoalList.ItemClass: TFslObjectClass;
begin
  result := TFhirPlanDefinitionGoal;
end;
function TFhirPlanDefinitionGoalList.IndexOf(value: TFhirPlanDefinitionGoal): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPlanDefinitionGoalList.Insert(index: Integer): TFhirPlanDefinitionGoal;
begin
  result := TFhirPlanDefinitionGoal.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionGoalList.InsertItem(index: Integer; value: TFhirPlanDefinitionGoal);
begin
  assert(value is TFhirPlanDefinitionGoal);
  Inherited Insert(index, value);
end;

function TFhirPlanDefinitionGoalList.Item(index: Integer): TFhirPlanDefinitionGoal;
begin
  result := TFhirPlanDefinitionGoal(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionGoalList.Link: TFhirPlanDefinitionGoalList;
begin
  result := TFhirPlanDefinitionGoalList(inherited Link);
end;

procedure TFhirPlanDefinitionGoalList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPlanDefinitionGoalList.SetItemByIndex(index: Integer; value: TFhirPlanDefinitionGoal);
begin
  assert(value is TFhirPlanDefinitionGoal);
  FhirPlanDefinitionGoals[index] := value;
end;

procedure TFhirPlanDefinitionGoalList.SetItemN(index: Integer; value: TFhirPlanDefinitionGoal);
begin
  assert(value is TFhirPlanDefinitionGoal);
  ObjectByIndex[index] := value;
end;

{ TFhirPlanDefinitionGoalTarget }

constructor TFhirPlanDefinitionGoalTarget.Create;
begin
  inherited;
end;

destructor TFhirPlanDefinitionGoalTarget.Destroy;
begin
  FMeasure.free;
  FDetail.free;
  FDue.free;
  inherited;
end;

procedure TFhirPlanDefinitionGoalTarget.Assign(oSource : TFslObject);
begin
  inherited;
  measure := TFhirPlanDefinitionGoalTarget(oSource).measure.Clone;
  detail := TFhirPlanDefinitionGoalTarget(oSource).detail.Clone;
  due := TFhirPlanDefinitionGoalTarget(oSource).due.Clone;
end;

procedure TFhirPlanDefinitionGoalTarget.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'measure') Then
     list.add(self.link, 'measure', FMeasure.Link);
  if (child_name = 'detail[x]') or (child_name = 'detail') Then
     list.add(self.link, 'detail[x]', FDetail.Link);
  if (child_name = 'due') Then
     list.add(self.link, 'due', FDue.Link);
end;

procedure TFhirPlanDefinitionGoalTarget.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'measure', 'CodeableConcept', false, TFhirCodeableConcept, FMeasure.Link));{2}
  oList.add(TFHIRProperty.create(self, 'detail[x]', 'Quantity|Range|CodeableConcept', false, TFhirType, FDetail.Link));{2}
  oList.add(TFHIRProperty.create(self, 'due', 'Duration', false, TFhirDuration, FDue.Link));{2}
end;

function TFhirPlanDefinitionGoalTarget.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'measure') then
  begin
    Measure := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'detail', ['Quantity', 'Range', 'CodeableConcept'])) then
  begin
    Detail := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'due') then
  begin
    Due := propValue as TFhirDuration{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPlanDefinitionGoalTarget.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPlanDefinitionGoalTarget.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'measure') then result := TFhirCodeableConcept.create(){4b}
  else if (isMatchingName(propName, 'detail', ['Quantity', 'Range', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property Detail'){4x}
  else if (propName = 'due') then result := TFhirDuration.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPlanDefinitionGoalTarget.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'measure') then result := 'CodeableConcept'
  else if (propName = 'detail[x]') then result := 'Quantity|Range|CodeableConcept'
  else if (propName = 'due') then result := 'Duration'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPlanDefinitionGoalTarget.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'measure') then MeasureElement := nil
  else if (isMatchingName(propName, 'detail', ['Quantity', 'Range', 'CodeableConcept'])) then DetailElement := nil{4x}
  else if (propName = 'due') then DueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPlanDefinitionGoalTarget.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'measure') then MeasureElement := new as TFhirCodeableConcept{4}
  else if (isMatchingName(propName, 'detail', ['Quantity', 'Range', 'CodeableConcept'])) then DetailElement := new as TFhirType{4x}
  else if (propName = 'due') then DueElement := new as TFhirDuration{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPlanDefinitionGoalTarget.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPlanDefinitionGoalTarget.fhirType : string;
begin
  result := 'target';
end;

function TFhirPlanDefinitionGoalTarget.Link : TFhirPlanDefinitionGoalTarget;
begin
  result := TFhirPlanDefinitionGoalTarget(inherited Link);
end;

function TFhirPlanDefinitionGoalTarget.Clone : TFhirPlanDefinitionGoalTarget;
begin
  result := TFhirPlanDefinitionGoalTarget(inherited Clone);
end;

function TFhirPlanDefinitionGoalTarget.equals(other : TObject) : boolean;
var
  o : TFhirPlanDefinitionGoalTarget;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPlanDefinitionGoalTarget)) then
    result := false
  else
  begin
    o := TFhirPlanDefinitionGoalTarget(other);
    result := compareDeep(measureElement, o.measureElement, true) and compareDeep(detailElement, o.detailElement, true) and
      compareDeep(dueElement, o.dueElement, true);
  end;
end;

function TFhirPlanDefinitionGoalTarget.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMeasure) and isEmptyProp(FDetail) and isEmptyProp(FDue);
end;

procedure TFhirPlanDefinitionGoalTarget.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('measure');
  fields.add('detail[x]');
  fields.add('due');
end;

{ TFhirPlanDefinitionGoalTarget }

Procedure TFhirPlanDefinitionGoalTarget.SetMeasure(value : TFhirCodeableConcept);
begin
  FMeasure.free;
  FMeasure := value;
end;

Procedure TFhirPlanDefinitionGoalTarget.SetDetail(value : TFhirType);
begin
  FDetail.free;
  FDetail := value;
end;

Procedure TFhirPlanDefinitionGoalTarget.SetDue(value : TFhirDuration);
begin
  FDue.free;
  FDue := value;
end;

function TFhirPlanDefinitionGoalTarget.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FMeasure.sizeInBytes);
  inc(result, FDetail.sizeInBytes);
  inc(result, FDue.sizeInBytes);
end;

{ TFhirPlanDefinitionGoalTargetListEnumerator }

Constructor TFhirPlanDefinitionGoalTargetListEnumerator.Create(list : TFhirPlanDefinitionGoalTargetList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPlanDefinitionGoalTargetListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPlanDefinitionGoalTargetListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPlanDefinitionGoalTargetListEnumerator.GetCurrent : TFhirPlanDefinitionGoalTarget;
begin
  Result := FList[FIndex];
end;

function TFhirPlanDefinitionGoalTargetListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPlanDefinitionGoalTargetList }
procedure TFhirPlanDefinitionGoalTargetList.AddItem(value: TFhirPlanDefinitionGoalTarget);
begin
  assert(value.ClassName = 'TFhirPlanDefinitionGoalTarget', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPlanDefinitionGoalTarget');
  add(value);
end;

function TFhirPlanDefinitionGoalTargetList.Append: TFhirPlanDefinitionGoalTarget;
begin
  result := TFhirPlanDefinitionGoalTarget.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionGoalTargetList.ClearItems;
begin
  Clear;
end;

function TFhirPlanDefinitionGoalTargetList.GetEnumerator : TFhirPlanDefinitionGoalTargetListEnumerator;
begin
  result := TFhirPlanDefinitionGoalTargetListEnumerator.Create(self.link);
end;

function TFhirPlanDefinitionGoalTargetList.Clone: TFhirPlanDefinitionGoalTargetList;
begin
  result := TFhirPlanDefinitionGoalTargetList(inherited Clone);
end;

function TFhirPlanDefinitionGoalTargetList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPlanDefinitionGoalTargetList.GetItemN(index: Integer): TFhirPlanDefinitionGoalTarget;
begin
  result := TFhirPlanDefinitionGoalTarget(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionGoalTargetList.ItemClass: TFslObjectClass;
begin
  result := TFhirPlanDefinitionGoalTarget;
end;
function TFhirPlanDefinitionGoalTargetList.IndexOf(value: TFhirPlanDefinitionGoalTarget): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPlanDefinitionGoalTargetList.Insert(index: Integer): TFhirPlanDefinitionGoalTarget;
begin
  result := TFhirPlanDefinitionGoalTarget.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionGoalTargetList.InsertItem(index: Integer; value: TFhirPlanDefinitionGoalTarget);
begin
  assert(value is TFhirPlanDefinitionGoalTarget);
  Inherited Insert(index, value);
end;

function TFhirPlanDefinitionGoalTargetList.Item(index: Integer): TFhirPlanDefinitionGoalTarget;
begin
  result := TFhirPlanDefinitionGoalTarget(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionGoalTargetList.Link: TFhirPlanDefinitionGoalTargetList;
begin
  result := TFhirPlanDefinitionGoalTargetList(inherited Link);
end;

procedure TFhirPlanDefinitionGoalTargetList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPlanDefinitionGoalTargetList.SetItemByIndex(index: Integer; value: TFhirPlanDefinitionGoalTarget);
begin
  assert(value is TFhirPlanDefinitionGoalTarget);
  FhirPlanDefinitionGoalTargets[index] := value;
end;

procedure TFhirPlanDefinitionGoalTargetList.SetItemN(index: Integer; value: TFhirPlanDefinitionGoalTarget);
begin
  assert(value is TFhirPlanDefinitionGoalTarget);
  ObjectByIndex[index] := value;
end;

{ TFhirPlanDefinitionAction }

constructor TFhirPlanDefinitionAction.Create;
begin
  inherited;
end;

destructor TFhirPlanDefinitionAction.Destroy;
begin
  FLabel_.free;
  FTitle.free;
  FDescription.free;
  FTextEquivalent.free;
  FCodeList.Free;
  FReasonList.Free;
  FDocumentationList.Free;
  FGoalIdList.Free;
  FTriggerDefinitionList.Free;
  FConditionList.Free;
  FInputList.Free;
  FOutputList.Free;
  FRelatedActionList.Free;
  FTiming.free;
  FParticipantList.Free;
  FType_.free;
  FGroupingBehavior.free;
  FSelectionBehavior.free;
  FRequiredBehavior.free;
  FPrecheckBehavior.free;
  FCardinalityBehavior.free;
  FDefinition.free;
  FTransform.free;
  FDynamicValueList.Free;
  FActionList.Free;
  inherited;
end;

procedure TFhirPlanDefinitionAction.Assign(oSource : TFslObject);
begin
  inherited;
  label_Element := TFhirPlanDefinitionAction(oSource).label_Element.Clone;
  titleElement := TFhirPlanDefinitionAction(oSource).titleElement.Clone;
  descriptionElement := TFhirPlanDefinitionAction(oSource).descriptionElement.Clone;
  textEquivalentElement := TFhirPlanDefinitionAction(oSource).textEquivalentElement.Clone;
  if (TFhirPlanDefinitionAction(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirCodeableConceptList.Create;
    FCodeList.Assign(TFhirPlanDefinitionAction(oSource).FCodeList);
  end;
  if (TFhirPlanDefinitionAction(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableConceptList.Create;
    FReasonList.Assign(TFhirPlanDefinitionAction(oSource).FReasonList);
  end;
  if (TFhirPlanDefinitionAction(oSource).FDocumentationList = nil) then
  begin
    FDocumentationList.free;
    FDocumentationList := nil;
  end
  else
  begin
    if FDocumentationList = nil then
      FDocumentationList := TFhirRelatedArtifactList.Create;
    FDocumentationList.Assign(TFhirPlanDefinitionAction(oSource).FDocumentationList);
  end;
  if (TFhirPlanDefinitionAction(oSource).FGoalIdList = nil) then
  begin
    FGoalIdList.free;
    FGoalIdList := nil;
  end
  else
  begin
    if FGoalIdList = nil then
      FGoalIdList := TFhirIdList.Create;
    FGoalIdList.Assign(TFhirPlanDefinitionAction(oSource).FGoalIdList);
  end;
  if (TFhirPlanDefinitionAction(oSource).FTriggerDefinitionList = nil) then
  begin
    FTriggerDefinitionList.free;
    FTriggerDefinitionList := nil;
  end
  else
  begin
    if FTriggerDefinitionList = nil then
      FTriggerDefinitionList := TFhirTriggerDefinitionList.Create;
    FTriggerDefinitionList.Assign(TFhirPlanDefinitionAction(oSource).FTriggerDefinitionList);
  end;
  if (TFhirPlanDefinitionAction(oSource).FConditionList = nil) then
  begin
    FConditionList.free;
    FConditionList := nil;
  end
  else
  begin
    if FConditionList = nil then
      FConditionList := TFhirPlanDefinitionActionConditionList.Create;
    FConditionList.Assign(TFhirPlanDefinitionAction(oSource).FConditionList);
  end;
  if (TFhirPlanDefinitionAction(oSource).FInputList = nil) then
  begin
    FInputList.free;
    FInputList := nil;
  end
  else
  begin
    if FInputList = nil then
      FInputList := TFhirDataRequirementList.Create;
    FInputList.Assign(TFhirPlanDefinitionAction(oSource).FInputList);
  end;
  if (TFhirPlanDefinitionAction(oSource).FOutputList = nil) then
  begin
    FOutputList.free;
    FOutputList := nil;
  end
  else
  begin
    if FOutputList = nil then
      FOutputList := TFhirDataRequirementList.Create;
    FOutputList.Assign(TFhirPlanDefinitionAction(oSource).FOutputList);
  end;
  if (TFhirPlanDefinitionAction(oSource).FRelatedActionList = nil) then
  begin
    FRelatedActionList.free;
    FRelatedActionList := nil;
  end
  else
  begin
    if FRelatedActionList = nil then
      FRelatedActionList := TFhirPlanDefinitionActionRelatedActionList.Create;
    FRelatedActionList.Assign(TFhirPlanDefinitionAction(oSource).FRelatedActionList);
  end;
  timing := TFhirPlanDefinitionAction(oSource).timing.Clone;
  if (TFhirPlanDefinitionAction(oSource).FParticipantList = nil) then
  begin
    FParticipantList.free;
    FParticipantList := nil;
  end
  else
  begin
    if FParticipantList = nil then
      FParticipantList := TFhirPlanDefinitionActionParticipantList.Create;
    FParticipantList.Assign(TFhirPlanDefinitionAction(oSource).FParticipantList);
  end;
  type_ := TFhirPlanDefinitionAction(oSource).type_.Clone;
  FGroupingBehavior := TFhirPlanDefinitionAction(oSource).FGroupingBehavior.Link;
  FSelectionBehavior := TFhirPlanDefinitionAction(oSource).FSelectionBehavior.Link;
  FRequiredBehavior := TFhirPlanDefinitionAction(oSource).FRequiredBehavior.Link;
  FPrecheckBehavior := TFhirPlanDefinitionAction(oSource).FPrecheckBehavior.Link;
  FCardinalityBehavior := TFhirPlanDefinitionAction(oSource).FCardinalityBehavior.Link;
  definition := TFhirPlanDefinitionAction(oSource).definition.Clone;
  transform := TFhirPlanDefinitionAction(oSource).transform.Clone;
  if (TFhirPlanDefinitionAction(oSource).FDynamicValueList = nil) then
  begin
    FDynamicValueList.free;
    FDynamicValueList := nil;
  end
  else
  begin
    if FDynamicValueList = nil then
      FDynamicValueList := TFhirPlanDefinitionActionDynamicValueList.Create;
    FDynamicValueList.Assign(TFhirPlanDefinitionAction(oSource).FDynamicValueList);
  end;
  if (TFhirPlanDefinitionAction(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirPlanDefinitionActionList.Create;
    FActionList.Assign(TFhirPlanDefinitionAction(oSource).FActionList);
  end;
end;

procedure TFhirPlanDefinitionAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'label') Then
     list.add(self.link, 'label', FLabel_.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'textEquivalent') Then
     list.add(self.link, 'textEquivalent', FTextEquivalent.Link);
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'documentation') Then
    list.addAll(self, 'documentation', FDocumentationList);
  if (child_name = 'goalId') Then
    list.addAll(self, 'goalId', FGoalIdList);
  if (child_name = 'triggerDefinition') Then
    list.addAll(self, 'triggerDefinition', FTriggerDefinitionList);
  if (child_name = 'condition') Then
    list.addAll(self, 'condition', FConditionList);
  if (child_name = 'input') Then
    list.addAll(self, 'input', FInputList);
  if (child_name = 'output') Then
    list.addAll(self, 'output', FOutputList);
  if (child_name = 'relatedAction') Then
    list.addAll(self, 'relatedAction', FRelatedActionList);
  if (child_name = 'timing[x]') or (child_name = 'timing') Then
     list.add(self.link, 'timing[x]', FTiming.Link);
  if (child_name = 'participant') Then
    list.addAll(self, 'participant', FParticipantList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'groupingBehavior') Then
     list.add(self.link, 'groupingBehavior', FGroupingBehavior.Link);
  if (child_name = 'selectionBehavior') Then
     list.add(self.link, 'selectionBehavior', FSelectionBehavior.Link);
  if (child_name = 'requiredBehavior') Then
     list.add(self.link, 'requiredBehavior', FRequiredBehavior.Link);
  if (child_name = 'precheckBehavior') Then
     list.add(self.link, 'precheckBehavior', FPrecheckBehavior.Link);
  if (child_name = 'cardinalityBehavior') Then
     list.add(self.link, 'cardinalityBehavior', FCardinalityBehavior.Link);
  if (child_name = 'definition') Then
     list.add(self.link, 'definition', FDefinition.Link);
  if (child_name = 'transform') Then
     list.add(self.link, 'transform', FTransform.Link);
  if (child_name = 'dynamicValue') Then
    list.addAll(self, 'dynamicValue', FDynamicValueList);
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
end;

procedure TFhirPlanDefinitionAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'label', 'string', false, TFhirString, FLabel_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'textEquivalent', 'string', false, TFhirString, FTextEquivalent.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', true, TFhirCodeableConcept, FCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', true, TFhirCodeableConcept, FReasonList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'documentation', 'RelatedArtifact', true, TFhirRelatedArtifact, FDocumentationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'goalId', 'id', true, TFhirId, FGoalIdList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'triggerDefinition', 'TriggerDefinition', true, TFhirTriggerDefinition, FTriggerDefinitionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'condition', '', true, TFhirPlanDefinitionActionCondition, FConditionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'input', 'DataRequirement', true, TFhirDataRequirement, FInputList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'output', 'DataRequirement', true, TFhirDataRequirement, FOutputList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'relatedAction', '', true, TFhirPlanDefinitionActionRelatedAction, FRelatedActionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'timing[x]', 'dateTime|Period|Duration|Range|Timing', false, TFhirType, FTiming.Link));{2}
  oList.add(TFHIRProperty.create(self, 'participant', '', true, TFhirPlanDefinitionActionParticipant, FParticipantList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', false, TFhirCoding, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'groupingBehavior', 'code', false, TFHIREnum, FGroupingBehavior.Link));{1}
  oList.add(TFHIRProperty.create(self, 'selectionBehavior', 'code', false, TFHIREnum, FSelectionBehavior.Link));{1}
  oList.add(TFHIRProperty.create(self, 'requiredBehavior', 'code', false, TFHIREnum, FRequiredBehavior.Link));{1}
  oList.add(TFHIRProperty.create(self, 'precheckBehavior', 'code', false, TFHIREnum, FPrecheckBehavior.Link));{1}
  oList.add(TFHIRProperty.create(self, 'cardinalityBehavior', 'code', false, TFHIREnum, FCardinalityBehavior.Link));{1}
  oList.add(TFHIRProperty.create(self, 'definition', 'Reference(ActivityDefinition|PlanDefinition)', false, TFhirReference{Resource}, FDefinition.Link));{2}
  oList.add(TFHIRProperty.create(self, 'transform', 'Reference(StructureMap)', false, TFhirReference{TFhirStructureMap}, FTransform.Link));{2}
  oList.add(TFHIRProperty.create(self, 'dynamicValue', '', true, TFhirPlanDefinitionActionDynamicValue, FDynamicValueList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'action', '@PlanDefinition.action', true, TFhirPlanDefinitionAction, FActionList.Link)){3};
end;

function TFhirPlanDefinitionAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'label') then
  begin
    Label_Element := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'textEquivalent') then
  begin
    TextEquivalentElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'documentation') then
  begin
    DocumentationList.add(propValue as TFhirRelatedArtifact){2a};
    result := propValue;
  end
  else if (propName = 'goalId') then
  begin
    GoalIdList.add(asId(propValue)){2};     result := propValue;

  end
  else if (propName = 'triggerDefinition') then
  begin
    TriggerDefinitionList.add(propValue as TFhirTriggerDefinition){2a};
    result := propValue;
  end
  else if (propName = 'condition') then
  begin
    ConditionList.add(propValue as TFhirPlanDefinitionActionCondition){2a};
    result := propValue;
  end
  else if (propName = 'input') then
  begin
    InputList.add(propValue as TFhirDataRequirement){2a};
    result := propValue;
  end
  else if (propName = 'output') then
  begin
    OutputList.add(propValue as TFhirDataRequirement){2a};
    result := propValue;
  end
  else if (propName = 'relatedAction') then
  begin
    RelatedActionList.add(propValue as TFhirPlanDefinitionActionRelatedAction){2a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'timing', ['DateTime', 'Period', 'Duration', 'Range', 'Timing'])) then
  begin
    Timing := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'participant') then
  begin
    ParticipantList.add(propValue as TFhirPlanDefinitionActionParticipant){2a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'groupingBehavior') then
  begin
    GroupingBehaviorElement := asEnum(SYSTEMS_TFhirActionGroupingBehaviorEnum, CODES_TFhirActionGroupingBehaviorEnum, propValue);
    result := propValue
  end
  else if (propName = 'selectionBehavior') then
  begin
    SelectionBehaviorElement := asEnum(SYSTEMS_TFhirActionSelectionBehaviorEnum, CODES_TFhirActionSelectionBehaviorEnum, propValue);
    result := propValue
  end
  else if (propName = 'requiredBehavior') then
  begin
    RequiredBehaviorElement := asEnum(SYSTEMS_TFhirActionRequiredBehaviorEnum, CODES_TFhirActionRequiredBehaviorEnum, propValue);
    result := propValue
  end
  else if (propName = 'precheckBehavior') then
  begin
    PrecheckBehaviorElement := asEnum(SYSTEMS_TFhirActionPrecheckBehaviorEnum, CODES_TFhirActionPrecheckBehaviorEnum, propValue);
    result := propValue
  end
  else if (propName = 'cardinalityBehavior') then
  begin
    CardinalityBehaviorElement := asEnum(SYSTEMS_TFhirActionCardinalityBehaviorEnum, CODES_TFhirActionCardinalityBehaviorEnum, propValue);
    result := propValue
  end
  else if (propName = 'definition') then
  begin
    Definition := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'transform') then
  begin
    Transform := propValue as TFhirReference{TFhirStructureMap}{4b};
    result := propValue;
  end
  else if (propName = 'dynamicValue') then
  begin
    DynamicValueList.add(propValue as TFhirPlanDefinitionActionDynamicValue){2a};
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirPlanDefinitionAction){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPlanDefinitionAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'documentation') then DocumentationList.insertItem(index, propValue as TFhirRelatedArtifact){2a}
  else if (propName = 'goalId') then GoalIdList.insertItem(index, asId(propValue)){2}
  else if (propName = 'triggerDefinition') then TriggerDefinitionList.insertItem(index, propValue as TFhirTriggerDefinition){2a}
  else if (propName = 'condition') then ConditionList.insertItem(index, propValue as TFhirPlanDefinitionActionCondition){2a}
  else if (propName = 'input') then InputList.insertItem(index, propValue as TFhirDataRequirement){2a}
  else if (propName = 'output') then OutputList.insertItem(index, propValue as TFhirDataRequirement){2a}
  else if (propName = 'relatedAction') then RelatedActionList.insertItem(index, propValue as TFhirPlanDefinitionActionRelatedAction){2a}
  else if (propName = 'participant') then ParticipantList.insertItem(index, propValue as TFhirPlanDefinitionActionParticipant){2a}
  else if (propName = 'dynamicValue') then DynamicValueList.insertItem(index, propValue as TFhirPlanDefinitionActionDynamicValue){2a}
  else if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirPlanDefinitionAction){2a}
  else inherited;
end;

function TFhirPlanDefinitionAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'label') then result := TFhirString.create() {5b}
  else if (propName = 'title') then result := TFhirString.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'textEquivalent') then result := TFhirString.create() {5b}
  else if (propName = 'code') then result := CodeList.new(){2}
  else if (propName = 'reason') then result := ReasonList.new(){2}
  else if (propName = 'documentation') then result := DocumentationList.new(){2}
  else if (propName = 'goalId') then result := GoalIdList.new(){2}
  else if (propName = 'triggerDefinition') then result := TriggerDefinitionList.new(){2}
  else if (propName = 'condition') then result := ConditionList.new(){2}
  else if (propName = 'input') then result := InputList.new(){2}
  else if (propName = 'output') then result := OutputList.new(){2}
  else if (propName = 'relatedAction') then result := RelatedActionList.new(){2}
  else if (isMatchingName(propName, 'timing', ['DateTime', 'Period', 'Duration', 'Range', 'Timing'])) then raise EFHIRException.create('Cannot make property Timing'){4x}
  else if (propName = 'participant') then result := ParticipantList.new(){2}
  else if (propName = 'type') then result := TFhirCoding.create(){4b}
  else if (propName = 'definition') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'transform') then result := TFhirReference{TFhirStructureMap}.create(){4b}
  else if (propName = 'dynamicValue') then result := DynamicValueList.new(){2}
  else if (propName = 'action') then result := ActionList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPlanDefinitionAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'label') then result := 'string'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'textEquivalent') then result := 'string'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else if (propName = 'documentation') then result := 'RelatedArtifact'
  else if (propName = 'goalId') then result := 'id'
  else if (propName = 'triggerDefinition') then result := 'TriggerDefinition'
  else if (propName = 'condition') then result := ''
  else if (propName = 'input') then result := 'DataRequirement'
  else if (propName = 'output') then result := 'DataRequirement'
  else if (propName = 'relatedAction') then result := ''
  else if (propName = 'timing[x]') then result := 'dateTime|Period|Duration|Range|Timing'
  else if (propName = 'participant') then result := ''
  else if (propName = 'type') then result := 'Coding'
  else if (propName = 'groupingBehavior') then result := 'code'
  else if (propName = 'selectionBehavior') then result := 'code'
  else if (propName = 'requiredBehavior') then result := 'code'
  else if (propName = 'precheckBehavior') then result := 'code'
  else if (propName = 'cardinalityBehavior') then result := 'code'
  else if (propName = 'definition') then result := 'Reference'
  else if (propName = 'transform') then result := 'Reference'
  else if (propName = 'dynamicValue') then result := ''
  else if (propName = 'action') then result := '@PlanDefinition.action'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPlanDefinitionAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'label') then Label_Element := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'textEquivalent') then TextEquivalentElement := nil
  else if (propName = 'code') then deletePropertyValue('code', CodeList, value) {2}
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value) {2}
  else if (propName = 'documentation') then deletePropertyValue('documentation', DocumentationList, value) {2}
  else if (propName = 'goalId') then deletePropertyValue('goalId', GoalIdList, value) {2}
  else if (propName = 'triggerDefinition') then deletePropertyValue('triggerDefinition', TriggerDefinitionList, value) {2}
  else if (propName = 'condition') then deletePropertyValue('condition', ConditionList, value) {2}
  else if (propName = 'input') then deletePropertyValue('input', InputList, value) {2}
  else if (propName = 'output') then deletePropertyValue('output', OutputList, value) {2}
  else if (propName = 'relatedAction') then deletePropertyValue('relatedAction', RelatedActionList, value) {2}
  else if (isMatchingName(propName, 'timing', ['DateTime', 'Period', 'Duration', 'Range', 'Timing'])) then TimingElement := nil{4x}
  else if (propName = 'participant') then deletePropertyValue('participant', ParticipantList, value) {2}
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'groupingBehavior') then GroupingBehaviorElement := nil
  else if (propName = 'selectionBehavior') then SelectionBehaviorElement := nil
  else if (propName = 'requiredBehavior') then RequiredBehaviorElement := nil
  else if (propName = 'precheckBehavior') then PrecheckBehaviorElement := nil
  else if (propName = 'cardinalityBehavior') then CardinalityBehaviorElement := nil
  else if (propName = 'definition') then DefinitionElement := nil
  else if (propName = 'transform') then TransformElement := nil
  else if (propName = 'dynamicValue') then deletePropertyValue('dynamicValue', DynamicValueList, value) {2}
  else if (propName = 'action') then deletePropertyValue('action', ActionList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPlanDefinitionAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'label') then Label_Element := asString(new){5b}
  else if (propName = 'title') then TitleElement := asString(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'textEquivalent') then TextEquivalentElement := asString(new){5b}
  else if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new) {2}
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new) {2}
  else if (propName = 'documentation') then replacePropertyValue('documentation', DocumentationList, existing, new) {2}
  else if (propName = 'goalId') then replacePropertyValue('goalId', GoalIdList, existing, new) {2}
  else if (propName = 'triggerDefinition') then replacePropertyValue('triggerDefinition', TriggerDefinitionList, existing, new) {2}
  else if (propName = 'condition') then replacePropertyValue('condition', ConditionList, existing, new) {2}
  else if (propName = 'input') then replacePropertyValue('input', InputList, existing, new) {2}
  else if (propName = 'output') then replacePropertyValue('output', OutputList, existing, new) {2}
  else if (propName = 'relatedAction') then replacePropertyValue('relatedAction', RelatedActionList, existing, new) {2}
  else if (isMatchingName(propName, 'timing', ['DateTime', 'Period', 'Duration', 'Range', 'Timing'])) then TimingElement := new as TFhirType{4x}
  else if (propName = 'participant') then replacePropertyValue('participant', ParticipantList, existing, new) {2}
  else if (propName = 'type') then Type_Element := new as TFhirCoding{4}
  else if (propName = 'groupingBehavior') then GroupingBehaviorElement := asEnum(SYSTEMS_TFhirActionGroupingBehaviorEnum, CODES_TFhirActionGroupingBehaviorEnum, new){4}
  else if (propName = 'selectionBehavior') then SelectionBehaviorElement := asEnum(SYSTEMS_TFhirActionSelectionBehaviorEnum, CODES_TFhirActionSelectionBehaviorEnum, new){4}
  else if (propName = 'requiredBehavior') then RequiredBehaviorElement := asEnum(SYSTEMS_TFhirActionRequiredBehaviorEnum, CODES_TFhirActionRequiredBehaviorEnum, new){4}
  else if (propName = 'precheckBehavior') then PrecheckBehaviorElement := asEnum(SYSTEMS_TFhirActionPrecheckBehaviorEnum, CODES_TFhirActionPrecheckBehaviorEnum, new){4}
  else if (propName = 'cardinalityBehavior') then CardinalityBehaviorElement := asEnum(SYSTEMS_TFhirActionCardinalityBehaviorEnum, CODES_TFhirActionCardinalityBehaviorEnum, new){4}
  else if (propName = 'definition') then DefinitionElement := new as TFhirReference{Resource}{4}
  else if (propName = 'transform') then TransformElement := new as TFhirReference{TFhirStructureMap}{4}
  else if (propName = 'dynamicValue') then replacePropertyValue('dynamicValue', DynamicValueList, existing, new) {2}
  else if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPlanDefinitionAction.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'code') then CodeList.move(source, destination){2a}
  else if (propName = 'reason') then ReasonList.move(source, destination){2a}
  else if (propName = 'documentation') then DocumentationList.move(source, destination){2a}
  else if (propName = 'goalId') then GoalIdList.move(source, destination){2}
  else if (propName = 'triggerDefinition') then TriggerDefinitionList.move(source, destination){2a}
  else if (propName = 'condition') then ConditionList.move(source, destination){2a}
  else if (propName = 'input') then InputList.move(source, destination){2a}
  else if (propName = 'output') then OutputList.move(source, destination){2a}
  else if (propName = 'relatedAction') then RelatedActionList.move(source, destination){2a}
  else if (propName = 'participant') then ParticipantList.move(source, destination){2a}
  else if (propName = 'dynamicValue') then DynamicValueList.move(source, destination){2a}
  else if (propName = 'action') then ActionList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPlanDefinitionAction.fhirType : string;
begin
  result := 'action';
end;

function TFhirPlanDefinitionAction.Link : TFhirPlanDefinitionAction;
begin
  result := TFhirPlanDefinitionAction(inherited Link);
end;

function TFhirPlanDefinitionAction.Clone : TFhirPlanDefinitionAction;
begin
  result := TFhirPlanDefinitionAction(inherited Clone);
end;

function TFhirPlanDefinitionAction.equals(other : TObject) : boolean;
var
  o : TFhirPlanDefinitionAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPlanDefinitionAction)) then
    result := false
  else
  begin
    o := TFhirPlanDefinitionAction(other);
    result := compareDeep(label_Element, o.label_Element, true) and compareDeep(titleElement, o.titleElement, true) and
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(textEquivalentElement, o.textEquivalentElement, true) and
      compareDeep(codeList, o.codeList, true) and compareDeep(reasonList, o.reasonList, true) and
      compareDeep(documentationList, o.documentationList, true) and compareDeep(goalIdList, o.goalIdList, true) and
      compareDeep(triggerDefinitionList, o.triggerDefinitionList, true) and compareDeep(conditionList, o.conditionList, true) and
      compareDeep(inputList, o.inputList, true) and compareDeep(outputList, o.outputList, true) and
      compareDeep(relatedActionList, o.relatedActionList, true) and compareDeep(timingElement, o.timingElement, true) and
      compareDeep(participantList, o.participantList, true) and compareDeep(type_Element, o.type_Element, true) and
      compareDeep(groupingBehaviorElement, o.groupingBehaviorElement, true) and compareDeep(selectionBehaviorElement, o.selectionBehaviorElement, true) and
      compareDeep(requiredBehaviorElement, o.requiredBehaviorElement, true) and compareDeep(precheckBehaviorElement, o.precheckBehaviorElement, true) and
      compareDeep(cardinalityBehaviorElement, o.cardinalityBehaviorElement, true) and
      compareDeep(definitionElement, o.definitionElement, true) and compareDeep(transformElement, o.transformElement, true) and
      compareDeep(dynamicValueList, o.dynamicValueList, true) and compareDeep(actionList, o.actionList, true);
  end;
end;

function TFhirPlanDefinitionAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLabel_) and isEmptyProp(FTitle) and isEmptyProp(FDescription) and isEmptyProp(FTextEquivalent) and isEmptyProp(FcodeList) and isEmptyProp(FreasonList) and isEmptyProp(FdocumentationList) and isEmptyProp(FgoalIdList) and isEmptyProp(FtriggerDefinitionList) and isEmptyProp(FconditionList) and isEmptyProp(FinputList) and isEmptyProp(FoutputList) and isEmptyProp(FrelatedActionList) and isEmptyProp(FTiming) and isEmptyProp(FparticipantList) and isEmptyProp(FType_) and isEmptyProp(FGroupingBehavior) and isEmptyProp(FSelectionBehavior) and isEmptyProp(FRequiredBehavior) and isEmptyProp(FPrecheckBehavior) and isEmptyProp(FCardinalityBehavior) and isEmptyProp(FDefinition) and isEmptyProp(FTransform) and isEmptyProp(FdynamicValueList) and isEmptyProp(FactionList);
end;

procedure TFhirPlanDefinitionAction.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('label');
  fields.add('title');
  fields.add('description');
  fields.add('textEquivalent');
  fields.add('code');
  fields.add('reason');
  fields.add('documentation');
  fields.add('goalId');
  fields.add('triggerDefinition');
  fields.add('condition');
  fields.add('input');
  fields.add('output');
  fields.add('relatedAction');
  fields.add('timing[x]');
  fields.add('participant');
  fields.add('type');
  fields.add('groupingBehavior');
  fields.add('selectionBehavior');
  fields.add('requiredBehavior');
  fields.add('precheckBehavior');
  fields.add('cardinalityBehavior');
  fields.add('definition');
  fields.add('transform');
  fields.add('dynamicValue');
  fields.add('action');
end;

{ TFhirPlanDefinitionAction }

Procedure TFhirPlanDefinitionAction.SetLabel_(value : TFhirString);
begin
  FLabel_.free;
  FLabel_ := value;
end;

Function TFhirPlanDefinitionAction.GetLabel_ST : String;
begin
  if FLabel_ = nil then
    result := ''
  else
    result := FLabel_.value;
end;

Procedure TFhirPlanDefinitionAction.SetLabel_ST(value : String);
begin
  if value <> '' then
  begin
    if FLabel_ = nil then
      FLabel_ := TFhirString.create;
    FLabel_.value := value
  end
  else if FLabel_ <> nil then
    FLabel_.value := '';
end;

Procedure TFhirPlanDefinitionAction.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

Function TFhirPlanDefinitionAction.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

Procedure TFhirPlanDefinitionAction.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

Procedure TFhirPlanDefinitionAction.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirPlanDefinitionAction.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirPlanDefinitionAction.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirPlanDefinitionAction.SetTextEquivalent(value : TFhirString);
begin
  FTextEquivalent.free;
  FTextEquivalent := value;
end;

Function TFhirPlanDefinitionAction.GetTextEquivalentST : String;
begin
  if FTextEquivalent = nil then
    result := ''
  else
    result := FTextEquivalent.value;
end;

Procedure TFhirPlanDefinitionAction.SetTextEquivalentST(value : String);
begin
  if value <> '' then
  begin
    if FTextEquivalent = nil then
      FTextEquivalent := TFhirString.create;
    FTextEquivalent.value := value
  end
  else if FTextEquivalent <> nil then
    FTextEquivalent.value := '';
end;

Function TFhirPlanDefinitionAction.GetCodeList : TFhirCodeableConceptList;
begin
  if FCodeList = nil then
    FCodeList := TFhirCodeableConceptList.Create;
  result := FCodeList;
end;

Function TFhirPlanDefinitionAction.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

Function TFhirPlanDefinitionAction.GetReasonList : TFhirCodeableConceptList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableConceptList.Create;
  result := FReasonList;
end;

Function TFhirPlanDefinitionAction.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

Function TFhirPlanDefinitionAction.GetDocumentationList : TFhirRelatedArtifactList;
begin
  if FDocumentationList = nil then
    FDocumentationList := TFhirRelatedArtifactList.Create;
  result := FDocumentationList;
end;

Function TFhirPlanDefinitionAction.GetHasDocumentationList : boolean;
begin
  result := (FDocumentationList <> nil) and (FDocumentationList.count > 0);
end;

Function TFhirPlanDefinitionAction.GetGoalIdList : TFhirIdList;
begin
  if FGoalIdList = nil then
    FGoalIdList := TFhirIdList.Create;
  result := FGoalIdList;
end;

Function TFhirPlanDefinitionAction.GetHasGoalIdList : boolean;
begin
  result := (FGoalIdList <> nil) and (FGoalIdList.count > 0);
end;

Function TFhirPlanDefinitionAction.GetTriggerDefinitionList : TFhirTriggerDefinitionList;
begin
  if FTriggerDefinitionList = nil then
    FTriggerDefinitionList := TFhirTriggerDefinitionList.Create;
  result := FTriggerDefinitionList;
end;

Function TFhirPlanDefinitionAction.GetHasTriggerDefinitionList : boolean;
begin
  result := (FTriggerDefinitionList <> nil) and (FTriggerDefinitionList.count > 0);
end;

Function TFhirPlanDefinitionAction.GetConditionList : TFhirPlanDefinitionActionConditionList;
begin
  if FConditionList = nil then
    FConditionList := TFhirPlanDefinitionActionConditionList.Create;
  result := FConditionList;
end;

Function TFhirPlanDefinitionAction.GetHasConditionList : boolean;
begin
  result := (FConditionList <> nil) and (FConditionList.count > 0);
end;

Function TFhirPlanDefinitionAction.GetInputList : TFhirDataRequirementList;
begin
  if FInputList = nil then
    FInputList := TFhirDataRequirementList.Create;
  result := FInputList;
end;

Function TFhirPlanDefinitionAction.GetHasInputList : boolean;
begin
  result := (FInputList <> nil) and (FInputList.count > 0);
end;

Function TFhirPlanDefinitionAction.GetOutputList : TFhirDataRequirementList;
begin
  if FOutputList = nil then
    FOutputList := TFhirDataRequirementList.Create;
  result := FOutputList;
end;

Function TFhirPlanDefinitionAction.GetHasOutputList : boolean;
begin
  result := (FOutputList <> nil) and (FOutputList.count > 0);
end;

Function TFhirPlanDefinitionAction.GetRelatedActionList : TFhirPlanDefinitionActionRelatedActionList;
begin
  if FRelatedActionList = nil then
    FRelatedActionList := TFhirPlanDefinitionActionRelatedActionList.Create;
  result := FRelatedActionList;
end;

Function TFhirPlanDefinitionAction.GetHasRelatedActionList : boolean;
begin
  result := (FRelatedActionList <> nil) and (FRelatedActionList.count > 0);
end;

Procedure TFhirPlanDefinitionAction.SetTiming(value : TFhirType);
begin
  FTiming.free;
  FTiming := value;
end;

Function TFhirPlanDefinitionAction.GetParticipantList : TFhirPlanDefinitionActionParticipantList;
begin
  if FParticipantList = nil then
    FParticipantList := TFhirPlanDefinitionActionParticipantList.Create;
  result := FParticipantList;
end;

Function TFhirPlanDefinitionAction.GetHasParticipantList : boolean;
begin
  result := (FParticipantList <> nil) and (FParticipantList.count > 0);
end;

Procedure TFhirPlanDefinitionAction.SetType_(value : TFhirCoding);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirPlanDefinitionAction.SetGroupingBehavior(value : TFhirEnum);
begin
  FGroupingBehavior.free;
  FGroupingBehavior := value;
end;

Function TFhirPlanDefinitionAction.GetGroupingBehaviorST : TFhirActionGroupingBehaviorEnum;
begin
  if FGroupingBehavior = nil then
    result := TFhirActionGroupingBehaviorEnum(0)
  else
    result := TFhirActionGroupingBehaviorEnum(StringArrayIndexOfSensitive(CODES_TFhirActionGroupingBehaviorEnum, FGroupingBehavior.value));
end;

Procedure TFhirPlanDefinitionAction.SetGroupingBehaviorST(value : TFhirActionGroupingBehaviorEnum);
begin
  if ord(value) = 0 then
    GroupingBehaviorElement := nil
  else
    GroupingBehaviorElement := TFhirEnum.create(SYSTEMS_TFhirActionGroupingBehaviorEnum[value], CODES_TFhirActionGroupingBehaviorEnum[value]);
end;

Procedure TFhirPlanDefinitionAction.SetSelectionBehavior(value : TFhirEnum);
begin
  FSelectionBehavior.free;
  FSelectionBehavior := value;
end;

Function TFhirPlanDefinitionAction.GetSelectionBehaviorST : TFhirActionSelectionBehaviorEnum;
begin
  if FSelectionBehavior = nil then
    result := TFhirActionSelectionBehaviorEnum(0)
  else
    result := TFhirActionSelectionBehaviorEnum(StringArrayIndexOfSensitive(CODES_TFhirActionSelectionBehaviorEnum, FSelectionBehavior.value));
end;

Procedure TFhirPlanDefinitionAction.SetSelectionBehaviorST(value : TFhirActionSelectionBehaviorEnum);
begin
  if ord(value) = 0 then
    SelectionBehaviorElement := nil
  else
    SelectionBehaviorElement := TFhirEnum.create(SYSTEMS_TFhirActionSelectionBehaviorEnum[value], CODES_TFhirActionSelectionBehaviorEnum[value]);
end;

Procedure TFhirPlanDefinitionAction.SetRequiredBehavior(value : TFhirEnum);
begin
  FRequiredBehavior.free;
  FRequiredBehavior := value;
end;

Function TFhirPlanDefinitionAction.GetRequiredBehaviorST : TFhirActionRequiredBehaviorEnum;
begin
  if FRequiredBehavior = nil then
    result := TFhirActionRequiredBehaviorEnum(0)
  else
    result := TFhirActionRequiredBehaviorEnum(StringArrayIndexOfSensitive(CODES_TFhirActionRequiredBehaviorEnum, FRequiredBehavior.value));
end;

Procedure TFhirPlanDefinitionAction.SetRequiredBehaviorST(value : TFhirActionRequiredBehaviorEnum);
begin
  if ord(value) = 0 then
    RequiredBehaviorElement := nil
  else
    RequiredBehaviorElement := TFhirEnum.create(SYSTEMS_TFhirActionRequiredBehaviorEnum[value], CODES_TFhirActionRequiredBehaviorEnum[value]);
end;

Procedure TFhirPlanDefinitionAction.SetPrecheckBehavior(value : TFhirEnum);
begin
  FPrecheckBehavior.free;
  FPrecheckBehavior := value;
end;

Function TFhirPlanDefinitionAction.GetPrecheckBehaviorST : TFhirActionPrecheckBehaviorEnum;
begin
  if FPrecheckBehavior = nil then
    result := TFhirActionPrecheckBehaviorEnum(0)
  else
    result := TFhirActionPrecheckBehaviorEnum(StringArrayIndexOfSensitive(CODES_TFhirActionPrecheckBehaviorEnum, FPrecheckBehavior.value));
end;

Procedure TFhirPlanDefinitionAction.SetPrecheckBehaviorST(value : TFhirActionPrecheckBehaviorEnum);
begin
  if ord(value) = 0 then
    PrecheckBehaviorElement := nil
  else
    PrecheckBehaviorElement := TFhirEnum.create(SYSTEMS_TFhirActionPrecheckBehaviorEnum[value], CODES_TFhirActionPrecheckBehaviorEnum[value]);
end;

Procedure TFhirPlanDefinitionAction.SetCardinalityBehavior(value : TFhirEnum);
begin
  FCardinalityBehavior.free;
  FCardinalityBehavior := value;
end;

Function TFhirPlanDefinitionAction.GetCardinalityBehaviorST : TFhirActionCardinalityBehaviorEnum;
begin
  if FCardinalityBehavior = nil then
    result := TFhirActionCardinalityBehaviorEnum(0)
  else
    result := TFhirActionCardinalityBehaviorEnum(StringArrayIndexOfSensitive(CODES_TFhirActionCardinalityBehaviorEnum, FCardinalityBehavior.value));
end;

Procedure TFhirPlanDefinitionAction.SetCardinalityBehaviorST(value : TFhirActionCardinalityBehaviorEnum);
begin
  if ord(value) = 0 then
    CardinalityBehaviorElement := nil
  else
    CardinalityBehaviorElement := TFhirEnum.create(SYSTEMS_TFhirActionCardinalityBehaviorEnum[value], CODES_TFhirActionCardinalityBehaviorEnum[value]);
end;

Procedure TFhirPlanDefinitionAction.SetDefinition(value : TFhirReference{Resource});
begin
  FDefinition.free;
  FDefinition := value;
end;

Procedure TFhirPlanDefinitionAction.SetTransform(value : TFhirReference{TFhirStructureMap});
begin
  FTransform.free;
  FTransform := value;
end;

Function TFhirPlanDefinitionAction.GetDynamicValueList : TFhirPlanDefinitionActionDynamicValueList;
begin
  if FDynamicValueList = nil then
    FDynamicValueList := TFhirPlanDefinitionActionDynamicValueList.Create;
  result := FDynamicValueList;
end;

Function TFhirPlanDefinitionAction.GetHasDynamicValueList : boolean;
begin
  result := (FDynamicValueList <> nil) and (FDynamicValueList.count > 0);
end;

Function TFhirPlanDefinitionAction.GetActionList : TFhirPlanDefinitionActionList;
begin
  if FActionList = nil then
    FActionList := TFhirPlanDefinitionActionList.Create;
  result := FActionList;
end;

Function TFhirPlanDefinitionAction.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

function TFhirPlanDefinitionAction.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FLabel_.sizeInBytes);
  inc(result, FTitle.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FTextEquivalent.sizeInBytes);
  inc(result, FcodeList.sizeInBytes);
  inc(result, FreasonList.sizeInBytes);
  inc(result, FdocumentationList.sizeInBytes);
  inc(result, FgoalIdList.sizeInBytes);
  inc(result, FtriggerDefinitionList.sizeInBytes);
  inc(result, FconditionList.sizeInBytes);
  inc(result, FinputList.sizeInBytes);
  inc(result, FoutputList.sizeInBytes);
  inc(result, FrelatedActionList.sizeInBytes);
  inc(result, FTiming.sizeInBytes);
  inc(result, FparticipantList.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FGroupingBehavior.sizeInBytes);
  inc(result, FSelectionBehavior.sizeInBytes);
  inc(result, FRequiredBehavior.sizeInBytes);
  inc(result, FPrecheckBehavior.sizeInBytes);
  inc(result, FCardinalityBehavior.sizeInBytes);
  inc(result, FDefinition.sizeInBytes);
  inc(result, FTransform.sizeInBytes);
  inc(result, FdynamicValueList.sizeInBytes);
  inc(result, FactionList.sizeInBytes);
end;

{ TFhirPlanDefinitionActionListEnumerator }

Constructor TFhirPlanDefinitionActionListEnumerator.Create(list : TFhirPlanDefinitionActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPlanDefinitionActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPlanDefinitionActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPlanDefinitionActionListEnumerator.GetCurrent : TFhirPlanDefinitionAction;
begin
  Result := FList[FIndex];
end;

function TFhirPlanDefinitionActionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPlanDefinitionActionList }
procedure TFhirPlanDefinitionActionList.AddItem(value: TFhirPlanDefinitionAction);
begin
  assert(value.ClassName = 'TFhirPlanDefinitionAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPlanDefinitionAction');
  add(value);
end;

function TFhirPlanDefinitionActionList.Append: TFhirPlanDefinitionAction;
begin
  result := TFhirPlanDefinitionAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionActionList.ClearItems;
begin
  Clear;
end;

function TFhirPlanDefinitionActionList.GetEnumerator : TFhirPlanDefinitionActionListEnumerator;
begin
  result := TFhirPlanDefinitionActionListEnumerator.Create(self.link);
end;

function TFhirPlanDefinitionActionList.Clone: TFhirPlanDefinitionActionList;
begin
  result := TFhirPlanDefinitionActionList(inherited Clone);
end;

function TFhirPlanDefinitionActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPlanDefinitionActionList.GetItemN(index: Integer): TFhirPlanDefinitionAction;
begin
  result := TFhirPlanDefinitionAction(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirPlanDefinitionAction;
end;
function TFhirPlanDefinitionActionList.IndexOf(value: TFhirPlanDefinitionAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPlanDefinitionActionList.Insert(index: Integer): TFhirPlanDefinitionAction;
begin
  result := TFhirPlanDefinitionAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionActionList.InsertItem(index: Integer; value: TFhirPlanDefinitionAction);
begin
  assert(value is TFhirPlanDefinitionAction);
  Inherited Insert(index, value);
end;

function TFhirPlanDefinitionActionList.Item(index: Integer): TFhirPlanDefinitionAction;
begin
  result := TFhirPlanDefinitionAction(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionActionList.Link: TFhirPlanDefinitionActionList;
begin
  result := TFhirPlanDefinitionActionList(inherited Link);
end;

procedure TFhirPlanDefinitionActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPlanDefinitionActionList.SetItemByIndex(index: Integer; value: TFhirPlanDefinitionAction);
begin
  assert(value is TFhirPlanDefinitionAction);
  FhirPlanDefinitionActions[index] := value;
end;

procedure TFhirPlanDefinitionActionList.SetItemN(index: Integer; value: TFhirPlanDefinitionAction);
begin
  assert(value is TFhirPlanDefinitionAction);
  ObjectByIndex[index] := value;
end;

{ TFhirPlanDefinitionActionCondition }

constructor TFhirPlanDefinitionActionCondition.Create;
begin
  inherited;
end;

destructor TFhirPlanDefinitionActionCondition.Destroy;
begin
  FKind.free;
  FDescription.free;
  FLanguage.free;
  FExpression.free;
  inherited;
end;

procedure TFhirPlanDefinitionActionCondition.Assign(oSource : TFslObject);
begin
  inherited;
  FKind := TFhirPlanDefinitionActionCondition(oSource).FKind.Link;
  descriptionElement := TFhirPlanDefinitionActionCondition(oSource).descriptionElement.Clone;
  languageElement := TFhirPlanDefinitionActionCondition(oSource).languageElement.Clone;
  expressionElement := TFhirPlanDefinitionActionCondition(oSource).expressionElement.Clone;
end;

procedure TFhirPlanDefinitionActionCondition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'kind') Then
     list.add(self.link, 'kind', FKind.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'language') Then
     list.add(self.link, 'language', FLanguage.Link);
  if (child_name = 'expression') Then
     list.add(self.link, 'expression', FExpression.Link);
end;

procedure TFhirPlanDefinitionActionCondition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'kind', 'code', false, TFHIREnum, FKind.Link));{1}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'language', 'string', false, TFhirString, FLanguage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'expression', 'string', false, TFhirString, FExpression.Link));{2}
end;

function TFhirPlanDefinitionActionCondition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'kind') then
  begin
    KindElement := asEnum(SYSTEMS_TFhirActionConditionKindEnum, CODES_TFhirActionConditionKindEnum, propValue);
    result := propValue
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'language') then
  begin
    LanguageElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'expression') then
  begin
    ExpressionElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPlanDefinitionActionCondition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPlanDefinitionActionCondition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'language') then result := TFhirString.create() {5b}
  else if (propName = 'expression') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPlanDefinitionActionCondition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'kind') then result := 'code'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'language') then result := 'string'
  else if (propName = 'expression') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPlanDefinitionActionCondition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'kind') then KindElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'language') then LanguageElement := nil
  else if (propName = 'expression') then ExpressionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPlanDefinitionActionCondition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'kind') then KindElement := asEnum(SYSTEMS_TFhirActionConditionKindEnum, CODES_TFhirActionConditionKindEnum, new){4}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'language') then LanguageElement := asString(new){5b}
  else if (propName = 'expression') then ExpressionElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPlanDefinitionActionCondition.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPlanDefinitionActionCondition.fhirType : string;
begin
  result := 'condition';
end;

function TFhirPlanDefinitionActionCondition.Link : TFhirPlanDefinitionActionCondition;
begin
  result := TFhirPlanDefinitionActionCondition(inherited Link);
end;

function TFhirPlanDefinitionActionCondition.Clone : TFhirPlanDefinitionActionCondition;
begin
  result := TFhirPlanDefinitionActionCondition(inherited Clone);
end;

function TFhirPlanDefinitionActionCondition.equals(other : TObject) : boolean;
var
  o : TFhirPlanDefinitionActionCondition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPlanDefinitionActionCondition)) then
    result := false
  else
  begin
    o := TFhirPlanDefinitionActionCondition(other);
    result := compareDeep(kindElement, o.kindElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and
      compareDeep(languageElement, o.languageElement, true) and compareDeep(expressionElement, o.expressionElement, true);
  end;
end;

function TFhirPlanDefinitionActionCondition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FKind) and isEmptyProp(FDescription) and isEmptyProp(FLanguage) and isEmptyProp(FExpression);
end;

procedure TFhirPlanDefinitionActionCondition.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('kind');
  fields.add('description');
  fields.add('language');
  fields.add('expression');
end;

{ TFhirPlanDefinitionActionCondition }

Procedure TFhirPlanDefinitionActionCondition.SetKind(value : TFhirEnum);
begin
  FKind.free;
  FKind := value;
end;

Function TFhirPlanDefinitionActionCondition.GetKindST : TFhirActionConditionKindEnum;
begin
  if FKind = nil then
    result := TFhirActionConditionKindEnum(0)
  else
    result := TFhirActionConditionKindEnum(StringArrayIndexOfSensitive(CODES_TFhirActionConditionKindEnum, FKind.value));
end;

Procedure TFhirPlanDefinitionActionCondition.SetKindST(value : TFhirActionConditionKindEnum);
begin
  if ord(value) = 0 then
    KindElement := nil
  else
    KindElement := TFhirEnum.create(SYSTEMS_TFhirActionConditionKindEnum[value], CODES_TFhirActionConditionKindEnum[value]);
end;

Procedure TFhirPlanDefinitionActionCondition.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirPlanDefinitionActionCondition.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirPlanDefinitionActionCondition.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirPlanDefinitionActionCondition.SetLanguage(value : TFhirString);
begin
  FLanguage.free;
  FLanguage := value;
end;

Function TFhirPlanDefinitionActionCondition.GetLanguageST : String;
begin
  if FLanguage = nil then
    result := ''
  else
    result := FLanguage.value;
end;

Procedure TFhirPlanDefinitionActionCondition.SetLanguageST(value : String);
begin
  if value <> '' then
  begin
    if FLanguage = nil then
      FLanguage := TFhirString.create;
    FLanguage.value := value
  end
  else if FLanguage <> nil then
    FLanguage.value := '';
end;

Procedure TFhirPlanDefinitionActionCondition.SetExpression(value : TFhirString);
begin
  FExpression.free;
  FExpression := value;
end;

Function TFhirPlanDefinitionActionCondition.GetExpressionST : String;
begin
  if FExpression = nil then
    result := ''
  else
    result := FExpression.value;
end;

Procedure TFhirPlanDefinitionActionCondition.SetExpressionST(value : String);
begin
  if value <> '' then
  begin
    if FExpression = nil then
      FExpression := TFhirString.create;
    FExpression.value := value
  end
  else if FExpression <> nil then
    FExpression.value := '';
end;

function TFhirPlanDefinitionActionCondition.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FKind.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FLanguage.sizeInBytes);
  inc(result, FExpression.sizeInBytes);
end;

{ TFhirPlanDefinitionActionConditionListEnumerator }

Constructor TFhirPlanDefinitionActionConditionListEnumerator.Create(list : TFhirPlanDefinitionActionConditionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPlanDefinitionActionConditionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPlanDefinitionActionConditionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPlanDefinitionActionConditionListEnumerator.GetCurrent : TFhirPlanDefinitionActionCondition;
begin
  Result := FList[FIndex];
end;

function TFhirPlanDefinitionActionConditionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPlanDefinitionActionConditionList }
procedure TFhirPlanDefinitionActionConditionList.AddItem(value: TFhirPlanDefinitionActionCondition);
begin
  assert(value.ClassName = 'TFhirPlanDefinitionActionCondition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPlanDefinitionActionCondition');
  add(value);
end;

function TFhirPlanDefinitionActionConditionList.Append: TFhirPlanDefinitionActionCondition;
begin
  result := TFhirPlanDefinitionActionCondition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionActionConditionList.ClearItems;
begin
  Clear;
end;

function TFhirPlanDefinitionActionConditionList.GetEnumerator : TFhirPlanDefinitionActionConditionListEnumerator;
begin
  result := TFhirPlanDefinitionActionConditionListEnumerator.Create(self.link);
end;

function TFhirPlanDefinitionActionConditionList.Clone: TFhirPlanDefinitionActionConditionList;
begin
  result := TFhirPlanDefinitionActionConditionList(inherited Clone);
end;

function TFhirPlanDefinitionActionConditionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPlanDefinitionActionConditionList.GetItemN(index: Integer): TFhirPlanDefinitionActionCondition;
begin
  result := TFhirPlanDefinitionActionCondition(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionActionConditionList.ItemClass: TFslObjectClass;
begin
  result := TFhirPlanDefinitionActionCondition;
end;
function TFhirPlanDefinitionActionConditionList.IndexOf(value: TFhirPlanDefinitionActionCondition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPlanDefinitionActionConditionList.Insert(index: Integer): TFhirPlanDefinitionActionCondition;
begin
  result := TFhirPlanDefinitionActionCondition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionActionConditionList.InsertItem(index: Integer; value: TFhirPlanDefinitionActionCondition);
begin
  assert(value is TFhirPlanDefinitionActionCondition);
  Inherited Insert(index, value);
end;

function TFhirPlanDefinitionActionConditionList.Item(index: Integer): TFhirPlanDefinitionActionCondition;
begin
  result := TFhirPlanDefinitionActionCondition(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionActionConditionList.Link: TFhirPlanDefinitionActionConditionList;
begin
  result := TFhirPlanDefinitionActionConditionList(inherited Link);
end;

procedure TFhirPlanDefinitionActionConditionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPlanDefinitionActionConditionList.SetItemByIndex(index: Integer; value: TFhirPlanDefinitionActionCondition);
begin
  assert(value is TFhirPlanDefinitionActionCondition);
  FhirPlanDefinitionActionConditions[index] := value;
end;

procedure TFhirPlanDefinitionActionConditionList.SetItemN(index: Integer; value: TFhirPlanDefinitionActionCondition);
begin
  assert(value is TFhirPlanDefinitionActionCondition);
  ObjectByIndex[index] := value;
end;

{ TFhirPlanDefinitionActionRelatedAction }

constructor TFhirPlanDefinitionActionRelatedAction.Create;
begin
  inherited;
end;

destructor TFhirPlanDefinitionActionRelatedAction.Destroy;
begin
  FActionId.free;
  FRelationship.free;
  FOffset.free;
  inherited;
end;

procedure TFhirPlanDefinitionActionRelatedAction.Assign(oSource : TFslObject);
begin
  inherited;
  actionIdElement := TFhirPlanDefinitionActionRelatedAction(oSource).actionIdElement.Clone;
  FRelationship := TFhirPlanDefinitionActionRelatedAction(oSource).FRelationship.Link;
  offset := TFhirPlanDefinitionActionRelatedAction(oSource).offset.Clone;
end;

procedure TFhirPlanDefinitionActionRelatedAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'actionId') Then
     list.add(self.link, 'actionId', FActionId.Link);
  if (child_name = 'relationship') Then
     list.add(self.link, 'relationship', FRelationship.Link);
  if (child_name = 'offset[x]') or (child_name = 'offset') Then
     list.add(self.link, 'offset[x]', FOffset.Link);
end;

procedure TFhirPlanDefinitionActionRelatedAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'actionId', 'id', false, TFhirId, FActionId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'relationship', 'code', false, TFHIREnum, FRelationship.Link));{1}
  oList.add(TFHIRProperty.create(self, 'offset[x]', 'Duration|Range', false, TFhirType, FOffset.Link));{2}
end;

function TFhirPlanDefinitionActionRelatedAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'actionId') then
  begin
    ActionIdElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'relationship') then
  begin
    RelationshipElement := asEnum(SYSTEMS_TFhirActionRelationshipTypeEnum, CODES_TFhirActionRelationshipTypeEnum, propValue);
    result := propValue
  end
  else if (isMatchingName(propName, 'offset', ['Duration', 'Range'])) then
  begin
    Offset := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPlanDefinitionActionRelatedAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPlanDefinitionActionRelatedAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'actionId') then result := TFhirId.create() {5b}
  else if (isMatchingName(propName, 'offset', ['Duration', 'Range'])) then raise EFHIRException.create('Cannot make property Offset'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPlanDefinitionActionRelatedAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'actionId') then result := 'id'
  else if (propName = 'relationship') then result := 'code'
  else if (propName = 'offset[x]') then result := 'Duration|Range'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPlanDefinitionActionRelatedAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'actionId') then ActionIdElement := nil
  else if (propName = 'relationship') then RelationshipElement := nil
  else if (isMatchingName(propName, 'offset', ['Duration', 'Range'])) then OffsetElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPlanDefinitionActionRelatedAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'actionId') then ActionIdElement := asId(new){5b}
  else if (propName = 'relationship') then RelationshipElement := asEnum(SYSTEMS_TFhirActionRelationshipTypeEnum, CODES_TFhirActionRelationshipTypeEnum, new){4}
  else if (isMatchingName(propName, 'offset', ['Duration', 'Range'])) then OffsetElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPlanDefinitionActionRelatedAction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPlanDefinitionActionRelatedAction.fhirType : string;
begin
  result := 'relatedAction';
end;

function TFhirPlanDefinitionActionRelatedAction.Link : TFhirPlanDefinitionActionRelatedAction;
begin
  result := TFhirPlanDefinitionActionRelatedAction(inherited Link);
end;

function TFhirPlanDefinitionActionRelatedAction.Clone : TFhirPlanDefinitionActionRelatedAction;
begin
  result := TFhirPlanDefinitionActionRelatedAction(inherited Clone);
end;

function TFhirPlanDefinitionActionRelatedAction.equals(other : TObject) : boolean;
var
  o : TFhirPlanDefinitionActionRelatedAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPlanDefinitionActionRelatedAction)) then
    result := false
  else
  begin
    o := TFhirPlanDefinitionActionRelatedAction(other);
    result := compareDeep(actionIdElement, o.actionIdElement, true) and compareDeep(relationshipElement, o.relationshipElement, true) and
      compareDeep(offsetElement, o.offsetElement, true);
  end;
end;

function TFhirPlanDefinitionActionRelatedAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FActionId) and isEmptyProp(FRelationship) and isEmptyProp(FOffset);
end;

procedure TFhirPlanDefinitionActionRelatedAction.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('actionId');
  fields.add('relationship');
  fields.add('offset[x]');
end;

{ TFhirPlanDefinitionActionRelatedAction }

Procedure TFhirPlanDefinitionActionRelatedAction.SetActionId(value : TFhirId);
begin
  FActionId.free;
  FActionId := value;
end;

Function TFhirPlanDefinitionActionRelatedAction.GetActionIdST : String;
begin
  if FActionId = nil then
    result := ''
  else
    result := FActionId.value;
end;

Procedure TFhirPlanDefinitionActionRelatedAction.SetActionIdST(value : String);
begin
  if value <> '' then
  begin
    if FActionId = nil then
      FActionId := TFhirId.create;
    FActionId.value := value
  end
  else if FActionId <> nil then
    FActionId.value := '';
end;

Procedure TFhirPlanDefinitionActionRelatedAction.SetRelationship(value : TFhirEnum);
begin
  FRelationship.free;
  FRelationship := value;
end;

Function TFhirPlanDefinitionActionRelatedAction.GetRelationshipST : TFhirActionRelationshipTypeEnum;
begin
  if FRelationship = nil then
    result := TFhirActionRelationshipTypeEnum(0)
  else
    result := TFhirActionRelationshipTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirActionRelationshipTypeEnum, FRelationship.value));
end;

Procedure TFhirPlanDefinitionActionRelatedAction.SetRelationshipST(value : TFhirActionRelationshipTypeEnum);
begin
  if ord(value) = 0 then
    RelationshipElement := nil
  else
    RelationshipElement := TFhirEnum.create(SYSTEMS_TFhirActionRelationshipTypeEnum[value], CODES_TFhirActionRelationshipTypeEnum[value]);
end;

Procedure TFhirPlanDefinitionActionRelatedAction.SetOffset(value : TFhirType);
begin
  FOffset.free;
  FOffset := value;
end;

function TFhirPlanDefinitionActionRelatedAction.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FActionId.sizeInBytes);
  inc(result, FRelationship.sizeInBytes);
  inc(result, FOffset.sizeInBytes);
end;

{ TFhirPlanDefinitionActionRelatedActionListEnumerator }

Constructor TFhirPlanDefinitionActionRelatedActionListEnumerator.Create(list : TFhirPlanDefinitionActionRelatedActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPlanDefinitionActionRelatedActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPlanDefinitionActionRelatedActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPlanDefinitionActionRelatedActionListEnumerator.GetCurrent : TFhirPlanDefinitionActionRelatedAction;
begin
  Result := FList[FIndex];
end;

function TFhirPlanDefinitionActionRelatedActionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPlanDefinitionActionRelatedActionList }
procedure TFhirPlanDefinitionActionRelatedActionList.AddItem(value: TFhirPlanDefinitionActionRelatedAction);
begin
  assert(value.ClassName = 'TFhirPlanDefinitionActionRelatedAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPlanDefinitionActionRelatedAction');
  add(value);
end;

function TFhirPlanDefinitionActionRelatedActionList.Append: TFhirPlanDefinitionActionRelatedAction;
begin
  result := TFhirPlanDefinitionActionRelatedAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionActionRelatedActionList.ClearItems;
begin
  Clear;
end;

function TFhirPlanDefinitionActionRelatedActionList.GetEnumerator : TFhirPlanDefinitionActionRelatedActionListEnumerator;
begin
  result := TFhirPlanDefinitionActionRelatedActionListEnumerator.Create(self.link);
end;

function TFhirPlanDefinitionActionRelatedActionList.Clone: TFhirPlanDefinitionActionRelatedActionList;
begin
  result := TFhirPlanDefinitionActionRelatedActionList(inherited Clone);
end;

function TFhirPlanDefinitionActionRelatedActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPlanDefinitionActionRelatedActionList.GetItemN(index: Integer): TFhirPlanDefinitionActionRelatedAction;
begin
  result := TFhirPlanDefinitionActionRelatedAction(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionActionRelatedActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirPlanDefinitionActionRelatedAction;
end;
function TFhirPlanDefinitionActionRelatedActionList.IndexOf(value: TFhirPlanDefinitionActionRelatedAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPlanDefinitionActionRelatedActionList.Insert(index: Integer): TFhirPlanDefinitionActionRelatedAction;
begin
  result := TFhirPlanDefinitionActionRelatedAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionActionRelatedActionList.InsertItem(index: Integer; value: TFhirPlanDefinitionActionRelatedAction);
begin
  assert(value is TFhirPlanDefinitionActionRelatedAction);
  Inherited Insert(index, value);
end;

function TFhirPlanDefinitionActionRelatedActionList.Item(index: Integer): TFhirPlanDefinitionActionRelatedAction;
begin
  result := TFhirPlanDefinitionActionRelatedAction(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionActionRelatedActionList.Link: TFhirPlanDefinitionActionRelatedActionList;
begin
  result := TFhirPlanDefinitionActionRelatedActionList(inherited Link);
end;

procedure TFhirPlanDefinitionActionRelatedActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPlanDefinitionActionRelatedActionList.SetItemByIndex(index: Integer; value: TFhirPlanDefinitionActionRelatedAction);
begin
  assert(value is TFhirPlanDefinitionActionRelatedAction);
  FhirPlanDefinitionActionRelatedActions[index] := value;
end;

procedure TFhirPlanDefinitionActionRelatedActionList.SetItemN(index: Integer; value: TFhirPlanDefinitionActionRelatedAction);
begin
  assert(value is TFhirPlanDefinitionActionRelatedAction);
  ObjectByIndex[index] := value;
end;

{ TFhirPlanDefinitionActionParticipant }

constructor TFhirPlanDefinitionActionParticipant.Create;
begin
  inherited;
end;

destructor TFhirPlanDefinitionActionParticipant.Destroy;
begin
  FType_.free;
  FRole.free;
  inherited;
end;

procedure TFhirPlanDefinitionActionParticipant.Assign(oSource : TFslObject);
begin
  inherited;
  FType_ := TFhirPlanDefinitionActionParticipant(oSource).FType_.Link;
  role := TFhirPlanDefinitionActionParticipant(oSource).role.Clone;
end;

procedure TFhirPlanDefinitionActionParticipant.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
end;

procedure TFhirPlanDefinitionActionParticipant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));{2}
end;

function TFhirPlanDefinitionActionParticipant.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirActionParticipantTypeEnum, CODES_TFhirActionParticipantTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPlanDefinitionActionParticipant.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPlanDefinitionActionParticipant.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'role') then result := TFhirCodeableConcept.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPlanDefinitionActionParticipant.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'role') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPlanDefinitionActionParticipant.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'role') then RoleElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPlanDefinitionActionParticipant.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirActionParticipantTypeEnum, CODES_TFhirActionParticipantTypeEnum, new){4}
  else if (propName = 'role') then RoleElement := new as TFhirCodeableConcept{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPlanDefinitionActionParticipant.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPlanDefinitionActionParticipant.fhirType : string;
begin
  result := 'participant';
end;

function TFhirPlanDefinitionActionParticipant.Link : TFhirPlanDefinitionActionParticipant;
begin
  result := TFhirPlanDefinitionActionParticipant(inherited Link);
end;

function TFhirPlanDefinitionActionParticipant.Clone : TFhirPlanDefinitionActionParticipant;
begin
  result := TFhirPlanDefinitionActionParticipant(inherited Clone);
end;

function TFhirPlanDefinitionActionParticipant.equals(other : TObject) : boolean;
var
  o : TFhirPlanDefinitionActionParticipant;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPlanDefinitionActionParticipant)) then
    result := false
  else
  begin
    o := TFhirPlanDefinitionActionParticipant(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(roleElement, o.roleElement, true);
  end;
end;

function TFhirPlanDefinitionActionParticipant.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FRole);
end;

procedure TFhirPlanDefinitionActionParticipant.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('role');
end;

{ TFhirPlanDefinitionActionParticipant }

Procedure TFhirPlanDefinitionActionParticipant.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirPlanDefinitionActionParticipant.GetType_ST : TFhirActionParticipantTypeEnum;
begin
  if FType_ = nil then
    result := TFhirActionParticipantTypeEnum(0)
  else
    result := TFhirActionParticipantTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirActionParticipantTypeEnum, FType_.value));
end;

Procedure TFhirPlanDefinitionActionParticipant.SetType_ST(value : TFhirActionParticipantTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirActionParticipantTypeEnum[value], CODES_TFhirActionParticipantTypeEnum[value]);
end;

Procedure TFhirPlanDefinitionActionParticipant.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

function TFhirPlanDefinitionActionParticipant.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FRole.sizeInBytes);
end;

{ TFhirPlanDefinitionActionParticipantListEnumerator }

Constructor TFhirPlanDefinitionActionParticipantListEnumerator.Create(list : TFhirPlanDefinitionActionParticipantList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPlanDefinitionActionParticipantListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPlanDefinitionActionParticipantListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPlanDefinitionActionParticipantListEnumerator.GetCurrent : TFhirPlanDefinitionActionParticipant;
begin
  Result := FList[FIndex];
end;

function TFhirPlanDefinitionActionParticipantListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPlanDefinitionActionParticipantList }
procedure TFhirPlanDefinitionActionParticipantList.AddItem(value: TFhirPlanDefinitionActionParticipant);
begin
  assert(value.ClassName = 'TFhirPlanDefinitionActionParticipant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPlanDefinitionActionParticipant');
  add(value);
end;

function TFhirPlanDefinitionActionParticipantList.Append: TFhirPlanDefinitionActionParticipant;
begin
  result := TFhirPlanDefinitionActionParticipant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionActionParticipantList.ClearItems;
begin
  Clear;
end;

function TFhirPlanDefinitionActionParticipantList.GetEnumerator : TFhirPlanDefinitionActionParticipantListEnumerator;
begin
  result := TFhirPlanDefinitionActionParticipantListEnumerator.Create(self.link);
end;

function TFhirPlanDefinitionActionParticipantList.Clone: TFhirPlanDefinitionActionParticipantList;
begin
  result := TFhirPlanDefinitionActionParticipantList(inherited Clone);
end;

function TFhirPlanDefinitionActionParticipantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPlanDefinitionActionParticipantList.GetItemN(index: Integer): TFhirPlanDefinitionActionParticipant;
begin
  result := TFhirPlanDefinitionActionParticipant(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionActionParticipantList.ItemClass: TFslObjectClass;
begin
  result := TFhirPlanDefinitionActionParticipant;
end;
function TFhirPlanDefinitionActionParticipantList.IndexOf(value: TFhirPlanDefinitionActionParticipant): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPlanDefinitionActionParticipantList.Insert(index: Integer): TFhirPlanDefinitionActionParticipant;
begin
  result := TFhirPlanDefinitionActionParticipant.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionActionParticipantList.InsertItem(index: Integer; value: TFhirPlanDefinitionActionParticipant);
begin
  assert(value is TFhirPlanDefinitionActionParticipant);
  Inherited Insert(index, value);
end;

function TFhirPlanDefinitionActionParticipantList.Item(index: Integer): TFhirPlanDefinitionActionParticipant;
begin
  result := TFhirPlanDefinitionActionParticipant(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionActionParticipantList.Link: TFhirPlanDefinitionActionParticipantList;
begin
  result := TFhirPlanDefinitionActionParticipantList(inherited Link);
end;

procedure TFhirPlanDefinitionActionParticipantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPlanDefinitionActionParticipantList.SetItemByIndex(index: Integer; value: TFhirPlanDefinitionActionParticipant);
begin
  assert(value is TFhirPlanDefinitionActionParticipant);
  FhirPlanDefinitionActionParticipants[index] := value;
end;

procedure TFhirPlanDefinitionActionParticipantList.SetItemN(index: Integer; value: TFhirPlanDefinitionActionParticipant);
begin
  assert(value is TFhirPlanDefinitionActionParticipant);
  ObjectByIndex[index] := value;
end;

{ TFhirPlanDefinitionActionDynamicValue }

constructor TFhirPlanDefinitionActionDynamicValue.Create;
begin
  inherited;
end;

destructor TFhirPlanDefinitionActionDynamicValue.Destroy;
begin
  FDescription.free;
  FPath.free;
  FLanguage.free;
  FExpression.free;
  inherited;
end;

procedure TFhirPlanDefinitionActionDynamicValue.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirPlanDefinitionActionDynamicValue(oSource).descriptionElement.Clone;
  pathElement := TFhirPlanDefinitionActionDynamicValue(oSource).pathElement.Clone;
  languageElement := TFhirPlanDefinitionActionDynamicValue(oSource).languageElement.Clone;
  expressionElement := TFhirPlanDefinitionActionDynamicValue(oSource).expressionElement.Clone;
end;

procedure TFhirPlanDefinitionActionDynamicValue.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'path') Then
     list.add(self.link, 'path', FPath.Link);
  if (child_name = 'language') Then
     list.add(self.link, 'language', FLanguage.Link);
  if (child_name = 'expression') Then
     list.add(self.link, 'expression', FExpression.Link);
end;

procedure TFhirPlanDefinitionActionDynamicValue.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'path', 'string', false, TFhirString, FPath.Link));{2}
  oList.add(TFHIRProperty.create(self, 'language', 'string', false, TFhirString, FLanguage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'expression', 'string', false, TFhirString, FExpression.Link));{2}
end;

function TFhirPlanDefinitionActionDynamicValue.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'path') then
  begin
    PathElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'language') then
  begin
    LanguageElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'expression') then
  begin
    ExpressionElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPlanDefinitionActionDynamicValue.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPlanDefinitionActionDynamicValue.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'path') then result := TFhirString.create() {5b}
  else if (propName = 'language') then result := TFhirString.create() {5b}
  else if (propName = 'expression') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPlanDefinitionActionDynamicValue.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'path') then result := 'string'
  else if (propName = 'language') then result := 'string'
  else if (propName = 'expression') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPlanDefinitionActionDynamicValue.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'path') then PathElement := nil
  else if (propName = 'language') then LanguageElement := nil
  else if (propName = 'expression') then ExpressionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPlanDefinitionActionDynamicValue.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'path') then PathElement := asString(new){5b}
  else if (propName = 'language') then LanguageElement := asString(new){5b}
  else if (propName = 'expression') then ExpressionElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPlanDefinitionActionDynamicValue.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPlanDefinitionActionDynamicValue.fhirType : string;
begin
  result := 'dynamicValue';
end;

function TFhirPlanDefinitionActionDynamicValue.Link : TFhirPlanDefinitionActionDynamicValue;
begin
  result := TFhirPlanDefinitionActionDynamicValue(inherited Link);
end;

function TFhirPlanDefinitionActionDynamicValue.Clone : TFhirPlanDefinitionActionDynamicValue;
begin
  result := TFhirPlanDefinitionActionDynamicValue(inherited Clone);
end;

function TFhirPlanDefinitionActionDynamicValue.equals(other : TObject) : boolean;
var
  o : TFhirPlanDefinitionActionDynamicValue;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPlanDefinitionActionDynamicValue)) then
    result := false
  else
  begin
    o := TFhirPlanDefinitionActionDynamicValue(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(pathElement, o.pathElement, true) and
      compareDeep(languageElement, o.languageElement, true) and compareDeep(expressionElement, o.expressionElement, true);
  end;
end;

function TFhirPlanDefinitionActionDynamicValue.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FPath) and isEmptyProp(FLanguage) and isEmptyProp(FExpression);
end;

procedure TFhirPlanDefinitionActionDynamicValue.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('description');
  fields.add('path');
  fields.add('language');
  fields.add('expression');
end;

{ TFhirPlanDefinitionActionDynamicValue }

Procedure TFhirPlanDefinitionActionDynamicValue.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirPlanDefinitionActionDynamicValue.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirPlanDefinitionActionDynamicValue.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirPlanDefinitionActionDynamicValue.SetPath(value : TFhirString);
begin
  FPath.free;
  FPath := value;
end;

Function TFhirPlanDefinitionActionDynamicValue.GetPathST : String;
begin
  if FPath = nil then
    result := ''
  else
    result := FPath.value;
end;

Procedure TFhirPlanDefinitionActionDynamicValue.SetPathST(value : String);
begin
  if value <> '' then
  begin
    if FPath = nil then
      FPath := TFhirString.create;
    FPath.value := value
  end
  else if FPath <> nil then
    FPath.value := '';
end;

Procedure TFhirPlanDefinitionActionDynamicValue.SetLanguage(value : TFhirString);
begin
  FLanguage.free;
  FLanguage := value;
end;

Function TFhirPlanDefinitionActionDynamicValue.GetLanguageST : String;
begin
  if FLanguage = nil then
    result := ''
  else
    result := FLanguage.value;
end;

Procedure TFhirPlanDefinitionActionDynamicValue.SetLanguageST(value : String);
begin
  if value <> '' then
  begin
    if FLanguage = nil then
      FLanguage := TFhirString.create;
    FLanguage.value := value
  end
  else if FLanguage <> nil then
    FLanguage.value := '';
end;

Procedure TFhirPlanDefinitionActionDynamicValue.SetExpression(value : TFhirString);
begin
  FExpression.free;
  FExpression := value;
end;

Function TFhirPlanDefinitionActionDynamicValue.GetExpressionST : String;
begin
  if FExpression = nil then
    result := ''
  else
    result := FExpression.value;
end;

Procedure TFhirPlanDefinitionActionDynamicValue.SetExpressionST(value : String);
begin
  if value <> '' then
  begin
    if FExpression = nil then
      FExpression := TFhirString.create;
    FExpression.value := value
  end
  else if FExpression <> nil then
    FExpression.value := '';
end;

function TFhirPlanDefinitionActionDynamicValue.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDescription.sizeInBytes);
  inc(result, FPath.sizeInBytes);
  inc(result, FLanguage.sizeInBytes);
  inc(result, FExpression.sizeInBytes);
end;

{ TFhirPlanDefinitionActionDynamicValueListEnumerator }

Constructor TFhirPlanDefinitionActionDynamicValueListEnumerator.Create(list : TFhirPlanDefinitionActionDynamicValueList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPlanDefinitionActionDynamicValueListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPlanDefinitionActionDynamicValueListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPlanDefinitionActionDynamicValueListEnumerator.GetCurrent : TFhirPlanDefinitionActionDynamicValue;
begin
  Result := FList[FIndex];
end;

function TFhirPlanDefinitionActionDynamicValueListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPlanDefinitionActionDynamicValueList }
procedure TFhirPlanDefinitionActionDynamicValueList.AddItem(value: TFhirPlanDefinitionActionDynamicValue);
begin
  assert(value.ClassName = 'TFhirPlanDefinitionActionDynamicValue', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPlanDefinitionActionDynamicValue');
  add(value);
end;

function TFhirPlanDefinitionActionDynamicValueList.Append: TFhirPlanDefinitionActionDynamicValue;
begin
  result := TFhirPlanDefinitionActionDynamicValue.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionActionDynamicValueList.ClearItems;
begin
  Clear;
end;

function TFhirPlanDefinitionActionDynamicValueList.GetEnumerator : TFhirPlanDefinitionActionDynamicValueListEnumerator;
begin
  result := TFhirPlanDefinitionActionDynamicValueListEnumerator.Create(self.link);
end;

function TFhirPlanDefinitionActionDynamicValueList.Clone: TFhirPlanDefinitionActionDynamicValueList;
begin
  result := TFhirPlanDefinitionActionDynamicValueList(inherited Clone);
end;

function TFhirPlanDefinitionActionDynamicValueList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPlanDefinitionActionDynamicValueList.GetItemN(index: Integer): TFhirPlanDefinitionActionDynamicValue;
begin
  result := TFhirPlanDefinitionActionDynamicValue(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionActionDynamicValueList.ItemClass: TFslObjectClass;
begin
  result := TFhirPlanDefinitionActionDynamicValue;
end;
function TFhirPlanDefinitionActionDynamicValueList.IndexOf(value: TFhirPlanDefinitionActionDynamicValue): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPlanDefinitionActionDynamicValueList.Insert(index: Integer): TFhirPlanDefinitionActionDynamicValue;
begin
  result := TFhirPlanDefinitionActionDynamicValue.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionActionDynamicValueList.InsertItem(index: Integer; value: TFhirPlanDefinitionActionDynamicValue);
begin
  assert(value is TFhirPlanDefinitionActionDynamicValue);
  Inherited Insert(index, value);
end;

function TFhirPlanDefinitionActionDynamicValueList.Item(index: Integer): TFhirPlanDefinitionActionDynamicValue;
begin
  result := TFhirPlanDefinitionActionDynamicValue(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionActionDynamicValueList.Link: TFhirPlanDefinitionActionDynamicValueList;
begin
  result := TFhirPlanDefinitionActionDynamicValueList(inherited Link);
end;

procedure TFhirPlanDefinitionActionDynamicValueList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPlanDefinitionActionDynamicValueList.SetItemByIndex(index: Integer; value: TFhirPlanDefinitionActionDynamicValue);
begin
  assert(value is TFhirPlanDefinitionActionDynamicValue);
  FhirPlanDefinitionActionDynamicValues[index] := value;
end;

procedure TFhirPlanDefinitionActionDynamicValueList.SetItemN(index: Integer; value: TFhirPlanDefinitionActionDynamicValue);
begin
  assert(value is TFhirPlanDefinitionActionDynamicValue);
  ObjectByIndex[index] := value;
end;

{ TFhirPlanDefinition }

constructor TFhirPlanDefinition.Create;
begin
  inherited;
end;

destructor TFhirPlanDefinition.Destroy;
begin
  FIdentifierList.Free;
  FType_.free;
  FPurpose.free;
  FUsage.free;
  FApprovalDate.free;
  FLastReviewDate.free;
  FEffectivePeriod.free;
  FTopicList.Free;
  FContributorList.Free;
  FCopyright.free;
  FRelatedArtifactList.Free;
  FLibrary_List.Free;
  FGoalList.Free;
  FActionList.Free;
  inherited;
end;

function TFhirPlanDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtPlanDefinition;
end;

procedure TFhirPlanDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPlanDefinition(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirPlanDefinition(oSource).FIdentifierList);
  end;
  type_ := TFhirPlanDefinition(oSource).type_.Clone;
  purposeElement := TFhirPlanDefinition(oSource).purposeElement.Clone;
  usageElement := TFhirPlanDefinition(oSource).usageElement.Clone;
  approvalDateElement := TFhirPlanDefinition(oSource).approvalDateElement.Clone;
  lastReviewDateElement := TFhirPlanDefinition(oSource).lastReviewDateElement.Clone;
  effectivePeriod := TFhirPlanDefinition(oSource).effectivePeriod.Clone;
  if (TFhirPlanDefinition(oSource).FTopicList = nil) then
  begin
    FTopicList.free;
    FTopicList := nil;
  end
  else
  begin
    if FTopicList = nil then
      FTopicList := TFhirCodeableConceptList.Create;
    FTopicList.Assign(TFhirPlanDefinition(oSource).FTopicList);
  end;
  if (TFhirPlanDefinition(oSource).FContributorList = nil) then
  begin
    FContributorList.free;
    FContributorList := nil;
  end
  else
  begin
    if FContributorList = nil then
      FContributorList := TFhirContributorList.Create;
    FContributorList.Assign(TFhirPlanDefinition(oSource).FContributorList);
  end;
  copyrightElement := TFhirPlanDefinition(oSource).copyrightElement.Clone;
  if (TFhirPlanDefinition(oSource).FRelatedArtifactList = nil) then
  begin
    FRelatedArtifactList.free;
    FRelatedArtifactList := nil;
  end
  else
  begin
    if FRelatedArtifactList = nil then
      FRelatedArtifactList := TFhirRelatedArtifactList.Create;
    FRelatedArtifactList.Assign(TFhirPlanDefinition(oSource).FRelatedArtifactList);
  end;
  if (TFhirPlanDefinition(oSource).FLibrary_List = nil) then
  begin
    FLibrary_List.free;
    FLibrary_List := nil;
  end
  else
  begin
    if FLibrary_List = nil then
      FLibrary_List := TFhirReferenceList{TFhirLibrary}.Create;
    FLibrary_List.Assign(TFhirPlanDefinition(oSource).FLibrary_List);
  end;
  if (TFhirPlanDefinition(oSource).FGoalList = nil) then
  begin
    FGoalList.free;
    FGoalList := nil;
  end
  else
  begin
    if FGoalList = nil then
      FGoalList := TFhirPlanDefinitionGoalList.Create;
    FGoalList.Assign(TFhirPlanDefinition(oSource).FGoalList);
  end;
  if (TFhirPlanDefinition(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirPlanDefinitionActionList.Create;
    FActionList.Assign(TFhirPlanDefinition(oSource).FActionList);
  end;
end;

procedure TFhirPlanDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'usage') Then
     list.add(self.link, 'usage', FUsage.Link);
  if (child_name = 'approvalDate') Then
     list.add(self.link, 'approvalDate', FApprovalDate.Link);
  if (child_name = 'lastReviewDate') Then
     list.add(self.link, 'lastReviewDate', FLastReviewDate.Link);
  if (child_name = 'effectivePeriod') Then
     list.add(self.link, 'effectivePeriod', FEffectivePeriod.Link);
  if (child_name = 'topic') Then
    list.addAll(self, 'topic', FTopicList);
  if (child_name = 'contributor') Then
    list.addAll(self, 'contributor', FContributorList);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'relatedArtifact') Then
    list.addAll(self, 'relatedArtifact', FRelatedArtifactList);
  if (child_name = 'library') Then
    list.addAll(self, 'library', FLibrary_List);
  if (child_name = 'goal') Then
    list.addAll(self, 'goal', FGoalList);
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
end;

procedure TFhirPlanDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));{2}
  oList.add(TFHIRProperty.create(self, 'usage', 'string', false, TFhirString, FUsage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'approvalDate', 'date', false, TFhirDate, FApprovalDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'lastReviewDate', 'date', false, TFhirDate, FLastReviewDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'effectivePeriod', 'Period', false, TFhirPeriod, FEffectivePeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'topic', 'CodeableConcept', true, TFhirCodeableConcept, FTopicList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'contributor', 'Contributor', true, TFhirContributor, FContributorList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));{2}
  oList.add(TFHIRProperty.create(self, 'relatedArtifact', 'RelatedArtifact', true, TFhirRelatedArtifact, FRelatedArtifactList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'library', 'Reference(Library)', true, TFhirReference{TFhirLibrary}, FLibrary_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'goal', '', true, TFhirPlanDefinitionGoal, FGoalList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'action', '', true, TFhirPlanDefinitionAction, FActionList.Link)){3};
end;

function TFhirPlanDefinition.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept{4b};
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'usage') then
  begin
    UsageElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'approvalDate') then
  begin
    ApprovalDateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'lastReviewDate') then
  begin
    LastReviewDateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'effectivePeriod') then
  begin
    EffectivePeriod := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'topic') then
  begin
    TopicList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'contributor') then
  begin
    ContributorList.add(propValue as TFhirContributor){2a};
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'relatedArtifact') then
  begin
    RelatedArtifactList.add(propValue as TFhirRelatedArtifact){2a};
    result := propValue;
  end
  else if (propName = 'library') then
  begin
    Library_List.add(propValue as TFhirReference{TFhirLibrary}){2a};
    result := propValue;
  end
  else if (propName = 'goal') then
  begin
    GoalList.add(propValue as TFhirPlanDefinitionGoal){2a};
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirPlanDefinitionAction){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirPlanDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'topic') then TopicList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'contributor') then ContributorList.insertItem(index, propValue as TFhirContributor){2a}
  else if (propName = 'relatedArtifact') then RelatedArtifactList.insertItem(index, propValue as TFhirRelatedArtifact){2a}
  else if (propName = 'library') then Library_List.insertItem(index, propValue as TFhirReference{TFhirLibrary}){2a}
  else if (propName = 'goal') then GoalList.insertItem(index, propValue as TFhirPlanDefinitionGoal){2a}
  else if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirPlanDefinitionAction){2a}
  else inherited;
end;

function TFhirPlanDefinition.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'type') then result := TFhirCodeableConcept.create(){4b}
  else if (propName = 'purpose') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'usage') then result := TFhirString.create() {5b}
  else if (propName = 'approvalDate') then result := TFhirDate.create() {5b}
  else if (propName = 'lastReviewDate') then result := TFhirDate.create() {5b}
  else if (propName = 'effectivePeriod') then result := TFhirPeriod.create(){4b}
  else if (propName = 'topic') then result := TopicList.new(){2}
  else if (propName = 'contributor') then result := ContributorList.new(){2}
  else if (propName = 'copyright') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'relatedArtifact') then result := RelatedArtifactList.new(){2}
  else if (propName = 'library') then result := Library_List.new(){2}
  else if (propName = 'goal') then result := GoalList.new(){2}
  else if (propName = 'action') then result := ActionList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirPlanDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'usage') then result := 'string'
  else if (propName = 'approvalDate') then result := 'date'
  else if (propName = 'lastReviewDate') then result := 'date'
  else if (propName = 'effectivePeriod') then result := 'Period'
  else if (propName = 'topic') then result := 'CodeableConcept'
  else if (propName = 'contributor') then result := 'Contributor'
  else if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'relatedArtifact') then result := 'RelatedArtifact'
  else if (propName = 'library') then result := 'Reference'
  else if (propName = 'goal') then result := ''
  else if (propName = 'action') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPlanDefinition.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'usage') then UsageElement := nil
  else if (propName = 'approvalDate') then ApprovalDateElement := nil
  else if (propName = 'lastReviewDate') then LastReviewDateElement := nil
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := nil
  else if (propName = 'topic') then deletePropertyValue('topic', TopicList, value) {2}
  else if (propName = 'contributor') then deletePropertyValue('contributor', ContributorList, value) {2}
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'relatedArtifact') then deletePropertyValue('relatedArtifact', RelatedArtifactList, value) {2}
  else if (propName = 'library') then deletePropertyValue('library', Library_List, value) {2}
  else if (propName = 'goal') then deletePropertyValue('goal', GoalList, value) {2}
  else if (propName = 'action') then deletePropertyValue('action', ActionList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPlanDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept{4}
  else if (propName = 'purpose') then PurposeElement := asMarkdown(new){5b}
  else if (propName = 'usage') then UsageElement := asString(new){5b}
  else if (propName = 'approvalDate') then ApprovalDateElement := asDate(new){5b}
  else if (propName = 'lastReviewDate') then LastReviewDateElement := asDate(new){5b}
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := new as TFhirPeriod{4}
  else if (propName = 'topic') then replacePropertyValue('topic', TopicList, existing, new) {2}
  else if (propName = 'contributor') then replacePropertyValue('contributor', ContributorList, existing, new) {2}
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new){5b}
  else if (propName = 'relatedArtifact') then replacePropertyValue('relatedArtifact', RelatedArtifactList, existing, new) {2}
  else if (propName = 'library') then replacePropertyValue('library', Library_List, existing, new) {2}
  else if (propName = 'goal') then replacePropertyValue('goal', GoalList, existing, new) {2}
  else if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPlanDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'topic') then TopicList.move(source, destination){2a}
  else if (propName = 'contributor') then ContributorList.move(source, destination){2a}
  else if (propName = 'relatedArtifact') then RelatedArtifactList.move(source, destination){2a}
  else if (propName = 'library') then Library_List.move(source, destination){2a}
  else if (propName = 'goal') then GoalList.move(source, destination){2a}
  else if (propName = 'action') then ActionList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPlanDefinition.fhirType : string;
begin
  result := 'PlanDefinition';
end;

function TFhirPlanDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FType_) and isEmptyProp(FPurpose) and isEmptyProp(FUsage) and isEmptyProp(FApprovalDate) and isEmptyProp(FLastReviewDate) and isEmptyProp(FEffectivePeriod) and isEmptyProp(FtopicList) and isEmptyProp(FcontributorList) and isEmptyProp(FCopyright) and isEmptyProp(FrelatedArtifactList) and isEmptyProp(Flibrary_List) and isEmptyProp(FgoalList) and isEmptyProp(FactionList);
end;

function TFhirPlanDefinition.equals(other : TObject) : boolean;
var
  o : TFhirPlanDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPlanDefinition)) then
    result := false
  else
  begin
    o := TFhirPlanDefinition(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(type_Element, o.type_Element, true) and
      compareDeep(purposeElement, o.purposeElement, true) and compareDeep(usageElement, o.usageElement, true) and
      compareDeep(approvalDateElement, o.approvalDateElement, true) and compareDeep(lastReviewDateElement, o.lastReviewDateElement, true) and
      compareDeep(effectivePeriodElement, o.effectivePeriodElement, true) and compareDeep(topicList, o.topicList, true) and
      compareDeep(contributorList, o.contributorList, true) and compareDeep(copyrightElement, o.copyrightElement, true) and
      compareDeep(relatedArtifactList, o.relatedArtifactList, true) and compareDeep(library_List, o.library_List, true) and
      compareDeep(goalList, o.goalList, true) and compareDeep(actionList, o.actionList, true);
  end;
end;

function TFhirPlanDefinition.Link : TFhirPlanDefinition;
begin
  result := TFhirPlanDefinition(inherited Link);
end;

function TFhirPlanDefinition.Clone : TFhirPlanDefinition;
begin
  result := TFhirPlanDefinition(inherited Clone);
end;

procedure TFhirPlanDefinition.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('type');
  fields.add('status');
  fields.add('experimental');
  fields.add('date');
  fields.add('publisher');
  fields.add('description');
  fields.add('purpose');
  fields.add('usage');
  fields.add('approvalDate');
  fields.add('lastReviewDate');
  fields.add('effectivePeriod');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('topic');
  fields.add('contributor');
  fields.add('contact');
  fields.add('copyright');
  fields.add('relatedArtifact');
  fields.add('library');
  fields.add('goal');
  fields.add('action');
end;

{ TFhirPlanDefinition }

Function TFhirPlanDefinition.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirPlanDefinition.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirPlanDefinition.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirPlanDefinition.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

Function TFhirPlanDefinition.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

Procedure TFhirPlanDefinition.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

Procedure TFhirPlanDefinition.SetUsage(value : TFhirString);
begin
  FUsage.free;
  FUsage := value;
end;

Function TFhirPlanDefinition.GetUsageST : String;
begin
  if FUsage = nil then
    result := ''
  else
    result := FUsage.value;
end;

Procedure TFhirPlanDefinition.SetUsageST(value : String);
begin
  if value <> '' then
  begin
    if FUsage = nil then
      FUsage := TFhirString.create;
    FUsage.value := value
  end
  else if FUsage <> nil then
    FUsage.value := '';
end;

Procedure TFhirPlanDefinition.SetApprovalDate(value : TFhirDate);
begin
  FApprovalDate.free;
  FApprovalDate := value;
end;

Function TFhirPlanDefinition.GetApprovalDateST : TFslDateTime;
begin
  if FApprovalDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FApprovalDate.value;
end;

Procedure TFhirPlanDefinition.SetApprovalDateST(value : TFslDateTime);
begin
  if FApprovalDate = nil then
    FApprovalDate := TFhirDate.create;
  FApprovalDate.value := value
end;

Procedure TFhirPlanDefinition.SetLastReviewDate(value : TFhirDate);
begin
  FLastReviewDate.free;
  FLastReviewDate := value;
end;

Function TFhirPlanDefinition.GetLastReviewDateST : TFslDateTime;
begin
  if FLastReviewDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastReviewDate.value;
end;

Procedure TFhirPlanDefinition.SetLastReviewDateST(value : TFslDateTime);
begin
  if FLastReviewDate = nil then
    FLastReviewDate := TFhirDate.create;
  FLastReviewDate.value := value
end;

Procedure TFhirPlanDefinition.SetEffectivePeriod(value : TFhirPeriod);
begin
  FEffectivePeriod.free;
  FEffectivePeriod := value;
end;

Function TFhirPlanDefinition.GetTopicList : TFhirCodeableConceptList;
begin
  if FTopicList = nil then
    FTopicList := TFhirCodeableConceptList.Create;
  result := FTopicList;
end;

Function TFhirPlanDefinition.GetHasTopicList : boolean;
begin
  result := (FTopicList <> nil) and (FTopicList.count > 0);
end;

Function TFhirPlanDefinition.GetContributorList : TFhirContributorList;
begin
  if FContributorList = nil then
    FContributorList := TFhirContributorList.Create;
  result := FContributorList;
end;

Function TFhirPlanDefinition.GetHasContributorList : boolean;
begin
  result := (FContributorList <> nil) and (FContributorList.count > 0);
end;

Procedure TFhirPlanDefinition.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

Function TFhirPlanDefinition.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

Procedure TFhirPlanDefinition.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

Function TFhirPlanDefinition.GetRelatedArtifactList : TFhirRelatedArtifactList;
begin
  if FRelatedArtifactList = nil then
    FRelatedArtifactList := TFhirRelatedArtifactList.Create;
  result := FRelatedArtifactList;
end;

Function TFhirPlanDefinition.GetHasRelatedArtifactList : boolean;
begin
  result := (FRelatedArtifactList <> nil) and (FRelatedArtifactList.count > 0);
end;

Function TFhirPlanDefinition.GetLibrary_List : TFhirReferenceList{TFhirLibrary};
begin
  if FLibrary_List = nil then
    FLibrary_List := TFhirReferenceList{TFhirLibrary}.Create;
  result := FLibrary_List;
end;

Function TFhirPlanDefinition.GetHasLibrary_List : boolean;
begin
  result := (FLibrary_List <> nil) and (FLibrary_List.count > 0);
end;

Function TFhirPlanDefinition.GetGoalList : TFhirPlanDefinitionGoalList;
begin
  if FGoalList = nil then
    FGoalList := TFhirPlanDefinitionGoalList.Create;
  result := FGoalList;
end;

Function TFhirPlanDefinition.GetHasGoalList : boolean;
begin
  result := (FGoalList <> nil) and (FGoalList.count > 0);
end;

Function TFhirPlanDefinition.GetActionList : TFhirPlanDefinitionActionList;
begin
  if FActionList = nil then
    FActionList := TFhirPlanDefinitionActionList.Create;
  result := FActionList;
end;

Function TFhirPlanDefinition.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

function TFhirPlanDefinition.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FPurpose.sizeInBytes);
  inc(result, FUsage.sizeInBytes);
  inc(result, FApprovalDate.sizeInBytes);
  inc(result, FLastReviewDate.sizeInBytes);
  inc(result, FEffectivePeriod.sizeInBytes);
  inc(result, FtopicList.sizeInBytes);
  inc(result, FcontributorList.sizeInBytes);
  inc(result, FCopyright.sizeInBytes);
  inc(result, FrelatedArtifactList.sizeInBytes);
  inc(result, Flibrary_List.sizeInBytes);
  inc(result, FgoalList.sizeInBytes);
  inc(result, FactionList.sizeInBytes);
end;

{ TFhirPlanDefinitionListEnumerator }

Constructor TFhirPlanDefinitionListEnumerator.Create(list : TFhirPlanDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPlanDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPlanDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPlanDefinitionListEnumerator.GetCurrent : TFhirPlanDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirPlanDefinitionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirPlanDefinitionList }
procedure TFhirPlanDefinitionList.AddItem(value: TFhirPlanDefinition);
begin
  assert(value.ClassName = 'TFhirPlanDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPlanDefinition');
  add(value);
end;

function TFhirPlanDefinitionList.Append: TFhirPlanDefinition;
begin
  result := TFhirPlanDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirPlanDefinitionList.GetEnumerator : TFhirPlanDefinitionListEnumerator;
begin
  result := TFhirPlanDefinitionListEnumerator.Create(self.link);
end;

function TFhirPlanDefinitionList.Clone: TFhirPlanDefinitionList;
begin
  result := TFhirPlanDefinitionList(inherited Clone);
end;

function TFhirPlanDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPlanDefinitionList.GetItemN(index: Integer): TFhirPlanDefinition;
begin
  result := TFhirPlanDefinition(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirPlanDefinition;
end;
function TFhirPlanDefinitionList.IndexOf(value: TFhirPlanDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPlanDefinitionList.Insert(index: Integer): TFhirPlanDefinition;
begin
  result := TFhirPlanDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionList.InsertItem(index: Integer; value: TFhirPlanDefinition);
begin
  assert(value is TFhirPlanDefinition);
  Inherited Insert(index, value);
end;

function TFhirPlanDefinitionList.Item(index: Integer): TFhirPlanDefinition;
begin
  result := TFhirPlanDefinition(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionList.Link: TFhirPlanDefinitionList;
begin
  result := TFhirPlanDefinitionList(inherited Link);
end;

procedure TFhirPlanDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPlanDefinitionList.SetItemByIndex(index: Integer; value: TFhirPlanDefinition);
begin
  assert(value is TFhirPlanDefinition);
  FhirPlanDefinitions[index] := value;
end;

procedure TFhirPlanDefinitionList.SetItemN(index: Integer; value: TFhirPlanDefinition);
begin
  assert(value is TFhirPlanDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PLANDEFINITION}

{$IFDEF FHIR_QUESTIONNAIRE}

{ TFhirQuestionnaireItem }

constructor TFhirQuestionnaireItem.Create;
begin
  inherited;
end;

destructor TFhirQuestionnaireItem.Destroy;
begin
  FLinkId.free;
  FDefinition.free;
  FCodeList.Free;
  FPrefix.free;
  FText.free;
  FType_.free;
  FEnableWhenList.Free;
  FRequired.free;
  FRepeats.free;
  FReadOnly.free;
  FMaxLength.free;
  FOptions.free;
  FOptionList.Free;
  FInitial.free;
  FItemList.Free;
  inherited;
end;

procedure TFhirQuestionnaireItem.Assign(oSource : TFslObject);
begin
  inherited;
  linkIdElement := TFhirQuestionnaireItem(oSource).linkIdElement.Clone;
  definitionElement := TFhirQuestionnaireItem(oSource).definitionElement.Clone;
  if (TFhirQuestionnaireItem(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirCodingList.Create;
    FCodeList.Assign(TFhirQuestionnaireItem(oSource).FCodeList);
  end;
  prefixElement := TFhirQuestionnaireItem(oSource).prefixElement.Clone;
  textElement := TFhirQuestionnaireItem(oSource).textElement.Clone;
  FType_ := TFhirQuestionnaireItem(oSource).FType_.Link;
  if (TFhirQuestionnaireItem(oSource).FEnableWhenList = nil) then
  begin
    FEnableWhenList.free;
    FEnableWhenList := nil;
  end
  else
  begin
    if FEnableWhenList = nil then
      FEnableWhenList := TFhirQuestionnaireItemEnableWhenList.Create;
    FEnableWhenList.Assign(TFhirQuestionnaireItem(oSource).FEnableWhenList);
  end;
  requiredElement := TFhirQuestionnaireItem(oSource).requiredElement.Clone;
  repeatsElement := TFhirQuestionnaireItem(oSource).repeatsElement.Clone;
  readOnlyElement := TFhirQuestionnaireItem(oSource).readOnlyElement.Clone;
  maxLengthElement := TFhirQuestionnaireItem(oSource).maxLengthElement.Clone;
  options := TFhirQuestionnaireItem(oSource).options.Clone;
  if (TFhirQuestionnaireItem(oSource).FOptionList = nil) then
  begin
    FOptionList.free;
    FOptionList := nil;
  end
  else
  begin
    if FOptionList = nil then
      FOptionList := TFhirQuestionnaireItemOptionList.Create;
    FOptionList.Assign(TFhirQuestionnaireItem(oSource).FOptionList);
  end;
  initial := TFhirQuestionnaireItem(oSource).initial.Clone;
  if (TFhirQuestionnaireItem(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirQuestionnaireItemList.Create;
    FItemList.Assign(TFhirQuestionnaireItem(oSource).FItemList);
  end;
end;

procedure TFhirQuestionnaireItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'linkId') Then
     list.add(self.link, 'linkId', FLinkId.Link);
  if (child_name = 'definition') Then
     list.add(self.link, 'definition', FDefinition.Link);
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'prefix') Then
     list.add(self.link, 'prefix', FPrefix.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'enableWhen') Then
    list.addAll(self, 'enableWhen', FEnableWhenList);
  if (child_name = 'required') Then
     list.add(self.link, 'required', FRequired.Link);
  if (child_name = 'repeats') Then
     list.add(self.link, 'repeats', FRepeats.Link);
  if (child_name = 'readOnly') Then
     list.add(self.link, 'readOnly', FReadOnly.Link);
  if (child_name = 'maxLength') Then
     list.add(self.link, 'maxLength', FMaxLength.Link);
  if (child_name = 'options') Then
     list.add(self.link, 'options', FOptions.Link);
  if (child_name = 'option') Then
    list.addAll(self, 'option', FOptionList);
  if (child_name = 'initial[x]') or (child_name = 'initial') Then
     list.add(self.link, 'initial[x]', FInitial.Link);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
end;

procedure TFhirQuestionnaireItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'linkId', 'string', false, TFhirString, FLinkId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'definition', 'uri', false, TFhirUri, FDefinition.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'Coding', true, TFhirCoding, FCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'prefix', 'string', false, TFhirString, FPrefix.Link));{2}
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'enableWhen', '', true, TFhirQuestionnaireItemEnableWhen, FEnableWhenList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'required', 'boolean', false, TFhirBoolean, FRequired.Link));{2}
  oList.add(TFHIRProperty.create(self, 'repeats', 'boolean', false, TFhirBoolean, FRepeats.Link));{2}
  oList.add(TFHIRProperty.create(self, 'readOnly', 'boolean', false, TFhirBoolean, FReadOnly.Link));{2}
  oList.add(TFHIRProperty.create(self, 'maxLength', 'integer', false, TFhirInteger, FMaxLength.Link));{2}
  oList.add(TFHIRProperty.create(self, 'options', 'Reference(ValueSet)', false, TFhirReference{TFhirValueSet}, FOptions.Link));{2}
  oList.add(TFHIRProperty.create(self, 'option', '', true, TFhirQuestionnaireItemOption, FOptionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'initial[x]', 'boolean|decimal|integer|date|dateTime|time|string|uri|Attachment|Coding|Quantity|Reference(Any)', false, TFhirType, FInitial.Link));{2}
  oList.add(TFHIRProperty.create(self, 'item', '@Questionnaire.item', true, TFhirQuestionnaireItem, FItemList.Link)){3};
end;

function TFhirQuestionnaireItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'linkId') then
  begin
    LinkIdElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'definition') then
  begin
    DefinitionElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else if (propName = 'prefix') then
  begin
    PrefixElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirItemTypeEnum, CODES_TFhirItemTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'enableWhen') then
  begin
    EnableWhenList.add(propValue as TFhirQuestionnaireItemEnableWhen){2a};
    result := propValue;
  end
  else if (propName = 'required') then
  begin
    RequiredElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'repeats') then
  begin
    RepeatsElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'readOnly') then
  begin
    ReadOnlyElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'maxLength') then
  begin
    MaxLengthElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'options') then
  begin
    Options := propValue as TFhirReference{TFhirValueSet}{4b};
    result := propValue;
  end
  else if (propName = 'option') then
  begin
    OptionList.add(propValue as TFhirQuestionnaireItemOption){2a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'initial', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Time', 'String', 'Uri', 'Attachment', 'Coding', 'Quantity', 'Reference'])) then
  begin
    Initial := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirQuestionnaireItem){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirQuestionnaireItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirCoding){2a}
  else if (propName = 'enableWhen') then EnableWhenList.insertItem(index, propValue as TFhirQuestionnaireItemEnableWhen){2a}
  else if (propName = 'option') then OptionList.insertItem(index, propValue as TFhirQuestionnaireItemOption){2a}
  else if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirQuestionnaireItem){2a}
  else inherited;
end;

function TFhirQuestionnaireItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'linkId') then result := TFhirString.create() {5b}
  else if (propName = 'definition') then result := TFhirUri.create() {5b}
  else if (propName = 'code') then result := CodeList.new(){2}
  else if (propName = 'prefix') then result := TFhirString.create() {5b}
  else if (propName = 'text') then result := TFhirString.create() {5b}
  else if (propName = 'enableWhen') then result := EnableWhenList.new(){2}
  else if (propName = 'required') then result := TFhirBoolean.create() {5b}
  else if (propName = 'repeats') then result := TFhirBoolean.create() {5b}
  else if (propName = 'readOnly') then result := TFhirBoolean.create() {5b}
  else if (propName = 'maxLength') then result := TFhirInteger.create() {5b}
  else if (propName = 'options') then result := TFhirReference{TFhirValueSet}.create(){4b}
  else if (propName = 'option') then result := OptionList.new(){2}
  else if (isMatchingName(propName, 'initial', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Time', 'String', 'Uri', 'Attachment', 'Coding', 'Quantity', 'Reference'])) then raise EFHIRException.create('Cannot make property Initial'){4x}
  else if (propName = 'item') then result := ItemList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirQuestionnaireItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'linkId') then result := 'string'
  else if (propName = 'definition') then result := 'uri'
  else if (propName = 'code') then result := 'Coding'
  else if (propName = 'prefix') then result := 'string'
  else if (propName = 'text') then result := 'string'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'enableWhen') then result := ''
  else if (propName = 'required') then result := 'boolean'
  else if (propName = 'repeats') then result := 'boolean'
  else if (propName = 'readOnly') then result := 'boolean'
  else if (propName = 'maxLength') then result := 'integer'
  else if (propName = 'options') then result := 'Reference'
  else if (propName = 'option') then result := ''
  else if (propName = 'initial[x]') then result := 'boolean|decimal|integer|date|dateTime|time|string|uri|Attachment|Coding|Quantity|Reference'
  else if (propName = 'item') then result := '@Questionnaire.item'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirQuestionnaireItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'linkId') then LinkIdElement := nil
  else if (propName = 'definition') then DefinitionElement := nil
  else if (propName = 'code') then deletePropertyValue('code', CodeList, value) {2}
  else if (propName = 'prefix') then PrefixElement := nil
  else if (propName = 'text') then TextElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'enableWhen') then deletePropertyValue('enableWhen', EnableWhenList, value) {2}
  else if (propName = 'required') then RequiredElement := nil
  else if (propName = 'repeats') then RepeatsElement := nil
  else if (propName = 'readOnly') then ReadOnlyElement := nil
  else if (propName = 'maxLength') then MaxLengthElement := nil
  else if (propName = 'options') then OptionsElement := nil
  else if (propName = 'option') then deletePropertyValue('option', OptionList, value) {2}
  else if (isMatchingName(propName, 'initial', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Time', 'String', 'Uri', 'Attachment', 'Coding', 'Quantity', 'Reference'])) then InitialElement := nil{4x}
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirQuestionnaireItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'linkId') then LinkIdElement := asString(new){5b}
  else if (propName = 'definition') then DefinitionElement := asUri(new){5b}
  else if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new) {2}
  else if (propName = 'prefix') then PrefixElement := asString(new){5b}
  else if (propName = 'text') then TextElement := asString(new){5b}
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirItemTypeEnum, CODES_TFhirItemTypeEnum, new){4}
  else if (propName = 'enableWhen') then replacePropertyValue('enableWhen', EnableWhenList, existing, new) {2}
  else if (propName = 'required') then RequiredElement := asBoolean(new){5b}
  else if (propName = 'repeats') then RepeatsElement := asBoolean(new){5b}
  else if (propName = 'readOnly') then ReadOnlyElement := asBoolean(new){5b}
  else if (propName = 'maxLength') then MaxLengthElement := asInteger(new){5b}
  else if (propName = 'options') then OptionsElement := new as TFhirReference{TFhirValueSet}{4}
  else if (propName = 'option') then replacePropertyValue('option', OptionList, existing, new) {2}
  else if (isMatchingName(propName, 'initial', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Time', 'String', 'Uri', 'Attachment', 'Coding', 'Quantity', 'Reference'])) then InitialElement := new as TFhirType{4x}
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirQuestionnaireItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'code') then CodeList.move(source, destination){2a}
  else if (propName = 'enableWhen') then EnableWhenList.move(source, destination){2a}
  else if (propName = 'option') then OptionList.move(source, destination){2a}
  else if (propName = 'item') then ItemList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirQuestionnaireItem.fhirType : string;
begin
  result := 'item';
end;

function TFhirQuestionnaireItem.Link : TFhirQuestionnaireItem;
begin
  result := TFhirQuestionnaireItem(inherited Link);
end;

function TFhirQuestionnaireItem.Clone : TFhirQuestionnaireItem;
begin
  result := TFhirQuestionnaireItem(inherited Clone);
end;

function TFhirQuestionnaireItem.equals(other : TObject) : boolean;
var
  o : TFhirQuestionnaireItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirQuestionnaireItem)) then
    result := false
  else
  begin
    o := TFhirQuestionnaireItem(other);
    result := compareDeep(linkIdElement, o.linkIdElement, true) and compareDeep(definitionElement, o.definitionElement, true) and
      compareDeep(codeList, o.codeList, true) and compareDeep(prefixElement, o.prefixElement, true) and
      compareDeep(textElement, o.textElement, true) and compareDeep(type_Element, o.type_Element, true) and
      compareDeep(enableWhenList, o.enableWhenList, true) and compareDeep(requiredElement, o.requiredElement, true) and
      compareDeep(repeatsElement, o.repeatsElement, true) and compareDeep(readOnlyElement, o.readOnlyElement, true) and
      compareDeep(maxLengthElement, o.maxLengthElement, true) and compareDeep(optionsElement, o.optionsElement, true) and
      compareDeep(optionList, o.optionList, true) and compareDeep(initialElement, o.initialElement, true) and
      compareDeep(itemList, o.itemList, true);
  end;
end;

function TFhirQuestionnaireItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLinkId) and isEmptyProp(FDefinition) and isEmptyProp(FcodeList) and isEmptyProp(FPrefix) and isEmptyProp(FText) and isEmptyProp(FType_) and isEmptyProp(FenableWhenList) and isEmptyProp(FRequired) and isEmptyProp(FRepeats) and isEmptyProp(FReadOnly) and isEmptyProp(FMaxLength) and isEmptyProp(FOptions) and isEmptyProp(FoptionList) and isEmptyProp(FInitial) and isEmptyProp(FitemList);
end;

procedure TFhirQuestionnaireItem.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('linkId');
  fields.add('definition');
  fields.add('code');
  fields.add('prefix');
  fields.add('text');
  fields.add('type');
  fields.add('enableWhen');
  fields.add('required');
  fields.add('repeats');
  fields.add('readOnly');
  fields.add('maxLength');
  fields.add('options');
  fields.add('option');
  fields.add('initial[x]');
  fields.add('item');
end;

{ TFhirQuestionnaireItem }

Procedure TFhirQuestionnaireItem.SetLinkId(value : TFhirString);
begin
  FLinkId.free;
  FLinkId := value;
end;

Function TFhirQuestionnaireItem.GetLinkIdST : String;
begin
  if FLinkId = nil then
    result := ''
  else
    result := FLinkId.value;
end;

Procedure TFhirQuestionnaireItem.SetLinkIdST(value : String);
begin
  if value <> '' then
  begin
    if FLinkId = nil then
      FLinkId := TFhirString.create;
    FLinkId.value := value
  end
  else if FLinkId <> nil then
    FLinkId.value := '';
end;

Procedure TFhirQuestionnaireItem.SetDefinition(value : TFhirUri);
begin
  FDefinition.free;
  FDefinition := value;
end;

Function TFhirQuestionnaireItem.GetDefinitionST : String;
begin
  if FDefinition = nil then
    result := ''
  else
    result := FDefinition.value;
end;

Procedure TFhirQuestionnaireItem.SetDefinitionST(value : String);
begin
  if value <> '' then
  begin
    if FDefinition = nil then
      FDefinition := TFhirUri.create;
    FDefinition.value := value
  end
  else if FDefinition <> nil then
    FDefinition.value := '';
end;

Function TFhirQuestionnaireItem.GetCodeList : TFhirCodingList;
begin
  if FCodeList = nil then
    FCodeList := TFhirCodingList.Create;
  result := FCodeList;
end;

Function TFhirQuestionnaireItem.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

Procedure TFhirQuestionnaireItem.SetPrefix(value : TFhirString);
begin
  FPrefix.free;
  FPrefix := value;
end;

Function TFhirQuestionnaireItem.GetPrefixST : String;
begin
  if FPrefix = nil then
    result := ''
  else
    result := FPrefix.value;
end;

Procedure TFhirQuestionnaireItem.SetPrefixST(value : String);
begin
  if value <> '' then
  begin
    if FPrefix = nil then
      FPrefix := TFhirString.create;
    FPrefix.value := value
  end
  else if FPrefix <> nil then
    FPrefix.value := '';
end;

Procedure TFhirQuestionnaireItem.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

Function TFhirQuestionnaireItem.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

Procedure TFhirQuestionnaireItem.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

Procedure TFhirQuestionnaireItem.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirQuestionnaireItem.GetType_ST : TFhirItemTypeEnum;
begin
  if FType_ = nil then
    result := TFhirItemTypeEnum(0)
  else
    result := TFhirItemTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirItemTypeEnum, FType_.value));
end;

Procedure TFhirQuestionnaireItem.SetType_ST(value : TFhirItemTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirItemTypeEnum[value], CODES_TFhirItemTypeEnum[value]);
end;

Function TFhirQuestionnaireItem.GetEnableWhenList : TFhirQuestionnaireItemEnableWhenList;
begin
  if FEnableWhenList = nil then
    FEnableWhenList := TFhirQuestionnaireItemEnableWhenList.Create;
  result := FEnableWhenList;
end;

Function TFhirQuestionnaireItem.GetHasEnableWhenList : boolean;
begin
  result := (FEnableWhenList <> nil) and (FEnableWhenList.count > 0);
end;

Procedure TFhirQuestionnaireItem.SetRequired(value : TFhirBoolean);
begin
  FRequired.free;
  FRequired := value;
end;

Function TFhirQuestionnaireItem.GetRequiredST : Boolean;
begin
  if FRequired = nil then
    result := false
  else
    result := FRequired.value;
end;

Procedure TFhirQuestionnaireItem.SetRequiredST(value : Boolean);
begin
  if FRequired = nil then
    FRequired := TFhirBoolean.create;
  FRequired.value := value
end;

Procedure TFhirQuestionnaireItem.SetRepeats(value : TFhirBoolean);
begin
  FRepeats.free;
  FRepeats := value;
end;

Function TFhirQuestionnaireItem.GetRepeatsST : Boolean;
begin
  if FRepeats = nil then
    result := false
  else
    result := FRepeats.value;
end;

Procedure TFhirQuestionnaireItem.SetRepeatsST(value : Boolean);
begin
  if FRepeats = nil then
    FRepeats := TFhirBoolean.create;
  FRepeats.value := value
end;

Procedure TFhirQuestionnaireItem.SetReadOnly(value : TFhirBoolean);
begin
  FReadOnly.free;
  FReadOnly := value;
end;

Function TFhirQuestionnaireItem.GetReadOnlyST : Boolean;
begin
  if FReadOnly = nil then
    result := false
  else
    result := FReadOnly.value;
end;

Procedure TFhirQuestionnaireItem.SetReadOnlyST(value : Boolean);
begin
  if FReadOnly = nil then
    FReadOnly := TFhirBoolean.create;
  FReadOnly.value := value
end;

Procedure TFhirQuestionnaireItem.SetMaxLength(value : TFhirInteger);
begin
  FMaxLength.free;
  FMaxLength := value;
end;

Function TFhirQuestionnaireItem.GetMaxLengthST : String;
begin
  if FMaxLength = nil then
    result := ''
  else
    result := FMaxLength.value;
end;

Procedure TFhirQuestionnaireItem.SetMaxLengthST(value : String);
begin
  if value <> '' then
  begin
    if FMaxLength = nil then
      FMaxLength := TFhirInteger.create;
    FMaxLength.value := value
  end
  else if FMaxLength <> nil then
    FMaxLength.value := '';
end;

Procedure TFhirQuestionnaireItem.SetOptions(value : TFhirReference{TFhirValueSet});
begin
  FOptions.free;
  FOptions := value;
end;

Function TFhirQuestionnaireItem.GetOptionList : TFhirQuestionnaireItemOptionList;
begin
  if FOptionList = nil then
    FOptionList := TFhirQuestionnaireItemOptionList.Create;
  result := FOptionList;
end;

Function TFhirQuestionnaireItem.GetHasOptionList : boolean;
begin
  result := (FOptionList <> nil) and (FOptionList.count > 0);
end;

Procedure TFhirQuestionnaireItem.SetInitial(value : TFhirType);
begin
  FInitial.free;
  FInitial := value;
end;

Function TFhirQuestionnaireItem.GetItemList : TFhirQuestionnaireItemList;
begin
  if FItemList = nil then
    FItemList := TFhirQuestionnaireItemList.Create;
  result := FItemList;
end;

Function TFhirQuestionnaireItem.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

function TFhirQuestionnaireItem.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FLinkId.sizeInBytes);
  inc(result, FDefinition.sizeInBytes);
  inc(result, FcodeList.sizeInBytes);
  inc(result, FPrefix.sizeInBytes);
  inc(result, FText.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FenableWhenList.sizeInBytes);
  inc(result, FRequired.sizeInBytes);
  inc(result, FRepeats.sizeInBytes);
  inc(result, FReadOnly.sizeInBytes);
  inc(result, FMaxLength.sizeInBytes);
  inc(result, FOptions.sizeInBytes);
  inc(result, FoptionList.sizeInBytes);
  inc(result, FInitial.sizeInBytes);
  inc(result, FitemList.sizeInBytes);
end;

{ TFhirQuestionnaireItemListEnumerator }

Constructor TFhirQuestionnaireItemListEnumerator.Create(list : TFhirQuestionnaireItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirQuestionnaireItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirQuestionnaireItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirQuestionnaireItemListEnumerator.GetCurrent : TFhirQuestionnaireItem;
begin
  Result := FList[FIndex];
end;

function TFhirQuestionnaireItemListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirQuestionnaireItemList }
procedure TFhirQuestionnaireItemList.AddItem(value: TFhirQuestionnaireItem);
begin
  assert(value.ClassName = 'TFhirQuestionnaireItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirQuestionnaireItem');
  add(value);
end;

function TFhirQuestionnaireItemList.Append: TFhirQuestionnaireItem;
begin
  result := TFhirQuestionnaireItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireItemList.ClearItems;
begin
  Clear;
end;

function TFhirQuestionnaireItemList.GetEnumerator : TFhirQuestionnaireItemListEnumerator;
begin
  result := TFhirQuestionnaireItemListEnumerator.Create(self.link);
end;

function TFhirQuestionnaireItemList.Clone: TFhirQuestionnaireItemList;
begin
  result := TFhirQuestionnaireItemList(inherited Clone);
end;

function TFhirQuestionnaireItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirQuestionnaireItemList.GetItemN(index: Integer): TFhirQuestionnaireItem;
begin
  result := TFhirQuestionnaireItem(ObjectByIndex[index]);
end;

function TFhirQuestionnaireItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirQuestionnaireItem;
end;
function TFhirQuestionnaireItemList.IndexOf(value: TFhirQuestionnaireItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirQuestionnaireItemList.Insert(index: Integer): TFhirQuestionnaireItem;
begin
  result := TFhirQuestionnaireItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireItemList.InsertItem(index: Integer; value: TFhirQuestionnaireItem);
begin
  assert(value is TFhirQuestionnaireItem);
  Inherited Insert(index, value);
end;

function TFhirQuestionnaireItemList.Item(index: Integer): TFhirQuestionnaireItem;
begin
  result := TFhirQuestionnaireItem(ObjectByIndex[index]);
end;

function TFhirQuestionnaireItemList.Link: TFhirQuestionnaireItemList;
begin
  result := TFhirQuestionnaireItemList(inherited Link);
end;

procedure TFhirQuestionnaireItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirQuestionnaireItemList.SetItemByIndex(index: Integer; value: TFhirQuestionnaireItem);
begin
  assert(value is TFhirQuestionnaireItem);
  FhirQuestionnaireItems[index] := value;
end;

procedure TFhirQuestionnaireItemList.SetItemN(index: Integer; value: TFhirQuestionnaireItem);
begin
  assert(value is TFhirQuestionnaireItem);
  ObjectByIndex[index] := value;
end;

{ TFhirQuestionnaireItemEnableWhen }

constructor TFhirQuestionnaireItemEnableWhen.Create;
begin
  inherited;
end;

destructor TFhirQuestionnaireItemEnableWhen.Destroy;
begin
  FQuestion.free;
  FHasAnswer.free;
  FAnswer.free;
  inherited;
end;

procedure TFhirQuestionnaireItemEnableWhen.Assign(oSource : TFslObject);
begin
  inherited;
  questionElement := TFhirQuestionnaireItemEnableWhen(oSource).questionElement.Clone;
  hasAnswerElement := TFhirQuestionnaireItemEnableWhen(oSource).hasAnswerElement.Clone;
  answer := TFhirQuestionnaireItemEnableWhen(oSource).answer.Clone;
end;

procedure TFhirQuestionnaireItemEnableWhen.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'question') Then
     list.add(self.link, 'question', FQuestion.Link);
  if (child_name = 'hasAnswer') Then
     list.add(self.link, 'hasAnswer', FHasAnswer.Link);
  if (child_name = 'answer[x]') or (child_name = 'answer') Then
     list.add(self.link, 'answer[x]', FAnswer.Link);
end;

procedure TFhirQuestionnaireItemEnableWhen.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'question', 'string', false, TFhirString, FQuestion.Link));{2}
  oList.add(TFHIRProperty.create(self, 'hasAnswer', 'boolean', false, TFhirBoolean, FHasAnswer.Link));{2}
  oList.add(TFHIRProperty.create(self, 'answer[x]', 'boolean|decimal|integer|date|dateTime|time|string|uri|Attachment|Coding|Quantity|Reference(Any)', false, TFhirType, FAnswer.Link));{2}
end;

function TFhirQuestionnaireItemEnableWhen.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'question') then
  begin
    QuestionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'hasAnswer') then
  begin
    HasAnswerElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'answer', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Time', 'String', 'Uri', 'Attachment', 'Coding', 'Quantity', 'Reference'])) then
  begin
    Answer := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirQuestionnaireItemEnableWhen.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirQuestionnaireItemEnableWhen.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'question') then result := TFhirString.create() {5b}
  else if (propName = 'hasAnswer') then result := TFhirBoolean.create() {5b}
  else if (isMatchingName(propName, 'answer', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Time', 'String', 'Uri', 'Attachment', 'Coding', 'Quantity', 'Reference'])) then raise EFHIRException.create('Cannot make property Answer'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirQuestionnaireItemEnableWhen.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'question') then result := 'string'
  else if (propName = 'hasAnswer') then result := 'boolean'
  else if (propName = 'answer[x]') then result := 'boolean|decimal|integer|date|dateTime|time|string|uri|Attachment|Coding|Quantity|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirQuestionnaireItemEnableWhen.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'question') then QuestionElement := nil
  else if (propName = 'hasAnswer') then HasAnswerElement := nil
  else if (isMatchingName(propName, 'answer', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Time', 'String', 'Uri', 'Attachment', 'Coding', 'Quantity', 'Reference'])) then AnswerElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirQuestionnaireItemEnableWhen.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'question') then QuestionElement := asString(new){5b}
  else if (propName = 'hasAnswer') then HasAnswerElement := asBoolean(new){5b}
  else if (isMatchingName(propName, 'answer', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Time', 'String', 'Uri', 'Attachment', 'Coding', 'Quantity', 'Reference'])) then AnswerElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirQuestionnaireItemEnableWhen.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirQuestionnaireItemEnableWhen.fhirType : string;
begin
  result := 'enableWhen';
end;

function TFhirQuestionnaireItemEnableWhen.Link : TFhirQuestionnaireItemEnableWhen;
begin
  result := TFhirQuestionnaireItemEnableWhen(inherited Link);
end;

function TFhirQuestionnaireItemEnableWhen.Clone : TFhirQuestionnaireItemEnableWhen;
begin
  result := TFhirQuestionnaireItemEnableWhen(inherited Clone);
end;

function TFhirQuestionnaireItemEnableWhen.equals(other : TObject) : boolean;
var
  o : TFhirQuestionnaireItemEnableWhen;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirQuestionnaireItemEnableWhen)) then
    result := false
  else
  begin
    o := TFhirQuestionnaireItemEnableWhen(other);
    result := compareDeep(questionElement, o.questionElement, true) and compareDeep(hasAnswerElement, o.hasAnswerElement, true) and
      compareDeep(answerElement, o.answerElement, true);
  end;
end;

function TFhirQuestionnaireItemEnableWhen.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FQuestion) and isEmptyProp(FHasAnswer) and isEmptyProp(FAnswer);
end;

procedure TFhirQuestionnaireItemEnableWhen.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('question');
  fields.add('hasAnswer');
  fields.add('answer[x]');
end;

{ TFhirQuestionnaireItemEnableWhen }

Procedure TFhirQuestionnaireItemEnableWhen.SetQuestion(value : TFhirString);
begin
  FQuestion.free;
  FQuestion := value;
end;

Function TFhirQuestionnaireItemEnableWhen.GetQuestionST : String;
begin
  if FQuestion = nil then
    result := ''
  else
    result := FQuestion.value;
end;

Procedure TFhirQuestionnaireItemEnableWhen.SetQuestionST(value : String);
begin
  if value <> '' then
  begin
    if FQuestion = nil then
      FQuestion := TFhirString.create;
    FQuestion.value := value
  end
  else if FQuestion <> nil then
    FQuestion.value := '';
end;

Procedure TFhirQuestionnaireItemEnableWhen.SetHasAnswer(value : TFhirBoolean);
begin
  FHasAnswer.free;
  FHasAnswer := value;
end;

Function TFhirQuestionnaireItemEnableWhen.GetHasAnswerST : Boolean;
begin
  if FHasAnswer = nil then
    result := false
  else
    result := FHasAnswer.value;
end;

Procedure TFhirQuestionnaireItemEnableWhen.SetHasAnswerST(value : Boolean);
begin
  if FHasAnswer = nil then
    FHasAnswer := TFhirBoolean.create;
  FHasAnswer.value := value
end;

Procedure TFhirQuestionnaireItemEnableWhen.SetAnswer(value : TFhirType);
begin
  FAnswer.free;
  FAnswer := value;
end;

function TFhirQuestionnaireItemEnableWhen.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FQuestion.sizeInBytes);
  inc(result, FHasAnswer.sizeInBytes);
  inc(result, FAnswer.sizeInBytes);
end;

{ TFhirQuestionnaireItemEnableWhenListEnumerator }

Constructor TFhirQuestionnaireItemEnableWhenListEnumerator.Create(list : TFhirQuestionnaireItemEnableWhenList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirQuestionnaireItemEnableWhenListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirQuestionnaireItemEnableWhenListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirQuestionnaireItemEnableWhenListEnumerator.GetCurrent : TFhirQuestionnaireItemEnableWhen;
begin
  Result := FList[FIndex];
end;

function TFhirQuestionnaireItemEnableWhenListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirQuestionnaireItemEnableWhenList }
procedure TFhirQuestionnaireItemEnableWhenList.AddItem(value: TFhirQuestionnaireItemEnableWhen);
begin
  assert(value.ClassName = 'TFhirQuestionnaireItemEnableWhen', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirQuestionnaireItemEnableWhen');
  add(value);
end;

function TFhirQuestionnaireItemEnableWhenList.Append: TFhirQuestionnaireItemEnableWhen;
begin
  result := TFhirQuestionnaireItemEnableWhen.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireItemEnableWhenList.ClearItems;
begin
  Clear;
end;

function TFhirQuestionnaireItemEnableWhenList.GetEnumerator : TFhirQuestionnaireItemEnableWhenListEnumerator;
begin
  result := TFhirQuestionnaireItemEnableWhenListEnumerator.Create(self.link);
end;

function TFhirQuestionnaireItemEnableWhenList.Clone: TFhirQuestionnaireItemEnableWhenList;
begin
  result := TFhirQuestionnaireItemEnableWhenList(inherited Clone);
end;

function TFhirQuestionnaireItemEnableWhenList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirQuestionnaireItemEnableWhenList.GetItemN(index: Integer): TFhirQuestionnaireItemEnableWhen;
begin
  result := TFhirQuestionnaireItemEnableWhen(ObjectByIndex[index]);
end;

function TFhirQuestionnaireItemEnableWhenList.ItemClass: TFslObjectClass;
begin
  result := TFhirQuestionnaireItemEnableWhen;
end;
function TFhirQuestionnaireItemEnableWhenList.IndexOf(value: TFhirQuestionnaireItemEnableWhen): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirQuestionnaireItemEnableWhenList.Insert(index: Integer): TFhirQuestionnaireItemEnableWhen;
begin
  result := TFhirQuestionnaireItemEnableWhen.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireItemEnableWhenList.InsertItem(index: Integer; value: TFhirQuestionnaireItemEnableWhen);
begin
  assert(value is TFhirQuestionnaireItemEnableWhen);
  Inherited Insert(index, value);
end;

function TFhirQuestionnaireItemEnableWhenList.Item(index: Integer): TFhirQuestionnaireItemEnableWhen;
begin
  result := TFhirQuestionnaireItemEnableWhen(ObjectByIndex[index]);
end;

function TFhirQuestionnaireItemEnableWhenList.Link: TFhirQuestionnaireItemEnableWhenList;
begin
  result := TFhirQuestionnaireItemEnableWhenList(inherited Link);
end;

procedure TFhirQuestionnaireItemEnableWhenList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirQuestionnaireItemEnableWhenList.SetItemByIndex(index: Integer; value: TFhirQuestionnaireItemEnableWhen);
begin
  assert(value is TFhirQuestionnaireItemEnableWhen);
  FhirQuestionnaireItemEnableWhens[index] := value;
end;

procedure TFhirQuestionnaireItemEnableWhenList.SetItemN(index: Integer; value: TFhirQuestionnaireItemEnableWhen);
begin
  assert(value is TFhirQuestionnaireItemEnableWhen);
  ObjectByIndex[index] := value;
end;

{ TFhirQuestionnaireItemOption }

constructor TFhirQuestionnaireItemOption.Create;
begin
  inherited;
end;

destructor TFhirQuestionnaireItemOption.Destroy;
begin
  FValue.free;
  inherited;
end;

procedure TFhirQuestionnaireItemOption.Assign(oSource : TFslObject);
begin
  inherited;
  value := TFhirQuestionnaireItemOption(oSource).value.Clone;
end;

procedure TFhirQuestionnaireItemOption.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirQuestionnaireItemOption.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'value[x]', 'integer|date|time|string|Coding', false, TFhirType, FValue.Link));{2}
end;

function TFhirQuestionnaireItemOption.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'value', ['Integer', 'Date', 'Time', 'String', 'Coding'])) then
  begin
    Value := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirQuestionnaireItemOption.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirQuestionnaireItemOption.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'value', ['Integer', 'Date', 'Time', 'String', 'Coding'])) then raise EFHIRException.create('Cannot make property Value'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirQuestionnaireItemOption.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'value[x]') then result := 'integer|date|time|string|Coding'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirQuestionnaireItemOption.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'value', ['Integer', 'Date', 'Time', 'String', 'Coding'])) then ValueElement := nil{4x}
  else
  inherited deleteProperty(propName, value);
end;

procedure TFhirQuestionnaireItemOption.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'value', ['Integer', 'Date', 'Time', 'String', 'Coding'])) then ValueElement := new as TFhirType{4x}
  else
  inherited replaceProperty(propName, existing, new);
end;

procedure TFhirQuestionnaireItemOption.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirQuestionnaireItemOption.fhirType : string;
begin
  result := 'option';
end;

function TFhirQuestionnaireItemOption.Link : TFhirQuestionnaireItemOption;
begin
  result := TFhirQuestionnaireItemOption(inherited Link);
end;

function TFhirQuestionnaireItemOption.Clone : TFhirQuestionnaireItemOption;
begin
  result := TFhirQuestionnaireItemOption(inherited Clone);
end;

function TFhirQuestionnaireItemOption.equals(other : TObject) : boolean;
var
  o : TFhirQuestionnaireItemOption;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirQuestionnaireItemOption)) then
    result := false
  else
  begin
    o := TFhirQuestionnaireItemOption(other);
    result := compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirQuestionnaireItemOption.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FValue);
end;

procedure TFhirQuestionnaireItemOption.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('value[x]');
end;

{ TFhirQuestionnaireItemOption }

Procedure TFhirQuestionnaireItemOption.SetValue(value : TFhirType);
begin
  FValue.free;
  FValue := value;
end;

function TFhirQuestionnaireItemOption.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FValue.sizeInBytes);
end;

{ TFhirQuestionnaireItemOptionListEnumerator }

Constructor TFhirQuestionnaireItemOptionListEnumerator.Create(list : TFhirQuestionnaireItemOptionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirQuestionnaireItemOptionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirQuestionnaireItemOptionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirQuestionnaireItemOptionListEnumerator.GetCurrent : TFhirQuestionnaireItemOption;
begin
  Result := FList[FIndex];
end;

function TFhirQuestionnaireItemOptionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirQuestionnaireItemOptionList }
procedure TFhirQuestionnaireItemOptionList.AddItem(value: TFhirQuestionnaireItemOption);
begin
  assert(value.ClassName = 'TFhirQuestionnaireItemOption', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirQuestionnaireItemOption');
  add(value);
end;

function TFhirQuestionnaireItemOptionList.Append: TFhirQuestionnaireItemOption;
begin
  result := TFhirQuestionnaireItemOption.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireItemOptionList.ClearItems;
begin
  Clear;
end;

function TFhirQuestionnaireItemOptionList.GetEnumerator : TFhirQuestionnaireItemOptionListEnumerator;
begin
  result := TFhirQuestionnaireItemOptionListEnumerator.Create(self.link);
end;

function TFhirQuestionnaireItemOptionList.Clone: TFhirQuestionnaireItemOptionList;
begin
  result := TFhirQuestionnaireItemOptionList(inherited Clone);
end;

function TFhirQuestionnaireItemOptionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirQuestionnaireItemOptionList.GetItemN(index: Integer): TFhirQuestionnaireItemOption;
begin
  result := TFhirQuestionnaireItemOption(ObjectByIndex[index]);
end;

function TFhirQuestionnaireItemOptionList.ItemClass: TFslObjectClass;
begin
  result := TFhirQuestionnaireItemOption;
end;
function TFhirQuestionnaireItemOptionList.IndexOf(value: TFhirQuestionnaireItemOption): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirQuestionnaireItemOptionList.Insert(index: Integer): TFhirQuestionnaireItemOption;
begin
  result := TFhirQuestionnaireItemOption.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireItemOptionList.InsertItem(index: Integer; value: TFhirQuestionnaireItemOption);
begin
  assert(value is TFhirQuestionnaireItemOption);
  Inherited Insert(index, value);
end;

function TFhirQuestionnaireItemOptionList.Item(index: Integer): TFhirQuestionnaireItemOption;
begin
  result := TFhirQuestionnaireItemOption(ObjectByIndex[index]);
end;

function TFhirQuestionnaireItemOptionList.Link: TFhirQuestionnaireItemOptionList;
begin
  result := TFhirQuestionnaireItemOptionList(inherited Link);
end;

procedure TFhirQuestionnaireItemOptionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirQuestionnaireItemOptionList.SetItemByIndex(index: Integer; value: TFhirQuestionnaireItemOption);
begin
  assert(value is TFhirQuestionnaireItemOption);
  FhirQuestionnaireItemOptions[index] := value;
end;

procedure TFhirQuestionnaireItemOptionList.SetItemN(index: Integer; value: TFhirQuestionnaireItemOption);
begin
  assert(value is TFhirQuestionnaireItemOption);
  ObjectByIndex[index] := value;
end;

{ TFhirQuestionnaire }

constructor TFhirQuestionnaire.Create;
begin
  inherited;
end;

destructor TFhirQuestionnaire.Destroy;
begin
  FIdentifierList.Free;
  FPurpose.free;
  FApprovalDate.free;
  FLastReviewDate.free;
  FEffectivePeriod.free;
  FCopyright.free;
  FCodeList.Free;
  FSubjectType.Free;
  FItemList.Free;
  inherited;
end;

function TFhirQuestionnaire.GetResourceType : TFhirResourceType;
begin
  result := frtQuestionnaire;
end;

procedure TFhirQuestionnaire.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirQuestionnaire(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirQuestionnaire(oSource).FIdentifierList);
  end;
  purposeElement := TFhirQuestionnaire(oSource).purposeElement.Clone;
  approvalDateElement := TFhirQuestionnaire(oSource).approvalDateElement.Clone;
  lastReviewDateElement := TFhirQuestionnaire(oSource).lastReviewDateElement.Clone;
  effectivePeriod := TFhirQuestionnaire(oSource).effectivePeriod.Clone;
  copyrightElement := TFhirQuestionnaire(oSource).copyrightElement.Clone;
  if (TFhirQuestionnaire(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirCodingList.Create;
    FCodeList.Assign(TFhirQuestionnaire(oSource).FCodeList);
  end;
  if (TFhirQuestionnaire(oSource).FSubjectType = nil) then
  begin
    FSubjectType.free;
    FSubjectType := nil;
  end
  else
  begin
    FSubjectType := TFHIREnumList.Create(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum);
    FSubjectType.Assign(TFhirQuestionnaire(oSource).FSubjectType);
  end;
  if (TFhirQuestionnaire(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirQuestionnaireItemList.Create;
    FItemList.Assign(TFhirQuestionnaire(oSource).FItemList);
  end;
end;

procedure TFhirQuestionnaire.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'approvalDate') Then
     list.add(self.link, 'approvalDate', FApprovalDate.Link);
  if (child_name = 'lastReviewDate') Then
     list.add(self.link, 'lastReviewDate', FLastReviewDate.Link);
  if (child_name = 'effectivePeriod') Then
     list.add(self.link, 'effectivePeriod', FEffectivePeriod.Link);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'subjectType') Then
     list.addAll(self, 'subjectType', FSubjectType);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
end;

procedure TFhirQuestionnaire.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));{2}
  oList.add(TFHIRProperty.create(self, 'approvalDate', 'date', false, TFhirDate, FApprovalDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'lastReviewDate', 'date', false, TFhirDate, FLastReviewDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'effectivePeriod', 'Period', false, TFhirPeriod, FEffectivePeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'Coding', true, TFhirCoding, FCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'subjectType', 'code', true, TFHIREnum, FSubjectType.Link)){3};
  oList.add(TFHIRProperty.create(self, 'item', '', true, TFhirQuestionnaireItem, FItemList.Link)){3};
end;

function TFhirQuestionnaire.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'approvalDate') then
  begin
    ApprovalDateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'lastReviewDate') then
  begin
    LastReviewDateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'effectivePeriod') then
  begin
    EffectivePeriod := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else if (propName = 'subjectType') then
  begin
    SubjectTypeList.add(asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue)); {1}
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirQuestionnaireItem){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirQuestionnaire.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirCoding){2a}
  else if (propName = 'subjectType') then FSubjectType.insertItem(index, asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue)) {1}
  else if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirQuestionnaireItem){2a}
  else inherited;
end;

function TFhirQuestionnaire.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'purpose') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'approvalDate') then result := TFhirDate.create() {5b}
  else if (propName = 'lastReviewDate') then result := TFhirDate.create() {5b}
  else if (propName = 'effectivePeriod') then result := TFhirPeriod.create(){4b}
  else if (propName = 'copyright') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'code') then result := CodeList.new(){2}
  else if (propName = 'item') then result := ItemList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirQuestionnaire.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'approvalDate') then result := 'date'
  else if (propName = 'lastReviewDate') then result := 'date'
  else if (propName = 'effectivePeriod') then result := 'Period'
  else if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'code') then result := 'Coding'
  else if (propName = 'subjectType') then result := 'code'
  else if (propName = 'item') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirQuestionnaire.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'approvalDate') then ApprovalDateElement := nil
  else if (propName = 'lastReviewDate') then LastReviewDateElement := nil
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := nil
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'code') then deletePropertyValue('code', CodeList, value) {2}
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirQuestionnaire.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'purpose') then PurposeElement := asMarkdown(new){5b}
  else if (propName = 'approvalDate') then ApprovalDateElement := asDate(new){5b}
  else if (propName = 'lastReviewDate') then LastReviewDateElement := asDate(new){5b}
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := new as TFhirPeriod{4}
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new){5b}
  else if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new) {2}
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirQuestionnaire.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'code') then CodeList.move(source, destination){2a}
  else if (propName = 'subjectType') then FSubjectType.move(source, destination) {1}
  else if (propName = 'item') then ItemList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirQuestionnaire.fhirType : string;
begin
  result := 'Questionnaire';
end;

function TFhirQuestionnaire.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FPurpose) and isEmptyProp(FApprovalDate) and isEmptyProp(FLastReviewDate) and isEmptyProp(FEffectivePeriod) and isEmptyProp(FCopyright) and isEmptyProp(FcodeList) and isEmptyProp(FSubjectType) and isEmptyProp(FitemList);
end;

function TFhirQuestionnaire.equals(other : TObject) : boolean;
var
  o : TFhirQuestionnaire;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirQuestionnaire)) then
    result := false
  else
  begin
    o := TFhirQuestionnaire(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(purposeElement, o.purposeElement, true) and
      compareDeep(approvalDateElement, o.approvalDateElement, true) and compareDeep(lastReviewDateElement, o.lastReviewDateElement, true) and
      compareDeep(effectivePeriodElement, o.effectivePeriodElement, true) and compareDeep(copyrightElement, o.copyrightElement, true) and
      compareDeep(codeList, o.codeList, true) and compareDeep(subjectTypeList, o.subjectTypeList, true) and
      compareDeep(itemList, o.itemList, true);
  end;
end;

function TFhirQuestionnaire.Link : TFhirQuestionnaire;
begin
  result := TFhirQuestionnaire(inherited Link);
end;

function TFhirQuestionnaire.Clone : TFhirQuestionnaire;
begin
  result := TFhirQuestionnaire(inherited Clone);
end;

procedure TFhirQuestionnaire.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('status');
  fields.add('experimental');
  fields.add('date');
  fields.add('publisher');
  fields.add('description');
  fields.add('purpose');
  fields.add('approvalDate');
  fields.add('lastReviewDate');
  fields.add('effectivePeriod');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('contact');
  fields.add('copyright');
  fields.add('code');
  fields.add('subjectType');
  fields.add('item');
end;

{ TFhirQuestionnaire }

Function TFhirQuestionnaire.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirQuestionnaire.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirQuestionnaire.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

Function TFhirQuestionnaire.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

Procedure TFhirQuestionnaire.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

Procedure TFhirQuestionnaire.SetApprovalDate(value : TFhirDate);
begin
  FApprovalDate.free;
  FApprovalDate := value;
end;

Function TFhirQuestionnaire.GetApprovalDateST : TFslDateTime;
begin
  if FApprovalDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FApprovalDate.value;
end;

Procedure TFhirQuestionnaire.SetApprovalDateST(value : TFslDateTime);
begin
  if FApprovalDate = nil then
    FApprovalDate := TFhirDate.create;
  FApprovalDate.value := value
end;

Procedure TFhirQuestionnaire.SetLastReviewDate(value : TFhirDate);
begin
  FLastReviewDate.free;
  FLastReviewDate := value;
end;

Function TFhirQuestionnaire.GetLastReviewDateST : TFslDateTime;
begin
  if FLastReviewDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastReviewDate.value;
end;

Procedure TFhirQuestionnaire.SetLastReviewDateST(value : TFslDateTime);
begin
  if FLastReviewDate = nil then
    FLastReviewDate := TFhirDate.create;
  FLastReviewDate.value := value
end;

Procedure TFhirQuestionnaire.SetEffectivePeriod(value : TFhirPeriod);
begin
  FEffectivePeriod.free;
  FEffectivePeriod := value;
end;

Procedure TFhirQuestionnaire.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

Function TFhirQuestionnaire.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

Procedure TFhirQuestionnaire.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

Function TFhirQuestionnaire.GetCodeList : TFhirCodingList;
begin
  if FCodeList = nil then
    FCodeList := TFhirCodingList.Create;
  result := FCodeList;
end;

Function TFhirQuestionnaire.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

Function TFhirQuestionnaire.GetSubjectType : TFhirEnumList;
begin
  if FSubjectType = nil then
    FSubjectType := TFHIREnumList.Create(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum);
  result := FSubjectType;
end;

Function TFhirQuestionnaire.GetHasSubjectType : boolean;
begin
  result := (FSubjectType <> nil) and (FSubjectType.count > 0);
end;

Function TFhirQuestionnaire.GetItemList : TFhirQuestionnaireItemList;
begin
  if FItemList = nil then
    FItemList := TFhirQuestionnaireItemList.Create;
  result := FItemList;
end;

Function TFhirQuestionnaire.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

function TFhirQuestionnaire.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FPurpose.sizeInBytes);
  inc(result, FApprovalDate.sizeInBytes);
  inc(result, FLastReviewDate.sizeInBytes);
  inc(result, FEffectivePeriod.sizeInBytes);
  inc(result, FCopyright.sizeInBytes);
  inc(result, FcodeList.sizeInBytes);
  inc(result, FSubjectType.sizeInBytes);
  inc(result, FitemList.sizeInBytes);
end;

{ TFhirQuestionnaireListEnumerator }

Constructor TFhirQuestionnaireListEnumerator.Create(list : TFhirQuestionnaireList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirQuestionnaireListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirQuestionnaireListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirQuestionnaireListEnumerator.GetCurrent : TFhirQuestionnaire;
begin
  Result := FList[FIndex];
end;

function TFhirQuestionnaireListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirQuestionnaireList }
procedure TFhirQuestionnaireList.AddItem(value: TFhirQuestionnaire);
begin
  assert(value.ClassName = 'TFhirQuestionnaire', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirQuestionnaire');
  add(value);
end;

function TFhirQuestionnaireList.Append: TFhirQuestionnaire;
begin
  result := TFhirQuestionnaire.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireList.ClearItems;
begin
  Clear;
end;

function TFhirQuestionnaireList.GetEnumerator : TFhirQuestionnaireListEnumerator;
begin
  result := TFhirQuestionnaireListEnumerator.Create(self.link);
end;

function TFhirQuestionnaireList.Clone: TFhirQuestionnaireList;
begin
  result := TFhirQuestionnaireList(inherited Clone);
end;

function TFhirQuestionnaireList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirQuestionnaireList.GetItemN(index: Integer): TFhirQuestionnaire;
begin
  result := TFhirQuestionnaire(ObjectByIndex[index]);
end;

function TFhirQuestionnaireList.ItemClass: TFslObjectClass;
begin
  result := TFhirQuestionnaire;
end;
function TFhirQuestionnaireList.IndexOf(value: TFhirQuestionnaire): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirQuestionnaireList.Insert(index: Integer): TFhirQuestionnaire;
begin
  result := TFhirQuestionnaire.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireList.InsertItem(index: Integer; value: TFhirQuestionnaire);
begin
  assert(value is TFhirQuestionnaire);
  Inherited Insert(index, value);
end;

function TFhirQuestionnaireList.Item(index: Integer): TFhirQuestionnaire;
begin
  result := TFhirQuestionnaire(ObjectByIndex[index]);
end;

function TFhirQuestionnaireList.Link: TFhirQuestionnaireList;
begin
  result := TFhirQuestionnaireList(inherited Link);
end;

procedure TFhirQuestionnaireList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirQuestionnaireList.SetItemByIndex(index: Integer; value: TFhirQuestionnaire);
begin
  assert(value is TFhirQuestionnaire);
  FhirQuestionnaires[index] := value;
end;

procedure TFhirQuestionnaireList.SetItemN(index: Integer; value: TFhirQuestionnaire);
begin
  assert(value is TFhirQuestionnaire);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_QUESTIONNAIRE}

{$IFDEF FHIR_REQUESTGROUP}

{ TFhirRequestGroupAction }

constructor TFhirRequestGroupAction.Create;
begin
  inherited;
end;

destructor TFhirRequestGroupAction.Destroy;
begin
  FLabel_.free;
  FTitle.free;
  FDescription.free;
  FTextEquivalent.free;
  FCodeList.Free;
  FDocumentationList.Free;
  FConditionList.Free;
  FRelatedActionList.Free;
  FTiming.free;
  FParticipantList.Free;
  FType_.free;
  FGroupingBehavior.free;
  FSelectionBehavior.free;
  FRequiredBehavior.free;
  FPrecheckBehavior.free;
  FCardinalityBehavior.free;
  FResource.free;
  FActionList.Free;
  inherited;
end;

procedure TFhirRequestGroupAction.Assign(oSource : TFslObject);
begin
  inherited;
  label_Element := TFhirRequestGroupAction(oSource).label_Element.Clone;
  titleElement := TFhirRequestGroupAction(oSource).titleElement.Clone;
  descriptionElement := TFhirRequestGroupAction(oSource).descriptionElement.Clone;
  textEquivalentElement := TFhirRequestGroupAction(oSource).textEquivalentElement.Clone;
  if (TFhirRequestGroupAction(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirCodeableConceptList.Create;
    FCodeList.Assign(TFhirRequestGroupAction(oSource).FCodeList);
  end;
  if (TFhirRequestGroupAction(oSource).FDocumentationList = nil) then
  begin
    FDocumentationList.free;
    FDocumentationList := nil;
  end
  else
  begin
    if FDocumentationList = nil then
      FDocumentationList := TFhirRelatedArtifactList.Create;
    FDocumentationList.Assign(TFhirRequestGroupAction(oSource).FDocumentationList);
  end;
  if (TFhirRequestGroupAction(oSource).FConditionList = nil) then
  begin
    FConditionList.free;
    FConditionList := nil;
  end
  else
  begin
    if FConditionList = nil then
      FConditionList := TFhirRequestGroupActionConditionList.Create;
    FConditionList.Assign(TFhirRequestGroupAction(oSource).FConditionList);
  end;
  if (TFhirRequestGroupAction(oSource).FRelatedActionList = nil) then
  begin
    FRelatedActionList.free;
    FRelatedActionList := nil;
  end
  else
  begin
    if FRelatedActionList = nil then
      FRelatedActionList := TFhirRequestGroupActionRelatedActionList.Create;
    FRelatedActionList.Assign(TFhirRequestGroupAction(oSource).FRelatedActionList);
  end;
  timing := TFhirRequestGroupAction(oSource).timing.Clone;
  if (TFhirRequestGroupAction(oSource).FParticipantList = nil) then
  begin
    FParticipantList.free;
    FParticipantList := nil;
  end
  else
  begin
    if FParticipantList = nil then
      FParticipantList := TFhirReferenceList{Resource}.Create;
    FParticipantList.Assign(TFhirRequestGroupAction(oSource).FParticipantList);
  end;
  type_ := TFhirRequestGroupAction(oSource).type_.Clone;
  FGroupingBehavior := TFhirRequestGroupAction(oSource).FGroupingBehavior.Link;
  FSelectionBehavior := TFhirRequestGroupAction(oSource).FSelectionBehavior.Link;
  FRequiredBehavior := TFhirRequestGroupAction(oSource).FRequiredBehavior.Link;
  FPrecheckBehavior := TFhirRequestGroupAction(oSource).FPrecheckBehavior.Link;
  FCardinalityBehavior := TFhirRequestGroupAction(oSource).FCardinalityBehavior.Link;
  resource := TFhirRequestGroupAction(oSource).resource.Clone;
  if (TFhirRequestGroupAction(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirRequestGroupActionList.Create;
    FActionList.Assign(TFhirRequestGroupAction(oSource).FActionList);
  end;
end;

procedure TFhirRequestGroupAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'label') Then
     list.add(self.link, 'label', FLabel_.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'textEquivalent') Then
     list.add(self.link, 'textEquivalent', FTextEquivalent.Link);
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'documentation') Then
    list.addAll(self, 'documentation', FDocumentationList);
  if (child_name = 'condition') Then
    list.addAll(self, 'condition', FConditionList);
  if (child_name = 'relatedAction') Then
    list.addAll(self, 'relatedAction', FRelatedActionList);
  if (child_name = 'timing[x]') or (child_name = 'timing') Then
     list.add(self.link, 'timing[x]', FTiming.Link);
  if (child_name = 'participant') Then
    list.addAll(self, 'participant', FParticipantList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'groupingBehavior') Then
     list.add(self.link, 'groupingBehavior', FGroupingBehavior.Link);
  if (child_name = 'selectionBehavior') Then
     list.add(self.link, 'selectionBehavior', FSelectionBehavior.Link);
  if (child_name = 'requiredBehavior') Then
     list.add(self.link, 'requiredBehavior', FRequiredBehavior.Link);
  if (child_name = 'precheckBehavior') Then
     list.add(self.link, 'precheckBehavior', FPrecheckBehavior.Link);
  if (child_name = 'cardinalityBehavior') Then
     list.add(self.link, 'cardinalityBehavior', FCardinalityBehavior.Link);
  if (child_name = 'resource') Then
     list.add(self.link, 'resource', FResource.Link);
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
end;

procedure TFhirRequestGroupAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'label', 'string', false, TFhirString, FLabel_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'textEquivalent', 'string', false, TFhirString, FTextEquivalent.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', true, TFhirCodeableConcept, FCodeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'documentation', 'RelatedArtifact', true, TFhirRelatedArtifact, FDocumentationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'condition', '', true, TFhirRequestGroupActionCondition, FConditionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'relatedAction', '', true, TFhirRequestGroupActionRelatedAction, FRelatedActionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'timing[x]', 'dateTime|Period|Duration|Range|Timing', false, TFhirType, FTiming.Link));{2}
  oList.add(TFHIRProperty.create(self, 'participant', 'Reference(Patient|Person|Practitioner|RelatedPerson)', true, TFhirReference{Resource}, FParticipantList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', false, TFhirCoding, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'groupingBehavior', 'code', false, TFHIREnum, FGroupingBehavior.Link));{1}
  oList.add(TFHIRProperty.create(self, 'selectionBehavior', 'code', false, TFHIREnum, FSelectionBehavior.Link));{1}
  oList.add(TFHIRProperty.create(self, 'requiredBehavior', 'code', false, TFHIREnum, FRequiredBehavior.Link));{1}
  oList.add(TFHIRProperty.create(self, 'precheckBehavior', 'code', false, TFHIREnum, FPrecheckBehavior.Link));{1}
  oList.add(TFHIRProperty.create(self, 'cardinalityBehavior', 'code', false, TFHIREnum, FCardinalityBehavior.Link));{1}
  oList.add(TFHIRProperty.create(self, 'resource', 'Reference(Any)', false, TFhirReference{TFhirReference}, FResource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'action', '@RequestGroup.action', true, TFhirRequestGroupAction, FActionList.Link)){3};
end;

function TFhirRequestGroupAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'label') then
  begin
    Label_Element := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'textEquivalent') then
  begin
    TextEquivalentElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'documentation') then
  begin
    DocumentationList.add(propValue as TFhirRelatedArtifact){2a};
    result := propValue;
  end
  else if (propName = 'condition') then
  begin
    ConditionList.add(propValue as TFhirRequestGroupActionCondition){2a};
    result := propValue;
  end
  else if (propName = 'relatedAction') then
  begin
    RelatedActionList.add(propValue as TFhirRequestGroupActionRelatedAction){2a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'timing', ['DateTime', 'Period', 'Duration', 'Range', 'Timing'])) then
  begin
    Timing := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'participant') then
  begin
    ParticipantList.add(propValue as TFhirReference{Resource}){2a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'groupingBehavior') then
  begin
    GroupingBehaviorElement := asEnum(SYSTEMS_TFhirActionGroupingBehaviorEnum, CODES_TFhirActionGroupingBehaviorEnum, propValue);
    result := propValue
  end
  else if (propName = 'selectionBehavior') then
  begin
    SelectionBehaviorElement := asEnum(SYSTEMS_TFhirActionSelectionBehaviorEnum, CODES_TFhirActionSelectionBehaviorEnum, propValue);
    result := propValue
  end
  else if (propName = 'requiredBehavior') then
  begin
    RequiredBehaviorElement := asEnum(SYSTEMS_TFhirActionRequiredBehaviorEnum, CODES_TFhirActionRequiredBehaviorEnum, propValue);
    result := propValue
  end
  else if (propName = 'precheckBehavior') then
  begin
    PrecheckBehaviorElement := asEnum(SYSTEMS_TFhirActionPrecheckBehaviorEnum, CODES_TFhirActionPrecheckBehaviorEnum, propValue);
    result := propValue
  end
  else if (propName = 'cardinalityBehavior') then
  begin
    CardinalityBehaviorElement := asEnum(SYSTEMS_TFhirActionCardinalityBehaviorEnum, CODES_TFhirActionCardinalityBehaviorEnum, propValue);
    result := propValue
  end
  else if (propName = 'resource') then
  begin
    Resource := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirRequestGroupAction){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRequestGroupAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'documentation') then DocumentationList.insertItem(index, propValue as TFhirRelatedArtifact){2a}
  else if (propName = 'condition') then ConditionList.insertItem(index, propValue as TFhirRequestGroupActionCondition){2a}
  else if (propName = 'relatedAction') then RelatedActionList.insertItem(index, propValue as TFhirRequestGroupActionRelatedAction){2a}
  else if (propName = 'participant') then ParticipantList.insertItem(index, propValue as TFhirReference{Resource}){2a}
  else if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirRequestGroupAction){2a}
  else inherited;
end;

function TFhirRequestGroupAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'label') then result := TFhirString.create() {5b}
  else if (propName = 'title') then result := TFhirString.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'textEquivalent') then result := TFhirString.create() {5b}
  else if (propName = 'code') then result := CodeList.new(){2}
  else if (propName = 'documentation') then result := DocumentationList.new(){2}
  else if (propName = 'condition') then result := ConditionList.new(){2}
  else if (propName = 'relatedAction') then result := RelatedActionList.new(){2}
  else if (isMatchingName(propName, 'timing', ['DateTime', 'Period', 'Duration', 'Range', 'Timing'])) then raise EFHIRException.create('Cannot make property Timing'){4x}
  else if (propName = 'participant') then result := ParticipantList.new(){2}
  else if (propName = 'type') then result := TFhirCoding.create(){4b}
  else if (propName = 'resource') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'action') then result := ActionList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirRequestGroupAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'label') then result := 'string'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'textEquivalent') then result := 'string'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'documentation') then result := 'RelatedArtifact'
  else if (propName = 'condition') then result := ''
  else if (propName = 'relatedAction') then result := ''
  else if (propName = 'timing[x]') then result := 'dateTime|Period|Duration|Range|Timing'
  else if (propName = 'participant') then result := 'Reference'
  else if (propName = 'type') then result := 'Coding'
  else if (propName = 'groupingBehavior') then result := 'code'
  else if (propName = 'selectionBehavior') then result := 'code'
  else if (propName = 'requiredBehavior') then result := 'code'
  else if (propName = 'precheckBehavior') then result := 'code'
  else if (propName = 'cardinalityBehavior') then result := 'code'
  else if (propName = 'resource') then result := 'Reference'
  else if (propName = 'action') then result := '@RequestGroup.action'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRequestGroupAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'label') then Label_Element := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'textEquivalent') then TextEquivalentElement := nil
  else if (propName = 'code') then deletePropertyValue('code', CodeList, value) {2}
  else if (propName = 'documentation') then deletePropertyValue('documentation', DocumentationList, value) {2}
  else if (propName = 'condition') then deletePropertyValue('condition', ConditionList, value) {2}
  else if (propName = 'relatedAction') then deletePropertyValue('relatedAction', RelatedActionList, value) {2}
  else if (isMatchingName(propName, 'timing', ['DateTime', 'Period', 'Duration', 'Range', 'Timing'])) then TimingElement := nil{4x}
  else if (propName = 'participant') then deletePropertyValue('participant', ParticipantList, value) {2}
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'groupingBehavior') then GroupingBehaviorElement := nil
  else if (propName = 'selectionBehavior') then SelectionBehaviorElement := nil
  else if (propName = 'requiredBehavior') then RequiredBehaviorElement := nil
  else if (propName = 'precheckBehavior') then PrecheckBehaviorElement := nil
  else if (propName = 'cardinalityBehavior') then CardinalityBehaviorElement := nil
  else if (propName = 'resource') then ResourceElement := nil
  else if (propName = 'action') then deletePropertyValue('action', ActionList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRequestGroupAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'label') then Label_Element := asString(new){5b}
  else if (propName = 'title') then TitleElement := asString(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'textEquivalent') then TextEquivalentElement := asString(new){5b}
  else if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new) {2}
  else if (propName = 'documentation') then replacePropertyValue('documentation', DocumentationList, existing, new) {2}
  else if (propName = 'condition') then replacePropertyValue('condition', ConditionList, existing, new) {2}
  else if (propName = 'relatedAction') then replacePropertyValue('relatedAction', RelatedActionList, existing, new) {2}
  else if (isMatchingName(propName, 'timing', ['DateTime', 'Period', 'Duration', 'Range', 'Timing'])) then TimingElement := new as TFhirType{4x}
  else if (propName = 'participant') then replacePropertyValue('participant', ParticipantList, existing, new) {2}
  else if (propName = 'type') then Type_Element := new as TFhirCoding{4}
  else if (propName = 'groupingBehavior') then GroupingBehaviorElement := asEnum(SYSTEMS_TFhirActionGroupingBehaviorEnum, CODES_TFhirActionGroupingBehaviorEnum, new){4}
  else if (propName = 'selectionBehavior') then SelectionBehaviorElement := asEnum(SYSTEMS_TFhirActionSelectionBehaviorEnum, CODES_TFhirActionSelectionBehaviorEnum, new){4}
  else if (propName = 'requiredBehavior') then RequiredBehaviorElement := asEnum(SYSTEMS_TFhirActionRequiredBehaviorEnum, CODES_TFhirActionRequiredBehaviorEnum, new){4}
  else if (propName = 'precheckBehavior') then PrecheckBehaviorElement := asEnum(SYSTEMS_TFhirActionPrecheckBehaviorEnum, CODES_TFhirActionPrecheckBehaviorEnum, new){4}
  else if (propName = 'cardinalityBehavior') then CardinalityBehaviorElement := asEnum(SYSTEMS_TFhirActionCardinalityBehaviorEnum, CODES_TFhirActionCardinalityBehaviorEnum, new){4}
  else if (propName = 'resource') then ResourceElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRequestGroupAction.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'code') then CodeList.move(source, destination){2a}
  else if (propName = 'documentation') then DocumentationList.move(source, destination){2a}
  else if (propName = 'condition') then ConditionList.move(source, destination){2a}
  else if (propName = 'relatedAction') then RelatedActionList.move(source, destination){2a}
  else if (propName = 'participant') then ParticipantList.move(source, destination){2a}
  else if (propName = 'action') then ActionList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirRequestGroupAction.fhirType : string;
begin
  result := 'action';
end;

function TFhirRequestGroupAction.Link : TFhirRequestGroupAction;
begin
  result := TFhirRequestGroupAction(inherited Link);
end;

function TFhirRequestGroupAction.Clone : TFhirRequestGroupAction;
begin
  result := TFhirRequestGroupAction(inherited Clone);
end;

function TFhirRequestGroupAction.equals(other : TObject) : boolean;
var
  o : TFhirRequestGroupAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRequestGroupAction)) then
    result := false
  else
  begin
    o := TFhirRequestGroupAction(other);
    result := compareDeep(label_Element, o.label_Element, true) and compareDeep(titleElement, o.titleElement, true) and
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(textEquivalentElement, o.textEquivalentElement, true) and
      compareDeep(codeList, o.codeList, true) and compareDeep(documentationList, o.documentationList, true) and
      compareDeep(conditionList, o.conditionList, true) and compareDeep(relatedActionList, o.relatedActionList, true) and
      compareDeep(timingElement, o.timingElement, true) and compareDeep(participantList, o.participantList, true) and
      compareDeep(type_Element, o.type_Element, true) and compareDeep(groupingBehaviorElement, o.groupingBehaviorElement, true) and
      compareDeep(selectionBehaviorElement, o.selectionBehaviorElement, true) and compareDeep(requiredBehaviorElement, o.requiredBehaviorElement, true) and
      compareDeep(precheckBehaviorElement, o.precheckBehaviorElement, true) and compareDeep(cardinalityBehaviorElement, o.cardinalityBehaviorElement, true) and
      compareDeep(resourceElement, o.resourceElement, true) and compareDeep(actionList, o.actionList, true);
  end;
end;

function TFhirRequestGroupAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLabel_) and isEmptyProp(FTitle) and isEmptyProp(FDescription) and isEmptyProp(FTextEquivalent) and isEmptyProp(FcodeList) and isEmptyProp(FdocumentationList) and isEmptyProp(FconditionList) and isEmptyProp(FrelatedActionList) and isEmptyProp(FTiming) and isEmptyProp(FparticipantList) and isEmptyProp(FType_) and isEmptyProp(FGroupingBehavior) and isEmptyProp(FSelectionBehavior) and isEmptyProp(FRequiredBehavior) and isEmptyProp(FPrecheckBehavior) and isEmptyProp(FCardinalityBehavior) and isEmptyProp(FResource) and isEmptyProp(FactionList);
end;

procedure TFhirRequestGroupAction.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('label');
  fields.add('title');
  fields.add('description');
  fields.add('textEquivalent');
  fields.add('code');
  fields.add('documentation');
  fields.add('condition');
  fields.add('relatedAction');
  fields.add('timing[x]');
  fields.add('participant');
  fields.add('type');
  fields.add('groupingBehavior');
  fields.add('selectionBehavior');
  fields.add('requiredBehavior');
  fields.add('precheckBehavior');
  fields.add('cardinalityBehavior');
  fields.add('resource');
  fields.add('action');
end;

{ TFhirRequestGroupAction }

Procedure TFhirRequestGroupAction.SetLabel_(value : TFhirString);
begin
  FLabel_.free;
  FLabel_ := value;
end;

Function TFhirRequestGroupAction.GetLabel_ST : String;
begin
  if FLabel_ = nil then
    result := ''
  else
    result := FLabel_.value;
end;

Procedure TFhirRequestGroupAction.SetLabel_ST(value : String);
begin
  if value <> '' then
  begin
    if FLabel_ = nil then
      FLabel_ := TFhirString.create;
    FLabel_.value := value
  end
  else if FLabel_ <> nil then
    FLabel_.value := '';
end;

Procedure TFhirRequestGroupAction.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

Function TFhirRequestGroupAction.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

Procedure TFhirRequestGroupAction.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

Procedure TFhirRequestGroupAction.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirRequestGroupAction.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirRequestGroupAction.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirRequestGroupAction.SetTextEquivalent(value : TFhirString);
begin
  FTextEquivalent.free;
  FTextEquivalent := value;
end;

Function TFhirRequestGroupAction.GetTextEquivalentST : String;
begin
  if FTextEquivalent = nil then
    result := ''
  else
    result := FTextEquivalent.value;
end;

Procedure TFhirRequestGroupAction.SetTextEquivalentST(value : String);
begin
  if value <> '' then
  begin
    if FTextEquivalent = nil then
      FTextEquivalent := TFhirString.create;
    FTextEquivalent.value := value
  end
  else if FTextEquivalent <> nil then
    FTextEquivalent.value := '';
end;

Function TFhirRequestGroupAction.GetCodeList : TFhirCodeableConceptList;
begin
  if FCodeList = nil then
    FCodeList := TFhirCodeableConceptList.Create;
  result := FCodeList;
end;

Function TFhirRequestGroupAction.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

Function TFhirRequestGroupAction.GetDocumentationList : TFhirRelatedArtifactList;
begin
  if FDocumentationList = nil then
    FDocumentationList := TFhirRelatedArtifactList.Create;
  result := FDocumentationList;
end;

Function TFhirRequestGroupAction.GetHasDocumentationList : boolean;
begin
  result := (FDocumentationList <> nil) and (FDocumentationList.count > 0);
end;

Function TFhirRequestGroupAction.GetConditionList : TFhirRequestGroupActionConditionList;
begin
  if FConditionList = nil then
    FConditionList := TFhirRequestGroupActionConditionList.Create;
  result := FConditionList;
end;

Function TFhirRequestGroupAction.GetHasConditionList : boolean;
begin
  result := (FConditionList <> nil) and (FConditionList.count > 0);
end;

Function TFhirRequestGroupAction.GetRelatedActionList : TFhirRequestGroupActionRelatedActionList;
begin
  if FRelatedActionList = nil then
    FRelatedActionList := TFhirRequestGroupActionRelatedActionList.Create;
  result := FRelatedActionList;
end;

Function TFhirRequestGroupAction.GetHasRelatedActionList : boolean;
begin
  result := (FRelatedActionList <> nil) and (FRelatedActionList.count > 0);
end;

Procedure TFhirRequestGroupAction.SetTiming(value : TFhirType);
begin
  FTiming.free;
  FTiming := value;
end;

Function TFhirRequestGroupAction.GetParticipantList : TFhirReferenceList{Resource};
begin
  if FParticipantList = nil then
    FParticipantList := TFhirReferenceList{Resource}.Create;
  result := FParticipantList;
end;

Function TFhirRequestGroupAction.GetHasParticipantList : boolean;
begin
  result := (FParticipantList <> nil) and (FParticipantList.count > 0);
end;

Procedure TFhirRequestGroupAction.SetType_(value : TFhirCoding);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirRequestGroupAction.SetGroupingBehavior(value : TFhirEnum);
begin
  FGroupingBehavior.free;
  FGroupingBehavior := value;
end;

Function TFhirRequestGroupAction.GetGroupingBehaviorST : TFhirActionGroupingBehaviorEnum;
begin
  if FGroupingBehavior = nil then
    result := TFhirActionGroupingBehaviorEnum(0)
  else
    result := TFhirActionGroupingBehaviorEnum(StringArrayIndexOfSensitive(CODES_TFhirActionGroupingBehaviorEnum, FGroupingBehavior.value));
end;

Procedure TFhirRequestGroupAction.SetGroupingBehaviorST(value : TFhirActionGroupingBehaviorEnum);
begin
  if ord(value) = 0 then
    GroupingBehaviorElement := nil
  else
    GroupingBehaviorElement := TFhirEnum.create(SYSTEMS_TFhirActionGroupingBehaviorEnum[value], CODES_TFhirActionGroupingBehaviorEnum[value]);
end;

Procedure TFhirRequestGroupAction.SetSelectionBehavior(value : TFhirEnum);
begin
  FSelectionBehavior.free;
  FSelectionBehavior := value;
end;

Function TFhirRequestGroupAction.GetSelectionBehaviorST : TFhirActionSelectionBehaviorEnum;
begin
  if FSelectionBehavior = nil then
    result := TFhirActionSelectionBehaviorEnum(0)
  else
    result := TFhirActionSelectionBehaviorEnum(StringArrayIndexOfSensitive(CODES_TFhirActionSelectionBehaviorEnum, FSelectionBehavior.value));
end;

Procedure TFhirRequestGroupAction.SetSelectionBehaviorST(value : TFhirActionSelectionBehaviorEnum);
begin
  if ord(value) = 0 then
    SelectionBehaviorElement := nil
  else
    SelectionBehaviorElement := TFhirEnum.create(SYSTEMS_TFhirActionSelectionBehaviorEnum[value], CODES_TFhirActionSelectionBehaviorEnum[value]);
end;

Procedure TFhirRequestGroupAction.SetRequiredBehavior(value : TFhirEnum);
begin
  FRequiredBehavior.free;
  FRequiredBehavior := value;
end;

Function TFhirRequestGroupAction.GetRequiredBehaviorST : TFhirActionRequiredBehaviorEnum;
begin
  if FRequiredBehavior = nil then
    result := TFhirActionRequiredBehaviorEnum(0)
  else
    result := TFhirActionRequiredBehaviorEnum(StringArrayIndexOfSensitive(CODES_TFhirActionRequiredBehaviorEnum, FRequiredBehavior.value));
end;

Procedure TFhirRequestGroupAction.SetRequiredBehaviorST(value : TFhirActionRequiredBehaviorEnum);
begin
  if ord(value) = 0 then
    RequiredBehaviorElement := nil
  else
    RequiredBehaviorElement := TFhirEnum.create(SYSTEMS_TFhirActionRequiredBehaviorEnum[value], CODES_TFhirActionRequiredBehaviorEnum[value]);
end;

Procedure TFhirRequestGroupAction.SetPrecheckBehavior(value : TFhirEnum);
begin
  FPrecheckBehavior.free;
  FPrecheckBehavior := value;
end;

Function TFhirRequestGroupAction.GetPrecheckBehaviorST : TFhirActionPrecheckBehaviorEnum;
begin
  if FPrecheckBehavior = nil then
    result := TFhirActionPrecheckBehaviorEnum(0)
  else
    result := TFhirActionPrecheckBehaviorEnum(StringArrayIndexOfSensitive(CODES_TFhirActionPrecheckBehaviorEnum, FPrecheckBehavior.value));
end;

Procedure TFhirRequestGroupAction.SetPrecheckBehaviorST(value : TFhirActionPrecheckBehaviorEnum);
begin
  if ord(value) = 0 then
    PrecheckBehaviorElement := nil
  else
    PrecheckBehaviorElement := TFhirEnum.create(SYSTEMS_TFhirActionPrecheckBehaviorEnum[value], CODES_TFhirActionPrecheckBehaviorEnum[value]);
end;

Procedure TFhirRequestGroupAction.SetCardinalityBehavior(value : TFhirEnum);
begin
  FCardinalityBehavior.free;
  FCardinalityBehavior := value;
end;

Function TFhirRequestGroupAction.GetCardinalityBehaviorST : TFhirActionCardinalityBehaviorEnum;
begin
  if FCardinalityBehavior = nil then
    result := TFhirActionCardinalityBehaviorEnum(0)
  else
    result := TFhirActionCardinalityBehaviorEnum(StringArrayIndexOfSensitive(CODES_TFhirActionCardinalityBehaviorEnum, FCardinalityBehavior.value));
end;

Procedure TFhirRequestGroupAction.SetCardinalityBehaviorST(value : TFhirActionCardinalityBehaviorEnum);
begin
  if ord(value) = 0 then
    CardinalityBehaviorElement := nil
  else
    CardinalityBehaviorElement := TFhirEnum.create(SYSTEMS_TFhirActionCardinalityBehaviorEnum[value], CODES_TFhirActionCardinalityBehaviorEnum[value]);
end;

Procedure TFhirRequestGroupAction.SetResource(value : TFhirReference{TFhirReference});
begin
  FResource.free;
  FResource := value;
end;

Function TFhirRequestGroupAction.GetActionList : TFhirRequestGroupActionList;
begin
  if FActionList = nil then
    FActionList := TFhirRequestGroupActionList.Create;
  result := FActionList;
end;

Function TFhirRequestGroupAction.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

function TFhirRequestGroupAction.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FLabel_.sizeInBytes);
  inc(result, FTitle.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FTextEquivalent.sizeInBytes);
  inc(result, FcodeList.sizeInBytes);
  inc(result, FdocumentationList.sizeInBytes);
  inc(result, FconditionList.sizeInBytes);
  inc(result, FrelatedActionList.sizeInBytes);
  inc(result, FTiming.sizeInBytes);
  inc(result, FparticipantList.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FGroupingBehavior.sizeInBytes);
  inc(result, FSelectionBehavior.sizeInBytes);
  inc(result, FRequiredBehavior.sizeInBytes);
  inc(result, FPrecheckBehavior.sizeInBytes);
  inc(result, FCardinalityBehavior.sizeInBytes);
  inc(result, FResource.sizeInBytes);
  inc(result, FactionList.sizeInBytes);
end;

{ TFhirRequestGroupActionListEnumerator }

Constructor TFhirRequestGroupActionListEnumerator.Create(list : TFhirRequestGroupActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRequestGroupActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRequestGroupActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRequestGroupActionListEnumerator.GetCurrent : TFhirRequestGroupAction;
begin
  Result := FList[FIndex];
end;

function TFhirRequestGroupActionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirRequestGroupActionList }
procedure TFhirRequestGroupActionList.AddItem(value: TFhirRequestGroupAction);
begin
  assert(value.ClassName = 'TFhirRequestGroupAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRequestGroupAction');
  add(value);
end;

function TFhirRequestGroupActionList.Append: TFhirRequestGroupAction;
begin
  result := TFhirRequestGroupAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestGroupActionList.ClearItems;
begin
  Clear;
end;

function TFhirRequestGroupActionList.GetEnumerator : TFhirRequestGroupActionListEnumerator;
begin
  result := TFhirRequestGroupActionListEnumerator.Create(self.link);
end;

function TFhirRequestGroupActionList.Clone: TFhirRequestGroupActionList;
begin
  result := TFhirRequestGroupActionList(inherited Clone);
end;

function TFhirRequestGroupActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRequestGroupActionList.GetItemN(index: Integer): TFhirRequestGroupAction;
begin
  result := TFhirRequestGroupAction(ObjectByIndex[index]);
end;

function TFhirRequestGroupActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirRequestGroupAction;
end;
function TFhirRequestGroupActionList.IndexOf(value: TFhirRequestGroupAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRequestGroupActionList.Insert(index: Integer): TFhirRequestGroupAction;
begin
  result := TFhirRequestGroupAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestGroupActionList.InsertItem(index: Integer; value: TFhirRequestGroupAction);
begin
  assert(value is TFhirRequestGroupAction);
  Inherited Insert(index, value);
end;

function TFhirRequestGroupActionList.Item(index: Integer): TFhirRequestGroupAction;
begin
  result := TFhirRequestGroupAction(ObjectByIndex[index]);
end;

function TFhirRequestGroupActionList.Link: TFhirRequestGroupActionList;
begin
  result := TFhirRequestGroupActionList(inherited Link);
end;

procedure TFhirRequestGroupActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRequestGroupActionList.SetItemByIndex(index: Integer; value: TFhirRequestGroupAction);
begin
  assert(value is TFhirRequestGroupAction);
  FhirRequestGroupActions[index] := value;
end;

procedure TFhirRequestGroupActionList.SetItemN(index: Integer; value: TFhirRequestGroupAction);
begin
  assert(value is TFhirRequestGroupAction);
  ObjectByIndex[index] := value;
end;

{ TFhirRequestGroupActionCondition }

constructor TFhirRequestGroupActionCondition.Create;
begin
  inherited;
end;

destructor TFhirRequestGroupActionCondition.Destroy;
begin
  FKind.free;
  FDescription.free;
  FLanguage.free;
  FExpression.free;
  inherited;
end;

procedure TFhirRequestGroupActionCondition.Assign(oSource : TFslObject);
begin
  inherited;
  FKind := TFhirRequestGroupActionCondition(oSource).FKind.Link;
  descriptionElement := TFhirRequestGroupActionCondition(oSource).descriptionElement.Clone;
  languageElement := TFhirRequestGroupActionCondition(oSource).languageElement.Clone;
  expressionElement := TFhirRequestGroupActionCondition(oSource).expressionElement.Clone;
end;

procedure TFhirRequestGroupActionCondition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'kind') Then
     list.add(self.link, 'kind', FKind.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'language') Then
     list.add(self.link, 'language', FLanguage.Link);
  if (child_name = 'expression') Then
     list.add(self.link, 'expression', FExpression.Link);
end;

procedure TFhirRequestGroupActionCondition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'kind', 'code', false, TFHIREnum, FKind.Link));{1}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'language', 'string', false, TFhirString, FLanguage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'expression', 'string', false, TFhirString, FExpression.Link));{2}
end;

function TFhirRequestGroupActionCondition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'kind') then
  begin
    KindElement := asEnum(SYSTEMS_TFhirActionConditionKindEnum, CODES_TFhirActionConditionKindEnum, propValue);
    result := propValue
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'language') then
  begin
    LanguageElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'expression') then
  begin
    ExpressionElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRequestGroupActionCondition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirRequestGroupActionCondition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'language') then result := TFhirString.create() {5b}
  else if (propName = 'expression') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirRequestGroupActionCondition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'kind') then result := 'code'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'language') then result := 'string'
  else if (propName = 'expression') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRequestGroupActionCondition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'kind') then KindElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'language') then LanguageElement := nil
  else if (propName = 'expression') then ExpressionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRequestGroupActionCondition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'kind') then KindElement := asEnum(SYSTEMS_TFhirActionConditionKindEnum, CODES_TFhirActionConditionKindEnum, new){4}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'language') then LanguageElement := asString(new){5b}
  else if (propName = 'expression') then ExpressionElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRequestGroupActionCondition.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirRequestGroupActionCondition.fhirType : string;
begin
  result := 'condition';
end;

function TFhirRequestGroupActionCondition.Link : TFhirRequestGroupActionCondition;
begin
  result := TFhirRequestGroupActionCondition(inherited Link);
end;

function TFhirRequestGroupActionCondition.Clone : TFhirRequestGroupActionCondition;
begin
  result := TFhirRequestGroupActionCondition(inherited Clone);
end;

function TFhirRequestGroupActionCondition.equals(other : TObject) : boolean;
var
  o : TFhirRequestGroupActionCondition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRequestGroupActionCondition)) then
    result := false
  else
  begin
    o := TFhirRequestGroupActionCondition(other);
    result := compareDeep(kindElement, o.kindElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and
      compareDeep(languageElement, o.languageElement, true) and compareDeep(expressionElement, o.expressionElement, true);
  end;
end;

function TFhirRequestGroupActionCondition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FKind) and isEmptyProp(FDescription) and isEmptyProp(FLanguage) and isEmptyProp(FExpression);
end;

procedure TFhirRequestGroupActionCondition.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('kind');
  fields.add('description');
  fields.add('language');
  fields.add('expression');
end;

{ TFhirRequestGroupActionCondition }

Procedure TFhirRequestGroupActionCondition.SetKind(value : TFhirEnum);
begin
  FKind.free;
  FKind := value;
end;

Function TFhirRequestGroupActionCondition.GetKindST : TFhirActionConditionKindEnum;
begin
  if FKind = nil then
    result := TFhirActionConditionKindEnum(0)
  else
    result := TFhirActionConditionKindEnum(StringArrayIndexOfSensitive(CODES_TFhirActionConditionKindEnum, FKind.value));
end;

Procedure TFhirRequestGroupActionCondition.SetKindST(value : TFhirActionConditionKindEnum);
begin
  if ord(value) = 0 then
    KindElement := nil
  else
    KindElement := TFhirEnum.create(SYSTEMS_TFhirActionConditionKindEnum[value], CODES_TFhirActionConditionKindEnum[value]);
end;

Procedure TFhirRequestGroupActionCondition.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirRequestGroupActionCondition.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirRequestGroupActionCondition.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirRequestGroupActionCondition.SetLanguage(value : TFhirString);
begin
  FLanguage.free;
  FLanguage := value;
end;

Function TFhirRequestGroupActionCondition.GetLanguageST : String;
begin
  if FLanguage = nil then
    result := ''
  else
    result := FLanguage.value;
end;

Procedure TFhirRequestGroupActionCondition.SetLanguageST(value : String);
begin
  if value <> '' then
  begin
    if FLanguage = nil then
      FLanguage := TFhirString.create;
    FLanguage.value := value
  end
  else if FLanguage <> nil then
    FLanguage.value := '';
end;

Procedure TFhirRequestGroupActionCondition.SetExpression(value : TFhirString);
begin
  FExpression.free;
  FExpression := value;
end;

Function TFhirRequestGroupActionCondition.GetExpressionST : String;
begin
  if FExpression = nil then
    result := ''
  else
    result := FExpression.value;
end;

Procedure TFhirRequestGroupActionCondition.SetExpressionST(value : String);
begin
  if value <> '' then
  begin
    if FExpression = nil then
      FExpression := TFhirString.create;
    FExpression.value := value
  end
  else if FExpression <> nil then
    FExpression.value := '';
end;

function TFhirRequestGroupActionCondition.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FKind.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FLanguage.sizeInBytes);
  inc(result, FExpression.sizeInBytes);
end;

{ TFhirRequestGroupActionConditionListEnumerator }

Constructor TFhirRequestGroupActionConditionListEnumerator.Create(list : TFhirRequestGroupActionConditionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRequestGroupActionConditionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRequestGroupActionConditionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRequestGroupActionConditionListEnumerator.GetCurrent : TFhirRequestGroupActionCondition;
begin
  Result := FList[FIndex];
end;

function TFhirRequestGroupActionConditionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirRequestGroupActionConditionList }
procedure TFhirRequestGroupActionConditionList.AddItem(value: TFhirRequestGroupActionCondition);
begin
  assert(value.ClassName = 'TFhirRequestGroupActionCondition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRequestGroupActionCondition');
  add(value);
end;

function TFhirRequestGroupActionConditionList.Append: TFhirRequestGroupActionCondition;
begin
  result := TFhirRequestGroupActionCondition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestGroupActionConditionList.ClearItems;
begin
  Clear;
end;

function TFhirRequestGroupActionConditionList.GetEnumerator : TFhirRequestGroupActionConditionListEnumerator;
begin
  result := TFhirRequestGroupActionConditionListEnumerator.Create(self.link);
end;

function TFhirRequestGroupActionConditionList.Clone: TFhirRequestGroupActionConditionList;
begin
  result := TFhirRequestGroupActionConditionList(inherited Clone);
end;

function TFhirRequestGroupActionConditionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRequestGroupActionConditionList.GetItemN(index: Integer): TFhirRequestGroupActionCondition;
begin
  result := TFhirRequestGroupActionCondition(ObjectByIndex[index]);
end;

function TFhirRequestGroupActionConditionList.ItemClass: TFslObjectClass;
begin
  result := TFhirRequestGroupActionCondition;
end;
function TFhirRequestGroupActionConditionList.IndexOf(value: TFhirRequestGroupActionCondition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRequestGroupActionConditionList.Insert(index: Integer): TFhirRequestGroupActionCondition;
begin
  result := TFhirRequestGroupActionCondition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestGroupActionConditionList.InsertItem(index: Integer; value: TFhirRequestGroupActionCondition);
begin
  assert(value is TFhirRequestGroupActionCondition);
  Inherited Insert(index, value);
end;

function TFhirRequestGroupActionConditionList.Item(index: Integer): TFhirRequestGroupActionCondition;
begin
  result := TFhirRequestGroupActionCondition(ObjectByIndex[index]);
end;

function TFhirRequestGroupActionConditionList.Link: TFhirRequestGroupActionConditionList;
begin
  result := TFhirRequestGroupActionConditionList(inherited Link);
end;

procedure TFhirRequestGroupActionConditionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRequestGroupActionConditionList.SetItemByIndex(index: Integer; value: TFhirRequestGroupActionCondition);
begin
  assert(value is TFhirRequestGroupActionCondition);
  FhirRequestGroupActionConditions[index] := value;
end;

procedure TFhirRequestGroupActionConditionList.SetItemN(index: Integer; value: TFhirRequestGroupActionCondition);
begin
  assert(value is TFhirRequestGroupActionCondition);
  ObjectByIndex[index] := value;
end;

{ TFhirRequestGroupActionRelatedAction }

constructor TFhirRequestGroupActionRelatedAction.Create;
begin
  inherited;
end;

destructor TFhirRequestGroupActionRelatedAction.Destroy;
begin
  FActionId.free;
  FRelationship.free;
  FOffset.free;
  inherited;
end;

procedure TFhirRequestGroupActionRelatedAction.Assign(oSource : TFslObject);
begin
  inherited;
  actionIdElement := TFhirRequestGroupActionRelatedAction(oSource).actionIdElement.Clone;
  FRelationship := TFhirRequestGroupActionRelatedAction(oSource).FRelationship.Link;
  offset := TFhirRequestGroupActionRelatedAction(oSource).offset.Clone;
end;

procedure TFhirRequestGroupActionRelatedAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'actionId') Then
     list.add(self.link, 'actionId', FActionId.Link);
  if (child_name = 'relationship') Then
     list.add(self.link, 'relationship', FRelationship.Link);
  if (child_name = 'offset[x]') or (child_name = 'offset') Then
     list.add(self.link, 'offset[x]', FOffset.Link);
end;

procedure TFhirRequestGroupActionRelatedAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'actionId', 'id', false, TFhirId, FActionId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'relationship', 'code', false, TFHIREnum, FRelationship.Link));{1}
  oList.add(TFHIRProperty.create(self, 'offset[x]', 'Duration|Range', false, TFhirType, FOffset.Link));{2}
end;

function TFhirRequestGroupActionRelatedAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'actionId') then
  begin
    ActionIdElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'relationship') then
  begin
    RelationshipElement := asEnum(SYSTEMS_TFhirActionRelationshipTypeEnum, CODES_TFhirActionRelationshipTypeEnum, propValue);
    result := propValue
  end
  else if (isMatchingName(propName, 'offset', ['Duration', 'Range'])) then
  begin
    Offset := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRequestGroupActionRelatedAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirRequestGroupActionRelatedAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'actionId') then result := TFhirId.create() {5b}
  else if (isMatchingName(propName, 'offset', ['Duration', 'Range'])) then raise EFHIRException.create('Cannot make property Offset'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirRequestGroupActionRelatedAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'actionId') then result := 'id'
  else if (propName = 'relationship') then result := 'code'
  else if (propName = 'offset[x]') then result := 'Duration|Range'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRequestGroupActionRelatedAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'actionId') then ActionIdElement := nil
  else if (propName = 'relationship') then RelationshipElement := nil
  else if (isMatchingName(propName, 'offset', ['Duration', 'Range'])) then OffsetElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRequestGroupActionRelatedAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'actionId') then ActionIdElement := asId(new){5b}
  else if (propName = 'relationship') then RelationshipElement := asEnum(SYSTEMS_TFhirActionRelationshipTypeEnum, CODES_TFhirActionRelationshipTypeEnum, new){4}
  else if (isMatchingName(propName, 'offset', ['Duration', 'Range'])) then OffsetElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRequestGroupActionRelatedAction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirRequestGroupActionRelatedAction.fhirType : string;
begin
  result := 'relatedAction';
end;

function TFhirRequestGroupActionRelatedAction.Link : TFhirRequestGroupActionRelatedAction;
begin
  result := TFhirRequestGroupActionRelatedAction(inherited Link);
end;

function TFhirRequestGroupActionRelatedAction.Clone : TFhirRequestGroupActionRelatedAction;
begin
  result := TFhirRequestGroupActionRelatedAction(inherited Clone);
end;

function TFhirRequestGroupActionRelatedAction.equals(other : TObject) : boolean;
var
  o : TFhirRequestGroupActionRelatedAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRequestGroupActionRelatedAction)) then
    result := false
  else
  begin
    o := TFhirRequestGroupActionRelatedAction(other);
    result := compareDeep(actionIdElement, o.actionIdElement, true) and compareDeep(relationshipElement, o.relationshipElement, true) and
      compareDeep(offsetElement, o.offsetElement, true);
  end;
end;

function TFhirRequestGroupActionRelatedAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FActionId) and isEmptyProp(FRelationship) and isEmptyProp(FOffset);
end;

procedure TFhirRequestGroupActionRelatedAction.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('actionId');
  fields.add('relationship');
  fields.add('offset[x]');
end;

{ TFhirRequestGroupActionRelatedAction }

Procedure TFhirRequestGroupActionRelatedAction.SetActionId(value : TFhirId);
begin
  FActionId.free;
  FActionId := value;
end;

Function TFhirRequestGroupActionRelatedAction.GetActionIdST : String;
begin
  if FActionId = nil then
    result := ''
  else
    result := FActionId.value;
end;

Procedure TFhirRequestGroupActionRelatedAction.SetActionIdST(value : String);
begin
  if value <> '' then
  begin
    if FActionId = nil then
      FActionId := TFhirId.create;
    FActionId.value := value
  end
  else if FActionId <> nil then
    FActionId.value := '';
end;

Procedure TFhirRequestGroupActionRelatedAction.SetRelationship(value : TFhirEnum);
begin
  FRelationship.free;
  FRelationship := value;
end;

Function TFhirRequestGroupActionRelatedAction.GetRelationshipST : TFhirActionRelationshipTypeEnum;
begin
  if FRelationship = nil then
    result := TFhirActionRelationshipTypeEnum(0)
  else
    result := TFhirActionRelationshipTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirActionRelationshipTypeEnum, FRelationship.value));
end;

Procedure TFhirRequestGroupActionRelatedAction.SetRelationshipST(value : TFhirActionRelationshipTypeEnum);
begin
  if ord(value) = 0 then
    RelationshipElement := nil
  else
    RelationshipElement := TFhirEnum.create(SYSTEMS_TFhirActionRelationshipTypeEnum[value], CODES_TFhirActionRelationshipTypeEnum[value]);
end;

Procedure TFhirRequestGroupActionRelatedAction.SetOffset(value : TFhirType);
begin
  FOffset.free;
  FOffset := value;
end;

function TFhirRequestGroupActionRelatedAction.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FActionId.sizeInBytes);
  inc(result, FRelationship.sizeInBytes);
  inc(result, FOffset.sizeInBytes);
end;

{ TFhirRequestGroupActionRelatedActionListEnumerator }

Constructor TFhirRequestGroupActionRelatedActionListEnumerator.Create(list : TFhirRequestGroupActionRelatedActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRequestGroupActionRelatedActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRequestGroupActionRelatedActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRequestGroupActionRelatedActionListEnumerator.GetCurrent : TFhirRequestGroupActionRelatedAction;
begin
  Result := FList[FIndex];
end;

function TFhirRequestGroupActionRelatedActionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirRequestGroupActionRelatedActionList }
procedure TFhirRequestGroupActionRelatedActionList.AddItem(value: TFhirRequestGroupActionRelatedAction);
begin
  assert(value.ClassName = 'TFhirRequestGroupActionRelatedAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRequestGroupActionRelatedAction');
  add(value);
end;

function TFhirRequestGroupActionRelatedActionList.Append: TFhirRequestGroupActionRelatedAction;
begin
  result := TFhirRequestGroupActionRelatedAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestGroupActionRelatedActionList.ClearItems;
begin
  Clear;
end;

function TFhirRequestGroupActionRelatedActionList.GetEnumerator : TFhirRequestGroupActionRelatedActionListEnumerator;
begin
  result := TFhirRequestGroupActionRelatedActionListEnumerator.Create(self.link);
end;

function TFhirRequestGroupActionRelatedActionList.Clone: TFhirRequestGroupActionRelatedActionList;
begin
  result := TFhirRequestGroupActionRelatedActionList(inherited Clone);
end;

function TFhirRequestGroupActionRelatedActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRequestGroupActionRelatedActionList.GetItemN(index: Integer): TFhirRequestGroupActionRelatedAction;
begin
  result := TFhirRequestGroupActionRelatedAction(ObjectByIndex[index]);
end;

function TFhirRequestGroupActionRelatedActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirRequestGroupActionRelatedAction;
end;
function TFhirRequestGroupActionRelatedActionList.IndexOf(value: TFhirRequestGroupActionRelatedAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRequestGroupActionRelatedActionList.Insert(index: Integer): TFhirRequestGroupActionRelatedAction;
begin
  result := TFhirRequestGroupActionRelatedAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestGroupActionRelatedActionList.InsertItem(index: Integer; value: TFhirRequestGroupActionRelatedAction);
begin
  assert(value is TFhirRequestGroupActionRelatedAction);
  Inherited Insert(index, value);
end;

function TFhirRequestGroupActionRelatedActionList.Item(index: Integer): TFhirRequestGroupActionRelatedAction;
begin
  result := TFhirRequestGroupActionRelatedAction(ObjectByIndex[index]);
end;

function TFhirRequestGroupActionRelatedActionList.Link: TFhirRequestGroupActionRelatedActionList;
begin
  result := TFhirRequestGroupActionRelatedActionList(inherited Link);
end;

procedure TFhirRequestGroupActionRelatedActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRequestGroupActionRelatedActionList.SetItemByIndex(index: Integer; value: TFhirRequestGroupActionRelatedAction);
begin
  assert(value is TFhirRequestGroupActionRelatedAction);
  FhirRequestGroupActionRelatedActions[index] := value;
end;

procedure TFhirRequestGroupActionRelatedActionList.SetItemN(index: Integer; value: TFhirRequestGroupActionRelatedAction);
begin
  assert(value is TFhirRequestGroupActionRelatedAction);
  ObjectByIndex[index] := value;
end;

{ TFhirRequestGroup }

constructor TFhirRequestGroup.Create;
begin
  inherited;
end;

destructor TFhirRequestGroup.Destroy;
begin
  FIdentifierList.Free;
  FDefinitionList.Free;
  FBasedOnList.Free;
  FReplacesList.Free;
  FGroupIdentifier.free;
  FStatus.free;
  FIntent.free;
  FPriority.free;
  FSubject.free;
  FContext.free;
  FAuthoredOn.free;
  FAuthor.free;
  FReason.free;
  FNoteList.Free;
  FActionList.Free;
  inherited;
end;

function TFhirRequestGroup.GetResourceType : TFhirResourceType;
begin
  result := frtRequestGroup;
end;

procedure TFhirRequestGroup.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirRequestGroup(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirRequestGroup(oSource).FIdentifierList);
  end;
  if (TFhirRequestGroup(oSource).FDefinitionList = nil) then
  begin
    FDefinitionList.free;
    FDefinitionList := nil;
  end
  else
  begin
    if FDefinitionList = nil then
      FDefinitionList := TFhirReferenceList{TFhirReference}.Create;
    FDefinitionList.Assign(TFhirRequestGroup(oSource).FDefinitionList);
  end;
  if (TFhirRequestGroup(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList{TFhirReference}.Create;
    FBasedOnList.Assign(TFhirRequestGroup(oSource).FBasedOnList);
  end;
  if (TFhirRequestGroup(oSource).FReplacesList = nil) then
  begin
    FReplacesList.free;
    FReplacesList := nil;
  end
  else
  begin
    if FReplacesList = nil then
      FReplacesList := TFhirReferenceList{TFhirReference}.Create;
    FReplacesList.Assign(TFhirRequestGroup(oSource).FReplacesList);
  end;
  groupIdentifier := TFhirRequestGroup(oSource).groupIdentifier.Clone;
  FStatus := TFhirRequestGroup(oSource).FStatus.Link;
  FIntent := TFhirRequestGroup(oSource).FIntent.Link;
  FPriority := TFhirRequestGroup(oSource).FPriority.Link;
  subject := TFhirRequestGroup(oSource).subject.Clone;
  context := TFhirRequestGroup(oSource).context.Clone;
  authoredOnElement := TFhirRequestGroup(oSource).authoredOnElement.Clone;
  author := TFhirRequestGroup(oSource).author.Clone;
  reason := TFhirRequestGroup(oSource).reason.Clone;
  if (TFhirRequestGroup(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirRequestGroup(oSource).FNoteList);
  end;
  if (TFhirRequestGroup(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirRequestGroupActionList.Create;
    FActionList.Assign(TFhirRequestGroup(oSource).FActionList);
  end;
end;

procedure TFhirRequestGroup.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'definition') Then
    list.addAll(self, 'definition', FDefinitionList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'replaces') Then
    list.addAll(self, 'replaces', FReplacesList);
  if (child_name = 'groupIdentifier') Then
     list.add(self.link, 'groupIdentifier', FGroupIdentifier.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'intent') Then
     list.add(self.link, 'intent', FIntent.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
  if (child_name = 'authoredOn') Then
     list.add(self.link, 'authoredOn', FAuthoredOn.Link);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
  if (child_name = 'reason[x]') or (child_name = 'reason') Then
     list.add(self.link, 'reason[x]', FReason.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
end;

procedure TFhirRequestGroup.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'definition', 'Reference(Any)', true, TFhirReference{TFhirReference}, FDefinitionList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference(Any)', true, TFhirReference{TFhirReference}, FBasedOnList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'replaces', 'Reference(Any)', true, TFhirReference{TFhirReference}, FReplacesList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'groupIdentifier', 'Identifier', false, TFhirIdentifier, FGroupIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFHIREnum, FStatus.Link));{1}
  oList.add(TFHIRProperty.create(self, 'intent', 'code', false, TFHIREnum, FIntent.Link));{1}
  oList.add(TFHIRProperty.create(self, 'priority', 'code', false, TFHIREnum, FPriority.Link));{1}
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference(Patient|Group)', false, TFhirReference{Resource}, FSubject.Link));{2}
  oList.add(TFHIRProperty.create(self, 'context', 'Reference(Encounter|EpisodeOfCare)', false, TFhirReference{Resource}, FContext.Link));{2}
  oList.add(TFHIRProperty.create(self, 'authoredOn', 'dateTime', false, TFhirDateTime, FAuthoredOn.Link));{2}
  oList.add(TFHIRProperty.create(self, 'author', 'Reference(Device|Practitioner)', false, TFhirReference{Resource}, FAuthor.Link));{2}
  oList.add(TFHIRProperty.create(self, 'reason[x]', 'CodeableConcept|Reference(Any)', false, TFhirType, FReason.Link));{2}
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'action', '', true, TFhirRequestGroupAction, FActionList.Link)){3};
end;

function TFhirRequestGroup.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'definition') then
  begin
    DefinitionList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'replaces') then
  begin
    ReplacesList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'groupIdentifier') then
  begin
    GroupIdentifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirRequestStatusEnum, CODES_TFhirRequestStatusEnum, propValue);
    result := propValue
  end
  else if (propName = 'intent') then
  begin
    IntentElement := asEnum(SYSTEMS_TFhirRequestIntentEnum, CODES_TFhirRequestIntentEnum, propValue);
    result := propValue
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, propValue);
    result := propValue
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'context') then
  begin
    Context := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (propName = 'authoredOn') then
  begin
    AuthoredOnElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference{Resource}{4b};
    result := propValue;
  end
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then
  begin
    Reason := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation){2a};
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirRequestGroupAction){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirRequestGroup.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'definition') then DefinitionList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'replaces') then ReplacesList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation){2a}
  else if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirRequestGroupAction){2a}
  else inherited;
end;

function TFhirRequestGroup.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'definition') then result := DefinitionList.new(){2}
  else if (propName = 'basedOn') then result := BasedOnList.new(){2}
  else if (propName = 'replaces') then result := ReplacesList.new(){2}
  else if (propName = 'groupIdentifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'subject') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'context') then result := TFhirReference{Resource}.create(){4b}
  else if (propName = 'authoredOn') then result := TFhirDateTime.create() {5b}
  else if (propName = 'author') then result := TFhirReference{Resource}.create(){4b}
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Reason'){4x}
  else if (propName = 'note') then result := NoteList.new(){2}
  else if (propName = 'action') then result := ActionList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirRequestGroup.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'definition') then result := 'Reference'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'replaces') then result := 'Reference'
  else if (propName = 'groupIdentifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'intent') then result := 'code'
  else if (propName = 'priority') then result := 'code'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'context') then result := 'Reference'
  else if (propName = 'authoredOn') then result := 'dateTime'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'reason[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'action') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRequestGroup.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'definition') then deletePropertyValue('definition', DefinitionList, value) {2}
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value) {2}
  else if (propName = 'replaces') then deletePropertyValue('replaces', ReplacesList, value) {2}
  else if (propName = 'groupIdentifier') then GroupIdentifierElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'intent') then IntentElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'context') then ContextElement := nil
  else if (propName = 'authoredOn') then AuthoredOnElement := nil
  else if (propName = 'author') then AuthorElement := nil
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then ReasonElement := nil{4x}
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value) {2}
  else if (propName = 'action') then deletePropertyValue('action', ActionList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRequestGroup.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'definition') then replacePropertyValue('definition', DefinitionList, existing, new) {2}
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new) {2}
  else if (propName = 'replaces') then replacePropertyValue('replaces', ReplacesList, existing, new) {2}
  else if (propName = 'groupIdentifier') then GroupIdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirRequestStatusEnum, CODES_TFhirRequestStatusEnum, new){4}
  else if (propName = 'intent') then IntentElement := asEnum(SYSTEMS_TFhirRequestIntentEnum, CODES_TFhirRequestIntentEnum, new){4}
  else if (propName = 'priority') then PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, new){4}
  else if (propName = 'subject') then SubjectElement := new as TFhirReference{Resource}{4}
  else if (propName = 'context') then ContextElement := new as TFhirReference{Resource}{4}
  else if (propName = 'authoredOn') then AuthoredOnElement := asDateTime(new){5b}
  else if (propName = 'author') then AuthorElement := new as TFhirReference{Resource}{4}
  else if (isMatchingName(propName, 'reason', ['CodeableConcept', 'Reference'])) then ReasonElement := new as TFhirType{4x}
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new) {2}
  else if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRequestGroup.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'definition') then DefinitionList.move(source, destination){2a}
  else if (propName = 'basedOn') then BasedOnList.move(source, destination){2a}
  else if (propName = 'replaces') then ReplacesList.move(source, destination){2a}
  else if (propName = 'note') then NoteList.move(source, destination){2a}
  else if (propName = 'action') then ActionList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirRequestGroup.fhirType : string;
begin
  result := 'RequestGroup';
end;

function TFhirRequestGroup.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FdefinitionList) and isEmptyProp(FbasedOnList) and isEmptyProp(FreplacesList) and isEmptyProp(FGroupIdentifier) and isEmptyProp(FStatus) and isEmptyProp(FIntent) and isEmptyProp(FPriority) and isEmptyProp(FSubject) and isEmptyProp(FContext) and isEmptyProp(FAuthoredOn) and isEmptyProp(FAuthor) and isEmptyProp(FReason) and isEmptyProp(FnoteList) and isEmptyProp(FactionList);
end;

function TFhirRequestGroup.equals(other : TObject) : boolean;
var
  o : TFhirRequestGroup;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRequestGroup)) then
    result := false
  else
  begin
    o := TFhirRequestGroup(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(definitionList, o.definitionList, true) and
      compareDeep(basedOnList, o.basedOnList, true) and compareDeep(replacesList, o.replacesList, true) and
      compareDeep(groupIdentifierElement, o.groupIdentifierElement, true) and compareDeep(statusElement, o.statusElement, true) and
      compareDeep(intentElement, o.intentElement, true) and compareDeep(priorityElement, o.priorityElement, true) and
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(contextElement, o.contextElement, true) and
      compareDeep(authoredOnElement, o.authoredOnElement, true) and compareDeep(authorElement, o.authorElement, true) and
      compareDeep(reasonElement, o.reasonElement, true) and compareDeep(noteList, o.noteList, true) and
      compareDeep(actionList, o.actionList, true);
  end;
end;

function TFhirRequestGroup.Link : TFhirRequestGroup;
begin
  result := TFhirRequestGroup(inherited Link);
end;

function TFhirRequestGroup.Clone : TFhirRequestGroup;
begin
  result := TFhirRequestGroup(inherited Clone);
end;

procedure TFhirRequestGroup.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('definition');
  fields.add('basedOn');
  fields.add('replaces');
  fields.add('groupIdentifier');
  fields.add('status');
  fields.add('intent');
  fields.add('priority');
  fields.add('subject');
  fields.add('context');
  fields.add('authoredOn');
  fields.add('author');
  fields.add('reason[x]');
  fields.add('note');
  fields.add('action');
end;

{ TFhirRequestGroup }

Function TFhirRequestGroup.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirRequestGroup.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Function TFhirRequestGroup.GetDefinitionList : TFhirReferenceList{TFhirReference};
begin
  if FDefinitionList = nil then
    FDefinitionList := TFhirReferenceList{TFhirReference}.Create;
  result := FDefinitionList;
end;

Function TFhirRequestGroup.GetHasDefinitionList : boolean;
begin
  result := (FDefinitionList <> nil) and (FDefinitionList.count > 0);
end;

Function TFhirRequestGroup.GetBasedOnList : TFhirReferenceList{TFhirReference};
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList{TFhirReference}.Create;
  result := FBasedOnList;
end;

Function TFhirRequestGroup.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

Function TFhirRequestGroup.GetReplacesList : TFhirReferenceList{TFhirReference};
begin
  if FReplacesList = nil then
    FReplacesList := TFhirReferenceList{TFhirReference}.Create;
  result := FReplacesList;
end;

Function TFhirRequestGroup.GetHasReplacesList : boolean;
begin
  result := (FReplacesList <> nil) and (FReplacesList.count > 0);
end;

Procedure TFhirRequestGroup.SetGroupIdentifier(value : TFhirIdentifier);
begin
  FGroupIdentifier.free;
  FGroupIdentifier := value;
end;

Procedure TFhirRequestGroup.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

Function TFhirRequestGroup.GetStatusST : TFhirRequestStatusEnum;
begin
  if FStatus = nil then
    result := TFhirRequestStatusEnum(0)
  else
    result := TFhirRequestStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestStatusEnum, FStatus.value));
end;

Procedure TFhirRequestGroup.SetStatusST(value : TFhirRequestStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirRequestStatusEnum[value], CODES_TFhirRequestStatusEnum[value]);
end;

Procedure TFhirRequestGroup.SetIntent(value : TFhirEnum);
begin
  FIntent.free;
  FIntent := value;
end;

Function TFhirRequestGroup.GetIntentST : TFhirRequestIntentEnum;
begin
  if FIntent = nil then
    result := TFhirRequestIntentEnum(0)
  else
    result := TFhirRequestIntentEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestIntentEnum, FIntent.value));
end;

Procedure TFhirRequestGroup.SetIntentST(value : TFhirRequestIntentEnum);
begin
  if ord(value) = 0 then
    IntentElement := nil
  else
    IntentElement := TFhirEnum.create(SYSTEMS_TFhirRequestIntentEnum[value], CODES_TFhirRequestIntentEnum[value]);
end;

Procedure TFhirRequestGroup.SetPriority(value : TFhirEnum);
begin
  FPriority.free;
  FPriority := value;
end;

Function TFhirRequestGroup.GetPriorityST : TFhirRequestPriorityEnum;
begin
  if FPriority = nil then
    result := TFhirRequestPriorityEnum(0)
  else
    result := TFhirRequestPriorityEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestPriorityEnum, FPriority.value));
end;

Procedure TFhirRequestGroup.SetPriorityST(value : TFhirRequestPriorityEnum);
begin
  if ord(value) = 0 then
    PriorityElement := nil
  else
    PriorityElement := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[value], CODES_TFhirRequestPriorityEnum[value]);
end;

Procedure TFhirRequestGroup.SetSubject(value : TFhirReference{Resource});
begin
  FSubject.free;
  FSubject := value;
end;

Procedure TFhirRequestGroup.SetContext(value : TFhirReference{Resource});
begin
  FContext.free;
  FContext := value;
end;

Procedure TFhirRequestGroup.SetAuthoredOn(value : TFhirDateTime);
begin
  FAuthoredOn.free;
  FAuthoredOn := value;
end;

Function TFhirRequestGroup.GetAuthoredOnST : TFslDateTime;
begin
  if FAuthoredOn = nil then
    result := TFslDateTime.makeNull
  else
    result := FAuthoredOn.value;
end;

Procedure TFhirRequestGroup.SetAuthoredOnST(value : TFslDateTime);
begin
  if FAuthoredOn = nil then
    FAuthoredOn := TFhirDateTime.create;
  FAuthoredOn.value := value
end;

Procedure TFhirRequestGroup.SetAuthor(value : TFhirReference{Resource});
begin
  FAuthor.free;
  FAuthor := value;
end;

Procedure TFhirRequestGroup.SetReason(value : TFhirType);
begin
  FReason.free;
  FReason := value;
end;

Function TFhirRequestGroup.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

Function TFhirRequestGroup.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

Function TFhirRequestGroup.GetActionList : TFhirRequestGroupActionList;
begin
  if FActionList = nil then
    FActionList := TFhirRequestGroupActionList.Create;
  result := FActionList;
end;

Function TFhirRequestGroup.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

function TFhirRequestGroup.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FdefinitionList.sizeInBytes);
  inc(result, FbasedOnList.sizeInBytes);
  inc(result, FreplacesList.sizeInBytes);
  inc(result, FGroupIdentifier.sizeInBytes);
  inc(result, FStatus.sizeInBytes);
  inc(result, FIntent.sizeInBytes);
  inc(result, FPriority.sizeInBytes);
  inc(result, FSubject.sizeInBytes);
  inc(result, FContext.sizeInBytes);
  inc(result, FAuthoredOn.sizeInBytes);
  inc(result, FAuthor.sizeInBytes);
  inc(result, FReason.sizeInBytes);
  inc(result, FnoteList.sizeInBytes);
  inc(result, FactionList.sizeInBytes);
end;

{ TFhirRequestGroupListEnumerator }

Constructor TFhirRequestGroupListEnumerator.Create(list : TFhirRequestGroupList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRequestGroupListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRequestGroupListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRequestGroupListEnumerator.GetCurrent : TFhirRequestGroup;
begin
  Result := FList[FIndex];
end;

function TFhirRequestGroupListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirRequestGroupList }
procedure TFhirRequestGroupList.AddItem(value: TFhirRequestGroup);
begin
  assert(value.ClassName = 'TFhirRequestGroup', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRequestGroup');
  add(value);
end;

function TFhirRequestGroupList.Append: TFhirRequestGroup;
begin
  result := TFhirRequestGroup.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestGroupList.ClearItems;
begin
  Clear;
end;

function TFhirRequestGroupList.GetEnumerator : TFhirRequestGroupListEnumerator;
begin
  result := TFhirRequestGroupListEnumerator.Create(self.link);
end;

function TFhirRequestGroupList.Clone: TFhirRequestGroupList;
begin
  result := TFhirRequestGroupList(inherited Clone);
end;

function TFhirRequestGroupList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRequestGroupList.GetItemN(index: Integer): TFhirRequestGroup;
begin
  result := TFhirRequestGroup(ObjectByIndex[index]);
end;

function TFhirRequestGroupList.ItemClass: TFslObjectClass;
begin
  result := TFhirRequestGroup;
end;
function TFhirRequestGroupList.IndexOf(value: TFhirRequestGroup): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRequestGroupList.Insert(index: Integer): TFhirRequestGroup;
begin
  result := TFhirRequestGroup.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestGroupList.InsertItem(index: Integer; value: TFhirRequestGroup);
begin
  assert(value is TFhirRequestGroup);
  Inherited Insert(index, value);
end;

function TFhirRequestGroupList.Item(index: Integer): TFhirRequestGroup;
begin
  result := TFhirRequestGroup(ObjectByIndex[index]);
end;

function TFhirRequestGroupList.Link: TFhirRequestGroupList;
begin
  result := TFhirRequestGroupList(inherited Link);
end;

procedure TFhirRequestGroupList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRequestGroupList.SetItemByIndex(index: Integer; value: TFhirRequestGroup);
begin
  assert(value is TFhirRequestGroup);
  FhirRequestGroups[index] := value;
end;

procedure TFhirRequestGroupList.SetItemN(index: Integer; value: TFhirRequestGroup);
begin
  assert(value is TFhirRequestGroup);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_REQUESTGROUP}

{$IFDEF FHIR_SEARCHPARAMETER}

{ TFhirSearchParameterComponent }

constructor TFhirSearchParameterComponent.Create;
begin
  inherited;
end;

destructor TFhirSearchParameterComponent.Destroy;
begin
  FDefinition.free;
  FExpression.free;
  inherited;
end;

procedure TFhirSearchParameterComponent.Assign(oSource : TFslObject);
begin
  inherited;
  definition := TFhirSearchParameterComponent(oSource).definition.Clone;
  expressionElement := TFhirSearchParameterComponent(oSource).expressionElement.Clone;
end;

procedure TFhirSearchParameterComponent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'definition') Then
     list.add(self.link, 'definition', FDefinition.Link);
  if (child_name = 'expression') Then
     list.add(self.link, 'expression', FExpression.Link);
end;

procedure TFhirSearchParameterComponent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'definition', 'Reference(SearchParameter)', false, TFhirReference{TFhirSearchParameter}, FDefinition.Link));{2}
  oList.add(TFHIRProperty.create(self, 'expression', 'string', false, TFhirString, FExpression.Link));{2}
end;

function TFhirSearchParameterComponent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'definition') then
  begin
    Definition := propValue as TFhirReference{TFhirSearchParameter}{4b};
    result := propValue;
  end
  else if (propName = 'expression') then
  begin
    ExpressionElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSearchParameterComponent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSearchParameterComponent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'definition') then result := TFhirReference{TFhirSearchParameter}.create(){4b}
  else if (propName = 'expression') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSearchParameterComponent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'definition') then result := 'Reference'
  else if (propName = 'expression') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSearchParameterComponent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'definition') then DefinitionElement := nil
  else if (propName = 'expression') then ExpressionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSearchParameterComponent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'definition') then DefinitionElement := new as TFhirReference{TFhirSearchParameter}{4}
  else if (propName = 'expression') then ExpressionElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSearchParameterComponent.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSearchParameterComponent.fhirType : string;
begin
  result := 'component';
end;

function TFhirSearchParameterComponent.Link : TFhirSearchParameterComponent;
begin
  result := TFhirSearchParameterComponent(inherited Link);
end;

function TFhirSearchParameterComponent.Clone : TFhirSearchParameterComponent;
begin
  result := TFhirSearchParameterComponent(inherited Clone);
end;

function TFhirSearchParameterComponent.equals(other : TObject) : boolean;
var
  o : TFhirSearchParameterComponent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSearchParameterComponent)) then
    result := false
  else
  begin
    o := TFhirSearchParameterComponent(other);
    result := compareDeep(definitionElement, o.definitionElement, true) and compareDeep(expressionElement, o.expressionElement, true);
  end;
end;

function TFhirSearchParameterComponent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDefinition) and isEmptyProp(FExpression);
end;

procedure TFhirSearchParameterComponent.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('definition');
  fields.add('expression');
end;

{ TFhirSearchParameterComponent }

Procedure TFhirSearchParameterComponent.SetDefinition(value : TFhirReference{TFhirSearchParameter});
begin
  FDefinition.free;
  FDefinition := value;
end;

Procedure TFhirSearchParameterComponent.SetExpression(value : TFhirString);
begin
  FExpression.free;
  FExpression := value;
end;

Function TFhirSearchParameterComponent.GetExpressionST : String;
begin
  if FExpression = nil then
    result := ''
  else
    result := FExpression.value;
end;

Procedure TFhirSearchParameterComponent.SetExpressionST(value : String);
begin
  if value <> '' then
  begin
    if FExpression = nil then
      FExpression := TFhirString.create;
    FExpression.value := value
  end
  else if FExpression <> nil then
    FExpression.value := '';
end;

function TFhirSearchParameterComponent.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FDefinition.sizeInBytes);
  inc(result, FExpression.sizeInBytes);
end;

{ TFhirSearchParameterComponentListEnumerator }

Constructor TFhirSearchParameterComponentListEnumerator.Create(list : TFhirSearchParameterComponentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSearchParameterComponentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSearchParameterComponentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSearchParameterComponentListEnumerator.GetCurrent : TFhirSearchParameterComponent;
begin
  Result := FList[FIndex];
end;

function TFhirSearchParameterComponentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSearchParameterComponentList }
procedure TFhirSearchParameterComponentList.AddItem(value: TFhirSearchParameterComponent);
begin
  assert(value.ClassName = 'TFhirSearchParameterComponent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSearchParameterComponent');
  add(value);
end;

function TFhirSearchParameterComponentList.Append: TFhirSearchParameterComponent;
begin
  result := TFhirSearchParameterComponent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSearchParameterComponentList.ClearItems;
begin
  Clear;
end;

function TFhirSearchParameterComponentList.GetEnumerator : TFhirSearchParameterComponentListEnumerator;
begin
  result := TFhirSearchParameterComponentListEnumerator.Create(self.link);
end;

function TFhirSearchParameterComponentList.Clone: TFhirSearchParameterComponentList;
begin
  result := TFhirSearchParameterComponentList(inherited Clone);
end;

function TFhirSearchParameterComponentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSearchParameterComponentList.GetItemN(index: Integer): TFhirSearchParameterComponent;
begin
  result := TFhirSearchParameterComponent(ObjectByIndex[index]);
end;

function TFhirSearchParameterComponentList.ItemClass: TFslObjectClass;
begin
  result := TFhirSearchParameterComponent;
end;
function TFhirSearchParameterComponentList.IndexOf(value: TFhirSearchParameterComponent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSearchParameterComponentList.Insert(index: Integer): TFhirSearchParameterComponent;
begin
  result := TFhirSearchParameterComponent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSearchParameterComponentList.InsertItem(index: Integer; value: TFhirSearchParameterComponent);
begin
  assert(value is TFhirSearchParameterComponent);
  Inherited Insert(index, value);
end;

function TFhirSearchParameterComponentList.Item(index: Integer): TFhirSearchParameterComponent;
begin
  result := TFhirSearchParameterComponent(ObjectByIndex[index]);
end;

function TFhirSearchParameterComponentList.Link: TFhirSearchParameterComponentList;
begin
  result := TFhirSearchParameterComponentList(inherited Link);
end;

procedure TFhirSearchParameterComponentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSearchParameterComponentList.SetItemByIndex(index: Integer; value: TFhirSearchParameterComponent);
begin
  assert(value is TFhirSearchParameterComponent);
  FhirSearchParameterComponents[index] := value;
end;

procedure TFhirSearchParameterComponentList.SetItemN(index: Integer; value: TFhirSearchParameterComponent);
begin
  assert(value is TFhirSearchParameterComponent);
  ObjectByIndex[index] := value;
end;

{ TFhirSearchParameter }

constructor TFhirSearchParameter.Create;
begin
  inherited;
end;

destructor TFhirSearchParameter.Destroy;
begin
  FPurpose.free;
  FCode.free;
  FBase.Free;
  FType_.free;
  FDerivedFrom.free;
  FExpression.free;
  FXpath.free;
  FXpathUsage.free;
  FTarget.Free;
  FComparator.Free;
  FModifier.Free;
  FChainList.Free;
  FComponentList.Free;
  inherited;
end;

function TFhirSearchParameter.GetResourceType : TFhirResourceType;
begin
  result := frtSearchParameter;
end;

procedure TFhirSearchParameter.Assign(oSource : TFslObject);
begin
  inherited;
  purposeElement := TFhirSearchParameter(oSource).purposeElement.Clone;
  codeElement := TFhirSearchParameter(oSource).codeElement.Clone;
  if (TFhirSearchParameter(oSource).FBase = nil) then
  begin
    FBase.free;
    FBase := nil;
  end
  else
  begin
    FBase := TFHIREnumList.Create(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum);
    FBase.Assign(TFhirSearchParameter(oSource).FBase);
  end;
  FType_ := TFhirSearchParameter(oSource).FType_.Link;
  derivedFromElement := TFhirSearchParameter(oSource).derivedFromElement.Clone;
  expressionElement := TFhirSearchParameter(oSource).expressionElement.Clone;
  xpathElement := TFhirSearchParameter(oSource).xpathElement.Clone;
  FXpathUsage := TFhirSearchParameter(oSource).FXpathUsage.Link;
  if (TFhirSearchParameter(oSource).FTarget = nil) then
  begin
    FTarget.free;
    FTarget := nil;
  end
  else
  begin
    FTarget := TFHIREnumList.Create(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum);
    FTarget.Assign(TFhirSearchParameter(oSource).FTarget);
  end;
  if (TFhirSearchParameter(oSource).FComparator = nil) then
  begin
    FComparator.free;
    FComparator := nil;
  end
  else
  begin
    FComparator := TFHIREnumList.Create(SYSTEMS_TFhirSearchComparatorEnum, CODES_TFhirSearchComparatorEnum);
    FComparator.Assign(TFhirSearchParameter(oSource).FComparator);
  end;
  if (TFhirSearchParameter(oSource).FModifier = nil) then
  begin
    FModifier.free;
    FModifier := nil;
  end
  else
  begin
    FModifier := TFHIREnumList.Create(SYSTEMS_TFhirSearchModifierCodeEnum, CODES_TFhirSearchModifierCodeEnum);
    FModifier.Assign(TFhirSearchParameter(oSource).FModifier);
  end;
  if (TFhirSearchParameter(oSource).FChainList = nil) then
  begin
    FChainList.free;
    FChainList := nil;
  end
  else
  begin
    if FChainList = nil then
      FChainList := TFhirStringList.Create;
    FChainList.Assign(TFhirSearchParameter(oSource).FChainList);
  end;
  if (TFhirSearchParameter(oSource).FComponentList = nil) then
  begin
    FComponentList.free;
    FComponentList := nil;
  end
  else
  begin
    if FComponentList = nil then
      FComponentList := TFhirSearchParameterComponentList.Create;
    FComponentList.Assign(TFhirSearchParameter(oSource).FComponentList);
  end;
end;

procedure TFhirSearchParameter.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'base') Then
     list.addAll(self, 'base', FBase);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'derivedFrom') Then
     list.add(self.link, 'derivedFrom', FDerivedFrom.Link);
  if (child_name = 'expression') Then
     list.add(self.link, 'expression', FExpression.Link);
  if (child_name = 'xpath') Then
     list.add(self.link, 'xpath', FXpath.Link);
  if (child_name = 'xpathUsage') Then
     list.add(self.link, 'xpathUsage', FXpathUsage.Link);
  if (child_name = 'target') Then
     list.addAll(self, 'target', FTarget);
  if (child_name = 'comparator') Then
     list.addAll(self, 'comparator', FComparator);
  if (child_name = 'modifier') Then
     list.addAll(self, 'modifier', FModifier);
  if (child_name = 'chain') Then
    list.addAll(self, 'chain', FChainList);
  if (child_name = 'component') Then
    list.addAll(self, 'component', FComponentList);
end;

procedure TFhirSearchParameter.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirCode, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'base', 'code', true, TFHIREnum, FBase.Link)){3};
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFHIREnum, FType_.Link));{1}
  oList.add(TFHIRProperty.create(self, 'derivedFrom', 'uri', false, TFhirUri, FDerivedFrom.Link));{2}
  oList.add(TFHIRProperty.create(self, 'expression', 'string', false, TFhirString, FExpression.Link));{2}
  oList.add(TFHIRProperty.create(self, 'xpath', 'string', false, TFhirString, FXpath.Link));{2}
  oList.add(TFHIRProperty.create(self, 'xpathUsage', 'code', false, TFHIREnum, FXpathUsage.Link));{1}
  oList.add(TFHIRProperty.create(self, 'target', 'code', true, TFHIREnum, FTarget.Link)){3};
  oList.add(TFHIRProperty.create(self, 'comparator', 'code', true, TFHIREnum, FComparator.Link)){3};
  oList.add(TFHIRProperty.create(self, 'modifier', 'code', true, TFHIREnum, FModifier.Link)){3};
  oList.add(TFHIRProperty.create(self, 'chain', 'string', true, TFhirString, FChainList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'component', '', true, TFhirSearchParameterComponent, FComponentList.Link)){3};
end;

function TFhirSearchParameter.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'base') then
  begin
    BaseList.add(asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue)); {1}
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirSearchParamTypeEnum, CODES_TFhirSearchParamTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'derivedFrom') then
  begin
    DerivedFromElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'expression') then
  begin
    ExpressionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'xpath') then
  begin
    XpathElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'xpathUsage') then
  begin
    XpathUsageElement := asEnum(SYSTEMS_TFhirSearchXpathUsageEnum, CODES_TFhirSearchXpathUsageEnum, propValue);
    result := propValue
  end
  else if (propName = 'target') then
  begin
    TargetList.add(asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue)); {1}
    result := propValue;
  end
  else if (propName = 'comparator') then
  begin
    ComparatorList.add(asEnum(SYSTEMS_TFhirSearchComparatorEnum, CODES_TFhirSearchComparatorEnum, propValue)); {1}
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(asEnum(SYSTEMS_TFhirSearchModifierCodeEnum, CODES_TFhirSearchModifierCodeEnum, propValue)); {1}
    result := propValue;
  end
  else if (propName = 'chain') then
  begin
    ChainList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'component') then
  begin
    ComponentList.add(propValue as TFhirSearchParameterComponent){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirSearchParameter.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'base') then FBase.insertItem(index, asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue)) {1}
  else if (propName = 'target') then FTarget.insertItem(index, asEnum(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum, propValue)) {1}
  else if (propName = 'comparator') then FComparator.insertItem(index, asEnum(SYSTEMS_TFhirSearchComparatorEnum, CODES_TFhirSearchComparatorEnum, propValue)) {1}
  else if (propName = 'modifier') then FModifier.insertItem(index, asEnum(SYSTEMS_TFhirSearchModifierCodeEnum, CODES_TFhirSearchModifierCodeEnum, propValue)) {1}
  else if (propName = 'chain') then ChainList.insertItem(index, asString(propValue)){2}
  else if (propName = 'component') then ComponentList.insertItem(index, propValue as TFhirSearchParameterComponent){2a}
  else inherited;
end;

function TFhirSearchParameter.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'purpose') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'code') then result := TFhirCode.create() {5b}
  else if (propName = 'derivedFrom') then result := TFhirUri.create() {5b}
  else if (propName = 'expression') then result := TFhirString.create() {5b}
  else if (propName = 'xpath') then result := TFhirString.create() {5b}
  else if (propName = 'chain') then result := ChainList.new(){2}
  else if (propName = 'component') then result := ComponentList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirSearchParameter.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'code') then result := 'code'
  else if (propName = 'base') then result := 'code'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'derivedFrom') then result := 'uri'
  else if (propName = 'expression') then result := 'string'
  else if (propName = 'xpath') then result := 'string'
  else if (propName = 'xpathUsage') then result := 'code'
  else if (propName = 'target') then result := 'code'
  else if (propName = 'comparator') then result := 'code'
  else if (propName = 'modifier') then result := 'code'
  else if (propName = 'chain') then result := 'string'
  else if (propName = 'component') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSearchParameter.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'derivedFrom') then DerivedFromElement := nil
  else if (propName = 'expression') then ExpressionElement := nil
  else if (propName = 'xpath') then XpathElement := nil
  else if (propName = 'xpathUsage') then XpathUsageElement := nil
  else if (propName = 'chain') then deletePropertyValue('chain', ChainList, value) {2}
  else if (propName = 'component') then deletePropertyValue('component', ComponentList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSearchParameter.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'purpose') then PurposeElement := asMarkdown(new){5b}
  else if (propName = 'code') then CodeElement := asCode(new){5b}
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirSearchParamTypeEnum, CODES_TFhirSearchParamTypeEnum, new){4}
  else if (propName = 'derivedFrom') then DerivedFromElement := asUri(new){5b}
  else if (propName = 'expression') then ExpressionElement := asString(new){5b}
  else if (propName = 'xpath') then XpathElement := asString(new){5b}
  else if (propName = 'xpathUsage') then XpathUsageElement := asEnum(SYSTEMS_TFhirSearchXpathUsageEnum, CODES_TFhirSearchXpathUsageEnum, new){4}
  else if (propName = 'chain') then replacePropertyValue('chain', ChainList, existing, new) {2}
  else if (propName = 'component') then replacePropertyValue('component', ComponentList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSearchParameter.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'base') then FBase.move(source, destination) {1}
  else if (propName = 'target') then FTarget.move(source, destination) {1}
  else if (propName = 'comparator') then FComparator.move(source, destination) {1}
  else if (propName = 'modifier') then FModifier.move(source, destination) {1}
  else if (propName = 'chain') then ChainList.move(source, destination){2}
  else if (propName = 'component') then ComponentList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSearchParameter.fhirType : string;
begin
  result := 'SearchParameter';
end;

function TFhirSearchParameter.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPurpose) and isEmptyProp(FCode) and isEmptyProp(FBase) and isEmptyProp(FType_) and isEmptyProp(FDerivedFrom) and isEmptyProp(FExpression) and isEmptyProp(FXpath) and isEmptyProp(FXpathUsage) and isEmptyProp(FTarget) and isEmptyProp(FComparator) and isEmptyProp(FModifier) and isEmptyProp(FchainList) and isEmptyProp(FcomponentList);
end;

function TFhirSearchParameter.equals(other : TObject) : boolean;
var
  o : TFhirSearchParameter;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSearchParameter)) then
    result := false
  else
  begin
    o := TFhirSearchParameter(other);
    result := compareDeep(purposeElement, o.purposeElement, true) and compareDeep(codeElement, o.codeElement, true) and
      compareDeep(baseList, o.baseList, true) and compareDeep(type_Element, o.type_Element, true) and
      compareDeep(derivedFromElement, o.derivedFromElement, true) and compareDeep(expressionElement, o.expressionElement, true) and
      compareDeep(xpathElement, o.xpathElement, true) and compareDeep(xpathUsageElement, o.xpathUsageElement, true) and
      compareDeep(targetList, o.targetList, true) and compareDeep(comparatorList, o.comparatorList, true) and
      compareDeep(modifierList, o.modifierList, true) and compareDeep(chainList, o.chainList, true) and
      compareDeep(componentList, o.componentList, true);
  end;
end;

function TFhirSearchParameter.Link : TFhirSearchParameter;
begin
  result := TFhirSearchParameter(inherited Link);
end;

function TFhirSearchParameter.Clone : TFhirSearchParameter;
begin
  result := TFhirSearchParameter(inherited Clone);
end;

procedure TFhirSearchParameter.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('url');
  fields.add('version');
  fields.add('name');
  fields.add('status');
  fields.add('experimental');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('purpose');
  fields.add('code');
  fields.add('base');
  fields.add('type');
  fields.add('derivedFrom');
  fields.add('description');
  fields.add('expression');
  fields.add('xpath');
  fields.add('xpathUsage');
  fields.add('target');
  fields.add('comparator');
  fields.add('modifier');
  fields.add('chain');
  fields.add('component');
end;

{ TFhirSearchParameter }

Procedure TFhirSearchParameter.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

Function TFhirSearchParameter.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

Procedure TFhirSearchParameter.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

Procedure TFhirSearchParameter.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirSearchParameter.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

Procedure TFhirSearchParameter.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

Function TFhirSearchParameter.GetBase : TFhirEnumList;
begin
  if FBase = nil then
    FBase := TFHIREnumList.Create(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum);
  result := FBase;
end;

Function TFhirSearchParameter.GetHasBase : boolean;
begin
  result := (FBase <> nil) and (FBase.count > 0);
end;

Procedure TFhirSearchParameter.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirSearchParameter.GetType_ST : TFhirSearchParamTypeEnum;
begin
  if FType_ = nil then
    result := TFhirSearchParamTypeEnum(0)
  else
    result := TFhirSearchParamTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirSearchParamTypeEnum, FType_.value));
end;

Procedure TFhirSearchParameter.SetType_ST(value : TFhirSearchParamTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirSearchParamTypeEnum[value], CODES_TFhirSearchParamTypeEnum[value]);
end;

Procedure TFhirSearchParameter.SetDerivedFrom(value : TFhirUri);
begin
  FDerivedFrom.free;
  FDerivedFrom := value;
end;

Function TFhirSearchParameter.GetDerivedFromST : String;
begin
  if FDerivedFrom = nil then
    result := ''
  else
    result := FDerivedFrom.value;
end;

Procedure TFhirSearchParameter.SetDerivedFromST(value : String);
begin
  if value <> '' then
  begin
    if FDerivedFrom = nil then
      FDerivedFrom := TFhirUri.create;
    FDerivedFrom.value := value
  end
  else if FDerivedFrom <> nil then
    FDerivedFrom.value := '';
end;

Procedure TFhirSearchParameter.SetExpression(value : TFhirString);
begin
  FExpression.free;
  FExpression := value;
end;

Function TFhirSearchParameter.GetExpressionST : String;
begin
  if FExpression = nil then
    result := ''
  else
    result := FExpression.value;
end;

Procedure TFhirSearchParameter.SetExpressionST(value : String);
begin
  if value <> '' then
  begin
    if FExpression = nil then
      FExpression := TFhirString.create;
    FExpression.value := value
  end
  else if FExpression <> nil then
    FExpression.value := '';
end;

Procedure TFhirSearchParameter.SetXpath(value : TFhirString);
begin
  FXpath.free;
  FXpath := value;
end;

Function TFhirSearchParameter.GetXpathST : String;
begin
  if FXpath = nil then
    result := ''
  else
    result := FXpath.value;
end;

Procedure TFhirSearchParameter.SetXpathST(value : String);
begin
  if value <> '' then
  begin
    if FXpath = nil then
      FXpath := TFhirString.create;
    FXpath.value := value
  end
  else if FXpath <> nil then
    FXpath.value := '';
end;

Procedure TFhirSearchParameter.SetXpathUsage(value : TFhirEnum);
begin
  FXpathUsage.free;
  FXpathUsage := value;
end;

Function TFhirSearchParameter.GetXpathUsageST : TFhirSearchXpathUsageEnum;
begin
  if FXpathUsage = nil then
    result := TFhirSearchXpathUsageEnum(0)
  else
    result := TFhirSearchXpathUsageEnum(StringArrayIndexOfSensitive(CODES_TFhirSearchXpathUsageEnum, FXpathUsage.value));
end;

Procedure TFhirSearchParameter.SetXpathUsageST(value : TFhirSearchXpathUsageEnum);
begin
  if ord(value) = 0 then
    XpathUsageElement := nil
  else
    XpathUsageElement := TFhirEnum.create(SYSTEMS_TFhirSearchXpathUsageEnum[value], CODES_TFhirSearchXpathUsageEnum[value]);
end;

Function TFhirSearchParameter.GetTarget : TFhirEnumList;
begin
  if FTarget = nil then
    FTarget := TFHIREnumList.Create(SYSTEMS_TFhirResourceTypesEnum, CODES_TFhirResourceTypesEnum);
  result := FTarget;
end;

Function TFhirSearchParameter.GetHasTarget : boolean;
begin
  result := (FTarget <> nil) and (FTarget.count > 0);
end;

Function TFhirSearchParameter.GetComparator : TFhirEnumList;
begin
  if FComparator = nil then
    FComparator := TFHIREnumList.Create(SYSTEMS_TFhirSearchComparatorEnum, CODES_TFhirSearchComparatorEnum);
  result := FComparator;
end;

Function TFhirSearchParameter.GetHasComparator : boolean;
begin
  result := (FComparator <> nil) and (FComparator.count > 0);
end;

Function TFhirSearchParameter.GetComparatorST : TFhirSearchComparatorEnumList;
  var i : integer;
begin
  result := [];
  if Fcomparator <> nil then
    for i := 0 to Fcomparator.count - 1 do
      result := result + [TFhirSearchComparatorEnum(StringArrayIndexOfSensitive(CODES_TFhirSearchComparatorEnum, Fcomparator[i].value))];
end;

Procedure TFhirSearchParameter.SetComparatorST(value : TFhirSearchComparatorEnumList);
var a : TFhirSearchComparatorEnum;
begin
  if Fcomparator = nil then
    Fcomparator := TFhirEnumList.create(SYSTEMS_TFhirSearchComparatorEnum, CODES_TFhirSearchComparatorEnum);
  Fcomparator.clear;
  for a := low(TFhirSearchComparatorEnum) to high(TFhirSearchComparatorEnum) do
    if a in value then
      begin
         if Fcomparator = nil then
           Fcomparator := TFhirEnumList.create(SYSTEMS_TFhirSearchComparatorEnum, CODES_TFhirSearchComparatorEnum);
         Fcomparator.add(TFhirEnum.create(SYSTEMS_TFhirSearchComparatorEnum[a], CODES_TFhirSearchComparatorEnum[a]));
      end;
end;

Function TFhirSearchParameter.GetModifier : TFhirEnumList;
begin
  if FModifier = nil then
    FModifier := TFHIREnumList.Create(SYSTEMS_TFhirSearchModifierCodeEnum, CODES_TFhirSearchModifierCodeEnum);
  result := FModifier;
end;

Function TFhirSearchParameter.GetHasModifier : boolean;
begin
  result := (FModifier <> nil) and (FModifier.count > 0);
end;

Function TFhirSearchParameter.GetModifierST : TFhirSearchModifierCodeEnumList;
  var i : integer;
begin
  result := [];
  if Fmodifier <> nil then
    for i := 0 to Fmodifier.count - 1 do
      result := result + [TFhirSearchModifierCodeEnum(StringArrayIndexOfSensitive(CODES_TFhirSearchModifierCodeEnum, Fmodifier[i].value))];
end;

Procedure TFhirSearchParameter.SetModifierST(value : TFhirSearchModifierCodeEnumList);
var a : TFhirSearchModifierCodeEnum;
begin
  if Fmodifier = nil then
    Fmodifier := TFhirEnumList.create(SYSTEMS_TFhirSearchModifierCodeEnum, CODES_TFhirSearchModifierCodeEnum);
  Fmodifier.clear;
  for a := low(TFhirSearchModifierCodeEnum) to high(TFhirSearchModifierCodeEnum) do
    if a in value then
      begin
         if Fmodifier = nil then
           Fmodifier := TFhirEnumList.create(SYSTEMS_TFhirSearchModifierCodeEnum, CODES_TFhirSearchModifierCodeEnum);
         Fmodifier.add(TFhirEnum.create(SYSTEMS_TFhirSearchModifierCodeEnum[a], CODES_TFhirSearchModifierCodeEnum[a]));
      end;
end;

Function TFhirSearchParameter.GetChainList : TFhirStringList;
begin
  if FChainList = nil then
    FChainList := TFhirStringList.Create;
  result := FChainList;
end;

Function TFhirSearchParameter.GetHasChainList : boolean;
begin
  result := (FChainList <> nil) and (FChainList.count > 0);
end;

Function TFhirSearchParameter.GetComponentList : TFhirSearchParameterComponentList;
begin
  if FComponentList = nil then
    FComponentList := TFhirSearchParameterComponentList.Create;
  result := FComponentList;
end;

Function TFhirSearchParameter.GetHasComponentList : boolean;
begin
  result := (FComponentList <> nil) and (FComponentList.count > 0);
end;

function TFhirSearchParameter.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FPurpose.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FBase.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FDerivedFrom.sizeInBytes);
  inc(result, FExpression.sizeInBytes);
  inc(result, FXpath.sizeInBytes);
  inc(result, FXpathUsage.sizeInBytes);
  inc(result, FTarget.sizeInBytes);
  inc(result, FComparator.sizeInBytes);
  inc(result, FModifier.sizeInBytes);
  inc(result, FchainList.sizeInBytes);
  inc(result, FcomponentList.sizeInBytes);
end;

{ TFhirSearchParameterListEnumerator }

Constructor TFhirSearchParameterListEnumerator.Create(list : TFhirSearchParameterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSearchParameterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSearchParameterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSearchParameterListEnumerator.GetCurrent : TFhirSearchParameter;
begin
  Result := FList[FIndex];
end;

function TFhirSearchParameterListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirSearchParameterList }
procedure TFhirSearchParameterList.AddItem(value: TFhirSearchParameter);
begin
  assert(value.ClassName = 'TFhirSearchParameter', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSearchParameter');
  add(value);
end;

function TFhirSearchParameterList.Append: TFhirSearchParameter;
begin
  result := TFhirSearchParameter.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSearchParameterList.ClearItems;
begin
  Clear;
end;

function TFhirSearchParameterList.GetEnumerator : TFhirSearchParameterListEnumerator;
begin
  result := TFhirSearchParameterListEnumerator.Create(self.link);
end;

function TFhirSearchParameterList.Clone: TFhirSearchParameterList;
begin
  result := TFhirSearchParameterList(inherited Clone);
end;

function TFhirSearchParameterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSearchParameterList.GetItemN(index: Integer): TFhirSearchParameter;
begin
  result := TFhirSearchParameter(ObjectByIndex[index]);
end;

function TFhirSearchParameterList.ItemClass: TFslObjectClass;
begin
  result := TFhirSearchParameter;
end;
function TFhirSearchParameterList.IndexOf(value: TFhirSearchParameter): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSearchParameterList.Insert(index: Integer): TFhirSearchParameter;
begin
  result := TFhirSearchParameter.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSearchParameterList.InsertItem(index: Integer; value: TFhirSearchParameter);
begin
  assert(value is TFhirSearchParameter);
  Inherited Insert(index, value);
end;

function TFhirSearchParameterList.Item(index: Integer): TFhirSearchParameter;
begin
  result := TFhirSearchParameter(ObjectByIndex[index]);
end;

function TFhirSearchParameterList.Link: TFhirSearchParameterList;
begin
  result := TFhirSearchParameterList(inherited Link);
end;

procedure TFhirSearchParameterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSearchParameterList.SetItemByIndex(index: Integer; value: TFhirSearchParameter);
begin
  assert(value is TFhirSearchParameter);
  FhirSearchParameters[index] := value;
end;

procedure TFhirSearchParameterList.SetItemN(index: Integer; value: TFhirSearchParameter);
begin
  assert(value is TFhirSearchParameter);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SEARCHPARAMETER}

{$IFDEF FHIR_SERVICEDEFINITION}

{ TFhirServiceDefinition }

constructor TFhirServiceDefinition.Create;
begin
  inherited;
end;

destructor TFhirServiceDefinition.Destroy;
begin
  FIdentifierList.Free;
  FPurpose.free;
  FUsage.free;
  FApprovalDate.free;
  FLastReviewDate.free;
  FEffectivePeriod.free;
  FTopicList.Free;
  FContributorList.Free;
  FCopyright.free;
  FRelatedArtifactList.Free;
  FTriggerList.Free;
  FDataRequirementList.Free;
  FOperationDefinition.free;
  inherited;
end;

function TFhirServiceDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtServiceDefinition;
end;

procedure TFhirServiceDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirServiceDefinition(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirServiceDefinition(oSource).FIdentifierList);
  end;
  purposeElement := TFhirServiceDefinition(oSource).purposeElement.Clone;
  usageElement := TFhirServiceDefinition(oSource).usageElement.Clone;
  approvalDateElement := TFhirServiceDefinition(oSource).approvalDateElement.Clone;
  lastReviewDateElement := TFhirServiceDefinition(oSource).lastReviewDateElement.Clone;
  effectivePeriod := TFhirServiceDefinition(oSource).effectivePeriod.Clone;
  if (TFhirServiceDefinition(oSource).FTopicList = nil) then
  begin
    FTopicList.free;
    FTopicList := nil;
  end
  else
  begin
    if FTopicList = nil then
      FTopicList := TFhirCodeableConceptList.Create;
    FTopicList.Assign(TFhirServiceDefinition(oSource).FTopicList);
  end;
  if (TFhirServiceDefinition(oSource).FContributorList = nil) then
  begin
    FContributorList.free;
    FContributorList := nil;
  end
  else
  begin
    if FContributorList = nil then
      FContributorList := TFhirContributorList.Create;
    FContributorList.Assign(TFhirServiceDefinition(oSource).FContributorList);
  end;
  copyrightElement := TFhirServiceDefinition(oSource).copyrightElement.Clone;
  if (TFhirServiceDefinition(oSource).FRelatedArtifactList = nil) then
  begin
    FRelatedArtifactList.free;
    FRelatedArtifactList := nil;
  end
  else
  begin
    if FRelatedArtifactList = nil then
      FRelatedArtifactList := TFhirRelatedArtifactList.Create;
    FRelatedArtifactList.Assign(TFhirServiceDefinition(oSource).FRelatedArtifactList);
  end;
  if (TFhirServiceDefinition(oSource).FTriggerList = nil) then
  begin
    FTriggerList.free;
    FTriggerList := nil;
  end
  else
  begin
    if FTriggerList = nil then
      FTriggerList := TFhirTriggerDefinitionList.Create;
    FTriggerList.Assign(TFhirServiceDefinition(oSource).FTriggerList);
  end;
  if (TFhirServiceDefinition(oSource).FDataRequirementList = nil) then
  begin
    FDataRequirementList.free;
    FDataRequirementList := nil;
  end
  else
  begin
    if FDataRequirementList = nil then
      FDataRequirementList := TFhirDataRequirementList.Create;
    FDataRequirementList.Assign(TFhirServiceDefinition(oSource).FDataRequirementList);
  end;
  operationDefinition := TFhirServiceDefinition(oSource).operationDefinition.Clone;
end;

procedure TFhirServiceDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'usage') Then
     list.add(self.link, 'usage', FUsage.Link);
  if (child_name = 'approvalDate') Then
     list.add(self.link, 'approvalDate', FApprovalDate.Link);
  if (child_name = 'lastReviewDate') Then
     list.add(self.link, 'lastReviewDate', FLastReviewDate.Link);
  if (child_name = 'effectivePeriod') Then
     list.add(self.link, 'effectivePeriod', FEffectivePeriod.Link);
  if (child_name = 'topic') Then
    list.addAll(self, 'topic', FTopicList);
  if (child_name = 'contributor') Then
    list.addAll(self, 'contributor', FContributorList);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'relatedArtifact') Then
    list.addAll(self, 'relatedArtifact', FRelatedArtifactList);
  if (child_name = 'trigger') Then
    list.addAll(self, 'trigger', FTriggerList);
  if (child_name = 'dataRequirement') Then
    list.addAll(self, 'dataRequirement', FDataRequirementList);
  if (child_name = 'operationDefinition') Then
     list.add(self.link, 'operationDefinition', FOperationDefinition.Link);
end;

procedure TFhirServiceDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));{2}
  oList.add(TFHIRProperty.create(self, 'usage', 'string', false, TFhirString, FUsage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'approvalDate', 'date', false, TFhirDate, FApprovalDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'lastReviewDate', 'date', false, TFhirDate, FLastReviewDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'effectivePeriod', 'Period', false, TFhirPeriod, FEffectivePeriod.Link));{2}
  oList.add(TFHIRProperty.create(self, 'topic', 'CodeableConcept', true, TFhirCodeableConcept, FTopicList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'contributor', 'Contributor', true, TFhirContributor, FContributorList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));{2}
  oList.add(TFHIRProperty.create(self, 'relatedArtifact', 'RelatedArtifact', true, TFhirRelatedArtifact, FRelatedArtifactList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'trigger', 'TriggerDefinition', true, TFhirTriggerDefinition, FTriggerList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'dataRequirement', 'DataRequirement', true, TFhirDataRequirement, FDataRequirementList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'operationDefinition', 'Reference(OperationDefinition)', false, TFhirReference{TFhirOperationDefinition}, FOperationDefinition.Link));{2}
end;

function TFhirServiceDefinition.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'usage') then
  begin
    UsageElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'approvalDate') then
  begin
    ApprovalDateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'lastReviewDate') then
  begin
    LastReviewDateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'effectivePeriod') then
  begin
    EffectivePeriod := propValue as TFhirPeriod{4b};
    result := propValue;
  end
  else if (propName = 'topic') then
  begin
    TopicList.add(propValue as TFhirCodeableConcept){2a};
    result := propValue;
  end
  else if (propName = 'contributor') then
  begin
    ContributorList.add(propValue as TFhirContributor){2a};
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'relatedArtifact') then
  begin
    RelatedArtifactList.add(propValue as TFhirRelatedArtifact){2a};
    result := propValue;
  end
  else if (propName = 'trigger') then
  begin
    TriggerList.add(propValue as TFhirTriggerDefinition){2a};
    result := propValue;
  end
  else if (propName = 'dataRequirement') then
  begin
    DataRequirementList.add(propValue as TFhirDataRequirement){2a};
    result := propValue;
  end
  else if (propName = 'operationDefinition') then
  begin
    OperationDefinition := propValue as TFhirReference{TFhirOperationDefinition}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirServiceDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'topic') then TopicList.insertItem(index, propValue as TFhirCodeableConcept){2a}
  else if (propName = 'contributor') then ContributorList.insertItem(index, propValue as TFhirContributor){2a}
  else if (propName = 'relatedArtifact') then RelatedArtifactList.insertItem(index, propValue as TFhirRelatedArtifact){2a}
  else if (propName = 'trigger') then TriggerList.insertItem(index, propValue as TFhirTriggerDefinition){2a}
  else if (propName = 'dataRequirement') then DataRequirementList.insertItem(index, propValue as TFhirDataRequirement){2a}
  else inherited;
end;

function TFhirServiceDefinition.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'purpose') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'usage') then result := TFhirString.create() {5b}
  else if (propName = 'approvalDate') then result := TFhirDate.create() {5b}
  else if (propName = 'lastReviewDate') then result := TFhirDate.create() {5b}
  else if (propName = 'effectivePeriod') then result := TFhirPeriod.create(){4b}
  else if (propName = 'topic') then result := TopicList.new(){2}
  else if (propName = 'contributor') then result := ContributorList.new(){2}
  else if (propName = 'copyright') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'relatedArtifact') then result := RelatedArtifactList.new(){2}
  else if (propName = 'trigger') then result := TriggerList.new(){2}
  else if (propName = 'dataRequirement') then result := DataRequirementList.new(){2}
  else if (propName = 'operationDefinition') then result := TFhirReference{TFhirOperationDefinition}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirServiceDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'usage') then result := 'string'
  else if (propName = 'approvalDate') then result := 'date'
  else if (propName = 'lastReviewDate') then result := 'date'
  else if (propName = 'effectivePeriod') then result := 'Period'
  else if (propName = 'topic') then result := 'CodeableConcept'
  else if (propName = 'contributor') then result := 'Contributor'
  else if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'relatedArtifact') then result := 'RelatedArtifact'
  else if (propName = 'trigger') then result := 'TriggerDefinition'
  else if (propName = 'dataRequirement') then result := 'DataRequirement'
  else if (propName = 'operationDefinition') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirServiceDefinition.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'usage') then UsageElement := nil
  else if (propName = 'approvalDate') then ApprovalDateElement := nil
  else if (propName = 'lastReviewDate') then LastReviewDateElement := nil
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := nil
  else if (propName = 'topic') then deletePropertyValue('topic', TopicList, value) {2}
  else if (propName = 'contributor') then deletePropertyValue('contributor', ContributorList, value) {2}
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'relatedArtifact') then deletePropertyValue('relatedArtifact', RelatedArtifactList, value) {2}
  else if (propName = 'trigger') then deletePropertyValue('trigger', TriggerList, value) {2}
  else if (propName = 'dataRequirement') then deletePropertyValue('dataRequirement', DataRequirementList, value) {2}
  else if (propName = 'operationDefinition') then OperationDefinitionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirServiceDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'purpose') then PurposeElement := asMarkdown(new){5b}
  else if (propName = 'usage') then UsageElement := asString(new){5b}
  else if (propName = 'approvalDate') then ApprovalDateElement := asDate(new){5b}
  else if (propName = 'lastReviewDate') then LastReviewDateElement := asDate(new){5b}
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := new as TFhirPeriod{4}
  else if (propName = 'topic') then replacePropertyValue('topic', TopicList, existing, new) {2}
  else if (propName = 'contributor') then replacePropertyValue('contributor', ContributorList, existing, new) {2}
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new){5b}
  else if (propName = 'relatedArtifact') then replacePropertyValue('relatedArtifact', RelatedArtifactList, existing, new) {2}
  else if (propName = 'trigger') then replacePropertyValue('trigger', TriggerList, existing, new) {2}
  else if (propName = 'dataRequirement') then replacePropertyValue('dataRequirement', DataRequirementList, existing, new) {2}
  else if (propName = 'operationDefinition') then OperationDefinitionElement := new as TFhirReference{TFhirOperationDefinition}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirServiceDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'topic') then TopicList.move(source, destination){2a}
  else if (propName = 'contributor') then ContributorList.move(source, destination){2a}
  else if (propName = 'relatedArtifact') then RelatedArtifactList.move(source, destination){2a}
  else if (propName = 'trigger') then TriggerList.move(source, destination){2a}
  else if (propName = 'dataRequirement') then DataRequirementList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirServiceDefinition.fhirType : string;
begin
  result := 'ServiceDefinition';
end;

function TFhirServiceDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FPurpose) and isEmptyProp(FUsage) and isEmptyProp(FApprovalDate) and isEmptyProp(FLastReviewDate) and isEmptyProp(FEffectivePeriod) and isEmptyProp(FtopicList) and isEmptyProp(FcontributorList) and isEmptyProp(FCopyright) and isEmptyProp(FrelatedArtifactList) and isEmptyProp(FtriggerList) and isEmptyProp(FdataRequirementList) and isEmptyProp(FOperationDefinition);
end;

function TFhirServiceDefinition.equals(other : TObject) : boolean;
var
  o : TFhirServiceDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirServiceDefinition)) then
    result := false
  else
  begin
    o := TFhirServiceDefinition(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(purposeElement, o.purposeElement, true) and
      compareDeep(usageElement, o.usageElement, true) and compareDeep(approvalDateElement, o.approvalDateElement, true) and
      compareDeep(lastReviewDateElement, o.lastReviewDateElement, true) and compareDeep(effectivePeriodElement, o.effectivePeriodElement, true) and
      compareDeep(topicList, o.topicList, true) and compareDeep(contributorList, o.contributorList, true) and
      compareDeep(copyrightElement, o.copyrightElement, true) and compareDeep(relatedArtifactList, o.relatedArtifactList, true) and
      compareDeep(triggerList, o.triggerList, true) and compareDeep(dataRequirementList, o.dataRequirementList, true) and
      compareDeep(operationDefinitionElement, o.operationDefinitionElement, true);
  end;
end;

function TFhirServiceDefinition.Link : TFhirServiceDefinition;
begin
  result := TFhirServiceDefinition(inherited Link);
end;

function TFhirServiceDefinition.Clone : TFhirServiceDefinition;
begin
  result := TFhirServiceDefinition(inherited Clone);
end;

procedure TFhirServiceDefinition.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('status');
  fields.add('experimental');
  fields.add('date');
  fields.add('publisher');
  fields.add('description');
  fields.add('purpose');
  fields.add('usage');
  fields.add('approvalDate');
  fields.add('lastReviewDate');
  fields.add('effectivePeriod');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('topic');
  fields.add('contributor');
  fields.add('contact');
  fields.add('copyright');
  fields.add('relatedArtifact');
  fields.add('trigger');
  fields.add('dataRequirement');
  fields.add('operationDefinition');
end;

{ TFhirServiceDefinition }

Function TFhirServiceDefinition.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirServiceDefinition.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirServiceDefinition.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

Function TFhirServiceDefinition.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

Procedure TFhirServiceDefinition.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

Procedure TFhirServiceDefinition.SetUsage(value : TFhirString);
begin
  FUsage.free;
  FUsage := value;
end;

Function TFhirServiceDefinition.GetUsageST : String;
begin
  if FUsage = nil then
    result := ''
  else
    result := FUsage.value;
end;

Procedure TFhirServiceDefinition.SetUsageST(value : String);
begin
  if value <> '' then
  begin
    if FUsage = nil then
      FUsage := TFhirString.create;
    FUsage.value := value
  end
  else if FUsage <> nil then
    FUsage.value := '';
end;

Procedure TFhirServiceDefinition.SetApprovalDate(value : TFhirDate);
begin
  FApprovalDate.free;
  FApprovalDate := value;
end;

Function TFhirServiceDefinition.GetApprovalDateST : TFslDateTime;
begin
  if FApprovalDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FApprovalDate.value;
end;

Procedure TFhirServiceDefinition.SetApprovalDateST(value : TFslDateTime);
begin
  if FApprovalDate = nil then
    FApprovalDate := TFhirDate.create;
  FApprovalDate.value := value
end;

Procedure TFhirServiceDefinition.SetLastReviewDate(value : TFhirDate);
begin
  FLastReviewDate.free;
  FLastReviewDate := value;
end;

Function TFhirServiceDefinition.GetLastReviewDateST : TFslDateTime;
begin
  if FLastReviewDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastReviewDate.value;
end;

Procedure TFhirServiceDefinition.SetLastReviewDateST(value : TFslDateTime);
begin
  if FLastReviewDate = nil then
    FLastReviewDate := TFhirDate.create;
  FLastReviewDate.value := value
end;

Procedure TFhirServiceDefinition.SetEffectivePeriod(value : TFhirPeriod);
begin
  FEffectivePeriod.free;
  FEffectivePeriod := value;
end;

Function TFhirServiceDefinition.GetTopicList : TFhirCodeableConceptList;
begin
  if FTopicList = nil then
    FTopicList := TFhirCodeableConceptList.Create;
  result := FTopicList;
end;

Function TFhirServiceDefinition.GetHasTopicList : boolean;
begin
  result := (FTopicList <> nil) and (FTopicList.count > 0);
end;

Function TFhirServiceDefinition.GetContributorList : TFhirContributorList;
begin
  if FContributorList = nil then
    FContributorList := TFhirContributorList.Create;
  result := FContributorList;
end;

Function TFhirServiceDefinition.GetHasContributorList : boolean;
begin
  result := (FContributorList <> nil) and (FContributorList.count > 0);
end;

Procedure TFhirServiceDefinition.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

Function TFhirServiceDefinition.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

Procedure TFhirServiceDefinition.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

Function TFhirServiceDefinition.GetRelatedArtifactList : TFhirRelatedArtifactList;
begin
  if FRelatedArtifactList = nil then
    FRelatedArtifactList := TFhirRelatedArtifactList.Create;
  result := FRelatedArtifactList;
end;

Function TFhirServiceDefinition.GetHasRelatedArtifactList : boolean;
begin
  result := (FRelatedArtifactList <> nil) and (FRelatedArtifactList.count > 0);
end;

Function TFhirServiceDefinition.GetTriggerList : TFhirTriggerDefinitionList;
begin
  if FTriggerList = nil then
    FTriggerList := TFhirTriggerDefinitionList.Create;
  result := FTriggerList;
end;

Function TFhirServiceDefinition.GetHasTriggerList : boolean;
begin
  result := (FTriggerList <> nil) and (FTriggerList.count > 0);
end;

Function TFhirServiceDefinition.GetDataRequirementList : TFhirDataRequirementList;
begin
  if FDataRequirementList = nil then
    FDataRequirementList := TFhirDataRequirementList.Create;
  result := FDataRequirementList;
end;

Function TFhirServiceDefinition.GetHasDataRequirementList : boolean;
begin
  result := (FDataRequirementList <> nil) and (FDataRequirementList.count > 0);
end;

Procedure TFhirServiceDefinition.SetOperationDefinition(value : TFhirReference{TFhirOperationDefinition});
begin
  FOperationDefinition.free;
  FOperationDefinition := value;
end;

function TFhirServiceDefinition.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FPurpose.sizeInBytes);
  inc(result, FUsage.sizeInBytes);
  inc(result, FApprovalDate.sizeInBytes);
  inc(result, FLastReviewDate.sizeInBytes);
  inc(result, FEffectivePeriod.sizeInBytes);
  inc(result, FtopicList.sizeInBytes);
  inc(result, FcontributorList.sizeInBytes);
  inc(result, FCopyright.sizeInBytes);
  inc(result, FrelatedArtifactList.sizeInBytes);
  inc(result, FtriggerList.sizeInBytes);
  inc(result, FdataRequirementList.sizeInBytes);
  inc(result, FOperationDefinition.sizeInBytes);
end;

{ TFhirServiceDefinitionListEnumerator }

Constructor TFhirServiceDefinitionListEnumerator.Create(list : TFhirServiceDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirServiceDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirServiceDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirServiceDefinitionListEnumerator.GetCurrent : TFhirServiceDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirServiceDefinitionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirServiceDefinitionList }
procedure TFhirServiceDefinitionList.AddItem(value: TFhirServiceDefinition);
begin
  assert(value.ClassName = 'TFhirServiceDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirServiceDefinition');
  add(value);
end;

function TFhirServiceDefinitionList.Append: TFhirServiceDefinition;
begin
  result := TFhirServiceDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirServiceDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirServiceDefinitionList.GetEnumerator : TFhirServiceDefinitionListEnumerator;
begin
  result := TFhirServiceDefinitionListEnumerator.Create(self.link);
end;

function TFhirServiceDefinitionList.Clone: TFhirServiceDefinitionList;
begin
  result := TFhirServiceDefinitionList(inherited Clone);
end;

function TFhirServiceDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirServiceDefinitionList.GetItemN(index: Integer): TFhirServiceDefinition;
begin
  result := TFhirServiceDefinition(ObjectByIndex[index]);
end;

function TFhirServiceDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirServiceDefinition;
end;
function TFhirServiceDefinitionList.IndexOf(value: TFhirServiceDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirServiceDefinitionList.Insert(index: Integer): TFhirServiceDefinition;
begin
  result := TFhirServiceDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirServiceDefinitionList.InsertItem(index: Integer; value: TFhirServiceDefinition);
begin
  assert(value is TFhirServiceDefinition);
  Inherited Insert(index, value);
end;

function TFhirServiceDefinitionList.Item(index: Integer): TFhirServiceDefinition;
begin
  result := TFhirServiceDefinition(ObjectByIndex[index]);
end;

function TFhirServiceDefinitionList.Link: TFhirServiceDefinitionList;
begin
  result := TFhirServiceDefinitionList(inherited Link);
end;

procedure TFhirServiceDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirServiceDefinitionList.SetItemByIndex(index: Integer; value: TFhirServiceDefinition);
begin
  assert(value is TFhirServiceDefinition);
  FhirServiceDefinitions[index] := value;
end;

procedure TFhirServiceDefinitionList.SetItemN(index: Integer; value: TFhirServiceDefinition);
begin
  assert(value is TFhirServiceDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SERVICEDEFINITION}

{$IFDEF FHIR_STRUCTUREDEFINITION}

{ TFhirStructureDefinitionMapping }

constructor TFhirStructureDefinitionMapping.Create;
begin
  inherited;
end;

destructor TFhirStructureDefinitionMapping.Destroy;
begin
  FIdentity.free;
  FUri.free;
  FName.free;
  FComment.free;
  inherited;
end;

procedure TFhirStructureDefinitionMapping.Assign(oSource : TFslObject);
begin
  inherited;
  identityElement := TFhirStructureDefinitionMapping(oSource).identityElement.Clone;
  uriElement := TFhirStructureDefinitionMapping(oSource).uriElement.Clone;
  nameElement := TFhirStructureDefinitionMapping(oSource).nameElement.Clone;
  commentElement := TFhirStructureDefinitionMapping(oSource).commentElement.Clone;
end;

procedure TFhirStructureDefinitionMapping.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identity') Then
     list.add(self.link, 'identity', FIdentity.Link);
  if (child_name = 'uri') Then
     list.add(self.link, 'uri', FUri.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
end;

procedure TFhirStructureDefinitionMapping.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identity', 'id', false, TFhirId, FIdentity.Link));{2}
  oList.add(TFHIRProperty.create(self, 'uri', 'uri', false, TFhirUri, FUri.Link));{2}
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'comment', 'string', false, TFhirString, FComment.Link));{2}
end;

function TFhirStructureDefinitionMapping.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identity') then
  begin
    IdentityElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'uri') then
  begin
    UriElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirStructureDefinitionMapping.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirStructureDefinitionMapping.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identity') then result := TFhirId.create() {5b}
  else if (propName = 'uri') then result := TFhirUri.create() {5b}
  else if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'comment') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirStructureDefinitionMapping.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identity') then result := 'id'
  else if (propName = 'uri') then result := 'uri'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'comment') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirStructureDefinitionMapping.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identity') then IdentityElement := nil
  else if (propName = 'uri') then UriElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'comment') then CommentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirStructureDefinitionMapping.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identity') then IdentityElement := asId(new){5b}
  else if (propName = 'uri') then UriElement := asUri(new){5b}
  else if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'comment') then CommentElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirStructureDefinitionMapping.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirStructureDefinitionMapping.fhirType : string;
begin
  result := 'mapping';
end;

function TFhirStructureDefinitionMapping.Link : TFhirStructureDefinitionMapping;
begin
  result := TFhirStructureDefinitionMapping(inherited Link);
end;

function TFhirStructureDefinitionMapping.Clone : TFhirStructureDefinitionMapping;
begin
  result := TFhirStructureDefinitionMapping(inherited Clone);
end;

function TFhirStructureDefinitionMapping.equals(other : TObject) : boolean;
var
  o : TFhirStructureDefinitionMapping;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirStructureDefinitionMapping)) then
    result := false
  else
  begin
    o := TFhirStructureDefinitionMapping(other);
    result := compareDeep(identityElement, o.identityElement, true) and compareDeep(uriElement, o.uriElement, true) and
      compareDeep(nameElement, o.nameElement, true) and compareDeep(commentElement, o.commentElement, true);
  end;
end;

function TFhirStructureDefinitionMapping.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentity) and isEmptyProp(FUri) and isEmptyProp(FName) and isEmptyProp(FComment);
end;

procedure TFhirStructureDefinitionMapping.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identity');
  fields.add('uri');
  fields.add('name');
  fields.add('comment');
end;

{ TFhirStructureDefinitionMapping }

Procedure TFhirStructureDefinitionMapping.SetIdentity(value : TFhirId);
begin
  FIdentity.free;
  FIdentity := value;
end;

Function TFhirStructureDefinitionMapping.GetIdentityST : String;
begin
  if FIdentity = nil then
    result := ''
  else
    result := FIdentity.value;
end;

Procedure TFhirStructureDefinitionMapping.SetIdentityST(value : String);
begin
  if value <> '' then
  begin
    if FIdentity = nil then
      FIdentity := TFhirId.create;
    FIdentity.value := value
  end
  else if FIdentity <> nil then
    FIdentity.value := '';
end;

Procedure TFhirStructureDefinitionMapping.SetUri(value : TFhirUri);
begin
  FUri.free;
  FUri := value;
end;

Function TFhirStructureDefinitionMapping.GetUriST : String;
begin
  if FUri = nil then
    result := ''
  else
    result := FUri.value;
end;

Procedure TFhirStructureDefinitionMapping.SetUriST(value : String);
begin
  if value <> '' then
  begin
    if FUri = nil then
      FUri := TFhirUri.create;
    FUri.value := value
  end
  else if FUri <> nil then
    FUri.value := '';
end;

Procedure TFhirStructureDefinitionMapping.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirStructureDefinitionMapping.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirStructureDefinitionMapping.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirStructureDefinitionMapping.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value;
end;

Function TFhirStructureDefinitionMapping.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

Procedure TFhirStructureDefinitionMapping.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

function TFhirStructureDefinitionMapping.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentity.sizeInBytes);
  inc(result, FUri.sizeInBytes);
  inc(result, FName.sizeInBytes);
  inc(result, FComment.sizeInBytes);
end;

{ TFhirStructureDefinitionMappingListEnumerator }

Constructor TFhirStructureDefinitionMappingListEnumerator.Create(list : TFhirStructureDefinitionMappingList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirStructureDefinitionMappingListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirStructureDefinitionMappingListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirStructureDefinitionMappingListEnumerator.GetCurrent : TFhirStructureDefinitionMapping;
begin
  Result := FList[FIndex];
end;

function TFhirStructureDefinitionMappingListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirStructureDefinitionMappingList }
procedure TFhirStructureDefinitionMappingList.AddItem(value: TFhirStructureDefinitionMapping);
begin
  assert(value.ClassName = 'TFhirStructureDefinitionMapping', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirStructureDefinitionMapping');
  add(value);
end;

function TFhirStructureDefinitionMappingList.Append: TFhirStructureDefinitionMapping;
begin
  result := TFhirStructureDefinitionMapping.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureDefinitionMappingList.ClearItems;
begin
  Clear;
end;

function TFhirStructureDefinitionMappingList.GetEnumerator : TFhirStructureDefinitionMappingListEnumerator;
begin
  result := TFhirStructureDefinitionMappingListEnumerator.Create(self.link);
end;

function TFhirStructureDefinitionMappingList.Clone: TFhirStructureDefinitionMappingList;
begin
  result := TFhirStructureDefinitionMappingList(inherited Clone);
end;

function TFhirStructureDefinitionMappingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirStructureDefinitionMappingList.GetItemN(index: Integer): TFhirStructureDefinitionMapping;
begin
  result := TFhirStructureDefinitionMapping(ObjectByIndex[index]);
end;

function TFhirStructureDefinitionMappingList.ItemClass: TFslObjectClass;
begin
  result := TFhirStructureDefinitionMapping;
end;
function TFhirStructureDefinitionMappingList.IndexOf(value: TFhirStructureDefinitionMapping): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirStructureDefinitionMappingList.Insert(index: Integer): TFhirStructureDefinitionMapping;
begin
  result := TFhirStructureDefinitionMapping.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureDefinitionMappingList.InsertItem(index: Integer; value: TFhirStructureDefinitionMapping);
begin
  assert(value is TFhirStructureDefinitionMapping);
  Inherited Insert(index, value);
end;

function TFhirStructureDefinitionMappingList.Item(index: Integer): TFhirStructureDefinitionMapping;
begin
  result := TFhirStructureDefinitionMapping(ObjectByIndex[index]);
end;

function TFhirStructureDefinitionMappingList.Link: TFhirStructureDefinitionMappingList;
begin
  result := TFhirStructureDefinitionMappingList(inherited Link);
end;

procedure TFhirStructureDefinitionMappingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirStructureDefinitionMappingList.SetItemByIndex(index: Integer; value: TFhirStructureDefinitionMapping);
begin
  assert(value is TFhirStructureDefinitionMapping);
  FhirStructureDefinitionMappings[index] := value;
end;

procedure TFhirStructureDefinitionMappingList.SetItemN(index: Integer; value: TFhirStructureDefinitionMapping);
begin
  assert(value is TFhirStructureDefinitionMapping);
  ObjectByIndex[index] := value;
end;

{ TFhirStructureDefinitionSnapshot }

constructor TFhirStructureDefinitionSnapshot.Create;
begin
  inherited;
end;

destructor TFhirStructureDefinitionSnapshot.Destroy;
begin
  FElementList.Free;
  inherited;
end;

procedure TFhirStructureDefinitionSnapshot.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirStructureDefinitionSnapshot(oSource).FElementList = nil) then
  begin
    FElementList.free;
    FElementList := nil;
  end
  else
  begin
    if FElementList = nil then
      FElementList := TFhirElementDefinitionList.Create;
    FElementList.Assign(TFhirStructureDefinitionSnapshot(oSource).FElementList);
  end;
end;

procedure TFhirStructureDefinitionSnapshot.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'element') Then
    list.addAll(self, 'element', FElementList);
end;

procedure TFhirStructureDefinitionSnapshot.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'element', 'ElementDefinition', true, TFhirElementDefinition, FElementList.Link)){3};
end;

function TFhirStructureDefinitionSnapshot.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'element') then
  begin
    ElementList.add(propValue as TFhirElementDefinition){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirStructureDefinitionSnapshot.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'element') then ElementList.insertItem(index, propValue as TFhirElementDefinition){2a}
  else inherited;
end;

function TFhirStructureDefinitionSnapshot.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'element') then result := ElementList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirStructureDefinitionSnapshot.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'element') then result := 'ElementDefinition'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirStructureDefinitionSnapshot.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'element') then deletePropertyValue('element', ElementList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirStructureDefinitionSnapshot.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'element') then replacePropertyValue('element', ElementList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirStructureDefinitionSnapshot.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'element') then ElementList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirStructureDefinitionSnapshot.fhirType : string;
begin
  result := 'snapshot';
end;

function TFhirStructureDefinitionSnapshot.Link : TFhirStructureDefinitionSnapshot;
begin
  result := TFhirStructureDefinitionSnapshot(inherited Link);
end;

function TFhirStructureDefinitionSnapshot.Clone : TFhirStructureDefinitionSnapshot;
begin
  result := TFhirStructureDefinitionSnapshot(inherited Clone);
end;

function TFhirStructureDefinitionSnapshot.equals(other : TObject) : boolean;
var
  o : TFhirStructureDefinitionSnapshot;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirStructureDefinitionSnapshot)) then
    result := false
  else
  begin
    o := TFhirStructureDefinitionSnapshot(other);
    result := compareDeep(elementList, o.elementList, true);
  end;
end;

function TFhirStructureDefinitionSnapshot.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FelementList);
end;

procedure TFhirStructureDefinitionSnapshot.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('element');
end;

{ TFhirStructureDefinitionSnapshot }

Function TFhirStructureDefinitionSnapshot.GetElementList : TFhirElementDefinitionList;
begin
  if FElementList = nil then
    FElementList := TFhirElementDefinitionList.Create;
  result := FElementList;
end;

Function TFhirStructureDefinitionSnapshot.GetHasElementList : boolean;
begin
  result := (FElementList <> nil) and (FElementList.count > 0);
end;

function TFhirStructureDefinitionSnapshot.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FelementList.sizeInBytes);
end;

{ TFhirStructureDefinitionSnapshotListEnumerator }

Constructor TFhirStructureDefinitionSnapshotListEnumerator.Create(list : TFhirStructureDefinitionSnapshotList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirStructureDefinitionSnapshotListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirStructureDefinitionSnapshotListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirStructureDefinitionSnapshotListEnumerator.GetCurrent : TFhirStructureDefinitionSnapshot;
begin
  Result := FList[FIndex];
end;

function TFhirStructureDefinitionSnapshotListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirStructureDefinitionSnapshotList }
procedure TFhirStructureDefinitionSnapshotList.AddItem(value: TFhirStructureDefinitionSnapshot);
begin
  assert(value.ClassName = 'TFhirStructureDefinitionSnapshot', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirStructureDefinitionSnapshot');
  add(value);
end;

function TFhirStructureDefinitionSnapshotList.Append: TFhirStructureDefinitionSnapshot;
begin
  result := TFhirStructureDefinitionSnapshot.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureDefinitionSnapshotList.ClearItems;
begin
  Clear;
end;

function TFhirStructureDefinitionSnapshotList.GetEnumerator : TFhirStructureDefinitionSnapshotListEnumerator;
begin
  result := TFhirStructureDefinitionSnapshotListEnumerator.Create(self.link);
end;

function TFhirStructureDefinitionSnapshotList.Clone: TFhirStructureDefinitionSnapshotList;
begin
  result := TFhirStructureDefinitionSnapshotList(inherited Clone);
end;

function TFhirStructureDefinitionSnapshotList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirStructureDefinitionSnapshotList.GetItemN(index: Integer): TFhirStructureDefinitionSnapshot;
begin
  result := TFhirStructureDefinitionSnapshot(ObjectByIndex[index]);
end;

function TFhirStructureDefinitionSnapshotList.ItemClass: TFslObjectClass;
begin
  result := TFhirStructureDefinitionSnapshot;
end;
function TFhirStructureDefinitionSnapshotList.IndexOf(value: TFhirStructureDefinitionSnapshot): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirStructureDefinitionSnapshotList.Insert(index: Integer): TFhirStructureDefinitionSnapshot;
begin
  result := TFhirStructureDefinitionSnapshot.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureDefinitionSnapshotList.InsertItem(index: Integer; value: TFhirStructureDefinitionSnapshot);
begin
  assert(value is TFhirStructureDefinitionSnapshot);
  Inherited Insert(index, value);
end;

function TFhirStructureDefinitionSnapshotList.Item(index: Integer): TFhirStructureDefinitionSnapshot;
begin
  result := TFhirStructureDefinitionSnapshot(ObjectByIndex[index]);
end;

function TFhirStructureDefinitionSnapshotList.Link: TFhirStructureDefinitionSnapshotList;
begin
  result := TFhirStructureDefinitionSnapshotList(inherited Link);
end;

procedure TFhirStructureDefinitionSnapshotList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirStructureDefinitionSnapshotList.SetItemByIndex(index: Integer; value: TFhirStructureDefinitionSnapshot);
begin
  assert(value is TFhirStructureDefinitionSnapshot);
  FhirStructureDefinitionSnapshots[index] := value;
end;

procedure TFhirStructureDefinitionSnapshotList.SetItemN(index: Integer; value: TFhirStructureDefinitionSnapshot);
begin
  assert(value is TFhirStructureDefinitionSnapshot);
  ObjectByIndex[index] := value;
end;

{ TFhirStructureDefinitionDifferential }

constructor TFhirStructureDefinitionDifferential.Create;
begin
  inherited;
end;

destructor TFhirStructureDefinitionDifferential.Destroy;
begin
  FElementList.Free;
  inherited;
end;

procedure TFhirStructureDefinitionDifferential.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirStructureDefinitionDifferential(oSource).FElementList = nil) then
  begin
    FElementList.free;
    FElementList := nil;
  end
  else
  begin
    if FElementList = nil then
      FElementList := TFhirElementDefinitionList.Create;
    FElementList.Assign(TFhirStructureDefinitionDifferential(oSource).FElementList);
  end;
end;

procedure TFhirStructureDefinitionDifferential.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'element') Then
    list.addAll(self, 'element', FElementList);
end;

procedure TFhirStructureDefinitionDifferential.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'element', 'ElementDefinition', true, TFhirElementDefinition, FElementList.Link)){3};
end;

function TFhirStructureDefinitionDifferential.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'element') then
  begin
    ElementList.add(propValue as TFhirElementDefinition){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirStructureDefinitionDifferential.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'element') then ElementList.insertItem(index, propValue as TFhirElementDefinition){2a}
  else inherited;
end;

function TFhirStructureDefinitionDifferential.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'element') then result := ElementList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirStructureDefinitionDifferential.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'element') then result := 'ElementDefinition'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirStructureDefinitionDifferential.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'element') then deletePropertyValue('element', ElementList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirStructureDefinitionDifferential.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'element') then replacePropertyValue('element', ElementList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirStructureDefinitionDifferential.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'element') then ElementList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirStructureDefinitionDifferential.fhirType : string;
begin
  result := 'differential';
end;

function TFhirStructureDefinitionDifferential.Link : TFhirStructureDefinitionDifferential;
begin
  result := TFhirStructureDefinitionDifferential(inherited Link);
end;

function TFhirStructureDefinitionDifferential.Clone : TFhirStructureDefinitionDifferential;
begin
  result := TFhirStructureDefinitionDifferential(inherited Clone);
end;

function TFhirStructureDefinitionDifferential.equals(other : TObject) : boolean;
var
  o : TFhirStructureDefinitionDifferential;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirStructureDefinitionDifferential)) then
    result := false
  else
  begin
    o := TFhirStructureDefinitionDifferential(other);
    result := compareDeep(elementList, o.elementList, true);
  end;
end;

function TFhirStructureDefinitionDifferential.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FelementList);
end;

procedure TFhirStructureDefinitionDifferential.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('element');
end;

{ TFhirStructureDefinitionDifferential }

Function TFhirStructureDefinitionDifferential.GetElementList : TFhirElementDefinitionList;
begin
  if FElementList = nil then
    FElementList := TFhirElementDefinitionList.Create;
  result := FElementList;
end;

Function TFhirStructureDefinitionDifferential.GetHasElementList : boolean;
begin
  result := (FElementList <> nil) and (FElementList.count > 0);
end;

function TFhirStructureDefinitionDifferential.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FelementList.sizeInBytes);
end;

{ TFhirStructureDefinitionDifferentialListEnumerator }

Constructor TFhirStructureDefinitionDifferentialListEnumerator.Create(list : TFhirStructureDefinitionDifferentialList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirStructureDefinitionDifferentialListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirStructureDefinitionDifferentialListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirStructureDefinitionDifferentialListEnumerator.GetCurrent : TFhirStructureDefinitionDifferential;
begin
  Result := FList[FIndex];
end;

function TFhirStructureDefinitionDifferentialListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirStructureDefinitionDifferentialList }
procedure TFhirStructureDefinitionDifferentialList.AddItem(value: TFhirStructureDefinitionDifferential);
begin
  assert(value.ClassName = 'TFhirStructureDefinitionDifferential', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirStructureDefinitionDifferential');
  add(value);
end;

function TFhirStructureDefinitionDifferentialList.Append: TFhirStructureDefinitionDifferential;
begin
  result := TFhirStructureDefinitionDifferential.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureDefinitionDifferentialList.ClearItems;
begin
  Clear;
end;

function TFhirStructureDefinitionDifferentialList.GetEnumerator : TFhirStructureDefinitionDifferentialListEnumerator;
begin
  result := TFhirStructureDefinitionDifferentialListEnumerator.Create(self.link);
end;

function TFhirStructureDefinitionDifferentialList.Clone: TFhirStructureDefinitionDifferentialList;
begin
  result := TFhirStructureDefinitionDifferentialList(inherited Clone);
end;

function TFhirStructureDefinitionDifferentialList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirStructureDefinitionDifferentialList.GetItemN(index: Integer): TFhirStructureDefinitionDifferential;
begin
  result := TFhirStructureDefinitionDifferential(ObjectByIndex[index]);
end;

function TFhirStructureDefinitionDifferentialList.ItemClass: TFslObjectClass;
begin
  result := TFhirStructureDefinitionDifferential;
end;
function TFhirStructureDefinitionDifferentialList.IndexOf(value: TFhirStructureDefinitionDifferential): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirStructureDefinitionDifferentialList.Insert(index: Integer): TFhirStructureDefinitionDifferential;
begin
  result := TFhirStructureDefinitionDifferential.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureDefinitionDifferentialList.InsertItem(index: Integer; value: TFhirStructureDefinitionDifferential);
begin
  assert(value is TFhirStructureDefinitionDifferential);
  Inherited Insert(index, value);
end;

function TFhirStructureDefinitionDifferentialList.Item(index: Integer): TFhirStructureDefinitionDifferential;
begin
  result := TFhirStructureDefinitionDifferential(ObjectByIndex[index]);
end;

function TFhirStructureDefinitionDifferentialList.Link: TFhirStructureDefinitionDifferentialList;
begin
  result := TFhirStructureDefinitionDifferentialList(inherited Link);
end;

procedure TFhirStructureDefinitionDifferentialList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirStructureDefinitionDifferentialList.SetItemByIndex(index: Integer; value: TFhirStructureDefinitionDifferential);
begin
  assert(value is TFhirStructureDefinitionDifferential);
  FhirStructureDefinitionDifferentials[index] := value;
end;

procedure TFhirStructureDefinitionDifferentialList.SetItemN(index: Integer; value: TFhirStructureDefinitionDifferential);
begin
  assert(value is TFhirStructureDefinitionDifferential);
  ObjectByIndex[index] := value;
end;

{ TFhirStructureDefinition }

constructor TFhirStructureDefinition.Create;
begin
  inherited;
end;

destructor TFhirStructureDefinition.Destroy;
begin
  FIdentifierList.Free;
  FPurpose.free;
  FCopyright.free;
  FKeywordList.Free;
  FFhirVersion.free;
  FMappingList.Free;
  FKind.free;
  FAbstract.free;
  FContextType.free;
  FContextList.Free;
  FContextInvariantList.Free;
  FType_.free;
  FBaseDefinition.free;
  FDerivation.free;
  FSnapshot.free;
  FDifferential.free;
  inherited;
end;

function TFhirStructureDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtStructureDefinition;
end;

procedure TFhirStructureDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirStructureDefinition(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirStructureDefinition(oSource).FIdentifierList);
  end;
  purposeElement := TFhirStructureDefinition(oSource).purposeElement.Clone;
  copyrightElement := TFhirStructureDefinition(oSource).copyrightElement.Clone;
  if (TFhirStructureDefinition(oSource).FKeywordList = nil) then
  begin
    FKeywordList.free;
    FKeywordList := nil;
  end
  else
  begin
    if FKeywordList = nil then
      FKeywordList := TFhirCodingList.Create;
    FKeywordList.Assign(TFhirStructureDefinition(oSource).FKeywordList);
  end;
  fhirVersionElement := TFhirStructureDefinition(oSource).fhirVersionElement.Clone;
  if (TFhirStructureDefinition(oSource).FMappingList = nil) then
  begin
    FMappingList.free;
    FMappingList := nil;
  end
  else
  begin
    if FMappingList = nil then
      FMappingList := TFhirStructureDefinitionMappingList.Create;
    FMappingList.Assign(TFhirStructureDefinition(oSource).FMappingList);
  end;
  FKind := TFhirStructureDefinition(oSource).FKind.Link;
  abstractElement := TFhirStructureDefinition(oSource).abstractElement.Clone;
  FContextType := TFhirStructureDefinition(oSource).FContextType.Link;
  if (TFhirStructureDefinition(oSource).FContextList = nil) then
  begin
    FContextList.free;
    FContextList := nil;
  end
  else
  begin
    if FContextList = nil then
      FContextList := TFhirStringList.Create;
    FContextList.Assign(TFhirStructureDefinition(oSource).FContextList);
  end;
  if (TFhirStructureDefinition(oSource).FContextInvariantList = nil) then
  begin
    FContextInvariantList.free;
    FContextInvariantList := nil;
  end
  else
  begin
    if FContextInvariantList = nil then
      FContextInvariantList := TFhirStringList.Create;
    FContextInvariantList.Assign(TFhirStructureDefinition(oSource).FContextInvariantList);
  end;
  type_Element := TFhirStructureDefinition(oSource).type_Element.Clone;
  baseDefinitionElement := TFhirStructureDefinition(oSource).baseDefinitionElement.Clone;
  FDerivation := TFhirStructureDefinition(oSource).FDerivation.Link;
  snapshot := TFhirStructureDefinition(oSource).snapshot.Clone;
  differential := TFhirStructureDefinition(oSource).differential.Clone;
end;

procedure TFhirStructureDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'keyword') Then
    list.addAll(self, 'keyword', FKeywordList);
  if (child_name = 'fhirVersion') Then
     list.add(self.link, 'fhirVersion', FFhirVersion.Link);
  if (child_name = 'mapping') Then
    list.addAll(self, 'mapping', FMappingList);
  if (child_name = 'kind') Then
     list.add(self.link, 'kind', FKind.Link);
  if (child_name = 'abstract') Then
     list.add(self.link, 'abstract', FAbstract.Link);
  if (child_name = 'contextType') Then
     list.add(self.link, 'contextType', FContextType.Link);
  if (child_name = 'context') Then
    list.addAll(self, 'context', FContextList);
  if (child_name = 'contextInvariant') Then
    list.addAll(self, 'contextInvariant', FContextInvariantList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'baseDefinition') Then
     list.add(self.link, 'baseDefinition', FBaseDefinition.Link);
  if (child_name = 'derivation') Then
     list.add(self.link, 'derivation', FDerivation.Link);
  if (child_name = 'snapshot') Then
     list.add(self.link, 'snapshot', FSnapshot.Link);
  if (child_name = 'differential') Then
     list.add(self.link, 'differential', FDifferential.Link);
end;

procedure TFhirStructureDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));{2}
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));{2}
  oList.add(TFHIRProperty.create(self, 'keyword', 'Coding', true, TFhirCoding, FKeywordList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'fhirVersion', 'id', false, TFhirId, FFhirVersion.Link));{2}
  oList.add(TFHIRProperty.create(self, 'mapping', '', true, TFhirStructureDefinitionMapping, FMappingList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'kind', 'code', false, TFHIREnum, FKind.Link));{1}
  oList.add(TFHIRProperty.create(self, 'abstract', 'boolean', false, TFhirBoolean, FAbstract.Link));{2}
  oList.add(TFHIRProperty.create(self, 'contextType', 'code', false, TFHIREnum, FContextType.Link));{1}
  oList.add(TFHIRProperty.create(self, 'context', 'string', true, TFhirString, FContextList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'contextInvariant', 'string', true, TFhirString, FContextInvariantList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirCode, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'baseDefinition', 'uri', false, TFhirUri, FBaseDefinition.Link));{2}
  oList.add(TFHIRProperty.create(self, 'derivation', 'code', false, TFHIREnum, FDerivation.Link));{1}
  oList.add(TFHIRProperty.create(self, 'snapshot', '', false, TFhirStructureDefinitionSnapshot, FSnapshot.Link));{2}
  oList.add(TFHIRProperty.create(self, 'differential', '', false, TFhirStructureDefinitionDifferential, FDifferential.Link));{2}
end;

function TFhirStructureDefinition.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'keyword') then
  begin
    KeywordList.add(propValue as TFhirCoding){2a};
    result := propValue;
  end
  else if (propName = 'fhirVersion') then
  begin
    FhirVersionElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'mapping') then
  begin
    MappingList.add(propValue as TFhirStructureDefinitionMapping){2a};
    result := propValue;
  end
  else if (propName = 'kind') then
  begin
    KindElement := asEnum(SYSTEMS_TFhirStructureDefinitionKindEnum, CODES_TFhirStructureDefinitionKindEnum, propValue);
    result := propValue
  end
  else if (propName = 'abstract') then
  begin
    AbstractElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'contextType') then
  begin
    ContextTypeElement := asEnum(SYSTEMS_TFhirExtensionContextEnum, CODES_TFhirExtensionContextEnum, propValue);
    result := propValue
  end
  else if (propName = 'context') then
  begin
    ContextList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'contextInvariant') then
  begin
    ContextInvariantList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'type') then
  begin
    Type_Element := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'baseDefinition') then
  begin
    BaseDefinitionElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'derivation') then
  begin
    DerivationElement := asEnum(SYSTEMS_TFhirTypeDerivationRuleEnum, CODES_TFhirTypeDerivationRuleEnum, propValue);
    result := propValue
  end
  else if (propName = 'snapshot') then
  begin
    Snapshot := propValue as TFhirStructureDefinitionSnapshot{4b};
    result := propValue;
  end
  else if (propName = 'differential') then
  begin
    Differential := propValue as TFhirStructureDefinitionDifferential{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirStructureDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'keyword') then KeywordList.insertItem(index, propValue as TFhirCoding){2a}
  else if (propName = 'mapping') then MappingList.insertItem(index, propValue as TFhirStructureDefinitionMapping){2a}
  else if (propName = 'context') then ContextList.insertItem(index, asString(propValue)){2}
  else if (propName = 'contextInvariant') then ContextInvariantList.insertItem(index, asString(propValue)){2}
  else inherited;
end;

function TFhirStructureDefinition.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'purpose') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'copyright') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'keyword') then result := KeywordList.new(){2}
  else if (propName = 'fhirVersion') then result := TFhirId.create() {5b}
  else if (propName = 'mapping') then result := MappingList.new(){2}
  else if (propName = 'abstract') then result := TFhirBoolean.create() {5b}
  else if (propName = 'context') then result := ContextList.new(){2}
  else if (propName = 'contextInvariant') then result := ContextInvariantList.new(){2}
  else if (propName = 'type') then result := TFhirCode.create() {5b}
  else if (propName = 'baseDefinition') then result := TFhirUri.create() {5b}
  else if (propName = 'snapshot') then result := TFhirStructureDefinitionSnapshot.create(){4b}
  else if (propName = 'differential') then result := TFhirStructureDefinitionDifferential.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirStructureDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'keyword') then result := 'Coding'
  else if (propName = 'fhirVersion') then result := 'id'
  else if (propName = 'mapping') then result := ''
  else if (propName = 'kind') then result := 'code'
  else if (propName = 'abstract') then result := 'boolean'
  else if (propName = 'contextType') then result := 'code'
  else if (propName = 'context') then result := 'string'
  else if (propName = 'contextInvariant') then result := 'string'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'baseDefinition') then result := 'uri'
  else if (propName = 'derivation') then result := 'code'
  else if (propName = 'snapshot') then result := ''
  else if (propName = 'differential') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirStructureDefinition.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'keyword') then deletePropertyValue('keyword', KeywordList, value) {2}
  else if (propName = 'fhirVersion') then FhirVersionElement := nil
  else if (propName = 'mapping') then deletePropertyValue('mapping', MappingList, value) {2}
  else if (propName = 'kind') then KindElement := nil
  else if (propName = 'abstract') then AbstractElement := nil
  else if (propName = 'contextType') then ContextTypeElement := nil
  else if (propName = 'context') then deletePropertyValue('context', ContextList, value) {2}
  else if (propName = 'contextInvariant') then deletePropertyValue('contextInvariant', ContextInvariantList, value) {2}
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'baseDefinition') then BaseDefinitionElement := nil
  else if (propName = 'derivation') then DerivationElement := nil
  else if (propName = 'snapshot') then SnapshotElement := nil
  else if (propName = 'differential') then DifferentialElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirStructureDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'purpose') then PurposeElement := asMarkdown(new){5b}
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new){5b}
  else if (propName = 'keyword') then replacePropertyValue('keyword', KeywordList, existing, new) {2}
  else if (propName = 'fhirVersion') then FhirVersionElement := asId(new){5b}
  else if (propName = 'mapping') then replacePropertyValue('mapping', MappingList, existing, new) {2}
  else if (propName = 'kind') then KindElement := asEnum(SYSTEMS_TFhirStructureDefinitionKindEnum, CODES_TFhirStructureDefinitionKindEnum, new){4}
  else if (propName = 'abstract') then AbstractElement := asBoolean(new){5b}
  else if (propName = 'contextType') then ContextTypeElement := asEnum(SYSTEMS_TFhirExtensionContextEnum, CODES_TFhirExtensionContextEnum, new){4}
  else if (propName = 'context') then replacePropertyValue('context', ContextList, existing, new) {2}
  else if (propName = 'contextInvariant') then replacePropertyValue('contextInvariant', ContextInvariantList, existing, new) {2}
  else if (propName = 'type') then Type_Element := asCode(new){5b}
  else if (propName = 'baseDefinition') then BaseDefinitionElement := asUri(new){5b}
  else if (propName = 'derivation') then DerivationElement := asEnum(SYSTEMS_TFhirTypeDerivationRuleEnum, CODES_TFhirTypeDerivationRuleEnum, new){4}
  else if (propName = 'snapshot') then SnapshotElement := new as TFhirStructureDefinitionSnapshot{4}
  else if (propName = 'differential') then DifferentialElement := new as TFhirStructureDefinitionDifferential{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirStructureDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'keyword') then KeywordList.move(source, destination){2a}
  else if (propName = 'mapping') then MappingList.move(source, destination){2a}
  else if (propName = 'context') then ContextList.move(source, destination){2}
  else if (propName = 'contextInvariant') then ContextInvariantList.move(source, destination){2}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirStructureDefinition.fhirType : string;
begin
  result := 'StructureDefinition';
end;

function TFhirStructureDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FPurpose) and isEmptyProp(FCopyright) and isEmptyProp(FkeywordList) and isEmptyProp(FFhirVersion) and isEmptyProp(FmappingList) and isEmptyProp(FKind) and isEmptyProp(FAbstract) and isEmptyProp(FContextType) and isEmptyProp(FcontextList) and isEmptyProp(FcontextInvariantList) and isEmptyProp(FType_) and isEmptyProp(FBaseDefinition) and isEmptyProp(FDerivation) and isEmptyProp(FSnapshot) and isEmptyProp(FDifferential);
end;

function TFhirStructureDefinition.equals(other : TObject) : boolean;
var
  o : TFhirStructureDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirStructureDefinition)) then
    result := false
  else
  begin
    o := TFhirStructureDefinition(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(purposeElement, o.purposeElement, true) and
      compareDeep(copyrightElement, o.copyrightElement, true) and compareDeep(keywordList, o.keywordList, true) and
      compareDeep(fhirVersionElement, o.fhirVersionElement, true) and compareDeep(mappingList, o.mappingList, true) and
      compareDeep(kindElement, o.kindElement, true) and compareDeep(abstractElement, o.abstractElement, true) and
      compareDeep(contextTypeElement, o.contextTypeElement, true) and compareDeep(contextList, o.contextList, true) and
      compareDeep(contextInvariantList, o.contextInvariantList, true) and compareDeep(type_Element, o.type_Element, true) and
      compareDeep(baseDefinitionElement, o.baseDefinitionElement, true) and compareDeep(derivationElement, o.derivationElement, true) and
      compareDeep(snapshotElement, o.snapshotElement, true) and compareDeep(differentialElement, o.differentialElement, true);
  end;
end;

function TFhirStructureDefinition.Link : TFhirStructureDefinition;
begin
  result := TFhirStructureDefinition(inherited Link);
end;

function TFhirStructureDefinition.Clone : TFhirStructureDefinition;
begin
  result := TFhirStructureDefinition(inherited Clone);
end;

procedure TFhirStructureDefinition.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('status');
  fields.add('experimental');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('purpose');
  fields.add('copyright');
  fields.add('keyword');
  fields.add('fhirVersion');
  fields.add('mapping');
  fields.add('kind');
  fields.add('abstract');
  fields.add('contextType');
  fields.add('context');
  fields.add('contextInvariant');
  fields.add('type');
  fields.add('baseDefinition');
  fields.add('derivation');
  fields.add('snapshot');
  fields.add('differential');
end;

{ TFhirStructureDefinition }

Function TFhirStructureDefinition.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirStructureDefinition.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirStructureDefinition.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

Function TFhirStructureDefinition.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

Procedure TFhirStructureDefinition.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

Procedure TFhirStructureDefinition.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

Function TFhirStructureDefinition.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

Procedure TFhirStructureDefinition.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

Function TFhirStructureDefinition.GetKeywordList : TFhirCodingList;
begin
  if FKeywordList = nil then
    FKeywordList := TFhirCodingList.Create;
  result := FKeywordList;
end;

Function TFhirStructureDefinition.GetHasKeywordList : boolean;
begin
  result := (FKeywordList <> nil) and (FKeywordList.count > 0);
end;

Procedure TFhirStructureDefinition.SetFhirVersion(value : TFhirId);
begin
  FFhirVersion.free;
  FFhirVersion := value;
end;

Function TFhirStructureDefinition.GetFhirVersionST : String;
begin
  if FFhirVersion = nil then
    result := ''
  else
    result := FFhirVersion.value;
end;

Procedure TFhirStructureDefinition.SetFhirVersionST(value : String);
begin
  if value <> '' then
  begin
    if FFhirVersion = nil then
      FFhirVersion := TFhirId.create;
    FFhirVersion.value := value
  end
  else if FFhirVersion <> nil then
    FFhirVersion.value := '';
end;

Function TFhirStructureDefinition.GetMappingList : TFhirStructureDefinitionMappingList;
begin
  if FMappingList = nil then
    FMappingList := TFhirStructureDefinitionMappingList.Create;
  result := FMappingList;
end;

Function TFhirStructureDefinition.GetHasMappingList : boolean;
begin
  result := (FMappingList <> nil) and (FMappingList.count > 0);
end;

Procedure TFhirStructureDefinition.SetKind(value : TFhirEnum);
begin
  FKind.free;
  FKind := value;
end;

Function TFhirStructureDefinition.GetKindST : TFhirStructureDefinitionKindEnum;
begin
  if FKind = nil then
    result := TFhirStructureDefinitionKindEnum(0)
  else
    result := TFhirStructureDefinitionKindEnum(StringArrayIndexOfSensitive(CODES_TFhirStructureDefinitionKindEnum, FKind.value));
end;

Procedure TFhirStructureDefinition.SetKindST(value : TFhirStructureDefinitionKindEnum);
begin
  if ord(value) = 0 then
    KindElement := nil
  else
    KindElement := TFhirEnum.create(SYSTEMS_TFhirStructureDefinitionKindEnum[value], CODES_TFhirStructureDefinitionKindEnum[value]);
end;

Procedure TFhirStructureDefinition.SetAbstract(value : TFhirBoolean);
begin
  FAbstract.free;
  FAbstract := value;
end;

Function TFhirStructureDefinition.GetAbstractST : Boolean;
begin
  if FAbstract = nil then
    result := false
  else
    result := FAbstract.value;
end;

Procedure TFhirStructureDefinition.SetAbstractST(value : Boolean);
begin
  if FAbstract = nil then
    FAbstract := TFhirBoolean.create;
  FAbstract.value := value
end;

Procedure TFhirStructureDefinition.SetContextType(value : TFhirEnum);
begin
  FContextType.free;
  FContextType := value;
end;

Function TFhirStructureDefinition.GetContextTypeST : TFhirExtensionContextEnum;
begin
  if FContextType = nil then
    result := TFhirExtensionContextEnum(0)
  else
    result := TFhirExtensionContextEnum(StringArrayIndexOfSensitive(CODES_TFhirExtensionContextEnum, FContextType.value));
end;

Procedure TFhirStructureDefinition.SetContextTypeST(value : TFhirExtensionContextEnum);
begin
  if ord(value) = 0 then
    ContextTypeElement := nil
  else
    ContextTypeElement := TFhirEnum.create(SYSTEMS_TFhirExtensionContextEnum[value], CODES_TFhirExtensionContextEnum[value]);
end;

Function TFhirStructureDefinition.GetContextList : TFhirStringList;
begin
  if FContextList = nil then
    FContextList := TFhirStringList.Create;
  result := FContextList;
end;

Function TFhirStructureDefinition.GetHasContextList : boolean;
begin
  result := (FContextList <> nil) and (FContextList.count > 0);
end;

Function TFhirStructureDefinition.GetContextInvariantList : TFhirStringList;
begin
  if FContextInvariantList = nil then
    FContextInvariantList := TFhirStringList.Create;
  result := FContextInvariantList;
end;

Function TFhirStructureDefinition.GetHasContextInvariantList : boolean;
begin
  result := (FContextInvariantList <> nil) and (FContextInvariantList.count > 0);
end;

Procedure TFhirStructureDefinition.SetType_(value : TFhirCode);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirStructureDefinition.GetType_ST : String;
begin
  if FType_ = nil then
    result := ''
  else
    result := FType_.value;
end;

Procedure TFhirStructureDefinition.SetType_ST(value : String);
begin
  if value <> '' then
  begin
    if FType_ = nil then
      FType_ := TFhirCode.create;
    FType_.value := value
  end
  else if FType_ <> nil then
    FType_.value := '';
end;

Procedure TFhirStructureDefinition.SetBaseDefinition(value : TFhirUri);
begin
  FBaseDefinition.free;
  FBaseDefinition := value;
end;

Function TFhirStructureDefinition.GetBaseDefinitionST : String;
begin
  if FBaseDefinition = nil then
    result := ''
  else
    result := FBaseDefinition.value;
end;

Procedure TFhirStructureDefinition.SetBaseDefinitionST(value : String);
begin
  if value <> '' then
  begin
    if FBaseDefinition = nil then
      FBaseDefinition := TFhirUri.create;
    FBaseDefinition.value := value
  end
  else if FBaseDefinition <> nil then
    FBaseDefinition.value := '';
end;

Procedure TFhirStructureDefinition.SetDerivation(value : TFhirEnum);
begin
  FDerivation.free;
  FDerivation := value;
end;

Function TFhirStructureDefinition.GetDerivationST : TFhirTypeDerivationRuleEnum;
begin
  if FDerivation = nil then
    result := TFhirTypeDerivationRuleEnum(0)
  else
    result := TFhirTypeDerivationRuleEnum(StringArrayIndexOfSensitive(CODES_TFhirTypeDerivationRuleEnum, FDerivation.value));
end;

Procedure TFhirStructureDefinition.SetDerivationST(value : TFhirTypeDerivationRuleEnum);
begin
  if ord(value) = 0 then
    DerivationElement := nil
  else
    DerivationElement := TFhirEnum.create(SYSTEMS_TFhirTypeDerivationRuleEnum[value], CODES_TFhirTypeDerivationRuleEnum[value]);
end;

Procedure TFhirStructureDefinition.SetSnapshot(value : TFhirStructureDefinitionSnapshot);
begin
  FSnapshot.free;
  FSnapshot := value;
end;

Procedure TFhirStructureDefinition.SetDifferential(value : TFhirStructureDefinitionDifferential);
begin
  FDifferential.free;
  FDifferential := value;
end;

function TFhirStructureDefinition.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FPurpose.sizeInBytes);
  inc(result, FCopyright.sizeInBytes);
  inc(result, FkeywordList.sizeInBytes);
  inc(result, FFhirVersion.sizeInBytes);
  inc(result, FmappingList.sizeInBytes);
  inc(result, FKind.sizeInBytes);
  inc(result, FAbstract.sizeInBytes);
  inc(result, FContextType.sizeInBytes);
  inc(result, FcontextList.sizeInBytes);
  inc(result, FcontextInvariantList.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FBaseDefinition.sizeInBytes);
  inc(result, FDerivation.sizeInBytes);
  inc(result, FSnapshot.sizeInBytes);
  inc(result, FDifferential.sizeInBytes);
end;

{ TFhirStructureDefinitionListEnumerator }

Constructor TFhirStructureDefinitionListEnumerator.Create(list : TFhirStructureDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirStructureDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirStructureDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirStructureDefinitionListEnumerator.GetCurrent : TFhirStructureDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirStructureDefinitionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirStructureDefinitionList }
procedure TFhirStructureDefinitionList.AddItem(value: TFhirStructureDefinition);
begin
  assert(value.ClassName = 'TFhirStructureDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirStructureDefinition');
  add(value);
end;

function TFhirStructureDefinitionList.Append: TFhirStructureDefinition;
begin
  result := TFhirStructureDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirStructureDefinitionList.GetEnumerator : TFhirStructureDefinitionListEnumerator;
begin
  result := TFhirStructureDefinitionListEnumerator.Create(self.link);
end;

function TFhirStructureDefinitionList.Clone: TFhirStructureDefinitionList;
begin
  result := TFhirStructureDefinitionList(inherited Clone);
end;

function TFhirStructureDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirStructureDefinitionList.GetItemN(index: Integer): TFhirStructureDefinition;
begin
  result := TFhirStructureDefinition(ObjectByIndex[index]);
end;

function TFhirStructureDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirStructureDefinition;
end;
function TFhirStructureDefinitionList.IndexOf(value: TFhirStructureDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirStructureDefinitionList.Insert(index: Integer): TFhirStructureDefinition;
begin
  result := TFhirStructureDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureDefinitionList.InsertItem(index: Integer; value: TFhirStructureDefinition);
begin
  assert(value is TFhirStructureDefinition);
  Inherited Insert(index, value);
end;

function TFhirStructureDefinitionList.Item(index: Integer): TFhirStructureDefinition;
begin
  result := TFhirStructureDefinition(ObjectByIndex[index]);
end;

function TFhirStructureDefinitionList.Link: TFhirStructureDefinitionList;
begin
  result := TFhirStructureDefinitionList(inherited Link);
end;

procedure TFhirStructureDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirStructureDefinitionList.SetItemByIndex(index: Integer; value: TFhirStructureDefinition);
begin
  assert(value is TFhirStructureDefinition);
  FhirStructureDefinitions[index] := value;
end;

procedure TFhirStructureDefinitionList.SetItemN(index: Integer; value: TFhirStructureDefinition);
begin
  assert(value is TFhirStructureDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_STRUCTUREDEFINITION}

{$IFDEF FHIR_STRUCTUREMAP}

{ TFhirStructureMapStructure }

constructor TFhirStructureMapStructure.Create;
begin
  inherited;
end;

destructor TFhirStructureMapStructure.Destroy;
begin
  FUrl.free;
  FMode.free;
  FAlias.free;
  FDocumentation.free;
  inherited;
end;

procedure TFhirStructureMapStructure.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirStructureMapStructure(oSource).urlElement.Clone;
  FMode := TFhirStructureMapStructure(oSource).FMode.Link;
  aliasElement := TFhirStructureMapStructure(oSource).aliasElement.Clone;
  documentationElement := TFhirStructureMapStructure(oSource).documentationElement.Clone;
end;

procedure TFhirStructureMapStructure.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'mode') Then
     list.add(self.link, 'mode', FMode.Link);
  if (child_name = 'alias') Then
     list.add(self.link, 'alias', FAlias.Link);
  if (child_name = 'documentation') Then
     list.add(self.link, 'documentation', FDocumentation.Link);
end;

procedure TFhirStructureMapStructure.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));{2}
  oList.add(TFHIRProperty.create(self, 'mode', 'code', false, TFHIREnum, FMode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'alias', 'string', false, TFhirString, FAlias.Link));{2}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', false, TFhirString, FDocumentation.Link));{2}
end;

function TFhirStructureMapStructure.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'mode') then
  begin
    ModeElement := asEnum(SYSTEMS_TFhirMapModelModeEnum, CODES_TFhirMapModelModeEnum, propValue);
    result := propValue
  end
  else if (propName = 'alias') then
  begin
    AliasElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'documentation') then
  begin
    DocumentationElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirStructureMapStructure.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirStructureMapStructure.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create() {5b}
  else if (propName = 'alias') then result := TFhirString.create() {5b}
  else if (propName = 'documentation') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirStructureMapStructure.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'mode') then result := 'code'
  else if (propName = 'alias') then result := 'string'
  else if (propName = 'documentation') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirStructureMapStructure.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'mode') then ModeElement := nil
  else if (propName = 'alias') then AliasElement := nil
  else if (propName = 'documentation') then DocumentationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirStructureMapStructure.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new){5b}
  else if (propName = 'mode') then ModeElement := asEnum(SYSTEMS_TFhirMapModelModeEnum, CODES_TFhirMapModelModeEnum, new){4}
  else if (propName = 'alias') then AliasElement := asString(new){5b}
  else if (propName = 'documentation') then DocumentationElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirStructureMapStructure.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirStructureMapStructure.fhirType : string;
begin
  result := 'structure';
end;

function TFhirStructureMapStructure.Link : TFhirStructureMapStructure;
begin
  result := TFhirStructureMapStructure(inherited Link);
end;

function TFhirStructureMapStructure.Clone : TFhirStructureMapStructure;
begin
  result := TFhirStructureMapStructure(inherited Clone);
end;

function TFhirStructureMapStructure.equals(other : TObject) : boolean;
var
  o : TFhirStructureMapStructure;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirStructureMapStructure)) then
    result := false
  else
  begin
    o := TFhirStructureMapStructure(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(modeElement, o.modeElement, true) and
      compareDeep(aliasElement, o.aliasElement, true) and compareDeep(documentationElement, o.documentationElement, true);
  end;
end;

function TFhirStructureMapStructure.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FMode) and isEmptyProp(FAlias) and isEmptyProp(FDocumentation);
end;

procedure TFhirStructureMapStructure.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('url');
  fields.add('mode');
  fields.add('alias');
  fields.add('documentation');
end;

{ TFhirStructureMapStructure }

Procedure TFhirStructureMapStructure.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirStructureMapStructure.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

Procedure TFhirStructureMapStructure.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

Procedure TFhirStructureMapStructure.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

Function TFhirStructureMapStructure.GetModeST : TFhirMapModelModeEnum;
begin
  if FMode = nil then
    result := TFhirMapModelModeEnum(0)
  else
    result := TFhirMapModelModeEnum(StringArrayIndexOfSensitive(CODES_TFhirMapModelModeEnum, FMode.value));
end;

Procedure TFhirStructureMapStructure.SetModeST(value : TFhirMapModelModeEnum);
begin
  if ord(value) = 0 then
    ModeElement := nil
  else
    ModeElement := TFhirEnum.create(SYSTEMS_TFhirMapModelModeEnum[value], CODES_TFhirMapModelModeEnum[value]);
end;

Procedure TFhirStructureMapStructure.SetAlias(value : TFhirString);
begin
  FAlias.free;
  FAlias := value;
end;

Function TFhirStructureMapStructure.GetAliasST : String;
begin
  if FAlias = nil then
    result := ''
  else
    result := FAlias.value;
end;

Procedure TFhirStructureMapStructure.SetAliasST(value : String);
begin
  if value <> '' then
  begin
    if FAlias = nil then
      FAlias := TFhirString.create;
    FAlias.value := value
  end
  else if FAlias <> nil then
    FAlias.value := '';
end;

Procedure TFhirStructureMapStructure.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirStructureMapStructure.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

Procedure TFhirStructureMapStructure.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

function TFhirStructureMapStructure.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FUrl.sizeInBytes);
  inc(result, FMode.sizeInBytes);
  inc(result, FAlias.sizeInBytes);
  inc(result, FDocumentation.sizeInBytes);
end;

{ TFhirStructureMapStructureListEnumerator }

Constructor TFhirStructureMapStructureListEnumerator.Create(list : TFhirStructureMapStructureList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirStructureMapStructureListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirStructureMapStructureListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirStructureMapStructureListEnumerator.GetCurrent : TFhirStructureMapStructure;
begin
  Result := FList[FIndex];
end;

function TFhirStructureMapStructureListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirStructureMapStructureList }
procedure TFhirStructureMapStructureList.AddItem(value: TFhirStructureMapStructure);
begin
  assert(value.ClassName = 'TFhirStructureMapStructure', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirStructureMapStructure');
  add(value);
end;

function TFhirStructureMapStructureList.Append: TFhirStructureMapStructure;
begin
  result := TFhirStructureMapStructure.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureMapStructureList.ClearItems;
begin
  Clear;
end;

function TFhirStructureMapStructureList.GetEnumerator : TFhirStructureMapStructureListEnumerator;
begin
  result := TFhirStructureMapStructureListEnumerator.Create(self.link);
end;

function TFhirStructureMapStructureList.Clone: TFhirStructureMapStructureList;
begin
  result := TFhirStructureMapStructureList(inherited Clone);
end;

function TFhirStructureMapStructureList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirStructureMapStructureList.GetItemN(index: Integer): TFhirStructureMapStructure;
begin
  result := TFhirStructureMapStructure(ObjectByIndex[index]);
end;

function TFhirStructureMapStructureList.ItemClass: TFslObjectClass;
begin
  result := TFhirStructureMapStructure;
end;
function TFhirStructureMapStructureList.IndexOf(value: TFhirStructureMapStructure): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirStructureMapStructureList.Insert(index: Integer): TFhirStructureMapStructure;
begin
  result := TFhirStructureMapStructure.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureMapStructureList.InsertItem(index: Integer; value: TFhirStructureMapStructure);
begin
  assert(value is TFhirStructureMapStructure);
  Inherited Insert(index, value);
end;

function TFhirStructureMapStructureList.Item(index: Integer): TFhirStructureMapStructure;
begin
  result := TFhirStructureMapStructure(ObjectByIndex[index]);
end;

function TFhirStructureMapStructureList.Link: TFhirStructureMapStructureList;
begin
  result := TFhirStructureMapStructureList(inherited Link);
end;

procedure TFhirStructureMapStructureList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirStructureMapStructureList.SetItemByIndex(index: Integer; value: TFhirStructureMapStructure);
begin
  assert(value is TFhirStructureMapStructure);
  FhirStructureMapStructures[index] := value;
end;

procedure TFhirStructureMapStructureList.SetItemN(index: Integer; value: TFhirStructureMapStructure);
begin
  assert(value is TFhirStructureMapStructure);
  ObjectByIndex[index] := value;
end;

{ TFhirStructureMapGroup }

constructor TFhirStructureMapGroup.Create;
begin
  inherited;
end;

destructor TFhirStructureMapGroup.Destroy;
begin
  FName.free;
  FExtends.free;
  FTypeMode.free;
  FDocumentation.free;
  FInputList.Free;
  FRuleList.Free;
  inherited;
end;

procedure TFhirStructureMapGroup.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirStructureMapGroup(oSource).nameElement.Clone;
  extendsElement := TFhirStructureMapGroup(oSource).extendsElement.Clone;
  FTypeMode := TFhirStructureMapGroup(oSource).FTypeMode.Link;
  documentationElement := TFhirStructureMapGroup(oSource).documentationElement.Clone;
  if (TFhirStructureMapGroup(oSource).FInputList = nil) then
  begin
    FInputList.free;
    FInputList := nil;
  end
  else
  begin
    if FInputList = nil then
      FInputList := TFhirStructureMapGroupInputList.Create;
    FInputList.Assign(TFhirStructureMapGroup(oSource).FInputList);
  end;
  if (TFhirStructureMapGroup(oSource).FRuleList = nil) then
  begin
    FRuleList.free;
    FRuleList := nil;
  end
  else
  begin
    if FRuleList = nil then
      FRuleList := TFhirStructureMapGroupRuleList.Create;
    FRuleList.Assign(TFhirStructureMapGroup(oSource).FRuleList);
  end;
end;

procedure TFhirStructureMapGroup.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'extends') Then
     list.add(self.link, 'extends', FExtends.Link);
  if (child_name = 'typeMode') Then
     list.add(self.link, 'typeMode', FTypeMode.Link);
  if (child_name = 'documentation') Then
     list.add(self.link, 'documentation', FDocumentation.Link);
  if (child_name = 'input') Then
    list.addAll(self, 'input', FInputList);
  if (child_name = 'rule') Then
    list.addAll(self, 'rule', FRuleList);
end;

procedure TFhirStructureMapGroup.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'id', false, TFhirId, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'extends', 'id', false, TFhirId, FExtends.Link));{2}
  oList.add(TFHIRProperty.create(self, 'typeMode', 'code', false, TFHIREnum, FTypeMode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', false, TFhirString, FDocumentation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'input', '', true, TFhirStructureMapGroupInput, FInputList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'rule', '', true, TFhirStructureMapGroupRule, FRuleList.Link)){3};
end;

function TFhirStructureMapGroup.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'extends') then
  begin
    ExtendsElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'typeMode') then
  begin
    TypeModeElement := asEnum(SYSTEMS_TFhirMapGroupTypeModeEnum, CODES_TFhirMapGroupTypeModeEnum, propValue);
    result := propValue
  end
  else if (propName = 'documentation') then
  begin
    DocumentationElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'input') then
  begin
    InputList.add(propValue as TFhirStructureMapGroupInput){2a};
    result := propValue;
  end
  else if (propName = 'rule') then
  begin
    RuleList.add(propValue as TFhirStructureMapGroupRule){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirStructureMapGroup.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'input') then InputList.insertItem(index, propValue as TFhirStructureMapGroupInput){2a}
  else if (propName = 'rule') then RuleList.insertItem(index, propValue as TFhirStructureMapGroupRule){2a}
  else inherited;
end;

function TFhirStructureMapGroup.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirId.create() {5b}
  else if (propName = 'extends') then result := TFhirId.create() {5b}
  else if (propName = 'documentation') then result := TFhirString.create() {5b}
  else if (propName = 'input') then result := InputList.new(){2}
  else if (propName = 'rule') then result := RuleList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirStructureMapGroup.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'id'
  else if (propName = 'extends') then result := 'id'
  else if (propName = 'typeMode') then result := 'code'
  else if (propName = 'documentation') then result := 'string'
  else if (propName = 'input') then result := ''
  else if (propName = 'rule') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirStructureMapGroup.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'extends') then ExtendsElement := nil
  else if (propName = 'typeMode') then TypeModeElement := nil
  else if (propName = 'documentation') then DocumentationElement := nil
  else if (propName = 'input') then deletePropertyValue('input', InputList, value) {2}
  else if (propName = 'rule') then deletePropertyValue('rule', RuleList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirStructureMapGroup.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asId(new){5b}
  else if (propName = 'extends') then ExtendsElement := asId(new){5b}
  else if (propName = 'typeMode') then TypeModeElement := asEnum(SYSTEMS_TFhirMapGroupTypeModeEnum, CODES_TFhirMapGroupTypeModeEnum, new){4}
  else if (propName = 'documentation') then DocumentationElement := asString(new){5b}
  else if (propName = 'input') then replacePropertyValue('input', InputList, existing, new) {2}
  else if (propName = 'rule') then replacePropertyValue('rule', RuleList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirStructureMapGroup.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'input') then InputList.move(source, destination){2a}
  else if (propName = 'rule') then RuleList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirStructureMapGroup.fhirType : string;
begin
  result := 'group';
end;

function TFhirStructureMapGroup.Link : TFhirStructureMapGroup;
begin
  result := TFhirStructureMapGroup(inherited Link);
end;

function TFhirStructureMapGroup.Clone : TFhirStructureMapGroup;
begin
  result := TFhirStructureMapGroup(inherited Clone);
end;

function TFhirStructureMapGroup.equals(other : TObject) : boolean;
var
  o : TFhirStructureMapGroup;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirStructureMapGroup)) then
    result := false
  else
  begin
    o := TFhirStructureMapGroup(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(extendsElement, o.extendsElement, true) and
      compareDeep(typeModeElement, o.typeModeElement, true) and compareDeep(documentationElement, o.documentationElement, true) and
      compareDeep(inputList, o.inputList, true) and compareDeep(ruleList, o.ruleList, true);
  end;
end;

function TFhirStructureMapGroup.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FExtends) and isEmptyProp(FTypeMode) and isEmptyProp(FDocumentation) and isEmptyProp(FinputList) and isEmptyProp(FruleList);
end;

procedure TFhirStructureMapGroup.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('extends');
  fields.add('typeMode');
  fields.add('documentation');
  fields.add('input');
  fields.add('rule');
end;

{ TFhirStructureMapGroup }

Procedure TFhirStructureMapGroup.SetName(value : TFhirId);
begin
  FName.free;
  FName := value;
end;

Function TFhirStructureMapGroup.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirStructureMapGroup.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirId.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirStructureMapGroup.SetExtends(value : TFhirId);
begin
  FExtends.free;
  FExtends := value;
end;

Function TFhirStructureMapGroup.GetExtendsST : String;
begin
  if FExtends = nil then
    result := ''
  else
    result := FExtends.value;
end;

Procedure TFhirStructureMapGroup.SetExtendsST(value : String);
begin
  if value <> '' then
  begin
    if FExtends = nil then
      FExtends := TFhirId.create;
    FExtends.value := value
  end
  else if FExtends <> nil then
    FExtends.value := '';
end;

Procedure TFhirStructureMapGroup.SetTypeMode(value : TFhirEnum);
begin
  FTypeMode.free;
  FTypeMode := value;
end;

Function TFhirStructureMapGroup.GetTypeModeST : TFhirMapGroupTypeModeEnum;
begin
  if FTypeMode = nil then
    result := TFhirMapGroupTypeModeEnum(0)
  else
    result := TFhirMapGroupTypeModeEnum(StringArrayIndexOfSensitive(CODES_TFhirMapGroupTypeModeEnum, FTypeMode.value));
end;

Procedure TFhirStructureMapGroup.SetTypeModeST(value : TFhirMapGroupTypeModeEnum);
begin
  if ord(value) = 0 then
    TypeModeElement := nil
  else
    TypeModeElement := TFhirEnum.create(SYSTEMS_TFhirMapGroupTypeModeEnum[value], CODES_TFhirMapGroupTypeModeEnum[value]);
end;

Procedure TFhirStructureMapGroup.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirStructureMapGroup.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

Procedure TFhirStructureMapGroup.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

Function TFhirStructureMapGroup.GetInputList : TFhirStructureMapGroupInputList;
begin
  if FInputList = nil then
    FInputList := TFhirStructureMapGroupInputList.Create;
  result := FInputList;
end;

Function TFhirStructureMapGroup.GetHasInputList : boolean;
begin
  result := (FInputList <> nil) and (FInputList.count > 0);
end;

Function TFhirStructureMapGroup.GetRuleList : TFhirStructureMapGroupRuleList;
begin
  if FRuleList = nil then
    FRuleList := TFhirStructureMapGroupRuleList.Create;
  result := FRuleList;
end;

Function TFhirStructureMapGroup.GetHasRuleList : boolean;
begin
  result := (FRuleList <> nil) and (FRuleList.count > 0);
end;

function TFhirStructureMapGroup.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FExtends.sizeInBytes);
  inc(result, FTypeMode.sizeInBytes);
  inc(result, FDocumentation.sizeInBytes);
  inc(result, FinputList.sizeInBytes);
  inc(result, FruleList.sizeInBytes);
end;

{ TFhirStructureMapGroupListEnumerator }

Constructor TFhirStructureMapGroupListEnumerator.Create(list : TFhirStructureMapGroupList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirStructureMapGroupListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirStructureMapGroupListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirStructureMapGroupListEnumerator.GetCurrent : TFhirStructureMapGroup;
begin
  Result := FList[FIndex];
end;

function TFhirStructureMapGroupListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirStructureMapGroupList }
procedure TFhirStructureMapGroupList.AddItem(value: TFhirStructureMapGroup);
begin
  assert(value.ClassName = 'TFhirStructureMapGroup', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirStructureMapGroup');
  add(value);
end;

function TFhirStructureMapGroupList.Append: TFhirStructureMapGroup;
begin
  result := TFhirStructureMapGroup.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureMapGroupList.ClearItems;
begin
  Clear;
end;

function TFhirStructureMapGroupList.GetEnumerator : TFhirStructureMapGroupListEnumerator;
begin
  result := TFhirStructureMapGroupListEnumerator.Create(self.link);
end;

function TFhirStructureMapGroupList.Clone: TFhirStructureMapGroupList;
begin
  result := TFhirStructureMapGroupList(inherited Clone);
end;

function TFhirStructureMapGroupList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirStructureMapGroupList.GetItemN(index: Integer): TFhirStructureMapGroup;
begin
  result := TFhirStructureMapGroup(ObjectByIndex[index]);
end;

function TFhirStructureMapGroupList.ItemClass: TFslObjectClass;
begin
  result := TFhirStructureMapGroup;
end;
function TFhirStructureMapGroupList.IndexOf(value: TFhirStructureMapGroup): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirStructureMapGroupList.Insert(index: Integer): TFhirStructureMapGroup;
begin
  result := TFhirStructureMapGroup.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureMapGroupList.InsertItem(index: Integer; value: TFhirStructureMapGroup);
begin
  assert(value is TFhirStructureMapGroup);
  Inherited Insert(index, value);
end;

function TFhirStructureMapGroupList.Item(index: Integer): TFhirStructureMapGroup;
begin
  result := TFhirStructureMapGroup(ObjectByIndex[index]);
end;

function TFhirStructureMapGroupList.Link: TFhirStructureMapGroupList;
begin
  result := TFhirStructureMapGroupList(inherited Link);
end;

procedure TFhirStructureMapGroupList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirStructureMapGroupList.SetItemByIndex(index: Integer; value: TFhirStructureMapGroup);
begin
  assert(value is TFhirStructureMapGroup);
  FhirStructureMapGroups[index] := value;
end;

procedure TFhirStructureMapGroupList.SetItemN(index: Integer; value: TFhirStructureMapGroup);
begin
  assert(value is TFhirStructureMapGroup);
  ObjectByIndex[index] := value;
end;

{ TFhirStructureMapGroupInput }

constructor TFhirStructureMapGroupInput.Create;
begin
  inherited;
end;

destructor TFhirStructureMapGroupInput.Destroy;
begin
  FName.free;
  FType_.free;
  FMode.free;
  FDocumentation.free;
  inherited;
end;

procedure TFhirStructureMapGroupInput.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirStructureMapGroupInput(oSource).nameElement.Clone;
  type_Element := TFhirStructureMapGroupInput(oSource).type_Element.Clone;
  FMode := TFhirStructureMapGroupInput(oSource).FMode.Link;
  documentationElement := TFhirStructureMapGroupInput(oSource).documentationElement.Clone;
end;

procedure TFhirStructureMapGroupInput.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'mode') Then
     list.add(self.link, 'mode', FMode.Link);
  if (child_name = 'documentation') Then
     list.add(self.link, 'documentation', FDocumentation.Link);
end;

procedure TFhirStructureMapGroupInput.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'id', false, TFhirId, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'string', false, TFhirString, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'mode', 'code', false, TFHIREnum, FMode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', false, TFhirString, FDocumentation.Link));{2}
end;

function TFhirStructureMapGroupInput.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'mode') then
  begin
    ModeElement := asEnum(SYSTEMS_TFhirMapInputModeEnum, CODES_TFhirMapInputModeEnum, propValue);
    result := propValue
  end
  else if (propName = 'documentation') then
  begin
    DocumentationElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirStructureMapGroupInput.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirStructureMapGroupInput.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirId.create() {5b}
  else if (propName = 'type') then result := TFhirString.create() {5b}
  else if (propName = 'documentation') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirStructureMapGroupInput.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'id'
  else if (propName = 'type') then result := 'string'
  else if (propName = 'mode') then result := 'code'
  else if (propName = 'documentation') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirStructureMapGroupInput.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'mode') then ModeElement := nil
  else if (propName = 'documentation') then DocumentationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirStructureMapGroupInput.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asId(new){5b}
  else if (propName = 'type') then Type_Element := asString(new){5b}
  else if (propName = 'mode') then ModeElement := asEnum(SYSTEMS_TFhirMapInputModeEnum, CODES_TFhirMapInputModeEnum, new){4}
  else if (propName = 'documentation') then DocumentationElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirStructureMapGroupInput.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirStructureMapGroupInput.fhirType : string;
begin
  result := 'input';
end;

function TFhirStructureMapGroupInput.Link : TFhirStructureMapGroupInput;
begin
  result := TFhirStructureMapGroupInput(inherited Link);
end;

function TFhirStructureMapGroupInput.Clone : TFhirStructureMapGroupInput;
begin
  result := TFhirStructureMapGroupInput(inherited Clone);
end;

function TFhirStructureMapGroupInput.equals(other : TObject) : boolean;
var
  o : TFhirStructureMapGroupInput;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirStructureMapGroupInput)) then
    result := false
  else
  begin
    o := TFhirStructureMapGroupInput(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(type_Element, o.type_Element, true) and
      compareDeep(modeElement, o.modeElement, true) and compareDeep(documentationElement, o.documentationElement, true);
  end;
end;

function TFhirStructureMapGroupInput.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FType_) and isEmptyProp(FMode) and isEmptyProp(FDocumentation);
end;

procedure TFhirStructureMapGroupInput.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('type');
  fields.add('mode');
  fields.add('documentation');
end;

{ TFhirStructureMapGroupInput }

Procedure TFhirStructureMapGroupInput.SetName(value : TFhirId);
begin
  FName.free;
  FName := value;
end;

Function TFhirStructureMapGroupInput.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirStructureMapGroupInput.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirId.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirStructureMapGroupInput.SetType_(value : TFhirString);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirStructureMapGroupInput.GetType_ST : String;
begin
  if FType_ = nil then
    result := ''
  else
    result := FType_.value;
end;

Procedure TFhirStructureMapGroupInput.SetType_ST(value : String);
begin
  if value <> '' then
  begin
    if FType_ = nil then
      FType_ := TFhirString.create;
    FType_.value := value
  end
  else if FType_ <> nil then
    FType_.value := '';
end;

Procedure TFhirStructureMapGroupInput.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

Function TFhirStructureMapGroupInput.GetModeST : TFhirMapInputModeEnum;
begin
  if FMode = nil then
    result := TFhirMapInputModeEnum(0)
  else
    result := TFhirMapInputModeEnum(StringArrayIndexOfSensitive(CODES_TFhirMapInputModeEnum, FMode.value));
end;

Procedure TFhirStructureMapGroupInput.SetModeST(value : TFhirMapInputModeEnum);
begin
  if ord(value) = 0 then
    ModeElement := nil
  else
    ModeElement := TFhirEnum.create(SYSTEMS_TFhirMapInputModeEnum[value], CODES_TFhirMapInputModeEnum[value]);
end;

Procedure TFhirStructureMapGroupInput.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirStructureMapGroupInput.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

Procedure TFhirStructureMapGroupInput.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

function TFhirStructureMapGroupInput.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FMode.sizeInBytes);
  inc(result, FDocumentation.sizeInBytes);
end;

{ TFhirStructureMapGroupInputListEnumerator }

Constructor TFhirStructureMapGroupInputListEnumerator.Create(list : TFhirStructureMapGroupInputList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirStructureMapGroupInputListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirStructureMapGroupInputListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirStructureMapGroupInputListEnumerator.GetCurrent : TFhirStructureMapGroupInput;
begin
  Result := FList[FIndex];
end;

function TFhirStructureMapGroupInputListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirStructureMapGroupInputList }
procedure TFhirStructureMapGroupInputList.AddItem(value: TFhirStructureMapGroupInput);
begin
  assert(value.ClassName = 'TFhirStructureMapGroupInput', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirStructureMapGroupInput');
  add(value);
end;

function TFhirStructureMapGroupInputList.Append: TFhirStructureMapGroupInput;
begin
  result := TFhirStructureMapGroupInput.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureMapGroupInputList.ClearItems;
begin
  Clear;
end;

function TFhirStructureMapGroupInputList.GetEnumerator : TFhirStructureMapGroupInputListEnumerator;
begin
  result := TFhirStructureMapGroupInputListEnumerator.Create(self.link);
end;

function TFhirStructureMapGroupInputList.Clone: TFhirStructureMapGroupInputList;
begin
  result := TFhirStructureMapGroupInputList(inherited Clone);
end;

function TFhirStructureMapGroupInputList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirStructureMapGroupInputList.GetItemN(index: Integer): TFhirStructureMapGroupInput;
begin
  result := TFhirStructureMapGroupInput(ObjectByIndex[index]);
end;

function TFhirStructureMapGroupInputList.ItemClass: TFslObjectClass;
begin
  result := TFhirStructureMapGroupInput;
end;
function TFhirStructureMapGroupInputList.IndexOf(value: TFhirStructureMapGroupInput): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirStructureMapGroupInputList.Insert(index: Integer): TFhirStructureMapGroupInput;
begin
  result := TFhirStructureMapGroupInput.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureMapGroupInputList.InsertItem(index: Integer; value: TFhirStructureMapGroupInput);
begin
  assert(value is TFhirStructureMapGroupInput);
  Inherited Insert(index, value);
end;

function TFhirStructureMapGroupInputList.Item(index: Integer): TFhirStructureMapGroupInput;
begin
  result := TFhirStructureMapGroupInput(ObjectByIndex[index]);
end;

function TFhirStructureMapGroupInputList.Link: TFhirStructureMapGroupInputList;
begin
  result := TFhirStructureMapGroupInputList(inherited Link);
end;

procedure TFhirStructureMapGroupInputList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirStructureMapGroupInputList.SetItemByIndex(index: Integer; value: TFhirStructureMapGroupInput);
begin
  assert(value is TFhirStructureMapGroupInput);
  FhirStructureMapGroupInputs[index] := value;
end;

procedure TFhirStructureMapGroupInputList.SetItemN(index: Integer; value: TFhirStructureMapGroupInput);
begin
  assert(value is TFhirStructureMapGroupInput);
  ObjectByIndex[index] := value;
end;

{ TFhirStructureMapGroupRule }

constructor TFhirStructureMapGroupRule.Create;
begin
  inherited;
end;

destructor TFhirStructureMapGroupRule.Destroy;
begin
  FName.free;
  FSourceList.Free;
  FTargetList.Free;
  FRuleList.Free;
  FDependentList.Free;
  FDocumentation.free;
  inherited;
end;

procedure TFhirStructureMapGroupRule.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirStructureMapGroupRule(oSource).nameElement.Clone;
  if (TFhirStructureMapGroupRule(oSource).FSourceList = nil) then
  begin
    FSourceList.free;
    FSourceList := nil;
  end
  else
  begin
    if FSourceList = nil then
      FSourceList := TFhirStructureMapGroupRuleSourceList.Create;
    FSourceList.Assign(TFhirStructureMapGroupRule(oSource).FSourceList);
  end;
  if (TFhirStructureMapGroupRule(oSource).FTargetList = nil) then
  begin
    FTargetList.free;
    FTargetList := nil;
  end
  else
  begin
    if FTargetList = nil then
      FTargetList := TFhirStructureMapGroupRuleTargetList.Create;
    FTargetList.Assign(TFhirStructureMapGroupRule(oSource).FTargetList);
  end;
  if (TFhirStructureMapGroupRule(oSource).FRuleList = nil) then
  begin
    FRuleList.free;
    FRuleList := nil;
  end
  else
  begin
    if FRuleList = nil then
      FRuleList := TFhirStructureMapGroupRuleList.Create;
    FRuleList.Assign(TFhirStructureMapGroupRule(oSource).FRuleList);
  end;
  if (TFhirStructureMapGroupRule(oSource).FDependentList = nil) then
  begin
    FDependentList.free;
    FDependentList := nil;
  end
  else
  begin
    if FDependentList = nil then
      FDependentList := TFhirStructureMapGroupRuleDependentList.Create;
    FDependentList.Assign(TFhirStructureMapGroupRule(oSource).FDependentList);
  end;
  documentationElement := TFhirStructureMapGroupRule(oSource).documentationElement.Clone;
end;

procedure TFhirStructureMapGroupRule.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'source') Then
    list.addAll(self, 'source', FSourceList);
  if (child_name = 'target') Then
    list.addAll(self, 'target', FTargetList);
  if (child_name = 'rule') Then
    list.addAll(self, 'rule', FRuleList);
  if (child_name = 'dependent') Then
    list.addAll(self, 'dependent', FDependentList);
  if (child_name = 'documentation') Then
     list.add(self.link, 'documentation', FDocumentation.Link);
end;

procedure TFhirStructureMapGroupRule.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'id', false, TFhirId, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'source', '', true, TFhirStructureMapGroupRuleSource, FSourceList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'target', '', true, TFhirStructureMapGroupRuleTarget, FTargetList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'rule', '@StructureMap.group.rule', true, TFhirStructureMapGroupRule, FRuleList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'dependent', '', true, TFhirStructureMapGroupRuleDependent, FDependentList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'documentation', 'string', false, TFhirString, FDocumentation.Link));{2}
end;

function TFhirStructureMapGroupRule.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    SourceList.add(propValue as TFhirStructureMapGroupRuleSource){2a};
    result := propValue;
  end
  else if (propName = 'target') then
  begin
    TargetList.add(propValue as TFhirStructureMapGroupRuleTarget){2a};
    result := propValue;
  end
  else if (propName = 'rule') then
  begin
    RuleList.add(propValue as TFhirStructureMapGroupRule){2a};
    result := propValue;
  end
  else if (propName = 'dependent') then
  begin
    DependentList.add(propValue as TFhirStructureMapGroupRuleDependent){2a};
    result := propValue;
  end
  else if (propName = 'documentation') then
  begin
    DocumentationElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirStructureMapGroupRule.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'source') then SourceList.insertItem(index, propValue as TFhirStructureMapGroupRuleSource){2a}
  else if (propName = 'target') then TargetList.insertItem(index, propValue as TFhirStructureMapGroupRuleTarget){2a}
  else if (propName = 'rule') then RuleList.insertItem(index, propValue as TFhirStructureMapGroupRule){2a}
  else if (propName = 'dependent') then DependentList.insertItem(index, propValue as TFhirStructureMapGroupRuleDependent){2a}
  else inherited;
end;

function TFhirStructureMapGroupRule.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirId.create() {5b}
  else if (propName = 'source') then result := SourceList.new(){2}
  else if (propName = 'target') then result := TargetList.new(){2}
  else if (propName = 'rule') then result := RuleList.new(){2}
  else if (propName = 'dependent') then result := DependentList.new(){2}
  else if (propName = 'documentation') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirStructureMapGroupRule.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'id'
  else if (propName = 'source') then result := ''
  else if (propName = 'target') then result := ''
  else if (propName = 'rule') then result := '@StructureMap.group.rule'
  else if (propName = 'dependent') then result := ''
  else if (propName = 'documentation') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirStructureMapGroupRule.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'source') then deletePropertyValue('source', SourceList, value) {2}
  else if (propName = 'target') then deletePropertyValue('target', TargetList, value) {2}
  else if (propName = 'rule') then deletePropertyValue('rule', RuleList, value) {2}
  else if (propName = 'dependent') then deletePropertyValue('dependent', DependentList, value) {2}
  else if (propName = 'documentation') then DocumentationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirStructureMapGroupRule.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asId(new){5b}
  else if (propName = 'source') then replacePropertyValue('source', SourceList, existing, new) {2}
  else if (propName = 'target') then replacePropertyValue('target', TargetList, existing, new) {2}
  else if (propName = 'rule') then replacePropertyValue('rule', RuleList, existing, new) {2}
  else if (propName = 'dependent') then replacePropertyValue('dependent', DependentList, existing, new) {2}
  else if (propName = 'documentation') then DocumentationElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirStructureMapGroupRule.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'source') then SourceList.move(source, destination){2a}
  else if (propName = 'target') then TargetList.move(source, destination){2a}
  else if (propName = 'rule') then RuleList.move(source, destination){2a}
  else if (propName = 'dependent') then DependentList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirStructureMapGroupRule.fhirType : string;
begin
  result := 'rule';
end;

function TFhirStructureMapGroupRule.Link : TFhirStructureMapGroupRule;
begin
  result := TFhirStructureMapGroupRule(inherited Link);
end;

function TFhirStructureMapGroupRule.Clone : TFhirStructureMapGroupRule;
begin
  result := TFhirStructureMapGroupRule(inherited Clone);
end;

function TFhirStructureMapGroupRule.equals(other : TObject) : boolean;
var
  o : TFhirStructureMapGroupRule;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirStructureMapGroupRule)) then
    result := false
  else
  begin
    o := TFhirStructureMapGroupRule(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(sourceList, o.sourceList, true) and
      compareDeep(targetList, o.targetList, true) and compareDeep(ruleList, o.ruleList, true) and
      compareDeep(dependentList, o.dependentList, true) and compareDeep(documentationElement, o.documentationElement, true);
  end;
end;

function TFhirStructureMapGroupRule.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FsourceList) and isEmptyProp(FtargetList) and isEmptyProp(FruleList) and isEmptyProp(FdependentList) and isEmptyProp(FDocumentation);
end;

procedure TFhirStructureMapGroupRule.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('source');
  fields.add('target');
  fields.add('rule');
  fields.add('dependent');
  fields.add('documentation');
end;

{ TFhirStructureMapGroupRule }

Procedure TFhirStructureMapGroupRule.SetName(value : TFhirId);
begin
  FName.free;
  FName := value;
end;

Function TFhirStructureMapGroupRule.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirStructureMapGroupRule.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirId.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Function TFhirStructureMapGroupRule.GetSourceList : TFhirStructureMapGroupRuleSourceList;
begin
  if FSourceList = nil then
    FSourceList := TFhirStructureMapGroupRuleSourceList.Create;
  result := FSourceList;
end;

Function TFhirStructureMapGroupRule.GetHasSourceList : boolean;
begin
  result := (FSourceList <> nil) and (FSourceList.count > 0);
end;

Function TFhirStructureMapGroupRule.GetTargetList : TFhirStructureMapGroupRuleTargetList;
begin
  if FTargetList = nil then
    FTargetList := TFhirStructureMapGroupRuleTargetList.Create;
  result := FTargetList;
end;

Function TFhirStructureMapGroupRule.GetHasTargetList : boolean;
begin
  result := (FTargetList <> nil) and (FTargetList.count > 0);
end;

Function TFhirStructureMapGroupRule.GetRuleList : TFhirStructureMapGroupRuleList;
begin
  if FRuleList = nil then
    FRuleList := TFhirStructureMapGroupRuleList.Create;
  result := FRuleList;
end;

Function TFhirStructureMapGroupRule.GetHasRuleList : boolean;
begin
  result := (FRuleList <> nil) and (FRuleList.count > 0);
end;

Function TFhirStructureMapGroupRule.GetDependentList : TFhirStructureMapGroupRuleDependentList;
begin
  if FDependentList = nil then
    FDependentList := TFhirStructureMapGroupRuleDependentList.Create;
  result := FDependentList;
end;

Function TFhirStructureMapGroupRule.GetHasDependentList : boolean;
begin
  result := (FDependentList <> nil) and (FDependentList.count > 0);
end;

Procedure TFhirStructureMapGroupRule.SetDocumentation(value : TFhirString);
begin
  FDocumentation.free;
  FDocumentation := value;
end;

Function TFhirStructureMapGroupRule.GetDocumentationST : String;
begin
  if FDocumentation = nil then
    result := ''
  else
    result := FDocumentation.value;
end;

Procedure TFhirStructureMapGroupRule.SetDocumentationST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentation = nil then
      FDocumentation := TFhirString.create;
    FDocumentation.value := value
  end
  else if FDocumentation <> nil then
    FDocumentation.value := '';
end;

function TFhirStructureMapGroupRule.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FsourceList.sizeInBytes);
  inc(result, FtargetList.sizeInBytes);
  inc(result, FruleList.sizeInBytes);
  inc(result, FdependentList.sizeInBytes);
  inc(result, FDocumentation.sizeInBytes);
end;

{ TFhirStructureMapGroupRuleListEnumerator }

Constructor TFhirStructureMapGroupRuleListEnumerator.Create(list : TFhirStructureMapGroupRuleList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirStructureMapGroupRuleListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirStructureMapGroupRuleListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirStructureMapGroupRuleListEnumerator.GetCurrent : TFhirStructureMapGroupRule;
begin
  Result := FList[FIndex];
end;

function TFhirStructureMapGroupRuleListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirStructureMapGroupRuleList }
procedure TFhirStructureMapGroupRuleList.AddItem(value: TFhirStructureMapGroupRule);
begin
  assert(value.ClassName = 'TFhirStructureMapGroupRule', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirStructureMapGroupRule');
  add(value);
end;

function TFhirStructureMapGroupRuleList.Append: TFhirStructureMapGroupRule;
begin
  result := TFhirStructureMapGroupRule.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureMapGroupRuleList.ClearItems;
begin
  Clear;
end;

function TFhirStructureMapGroupRuleList.GetEnumerator : TFhirStructureMapGroupRuleListEnumerator;
begin
  result := TFhirStructureMapGroupRuleListEnumerator.Create(self.link);
end;

function TFhirStructureMapGroupRuleList.Clone: TFhirStructureMapGroupRuleList;
begin
  result := TFhirStructureMapGroupRuleList(inherited Clone);
end;

function TFhirStructureMapGroupRuleList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirStructureMapGroupRuleList.GetItemN(index: Integer): TFhirStructureMapGroupRule;
begin
  result := TFhirStructureMapGroupRule(ObjectByIndex[index]);
end;

function TFhirStructureMapGroupRuleList.ItemClass: TFslObjectClass;
begin
  result := TFhirStructureMapGroupRule;
end;
function TFhirStructureMapGroupRuleList.IndexOf(value: TFhirStructureMapGroupRule): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirStructureMapGroupRuleList.Insert(index: Integer): TFhirStructureMapGroupRule;
begin
  result := TFhirStructureMapGroupRule.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureMapGroupRuleList.InsertItem(index: Integer; value: TFhirStructureMapGroupRule);
begin
  assert(value is TFhirStructureMapGroupRule);
  Inherited Insert(index, value);
end;

function TFhirStructureMapGroupRuleList.Item(index: Integer): TFhirStructureMapGroupRule;
begin
  result := TFhirStructureMapGroupRule(ObjectByIndex[index]);
end;

function TFhirStructureMapGroupRuleList.Link: TFhirStructureMapGroupRuleList;
begin
  result := TFhirStructureMapGroupRuleList(inherited Link);
end;

procedure TFhirStructureMapGroupRuleList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirStructureMapGroupRuleList.SetItemByIndex(index: Integer; value: TFhirStructureMapGroupRule);
begin
  assert(value is TFhirStructureMapGroupRule);
  FhirStructureMapGroupRules[index] := value;
end;

procedure TFhirStructureMapGroupRuleList.SetItemN(index: Integer; value: TFhirStructureMapGroupRule);
begin
  assert(value is TFhirStructureMapGroupRule);
  ObjectByIndex[index] := value;
end;

{ TFhirStructureMapGroupRuleSource }

constructor TFhirStructureMapGroupRuleSource.Create;
begin
  inherited;
end;

destructor TFhirStructureMapGroupRuleSource.Destroy;
begin
  FContext.free;
  FMin.free;
  FMax.free;
  FType_.free;
  FDefaultValue.free;
  FElement.free;
  FListMode.free;
  FVariable.free;
  FCondition.free;
  FCheck.free;
  inherited;
end;

procedure TFhirStructureMapGroupRuleSource.Assign(oSource : TFslObject);
begin
  inherited;
  contextElement := TFhirStructureMapGroupRuleSource(oSource).contextElement.Clone;
  minElement := TFhirStructureMapGroupRuleSource(oSource).minElement.Clone;
  maxElement := TFhirStructureMapGroupRuleSource(oSource).maxElement.Clone;
  type_Element := TFhirStructureMapGroupRuleSource(oSource).type_Element.Clone;
  defaultValue := TFhirStructureMapGroupRuleSource(oSource).defaultValue.Clone;
  elementElement := TFhirStructureMapGroupRuleSource(oSource).elementElement.Clone;
  FListMode := TFhirStructureMapGroupRuleSource(oSource).FListMode.Link;
  variableElement := TFhirStructureMapGroupRuleSource(oSource).variableElement.Clone;
  conditionElement := TFhirStructureMapGroupRuleSource(oSource).conditionElement.Clone;
  checkElement := TFhirStructureMapGroupRuleSource(oSource).checkElement.Clone;
end;

procedure TFhirStructureMapGroupRuleSource.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
  if (child_name = 'min') Then
     list.add(self.link, 'min', FMin.Link);
  if (child_name = 'max') Then
     list.add(self.link, 'max', FMax.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'defaultValue[x]') or (child_name = 'defaultValue') Then
     list.add(self.link, 'defaultValue[x]', FDefaultValue.Link);
  if (child_name = 'element') Then
     list.add(self.link, 'element', FElement.Link);
  if (child_name = 'listMode') Then
     list.add(self.link, 'listMode', FListMode.Link);
  if (child_name = 'variable') Then
     list.add(self.link, 'variable', FVariable.Link);
  if (child_name = 'condition') Then
     list.add(self.link, 'condition', FCondition.Link);
  if (child_name = 'check') Then
     list.add(self.link, 'check', FCheck.Link);
end;

procedure TFhirStructureMapGroupRuleSource.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'context', 'id', false, TFhirId, FContext.Link));{2}
  oList.add(TFHIRProperty.create(self, 'min', 'integer', false, TFhirInteger, FMin.Link));{2}
  oList.add(TFHIRProperty.create(self, 'max', 'string', false, TFhirString, FMax.Link));{2}
  oList.add(TFHIRProperty.create(self, 'type', 'string', false, TFhirString, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'defaultValue[x]', 'base64Binary|boolean|code|date|dateTime|decimal|id|instant|integer|markdown|oid|positiveInt|string|time|unsignedInt|uri|Address|Age|Annotation|Attachment|CodeableConcept|Coding|ContactPoint|Count|Distance|Duration|HumanName|Identifier|Money|Period|Qu'+'antity|Range|Ratio|Reference|SampledData|Signature|Timing|Meta', false, TFhirType, FDefaultValue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'element', 'string', false, TFhirString, FElement.Link));{2}
  oList.add(TFHIRProperty.create(self, 'listMode', 'code', false, TFHIREnum, FListMode.Link));{1}
  oList.add(TFHIRProperty.create(self, 'variable', 'id', false, TFhirId, FVariable.Link));{2}
  oList.add(TFHIRProperty.create(self, 'condition', 'string', false, TFhirString, FCondition.Link));{2}
  oList.add(TFHIRProperty.create(self, 'check', 'string', false, TFhirString, FCheck.Link));{2}
end;

function TFhirStructureMapGroupRuleSource.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'context') then
  begin
    ContextElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'min') then
  begin
    MinElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'max') then
  begin
    MaxElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asString(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'defaultValue', ['Base64Binary', 'Boolean', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'Meta'])) then
  begin
    DefaultValue := propValue as TFhirType{4};
    result := propValue;
  end
  else if (propName = 'element') then
  begin
    ElementElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'listMode') then
  begin
    ListModeElement := asEnum(SYSTEMS_TFhirMapSourceListModeEnum, CODES_TFhirMapSourceListModeEnum, propValue);
    result := propValue
  end
  else if (propName = 'variable') then
  begin
    VariableElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'condition') then
  begin
    ConditionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'check') then
  begin
    CheckElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirStructureMapGroupRuleSource.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirStructureMapGroupRuleSource.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'context') then result := TFhirId.create() {5b}
  else if (propName = 'min') then result := TFhirInteger.create() {5b}
  else if (propName = 'max') then result := TFhirString.create() {5b}
  else if (propName = 'type') then result := TFhirString.create() {5b}
  else if (isMatchingName(propName, 'defaultValue', ['Base64Binary', 'Boolean', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'Meta'])) then raise EFHIRException.create('Cannot make property DefaultValue'){4x}
  else if (propName = 'element') then result := TFhirString.create() {5b}
  else if (propName = 'variable') then result := TFhirId.create() {5b}
  else if (propName = 'condition') then result := TFhirString.create() {5b}
  else if (propName = 'check') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirStructureMapGroupRuleSource.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'context') then result := 'id'
  else if (propName = 'min') then result := 'integer'
  else if (propName = 'max') then result := 'string'
  else if (propName = 'type') then result := 'string'
  else if (propName = 'defaultValue[x]') then result := 'base64Binary|boolean|code|date|dateTime|decimal|id|instant|integer|markdown|oid|positiveInt|string|time|unsignedInt|uri|Address|Age|Annotation|Attachment|CodeableConcept|Coding|ContactPoint|Count|Distance|Duration|HumanName|Identifier|Money|Period|Qu'+'antity|Range|Ratio|Reference|SampledData|Signature|Timing|Meta'
  else if (propName = 'element') then result := 'string'
  else if (propName = 'listMode') then result := 'code'
  else if (propName = 'variable') then result := 'id'
  else if (propName = 'condition') then result := 'string'
  else if (propName = 'check') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirStructureMapGroupRuleSource.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'context') then ContextElement := nil
  else if (propName = 'min') then MinElement := nil
  else if (propName = 'max') then MaxElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'defaultValue', ['Base64Binary', 'Boolean', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'Meta'])) then DefaultValueElement := nil{4x}
  else if (propName = 'element') then ElementElement := nil
  else if (propName = 'listMode') then ListModeElement := nil
  else if (propName = 'variable') then VariableElement := nil
  else if (propName = 'condition') then ConditionElement := nil
  else if (propName = 'check') then CheckElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirStructureMapGroupRuleSource.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'context') then ContextElement := asId(new){5b}
  else if (propName = 'min') then MinElement := asInteger(new){5b}
  else if (propName = 'max') then MaxElement := asString(new){5b}
  else if (propName = 'type') then Type_Element := asString(new){5b}
  else if (isMatchingName(propName, 'defaultValue', ['Base64Binary', 'Boolean', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'Meta'])) then DefaultValueElement := new as TFhirType{4x}
  else if (propName = 'element') then ElementElement := asString(new){5b}
  else if (propName = 'listMode') then ListModeElement := asEnum(SYSTEMS_TFhirMapSourceListModeEnum, CODES_TFhirMapSourceListModeEnum, new){4}
  else if (propName = 'variable') then VariableElement := asId(new){5b}
  else if (propName = 'condition') then ConditionElement := asString(new){5b}
  else if (propName = 'check') then CheckElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirStructureMapGroupRuleSource.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirStructureMapGroupRuleSource.fhirType : string;
begin
  result := 'source';
end;

function TFhirStructureMapGroupRuleSource.Link : TFhirStructureMapGroupRuleSource;
begin
  result := TFhirStructureMapGroupRuleSource(inherited Link);
end;

function TFhirStructureMapGroupRuleSource.Clone : TFhirStructureMapGroupRuleSource;
begin
  result := TFhirStructureMapGroupRuleSource(inherited Clone);
end;

function TFhirStructureMapGroupRuleSource.equals(other : TObject) : boolean;
var
  o : TFhirStructureMapGroupRuleSource;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirStructureMapGroupRuleSource)) then
    result := false
  else
  begin
    o := TFhirStructureMapGroupRuleSource(other);
    result := compareDeep(contextElement, o.contextElement, true) and compareDeep(minElement, o.minElement, true) and
      compareDeep(maxElement, o.maxElement, true) and compareDeep(type_Element, o.type_Element, true) and
      compareDeep(defaultValueElement, o.defaultValueElement, true) and compareDeep(elementElement, o.elementElement, true) and
      compareDeep(listModeElement, o.listModeElement, true) and compareDeep(variableElement, o.variableElement, true) and
      compareDeep(conditionElement, o.conditionElement, true) and compareDeep(checkElement, o.checkElement, true);
  end;
end;

function TFhirStructureMapGroupRuleSource.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FContext) and isEmptyProp(FMin) and isEmptyProp(FMax) and isEmptyProp(FType_) and isEmptyProp(FDefaultValue) and isEmptyProp(FElement) and isEmptyProp(FListMode) and isEmptyProp(FVariable) and isEmptyProp(FCondition) and isEmptyProp(FCheck);
end;

procedure TFhirStructureMapGroupRuleSource.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('context');
  fields.add('min');
  fields.add('max');
  fields.add('type');
  fields.add('defaultValue[x]');
  fields.add('element');
  fields.add('listMode');
  fields.add('variable');
  fields.add('condition');
  fields.add('check');
end;

{ TFhirStructureMapGroupRuleSource }

Procedure TFhirStructureMapGroupRuleSource.SetContext(value : TFhirId);
begin
  FContext.free;
  FContext := value;
end;

Function TFhirStructureMapGroupRuleSource.GetContextST : String;
begin
  if FContext = nil then
    result := ''
  else
    result := FContext.value;
end;

Procedure TFhirStructureMapGroupRuleSource.SetContextST(value : String);
begin
  if value <> '' then
  begin
    if FContext = nil then
      FContext := TFhirId.create;
    FContext.value := value
  end
  else if FContext <> nil then
    FContext.value := '';
end;

Procedure TFhirStructureMapGroupRuleSource.SetMin(value : TFhirInteger);
begin
  FMin.free;
  FMin := value;
end;

Function TFhirStructureMapGroupRuleSource.GetMinST : String;
begin
  if FMin = nil then
    result := ''
  else
    result := FMin.value;
end;

Procedure TFhirStructureMapGroupRuleSource.SetMinST(value : String);
begin
  if value <> '' then
  begin
    if FMin = nil then
      FMin := TFhirInteger.create;
    FMin.value := value
  end
  else if FMin <> nil then
    FMin.value := '';
end;

Procedure TFhirStructureMapGroupRuleSource.SetMax(value : TFhirString);
begin
  FMax.free;
  FMax := value;
end;

Function TFhirStructureMapGroupRuleSource.GetMaxST : String;
begin
  if FMax = nil then
    result := ''
  else
    result := FMax.value;
end;

Procedure TFhirStructureMapGroupRuleSource.SetMaxST(value : String);
begin
  if value <> '' then
  begin
    if FMax = nil then
      FMax := TFhirString.create;
    FMax.value := value
  end
  else if FMax <> nil then
    FMax.value := '';
end;

Procedure TFhirStructureMapGroupRuleSource.SetType_(value : TFhirString);
begin
  FType_.free;
  FType_ := value;
end;

Function TFhirStructureMapGroupRuleSource.GetType_ST : String;
begin
  if FType_ = nil then
    result := ''
  else
    result := FType_.value;
end;

Procedure TFhirStructureMapGroupRuleSource.SetType_ST(value : String);
begin
  if value <> '' then
  begin
    if FType_ = nil then
      FType_ := TFhirString.create;
    FType_.value := value
  end
  else if FType_ <> nil then
    FType_.value := '';
end;

Procedure TFhirStructureMapGroupRuleSource.SetDefaultValue(value : TFhirType);
begin
  FDefaultValue.free;
  FDefaultValue := value;
end;

Procedure TFhirStructureMapGroupRuleSource.SetElement(value : TFhirString);
begin
  FElement.free;
  FElement := value;
end;

Function TFhirStructureMapGroupRuleSource.GetElementST : String;
begin
  if FElement = nil then
    result := ''
  else
    result := FElement.value;
end;

Procedure TFhirStructureMapGroupRuleSource.SetElementST(value : String);
begin
  if value <> '' then
  begin
    if FElement = nil then
      FElement := TFhirString.create;
    FElement.value := value
  end
  else if FElement <> nil then
    FElement.value := '';
end;

Procedure TFhirStructureMapGroupRuleSource.SetListMode(value : TFhirEnum);
begin
  FListMode.free;
  FListMode := value;
end;

Function TFhirStructureMapGroupRuleSource.GetListModeST : TFhirMapSourceListModeEnum;
begin
  if FListMode = nil then
    result := TFhirMapSourceListModeEnum(0)
  else
    result := TFhirMapSourceListModeEnum(StringArrayIndexOfSensitive(CODES_TFhirMapSourceListModeEnum, FListMode.value));
end;

Procedure TFhirStructureMapGroupRuleSource.SetListModeST(value : TFhirMapSourceListModeEnum);
begin
  if ord(value) = 0 then
    ListModeElement := nil
  else
    ListModeElement := TFhirEnum.create(SYSTEMS_TFhirMapSourceListModeEnum[value], CODES_TFhirMapSourceListModeEnum[value]);
end;

Procedure TFhirStructureMapGroupRuleSource.SetVariable(value : TFhirId);
begin
  FVariable.free;
  FVariable := value;
end;

Function TFhirStructureMapGroupRuleSource.GetVariableST : String;
begin
  if FVariable = nil then
    result := ''
  else
    result := FVariable.value;
end;

Procedure TFhirStructureMapGroupRuleSource.SetVariableST(value : String);
begin
  if value <> '' then
  begin
    if FVariable = nil then
      FVariable := TFhirId.create;
    FVariable.value := value
  end
  else if FVariable <> nil then
    FVariable.value := '';
end;

Procedure TFhirStructureMapGroupRuleSource.SetCondition(value : TFhirString);
begin
  FCondition.free;
  FCondition := value;
end;

Function TFhirStructureMapGroupRuleSource.GetConditionST : String;
begin
  if FCondition = nil then
    result := ''
  else
    result := FCondition.value;
end;

Procedure TFhirStructureMapGroupRuleSource.SetConditionST(value : String);
begin
  if value <> '' then
  begin
    if FCondition = nil then
      FCondition := TFhirString.create;
    FCondition.value := value
  end
  else if FCondition <> nil then
    FCondition.value := '';
end;

Procedure TFhirStructureMapGroupRuleSource.SetCheck(value : TFhirString);
begin
  FCheck.free;
  FCheck := value;
end;

Function TFhirStructureMapGroupRuleSource.GetCheckST : String;
begin
  if FCheck = nil then
    result := ''
  else
    result := FCheck.value;
end;

Procedure TFhirStructureMapGroupRuleSource.SetCheckST(value : String);
begin
  if value <> '' then
  begin
    if FCheck = nil then
      FCheck := TFhirString.create;
    FCheck.value := value
  end
  else if FCheck <> nil then
    FCheck.value := '';
end;

function TFhirStructureMapGroupRuleSource.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FContext.sizeInBytes);
  inc(result, FMin.sizeInBytes);
  inc(result, FMax.sizeInBytes);
  inc(result, FType_.sizeInBytes);
  inc(result, FDefaultValue.sizeInBytes);
  inc(result, FElement.sizeInBytes);
  inc(result, FListMode.sizeInBytes);
  inc(result, FVariable.sizeInBytes);
  inc(result, FCondition.sizeInBytes);
  inc(result, FCheck.sizeInBytes);
end;

{ TFhirStructureMapGroupRuleSourceListEnumerator }

Constructor TFhirStructureMapGroupRuleSourceListEnumerator.Create(list : TFhirStructureMapGroupRuleSourceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirStructureMapGroupRuleSourceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirStructureMapGroupRuleSourceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirStructureMapGroupRuleSourceListEnumerator.GetCurrent : TFhirStructureMapGroupRuleSource;
begin
  Result := FList[FIndex];
end;

function TFhirStructureMapGroupRuleSourceListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirStructureMapGroupRuleSourceList }
procedure TFhirStructureMapGroupRuleSourceList.AddItem(value: TFhirStructureMapGroupRuleSource);
begin
  assert(value.ClassName = 'TFhirStructureMapGroupRuleSource', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirStructureMapGroupRuleSource');
  add(value);
end;

function TFhirStructureMapGroupRuleSourceList.Append: TFhirStructureMapGroupRuleSource;
begin
  result := TFhirStructureMapGroupRuleSource.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureMapGroupRuleSourceList.ClearItems;
begin
  Clear;
end;

function TFhirStructureMapGroupRuleSourceList.GetEnumerator : TFhirStructureMapGroupRuleSourceListEnumerator;
begin
  result := TFhirStructureMapGroupRuleSourceListEnumerator.Create(self.link);
end;

function TFhirStructureMapGroupRuleSourceList.Clone: TFhirStructureMapGroupRuleSourceList;
begin
  result := TFhirStructureMapGroupRuleSourceList(inherited Clone);
end;

function TFhirStructureMapGroupRuleSourceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirStructureMapGroupRuleSourceList.GetItemN(index: Integer): TFhirStructureMapGroupRuleSource;
begin
  result := TFhirStructureMapGroupRuleSource(ObjectByIndex[index]);
end;

function TFhirStructureMapGroupRuleSourceList.ItemClass: TFslObjectClass;
begin
  result := TFhirStructureMapGroupRuleSource;
end;
function TFhirStructureMapGroupRuleSourceList.IndexOf(value: TFhirStructureMapGroupRuleSource): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirStructureMapGroupRuleSourceList.Insert(index: Integer): TFhirStructureMapGroupRuleSource;
begin
  result := TFhirStructureMapGroupRuleSource.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureMapGroupRuleSourceList.InsertItem(index: Integer; value: TFhirStructureMapGroupRuleSource);
begin
  assert(value is TFhirStructureMapGroupRuleSource);
  Inherited Insert(index, value);
end;

function TFhirStructureMapGroupRuleSourceList.Item(index: Integer): TFhirStructureMapGroupRuleSource;
begin
  result := TFhirStructureMapGroupRuleSource(ObjectByIndex[index]);
end;

function TFhirStructureMapGroupRuleSourceList.Link: TFhirStructureMapGroupRuleSourceList;
begin
  result := TFhirStructureMapGroupRuleSourceList(inherited Link);
end;

procedure TFhirStructureMapGroupRuleSourceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirStructureMapGroupRuleSourceList.SetItemByIndex(index: Integer; value: TFhirStructureMapGroupRuleSource);
begin
  assert(value is TFhirStructureMapGroupRuleSource);
  FhirStructureMapGroupRuleSources[index] := value;
end;

procedure TFhirStructureMapGroupRuleSourceList.SetItemN(index: Integer; value: TFhirStructureMapGroupRuleSource);
begin
  assert(value is TFhirStructureMapGroupRuleSource);
  ObjectByIndex[index] := value;
end;

{ TFhirStructureMapGroupRuleTarget }

constructor TFhirStructureMapGroupRuleTarget.Create;
begin
  inherited;
end;

destructor TFhirStructureMapGroupRuleTarget.Destroy;
begin
  FContext.free;
  FContextType.free;
  FElement.free;
  FVariable.free;
  FListMode.Free;
  FListRuleId.free;
  FTransform.free;
  FParameterList.Free;
  inherited;
end;

procedure TFhirStructureMapGroupRuleTarget.Assign(oSource : TFslObject);
begin
  inherited;
  contextElement := TFhirStructureMapGroupRuleTarget(oSource).contextElement.Clone;
  FContextType := TFhirStructureMapGroupRuleTarget(oSource).FContextType.Link;
  elementElement := TFhirStructureMapGroupRuleTarget(oSource).elementElement.Clone;
  variableElement := TFhirStructureMapGroupRuleTarget(oSource).variableElement.Clone;
  if (TFhirStructureMapGroupRuleTarget(oSource).FListMode = nil) then
  begin
    FListMode.free;
    FListMode := nil;
  end
  else
  begin
    FListMode := TFHIREnumList.Create(SYSTEMS_TFhirMapTargetListModeEnum, CODES_TFhirMapTargetListModeEnum);
    FListMode.Assign(TFhirStructureMapGroupRuleTarget(oSource).FListMode);
  end;
  listRuleIdElement := TFhirStructureMapGroupRuleTarget(oSource).listRuleIdElement.Clone;
  FTransform := TFhirStructureMapGroupRuleTarget(oSource).FTransform.Link;
  if (TFhirStructureMapGroupRuleTarget(oSource).FParameterList = nil) then
  begin
    FParameterList.free;
    FParameterList := nil;
  end
  else
  begin
    if FParameterList = nil then
      FParameterList := TFhirStructureMapGroupRuleTargetParameterList.Create;
    FParameterList.Assign(TFhirStructureMapGroupRuleTarget(oSource).FParameterList);
  end;
end;

procedure TFhirStructureMapGroupRuleTarget.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
  if (child_name = 'contextType') Then
     list.add(self.link, 'contextType', FContextType.Link);
  if (child_name = 'element') Then
     list.add(self.link, 'element', FElement.Link);
  if (child_name = 'variable') Then
     list.add(self.link, 'variable', FVariable.Link);
  if (child_name = 'listMode') Then
     list.addAll(self, 'listMode', FListMode);
  if (child_name = 'listRuleId') Then
     list.add(self.link, 'listRuleId', FListRuleId.Link);
  if (child_name = 'transform') Then
     list.add(self.link, 'transform', FTransform.Link);
  if (child_name = 'parameter') Then
    list.addAll(self, 'parameter', FParameterList);
end;

procedure TFhirStructureMapGroupRuleTarget.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'context', 'id', false, TFhirId, FContext.Link));{2}
  oList.add(TFHIRProperty.create(self, 'contextType', 'code', false, TFHIREnum, FContextType.Link));{1}
  oList.add(TFHIRProperty.create(self, 'element', 'string', false, TFhirString, FElement.Link));{2}
  oList.add(TFHIRProperty.create(self, 'variable', 'id', false, TFhirId, FVariable.Link));{2}
  oList.add(TFHIRProperty.create(self, 'listMode', 'code', true, TFHIREnum, FListMode.Link)){3};
  oList.add(TFHIRProperty.create(self, 'listRuleId', 'id', false, TFhirId, FListRuleId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'transform', 'code', false, TFHIREnum, FTransform.Link));{1}
  oList.add(TFHIRProperty.create(self, 'parameter', '', true, TFhirStructureMapGroupRuleTargetParameter, FParameterList.Link)){3};
end;

function TFhirStructureMapGroupRuleTarget.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'context') then
  begin
    ContextElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'contextType') then
  begin
    ContextTypeElement := asEnum(SYSTEMS_TFhirMapContextTypeEnum, CODES_TFhirMapContextTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'element') then
  begin
    ElementElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'variable') then
  begin
    VariableElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'listMode') then
  begin
    ListModeList.add(asEnum(SYSTEMS_TFhirMapTargetListModeEnum, CODES_TFhirMapTargetListModeEnum, propValue)); {1}
    result := propValue;
  end
  else if (propName = 'listRuleId') then
  begin
    ListRuleIdElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'transform') then
  begin
    TransformElement := asEnum(SYSTEMS_TFhirMapTransformEnum, CODES_TFhirMapTransformEnum, propValue);
    result := propValue
  end
  else if (propName = 'parameter') then
  begin
    ParameterList.add(propValue as TFhirStructureMapGroupRuleTargetParameter){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirStructureMapGroupRuleTarget.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'listMode') then FListMode.insertItem(index, asEnum(SYSTEMS_TFhirMapTargetListModeEnum, CODES_TFhirMapTargetListModeEnum, propValue)) {1}
  else if (propName = 'parameter') then ParameterList.insertItem(index, propValue as TFhirStructureMapGroupRuleTargetParameter){2a}
  else inherited;
end;

function TFhirStructureMapGroupRuleTarget.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'context') then result := TFhirId.create() {5b}
  else if (propName = 'element') then result := TFhirString.create() {5b}
  else if (propName = 'variable') then result := TFhirId.create() {5b}
  else if (propName = 'listRuleId') then result := TFhirId.create() {5b}
  else if (propName = 'parameter') then result := ParameterList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirStructureMapGroupRuleTarget.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'context') then result := 'id'
  else if (propName = 'contextType') then result := 'code'
  else if (propName = 'element') then result := 'string'
  else if (propName = 'variable') then result := 'id'
  else if (propName = 'listMode') then result := 'code'
  else if (propName = 'listRuleId') then result := 'id'
  else if (propName = 'transform') then result := 'code'
  else if (propName = 'parameter') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirStructureMapGroupRuleTarget.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'context') then ContextElement := nil
  else if (propName = 'contextType') then ContextTypeElement := nil
  else if (propName = 'element') then ElementElement := nil
  else if (propName = 'variable') then VariableElement := nil
  else if (propName = 'listRuleId') then ListRuleIdElement := nil
  else if (propName = 'transform') then TransformElement := nil
  else if (propName = 'parameter') then deletePropertyValue('parameter', ParameterList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirStructureMapGroupRuleTarget.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'context') then ContextElement := asId(new){5b}
  else if (propName = 'contextType') then ContextTypeElement := asEnum(SYSTEMS_TFhirMapContextTypeEnum, CODES_TFhirMapContextTypeEnum, new){4}
  else if (propName = 'element') then ElementElement := asString(new){5b}
  else if (propName = 'variable') then VariableElement := asId(new){5b}
  else if (propName = 'listRuleId') then ListRuleIdElement := asId(new){5b}
  else if (propName = 'transform') then TransformElement := asEnum(SYSTEMS_TFhirMapTransformEnum, CODES_TFhirMapTransformEnum, new){4}
  else if (propName = 'parameter') then replacePropertyValue('parameter', ParameterList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirStructureMapGroupRuleTarget.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'listMode') then FListMode.move(source, destination) {1}
  else if (propName = 'parameter') then ParameterList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirStructureMapGroupRuleTarget.fhirType : string;
begin
  result := 'target';
end;

function TFhirStructureMapGroupRuleTarget.Link : TFhirStructureMapGroupRuleTarget;
begin
  result := TFhirStructureMapGroupRuleTarget(inherited Link);
end;

function TFhirStructureMapGroupRuleTarget.Clone : TFhirStructureMapGroupRuleTarget;
begin
  result := TFhirStructureMapGroupRuleTarget(inherited Clone);
end;

function TFhirStructureMapGroupRuleTarget.equals(other : TObject) : boolean;
var
  o : TFhirStructureMapGroupRuleTarget;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirStructureMapGroupRuleTarget)) then
    result := false
  else
  begin
    o := TFhirStructureMapGroupRuleTarget(other);
    result := compareDeep(contextElement, o.contextElement, true) and compareDeep(contextTypeElement, o.contextTypeElement, true) and
      compareDeep(elementElement, o.elementElement, true) and compareDeep(variableElement, o.variableElement, true) and
      compareDeep(listModeList, o.listModeList, true) and compareDeep(listRuleIdElement, o.listRuleIdElement, true) and
      compareDeep(transformElement, o.transformElement, true) and compareDeep(parameterList, o.parameterList, true);
  end;
end;

function TFhirStructureMapGroupRuleTarget.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FContext) and isEmptyProp(FContextType) and isEmptyProp(FElement) and isEmptyProp(FVariable) and isEmptyProp(FListMode) and isEmptyProp(FListRuleId) and isEmptyProp(FTransform) and isEmptyProp(FparameterList);
end;

procedure TFhirStructureMapGroupRuleTarget.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('context');
  fields.add('contextType');
  fields.add('element');
  fields.add('variable');
  fields.add('listMode');
  fields.add('listRuleId');
  fields.add('transform');
  fields.add('parameter');
end;

{ TFhirStructureMapGroupRuleTarget }

Procedure TFhirStructureMapGroupRuleTarget.SetContext(value : TFhirId);
begin
  FContext.free;
  FContext := value;
end;

Function TFhirStructureMapGroupRuleTarget.GetContextST : String;
begin
  if FContext = nil then
    result := ''
  else
    result := FContext.value;
end;

Procedure TFhirStructureMapGroupRuleTarget.SetContextST(value : String);
begin
  if value <> '' then
  begin
    if FContext = nil then
      FContext := TFhirId.create;
    FContext.value := value
  end
  else if FContext <> nil then
    FContext.value := '';
end;

Procedure TFhirStructureMapGroupRuleTarget.SetContextType(value : TFhirEnum);
begin
  FContextType.free;
  FContextType := value;
end;

Function TFhirStructureMapGroupRuleTarget.GetContextTypeST : TFhirMapContextTypeEnum;
begin
  if FContextType = nil then
    result := TFhirMapContextTypeEnum(0)
  else
    result := TFhirMapContextTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirMapContextTypeEnum, FContextType.value));
end;

Procedure TFhirStructureMapGroupRuleTarget.SetContextTypeST(value : TFhirMapContextTypeEnum);
begin
  if ord(value) = 0 then
    ContextTypeElement := nil
  else
    ContextTypeElement := TFhirEnum.create(SYSTEMS_TFhirMapContextTypeEnum[value], CODES_TFhirMapContextTypeEnum[value]);
end;

Procedure TFhirStructureMapGroupRuleTarget.SetElement(value : TFhirString);
begin
  FElement.free;
  FElement := value;
end;

Function TFhirStructureMapGroupRuleTarget.GetElementST : String;
begin
  if FElement = nil then
    result := ''
  else
    result := FElement.value;
end;

Procedure TFhirStructureMapGroupRuleTarget.SetElementST(value : String);
begin
  if value <> '' then
  begin
    if FElement = nil then
      FElement := TFhirString.create;
    FElement.value := value
  end
  else if FElement <> nil then
    FElement.value := '';
end;

Procedure TFhirStructureMapGroupRuleTarget.SetVariable(value : TFhirId);
begin
  FVariable.free;
  FVariable := value;
end;

Function TFhirStructureMapGroupRuleTarget.GetVariableST : String;
begin
  if FVariable = nil then
    result := ''
  else
    result := FVariable.value;
end;

Procedure TFhirStructureMapGroupRuleTarget.SetVariableST(value : String);
begin
  if value <> '' then
  begin
    if FVariable = nil then
      FVariable := TFhirId.create;
    FVariable.value := value
  end
  else if FVariable <> nil then
    FVariable.value := '';
end;

Function TFhirStructureMapGroupRuleTarget.GetListMode : TFhirEnumList;
begin
  if FListMode = nil then
    FListMode := TFHIREnumList.Create(SYSTEMS_TFhirMapTargetListModeEnum, CODES_TFhirMapTargetListModeEnum);
  result := FListMode;
end;

Function TFhirStructureMapGroupRuleTarget.GetHasListMode : boolean;
begin
  result := (FListMode <> nil) and (FListMode.count > 0);
end;

Function TFhirStructureMapGroupRuleTarget.GetListModeST : TFhirMapTargetListModeEnumList;
  var i : integer;
begin
  result := [];
  if FlistMode <> nil then
    for i := 0 to FlistMode.count - 1 do
      result := result + [TFhirMapTargetListModeEnum(StringArrayIndexOfSensitive(CODES_TFhirMapTargetListModeEnum, FlistMode[i].value))];
end;

Procedure TFhirStructureMapGroupRuleTarget.SetListModeST(value : TFhirMapTargetListModeEnumList);
var a : TFhirMapTargetListModeEnum;
begin
  if FlistMode = nil then
    FlistMode := TFhirEnumList.create(SYSTEMS_TFhirMapTargetListModeEnum, CODES_TFhirMapTargetListModeEnum);
  FlistMode.clear;
  for a := low(TFhirMapTargetListModeEnum) to high(TFhirMapTargetListModeEnum) do
    if a in value then
      begin
         if FlistMode = nil then
           FlistMode := TFhirEnumList.create(SYSTEMS_TFhirMapTargetListModeEnum, CODES_TFhirMapTargetListModeEnum);
         FlistMode.add(TFhirEnum.create(SYSTEMS_TFhirMapTargetListModeEnum[a], CODES_TFhirMapTargetListModeEnum[a]));
      end;
end;

Procedure TFhirStructureMapGroupRuleTarget.SetListRuleId(value : TFhirId);
begin
  FListRuleId.free;
  FListRuleId := value;
end;

Function TFhirStructureMapGroupRuleTarget.GetListRuleIdST : String;
begin
  if FListRuleId = nil then
    result := ''
  else
    result := FListRuleId.value;
end;

Procedure TFhirStructureMapGroupRuleTarget.SetListRuleIdST(value : String);
begin
  if value <> '' then
  begin
    if FListRuleId = nil then
      FListRuleId := TFhirId.create;
    FListRuleId.value := value
  end
  else if FListRuleId <> nil then
    FListRuleId.value := '';
end;

Procedure TFhirStructureMapGroupRuleTarget.SetTransform(value : TFhirEnum);
begin
  FTransform.free;
  FTransform := value;
end;

Function TFhirStructureMapGroupRuleTarget.GetTransformST : TFhirMapTransformEnum;
begin
  if FTransform = nil then
    result := TFhirMapTransformEnum(0)
  else
    result := TFhirMapTransformEnum(StringArrayIndexOfSensitive(CODES_TFhirMapTransformEnum, FTransform.value));
end;

Procedure TFhirStructureMapGroupRuleTarget.SetTransformST(value : TFhirMapTransformEnum);
begin
  if ord(value) = 0 then
    TransformElement := nil
  else
    TransformElement := TFhirEnum.create(SYSTEMS_TFhirMapTransformEnum[value], CODES_TFhirMapTransformEnum[value]);
end;

Function TFhirStructureMapGroupRuleTarget.GetParameterList : TFhirStructureMapGroupRuleTargetParameterList;
begin
  if FParameterList = nil then
    FParameterList := TFhirStructureMapGroupRuleTargetParameterList.Create;
  result := FParameterList;
end;

Function TFhirStructureMapGroupRuleTarget.GetHasParameterList : boolean;
begin
  result := (FParameterList <> nil) and (FParameterList.count > 0);
end;

function TFhirStructureMapGroupRuleTarget.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FContext.sizeInBytes);
  inc(result, FContextType.sizeInBytes);
  inc(result, FElement.sizeInBytes);
  inc(result, FVariable.sizeInBytes);
  inc(result, FListMode.sizeInBytes);
  inc(result, FListRuleId.sizeInBytes);
  inc(result, FTransform.sizeInBytes);
  inc(result, FparameterList.sizeInBytes);
end;

{ TFhirStructureMapGroupRuleTargetListEnumerator }

Constructor TFhirStructureMapGroupRuleTargetListEnumerator.Create(list : TFhirStructureMapGroupRuleTargetList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirStructureMapGroupRuleTargetListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirStructureMapGroupRuleTargetListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirStructureMapGroupRuleTargetListEnumerator.GetCurrent : TFhirStructureMapGroupRuleTarget;
begin
  Result := FList[FIndex];
end;

function TFhirStructureMapGroupRuleTargetListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirStructureMapGroupRuleTargetList }
procedure TFhirStructureMapGroupRuleTargetList.AddItem(value: TFhirStructureMapGroupRuleTarget);
begin
  assert(value.ClassName = 'TFhirStructureMapGroupRuleTarget', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirStructureMapGroupRuleTarget');
  add(value);
end;

function TFhirStructureMapGroupRuleTargetList.Append: TFhirStructureMapGroupRuleTarget;
begin
  result := TFhirStructureMapGroupRuleTarget.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureMapGroupRuleTargetList.ClearItems;
begin
  Clear;
end;

function TFhirStructureMapGroupRuleTargetList.GetEnumerator : TFhirStructureMapGroupRuleTargetListEnumerator;
begin
  result := TFhirStructureMapGroupRuleTargetListEnumerator.Create(self.link);
end;

function TFhirStructureMapGroupRuleTargetList.Clone: TFhirStructureMapGroupRuleTargetList;
begin
  result := TFhirStructureMapGroupRuleTargetList(inherited Clone);
end;

function TFhirStructureMapGroupRuleTargetList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirStructureMapGroupRuleTargetList.GetItemN(index: Integer): TFhirStructureMapGroupRuleTarget;
begin
  result := TFhirStructureMapGroupRuleTarget(ObjectByIndex[index]);
end;

function TFhirStructureMapGroupRuleTargetList.ItemClass: TFslObjectClass;
begin
  result := TFhirStructureMapGroupRuleTarget;
end;
function TFhirStructureMapGroupRuleTargetList.IndexOf(value: TFhirStructureMapGroupRuleTarget): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirStructureMapGroupRuleTargetList.Insert(index: Integer): TFhirStructureMapGroupRuleTarget;
begin
  result := TFhirStructureMapGroupRuleTarget.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureMapGroupRuleTargetList.InsertItem(index: Integer; value: TFhirStructureMapGroupRuleTarget);
begin
  assert(value is TFhirStructureMapGroupRuleTarget);
  Inherited Insert(index, value);
end;

function TFhirStructureMapGroupRuleTargetList.Item(index: Integer): TFhirStructureMapGroupRuleTarget;
begin
  result := TFhirStructureMapGroupRuleTarget(ObjectByIndex[index]);
end;

function TFhirStructureMapGroupRuleTargetList.Link: TFhirStructureMapGroupRuleTargetList;
begin
  result := TFhirStructureMapGroupRuleTargetList(inherited Link);
end;

procedure TFhirStructureMapGroupRuleTargetList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirStructureMapGroupRuleTargetList.SetItemByIndex(index: Integer; value: TFhirStructureMapGroupRuleTarget);
begin
  assert(value is TFhirStructureMapGroupRuleTarget);
  FhirStructureMapGroupRuleTargets[index] := value;
end;

procedure TFhirStructureMapGroupRuleTargetList.SetItemN(index: Integer; value: TFhirStructureMapGroupRuleTarget);
begin
  assert(value is TFhirStructureMapGroupRuleTarget);
  ObjectByIndex[index] := value;
end;

{ TFhirStructureMapGroupRuleTargetParameter }

constructor TFhirStructureMapGroupRuleTargetParameter.Create;
begin
  inherited;
end;

destructor TFhirStructureMapGroupRuleTargetParameter.Destroy;
begin
  FValue.free;
  inherited;
end;

procedure TFhirStructureMapGroupRuleTargetParameter.Assign(oSource : TFslObject);
begin
  inherited;
  value := TFhirStructureMapGroupRuleTargetParameter(oSource).value.Clone;
end;

procedure TFhirStructureMapGroupRuleTargetParameter.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirStructureMapGroupRuleTargetParameter.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'value[x]', 'id|string|boolean|integer|decimal', false, TFhirType, FValue.Link));{2}
end;

function TFhirStructureMapGroupRuleTargetParameter.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'value', ['Id', 'String', 'Boolean', 'Integer', 'Decimal'])) then
  begin
    Value := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirStructureMapGroupRuleTargetParameter.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirStructureMapGroupRuleTargetParameter.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'value', ['Id', 'String', 'Boolean', 'Integer', 'Decimal'])) then raise EFHIRException.create('Cannot make property Value'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirStructureMapGroupRuleTargetParameter.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'value[x]') then result := 'id|string|boolean|integer|decimal'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirStructureMapGroupRuleTargetParameter.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'value', ['Id', 'String', 'Boolean', 'Integer', 'Decimal'])) then ValueElement := nil{4x}
  else
  inherited deleteProperty(propName, value);
end;

procedure TFhirStructureMapGroupRuleTargetParameter.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'value', ['Id', 'String', 'Boolean', 'Integer', 'Decimal'])) then ValueElement := new as TFhirType{4x}
  else
  inherited replaceProperty(propName, existing, new);
end;

procedure TFhirStructureMapGroupRuleTargetParameter.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirStructureMapGroupRuleTargetParameter.fhirType : string;
begin
  result := 'parameter';
end;

function TFhirStructureMapGroupRuleTargetParameter.Link : TFhirStructureMapGroupRuleTargetParameter;
begin
  result := TFhirStructureMapGroupRuleTargetParameter(inherited Link);
end;

function TFhirStructureMapGroupRuleTargetParameter.Clone : TFhirStructureMapGroupRuleTargetParameter;
begin
  result := TFhirStructureMapGroupRuleTargetParameter(inherited Clone);
end;

function TFhirStructureMapGroupRuleTargetParameter.equals(other : TObject) : boolean;
var
  o : TFhirStructureMapGroupRuleTargetParameter;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirStructureMapGroupRuleTargetParameter)) then
    result := false
  else
  begin
    o := TFhirStructureMapGroupRuleTargetParameter(other);
    result := compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirStructureMapGroupRuleTargetParameter.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FValue);
end;

procedure TFhirStructureMapGroupRuleTargetParameter.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('value[x]');
end;

{ TFhirStructureMapGroupRuleTargetParameter }

Procedure TFhirStructureMapGroupRuleTargetParameter.SetValue(value : TFhirType);
begin
  FValue.free;
  FValue := value;
end;

function TFhirStructureMapGroupRuleTargetParameter.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FValue.sizeInBytes);
end;

{ TFhirStructureMapGroupRuleTargetParameterListEnumerator }

Constructor TFhirStructureMapGroupRuleTargetParameterListEnumerator.Create(list : TFhirStructureMapGroupRuleTargetParameterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirStructureMapGroupRuleTargetParameterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirStructureMapGroupRuleTargetParameterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirStructureMapGroupRuleTargetParameterListEnumerator.GetCurrent : TFhirStructureMapGroupRuleTargetParameter;
begin
  Result := FList[FIndex];
end;

function TFhirStructureMapGroupRuleTargetParameterListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirStructureMapGroupRuleTargetParameterList }
procedure TFhirStructureMapGroupRuleTargetParameterList.AddItem(value: TFhirStructureMapGroupRuleTargetParameter);
begin
  assert(value.ClassName = 'TFhirStructureMapGroupRuleTargetParameter', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirStructureMapGroupRuleTargetParameter');
  add(value);
end;

function TFhirStructureMapGroupRuleTargetParameterList.Append: TFhirStructureMapGroupRuleTargetParameter;
begin
  result := TFhirStructureMapGroupRuleTargetParameter.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureMapGroupRuleTargetParameterList.ClearItems;
begin
  Clear;
end;

function TFhirStructureMapGroupRuleTargetParameterList.GetEnumerator : TFhirStructureMapGroupRuleTargetParameterListEnumerator;
begin
  result := TFhirStructureMapGroupRuleTargetParameterListEnumerator.Create(self.link);
end;

function TFhirStructureMapGroupRuleTargetParameterList.Clone: TFhirStructureMapGroupRuleTargetParameterList;
begin
  result := TFhirStructureMapGroupRuleTargetParameterList(inherited Clone);
end;

function TFhirStructureMapGroupRuleTargetParameterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirStructureMapGroupRuleTargetParameterList.GetItemN(index: Integer): TFhirStructureMapGroupRuleTargetParameter;
begin
  result := TFhirStructureMapGroupRuleTargetParameter(ObjectByIndex[index]);
end;

function TFhirStructureMapGroupRuleTargetParameterList.ItemClass: TFslObjectClass;
begin
  result := TFhirStructureMapGroupRuleTargetParameter;
end;
function TFhirStructureMapGroupRuleTargetParameterList.IndexOf(value: TFhirStructureMapGroupRuleTargetParameter): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirStructureMapGroupRuleTargetParameterList.Insert(index: Integer): TFhirStructureMapGroupRuleTargetParameter;
begin
  result := TFhirStructureMapGroupRuleTargetParameter.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureMapGroupRuleTargetParameterList.InsertItem(index: Integer; value: TFhirStructureMapGroupRuleTargetParameter);
begin
  assert(value is TFhirStructureMapGroupRuleTargetParameter);
  Inherited Insert(index, value);
end;

function TFhirStructureMapGroupRuleTargetParameterList.Item(index: Integer): TFhirStructureMapGroupRuleTargetParameter;
begin
  result := TFhirStructureMapGroupRuleTargetParameter(ObjectByIndex[index]);
end;

function TFhirStructureMapGroupRuleTargetParameterList.Link: TFhirStructureMapGroupRuleTargetParameterList;
begin
  result := TFhirStructureMapGroupRuleTargetParameterList(inherited Link);
end;

procedure TFhirStructureMapGroupRuleTargetParameterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirStructureMapGroupRuleTargetParameterList.SetItemByIndex(index: Integer; value: TFhirStructureMapGroupRuleTargetParameter);
begin
  assert(value is TFhirStructureMapGroupRuleTargetParameter);
  FhirStructureMapGroupRuleTargetParameters[index] := value;
end;

procedure TFhirStructureMapGroupRuleTargetParameterList.SetItemN(index: Integer; value: TFhirStructureMapGroupRuleTargetParameter);
begin
  assert(value is TFhirStructureMapGroupRuleTargetParameter);
  ObjectByIndex[index] := value;
end;

{ TFhirStructureMapGroupRuleDependent }

constructor TFhirStructureMapGroupRuleDependent.Create;
begin
  inherited;
end;

destructor TFhirStructureMapGroupRuleDependent.Destroy;
begin
  FName.free;
  FVariableList.Free;
  inherited;
end;

procedure TFhirStructureMapGroupRuleDependent.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirStructureMapGroupRuleDependent(oSource).nameElement.Clone;
  if (TFhirStructureMapGroupRuleDependent(oSource).FVariableList = nil) then
  begin
    FVariableList.free;
    FVariableList := nil;
  end
  else
  begin
    if FVariableList = nil then
      FVariableList := TFhirStringList.Create;
    FVariableList.Assign(TFhirStructureMapGroupRuleDependent(oSource).FVariableList);
  end;
end;

procedure TFhirStructureMapGroupRuleDependent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'variable') Then
    list.addAll(self, 'variable', FVariableList);
end;

procedure TFhirStructureMapGroupRuleDependent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'id', false, TFhirId, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'variable', 'string', true, TFhirString, FVariableList.Link)){3};
end;

function TFhirStructureMapGroupRuleDependent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'variable') then
  begin
    VariableList.add(asString(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirStructureMapGroupRuleDependent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'variable') then VariableList.insertItem(index, asString(propValue)){2}
  else inherited;
end;

function TFhirStructureMapGroupRuleDependent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirId.create() {5b}
  else if (propName = 'variable') then result := VariableList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirStructureMapGroupRuleDependent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'id'
  else if (propName = 'variable') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirStructureMapGroupRuleDependent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'variable') then deletePropertyValue('variable', VariableList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirStructureMapGroupRuleDependent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asId(new){5b}
  else if (propName = 'variable') then replacePropertyValue('variable', VariableList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirStructureMapGroupRuleDependent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'variable') then VariableList.move(source, destination){2}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirStructureMapGroupRuleDependent.fhirType : string;
begin
  result := 'dependent';
end;

function TFhirStructureMapGroupRuleDependent.Link : TFhirStructureMapGroupRuleDependent;
begin
  result := TFhirStructureMapGroupRuleDependent(inherited Link);
end;

function TFhirStructureMapGroupRuleDependent.Clone : TFhirStructureMapGroupRuleDependent;
begin
  result := TFhirStructureMapGroupRuleDependent(inherited Clone);
end;

function TFhirStructureMapGroupRuleDependent.equals(other : TObject) : boolean;
var
  o : TFhirStructureMapGroupRuleDependent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirStructureMapGroupRuleDependent)) then
    result := false
  else
  begin
    o := TFhirStructureMapGroupRuleDependent(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(variableList, o.variableList, true);
  end;
end;

function TFhirStructureMapGroupRuleDependent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FvariableList);
end;

procedure TFhirStructureMapGroupRuleDependent.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('variable');
end;

{ TFhirStructureMapGroupRuleDependent }

Procedure TFhirStructureMapGroupRuleDependent.SetName(value : TFhirId);
begin
  FName.free;
  FName := value;
end;

Function TFhirStructureMapGroupRuleDependent.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirStructureMapGroupRuleDependent.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirId.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Function TFhirStructureMapGroupRuleDependent.GetVariableList : TFhirStringList;
begin
  if FVariableList = nil then
    FVariableList := TFhirStringList.Create;
  result := FVariableList;
end;

Function TFhirStructureMapGroupRuleDependent.GetHasVariableList : boolean;
begin
  result := (FVariableList <> nil) and (FVariableList.count > 0);
end;

function TFhirStructureMapGroupRuleDependent.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FvariableList.sizeInBytes);
end;

{ TFhirStructureMapGroupRuleDependentListEnumerator }

Constructor TFhirStructureMapGroupRuleDependentListEnumerator.Create(list : TFhirStructureMapGroupRuleDependentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirStructureMapGroupRuleDependentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirStructureMapGroupRuleDependentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirStructureMapGroupRuleDependentListEnumerator.GetCurrent : TFhirStructureMapGroupRuleDependent;
begin
  Result := FList[FIndex];
end;

function TFhirStructureMapGroupRuleDependentListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirStructureMapGroupRuleDependentList }
procedure TFhirStructureMapGroupRuleDependentList.AddItem(value: TFhirStructureMapGroupRuleDependent);
begin
  assert(value.ClassName = 'TFhirStructureMapGroupRuleDependent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirStructureMapGroupRuleDependent');
  add(value);
end;

function TFhirStructureMapGroupRuleDependentList.Append: TFhirStructureMapGroupRuleDependent;
begin
  result := TFhirStructureMapGroupRuleDependent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureMapGroupRuleDependentList.ClearItems;
begin
  Clear;
end;

function TFhirStructureMapGroupRuleDependentList.GetEnumerator : TFhirStructureMapGroupRuleDependentListEnumerator;
begin
  result := TFhirStructureMapGroupRuleDependentListEnumerator.Create(self.link);
end;

function TFhirStructureMapGroupRuleDependentList.Clone: TFhirStructureMapGroupRuleDependentList;
begin
  result := TFhirStructureMapGroupRuleDependentList(inherited Clone);
end;

function TFhirStructureMapGroupRuleDependentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirStructureMapGroupRuleDependentList.GetItemN(index: Integer): TFhirStructureMapGroupRuleDependent;
begin
  result := TFhirStructureMapGroupRuleDependent(ObjectByIndex[index]);
end;

function TFhirStructureMapGroupRuleDependentList.ItemClass: TFslObjectClass;
begin
  result := TFhirStructureMapGroupRuleDependent;
end;
function TFhirStructureMapGroupRuleDependentList.IndexOf(value: TFhirStructureMapGroupRuleDependent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirStructureMapGroupRuleDependentList.Insert(index: Integer): TFhirStructureMapGroupRuleDependent;
begin
  result := TFhirStructureMapGroupRuleDependent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureMapGroupRuleDependentList.InsertItem(index: Integer; value: TFhirStructureMapGroupRuleDependent);
begin
  assert(value is TFhirStructureMapGroupRuleDependent);
  Inherited Insert(index, value);
end;

function TFhirStructureMapGroupRuleDependentList.Item(index: Integer): TFhirStructureMapGroupRuleDependent;
begin
  result := TFhirStructureMapGroupRuleDependent(ObjectByIndex[index]);
end;

function TFhirStructureMapGroupRuleDependentList.Link: TFhirStructureMapGroupRuleDependentList;
begin
  result := TFhirStructureMapGroupRuleDependentList(inherited Link);
end;

procedure TFhirStructureMapGroupRuleDependentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirStructureMapGroupRuleDependentList.SetItemByIndex(index: Integer; value: TFhirStructureMapGroupRuleDependent);
begin
  assert(value is TFhirStructureMapGroupRuleDependent);
  FhirStructureMapGroupRuleDependents[index] := value;
end;

procedure TFhirStructureMapGroupRuleDependentList.SetItemN(index: Integer; value: TFhirStructureMapGroupRuleDependent);
begin
  assert(value is TFhirStructureMapGroupRuleDependent);
  ObjectByIndex[index] := value;
end;

{ TFhirStructureMap }

constructor TFhirStructureMap.Create;
begin
  inherited;
end;

destructor TFhirStructureMap.Destroy;
begin
  FIdentifierList.Free;
  FPurpose.free;
  FCopyright.free;
  FStructureList.Free;
  FImportList.Free;
  FGroupList.Free;
  inherited;
end;

function TFhirStructureMap.GetResourceType : TFhirResourceType;
begin
  result := frtStructureMap;
end;

procedure TFhirStructureMap.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirStructureMap(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirStructureMap(oSource).FIdentifierList);
  end;
  purposeElement := TFhirStructureMap(oSource).purposeElement.Clone;
  copyrightElement := TFhirStructureMap(oSource).copyrightElement.Clone;
  if (TFhirStructureMap(oSource).FStructureList = nil) then
  begin
    FStructureList.free;
    FStructureList := nil;
  end
  else
  begin
    if FStructureList = nil then
      FStructureList := TFhirStructureMapStructureList.Create;
    FStructureList.Assign(TFhirStructureMap(oSource).FStructureList);
  end;
  if (TFhirStructureMap(oSource).FImportList = nil) then
  begin
    FImportList.free;
    FImportList := nil;
  end
  else
  begin
    if FImportList = nil then
      FImportList := TFhirUriList.Create;
    FImportList.Assign(TFhirStructureMap(oSource).FImportList);
  end;
  if (TFhirStructureMap(oSource).FGroupList = nil) then
  begin
    FGroupList.free;
    FGroupList := nil;
  end
  else
  begin
    if FGroupList = nil then
      FGroupList := TFhirStructureMapGroupList.Create;
    FGroupList.Assign(TFhirStructureMap(oSource).FGroupList);
  end;
end;

procedure TFhirStructureMap.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'structure') Then
    list.addAll(self, 'structure', FStructureList);
  if (child_name = 'import') Then
    list.addAll(self, 'import', FImportList);
  if (child_name = 'group') Then
    list.addAll(self, 'group', FGroupList);
end;

procedure TFhirStructureMap.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));{2}
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));{2}
  oList.add(TFHIRProperty.create(self, 'structure', '', true, TFhirStructureMapStructure, FStructureList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'import', 'uri', true, TFhirUri, FImportList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'group', '', true, TFhirStructureMapGroup, FGroupList.Link)){3};
end;

function TFhirStructureMap.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'structure') then
  begin
    StructureList.add(propValue as TFhirStructureMapStructure){2a};
    result := propValue;
  end
  else if (propName = 'import') then
  begin
    ImportList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'group') then
  begin
    GroupList.add(propValue as TFhirStructureMapGroup){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirStructureMap.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else if (propName = 'structure') then StructureList.insertItem(index, propValue as TFhirStructureMapStructure){2a}
  else if (propName = 'import') then ImportList.insertItem(index, asUri(propValue)){2}
  else if (propName = 'group') then GroupList.insertItem(index, propValue as TFhirStructureMapGroup){2a}
  else inherited;
end;

function TFhirStructureMap.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'purpose') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'copyright') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'structure') then result := StructureList.new(){2}
  else if (propName = 'import') then result := ImportList.new(){2}
  else if (propName = 'group') then result := GroupList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirStructureMap.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'structure') then result := ''
  else if (propName = 'import') then result := 'uri'
  else if (propName = 'group') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirStructureMap.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'structure') then deletePropertyValue('structure', StructureList, value) {2}
  else if (propName = 'import') then deletePropertyValue('import', ImportList, value) {2}
  else if (propName = 'group') then deletePropertyValue('group', GroupList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirStructureMap.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'purpose') then PurposeElement := asMarkdown(new){5b}
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new){5b}
  else if (propName = 'structure') then replacePropertyValue('structure', StructureList, existing, new) {2}
  else if (propName = 'import') then replacePropertyValue('import', ImportList, existing, new) {2}
  else if (propName = 'group') then replacePropertyValue('group', GroupList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirStructureMap.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else if (propName = 'structure') then StructureList.move(source, destination){2a}
  else if (propName = 'import') then ImportList.move(source, destination){2}
  else if (propName = 'group') then GroupList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirStructureMap.fhirType : string;
begin
  result := 'StructureMap';
end;

function TFhirStructureMap.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FPurpose) and isEmptyProp(FCopyright) and isEmptyProp(FstructureList) and isEmptyProp(FimportList) and isEmptyProp(FgroupList);
end;

function TFhirStructureMap.equals(other : TObject) : boolean;
var
  o : TFhirStructureMap;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirStructureMap)) then
    result := false
  else
  begin
    o := TFhirStructureMap(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(purposeElement, o.purposeElement, true) and
      compareDeep(copyrightElement, o.copyrightElement, true) and compareDeep(structureList, o.structureList, true) and
      compareDeep(importList, o.importList, true) and compareDeep(groupList, o.groupList, true);
  end;
end;

function TFhirStructureMap.Link : TFhirStructureMap;
begin
  result := TFhirStructureMap(inherited Link);
end;

function TFhirStructureMap.Clone : TFhirStructureMap;
begin
  result := TFhirStructureMap(inherited Clone);
end;

procedure TFhirStructureMap.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('status');
  fields.add('experimental');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('purpose');
  fields.add('copyright');
  fields.add('structure');
  fields.add('import');
  fields.add('group');
end;

{ TFhirStructureMap }

Function TFhirStructureMap.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirStructureMap.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirStructureMap.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

Function TFhirStructureMap.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

Procedure TFhirStructureMap.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

Procedure TFhirStructureMap.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

Function TFhirStructureMap.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

Procedure TFhirStructureMap.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

Function TFhirStructureMap.GetStructureList : TFhirStructureMapStructureList;
begin
  if FStructureList = nil then
    FStructureList := TFhirStructureMapStructureList.Create;
  result := FStructureList;
end;

Function TFhirStructureMap.GetHasStructureList : boolean;
begin
  result := (FStructureList <> nil) and (FStructureList.count > 0);
end;

Function TFhirStructureMap.GetImportList : TFhirUriList;
begin
  if FImportList = nil then
    FImportList := TFhirUriList.Create;
  result := FImportList;
end;

Function TFhirStructureMap.GetHasImportList : boolean;
begin
  result := (FImportList <> nil) and (FImportList.count > 0);
end;

Function TFhirStructureMap.GetGroupList : TFhirStructureMapGroupList;
begin
  if FGroupList = nil then
    FGroupList := TFhirStructureMapGroupList.Create;
  result := FGroupList;
end;

Function TFhirStructureMap.GetHasGroupList : boolean;
begin
  result := (FGroupList <> nil) and (FGroupList.count > 0);
end;

function TFhirStructureMap.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FPurpose.sizeInBytes);
  inc(result, FCopyright.sizeInBytes);
  inc(result, FstructureList.sizeInBytes);
  inc(result, FimportList.sizeInBytes);
  inc(result, FgroupList.sizeInBytes);
end;

{ TFhirStructureMapListEnumerator }

Constructor TFhirStructureMapListEnumerator.Create(list : TFhirStructureMapList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirStructureMapListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirStructureMapListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirStructureMapListEnumerator.GetCurrent : TFhirStructureMap;
begin
  Result := FList[FIndex];
end;

function TFhirStructureMapListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirStructureMapList }
procedure TFhirStructureMapList.AddItem(value: TFhirStructureMap);
begin
  assert(value.ClassName = 'TFhirStructureMap', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirStructureMap');
  add(value);
end;

function TFhirStructureMapList.Append: TFhirStructureMap;
begin
  result := TFhirStructureMap.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureMapList.ClearItems;
begin
  Clear;
end;

function TFhirStructureMapList.GetEnumerator : TFhirStructureMapListEnumerator;
begin
  result := TFhirStructureMapListEnumerator.Create(self.link);
end;

function TFhirStructureMapList.Clone: TFhirStructureMapList;
begin
  result := TFhirStructureMapList(inherited Clone);
end;

function TFhirStructureMapList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirStructureMapList.GetItemN(index: Integer): TFhirStructureMap;
begin
  result := TFhirStructureMap(ObjectByIndex[index]);
end;

function TFhirStructureMapList.ItemClass: TFslObjectClass;
begin
  result := TFhirStructureMap;
end;
function TFhirStructureMapList.IndexOf(value: TFhirStructureMap): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirStructureMapList.Insert(index: Integer): TFhirStructureMap;
begin
  result := TFhirStructureMap.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirStructureMapList.InsertItem(index: Integer; value: TFhirStructureMap);
begin
  assert(value is TFhirStructureMap);
  Inherited Insert(index, value);
end;

function TFhirStructureMapList.Item(index: Integer): TFhirStructureMap;
begin
  result := TFhirStructureMap(ObjectByIndex[index]);
end;

function TFhirStructureMapList.Link: TFhirStructureMapList;
begin
  result := TFhirStructureMapList(inherited Link);
end;

procedure TFhirStructureMapList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirStructureMapList.SetItemByIndex(index: Integer; value: TFhirStructureMap);
begin
  assert(value is TFhirStructureMap);
  FhirStructureMaps[index] := value;
end;

procedure TFhirStructureMapList.SetItemN(index: Integer; value: TFhirStructureMap);
begin
  assert(value is TFhirStructureMap);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_STRUCTUREMAP}

{$IFDEF FHIR_TESTSCRIPT}

{ TFhirTestScriptOrigin }

constructor TFhirTestScriptOrigin.Create;
begin
  inherited;
end;

destructor TFhirTestScriptOrigin.Destroy;
begin
  FIndex.free;
  FProfile.free;
  inherited;
end;

procedure TFhirTestScriptOrigin.Assign(oSource : TFslObject);
begin
  inherited;
  indexElement := TFhirTestScriptOrigin(oSource).indexElement.Clone;
  profile := TFhirTestScriptOrigin(oSource).profile.Clone;
end;

procedure TFhirTestScriptOrigin.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'index') Then
     list.add(self.link, 'index', FIndex.Link);
  if (child_name = 'profile') Then
     list.add(self.link, 'profile', FProfile.Link);
end;

procedure TFhirTestScriptOrigin.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'index', 'integer', false, TFhirInteger, FIndex.Link));{2}
  oList.add(TFHIRProperty.create(self, 'profile', 'Coding', false, TFhirCoding, FProfile.Link));{2}
end;

function TFhirTestScriptOrigin.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'index') then
  begin
    IndexElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'profile') then
  begin
    Profile := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptOrigin.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestScriptOrigin.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'index') then result := TFhirInteger.create() {5b}
  else if (propName = 'profile') then result := TFhirCoding.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptOrigin.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'index') then result := 'integer'
  else if (propName = 'profile') then result := 'Coding'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptOrigin.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'index') then IndexElement := nil
  else if (propName = 'profile') then ProfileElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptOrigin.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'index') then IndexElement := asInteger(new){5b}
  else if (propName = 'profile') then ProfileElement := new as TFhirCoding{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptOrigin.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptOrigin.fhirType : string;
begin
  result := 'origin';
end;

function TFhirTestScriptOrigin.Link : TFhirTestScriptOrigin;
begin
  result := TFhirTestScriptOrigin(inherited Link);
end;

function TFhirTestScriptOrigin.Clone : TFhirTestScriptOrigin;
begin
  result := TFhirTestScriptOrigin(inherited Clone);
end;

function TFhirTestScriptOrigin.equals(other : TObject) : boolean;
var
  o : TFhirTestScriptOrigin;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptOrigin)) then
    result := false
  else
  begin
    o := TFhirTestScriptOrigin(other);
    result := compareDeep(indexElement, o.indexElement, true) and compareDeep(profileElement, o.profileElement, true);
  end;
end;

function TFhirTestScriptOrigin.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIndex) and isEmptyProp(FProfile);
end;

procedure TFhirTestScriptOrigin.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('index');
  fields.add('profile');
end;

{ TFhirTestScriptOrigin }

Procedure TFhirTestScriptOrigin.SetIndex(value : TFhirInteger);
begin
  FIndex.free;
  FIndex := value;
end;

Function TFhirTestScriptOrigin.GetIndexST : String;
begin
  if FIndex = nil then
    result := ''
  else
    result := FIndex.value;
end;

Procedure TFhirTestScriptOrigin.SetIndexST(value : String);
begin
  if value <> '' then
  begin
    if FIndex = nil then
      FIndex := TFhirInteger.create;
    FIndex.value := value
  end
  else if FIndex <> nil then
    FIndex.value := '';
end;

Procedure TFhirTestScriptOrigin.SetProfile(value : TFhirCoding);
begin
  FProfile.free;
  FProfile := value;
end;

function TFhirTestScriptOrigin.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIndex.sizeInBytes);
  inc(result, FProfile.sizeInBytes);
end;

{ TFhirTestScriptOriginListEnumerator }

Constructor TFhirTestScriptOriginListEnumerator.Create(list : TFhirTestScriptOriginList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptOriginListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptOriginListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptOriginListEnumerator.GetCurrent : TFhirTestScriptOrigin;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptOriginListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptOriginList }
procedure TFhirTestScriptOriginList.AddItem(value: TFhirTestScriptOrigin);
begin
  assert(value.ClassName = 'TFhirTestScriptOrigin', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptOrigin');
  add(value);
end;

function TFhirTestScriptOriginList.Append: TFhirTestScriptOrigin;
begin
  result := TFhirTestScriptOrigin.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptOriginList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptOriginList.GetEnumerator : TFhirTestScriptOriginListEnumerator;
begin
  result := TFhirTestScriptOriginListEnumerator.Create(self.link);
end;

function TFhirTestScriptOriginList.Clone: TFhirTestScriptOriginList;
begin
  result := TFhirTestScriptOriginList(inherited Clone);
end;

function TFhirTestScriptOriginList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptOriginList.GetItemN(index: Integer): TFhirTestScriptOrigin;
begin
  result := TFhirTestScriptOrigin(ObjectByIndex[index]);
end;

function TFhirTestScriptOriginList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptOrigin;
end;
function TFhirTestScriptOriginList.IndexOf(value: TFhirTestScriptOrigin): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptOriginList.Insert(index: Integer): TFhirTestScriptOrigin;
begin
  result := TFhirTestScriptOrigin.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptOriginList.InsertItem(index: Integer; value: TFhirTestScriptOrigin);
begin
  assert(value is TFhirTestScriptOrigin);
  Inherited Insert(index, value);
end;

function TFhirTestScriptOriginList.Item(index: Integer): TFhirTestScriptOrigin;
begin
  result := TFhirTestScriptOrigin(ObjectByIndex[index]);
end;

function TFhirTestScriptOriginList.Link: TFhirTestScriptOriginList;
begin
  result := TFhirTestScriptOriginList(inherited Link);
end;

procedure TFhirTestScriptOriginList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptOriginList.SetItemByIndex(index: Integer; value: TFhirTestScriptOrigin);
begin
  assert(value is TFhirTestScriptOrigin);
  FhirTestScriptOrigins[index] := value;
end;

procedure TFhirTestScriptOriginList.SetItemN(index: Integer; value: TFhirTestScriptOrigin);
begin
  assert(value is TFhirTestScriptOrigin);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptDestination }

constructor TFhirTestScriptDestination.Create;
begin
  inherited;
end;

destructor TFhirTestScriptDestination.Destroy;
begin
  FIndex.free;
  FProfile.free;
  inherited;
end;

procedure TFhirTestScriptDestination.Assign(oSource : TFslObject);
begin
  inherited;
  indexElement := TFhirTestScriptDestination(oSource).indexElement.Clone;
  profile := TFhirTestScriptDestination(oSource).profile.Clone;
end;

procedure TFhirTestScriptDestination.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'index') Then
     list.add(self.link, 'index', FIndex.Link);
  if (child_name = 'profile') Then
     list.add(self.link, 'profile', FProfile.Link);
end;

procedure TFhirTestScriptDestination.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'index', 'integer', false, TFhirInteger, FIndex.Link));{2}
  oList.add(TFHIRProperty.create(self, 'profile', 'Coding', false, TFhirCoding, FProfile.Link));{2}
end;

function TFhirTestScriptDestination.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'index') then
  begin
    IndexElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'profile') then
  begin
    Profile := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptDestination.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestScriptDestination.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'index') then result := TFhirInteger.create() {5b}
  else if (propName = 'profile') then result := TFhirCoding.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptDestination.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'index') then result := 'integer'
  else if (propName = 'profile') then result := 'Coding'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptDestination.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'index') then IndexElement := nil
  else if (propName = 'profile') then ProfileElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptDestination.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'index') then IndexElement := asInteger(new){5b}
  else if (propName = 'profile') then ProfileElement := new as TFhirCoding{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptDestination.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptDestination.fhirType : string;
begin
  result := 'destination';
end;

function TFhirTestScriptDestination.Link : TFhirTestScriptDestination;
begin
  result := TFhirTestScriptDestination(inherited Link);
end;

function TFhirTestScriptDestination.Clone : TFhirTestScriptDestination;
begin
  result := TFhirTestScriptDestination(inherited Clone);
end;

function TFhirTestScriptDestination.equals(other : TObject) : boolean;
var
  o : TFhirTestScriptDestination;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptDestination)) then
    result := false
  else
  begin
    o := TFhirTestScriptDestination(other);
    result := compareDeep(indexElement, o.indexElement, true) and compareDeep(profileElement, o.profileElement, true);
  end;
end;

function TFhirTestScriptDestination.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIndex) and isEmptyProp(FProfile);
end;

procedure TFhirTestScriptDestination.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('index');
  fields.add('profile');
end;

{ TFhirTestScriptDestination }

Procedure TFhirTestScriptDestination.SetIndex(value : TFhirInteger);
begin
  FIndex.free;
  FIndex := value;
end;

Function TFhirTestScriptDestination.GetIndexST : String;
begin
  if FIndex = nil then
    result := ''
  else
    result := FIndex.value;
end;

Procedure TFhirTestScriptDestination.SetIndexST(value : String);
begin
  if value <> '' then
  begin
    if FIndex = nil then
      FIndex := TFhirInteger.create;
    FIndex.value := value
  end
  else if FIndex <> nil then
    FIndex.value := '';
end;

Procedure TFhirTestScriptDestination.SetProfile(value : TFhirCoding);
begin
  FProfile.free;
  FProfile := value;
end;

function TFhirTestScriptDestination.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIndex.sizeInBytes);
  inc(result, FProfile.sizeInBytes);
end;

{ TFhirTestScriptDestinationListEnumerator }

Constructor TFhirTestScriptDestinationListEnumerator.Create(list : TFhirTestScriptDestinationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptDestinationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptDestinationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptDestinationListEnumerator.GetCurrent : TFhirTestScriptDestination;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptDestinationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptDestinationList }
procedure TFhirTestScriptDestinationList.AddItem(value: TFhirTestScriptDestination);
begin
  assert(value.ClassName = 'TFhirTestScriptDestination', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptDestination');
  add(value);
end;

function TFhirTestScriptDestinationList.Append: TFhirTestScriptDestination;
begin
  result := TFhirTestScriptDestination.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptDestinationList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptDestinationList.GetEnumerator : TFhirTestScriptDestinationListEnumerator;
begin
  result := TFhirTestScriptDestinationListEnumerator.Create(self.link);
end;

function TFhirTestScriptDestinationList.Clone: TFhirTestScriptDestinationList;
begin
  result := TFhirTestScriptDestinationList(inherited Clone);
end;

function TFhirTestScriptDestinationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptDestinationList.GetItemN(index: Integer): TFhirTestScriptDestination;
begin
  result := TFhirTestScriptDestination(ObjectByIndex[index]);
end;

function TFhirTestScriptDestinationList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptDestination;
end;
function TFhirTestScriptDestinationList.IndexOf(value: TFhirTestScriptDestination): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptDestinationList.Insert(index: Integer): TFhirTestScriptDestination;
begin
  result := TFhirTestScriptDestination.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptDestinationList.InsertItem(index: Integer; value: TFhirTestScriptDestination);
begin
  assert(value is TFhirTestScriptDestination);
  Inherited Insert(index, value);
end;

function TFhirTestScriptDestinationList.Item(index: Integer): TFhirTestScriptDestination;
begin
  result := TFhirTestScriptDestination(ObjectByIndex[index]);
end;

function TFhirTestScriptDestinationList.Link: TFhirTestScriptDestinationList;
begin
  result := TFhirTestScriptDestinationList(inherited Link);
end;

procedure TFhirTestScriptDestinationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptDestinationList.SetItemByIndex(index: Integer; value: TFhirTestScriptDestination);
begin
  assert(value is TFhirTestScriptDestination);
  FhirTestScriptDestinations[index] := value;
end;

procedure TFhirTestScriptDestinationList.SetItemN(index: Integer; value: TFhirTestScriptDestination);
begin
  assert(value is TFhirTestScriptDestination);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptMetadata }

constructor TFhirTestScriptMetadata.Create;
begin
  inherited;
end;

destructor TFhirTestScriptMetadata.Destroy;
begin
  FLink_List.Free;
  FCapabilityList.Free;
  inherited;
end;

procedure TFhirTestScriptMetadata.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirTestScriptMetadata(oSource).FLink_List = nil) then
  begin
    FLink_List.free;
    FLink_List := nil;
  end
  else
  begin
    if FLink_List = nil then
      FLink_List := TFhirTestScriptMetadataLinkList.Create;
    FLink_List.Assign(TFhirTestScriptMetadata(oSource).FLink_List);
  end;
  if (TFhirTestScriptMetadata(oSource).FCapabilityList = nil) then
  begin
    FCapabilityList.free;
    FCapabilityList := nil;
  end
  else
  begin
    if FCapabilityList = nil then
      FCapabilityList := TFhirTestScriptMetadataCapabilityList.Create;
    FCapabilityList.Assign(TFhirTestScriptMetadata(oSource).FCapabilityList);
  end;
end;

procedure TFhirTestScriptMetadata.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'link') Then
    list.addAll(self, 'link', FLink_List);
  if (child_name = 'capability') Then
    list.addAll(self, 'capability', FCapabilityList);
end;

procedure TFhirTestScriptMetadata.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'link', '', true, TFhirTestScriptMetadataLink, FLink_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'capability', '', true, TFhirTestScriptMetadataCapability, FCapabilityList.Link)){3};
end;

function TFhirTestScriptMetadata.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'link') then
  begin
    Link_List.add(propValue as TFhirTestScriptMetadataLink){2a};
    result := propValue;
  end
  else if (propName = 'capability') then
  begin
    CapabilityList.add(propValue as TFhirTestScriptMetadataCapability){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptMetadata.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'link') then Link_List.insertItem(index, propValue as TFhirTestScriptMetadataLink){2a}
  else if (propName = 'capability') then CapabilityList.insertItem(index, propValue as TFhirTestScriptMetadataCapability){2a}
  else inherited;
end;

function TFhirTestScriptMetadata.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'link') then result := Link_List.new(){2}
  else if (propName = 'capability') then result := CapabilityList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptMetadata.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'link') then result := ''
  else if (propName = 'capability') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptMetadata.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'link') then deletePropertyValue('link', Link_List, value) {2}
  else if (propName = 'capability') then deletePropertyValue('capability', CapabilityList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptMetadata.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'link') then replacePropertyValue('link', Link_List, existing, new) {2}
  else if (propName = 'capability') then replacePropertyValue('capability', CapabilityList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptMetadata.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'link') then Link_List.move(source, destination){2a}
  else if (propName = 'capability') then CapabilityList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptMetadata.fhirType : string;
begin
  result := 'metadata';
end;

function TFhirTestScriptMetadata.Link : TFhirTestScriptMetadata;
begin
  result := TFhirTestScriptMetadata(inherited Link);
end;

function TFhirTestScriptMetadata.Clone : TFhirTestScriptMetadata;
begin
  result := TFhirTestScriptMetadata(inherited Clone);
end;

function TFhirTestScriptMetadata.equals(other : TObject) : boolean;
var
  o : TFhirTestScriptMetadata;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptMetadata)) then
    result := false
  else
  begin
    o := TFhirTestScriptMetadata(other);
    result := compareDeep(link_List, o.link_List, true) and compareDeep(capabilityList, o.capabilityList, true);
  end;
end;

function TFhirTestScriptMetadata.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(Flink_List) and isEmptyProp(FcapabilityList);
end;

procedure TFhirTestScriptMetadata.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('link');
  fields.add('capability');
end;

{ TFhirTestScriptMetadata }

Function TFhirTestScriptMetadata.GetLink_List : TFhirTestScriptMetadataLinkList;
begin
  if FLink_List = nil then
    FLink_List := TFhirTestScriptMetadataLinkList.Create;
  result := FLink_List;
end;

Function TFhirTestScriptMetadata.GetHasLink_List : boolean;
begin
  result := (FLink_List <> nil) and (FLink_List.count > 0);
end;

Function TFhirTestScriptMetadata.GetCapabilityList : TFhirTestScriptMetadataCapabilityList;
begin
  if FCapabilityList = nil then
    FCapabilityList := TFhirTestScriptMetadataCapabilityList.Create;
  result := FCapabilityList;
end;

Function TFhirTestScriptMetadata.GetHasCapabilityList : boolean;
begin
  result := (FCapabilityList <> nil) and (FCapabilityList.count > 0);
end;

function TFhirTestScriptMetadata.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, Flink_List.sizeInBytes);
  inc(result, FcapabilityList.sizeInBytes);
end;

{ TFhirTestScriptMetadataListEnumerator }

Constructor TFhirTestScriptMetadataListEnumerator.Create(list : TFhirTestScriptMetadataList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptMetadataListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptMetadataListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptMetadataListEnumerator.GetCurrent : TFhirTestScriptMetadata;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptMetadataListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptMetadataList }
procedure TFhirTestScriptMetadataList.AddItem(value: TFhirTestScriptMetadata);
begin
  assert(value.ClassName = 'TFhirTestScriptMetadata', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptMetadata');
  add(value);
end;

function TFhirTestScriptMetadataList.Append: TFhirTestScriptMetadata;
begin
  result := TFhirTestScriptMetadata.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptMetadataList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptMetadataList.GetEnumerator : TFhirTestScriptMetadataListEnumerator;
begin
  result := TFhirTestScriptMetadataListEnumerator.Create(self.link);
end;

function TFhirTestScriptMetadataList.Clone: TFhirTestScriptMetadataList;
begin
  result := TFhirTestScriptMetadataList(inherited Clone);
end;

function TFhirTestScriptMetadataList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptMetadataList.GetItemN(index: Integer): TFhirTestScriptMetadata;
begin
  result := TFhirTestScriptMetadata(ObjectByIndex[index]);
end;

function TFhirTestScriptMetadataList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptMetadata;
end;
function TFhirTestScriptMetadataList.IndexOf(value: TFhirTestScriptMetadata): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptMetadataList.Insert(index: Integer): TFhirTestScriptMetadata;
begin
  result := TFhirTestScriptMetadata.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptMetadataList.InsertItem(index: Integer; value: TFhirTestScriptMetadata);
begin
  assert(value is TFhirTestScriptMetadata);
  Inherited Insert(index, value);
end;

function TFhirTestScriptMetadataList.Item(index: Integer): TFhirTestScriptMetadata;
begin
  result := TFhirTestScriptMetadata(ObjectByIndex[index]);
end;

function TFhirTestScriptMetadataList.Link: TFhirTestScriptMetadataList;
begin
  result := TFhirTestScriptMetadataList(inherited Link);
end;

procedure TFhirTestScriptMetadataList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptMetadataList.SetItemByIndex(index: Integer; value: TFhirTestScriptMetadata);
begin
  assert(value is TFhirTestScriptMetadata);
  FhirTestScriptMetadata[index] := value;
end;

procedure TFhirTestScriptMetadataList.SetItemN(index: Integer; value: TFhirTestScriptMetadata);
begin
  assert(value is TFhirTestScriptMetadata);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptMetadataLink }

constructor TFhirTestScriptMetadataLink.Create;
begin
  inherited;
end;

destructor TFhirTestScriptMetadataLink.Destroy;
begin
  FUrl.free;
  FDescription.free;
  inherited;
end;

procedure TFhirTestScriptMetadataLink.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirTestScriptMetadataLink(oSource).urlElement.Clone;
  descriptionElement := TFhirTestScriptMetadataLink(oSource).descriptionElement.Clone;
end;

procedure TFhirTestScriptMetadataLink.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
end;

procedure TFhirTestScriptMetadataLink.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
end;

function TFhirTestScriptMetadataLink.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptMetadataLink.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestScriptMetadataLink.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptMetadataLink.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'description') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptMetadataLink.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptMetadataLink.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptMetadataLink.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptMetadataLink.fhirType : string;
begin
  result := 'link';
end;

function TFhirTestScriptMetadataLink.Link : TFhirTestScriptMetadataLink;
begin
  result := TFhirTestScriptMetadataLink(inherited Link);
end;

function TFhirTestScriptMetadataLink.Clone : TFhirTestScriptMetadataLink;
begin
  result := TFhirTestScriptMetadataLink(inherited Clone);
end;

function TFhirTestScriptMetadataLink.equals(other : TObject) : boolean;
var
  o : TFhirTestScriptMetadataLink;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptMetadataLink)) then
    result := false
  else
  begin
    o := TFhirTestScriptMetadataLink(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(descriptionElement, o.descriptionElement, true);
  end;
end;

function TFhirTestScriptMetadataLink.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FDescription);
end;

procedure TFhirTestScriptMetadataLink.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('url');
  fields.add('description');
end;

{ TFhirTestScriptMetadataLink }

Procedure TFhirTestScriptMetadataLink.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirTestScriptMetadataLink.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

Procedure TFhirTestScriptMetadataLink.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

Procedure TFhirTestScriptMetadataLink.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirTestScriptMetadataLink.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirTestScriptMetadataLink.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirTestScriptMetadataLink.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FUrl.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
end;

{ TFhirTestScriptMetadataLinkListEnumerator }

Constructor TFhirTestScriptMetadataLinkListEnumerator.Create(list : TFhirTestScriptMetadataLinkList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptMetadataLinkListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptMetadataLinkListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptMetadataLinkListEnumerator.GetCurrent : TFhirTestScriptMetadataLink;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptMetadataLinkListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptMetadataLinkList }
procedure TFhirTestScriptMetadataLinkList.AddItem(value: TFhirTestScriptMetadataLink);
begin
  assert(value.ClassName = 'TFhirTestScriptMetadataLink', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptMetadataLink');
  add(value);
end;

function TFhirTestScriptMetadataLinkList.Append: TFhirTestScriptMetadataLink;
begin
  result := TFhirTestScriptMetadataLink.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptMetadataLinkList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptMetadataLinkList.GetEnumerator : TFhirTestScriptMetadataLinkListEnumerator;
begin
  result := TFhirTestScriptMetadataLinkListEnumerator.Create(self.link);
end;

function TFhirTestScriptMetadataLinkList.Clone: TFhirTestScriptMetadataLinkList;
begin
  result := TFhirTestScriptMetadataLinkList(inherited Clone);
end;

function TFhirTestScriptMetadataLinkList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptMetadataLinkList.GetItemN(index: Integer): TFhirTestScriptMetadataLink;
begin
  result := TFhirTestScriptMetadataLink(ObjectByIndex[index]);
end;

function TFhirTestScriptMetadataLinkList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptMetadataLink;
end;
function TFhirTestScriptMetadataLinkList.IndexOf(value: TFhirTestScriptMetadataLink): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptMetadataLinkList.Insert(index: Integer): TFhirTestScriptMetadataLink;
begin
  result := TFhirTestScriptMetadataLink.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptMetadataLinkList.InsertItem(index: Integer; value: TFhirTestScriptMetadataLink);
begin
  assert(value is TFhirTestScriptMetadataLink);
  Inherited Insert(index, value);
end;

function TFhirTestScriptMetadataLinkList.Item(index: Integer): TFhirTestScriptMetadataLink;
begin
  result := TFhirTestScriptMetadataLink(ObjectByIndex[index]);
end;

function TFhirTestScriptMetadataLinkList.Link: TFhirTestScriptMetadataLinkList;
begin
  result := TFhirTestScriptMetadataLinkList(inherited Link);
end;

procedure TFhirTestScriptMetadataLinkList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptMetadataLinkList.SetItemByIndex(index: Integer; value: TFhirTestScriptMetadataLink);
begin
  assert(value is TFhirTestScriptMetadataLink);
  FhirTestScriptMetadataLinks[index] := value;
end;

procedure TFhirTestScriptMetadataLinkList.SetItemN(index: Integer; value: TFhirTestScriptMetadataLink);
begin
  assert(value is TFhirTestScriptMetadataLink);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptMetadataCapability }

constructor TFhirTestScriptMetadataCapability.Create;
begin
  inherited;
end;

destructor TFhirTestScriptMetadataCapability.Destroy;
begin
  FRequired.free;
  FValidated.free;
  FDescription.free;
  FOriginList.Free;
  FDestination.free;
  FLink_List.Free;
  FCapabilities.free;
  inherited;
end;

procedure TFhirTestScriptMetadataCapability.Assign(oSource : TFslObject);
begin
  inherited;
  requiredElement := TFhirTestScriptMetadataCapability(oSource).requiredElement.Clone;
  validatedElement := TFhirTestScriptMetadataCapability(oSource).validatedElement.Clone;
  descriptionElement := TFhirTestScriptMetadataCapability(oSource).descriptionElement.Clone;
  if (TFhirTestScriptMetadataCapability(oSource).FOriginList = nil) then
  begin
    FOriginList.free;
    FOriginList := nil;
  end
  else
  begin
    if FOriginList = nil then
      FOriginList := TFhirIntegerList.Create;
    FOriginList.Assign(TFhirTestScriptMetadataCapability(oSource).FOriginList);
  end;
  destinationElement := TFhirTestScriptMetadataCapability(oSource).destinationElement.Clone;
  if (TFhirTestScriptMetadataCapability(oSource).FLink_List = nil) then
  begin
    FLink_List.free;
    FLink_List := nil;
  end
  else
  begin
    if FLink_List = nil then
      FLink_List := TFhirUriList.Create;
    FLink_List.Assign(TFhirTestScriptMetadataCapability(oSource).FLink_List);
  end;
  capabilities := TFhirTestScriptMetadataCapability(oSource).capabilities.Clone;
end;

procedure TFhirTestScriptMetadataCapability.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'required') Then
     list.add(self.link, 'required', FRequired.Link);
  if (child_name = 'validated') Then
     list.add(self.link, 'validated', FValidated.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'origin') Then
    list.addAll(self, 'origin', FOriginList);
  if (child_name = 'destination') Then
     list.add(self.link, 'destination', FDestination.Link);
  if (child_name = 'link') Then
    list.addAll(self, 'link', FLink_List);
  if (child_name = 'capabilities') Then
     list.add(self.link, 'capabilities', FCapabilities.Link);
end;

procedure TFhirTestScriptMetadataCapability.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'required', 'boolean', false, TFhirBoolean, FRequired.Link));{2}
  oList.add(TFHIRProperty.create(self, 'validated', 'boolean', false, TFhirBoolean, FValidated.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'origin', 'integer', true, TFhirInteger, FOriginList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'destination', 'integer', false, TFhirInteger, FDestination.Link));{2}
  oList.add(TFHIRProperty.create(self, 'link', 'uri', true, TFhirUri, FLink_List.Link)){3};
  oList.add(TFHIRProperty.create(self, 'capabilities', 'Reference(CapabilityStatement)', false, TFhirReference{TFhirCapabilityStatement}, FCapabilities.Link));{2}
end;

function TFhirTestScriptMetadataCapability.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'required') then
  begin
    RequiredElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'validated') then
  begin
    ValidatedElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'origin') then
  begin
    OriginList.add(asInteger(propValue)){2};     result := propValue;

  end
  else if (propName = 'destination') then
  begin
    DestinationElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'link') then
  begin
    Link_List.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'capabilities') then
  begin
    Capabilities := propValue as TFhirReference{TFhirCapabilityStatement}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptMetadataCapability.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'origin') then OriginList.insertItem(index, asInteger(propValue)){2}
  else if (propName = 'link') then Link_List.insertItem(index, asUri(propValue)){2}
  else inherited;
end;

function TFhirTestScriptMetadataCapability.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'required') then result := TFhirBoolean.create() {5b}
  else if (propName = 'validated') then result := TFhirBoolean.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'origin') then result := OriginList.new(){2}
  else if (propName = 'destination') then result := TFhirInteger.create() {5b}
  else if (propName = 'link') then result := Link_List.new(){2}
  else if (propName = 'capabilities') then result := TFhirReference{TFhirCapabilityStatement}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptMetadataCapability.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'required') then result := 'boolean'
  else if (propName = 'validated') then result := 'boolean'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'origin') then result := 'integer'
  else if (propName = 'destination') then result := 'integer'
  else if (propName = 'link') then result := 'uri'
  else if (propName = 'capabilities') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptMetadataCapability.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'required') then RequiredElement := nil
  else if (propName = 'validated') then ValidatedElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'origin') then deletePropertyValue('origin', OriginList, value) {2}
  else if (propName = 'destination') then DestinationElement := nil
  else if (propName = 'link') then deletePropertyValue('link', Link_List, value) {2}
  else if (propName = 'capabilities') then CapabilitiesElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptMetadataCapability.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'required') then RequiredElement := asBoolean(new){5b}
  else if (propName = 'validated') then ValidatedElement := asBoolean(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'origin') then replacePropertyValue('origin', OriginList, existing, new) {2}
  else if (propName = 'destination') then DestinationElement := asInteger(new){5b}
  else if (propName = 'link') then replacePropertyValue('link', Link_List, existing, new) {2}
  else if (propName = 'capabilities') then CapabilitiesElement := new as TFhirReference{TFhirCapabilityStatement}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptMetadataCapability.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'origin') then OriginList.move(source, destination){2}
  else if (propName = 'link') then Link_List.move(source, destination){2}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptMetadataCapability.fhirType : string;
begin
  result := 'capability';
end;

function TFhirTestScriptMetadataCapability.Link : TFhirTestScriptMetadataCapability;
begin
  result := TFhirTestScriptMetadataCapability(inherited Link);
end;

function TFhirTestScriptMetadataCapability.Clone : TFhirTestScriptMetadataCapability;
begin
  result := TFhirTestScriptMetadataCapability(inherited Clone);
end;

function TFhirTestScriptMetadataCapability.equals(other : TObject) : boolean;
var
  o : TFhirTestScriptMetadataCapability;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptMetadataCapability)) then
    result := false
  else
  begin
    o := TFhirTestScriptMetadataCapability(other);
    result := compareDeep(requiredElement, o.requiredElement, true) and compareDeep(validatedElement, o.validatedElement, true) and
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(originList, o.originList, true) and
      compareDeep(destinationElement, o.destinationElement, true) and compareDeep(link_List, o.link_List, true) and
      compareDeep(capabilitiesElement, o.capabilitiesElement, true);
  end;
end;

function TFhirTestScriptMetadataCapability.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRequired) and isEmptyProp(FValidated) and isEmptyProp(FDescription) and isEmptyProp(ForiginList) and isEmptyProp(FDestination) and isEmptyProp(Flink_List) and isEmptyProp(FCapabilities);
end;

procedure TFhirTestScriptMetadataCapability.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('required');
  fields.add('validated');
  fields.add('description');
  fields.add('origin');
  fields.add('destination');
  fields.add('link');
  fields.add('capabilities');
end;

{ TFhirTestScriptMetadataCapability }

Procedure TFhirTestScriptMetadataCapability.SetRequired(value : TFhirBoolean);
begin
  FRequired.free;
  FRequired := value;
end;

Function TFhirTestScriptMetadataCapability.GetRequiredST : Boolean;
begin
  if FRequired = nil then
    result := false
  else
    result := FRequired.value;
end;

Procedure TFhirTestScriptMetadataCapability.SetRequiredST(value : Boolean);
begin
  if FRequired = nil then
    FRequired := TFhirBoolean.create;
  FRequired.value := value
end;

Procedure TFhirTestScriptMetadataCapability.SetValidated(value : TFhirBoolean);
begin
  FValidated.free;
  FValidated := value;
end;

Function TFhirTestScriptMetadataCapability.GetValidatedST : Boolean;
begin
  if FValidated = nil then
    result := false
  else
    result := FValidated.value;
end;

Procedure TFhirTestScriptMetadataCapability.SetValidatedST(value : Boolean);
begin
  if FValidated = nil then
    FValidated := TFhirBoolean.create;
  FValidated.value := value
end;

Procedure TFhirTestScriptMetadataCapability.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirTestScriptMetadataCapability.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirTestScriptMetadataCapability.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Function TFhirTestScriptMetadataCapability.GetOriginList : TFhirIntegerList;
begin
  if FOriginList = nil then
    FOriginList := TFhirIntegerList.Create;
  result := FOriginList;
end;

Function TFhirTestScriptMetadataCapability.GetHasOriginList : boolean;
begin
  result := (FOriginList <> nil) and (FOriginList.count > 0);
end;

Procedure TFhirTestScriptMetadataCapability.SetDestination(value : TFhirInteger);
begin
  FDestination.free;
  FDestination := value;
end;

Function TFhirTestScriptMetadataCapability.GetDestinationST : String;
begin
  if FDestination = nil then
    result := ''
  else
    result := FDestination.value;
end;

Procedure TFhirTestScriptMetadataCapability.SetDestinationST(value : String);
begin
  if value <> '' then
  begin
    if FDestination = nil then
      FDestination := TFhirInteger.create;
    FDestination.value := value
  end
  else if FDestination <> nil then
    FDestination.value := '';
end;

Function TFhirTestScriptMetadataCapability.GetLink_List : TFhirUriList;
begin
  if FLink_List = nil then
    FLink_List := TFhirUriList.Create;
  result := FLink_List;
end;

Function TFhirTestScriptMetadataCapability.GetHasLink_List : boolean;
begin
  result := (FLink_List <> nil) and (FLink_List.count > 0);
end;

Procedure TFhirTestScriptMetadataCapability.SetCapabilities(value : TFhirReference{TFhirCapabilityStatement});
begin
  FCapabilities.free;
  FCapabilities := value;
end;

function TFhirTestScriptMetadataCapability.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FRequired.sizeInBytes);
  inc(result, FValidated.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, ForiginList.sizeInBytes);
  inc(result, FDestination.sizeInBytes);
  inc(result, Flink_List.sizeInBytes);
  inc(result, FCapabilities.sizeInBytes);
end;

{ TFhirTestScriptMetadataCapabilityListEnumerator }

Constructor TFhirTestScriptMetadataCapabilityListEnumerator.Create(list : TFhirTestScriptMetadataCapabilityList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptMetadataCapabilityListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptMetadataCapabilityListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptMetadataCapabilityListEnumerator.GetCurrent : TFhirTestScriptMetadataCapability;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptMetadataCapabilityListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptMetadataCapabilityList }
procedure TFhirTestScriptMetadataCapabilityList.AddItem(value: TFhirTestScriptMetadataCapability);
begin
  assert(value.ClassName = 'TFhirTestScriptMetadataCapability', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptMetadataCapability');
  add(value);
end;

function TFhirTestScriptMetadataCapabilityList.Append: TFhirTestScriptMetadataCapability;
begin
  result := TFhirTestScriptMetadataCapability.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptMetadataCapabilityList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptMetadataCapabilityList.GetEnumerator : TFhirTestScriptMetadataCapabilityListEnumerator;
begin
  result := TFhirTestScriptMetadataCapabilityListEnumerator.Create(self.link);
end;

function TFhirTestScriptMetadataCapabilityList.Clone: TFhirTestScriptMetadataCapabilityList;
begin
  result := TFhirTestScriptMetadataCapabilityList(inherited Clone);
end;

function TFhirTestScriptMetadataCapabilityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptMetadataCapabilityList.GetItemN(index: Integer): TFhirTestScriptMetadataCapability;
begin
  result := TFhirTestScriptMetadataCapability(ObjectByIndex[index]);
end;

function TFhirTestScriptMetadataCapabilityList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptMetadataCapability;
end;
function TFhirTestScriptMetadataCapabilityList.IndexOf(value: TFhirTestScriptMetadataCapability): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptMetadataCapabilityList.Insert(index: Integer): TFhirTestScriptMetadataCapability;
begin
  result := TFhirTestScriptMetadataCapability.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptMetadataCapabilityList.InsertItem(index: Integer; value: TFhirTestScriptMetadataCapability);
begin
  assert(value is TFhirTestScriptMetadataCapability);
  Inherited Insert(index, value);
end;

function TFhirTestScriptMetadataCapabilityList.Item(index: Integer): TFhirTestScriptMetadataCapability;
begin
  result := TFhirTestScriptMetadataCapability(ObjectByIndex[index]);
end;

function TFhirTestScriptMetadataCapabilityList.Link: TFhirTestScriptMetadataCapabilityList;
begin
  result := TFhirTestScriptMetadataCapabilityList(inherited Link);
end;

procedure TFhirTestScriptMetadataCapabilityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptMetadataCapabilityList.SetItemByIndex(index: Integer; value: TFhirTestScriptMetadataCapability);
begin
  assert(value is TFhirTestScriptMetadataCapability);
  FhirTestScriptMetadataCapabilities[index] := value;
end;

procedure TFhirTestScriptMetadataCapabilityList.SetItemN(index: Integer; value: TFhirTestScriptMetadataCapability);
begin
  assert(value is TFhirTestScriptMetadataCapability);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptFixture }

constructor TFhirTestScriptFixture.Create;
begin
  inherited;
end;

destructor TFhirTestScriptFixture.Destroy;
begin
  FAutocreate.free;
  FAutodelete.free;
  FResource.free;
  inherited;
end;

procedure TFhirTestScriptFixture.Assign(oSource : TFslObject);
begin
  inherited;
  autocreateElement := TFhirTestScriptFixture(oSource).autocreateElement.Clone;
  autodeleteElement := TFhirTestScriptFixture(oSource).autodeleteElement.Clone;
  resource := TFhirTestScriptFixture(oSource).resource.Clone;
end;

procedure TFhirTestScriptFixture.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'autocreate') Then
     list.add(self.link, 'autocreate', FAutocreate.Link);
  if (child_name = 'autodelete') Then
     list.add(self.link, 'autodelete', FAutodelete.Link);
  if (child_name = 'resource') Then
     list.add(self.link, 'resource', FResource.Link);
end;

procedure TFhirTestScriptFixture.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'autocreate', 'boolean', false, TFhirBoolean, FAutocreate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'autodelete', 'boolean', false, TFhirBoolean, FAutodelete.Link));{2}
  oList.add(TFHIRProperty.create(self, 'resource', 'Reference(Any)', false, TFhirReference{TFhirReference}, FResource.Link));{2}
end;

function TFhirTestScriptFixture.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'autocreate') then
  begin
    AutocreateElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'autodelete') then
  begin
    AutodeleteElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    Resource := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptFixture.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestScriptFixture.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'autocreate') then result := TFhirBoolean.create() {5b}
  else if (propName = 'autodelete') then result := TFhirBoolean.create() {5b}
  else if (propName = 'resource') then result := TFhirReference{TFhirReference}.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptFixture.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'autocreate') then result := 'boolean'
  else if (propName = 'autodelete') then result := 'boolean'
  else if (propName = 'resource') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptFixture.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'autocreate') then AutocreateElement := nil
  else if (propName = 'autodelete') then AutodeleteElement := nil
  else if (propName = 'resource') then ResourceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptFixture.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'autocreate') then AutocreateElement := asBoolean(new){5b}
  else if (propName = 'autodelete') then AutodeleteElement := asBoolean(new){5b}
  else if (propName = 'resource') then ResourceElement := new as TFhirReference{TFhirReference}{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptFixture.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptFixture.fhirType : string;
begin
  result := 'fixture';
end;

function TFhirTestScriptFixture.Link : TFhirTestScriptFixture;
begin
  result := TFhirTestScriptFixture(inherited Link);
end;

function TFhirTestScriptFixture.Clone : TFhirTestScriptFixture;
begin
  result := TFhirTestScriptFixture(inherited Clone);
end;

function TFhirTestScriptFixture.equals(other : TObject) : boolean;
var
  o : TFhirTestScriptFixture;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptFixture)) then
    result := false
  else
  begin
    o := TFhirTestScriptFixture(other);
    result := compareDeep(autocreateElement, o.autocreateElement, true) and compareDeep(autodeleteElement, o.autodeleteElement, true) and
      compareDeep(resourceElement, o.resourceElement, true);
  end;
end;

function TFhirTestScriptFixture.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAutocreate) and isEmptyProp(FAutodelete) and isEmptyProp(FResource);
end;

procedure TFhirTestScriptFixture.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('autocreate');
  fields.add('autodelete');
  fields.add('resource');
end;

{ TFhirTestScriptFixture }

Procedure TFhirTestScriptFixture.SetAutocreate(value : TFhirBoolean);
begin
  FAutocreate.free;
  FAutocreate := value;
end;

Function TFhirTestScriptFixture.GetAutocreateST : Boolean;
begin
  if FAutocreate = nil then
    result := false
  else
    result := FAutocreate.value;
end;

Procedure TFhirTestScriptFixture.SetAutocreateST(value : Boolean);
begin
  if FAutocreate = nil then
    FAutocreate := TFhirBoolean.create;
  FAutocreate.value := value
end;

Procedure TFhirTestScriptFixture.SetAutodelete(value : TFhirBoolean);
begin
  FAutodelete.free;
  FAutodelete := value;
end;

Function TFhirTestScriptFixture.GetAutodeleteST : Boolean;
begin
  if FAutodelete = nil then
    result := false
  else
    result := FAutodelete.value;
end;

Procedure TFhirTestScriptFixture.SetAutodeleteST(value : Boolean);
begin
  if FAutodelete = nil then
    FAutodelete := TFhirBoolean.create;
  FAutodelete.value := value
end;

Procedure TFhirTestScriptFixture.SetResource(value : TFhirReference{TFhirReference});
begin
  FResource.free;
  FResource := value;
end;

function TFhirTestScriptFixture.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FAutocreate.sizeInBytes);
  inc(result, FAutodelete.sizeInBytes);
  inc(result, FResource.sizeInBytes);
end;

{ TFhirTestScriptFixtureListEnumerator }

Constructor TFhirTestScriptFixtureListEnumerator.Create(list : TFhirTestScriptFixtureList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptFixtureListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptFixtureListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptFixtureListEnumerator.GetCurrent : TFhirTestScriptFixture;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptFixtureListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptFixtureList }
procedure TFhirTestScriptFixtureList.AddItem(value: TFhirTestScriptFixture);
begin
  assert(value.ClassName = 'TFhirTestScriptFixture', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptFixture');
  add(value);
end;

function TFhirTestScriptFixtureList.Append: TFhirTestScriptFixture;
begin
  result := TFhirTestScriptFixture.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptFixtureList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptFixtureList.GetEnumerator : TFhirTestScriptFixtureListEnumerator;
begin
  result := TFhirTestScriptFixtureListEnumerator.Create(self.link);
end;

function TFhirTestScriptFixtureList.Clone: TFhirTestScriptFixtureList;
begin
  result := TFhirTestScriptFixtureList(inherited Clone);
end;

function TFhirTestScriptFixtureList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptFixtureList.GetItemN(index: Integer): TFhirTestScriptFixture;
begin
  result := TFhirTestScriptFixture(ObjectByIndex[index]);
end;

function TFhirTestScriptFixtureList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptFixture;
end;
function TFhirTestScriptFixtureList.IndexOf(value: TFhirTestScriptFixture): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptFixtureList.Insert(index: Integer): TFhirTestScriptFixture;
begin
  result := TFhirTestScriptFixture.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptFixtureList.InsertItem(index: Integer; value: TFhirTestScriptFixture);
begin
  assert(value is TFhirTestScriptFixture);
  Inherited Insert(index, value);
end;

function TFhirTestScriptFixtureList.Item(index: Integer): TFhirTestScriptFixture;
begin
  result := TFhirTestScriptFixture(ObjectByIndex[index]);
end;

function TFhirTestScriptFixtureList.Link: TFhirTestScriptFixtureList;
begin
  result := TFhirTestScriptFixtureList(inherited Link);
end;

procedure TFhirTestScriptFixtureList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptFixtureList.SetItemByIndex(index: Integer; value: TFhirTestScriptFixture);
begin
  assert(value is TFhirTestScriptFixture);
  FhirTestScriptFixtures[index] := value;
end;

procedure TFhirTestScriptFixtureList.SetItemN(index: Integer; value: TFhirTestScriptFixture);
begin
  assert(value is TFhirTestScriptFixture);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptVariable }

constructor TFhirTestScriptVariable.Create;
begin
  inherited;
end;

destructor TFhirTestScriptVariable.Destroy;
begin
  FName.free;
  FDefaultValue.free;
  FDescription.free;
  FExpression.free;
  FHeaderField.free;
  FHint.free;
  FPath.free;
  FSourceId.free;
  inherited;
end;

procedure TFhirTestScriptVariable.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirTestScriptVariable(oSource).nameElement.Clone;
  defaultValueElement := TFhirTestScriptVariable(oSource).defaultValueElement.Clone;
  descriptionElement := TFhirTestScriptVariable(oSource).descriptionElement.Clone;
  expressionElement := TFhirTestScriptVariable(oSource).expressionElement.Clone;
  headerFieldElement := TFhirTestScriptVariable(oSource).headerFieldElement.Clone;
  hintElement := TFhirTestScriptVariable(oSource).hintElement.Clone;
  pathElement := TFhirTestScriptVariable(oSource).pathElement.Clone;
  sourceIdElement := TFhirTestScriptVariable(oSource).sourceIdElement.Clone;
end;

procedure TFhirTestScriptVariable.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'defaultValue') Then
     list.add(self.link, 'defaultValue', FDefaultValue.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'expression') Then
     list.add(self.link, 'expression', FExpression.Link);
  if (child_name = 'headerField') Then
     list.add(self.link, 'headerField', FHeaderField.Link);
  if (child_name = 'hint') Then
     list.add(self.link, 'hint', FHint.Link);
  if (child_name = 'path') Then
     list.add(self.link, 'path', FPath.Link);
  if (child_name = 'sourceId') Then
     list.add(self.link, 'sourceId', FSourceId.Link);
end;

procedure TFhirTestScriptVariable.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'defaultValue', 'string', false, TFhirString, FDefaultValue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'expression', 'string', false, TFhirString, FExpression.Link));{2}
  oList.add(TFHIRProperty.create(self, 'headerField', 'string', false, TFhirString, FHeaderField.Link));{2}
  oList.add(TFHIRProperty.create(self, 'hint', 'string', false, TFhirString, FHint.Link));{2}
  oList.add(TFHIRProperty.create(self, 'path', 'string', false, TFhirString, FPath.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sourceId', 'id', false, TFhirId, FSourceId.Link));{2}
end;

function TFhirTestScriptVariable.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'defaultValue') then
  begin
    DefaultValueElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'expression') then
  begin
    ExpressionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'headerField') then
  begin
    HeaderFieldElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'hint') then
  begin
    HintElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'path') then
  begin
    PathElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'sourceId') then
  begin
    SourceIdElement := asId(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptVariable.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestScriptVariable.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'defaultValue') then result := TFhirString.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'expression') then result := TFhirString.create() {5b}
  else if (propName = 'headerField') then result := TFhirString.create() {5b}
  else if (propName = 'hint') then result := TFhirString.create() {5b}
  else if (propName = 'path') then result := TFhirString.create() {5b}
  else if (propName = 'sourceId') then result := TFhirId.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptVariable.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'defaultValue') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'expression') then result := 'string'
  else if (propName = 'headerField') then result := 'string'
  else if (propName = 'hint') then result := 'string'
  else if (propName = 'path') then result := 'string'
  else if (propName = 'sourceId') then result := 'id'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptVariable.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'defaultValue') then DefaultValueElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'expression') then ExpressionElement := nil
  else if (propName = 'headerField') then HeaderFieldElement := nil
  else if (propName = 'hint') then HintElement := nil
  else if (propName = 'path') then PathElement := nil
  else if (propName = 'sourceId') then SourceIdElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptVariable.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'defaultValue') then DefaultValueElement := asString(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'expression') then ExpressionElement := asString(new){5b}
  else if (propName = 'headerField') then HeaderFieldElement := asString(new){5b}
  else if (propName = 'hint') then HintElement := asString(new){5b}
  else if (propName = 'path') then PathElement := asString(new){5b}
  else if (propName = 'sourceId') then SourceIdElement := asId(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptVariable.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptVariable.fhirType : string;
begin
  result := 'variable';
end;

function TFhirTestScriptVariable.Link : TFhirTestScriptVariable;
begin
  result := TFhirTestScriptVariable(inherited Link);
end;

function TFhirTestScriptVariable.Clone : TFhirTestScriptVariable;
begin
  result := TFhirTestScriptVariable(inherited Clone);
end;

function TFhirTestScriptVariable.equals(other : TObject) : boolean;
var
  o : TFhirTestScriptVariable;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptVariable)) then
    result := false
  else
  begin
    o := TFhirTestScriptVariable(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(defaultValueElement, o.defaultValueElement, true) and
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(expressionElement, o.expressionElement, true) and
      compareDeep(headerFieldElement, o.headerFieldElement, true) and compareDeep(hintElement, o.hintElement, true) and
      compareDeep(pathElement, o.pathElement, true) and compareDeep(sourceIdElement, o.sourceIdElement, true);
  end;
end;

function TFhirTestScriptVariable.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FDefaultValue) and isEmptyProp(FDescription) and isEmptyProp(FExpression) and isEmptyProp(FHeaderField) and isEmptyProp(FHint) and isEmptyProp(FPath) and isEmptyProp(FSourceId);
end;

procedure TFhirTestScriptVariable.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('defaultValue');
  fields.add('description');
  fields.add('expression');
  fields.add('headerField');
  fields.add('hint');
  fields.add('path');
  fields.add('sourceId');
end;

{ TFhirTestScriptVariable }

Procedure TFhirTestScriptVariable.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirTestScriptVariable.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirTestScriptVariable.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirTestScriptVariable.SetDefaultValue(value : TFhirString);
begin
  FDefaultValue.free;
  FDefaultValue := value;
end;

Function TFhirTestScriptVariable.GetDefaultValueST : String;
begin
  if FDefaultValue = nil then
    result := ''
  else
    result := FDefaultValue.value;
end;

Procedure TFhirTestScriptVariable.SetDefaultValueST(value : String);
begin
  if value <> '' then
  begin
    if FDefaultValue = nil then
      FDefaultValue := TFhirString.create;
    FDefaultValue.value := value
  end
  else if FDefaultValue <> nil then
    FDefaultValue.value := '';
end;

Procedure TFhirTestScriptVariable.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirTestScriptVariable.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirTestScriptVariable.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirTestScriptVariable.SetExpression(value : TFhirString);
begin
  FExpression.free;
  FExpression := value;
end;

Function TFhirTestScriptVariable.GetExpressionST : String;
begin
  if FExpression = nil then
    result := ''
  else
    result := FExpression.value;
end;

Procedure TFhirTestScriptVariable.SetExpressionST(value : String);
begin
  if value <> '' then
  begin
    if FExpression = nil then
      FExpression := TFhirString.create;
    FExpression.value := value
  end
  else if FExpression <> nil then
    FExpression.value := '';
end;

Procedure TFhirTestScriptVariable.SetHeaderField(value : TFhirString);
begin
  FHeaderField.free;
  FHeaderField := value;
end;

Function TFhirTestScriptVariable.GetHeaderFieldST : String;
begin
  if FHeaderField = nil then
    result := ''
  else
    result := FHeaderField.value;
end;

Procedure TFhirTestScriptVariable.SetHeaderFieldST(value : String);
begin
  if value <> '' then
  begin
    if FHeaderField = nil then
      FHeaderField := TFhirString.create;
    FHeaderField.value := value
  end
  else if FHeaderField <> nil then
    FHeaderField.value := '';
end;

Procedure TFhirTestScriptVariable.SetHint(value : TFhirString);
begin
  FHint.free;
  FHint := value;
end;

Function TFhirTestScriptVariable.GetHintST : String;
begin
  if FHint = nil then
    result := ''
  else
    result := FHint.value;
end;

Procedure TFhirTestScriptVariable.SetHintST(value : String);
begin
  if value <> '' then
  begin
    if FHint = nil then
      FHint := TFhirString.create;
    FHint.value := value
  end
  else if FHint <> nil then
    FHint.value := '';
end;

Procedure TFhirTestScriptVariable.SetPath(value : TFhirString);
begin
  FPath.free;
  FPath := value;
end;

Function TFhirTestScriptVariable.GetPathST : String;
begin
  if FPath = nil then
    result := ''
  else
    result := FPath.value;
end;

Procedure TFhirTestScriptVariable.SetPathST(value : String);
begin
  if value <> '' then
  begin
    if FPath = nil then
      FPath := TFhirString.create;
    FPath.value := value
  end
  else if FPath <> nil then
    FPath.value := '';
end;

Procedure TFhirTestScriptVariable.SetSourceId(value : TFhirId);
begin
  FSourceId.free;
  FSourceId := value;
end;

Function TFhirTestScriptVariable.GetSourceIdST : String;
begin
  if FSourceId = nil then
    result := ''
  else
    result := FSourceId.value;
end;

Procedure TFhirTestScriptVariable.SetSourceIdST(value : String);
begin
  if value <> '' then
  begin
    if FSourceId = nil then
      FSourceId := TFhirId.create;
    FSourceId.value := value
  end
  else if FSourceId <> nil then
    FSourceId.value := '';
end;

function TFhirTestScriptVariable.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FDefaultValue.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FExpression.sizeInBytes);
  inc(result, FHeaderField.sizeInBytes);
  inc(result, FHint.sizeInBytes);
  inc(result, FPath.sizeInBytes);
  inc(result, FSourceId.sizeInBytes);
end;

{ TFhirTestScriptVariableListEnumerator }

Constructor TFhirTestScriptVariableListEnumerator.Create(list : TFhirTestScriptVariableList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptVariableListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptVariableListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptVariableListEnumerator.GetCurrent : TFhirTestScriptVariable;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptVariableListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptVariableList }
procedure TFhirTestScriptVariableList.AddItem(value: TFhirTestScriptVariable);
begin
  assert(value.ClassName = 'TFhirTestScriptVariable', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptVariable');
  add(value);
end;

function TFhirTestScriptVariableList.Append: TFhirTestScriptVariable;
begin
  result := TFhirTestScriptVariable.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptVariableList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptVariableList.GetEnumerator : TFhirTestScriptVariableListEnumerator;
begin
  result := TFhirTestScriptVariableListEnumerator.Create(self.link);
end;

function TFhirTestScriptVariableList.Clone: TFhirTestScriptVariableList;
begin
  result := TFhirTestScriptVariableList(inherited Clone);
end;

function TFhirTestScriptVariableList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptVariableList.GetItemN(index: Integer): TFhirTestScriptVariable;
begin
  result := TFhirTestScriptVariable(ObjectByIndex[index]);
end;

function TFhirTestScriptVariableList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptVariable;
end;
function TFhirTestScriptVariableList.IndexOf(value: TFhirTestScriptVariable): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptVariableList.Insert(index: Integer): TFhirTestScriptVariable;
begin
  result := TFhirTestScriptVariable.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptVariableList.InsertItem(index: Integer; value: TFhirTestScriptVariable);
begin
  assert(value is TFhirTestScriptVariable);
  Inherited Insert(index, value);
end;

function TFhirTestScriptVariableList.Item(index: Integer): TFhirTestScriptVariable;
begin
  result := TFhirTestScriptVariable(ObjectByIndex[index]);
end;

function TFhirTestScriptVariableList.Link: TFhirTestScriptVariableList;
begin
  result := TFhirTestScriptVariableList(inherited Link);
end;

procedure TFhirTestScriptVariableList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptVariableList.SetItemByIndex(index: Integer; value: TFhirTestScriptVariable);
begin
  assert(value is TFhirTestScriptVariable);
  FhirTestScriptVariables[index] := value;
end;

procedure TFhirTestScriptVariableList.SetItemN(index: Integer; value: TFhirTestScriptVariable);
begin
  assert(value is TFhirTestScriptVariable);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptRule }

constructor TFhirTestScriptRule.Create;
begin
  inherited;
end;

destructor TFhirTestScriptRule.Destroy;
begin
  FResource.free;
  FParamList.Free;
  inherited;
end;

procedure TFhirTestScriptRule.Assign(oSource : TFslObject);
begin
  inherited;
  resource := TFhirTestScriptRule(oSource).resource.Clone;
  if (TFhirTestScriptRule(oSource).FParamList = nil) then
  begin
    FParamList.free;
    FParamList := nil;
  end
  else
  begin
    if FParamList = nil then
      FParamList := TFhirTestScriptRuleParamList.Create;
    FParamList.Assign(TFhirTestScriptRule(oSource).FParamList);
  end;
end;

procedure TFhirTestScriptRule.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'resource') Then
     list.add(self.link, 'resource', FResource.Link);
  if (child_name = 'param') Then
    list.addAll(self, 'param', FParamList);
end;

procedure TFhirTestScriptRule.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'resource', 'Reference(Any)', false, TFhirReference{TFhirReference}, FResource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'param', '', true, TFhirTestScriptRuleParam, FParamList.Link)){3};
end;

function TFhirTestScriptRule.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'resource') then
  begin
    Resource := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'param') then
  begin
    ParamList.add(propValue as TFhirTestScriptRuleParam){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptRule.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'param') then ParamList.insertItem(index, propValue as TFhirTestScriptRuleParam){2a}
  else inherited;
end;

function TFhirTestScriptRule.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'resource') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'param') then result := ParamList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptRule.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'resource') then result := 'Reference'
  else if (propName = 'param') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptRule.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'resource') then ResourceElement := nil
  else if (propName = 'param') then deletePropertyValue('param', ParamList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptRule.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'resource') then ResourceElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'param') then replacePropertyValue('param', ParamList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptRule.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'param') then ParamList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptRule.fhirType : string;
begin
  result := 'rule';
end;

function TFhirTestScriptRule.Link : TFhirTestScriptRule;
begin
  result := TFhirTestScriptRule(inherited Link);
end;

function TFhirTestScriptRule.Clone : TFhirTestScriptRule;
begin
  result := TFhirTestScriptRule(inherited Clone);
end;

function TFhirTestScriptRule.equals(other : TObject) : boolean;
var
  o : TFhirTestScriptRule;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptRule)) then
    result := false
  else
  begin
    o := TFhirTestScriptRule(other);
    result := compareDeep(resourceElement, o.resourceElement, true) and compareDeep(paramList, o.paramList, true);
  end;
end;

function TFhirTestScriptRule.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FResource) and isEmptyProp(FparamList);
end;

procedure TFhirTestScriptRule.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('resource');
  fields.add('param');
end;

{ TFhirTestScriptRule }

Procedure TFhirTestScriptRule.SetResource(value : TFhirReference{TFhirReference});
begin
  FResource.free;
  FResource := value;
end;

Function TFhirTestScriptRule.GetParamList : TFhirTestScriptRuleParamList;
begin
  if FParamList = nil then
    FParamList := TFhirTestScriptRuleParamList.Create;
  result := FParamList;
end;

Function TFhirTestScriptRule.GetHasParamList : boolean;
begin
  result := (FParamList <> nil) and (FParamList.count > 0);
end;

function TFhirTestScriptRule.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FResource.sizeInBytes);
  inc(result, FparamList.sizeInBytes);
end;

{ TFhirTestScriptRuleListEnumerator }

Constructor TFhirTestScriptRuleListEnumerator.Create(list : TFhirTestScriptRuleList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptRuleListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptRuleListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptRuleListEnumerator.GetCurrent : TFhirTestScriptRule;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptRuleListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptRuleList }
procedure TFhirTestScriptRuleList.AddItem(value: TFhirTestScriptRule);
begin
  assert(value.ClassName = 'TFhirTestScriptRule', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptRule');
  add(value);
end;

function TFhirTestScriptRuleList.Append: TFhirTestScriptRule;
begin
  result := TFhirTestScriptRule.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptRuleList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptRuleList.GetEnumerator : TFhirTestScriptRuleListEnumerator;
begin
  result := TFhirTestScriptRuleListEnumerator.Create(self.link);
end;

function TFhirTestScriptRuleList.Clone: TFhirTestScriptRuleList;
begin
  result := TFhirTestScriptRuleList(inherited Clone);
end;

function TFhirTestScriptRuleList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptRuleList.GetItemN(index: Integer): TFhirTestScriptRule;
begin
  result := TFhirTestScriptRule(ObjectByIndex[index]);
end;

function TFhirTestScriptRuleList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptRule;
end;
function TFhirTestScriptRuleList.IndexOf(value: TFhirTestScriptRule): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptRuleList.Insert(index: Integer): TFhirTestScriptRule;
begin
  result := TFhirTestScriptRule.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptRuleList.InsertItem(index: Integer; value: TFhirTestScriptRule);
begin
  assert(value is TFhirTestScriptRule);
  Inherited Insert(index, value);
end;

function TFhirTestScriptRuleList.Item(index: Integer): TFhirTestScriptRule;
begin
  result := TFhirTestScriptRule(ObjectByIndex[index]);
end;

function TFhirTestScriptRuleList.Link: TFhirTestScriptRuleList;
begin
  result := TFhirTestScriptRuleList(inherited Link);
end;

procedure TFhirTestScriptRuleList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptRuleList.SetItemByIndex(index: Integer; value: TFhirTestScriptRule);
begin
  assert(value is TFhirTestScriptRule);
  FhirTestScriptRules[index] := value;
end;

procedure TFhirTestScriptRuleList.SetItemN(index: Integer; value: TFhirTestScriptRule);
begin
  assert(value is TFhirTestScriptRule);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptRuleParam }

constructor TFhirTestScriptRuleParam.Create;
begin
  inherited;
end;

destructor TFhirTestScriptRuleParam.Destroy;
begin
  FName.free;
  FValue.free;
  inherited;
end;

procedure TFhirTestScriptRuleParam.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirTestScriptRuleParam(oSource).nameElement.Clone;
  valueElement := TFhirTestScriptRuleParam(oSource).valueElement.Clone;
end;

procedure TFhirTestScriptRuleParam.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirTestScriptRuleParam.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value', 'string', false, TFhirString, FValue.Link));{2}
end;

function TFhirTestScriptRuleParam.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptRuleParam.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestScriptRuleParam.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'value') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptRuleParam.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'value') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptRuleParam.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptRuleParam.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'value') then ValueElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptRuleParam.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptRuleParam.fhirType : string;
begin
  result := 'param';
end;

function TFhirTestScriptRuleParam.Link : TFhirTestScriptRuleParam;
begin
  result := TFhirTestScriptRuleParam(inherited Link);
end;

function TFhirTestScriptRuleParam.Clone : TFhirTestScriptRuleParam;
begin
  result := TFhirTestScriptRuleParam(inherited Clone);
end;

function TFhirTestScriptRuleParam.equals(other : TObject) : boolean;
var
  o : TFhirTestScriptRuleParam;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptRuleParam)) then
    result := false
  else
  begin
    o := TFhirTestScriptRuleParam(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirTestScriptRuleParam.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FValue);
end;

procedure TFhirTestScriptRuleParam.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('value');
end;

{ TFhirTestScriptRuleParam }

Procedure TFhirTestScriptRuleParam.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirTestScriptRuleParam.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirTestScriptRuleParam.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirTestScriptRuleParam.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirTestScriptRuleParam.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

Procedure TFhirTestScriptRuleParam.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

function TFhirTestScriptRuleParam.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirTestScriptRuleParamListEnumerator }

Constructor TFhirTestScriptRuleParamListEnumerator.Create(list : TFhirTestScriptRuleParamList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptRuleParamListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptRuleParamListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptRuleParamListEnumerator.GetCurrent : TFhirTestScriptRuleParam;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptRuleParamListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptRuleParamList }
procedure TFhirTestScriptRuleParamList.AddItem(value: TFhirTestScriptRuleParam);
begin
  assert(value.ClassName = 'TFhirTestScriptRuleParam', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptRuleParam');
  add(value);
end;

function TFhirTestScriptRuleParamList.Append: TFhirTestScriptRuleParam;
begin
  result := TFhirTestScriptRuleParam.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptRuleParamList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptRuleParamList.GetEnumerator : TFhirTestScriptRuleParamListEnumerator;
begin
  result := TFhirTestScriptRuleParamListEnumerator.Create(self.link);
end;

function TFhirTestScriptRuleParamList.Clone: TFhirTestScriptRuleParamList;
begin
  result := TFhirTestScriptRuleParamList(inherited Clone);
end;

function TFhirTestScriptRuleParamList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptRuleParamList.GetItemN(index: Integer): TFhirTestScriptRuleParam;
begin
  result := TFhirTestScriptRuleParam(ObjectByIndex[index]);
end;

function TFhirTestScriptRuleParamList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptRuleParam;
end;
function TFhirTestScriptRuleParamList.IndexOf(value: TFhirTestScriptRuleParam): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptRuleParamList.Insert(index: Integer): TFhirTestScriptRuleParam;
begin
  result := TFhirTestScriptRuleParam.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptRuleParamList.InsertItem(index: Integer; value: TFhirTestScriptRuleParam);
begin
  assert(value is TFhirTestScriptRuleParam);
  Inherited Insert(index, value);
end;

function TFhirTestScriptRuleParamList.Item(index: Integer): TFhirTestScriptRuleParam;
begin
  result := TFhirTestScriptRuleParam(ObjectByIndex[index]);
end;

function TFhirTestScriptRuleParamList.Link: TFhirTestScriptRuleParamList;
begin
  result := TFhirTestScriptRuleParamList(inherited Link);
end;

procedure TFhirTestScriptRuleParamList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptRuleParamList.SetItemByIndex(index: Integer; value: TFhirTestScriptRuleParam);
begin
  assert(value is TFhirTestScriptRuleParam);
  FhirTestScriptRuleParams[index] := value;
end;

procedure TFhirTestScriptRuleParamList.SetItemN(index: Integer; value: TFhirTestScriptRuleParam);
begin
  assert(value is TFhirTestScriptRuleParam);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptRuleset }

constructor TFhirTestScriptRuleset.Create;
begin
  inherited;
end;

destructor TFhirTestScriptRuleset.Destroy;
begin
  FResource.free;
  FRuleList.Free;
  inherited;
end;

procedure TFhirTestScriptRuleset.Assign(oSource : TFslObject);
begin
  inherited;
  resource := TFhirTestScriptRuleset(oSource).resource.Clone;
  if (TFhirTestScriptRuleset(oSource).FRuleList = nil) then
  begin
    FRuleList.free;
    FRuleList := nil;
  end
  else
  begin
    if FRuleList = nil then
      FRuleList := TFhirTestScriptRulesetRuleList.Create;
    FRuleList.Assign(TFhirTestScriptRuleset(oSource).FRuleList);
  end;
end;

procedure TFhirTestScriptRuleset.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'resource') Then
     list.add(self.link, 'resource', FResource.Link);
  if (child_name = 'rule') Then
    list.addAll(self, 'rule', FRuleList);
end;

procedure TFhirTestScriptRuleset.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'resource', 'Reference(Any)', false, TFhirReference{TFhirReference}, FResource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'rule', '', true, TFhirTestScriptRulesetRule, FRuleList.Link)){3};
end;

function TFhirTestScriptRuleset.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'resource') then
  begin
    Resource := propValue as TFhirReference{TFhirReference}{4b};
    result := propValue;
  end
  else if (propName = 'rule') then
  begin
    RuleList.add(propValue as TFhirTestScriptRulesetRule){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptRuleset.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'rule') then RuleList.insertItem(index, propValue as TFhirTestScriptRulesetRule){2a}
  else inherited;
end;

function TFhirTestScriptRuleset.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'resource') then result := TFhirReference{TFhirReference}.create(){4b}
  else if (propName = 'rule') then result := RuleList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptRuleset.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'resource') then result := 'Reference'
  else if (propName = 'rule') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptRuleset.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'resource') then ResourceElement := nil
  else if (propName = 'rule') then deletePropertyValue('rule', RuleList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptRuleset.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'resource') then ResourceElement := new as TFhirReference{TFhirReference}{4}
  else if (propName = 'rule') then replacePropertyValue('rule', RuleList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptRuleset.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'rule') then RuleList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptRuleset.fhirType : string;
begin
  result := 'ruleset';
end;

function TFhirTestScriptRuleset.Link : TFhirTestScriptRuleset;
begin
  result := TFhirTestScriptRuleset(inherited Link);
end;

function TFhirTestScriptRuleset.Clone : TFhirTestScriptRuleset;
begin
  result := TFhirTestScriptRuleset(inherited Clone);
end;

function TFhirTestScriptRuleset.equals(other : TObject) : boolean;
var
  o : TFhirTestScriptRuleset;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptRuleset)) then
    result := false
  else
  begin
    o := TFhirTestScriptRuleset(other);
    result := compareDeep(resourceElement, o.resourceElement, true) and compareDeep(ruleList, o.ruleList, true);
  end;
end;

function TFhirTestScriptRuleset.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FResource) and isEmptyProp(FruleList);
end;

procedure TFhirTestScriptRuleset.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('resource');
  fields.add('rule');
end;

{ TFhirTestScriptRuleset }

Procedure TFhirTestScriptRuleset.SetResource(value : TFhirReference{TFhirReference});
begin
  FResource.free;
  FResource := value;
end;

Function TFhirTestScriptRuleset.GetRuleList : TFhirTestScriptRulesetRuleList;
begin
  if FRuleList = nil then
    FRuleList := TFhirTestScriptRulesetRuleList.Create;
  result := FRuleList;
end;

Function TFhirTestScriptRuleset.GetHasRuleList : boolean;
begin
  result := (FRuleList <> nil) and (FRuleList.count > 0);
end;

function TFhirTestScriptRuleset.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FResource.sizeInBytes);
  inc(result, FruleList.sizeInBytes);
end;

{ TFhirTestScriptRulesetListEnumerator }

Constructor TFhirTestScriptRulesetListEnumerator.Create(list : TFhirTestScriptRulesetList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptRulesetListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptRulesetListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptRulesetListEnumerator.GetCurrent : TFhirTestScriptRuleset;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptRulesetListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptRulesetList }
procedure TFhirTestScriptRulesetList.AddItem(value: TFhirTestScriptRuleset);
begin
  assert(value.ClassName = 'TFhirTestScriptRuleset', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptRuleset');
  add(value);
end;

function TFhirTestScriptRulesetList.Append: TFhirTestScriptRuleset;
begin
  result := TFhirTestScriptRuleset.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptRulesetList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptRulesetList.GetEnumerator : TFhirTestScriptRulesetListEnumerator;
begin
  result := TFhirTestScriptRulesetListEnumerator.Create(self.link);
end;

function TFhirTestScriptRulesetList.Clone: TFhirTestScriptRulesetList;
begin
  result := TFhirTestScriptRulesetList(inherited Clone);
end;

function TFhirTestScriptRulesetList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptRulesetList.GetItemN(index: Integer): TFhirTestScriptRuleset;
begin
  result := TFhirTestScriptRuleset(ObjectByIndex[index]);
end;

function TFhirTestScriptRulesetList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptRuleset;
end;
function TFhirTestScriptRulesetList.IndexOf(value: TFhirTestScriptRuleset): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptRulesetList.Insert(index: Integer): TFhirTestScriptRuleset;
begin
  result := TFhirTestScriptRuleset.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptRulesetList.InsertItem(index: Integer; value: TFhirTestScriptRuleset);
begin
  assert(value is TFhirTestScriptRuleset);
  Inherited Insert(index, value);
end;

function TFhirTestScriptRulesetList.Item(index: Integer): TFhirTestScriptRuleset;
begin
  result := TFhirTestScriptRuleset(ObjectByIndex[index]);
end;

function TFhirTestScriptRulesetList.Link: TFhirTestScriptRulesetList;
begin
  result := TFhirTestScriptRulesetList(inherited Link);
end;

procedure TFhirTestScriptRulesetList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptRulesetList.SetItemByIndex(index: Integer; value: TFhirTestScriptRuleset);
begin
  assert(value is TFhirTestScriptRuleset);
  FhirTestScriptRulesets[index] := value;
end;

procedure TFhirTestScriptRulesetList.SetItemN(index: Integer; value: TFhirTestScriptRuleset);
begin
  assert(value is TFhirTestScriptRuleset);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptRulesetRule }

constructor TFhirTestScriptRulesetRule.Create;
begin
  inherited;
end;

destructor TFhirTestScriptRulesetRule.Destroy;
begin
  FRuleId.free;
  FParamList.Free;
  inherited;
end;

procedure TFhirTestScriptRulesetRule.Assign(oSource : TFslObject);
begin
  inherited;
  ruleIdElement := TFhirTestScriptRulesetRule(oSource).ruleIdElement.Clone;
  if (TFhirTestScriptRulesetRule(oSource).FParamList = nil) then
  begin
    FParamList.free;
    FParamList := nil;
  end
  else
  begin
    if FParamList = nil then
      FParamList := TFhirTestScriptRulesetRuleParamList.Create;
    FParamList.Assign(TFhirTestScriptRulesetRule(oSource).FParamList);
  end;
end;

procedure TFhirTestScriptRulesetRule.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'ruleId') Then
     list.add(self.link, 'ruleId', FRuleId.Link);
  if (child_name = 'param') Then
    list.addAll(self, 'param', FParamList);
end;

procedure TFhirTestScriptRulesetRule.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'ruleId', 'id', false, TFhirId, FRuleId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'param', '', true, TFhirTestScriptRulesetRuleParam, FParamList.Link)){3};
end;

function TFhirTestScriptRulesetRule.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'ruleId') then
  begin
    RuleIdElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'param') then
  begin
    ParamList.add(propValue as TFhirTestScriptRulesetRuleParam){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptRulesetRule.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'param') then ParamList.insertItem(index, propValue as TFhirTestScriptRulesetRuleParam){2a}
  else inherited;
end;

function TFhirTestScriptRulesetRule.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'ruleId') then result := TFhirId.create() {5b}
  else if (propName = 'param') then result := ParamList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptRulesetRule.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'ruleId') then result := 'id'
  else if (propName = 'param') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptRulesetRule.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'ruleId') then RuleIdElement := nil
  else if (propName = 'param') then deletePropertyValue('param', ParamList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptRulesetRule.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'ruleId') then RuleIdElement := asId(new){5b}
  else if (propName = 'param') then replacePropertyValue('param', ParamList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptRulesetRule.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'param') then ParamList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptRulesetRule.fhirType : string;
begin
  result := 'rule';
end;

function TFhirTestScriptRulesetRule.Link : TFhirTestScriptRulesetRule;
begin
  result := TFhirTestScriptRulesetRule(inherited Link);
end;

function TFhirTestScriptRulesetRule.Clone : TFhirTestScriptRulesetRule;
begin
  result := TFhirTestScriptRulesetRule(inherited Clone);
end;

function TFhirTestScriptRulesetRule.equals(other : TObject) : boolean;
var
  o : TFhirTestScriptRulesetRule;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptRulesetRule)) then
    result := false
  else
  begin
    o := TFhirTestScriptRulesetRule(other);
    result := compareDeep(ruleIdElement, o.ruleIdElement, true) and compareDeep(paramList, o.paramList, true);
  end;
end;

function TFhirTestScriptRulesetRule.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRuleId) and isEmptyProp(FparamList);
end;

procedure TFhirTestScriptRulesetRule.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('ruleId');
  fields.add('param');
end;

{ TFhirTestScriptRulesetRule }

Procedure TFhirTestScriptRulesetRule.SetRuleId(value : TFhirId);
begin
  FRuleId.free;
  FRuleId := value;
end;

Function TFhirTestScriptRulesetRule.GetRuleIdST : String;
begin
  if FRuleId = nil then
    result := ''
  else
    result := FRuleId.value;
end;

Procedure TFhirTestScriptRulesetRule.SetRuleIdST(value : String);
begin
  if value <> '' then
  begin
    if FRuleId = nil then
      FRuleId := TFhirId.create;
    FRuleId.value := value
  end
  else if FRuleId <> nil then
    FRuleId.value := '';
end;

Function TFhirTestScriptRulesetRule.GetParamList : TFhirTestScriptRulesetRuleParamList;
begin
  if FParamList = nil then
    FParamList := TFhirTestScriptRulesetRuleParamList.Create;
  result := FParamList;
end;

Function TFhirTestScriptRulesetRule.GetHasParamList : boolean;
begin
  result := (FParamList <> nil) and (FParamList.count > 0);
end;

function TFhirTestScriptRulesetRule.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FRuleId.sizeInBytes);
  inc(result, FparamList.sizeInBytes);
end;

{ TFhirTestScriptRulesetRuleListEnumerator }

Constructor TFhirTestScriptRulesetRuleListEnumerator.Create(list : TFhirTestScriptRulesetRuleList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptRulesetRuleListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptRulesetRuleListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptRulesetRuleListEnumerator.GetCurrent : TFhirTestScriptRulesetRule;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptRulesetRuleListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptRulesetRuleList }
procedure TFhirTestScriptRulesetRuleList.AddItem(value: TFhirTestScriptRulesetRule);
begin
  assert(value.ClassName = 'TFhirTestScriptRulesetRule', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptRulesetRule');
  add(value);
end;

function TFhirTestScriptRulesetRuleList.Append: TFhirTestScriptRulesetRule;
begin
  result := TFhirTestScriptRulesetRule.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptRulesetRuleList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptRulesetRuleList.GetEnumerator : TFhirTestScriptRulesetRuleListEnumerator;
begin
  result := TFhirTestScriptRulesetRuleListEnumerator.Create(self.link);
end;

function TFhirTestScriptRulesetRuleList.Clone: TFhirTestScriptRulesetRuleList;
begin
  result := TFhirTestScriptRulesetRuleList(inherited Clone);
end;

function TFhirTestScriptRulesetRuleList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptRulesetRuleList.GetItemN(index: Integer): TFhirTestScriptRulesetRule;
begin
  result := TFhirTestScriptRulesetRule(ObjectByIndex[index]);
end;

function TFhirTestScriptRulesetRuleList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptRulesetRule;
end;
function TFhirTestScriptRulesetRuleList.IndexOf(value: TFhirTestScriptRulesetRule): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptRulesetRuleList.Insert(index: Integer): TFhirTestScriptRulesetRule;
begin
  result := TFhirTestScriptRulesetRule.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptRulesetRuleList.InsertItem(index: Integer; value: TFhirTestScriptRulesetRule);
begin
  assert(value is TFhirTestScriptRulesetRule);
  Inherited Insert(index, value);
end;

function TFhirTestScriptRulesetRuleList.Item(index: Integer): TFhirTestScriptRulesetRule;
begin
  result := TFhirTestScriptRulesetRule(ObjectByIndex[index]);
end;

function TFhirTestScriptRulesetRuleList.Link: TFhirTestScriptRulesetRuleList;
begin
  result := TFhirTestScriptRulesetRuleList(inherited Link);
end;

procedure TFhirTestScriptRulesetRuleList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptRulesetRuleList.SetItemByIndex(index: Integer; value: TFhirTestScriptRulesetRule);
begin
  assert(value is TFhirTestScriptRulesetRule);
  FhirTestScriptRulesetRules[index] := value;
end;

procedure TFhirTestScriptRulesetRuleList.SetItemN(index: Integer; value: TFhirTestScriptRulesetRule);
begin
  assert(value is TFhirTestScriptRulesetRule);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptRulesetRuleParam }

constructor TFhirTestScriptRulesetRuleParam.Create;
begin
  inherited;
end;

destructor TFhirTestScriptRulesetRuleParam.Destroy;
begin
  FName.free;
  FValue.free;
  inherited;
end;

procedure TFhirTestScriptRulesetRuleParam.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirTestScriptRulesetRuleParam(oSource).nameElement.Clone;
  valueElement := TFhirTestScriptRulesetRuleParam(oSource).valueElement.Clone;
end;

procedure TFhirTestScriptRulesetRuleParam.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirTestScriptRulesetRuleParam.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value', 'string', false, TFhirString, FValue.Link));{2}
end;

function TFhirTestScriptRulesetRuleParam.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptRulesetRuleParam.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestScriptRulesetRuleParam.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'value') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptRulesetRuleParam.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'value') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptRulesetRuleParam.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptRulesetRuleParam.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'value') then ValueElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptRulesetRuleParam.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptRulesetRuleParam.fhirType : string;
begin
  result := 'param';
end;

function TFhirTestScriptRulesetRuleParam.Link : TFhirTestScriptRulesetRuleParam;
begin
  result := TFhirTestScriptRulesetRuleParam(inherited Link);
end;

function TFhirTestScriptRulesetRuleParam.Clone : TFhirTestScriptRulesetRuleParam;
begin
  result := TFhirTestScriptRulesetRuleParam(inherited Clone);
end;

function TFhirTestScriptRulesetRuleParam.equals(other : TObject) : boolean;
var
  o : TFhirTestScriptRulesetRuleParam;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptRulesetRuleParam)) then
    result := false
  else
  begin
    o := TFhirTestScriptRulesetRuleParam(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirTestScriptRulesetRuleParam.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FValue);
end;

procedure TFhirTestScriptRulesetRuleParam.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('value');
end;

{ TFhirTestScriptRulesetRuleParam }

Procedure TFhirTestScriptRulesetRuleParam.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirTestScriptRulesetRuleParam.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirTestScriptRulesetRuleParam.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirTestScriptRulesetRuleParam.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirTestScriptRulesetRuleParam.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

Procedure TFhirTestScriptRulesetRuleParam.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

function TFhirTestScriptRulesetRuleParam.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirTestScriptRulesetRuleParamListEnumerator }

Constructor TFhirTestScriptRulesetRuleParamListEnumerator.Create(list : TFhirTestScriptRulesetRuleParamList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptRulesetRuleParamListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptRulesetRuleParamListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptRulesetRuleParamListEnumerator.GetCurrent : TFhirTestScriptRulesetRuleParam;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptRulesetRuleParamListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptRulesetRuleParamList }
procedure TFhirTestScriptRulesetRuleParamList.AddItem(value: TFhirTestScriptRulesetRuleParam);
begin
  assert(value.ClassName = 'TFhirTestScriptRulesetRuleParam', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptRulesetRuleParam');
  add(value);
end;

function TFhirTestScriptRulesetRuleParamList.Append: TFhirTestScriptRulesetRuleParam;
begin
  result := TFhirTestScriptRulesetRuleParam.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptRulesetRuleParamList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptRulesetRuleParamList.GetEnumerator : TFhirTestScriptRulesetRuleParamListEnumerator;
begin
  result := TFhirTestScriptRulesetRuleParamListEnumerator.Create(self.link);
end;

function TFhirTestScriptRulesetRuleParamList.Clone: TFhirTestScriptRulesetRuleParamList;
begin
  result := TFhirTestScriptRulesetRuleParamList(inherited Clone);
end;

function TFhirTestScriptRulesetRuleParamList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptRulesetRuleParamList.GetItemN(index: Integer): TFhirTestScriptRulesetRuleParam;
begin
  result := TFhirTestScriptRulesetRuleParam(ObjectByIndex[index]);
end;

function TFhirTestScriptRulesetRuleParamList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptRulesetRuleParam;
end;
function TFhirTestScriptRulesetRuleParamList.IndexOf(value: TFhirTestScriptRulesetRuleParam): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptRulesetRuleParamList.Insert(index: Integer): TFhirTestScriptRulesetRuleParam;
begin
  result := TFhirTestScriptRulesetRuleParam.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptRulesetRuleParamList.InsertItem(index: Integer; value: TFhirTestScriptRulesetRuleParam);
begin
  assert(value is TFhirTestScriptRulesetRuleParam);
  Inherited Insert(index, value);
end;

function TFhirTestScriptRulesetRuleParamList.Item(index: Integer): TFhirTestScriptRulesetRuleParam;
begin
  result := TFhirTestScriptRulesetRuleParam(ObjectByIndex[index]);
end;

function TFhirTestScriptRulesetRuleParamList.Link: TFhirTestScriptRulesetRuleParamList;
begin
  result := TFhirTestScriptRulesetRuleParamList(inherited Link);
end;

procedure TFhirTestScriptRulesetRuleParamList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptRulesetRuleParamList.SetItemByIndex(index: Integer; value: TFhirTestScriptRulesetRuleParam);
begin
  assert(value is TFhirTestScriptRulesetRuleParam);
  FhirTestScriptRulesetRuleParams[index] := value;
end;

procedure TFhirTestScriptRulesetRuleParamList.SetItemN(index: Integer; value: TFhirTestScriptRulesetRuleParam);
begin
  assert(value is TFhirTestScriptRulesetRuleParam);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptSetup }

constructor TFhirTestScriptSetup.Create;
begin
  inherited;
end;

destructor TFhirTestScriptSetup.Destroy;
begin
  FActionList.Free;
  inherited;
end;

procedure TFhirTestScriptSetup.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirTestScriptSetup(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirTestScriptSetupActionList.Create;
    FActionList.Assign(TFhirTestScriptSetup(oSource).FActionList);
  end;
end;

procedure TFhirTestScriptSetup.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
end;

procedure TFhirTestScriptSetup.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'action', '', true, TFhirTestScriptSetupAction, FActionList.Link)){3};
end;

function TFhirTestScriptSetup.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirTestScriptSetupAction){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptSetup.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirTestScriptSetupAction){2a}
  else inherited;
end;

function TFhirTestScriptSetup.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'action') then result := ActionList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptSetup.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'action') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptSetup.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'action') then deletePropertyValue('action', ActionList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptSetup.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptSetup.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'action') then ActionList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptSetup.fhirType : string;
begin
  result := 'setup';
end;

function TFhirTestScriptSetup.Link : TFhirTestScriptSetup;
begin
  result := TFhirTestScriptSetup(inherited Link);
end;

function TFhirTestScriptSetup.Clone : TFhirTestScriptSetup;
begin
  result := TFhirTestScriptSetup(inherited Clone);
end;

function TFhirTestScriptSetup.equals(other : TObject) : boolean;
var
  o : TFhirTestScriptSetup;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptSetup)) then
    result := false
  else
  begin
    o := TFhirTestScriptSetup(other);
    result := compareDeep(actionList, o.actionList, true);
  end;
end;

function TFhirTestScriptSetup.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FactionList);
end;

procedure TFhirTestScriptSetup.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('action');
end;

{ TFhirTestScriptSetup }

Function TFhirTestScriptSetup.GetActionList : TFhirTestScriptSetupActionList;
begin
  if FActionList = nil then
    FActionList := TFhirTestScriptSetupActionList.Create;
  result := FActionList;
end;

Function TFhirTestScriptSetup.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

function TFhirTestScriptSetup.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FactionList.sizeInBytes);
end;

{ TFhirTestScriptSetupListEnumerator }

Constructor TFhirTestScriptSetupListEnumerator.Create(list : TFhirTestScriptSetupList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptSetupListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptSetupListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptSetupListEnumerator.GetCurrent : TFhirTestScriptSetup;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptSetupListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptSetupList }
procedure TFhirTestScriptSetupList.AddItem(value: TFhirTestScriptSetup);
begin
  assert(value.ClassName = 'TFhirTestScriptSetup', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptSetup');
  add(value);
end;

function TFhirTestScriptSetupList.Append: TFhirTestScriptSetup;
begin
  result := TFhirTestScriptSetup.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptSetupList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptSetupList.GetEnumerator : TFhirTestScriptSetupListEnumerator;
begin
  result := TFhirTestScriptSetupListEnumerator.Create(self.link);
end;

function TFhirTestScriptSetupList.Clone: TFhirTestScriptSetupList;
begin
  result := TFhirTestScriptSetupList(inherited Clone);
end;

function TFhirTestScriptSetupList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptSetupList.GetItemN(index: Integer): TFhirTestScriptSetup;
begin
  result := TFhirTestScriptSetup(ObjectByIndex[index]);
end;

function TFhirTestScriptSetupList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptSetup;
end;
function TFhirTestScriptSetupList.IndexOf(value: TFhirTestScriptSetup): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptSetupList.Insert(index: Integer): TFhirTestScriptSetup;
begin
  result := TFhirTestScriptSetup.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptSetupList.InsertItem(index: Integer; value: TFhirTestScriptSetup);
begin
  assert(value is TFhirTestScriptSetup);
  Inherited Insert(index, value);
end;

function TFhirTestScriptSetupList.Item(index: Integer): TFhirTestScriptSetup;
begin
  result := TFhirTestScriptSetup(ObjectByIndex[index]);
end;

function TFhirTestScriptSetupList.Link: TFhirTestScriptSetupList;
begin
  result := TFhirTestScriptSetupList(inherited Link);
end;

procedure TFhirTestScriptSetupList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptSetupList.SetItemByIndex(index: Integer; value: TFhirTestScriptSetup);
begin
  assert(value is TFhirTestScriptSetup);
  FhirTestScriptSetups[index] := value;
end;

procedure TFhirTestScriptSetupList.SetItemN(index: Integer; value: TFhirTestScriptSetup);
begin
  assert(value is TFhirTestScriptSetup);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptSetupAction }

constructor TFhirTestScriptSetupAction.Create;
begin
  inherited;
end;

destructor TFhirTestScriptSetupAction.Destroy;
begin
  FOperation.free;
  FAssert.free;
  inherited;
end;

procedure TFhirTestScriptSetupAction.Assign(oSource : TFslObject);
begin
  inherited;
  operation := TFhirTestScriptSetupAction(oSource).operation.Clone;
  assert := TFhirTestScriptSetupAction(oSource).assert.Clone;
end;

procedure TFhirTestScriptSetupAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'operation') Then
     list.add(self.link, 'operation', FOperation.Link);
  if (child_name = 'assert') Then
     list.add(self.link, 'assert', FAssert.Link);
end;

procedure TFhirTestScriptSetupAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'operation', '', false, TFhirTestScriptSetupActionOperation, FOperation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'assert', '', false, TFhirTestScriptSetupActionAssert, FAssert.Link));{2}
end;

function TFhirTestScriptSetupAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'operation') then
  begin
    Operation := propValue as TFhirTestScriptSetupActionOperation{4b};
    result := propValue;
  end
  else if (propName = 'assert') then
  begin
    Assert := propValue as TFhirTestScriptSetupActionAssert{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptSetupAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestScriptSetupAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'operation') then result := TFhirTestScriptSetupActionOperation.create(){4b}
  else if (propName = 'assert') then result := TFhirTestScriptSetupActionAssert.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptSetupAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'operation') then result := ''
  else if (propName = 'assert') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptSetupAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'operation') then OperationElement := nil
  else if (propName = 'assert') then AssertElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptSetupAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'operation') then OperationElement := new as TFhirTestScriptSetupActionOperation{4}
  else if (propName = 'assert') then AssertElement := new as TFhirTestScriptSetupActionAssert{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptSetupAction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptSetupAction.fhirType : string;
begin
  result := 'action';
end;

function TFhirTestScriptSetupAction.Link : TFhirTestScriptSetupAction;
begin
  result := TFhirTestScriptSetupAction(inherited Link);
end;

function TFhirTestScriptSetupAction.Clone : TFhirTestScriptSetupAction;
begin
  result := TFhirTestScriptSetupAction(inherited Clone);
end;

function TFhirTestScriptSetupAction.equals(other : TObject) : boolean;
var
  o : TFhirTestScriptSetupAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptSetupAction)) then
    result := false
  else
  begin
    o := TFhirTestScriptSetupAction(other);
    result := compareDeep(operationElement, o.operationElement, true) and compareDeep(assertElement, o.assertElement, true);
  end;
end;

function TFhirTestScriptSetupAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FOperation) and isEmptyProp(FAssert);
end;

procedure TFhirTestScriptSetupAction.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('operation');
  fields.add('assert');
end;

{ TFhirTestScriptSetupAction }

Procedure TFhirTestScriptSetupAction.SetOperation(value : TFhirTestScriptSetupActionOperation);
begin
  FOperation.free;
  FOperation := value;
end;

Procedure TFhirTestScriptSetupAction.SetAssert(value : TFhirTestScriptSetupActionAssert);
begin
  FAssert.free;
  FAssert := value;
end;

function TFhirTestScriptSetupAction.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FOperation.sizeInBytes);
  inc(result, FAssert.sizeInBytes);
end;

{ TFhirTestScriptSetupActionListEnumerator }

Constructor TFhirTestScriptSetupActionListEnumerator.Create(list : TFhirTestScriptSetupActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptSetupActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptSetupActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptSetupActionListEnumerator.GetCurrent : TFhirTestScriptSetupAction;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptSetupActionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptSetupActionList }
procedure TFhirTestScriptSetupActionList.AddItem(value: TFhirTestScriptSetupAction);
begin
  assert(value.ClassName = 'TFhirTestScriptSetupAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptSetupAction');
  add(value);
end;

function TFhirTestScriptSetupActionList.Append: TFhirTestScriptSetupAction;
begin
  result := TFhirTestScriptSetupAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptSetupActionList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptSetupActionList.GetEnumerator : TFhirTestScriptSetupActionListEnumerator;
begin
  result := TFhirTestScriptSetupActionListEnumerator.Create(self.link);
end;

function TFhirTestScriptSetupActionList.Clone: TFhirTestScriptSetupActionList;
begin
  result := TFhirTestScriptSetupActionList(inherited Clone);
end;

function TFhirTestScriptSetupActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptSetupActionList.GetItemN(index: Integer): TFhirTestScriptSetupAction;
begin
  result := TFhirTestScriptSetupAction(ObjectByIndex[index]);
end;

function TFhirTestScriptSetupActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptSetupAction;
end;
function TFhirTestScriptSetupActionList.IndexOf(value: TFhirTestScriptSetupAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptSetupActionList.Insert(index: Integer): TFhirTestScriptSetupAction;
begin
  result := TFhirTestScriptSetupAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptSetupActionList.InsertItem(index: Integer; value: TFhirTestScriptSetupAction);
begin
  assert(value is TFhirTestScriptSetupAction);
  Inherited Insert(index, value);
end;

function TFhirTestScriptSetupActionList.Item(index: Integer): TFhirTestScriptSetupAction;
begin
  result := TFhirTestScriptSetupAction(ObjectByIndex[index]);
end;

function TFhirTestScriptSetupActionList.Link: TFhirTestScriptSetupActionList;
begin
  result := TFhirTestScriptSetupActionList(inherited Link);
end;

procedure TFhirTestScriptSetupActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptSetupActionList.SetItemByIndex(index: Integer; value: TFhirTestScriptSetupAction);
begin
  assert(value is TFhirTestScriptSetupAction);
  FhirTestScriptSetupActions[index] := value;
end;

procedure TFhirTestScriptSetupActionList.SetItemN(index: Integer; value: TFhirTestScriptSetupAction);
begin
  assert(value is TFhirTestScriptSetupAction);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptSetupActionOperation }

constructor TFhirTestScriptSetupActionOperation.Create;
begin
  inherited;
end;

destructor TFhirTestScriptSetupActionOperation.Destroy;
begin
  FType_.free;
  FResource.free;
  FLabel_.free;
  FDescription.free;
  FAccept.free;
  FContentType.free;
  FDestination.free;
  FEncodeRequestUrl.free;
  FOrigin.free;
  FParams.free;
  FRequestHeaderList.Free;
  FRequestId.free;
  FResponseId.free;
  FSourceId.free;
  FTargetId.free;
  FUrl.free;
  inherited;
end;

procedure TFhirTestScriptSetupActionOperation.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirTestScriptSetupActionOperation(oSource).type_.Clone;
  resourceElement := TFhirTestScriptSetupActionOperation(oSource).resourceElement.Clone;
  label_Element := TFhirTestScriptSetupActionOperation(oSource).label_Element.Clone;
  descriptionElement := TFhirTestScriptSetupActionOperation(oSource).descriptionElement.Clone;
  FAccept := TFhirTestScriptSetupActionOperation(oSource).FAccept.Link;
  FContentType := TFhirTestScriptSetupActionOperation(oSource).FContentType.Link;
  destinationElement := TFhirTestScriptSetupActionOperation(oSource).destinationElement.Clone;
  encodeRequestUrlElement := TFhirTestScriptSetupActionOperation(oSource).encodeRequestUrlElement.Clone;
  originElement := TFhirTestScriptSetupActionOperation(oSource).originElement.Clone;
  paramsElement := TFhirTestScriptSetupActionOperation(oSource).paramsElement.Clone;
  if (TFhirTestScriptSetupActionOperation(oSource).FRequestHeaderList = nil) then
  begin
    FRequestHeaderList.free;
    FRequestHeaderList := nil;
  end
  else
  begin
    if FRequestHeaderList = nil then
      FRequestHeaderList := TFhirTestScriptSetupActionOperationRequestHeaderList.Create;
    FRequestHeaderList.Assign(TFhirTestScriptSetupActionOperation(oSource).FRequestHeaderList);
  end;
  requestIdElement := TFhirTestScriptSetupActionOperation(oSource).requestIdElement.Clone;
  responseIdElement := TFhirTestScriptSetupActionOperation(oSource).responseIdElement.Clone;
  sourceIdElement := TFhirTestScriptSetupActionOperation(oSource).sourceIdElement.Clone;
  targetIdElement := TFhirTestScriptSetupActionOperation(oSource).targetIdElement.Clone;
  urlElement := TFhirTestScriptSetupActionOperation(oSource).urlElement.Clone;
end;

procedure TFhirTestScriptSetupActionOperation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'resource') Then
     list.add(self.link, 'resource', FResource.Link);
  if (child_name = 'label') Then
     list.add(self.link, 'label', FLabel_.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'accept') Then
     list.add(self.link, 'accept', FAccept.Link);
  if (child_name = 'contentType') Then
     list.add(self.link, 'contentType', FContentType.Link);
  if (child_name = 'destination') Then
     list.add(self.link, 'destination', FDestination.Link);
  if (child_name = 'encodeRequestUrl') Then
     list.add(self.link, 'encodeRequestUrl', FEncodeRequestUrl.Link);
  if (child_name = 'origin') Then
     list.add(self.link, 'origin', FOrigin.Link);
  if (child_name = 'params') Then
     list.add(self.link, 'params', FParams.Link);
  if (child_name = 'requestHeader') Then
    list.addAll(self, 'requestHeader', FRequestHeaderList);
  if (child_name = 'requestId') Then
     list.add(self.link, 'requestId', FRequestId.Link);
  if (child_name = 'responseId') Then
     list.add(self.link, 'responseId', FResponseId.Link);
  if (child_name = 'sourceId') Then
     list.add(self.link, 'sourceId', FSourceId.Link);
  if (child_name = 'targetId') Then
     list.add(self.link, 'targetId', FTargetId.Link);
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
end;

procedure TFhirTestScriptSetupActionOperation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', false, TFhirCoding, FType_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'resource', 'code', false, TFhirCode, FResource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'label', 'string', false, TFhirString, FLabel_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'accept', 'code', false, TFHIREnum, FAccept.Link));{1}
  oList.add(TFHIRProperty.create(self, 'contentType', 'code', false, TFHIREnum, FContentType.Link));{1}
  oList.add(TFHIRProperty.create(self, 'destination', 'integer', false, TFhirInteger, FDestination.Link));{2}
  oList.add(TFHIRProperty.create(self, 'encodeRequestUrl', 'boolean', false, TFhirBoolean, FEncodeRequestUrl.Link));{2}
  oList.add(TFHIRProperty.create(self, 'origin', 'integer', false, TFhirInteger, FOrigin.Link));{2}
  oList.add(TFHIRProperty.create(self, 'params', 'string', false, TFhirString, FParams.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requestHeader', '', true, TFhirTestScriptSetupActionOperationRequestHeader, FRequestHeaderList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'requestId', 'id', false, TFhirId, FRequestId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'responseId', 'id', false, TFhirId, FResponseId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sourceId', 'id', false, TFhirId, FSourceId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'targetId', 'id', false, TFhirId, FTargetId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'url', 'string', false, TFhirString, FUrl.Link));{2}
end;

function TFhirTestScriptSetupActionOperation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    ResourceElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'label') then
  begin
    Label_Element := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'accept') then
  begin
    AcceptElement := asEnum(SYSTEMS_TFhirContentTypeEnum, CODES_TFhirContentTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'contentType') then
  begin
    ContentTypeElement := asEnum(SYSTEMS_TFhirContentTypeEnum, CODES_TFhirContentTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'destination') then
  begin
    DestinationElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'encodeRequestUrl') then
  begin
    EncodeRequestUrlElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'origin') then
  begin
    OriginElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'params') then
  begin
    ParamsElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'requestHeader') then
  begin
    RequestHeaderList.add(propValue as TFhirTestScriptSetupActionOperationRequestHeader){2a};
    result := propValue;
  end
  else if (propName = 'requestId') then
  begin
    RequestIdElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'responseId') then
  begin
    ResponseIdElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'sourceId') then
  begin
    SourceIdElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'targetId') then
  begin
    TargetIdElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'url') then
  begin
    UrlElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptSetupActionOperation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'requestHeader') then RequestHeaderList.insertItem(index, propValue as TFhirTestScriptSetupActionOperationRequestHeader){2a}
  else inherited;
end;

function TFhirTestScriptSetupActionOperation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCoding.create(){4b}
  else if (propName = 'resource') then result := TFhirCode.create() {5b}
  else if (propName = 'label') then result := TFhirString.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'destination') then result := TFhirInteger.create() {5b}
  else if (propName = 'encodeRequestUrl') then result := TFhirBoolean.create() {5b}
  else if (propName = 'origin') then result := TFhirInteger.create() {5b}
  else if (propName = 'params') then result := TFhirString.create() {5b}
  else if (propName = 'requestHeader') then result := RequestHeaderList.new(){2}
  else if (propName = 'requestId') then result := TFhirId.create() {5b}
  else if (propName = 'responseId') then result := TFhirId.create() {5b}
  else if (propName = 'sourceId') then result := TFhirId.create() {5b}
  else if (propName = 'targetId') then result := TFhirId.create() {5b}
  else if (propName = 'url') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptSetupActionOperation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'Coding'
  else if (propName = 'resource') then result := 'code'
  else if (propName = 'label') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'accept') then result := 'code'
  else if (propName = 'contentType') then result := 'code'
  else if (propName = 'destination') then result := 'integer'
  else if (propName = 'encodeRequestUrl') then result := 'boolean'
  else if (propName = 'origin') then result := 'integer'
  else if (propName = 'params') then result := 'string'
  else if (propName = 'requestHeader') then result := ''
  else if (propName = 'requestId') then result := 'id'
  else if (propName = 'responseId') then result := 'id'
  else if (propName = 'sourceId') then result := 'id'
  else if (propName = 'targetId') then result := 'id'
  else if (propName = 'url') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptSetupActionOperation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'resource') then ResourceElement := nil
  else if (propName = 'label') then Label_Element := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'accept') then AcceptElement := nil
  else if (propName = 'contentType') then ContentTypeElement := nil
  else if (propName = 'destination') then DestinationElement := nil
  else if (propName = 'encodeRequestUrl') then EncodeRequestUrlElement := nil
  else if (propName = 'origin') then OriginElement := nil
  else if (propName = 'params') then ParamsElement := nil
  else if (propName = 'requestHeader') then deletePropertyValue('requestHeader', RequestHeaderList, value) {2}
  else if (propName = 'requestId') then RequestIdElement := nil
  else if (propName = 'responseId') then ResponseIdElement := nil
  else if (propName = 'sourceId') then SourceIdElement := nil
  else if (propName = 'targetId') then TargetIdElement := nil
  else if (propName = 'url') then UrlElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptSetupActionOperation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCoding{4}
  else if (propName = 'resource') then ResourceElement := asCode(new){5b}
  else if (propName = 'label') then Label_Element := asString(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'accept') then AcceptElement := asEnum(SYSTEMS_TFhirContentTypeEnum, CODES_TFhirContentTypeEnum, new){4}
  else if (propName = 'contentType') then ContentTypeElement := asEnum(SYSTEMS_TFhirContentTypeEnum, CODES_TFhirContentTypeEnum, new){4}
  else if (propName = 'destination') then DestinationElement := asInteger(new){5b}
  else if (propName = 'encodeRequestUrl') then EncodeRequestUrlElement := asBoolean(new){5b}
  else if (propName = 'origin') then OriginElement := asInteger(new){5b}
  else if (propName = 'params') then ParamsElement := asString(new){5b}
  else if (propName = 'requestHeader') then replacePropertyValue('requestHeader', RequestHeaderList, existing, new) {2}
  else if (propName = 'requestId') then RequestIdElement := asId(new){5b}
  else if (propName = 'responseId') then ResponseIdElement := asId(new){5b}
  else if (propName = 'sourceId') then SourceIdElement := asId(new){5b}
  else if (propName = 'targetId') then TargetIdElement := asId(new){5b}
  else if (propName = 'url') then UrlElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptSetupActionOperation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'requestHeader') then RequestHeaderList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptSetupActionOperation.fhirType : string;
begin
  result := 'operation';
end;

function TFhirTestScriptSetupActionOperation.Link : TFhirTestScriptSetupActionOperation;
begin
  result := TFhirTestScriptSetupActionOperation(inherited Link);
end;

function TFhirTestScriptSetupActionOperation.Clone : TFhirTestScriptSetupActionOperation;
begin
  result := TFhirTestScriptSetupActionOperation(inherited Clone);
end;

function TFhirTestScriptSetupActionOperation.equals(other : TObject) : boolean;
var
  o : TFhirTestScriptSetupActionOperation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptSetupActionOperation)) then
    result := false
  else
  begin
    o := TFhirTestScriptSetupActionOperation(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(resourceElement, o.resourceElement, true) and
      compareDeep(label_Element, o.label_Element, true) and compareDeep(descriptionElement, o.descriptionElement, true) and
      compareDeep(acceptElement, o.acceptElement, true) and compareDeep(contentTypeElement, o.contentTypeElement, true) and
      compareDeep(destinationElement, o.destinationElement, true) and compareDeep(encodeRequestUrlElement, o.encodeRequestUrlElement, true) and
      compareDeep(originElement, o.originElement, true) and compareDeep(paramsElement, o.paramsElement, true) and
      compareDeep(requestHeaderList, o.requestHeaderList, true) and compareDeep(requestIdElement, o.requestIdElement, true) and
      compareDeep(responseIdElement, o.responseIdElement, true) and compareDeep(sourceIdElement, o.sourceIdElement, true) and
      compareDeep(targetIdElement, o.targetIdElement, true) and compareDeep(urlElement, o.urlElement, true);
  end;
end;

function TFhirTestScriptSetupActionOperation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FResource) and isEmptyProp(FLabel_) and isEmptyProp(FDescription) and isEmptyProp(FAccept) and isEmptyProp(FContentType) and isEmptyProp(FDestination) and isEmptyProp(FEncodeRequestUrl) and isEmptyProp(FOrigin) and isEmptyProp(FParams) and isEmptyProp(FrequestHeaderList) and isEmptyProp(FRequestId) and isEmptyProp(FResponseId) and isEmptyProp(FSourceId) and isEmptyProp(FTargetId) and isEmptyProp(FUrl);
end;

procedure TFhirTestScriptSetupActionOperation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('type');
  fields.add('resource');
  fields.add('label');
  fields.add('description');
  fields.add('accept');
  fields.add('contentType');
  fields.add('destination');
  fields.add('encodeRequestUrl');
  fields.add('origin');
  fields.add('params');
  fields.add('requestHeader');
  fields.add('requestId');
  fields.add('responseId');
  fields.add('sourceId');
  fields.add('targetId');
  fields.add('url');
end;

{ TFhirTestScriptSetupActionOperation }

Procedure TFhirTestScriptSetupActionOperation.SetType_(value : TFhirCoding);
begin
  FType_.free;
  FType_ := value;
end;

Procedure TFhirTestScriptSetupActionOperation.SetResource(value : TFhirCode);
begin
  FResource.free;
  FResource := value;
end;

Function TFhirTestScriptSetupActionOperation.GetResourceST : String;
begin
  if FResource = nil then
    result := ''
  else
    result := FResource.value;
end;

Procedure TFhirTestScriptSetupActionOperation.SetResourceST(value : String);
begin
  if value <> '' then
  begin
    if FResource = nil then
      FResource := TFhirCode.create;
    FResource.value := value
  end
  else if FResource <> nil then
    FResource.value := '';
end;

Procedure TFhirTestScriptSetupActionOperation.SetLabel_(value : TFhirString);
begin
  FLabel_.free;
  FLabel_ := value;
end;

Function TFhirTestScriptSetupActionOperation.GetLabel_ST : String;
begin
  if FLabel_ = nil then
    result := ''
  else
    result := FLabel_.value;
end;

Procedure TFhirTestScriptSetupActionOperation.SetLabel_ST(value : String);
begin
  if value <> '' then
  begin
    if FLabel_ = nil then
      FLabel_ := TFhirString.create;
    FLabel_.value := value
  end
  else if FLabel_ <> nil then
    FLabel_.value := '';
end;

Procedure TFhirTestScriptSetupActionOperation.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirTestScriptSetupActionOperation.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirTestScriptSetupActionOperation.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirTestScriptSetupActionOperation.SetAccept(value : TFhirEnum);
begin
  FAccept.free;
  FAccept := value;
end;

Function TFhirTestScriptSetupActionOperation.GetAcceptST : TFhirContentTypeEnum;
begin
  if FAccept = nil then
    result := TFhirContentTypeEnum(0)
  else
    result := TFhirContentTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirContentTypeEnum, FAccept.value));
end;

Procedure TFhirTestScriptSetupActionOperation.SetAcceptST(value : TFhirContentTypeEnum);
begin
  if ord(value) = 0 then
    AcceptElement := nil
  else
    AcceptElement := TFhirEnum.create(SYSTEMS_TFhirContentTypeEnum[value], CODES_TFhirContentTypeEnum[value]);
end;

Procedure TFhirTestScriptSetupActionOperation.SetContentType(value : TFhirEnum);
begin
  FContentType.free;
  FContentType := value;
end;

Function TFhirTestScriptSetupActionOperation.GetContentTypeST : TFhirContentTypeEnum;
begin
  if FContentType = nil then
    result := TFhirContentTypeEnum(0)
  else
    result := TFhirContentTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirContentTypeEnum, FContentType.value));
end;

Procedure TFhirTestScriptSetupActionOperation.SetContentTypeST(value : TFhirContentTypeEnum);
begin
  if ord(value) = 0 then
    ContentTypeElement := nil
  else
    ContentTypeElement := TFhirEnum.create(SYSTEMS_TFhirContentTypeEnum[value], CODES_TFhirContentTypeEnum[value]);
end;

Procedure TFhirTestScriptSetupActionOperation.SetDestination(value : TFhirInteger);
begin
  FDestination.free;
  FDestination := value;
end;

Function TFhirTestScriptSetupActionOperation.GetDestinationST : String;
begin
  if FDestination = nil then
    result := ''
  else
    result := FDestination.value;
end;

Procedure TFhirTestScriptSetupActionOperation.SetDestinationST(value : String);
begin
  if value <> '' then
  begin
    if FDestination = nil then
      FDestination := TFhirInteger.create;
    FDestination.value := value
  end
  else if FDestination <> nil then
    FDestination.value := '';
end;

Procedure TFhirTestScriptSetupActionOperation.SetEncodeRequestUrl(value : TFhirBoolean);
begin
  FEncodeRequestUrl.free;
  FEncodeRequestUrl := value;
end;

Function TFhirTestScriptSetupActionOperation.GetEncodeRequestUrlST : Boolean;
begin
  if FEncodeRequestUrl = nil then
    result := false
  else
    result := FEncodeRequestUrl.value;
end;

Procedure TFhirTestScriptSetupActionOperation.SetEncodeRequestUrlST(value : Boolean);
begin
  if FEncodeRequestUrl = nil then
    FEncodeRequestUrl := TFhirBoolean.create;
  FEncodeRequestUrl.value := value
end;

Procedure TFhirTestScriptSetupActionOperation.SetOrigin(value : TFhirInteger);
begin
  FOrigin.free;
  FOrigin := value;
end;

Function TFhirTestScriptSetupActionOperation.GetOriginST : String;
begin
  if FOrigin = nil then
    result := ''
  else
    result := FOrigin.value;
end;

Procedure TFhirTestScriptSetupActionOperation.SetOriginST(value : String);
begin
  if value <> '' then
  begin
    if FOrigin = nil then
      FOrigin := TFhirInteger.create;
    FOrigin.value := value
  end
  else if FOrigin <> nil then
    FOrigin.value := '';
end;

Procedure TFhirTestScriptSetupActionOperation.SetParams(value : TFhirString);
begin
  FParams.free;
  FParams := value;
end;

Function TFhirTestScriptSetupActionOperation.GetParamsST : String;
begin
  if FParams = nil then
    result := ''
  else
    result := FParams.value;
end;

Procedure TFhirTestScriptSetupActionOperation.SetParamsST(value : String);
begin
  if value <> '' then
  begin
    if FParams = nil then
      FParams := TFhirString.create;
    FParams.value := value
  end
  else if FParams <> nil then
    FParams.value := '';
end;

Function TFhirTestScriptSetupActionOperation.GetRequestHeaderList : TFhirTestScriptSetupActionOperationRequestHeaderList;
begin
  if FRequestHeaderList = nil then
    FRequestHeaderList := TFhirTestScriptSetupActionOperationRequestHeaderList.Create;
  result := FRequestHeaderList;
end;

Function TFhirTestScriptSetupActionOperation.GetHasRequestHeaderList : boolean;
begin
  result := (FRequestHeaderList <> nil) and (FRequestHeaderList.count > 0);
end;

Procedure TFhirTestScriptSetupActionOperation.SetRequestId(value : TFhirId);
begin
  FRequestId.free;
  FRequestId := value;
end;

Function TFhirTestScriptSetupActionOperation.GetRequestIdST : String;
begin
  if FRequestId = nil then
    result := ''
  else
    result := FRequestId.value;
end;

Procedure TFhirTestScriptSetupActionOperation.SetRequestIdST(value : String);
begin
  if value <> '' then
  begin
    if FRequestId = nil then
      FRequestId := TFhirId.create;
    FRequestId.value := value
  end
  else if FRequestId <> nil then
    FRequestId.value := '';
end;

Procedure TFhirTestScriptSetupActionOperation.SetResponseId(value : TFhirId);
begin
  FResponseId.free;
  FResponseId := value;
end;

Function TFhirTestScriptSetupActionOperation.GetResponseIdST : String;
begin
  if FResponseId = nil then
    result := ''
  else
    result := FResponseId.value;
end;

Procedure TFhirTestScriptSetupActionOperation.SetResponseIdST(value : String);
begin
  if value <> '' then
  begin
    if FResponseId = nil then
      FResponseId := TFhirId.create;
    FResponseId.value := value
  end
  else if FResponseId <> nil then
    FResponseId.value := '';
end;

Procedure TFhirTestScriptSetupActionOperation.SetSourceId(value : TFhirId);
begin
  FSourceId.free;
  FSourceId := value;
end;

Function TFhirTestScriptSetupActionOperation.GetSourceIdST : String;
begin
  if FSourceId = nil then
    result := ''
  else
    result := FSourceId.value;
end;

Procedure TFhirTestScriptSetupActionOperation.SetSourceIdST(value : String);
begin
  if value <> '' then
  begin
    if FSourceId = nil then
      FSourceId := TFhirId.create;
    FSourceId.value := value
  end
  else if FSourceId <> nil then
    FSourceId.value := '';
end;

Procedure TFhirTestScriptSetupActionOperation.SetTargetId(value : TFhirId);
begin
  FTargetId.free;
  FTargetId := value;
end;

Function TFhirTestScriptSetupActionOperation.GetTargetIdST : String;
begin
  if FTargetId = nil then
    result := ''
  else
    result := FTargetId.value;
end;

Procedure TFhirTestScriptSetupActionOperation.SetTargetIdST(value : String);
begin
  if value <> '' then
  begin
    if FTargetId = nil then
      FTargetId := TFhirId.create;
    FTargetId.value := value
  end
  else if FTargetId <> nil then
    FTargetId.value := '';
end;

Procedure TFhirTestScriptSetupActionOperation.SetUrl(value : TFhirString);
begin
  FUrl.free;
  FUrl := value;
end;

Function TFhirTestScriptSetupActionOperation.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

Procedure TFhirTestScriptSetupActionOperation.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirString.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

function TFhirTestScriptSetupActionOperation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FType_.sizeInBytes);
  inc(result, FResource.sizeInBytes);
  inc(result, FLabel_.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FAccept.sizeInBytes);
  inc(result, FContentType.sizeInBytes);
  inc(result, FDestination.sizeInBytes);
  inc(result, FEncodeRequestUrl.sizeInBytes);
  inc(result, FOrigin.sizeInBytes);
  inc(result, FParams.sizeInBytes);
  inc(result, FrequestHeaderList.sizeInBytes);
  inc(result, FRequestId.sizeInBytes);
  inc(result, FResponseId.sizeInBytes);
  inc(result, FSourceId.sizeInBytes);
  inc(result, FTargetId.sizeInBytes);
  inc(result, FUrl.sizeInBytes);
end;

{ TFhirTestScriptSetupActionOperationListEnumerator }

Constructor TFhirTestScriptSetupActionOperationListEnumerator.Create(list : TFhirTestScriptSetupActionOperationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptSetupActionOperationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptSetupActionOperationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptSetupActionOperationListEnumerator.GetCurrent : TFhirTestScriptSetupActionOperation;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptSetupActionOperationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptSetupActionOperationList }
procedure TFhirTestScriptSetupActionOperationList.AddItem(value: TFhirTestScriptSetupActionOperation);
begin
  assert(value.ClassName = 'TFhirTestScriptSetupActionOperation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptSetupActionOperation');
  add(value);
end;

function TFhirTestScriptSetupActionOperationList.Append: TFhirTestScriptSetupActionOperation;
begin
  result := TFhirTestScriptSetupActionOperation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptSetupActionOperationList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptSetupActionOperationList.GetEnumerator : TFhirTestScriptSetupActionOperationListEnumerator;
begin
  result := TFhirTestScriptSetupActionOperationListEnumerator.Create(self.link);
end;

function TFhirTestScriptSetupActionOperationList.Clone: TFhirTestScriptSetupActionOperationList;
begin
  result := TFhirTestScriptSetupActionOperationList(inherited Clone);
end;

function TFhirTestScriptSetupActionOperationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptSetupActionOperationList.GetItemN(index: Integer): TFhirTestScriptSetupActionOperation;
begin
  result := TFhirTestScriptSetupActionOperation(ObjectByIndex[index]);
end;

function TFhirTestScriptSetupActionOperationList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptSetupActionOperation;
end;
function TFhirTestScriptSetupActionOperationList.IndexOf(value: TFhirTestScriptSetupActionOperation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptSetupActionOperationList.Insert(index: Integer): TFhirTestScriptSetupActionOperation;
begin
  result := TFhirTestScriptSetupActionOperation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptSetupActionOperationList.InsertItem(index: Integer; value: TFhirTestScriptSetupActionOperation);
begin
  assert(value is TFhirTestScriptSetupActionOperation);
  Inherited Insert(index, value);
end;

function TFhirTestScriptSetupActionOperationList.Item(index: Integer): TFhirTestScriptSetupActionOperation;
begin
  result := TFhirTestScriptSetupActionOperation(ObjectByIndex[index]);
end;

function TFhirTestScriptSetupActionOperationList.Link: TFhirTestScriptSetupActionOperationList;
begin
  result := TFhirTestScriptSetupActionOperationList(inherited Link);
end;

procedure TFhirTestScriptSetupActionOperationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptSetupActionOperationList.SetItemByIndex(index: Integer; value: TFhirTestScriptSetupActionOperation);
begin
  assert(value is TFhirTestScriptSetupActionOperation);
  FhirTestScriptSetupActionOperations[index] := value;
end;

procedure TFhirTestScriptSetupActionOperationList.SetItemN(index: Integer; value: TFhirTestScriptSetupActionOperation);
begin
  assert(value is TFhirTestScriptSetupActionOperation);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptSetupActionOperationRequestHeader }

constructor TFhirTestScriptSetupActionOperationRequestHeader.Create;
begin
  inherited;
end;

destructor TFhirTestScriptSetupActionOperationRequestHeader.Destroy;
begin
  FField.free;
  FValue.free;
  inherited;
end;

procedure TFhirTestScriptSetupActionOperationRequestHeader.Assign(oSource : TFslObject);
begin
  inherited;
  fieldElement := TFhirTestScriptSetupActionOperationRequestHeader(oSource).fieldElement.Clone;
  valueElement := TFhirTestScriptSetupActionOperationRequestHeader(oSource).valueElement.Clone;
end;

procedure TFhirTestScriptSetupActionOperationRequestHeader.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'field') Then
     list.add(self.link, 'field', FField.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirTestScriptSetupActionOperationRequestHeader.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'field', 'string', false, TFhirString, FField.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value', 'string', false, TFhirString, FValue.Link));{2}
end;

function TFhirTestScriptSetupActionOperationRequestHeader.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'field') then
  begin
    FieldElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptSetupActionOperationRequestHeader.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestScriptSetupActionOperationRequestHeader.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'field') then result := TFhirString.create() {5b}
  else if (propName = 'value') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptSetupActionOperationRequestHeader.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'field') then result := 'string'
  else if (propName = 'value') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptSetupActionOperationRequestHeader.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'field') then FieldElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptSetupActionOperationRequestHeader.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'field') then FieldElement := asString(new){5b}
  else if (propName = 'value') then ValueElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptSetupActionOperationRequestHeader.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptSetupActionOperationRequestHeader.fhirType : string;
begin
  result := 'requestHeader';
end;

function TFhirTestScriptSetupActionOperationRequestHeader.Link : TFhirTestScriptSetupActionOperationRequestHeader;
begin
  result := TFhirTestScriptSetupActionOperationRequestHeader(inherited Link);
end;

function TFhirTestScriptSetupActionOperationRequestHeader.Clone : TFhirTestScriptSetupActionOperationRequestHeader;
begin
  result := TFhirTestScriptSetupActionOperationRequestHeader(inherited Clone);
end;

function TFhirTestScriptSetupActionOperationRequestHeader.equals(other : TObject) : boolean;
var
  o : TFhirTestScriptSetupActionOperationRequestHeader;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptSetupActionOperationRequestHeader)) then
    result := false
  else
  begin
    o := TFhirTestScriptSetupActionOperationRequestHeader(other);
    result := compareDeep(fieldElement, o.fieldElement, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirTestScriptSetupActionOperationRequestHeader.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FField) and isEmptyProp(FValue);
end;

procedure TFhirTestScriptSetupActionOperationRequestHeader.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('field');
  fields.add('value');
end;

{ TFhirTestScriptSetupActionOperationRequestHeader }

Procedure TFhirTestScriptSetupActionOperationRequestHeader.SetField(value : TFhirString);
begin
  FField.free;
  FField := value;
end;

Function TFhirTestScriptSetupActionOperationRequestHeader.GetFieldST : String;
begin
  if FField = nil then
    result := ''
  else
    result := FField.value;
end;

Procedure TFhirTestScriptSetupActionOperationRequestHeader.SetFieldST(value : String);
begin
  if value <> '' then
  begin
    if FField = nil then
      FField := TFhirString.create;
    FField.value := value
  end
  else if FField <> nil then
    FField.value := '';
end;

Procedure TFhirTestScriptSetupActionOperationRequestHeader.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirTestScriptSetupActionOperationRequestHeader.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

Procedure TFhirTestScriptSetupActionOperationRequestHeader.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

function TFhirTestScriptSetupActionOperationRequestHeader.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FField.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirTestScriptSetupActionOperationRequestHeaderListEnumerator }

Constructor TFhirTestScriptSetupActionOperationRequestHeaderListEnumerator.Create(list : TFhirTestScriptSetupActionOperationRequestHeaderList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptSetupActionOperationRequestHeaderListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptSetupActionOperationRequestHeaderListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptSetupActionOperationRequestHeaderListEnumerator.GetCurrent : TFhirTestScriptSetupActionOperationRequestHeader;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptSetupActionOperationRequestHeaderListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptSetupActionOperationRequestHeaderList }
procedure TFhirTestScriptSetupActionOperationRequestHeaderList.AddItem(value: TFhirTestScriptSetupActionOperationRequestHeader);
begin
  assert(value.ClassName = 'TFhirTestScriptSetupActionOperationRequestHeader', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptSetupActionOperationRequestHeader');
  add(value);
end;

function TFhirTestScriptSetupActionOperationRequestHeaderList.Append: TFhirTestScriptSetupActionOperationRequestHeader;
begin
  result := TFhirTestScriptSetupActionOperationRequestHeader.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptSetupActionOperationRequestHeaderList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptSetupActionOperationRequestHeaderList.GetEnumerator : TFhirTestScriptSetupActionOperationRequestHeaderListEnumerator;
begin
  result := TFhirTestScriptSetupActionOperationRequestHeaderListEnumerator.Create(self.link);
end;

function TFhirTestScriptSetupActionOperationRequestHeaderList.Clone: TFhirTestScriptSetupActionOperationRequestHeaderList;
begin
  result := TFhirTestScriptSetupActionOperationRequestHeaderList(inherited Clone);
end;

function TFhirTestScriptSetupActionOperationRequestHeaderList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptSetupActionOperationRequestHeaderList.GetItemN(index: Integer): TFhirTestScriptSetupActionOperationRequestHeader;
begin
  result := TFhirTestScriptSetupActionOperationRequestHeader(ObjectByIndex[index]);
end;

function TFhirTestScriptSetupActionOperationRequestHeaderList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptSetupActionOperationRequestHeader;
end;
function TFhirTestScriptSetupActionOperationRequestHeaderList.IndexOf(value: TFhirTestScriptSetupActionOperationRequestHeader): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptSetupActionOperationRequestHeaderList.Insert(index: Integer): TFhirTestScriptSetupActionOperationRequestHeader;
begin
  result := TFhirTestScriptSetupActionOperationRequestHeader.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptSetupActionOperationRequestHeaderList.InsertItem(index: Integer; value: TFhirTestScriptSetupActionOperationRequestHeader);
begin
  assert(value is TFhirTestScriptSetupActionOperationRequestHeader);
  Inherited Insert(index, value);
end;

function TFhirTestScriptSetupActionOperationRequestHeaderList.Item(index: Integer): TFhirTestScriptSetupActionOperationRequestHeader;
begin
  result := TFhirTestScriptSetupActionOperationRequestHeader(ObjectByIndex[index]);
end;

function TFhirTestScriptSetupActionOperationRequestHeaderList.Link: TFhirTestScriptSetupActionOperationRequestHeaderList;
begin
  result := TFhirTestScriptSetupActionOperationRequestHeaderList(inherited Link);
end;

procedure TFhirTestScriptSetupActionOperationRequestHeaderList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptSetupActionOperationRequestHeaderList.SetItemByIndex(index: Integer; value: TFhirTestScriptSetupActionOperationRequestHeader);
begin
  assert(value is TFhirTestScriptSetupActionOperationRequestHeader);
  FhirTestScriptSetupActionOperationRequestHeaders[index] := value;
end;

procedure TFhirTestScriptSetupActionOperationRequestHeaderList.SetItemN(index: Integer; value: TFhirTestScriptSetupActionOperationRequestHeader);
begin
  assert(value is TFhirTestScriptSetupActionOperationRequestHeader);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptSetupActionAssert }

constructor TFhirTestScriptSetupActionAssert.Create;
begin
  inherited;
end;

destructor TFhirTestScriptSetupActionAssert.Destroy;
begin
  FLabel_.free;
  FDescription.free;
  FDirection.free;
  FCompareToSourceId.free;
  FCompareToSourceExpression.free;
  FCompareToSourcePath.free;
  FContentType.free;
  FExpression.free;
  FHeaderField.free;
  FMinimumId.free;
  FNavigationLinks.free;
  FOperator.free;
  FPath.free;
  FRequestMethod.free;
  FRequestURL.free;
  FResource.free;
  FResponse.free;
  FResponseCode.free;
  FRule.free;
  FRuleset.free;
  FSourceId.free;
  FValidateProfileId.free;
  FValue.free;
  FWarningOnly.free;
  inherited;
end;

procedure TFhirTestScriptSetupActionAssert.Assign(oSource : TFslObject);
begin
  inherited;
  label_Element := TFhirTestScriptSetupActionAssert(oSource).label_Element.Clone;
  descriptionElement := TFhirTestScriptSetupActionAssert(oSource).descriptionElement.Clone;
  FDirection := TFhirTestScriptSetupActionAssert(oSource).FDirection.Link;
  compareToSourceIdElement := TFhirTestScriptSetupActionAssert(oSource).compareToSourceIdElement.Clone;
  compareToSourceExpressionElement := TFhirTestScriptSetupActionAssert(oSource).compareToSourceExpressionElement.Clone;
  compareToSourcePathElement := TFhirTestScriptSetupActionAssert(oSource).compareToSourcePathElement.Clone;
  FContentType := TFhirTestScriptSetupActionAssert(oSource).FContentType.Link;
  expressionElement := TFhirTestScriptSetupActionAssert(oSource).expressionElement.Clone;
  headerFieldElement := TFhirTestScriptSetupActionAssert(oSource).headerFieldElement.Clone;
  minimumIdElement := TFhirTestScriptSetupActionAssert(oSource).minimumIdElement.Clone;
  navigationLinksElement := TFhirTestScriptSetupActionAssert(oSource).navigationLinksElement.Clone;
  FOperator := TFhirTestScriptSetupActionAssert(oSource).FOperator.Link;
  pathElement := TFhirTestScriptSetupActionAssert(oSource).pathElement.Clone;
  FRequestMethod := TFhirTestScriptSetupActionAssert(oSource).FRequestMethod.Link;
  requestURLElement := TFhirTestScriptSetupActionAssert(oSource).requestURLElement.Clone;
  resourceElement := TFhirTestScriptSetupActionAssert(oSource).resourceElement.Clone;
  FResponse := TFhirTestScriptSetupActionAssert(oSource).FResponse.Link;
  responseCodeElement := TFhirTestScriptSetupActionAssert(oSource).responseCodeElement.Clone;
  rule := TFhirTestScriptSetupActionAssert(oSource).rule.Clone;
  ruleset := TFhirTestScriptSetupActionAssert(oSource).ruleset.Clone;
  sourceIdElement := TFhirTestScriptSetupActionAssert(oSource).sourceIdElement.Clone;
  validateProfileIdElement := TFhirTestScriptSetupActionAssert(oSource).validateProfileIdElement.Clone;
  valueElement := TFhirTestScriptSetupActionAssert(oSource).valueElement.Clone;
  warningOnlyElement := TFhirTestScriptSetupActionAssert(oSource).warningOnlyElement.Clone;
end;

procedure TFhirTestScriptSetupActionAssert.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'label') Then
     list.add(self.link, 'label', FLabel_.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'direction') Then
     list.add(self.link, 'direction', FDirection.Link);
  if (child_name = 'compareToSourceId') Then
     list.add(self.link, 'compareToSourceId', FCompareToSourceId.Link);
  if (child_name = 'compareToSourceExpression') Then
     list.add(self.link, 'compareToSourceExpression', FCompareToSourceExpression.Link);
  if (child_name = 'compareToSourcePath') Then
     list.add(self.link, 'compareToSourcePath', FCompareToSourcePath.Link);
  if (child_name = 'contentType') Then
     list.add(self.link, 'contentType', FContentType.Link);
  if (child_name = 'expression') Then
     list.add(self.link, 'expression', FExpression.Link);
  if (child_name = 'headerField') Then
     list.add(self.link, 'headerField', FHeaderField.Link);
  if (child_name = 'minimumId') Then
     list.add(self.link, 'minimumId', FMinimumId.Link);
  if (child_name = 'navigationLinks') Then
     list.add(self.link, 'navigationLinks', FNavigationLinks.Link);
  if (child_name = 'operator') Then
     list.add(self.link, 'operator', FOperator.Link);
  if (child_name = 'path') Then
     list.add(self.link, 'path', FPath.Link);
  if (child_name = 'requestMethod') Then
     list.add(self.link, 'requestMethod', FRequestMethod.Link);
  if (child_name = 'requestURL') Then
     list.add(self.link, 'requestURL', FRequestURL.Link);
  if (child_name = 'resource') Then
     list.add(self.link, 'resource', FResource.Link);
  if (child_name = 'response') Then
     list.add(self.link, 'response', FResponse.Link);
  if (child_name = 'responseCode') Then
     list.add(self.link, 'responseCode', FResponseCode.Link);
  if (child_name = 'rule') Then
     list.add(self.link, 'rule', FRule.Link);
  if (child_name = 'ruleset') Then
     list.add(self.link, 'ruleset', FRuleset.Link);
  if (child_name = 'sourceId') Then
     list.add(self.link, 'sourceId', FSourceId.Link);
  if (child_name = 'validateProfileId') Then
     list.add(self.link, 'validateProfileId', FValidateProfileId.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
  if (child_name = 'warningOnly') Then
     list.add(self.link, 'warningOnly', FWarningOnly.Link);
end;

procedure TFhirTestScriptSetupActionAssert.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'label', 'string', false, TFhirString, FLabel_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'direction', 'code', false, TFHIREnum, FDirection.Link));{1}
  oList.add(TFHIRProperty.create(self, 'compareToSourceId', 'string', false, TFhirString, FCompareToSourceId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'compareToSourceExpression', 'string', false, TFhirString, FCompareToSourceExpression.Link));{2}
  oList.add(TFHIRProperty.create(self, 'compareToSourcePath', 'string', false, TFhirString, FCompareToSourcePath.Link));{2}
  oList.add(TFHIRProperty.create(self, 'contentType', 'code', false, TFHIREnum, FContentType.Link));{1}
  oList.add(TFHIRProperty.create(self, 'expression', 'string', false, TFhirString, FExpression.Link));{2}
  oList.add(TFHIRProperty.create(self, 'headerField', 'string', false, TFhirString, FHeaderField.Link));{2}
  oList.add(TFHIRProperty.create(self, 'minimumId', 'string', false, TFhirString, FMinimumId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'navigationLinks', 'boolean', false, TFhirBoolean, FNavigationLinks.Link));{2}
  oList.add(TFHIRProperty.create(self, 'operator', 'code', false, TFHIREnum, FOperator.Link));{1}
  oList.add(TFHIRProperty.create(self, 'path', 'string', false, TFhirString, FPath.Link));{2}
  oList.add(TFHIRProperty.create(self, 'requestMethod', 'code', false, TFHIREnum, FRequestMethod.Link));{1}
  oList.add(TFHIRProperty.create(self, 'requestURL', 'string', false, TFhirString, FRequestURL.Link));{2}
  oList.add(TFHIRProperty.create(self, 'resource', 'code', false, TFhirCode, FResource.Link));{2}
  oList.add(TFHIRProperty.create(self, 'response', 'code', false, TFHIREnum, FResponse.Link));{1}
  oList.add(TFHIRProperty.create(self, 'responseCode', 'string', false, TFhirString, FResponseCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'rule', '', false, TFhirTestScriptSetupActionAssertRule, FRule.Link));{2}
  oList.add(TFHIRProperty.create(self, 'ruleset', '', false, TFhirTestScriptSetupActionAssertRuleset, FRuleset.Link));{2}
  oList.add(TFHIRProperty.create(self, 'sourceId', 'id', false, TFhirId, FSourceId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'validateProfileId', 'id', false, TFhirId, FValidateProfileId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value', 'string', false, TFhirString, FValue.Link));{2}
  oList.add(TFHIRProperty.create(self, 'warningOnly', 'boolean', false, TFhirBoolean, FWarningOnly.Link));{2}
end;

function TFhirTestScriptSetupActionAssert.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'label') then
  begin
    Label_Element := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'direction') then
  begin
    DirectionElement := asEnum(SYSTEMS_TFhirAssertDirectionCodesEnum, CODES_TFhirAssertDirectionCodesEnum, propValue);
    result := propValue
  end
  else if (propName = 'compareToSourceId') then
  begin
    CompareToSourceIdElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'compareToSourceExpression') then
  begin
    CompareToSourceExpressionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'compareToSourcePath') then
  begin
    CompareToSourcePathElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'contentType') then
  begin
    ContentTypeElement := asEnum(SYSTEMS_TFhirContentTypeEnum, CODES_TFhirContentTypeEnum, propValue);
    result := propValue
  end
  else if (propName = 'expression') then
  begin
    ExpressionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'headerField') then
  begin
    HeaderFieldElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'minimumId') then
  begin
    MinimumIdElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'navigationLinks') then
  begin
    NavigationLinksElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'operator') then
  begin
    OperatorElement := asEnum(SYSTEMS_TFhirAssertOperatorCodesEnum, CODES_TFhirAssertOperatorCodesEnum, propValue);
    result := propValue
  end
  else if (propName = 'path') then
  begin
    PathElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'requestMethod') then
  begin
    RequestMethodElement := asEnum(SYSTEMS_TFhirHttpOperationsEnum, CODES_TFhirHttpOperationsEnum, propValue);
    result := propValue
  end
  else if (propName = 'requestURL') then
  begin
    RequestURLElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    ResourceElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'response') then
  begin
    ResponseElement := asEnum(SYSTEMS_TFhirAssertResponseCodeTypesEnum, CODES_TFhirAssertResponseCodeTypesEnum, propValue);
    result := propValue
  end
  else if (propName = 'responseCode') then
  begin
    ResponseCodeElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'rule') then
  begin
    Rule := propValue as TFhirTestScriptSetupActionAssertRule{4b};
    result := propValue;
  end
  else if (propName = 'ruleset') then
  begin
    Ruleset := propValue as TFhirTestScriptSetupActionAssertRuleset{4b};
    result := propValue;
  end
  else if (propName = 'sourceId') then
  begin
    SourceIdElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'validateProfileId') then
  begin
    ValidateProfileIdElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'warningOnly') then
  begin
    WarningOnlyElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptSetupActionAssert.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestScriptSetupActionAssert.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'label') then result := TFhirString.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'compareToSourceId') then result := TFhirString.create() {5b}
  else if (propName = 'compareToSourceExpression') then result := TFhirString.create() {5b}
  else if (propName = 'compareToSourcePath') then result := TFhirString.create() {5b}
  else if (propName = 'expression') then result := TFhirString.create() {5b}
  else if (propName = 'headerField') then result := TFhirString.create() {5b}
  else if (propName = 'minimumId') then result := TFhirString.create() {5b}
  else if (propName = 'navigationLinks') then result := TFhirBoolean.create() {5b}
  else if (propName = 'path') then result := TFhirString.create() {5b}
  else if (propName = 'requestURL') then result := TFhirString.create() {5b}
  else if (propName = 'resource') then result := TFhirCode.create() {5b}
  else if (propName = 'responseCode') then result := TFhirString.create() {5b}
  else if (propName = 'rule') then result := TFhirTestScriptSetupActionAssertRule.create(){4b}
  else if (propName = 'ruleset') then result := TFhirTestScriptSetupActionAssertRuleset.create(){4b}
  else if (propName = 'sourceId') then result := TFhirId.create() {5b}
  else if (propName = 'validateProfileId') then result := TFhirId.create() {5b}
  else if (propName = 'value') then result := TFhirString.create() {5b}
  else if (propName = 'warningOnly') then result := TFhirBoolean.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptSetupActionAssert.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'label') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'direction') then result := 'code'
  else if (propName = 'compareToSourceId') then result := 'string'
  else if (propName = 'compareToSourceExpression') then result := 'string'
  else if (propName = 'compareToSourcePath') then result := 'string'
  else if (propName = 'contentType') then result := 'code'
  else if (propName = 'expression') then result := 'string'
  else if (propName = 'headerField') then result := 'string'
  else if (propName = 'minimumId') then result := 'string'
  else if (propName = 'navigationLinks') then result := 'boolean'
  else if (propName = 'operator') then result := 'code'
  else if (propName = 'path') then result := 'string'
  else if (propName = 'requestMethod') then result := 'code'
  else if (propName = 'requestURL') then result := 'string'
  else if (propName = 'resource') then result := 'code'
  else if (propName = 'response') then result := 'code'
  else if (propName = 'responseCode') then result := 'string'
  else if (propName = 'rule') then result := ''
  else if (propName = 'ruleset') then result := ''
  else if (propName = 'sourceId') then result := 'id'
  else if (propName = 'validateProfileId') then result := 'id'
  else if (propName = 'value') then result := 'string'
  else if (propName = 'warningOnly') then result := 'boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptSetupActionAssert.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'label') then Label_Element := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'direction') then DirectionElement := nil
  else if (propName = 'compareToSourceId') then CompareToSourceIdElement := nil
  else if (propName = 'compareToSourceExpression') then CompareToSourceExpressionElement := nil
  else if (propName = 'compareToSourcePath') then CompareToSourcePathElement := nil
  else if (propName = 'contentType') then ContentTypeElement := nil
  else if (propName = 'expression') then ExpressionElement := nil
  else if (propName = 'headerField') then HeaderFieldElement := nil
  else if (propName = 'minimumId') then MinimumIdElement := nil
  else if (propName = 'navigationLinks') then NavigationLinksElement := nil
  else if (propName = 'operator') then OperatorElement := nil
  else if (propName = 'path') then PathElement := nil
  else if (propName = 'requestMethod') then RequestMethodElement := nil
  else if (propName = 'requestURL') then RequestURLElement := nil
  else if (propName = 'resource') then ResourceElement := nil
  else if (propName = 'response') then ResponseElement := nil
  else if (propName = 'responseCode') then ResponseCodeElement := nil
  else if (propName = 'rule') then RuleElement := nil
  else if (propName = 'ruleset') then RulesetElement := nil
  else if (propName = 'sourceId') then SourceIdElement := nil
  else if (propName = 'validateProfileId') then ValidateProfileIdElement := nil
  else if (propName = 'value') then ValueElement := nil
  else if (propName = 'warningOnly') then WarningOnlyElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptSetupActionAssert.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'label') then Label_Element := asString(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'direction') then DirectionElement := asEnum(SYSTEMS_TFhirAssertDirectionCodesEnum, CODES_TFhirAssertDirectionCodesEnum, new){4}
  else if (propName = 'compareToSourceId') then CompareToSourceIdElement := asString(new){5b}
  else if (propName = 'compareToSourceExpression') then CompareToSourceExpressionElement := asString(new){5b}
  else if (propName = 'compareToSourcePath') then CompareToSourcePathElement := asString(new){5b}
  else if (propName = 'contentType') then ContentTypeElement := asEnum(SYSTEMS_TFhirContentTypeEnum, CODES_TFhirContentTypeEnum, new){4}
  else if (propName = 'expression') then ExpressionElement := asString(new){5b}
  else if (propName = 'headerField') then HeaderFieldElement := asString(new){5b}
  else if (propName = 'minimumId') then MinimumIdElement := asString(new){5b}
  else if (propName = 'navigationLinks') then NavigationLinksElement := asBoolean(new){5b}
  else if (propName = 'operator') then OperatorElement := asEnum(SYSTEMS_TFhirAssertOperatorCodesEnum, CODES_TFhirAssertOperatorCodesEnum, new){4}
  else if (propName = 'path') then PathElement := asString(new){5b}
  else if (propName = 'requestMethod') then RequestMethodElement := asEnum(SYSTEMS_TFhirHttpOperationsEnum, CODES_TFhirHttpOperationsEnum, new){4}
  else if (propName = 'requestURL') then RequestURLElement := asString(new){5b}
  else if (propName = 'resource') then ResourceElement := asCode(new){5b}
  else if (propName = 'response') then ResponseElement := asEnum(SYSTEMS_TFhirAssertResponseCodeTypesEnum, CODES_TFhirAssertResponseCodeTypesEnum, new){4}
  else if (propName = 'responseCode') then ResponseCodeElement := asString(new){5b}
  else if (propName = 'rule') then RuleElement := new as TFhirTestScriptSetupActionAssertRule{4}
  else if (propName = 'ruleset') then RulesetElement := new as TFhirTestScriptSetupActionAssertRuleset{4}
  else if (propName = 'sourceId') then SourceIdElement := asId(new){5b}
  else if (propName = 'validateProfileId') then ValidateProfileIdElement := asId(new){5b}
  else if (propName = 'value') then ValueElement := asString(new){5b}
  else if (propName = 'warningOnly') then WarningOnlyElement := asBoolean(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptSetupActionAssert.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptSetupActionAssert.fhirType : string;
begin
  result := 'assert';
end;

function TFhirTestScriptSetupActionAssert.Link : TFhirTestScriptSetupActionAssert;
begin
  result := TFhirTestScriptSetupActionAssert(inherited Link);
end;

function TFhirTestScriptSetupActionAssert.Clone : TFhirTestScriptSetupActionAssert;
begin
  result := TFhirTestScriptSetupActionAssert(inherited Clone);
end;

function TFhirTestScriptSetupActionAssert.equals(other : TObject) : boolean;
var
  o : TFhirTestScriptSetupActionAssert;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptSetupActionAssert)) then
    result := false
  else
  begin
    o := TFhirTestScriptSetupActionAssert(other);
    result := compareDeep(label_Element, o.label_Element, true) and compareDeep(descriptionElement, o.descriptionElement, true) and
      compareDeep(directionElement, o.directionElement, true) and compareDeep(compareToSourceIdElement, o.compareToSourceIdElement, true) and
      compareDeep(compareToSourceExpressionElement, o.compareToSourceExpressionElement, true) and
      compareDeep(compareToSourcePathElement, o.compareToSourcePathElement, true) and
      compareDeep(contentTypeElement, o.contentTypeElement, true) and compareDeep(expressionElement, o.expressionElement, true) and
      compareDeep(headerFieldElement, o.headerFieldElement, true) and compareDeep(minimumIdElement, o.minimumIdElement, true) and
      compareDeep(navigationLinksElement, o.navigationLinksElement, true) and compareDeep(operatorElement, o.operatorElement, true) and
      compareDeep(pathElement, o.pathElement, true) and compareDeep(requestMethodElement, o.requestMethodElement, true) and
      compareDeep(requestURLElement, o.requestURLElement, true) and compareDeep(resourceElement, o.resourceElement, true) and
      compareDeep(responseElement, o.responseElement, true) and compareDeep(responseCodeElement, o.responseCodeElement, true) and
      compareDeep(ruleElement, o.ruleElement, true) and compareDeep(rulesetElement, o.rulesetElement, true) and
      compareDeep(sourceIdElement, o.sourceIdElement, true) and compareDeep(validateProfileIdElement, o.validateProfileIdElement, true) and
      compareDeep(valueElement, o.valueElement, true) and compareDeep(warningOnlyElement, o.warningOnlyElement, true);
  end;
end;

function TFhirTestScriptSetupActionAssert.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLabel_) and isEmptyProp(FDescription) and isEmptyProp(FDirection) and isEmptyProp(FCompareToSourceId) and isEmptyProp(FCompareToSourceExpression) and isEmptyProp(FCompareToSourcePath) and isEmptyProp(FContentType) and isEmptyProp(FExpression) and isEmptyProp(FHeaderField) and isEmptyProp(FMinimumId) and isEmptyProp(FNavigationLinks) and isEmptyProp(FOperator) and isEmptyProp(FPath) and isEmptyProp(FRequestMethod) and isEmptyProp(FRequestURL) and isEmptyProp(FResource) and isEmptyProp(FResponse) and isEmptyProp(FResponseCode) and isEmptyProp(FRule) and isEmptyProp(FRuleset) and isEmptyProp(FSourceId) and isEmptyProp(FValidateProfileId) and isEmptyProp(FValue) and isEmptyProp(FWarningOnly);
end;

procedure TFhirTestScriptSetupActionAssert.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('label');
  fields.add('description');
  fields.add('direction');
  fields.add('compareToSourceId');
  fields.add('compareToSourceExpression');
  fields.add('compareToSourcePath');
  fields.add('contentType');
  fields.add('expression');
  fields.add('headerField');
  fields.add('minimumId');
  fields.add('navigationLinks');
  fields.add('operator');
  fields.add('path');
  fields.add('requestMethod');
  fields.add('requestURL');
  fields.add('resource');
  fields.add('response');
  fields.add('responseCode');
  fields.add('rule');
  fields.add('ruleset');
  fields.add('sourceId');
  fields.add('validateProfileId');
  fields.add('value');
  fields.add('warningOnly');
end;

{ TFhirTestScriptSetupActionAssert }

Procedure TFhirTestScriptSetupActionAssert.SetLabel_(value : TFhirString);
begin
  FLabel_.free;
  FLabel_ := value;
end;

Function TFhirTestScriptSetupActionAssert.GetLabel_ST : String;
begin
  if FLabel_ = nil then
    result := ''
  else
    result := FLabel_.value;
end;

Procedure TFhirTestScriptSetupActionAssert.SetLabel_ST(value : String);
begin
  if value <> '' then
  begin
    if FLabel_ = nil then
      FLabel_ := TFhirString.create;
    FLabel_.value := value
  end
  else if FLabel_ <> nil then
    FLabel_.value := '';
end;

Procedure TFhirTestScriptSetupActionAssert.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirTestScriptSetupActionAssert.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirTestScriptSetupActionAssert.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Procedure TFhirTestScriptSetupActionAssert.SetDirection(value : TFhirEnum);
begin
  FDirection.free;
  FDirection := value;
end;

Function TFhirTestScriptSetupActionAssert.GetDirectionST : TFhirAssertDirectionCodesEnum;
begin
  if FDirection = nil then
    result := TFhirAssertDirectionCodesEnum(0)
  else
    result := TFhirAssertDirectionCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirAssertDirectionCodesEnum, FDirection.value));
end;

Procedure TFhirTestScriptSetupActionAssert.SetDirectionST(value : TFhirAssertDirectionCodesEnum);
begin
  if ord(value) = 0 then
    DirectionElement := nil
  else
    DirectionElement := TFhirEnum.create(SYSTEMS_TFhirAssertDirectionCodesEnum[value], CODES_TFhirAssertDirectionCodesEnum[value]);
end;

Procedure TFhirTestScriptSetupActionAssert.SetCompareToSourceId(value : TFhirString);
begin
  FCompareToSourceId.free;
  FCompareToSourceId := value;
end;

Function TFhirTestScriptSetupActionAssert.GetCompareToSourceIdST : String;
begin
  if FCompareToSourceId = nil then
    result := ''
  else
    result := FCompareToSourceId.value;
end;

Procedure TFhirTestScriptSetupActionAssert.SetCompareToSourceIdST(value : String);
begin
  if value <> '' then
  begin
    if FCompareToSourceId = nil then
      FCompareToSourceId := TFhirString.create;
    FCompareToSourceId.value := value
  end
  else if FCompareToSourceId <> nil then
    FCompareToSourceId.value := '';
end;

Procedure TFhirTestScriptSetupActionAssert.SetCompareToSourceExpression(value : TFhirString);
begin
  FCompareToSourceExpression.free;
  FCompareToSourceExpression := value;
end;

Function TFhirTestScriptSetupActionAssert.GetCompareToSourceExpressionST : String;
begin
  if FCompareToSourceExpression = nil then
    result := ''
  else
    result := FCompareToSourceExpression.value;
end;

Procedure TFhirTestScriptSetupActionAssert.SetCompareToSourceExpressionST(value : String);
begin
  if value <> '' then
  begin
    if FCompareToSourceExpression = nil then
      FCompareToSourceExpression := TFhirString.create;
    FCompareToSourceExpression.value := value
  end
  else if FCompareToSourceExpression <> nil then
    FCompareToSourceExpression.value := '';
end;

Procedure TFhirTestScriptSetupActionAssert.SetCompareToSourcePath(value : TFhirString);
begin
  FCompareToSourcePath.free;
  FCompareToSourcePath := value;
end;

Function TFhirTestScriptSetupActionAssert.GetCompareToSourcePathST : String;
begin
  if FCompareToSourcePath = nil then
    result := ''
  else
    result := FCompareToSourcePath.value;
end;

Procedure TFhirTestScriptSetupActionAssert.SetCompareToSourcePathST(value : String);
begin
  if value <> '' then
  begin
    if FCompareToSourcePath = nil then
      FCompareToSourcePath := TFhirString.create;
    FCompareToSourcePath.value := value
  end
  else if FCompareToSourcePath <> nil then
    FCompareToSourcePath.value := '';
end;

Procedure TFhirTestScriptSetupActionAssert.SetContentType(value : TFhirEnum);
begin
  FContentType.free;
  FContentType := value;
end;

Function TFhirTestScriptSetupActionAssert.GetContentTypeST : TFhirContentTypeEnum;
begin
  if FContentType = nil then
    result := TFhirContentTypeEnum(0)
  else
    result := TFhirContentTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirContentTypeEnum, FContentType.value));
end;

Procedure TFhirTestScriptSetupActionAssert.SetContentTypeST(value : TFhirContentTypeEnum);
begin
  if ord(value) = 0 then
    ContentTypeElement := nil
  else
    ContentTypeElement := TFhirEnum.create(SYSTEMS_TFhirContentTypeEnum[value], CODES_TFhirContentTypeEnum[value]);
end;

Procedure TFhirTestScriptSetupActionAssert.SetExpression(value : TFhirString);
begin
  FExpression.free;
  FExpression := value;
end;

Function TFhirTestScriptSetupActionAssert.GetExpressionST : String;
begin
  if FExpression = nil then
    result := ''
  else
    result := FExpression.value;
end;

Procedure TFhirTestScriptSetupActionAssert.SetExpressionST(value : String);
begin
  if value <> '' then
  begin
    if FExpression = nil then
      FExpression := TFhirString.create;
    FExpression.value := value
  end
  else if FExpression <> nil then
    FExpression.value := '';
end;

Procedure TFhirTestScriptSetupActionAssert.SetHeaderField(value : TFhirString);
begin
  FHeaderField.free;
  FHeaderField := value;
end;

Function TFhirTestScriptSetupActionAssert.GetHeaderFieldST : String;
begin
  if FHeaderField = nil then
    result := ''
  else
    result := FHeaderField.value;
end;

Procedure TFhirTestScriptSetupActionAssert.SetHeaderFieldST(value : String);
begin
  if value <> '' then
  begin
    if FHeaderField = nil then
      FHeaderField := TFhirString.create;
    FHeaderField.value := value
  end
  else if FHeaderField <> nil then
    FHeaderField.value := '';
end;

Procedure TFhirTestScriptSetupActionAssert.SetMinimumId(value : TFhirString);
begin
  FMinimumId.free;
  FMinimumId := value;
end;

Function TFhirTestScriptSetupActionAssert.GetMinimumIdST : String;
begin
  if FMinimumId = nil then
    result := ''
  else
    result := FMinimumId.value;
end;

Procedure TFhirTestScriptSetupActionAssert.SetMinimumIdST(value : String);
begin
  if value <> '' then
  begin
    if FMinimumId = nil then
      FMinimumId := TFhirString.create;
    FMinimumId.value := value
  end
  else if FMinimumId <> nil then
    FMinimumId.value := '';
end;

Procedure TFhirTestScriptSetupActionAssert.SetNavigationLinks(value : TFhirBoolean);
begin
  FNavigationLinks.free;
  FNavigationLinks := value;
end;

Function TFhirTestScriptSetupActionAssert.GetNavigationLinksST : Boolean;
begin
  if FNavigationLinks = nil then
    result := false
  else
    result := FNavigationLinks.value;
end;

Procedure TFhirTestScriptSetupActionAssert.SetNavigationLinksST(value : Boolean);
begin
  if FNavigationLinks = nil then
    FNavigationLinks := TFhirBoolean.create;
  FNavigationLinks.value := value
end;

Procedure TFhirTestScriptSetupActionAssert.SetOperator(value : TFhirEnum);
begin
  FOperator.free;
  FOperator := value;
end;

Function TFhirTestScriptSetupActionAssert.GetOperatorST : TFhirAssertOperatorCodesEnum;
begin
  if FOperator = nil then
    result := TFhirAssertOperatorCodesEnum(0)
  else
    result := TFhirAssertOperatorCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirAssertOperatorCodesEnum, FOperator.value));
end;

Procedure TFhirTestScriptSetupActionAssert.SetOperatorST(value : TFhirAssertOperatorCodesEnum);
begin
  if ord(value) = 0 then
    OperatorElement := nil
  else
    OperatorElement := TFhirEnum.create(SYSTEMS_TFhirAssertOperatorCodesEnum[value], CODES_TFhirAssertOperatorCodesEnum[value]);
end;

Procedure TFhirTestScriptSetupActionAssert.SetPath(value : TFhirString);
begin
  FPath.free;
  FPath := value;
end;

Function TFhirTestScriptSetupActionAssert.GetPathST : String;
begin
  if FPath = nil then
    result := ''
  else
    result := FPath.value;
end;

Procedure TFhirTestScriptSetupActionAssert.SetPathST(value : String);
begin
  if value <> '' then
  begin
    if FPath = nil then
      FPath := TFhirString.create;
    FPath.value := value
  end
  else if FPath <> nil then
    FPath.value := '';
end;

Procedure TFhirTestScriptSetupActionAssert.SetRequestMethod(value : TFhirEnum);
begin
  FRequestMethod.free;
  FRequestMethod := value;
end;

Function TFhirTestScriptSetupActionAssert.GetRequestMethodST : TFhirHttpOperationsEnum;
begin
  if FRequestMethod = nil then
    result := TFhirHttpOperationsEnum(0)
  else
    result := TFhirHttpOperationsEnum(StringArrayIndexOfSensitive(CODES_TFhirHttpOperationsEnum, FRequestMethod.value));
end;

Procedure TFhirTestScriptSetupActionAssert.SetRequestMethodST(value : TFhirHttpOperationsEnum);
begin
  if ord(value) = 0 then
    RequestMethodElement := nil
  else
    RequestMethodElement := TFhirEnum.create(SYSTEMS_TFhirHttpOperationsEnum[value], CODES_TFhirHttpOperationsEnum[value]);
end;

Procedure TFhirTestScriptSetupActionAssert.SetRequestURL(value : TFhirString);
begin
  FRequestURL.free;
  FRequestURL := value;
end;

Function TFhirTestScriptSetupActionAssert.GetRequestURLST : String;
begin
  if FRequestURL = nil then
    result := ''
  else
    result := FRequestURL.value;
end;

Procedure TFhirTestScriptSetupActionAssert.SetRequestURLST(value : String);
begin
  if value <> '' then
  begin
    if FRequestURL = nil then
      FRequestURL := TFhirString.create;
    FRequestURL.value := value
  end
  else if FRequestURL <> nil then
    FRequestURL.value := '';
end;

Procedure TFhirTestScriptSetupActionAssert.SetResource(value : TFhirCode);
begin
  FResource.free;
  FResource := value;
end;

Function TFhirTestScriptSetupActionAssert.GetResourceST : String;
begin
  if FResource = nil then
    result := ''
  else
    result := FResource.value;
end;

Procedure TFhirTestScriptSetupActionAssert.SetResourceST(value : String);
begin
  if value <> '' then
  begin
    if FResource = nil then
      FResource := TFhirCode.create;
    FResource.value := value
  end
  else if FResource <> nil then
    FResource.value := '';
end;

Procedure TFhirTestScriptSetupActionAssert.SetResponse(value : TFhirEnum);
begin
  FResponse.free;
  FResponse := value;
end;

Function TFhirTestScriptSetupActionAssert.GetResponseST : TFhirAssertResponseCodeTypesEnum;
begin
  if FResponse = nil then
    result := TFhirAssertResponseCodeTypesEnum(0)
  else
    result := TFhirAssertResponseCodeTypesEnum(StringArrayIndexOfSensitive(CODES_TFhirAssertResponseCodeTypesEnum, FResponse.value));
end;

Procedure TFhirTestScriptSetupActionAssert.SetResponseST(value : TFhirAssertResponseCodeTypesEnum);
begin
  if ord(value) = 0 then
    ResponseElement := nil
  else
    ResponseElement := TFhirEnum.create(SYSTEMS_TFhirAssertResponseCodeTypesEnum[value], CODES_TFhirAssertResponseCodeTypesEnum[value]);
end;

Procedure TFhirTestScriptSetupActionAssert.SetResponseCode(value : TFhirString);
begin
  FResponseCode.free;
  FResponseCode := value;
end;

Function TFhirTestScriptSetupActionAssert.GetResponseCodeST : String;
begin
  if FResponseCode = nil then
    result := ''
  else
    result := FResponseCode.value;
end;

Procedure TFhirTestScriptSetupActionAssert.SetResponseCodeST(value : String);
begin
  if value <> '' then
  begin
    if FResponseCode = nil then
      FResponseCode := TFhirString.create;
    FResponseCode.value := value
  end
  else if FResponseCode <> nil then
    FResponseCode.value := '';
end;

Procedure TFhirTestScriptSetupActionAssert.SetRule(value : TFhirTestScriptSetupActionAssertRule);
begin
  FRule.free;
  FRule := value;
end;

Procedure TFhirTestScriptSetupActionAssert.SetRuleset(value : TFhirTestScriptSetupActionAssertRuleset);
begin
  FRuleset.free;
  FRuleset := value;
end;

Procedure TFhirTestScriptSetupActionAssert.SetSourceId(value : TFhirId);
begin
  FSourceId.free;
  FSourceId := value;
end;

Function TFhirTestScriptSetupActionAssert.GetSourceIdST : String;
begin
  if FSourceId = nil then
    result := ''
  else
    result := FSourceId.value;
end;

Procedure TFhirTestScriptSetupActionAssert.SetSourceIdST(value : String);
begin
  if value <> '' then
  begin
    if FSourceId = nil then
      FSourceId := TFhirId.create;
    FSourceId.value := value
  end
  else if FSourceId <> nil then
    FSourceId.value := '';
end;

Procedure TFhirTestScriptSetupActionAssert.SetValidateProfileId(value : TFhirId);
begin
  FValidateProfileId.free;
  FValidateProfileId := value;
end;

Function TFhirTestScriptSetupActionAssert.GetValidateProfileIdST : String;
begin
  if FValidateProfileId = nil then
    result := ''
  else
    result := FValidateProfileId.value;
end;

Procedure TFhirTestScriptSetupActionAssert.SetValidateProfileIdST(value : String);
begin
  if value <> '' then
  begin
    if FValidateProfileId = nil then
      FValidateProfileId := TFhirId.create;
    FValidateProfileId.value := value
  end
  else if FValidateProfileId <> nil then
    FValidateProfileId.value := '';
end;

Procedure TFhirTestScriptSetupActionAssert.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirTestScriptSetupActionAssert.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

Procedure TFhirTestScriptSetupActionAssert.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

Procedure TFhirTestScriptSetupActionAssert.SetWarningOnly(value : TFhirBoolean);
begin
  FWarningOnly.free;
  FWarningOnly := value;
end;

Function TFhirTestScriptSetupActionAssert.GetWarningOnlyST : Boolean;
begin
  if FWarningOnly = nil then
    result := false
  else
    result := FWarningOnly.value;
end;

Procedure TFhirTestScriptSetupActionAssert.SetWarningOnlyST(value : Boolean);
begin
  if FWarningOnly = nil then
    FWarningOnly := TFhirBoolean.create;
  FWarningOnly.value := value
end;

function TFhirTestScriptSetupActionAssert.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FLabel_.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FDirection.sizeInBytes);
  inc(result, FCompareToSourceId.sizeInBytes);
  inc(result, FCompareToSourceExpression.sizeInBytes);
  inc(result, FCompareToSourcePath.sizeInBytes);
  inc(result, FContentType.sizeInBytes);
  inc(result, FExpression.sizeInBytes);
  inc(result, FHeaderField.sizeInBytes);
  inc(result, FMinimumId.sizeInBytes);
  inc(result, FNavigationLinks.sizeInBytes);
  inc(result, FOperator.sizeInBytes);
  inc(result, FPath.sizeInBytes);
  inc(result, FRequestMethod.sizeInBytes);
  inc(result, FRequestURL.sizeInBytes);
  inc(result, FResource.sizeInBytes);
  inc(result, FResponse.sizeInBytes);
  inc(result, FResponseCode.sizeInBytes);
  inc(result, FRule.sizeInBytes);
  inc(result, FRuleset.sizeInBytes);
  inc(result, FSourceId.sizeInBytes);
  inc(result, FValidateProfileId.sizeInBytes);
  inc(result, FValue.sizeInBytes);
  inc(result, FWarningOnly.sizeInBytes);
end;

{ TFhirTestScriptSetupActionAssertListEnumerator }

Constructor TFhirTestScriptSetupActionAssertListEnumerator.Create(list : TFhirTestScriptSetupActionAssertList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptSetupActionAssertListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptSetupActionAssertListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptSetupActionAssertListEnumerator.GetCurrent : TFhirTestScriptSetupActionAssert;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptSetupActionAssertListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptSetupActionAssertList }
procedure TFhirTestScriptSetupActionAssertList.AddItem(value: TFhirTestScriptSetupActionAssert);
begin
  assert(value.ClassName = 'TFhirTestScriptSetupActionAssert', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptSetupActionAssert');
  add(value);
end;

function TFhirTestScriptSetupActionAssertList.Append: TFhirTestScriptSetupActionAssert;
begin
  result := TFhirTestScriptSetupActionAssert.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptSetupActionAssertList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptSetupActionAssertList.GetEnumerator : TFhirTestScriptSetupActionAssertListEnumerator;
begin
  result := TFhirTestScriptSetupActionAssertListEnumerator.Create(self.link);
end;

function TFhirTestScriptSetupActionAssertList.Clone: TFhirTestScriptSetupActionAssertList;
begin
  result := TFhirTestScriptSetupActionAssertList(inherited Clone);
end;

function TFhirTestScriptSetupActionAssertList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptSetupActionAssertList.GetItemN(index: Integer): TFhirTestScriptSetupActionAssert;
begin
  result := TFhirTestScriptSetupActionAssert(ObjectByIndex[index]);
end;

function TFhirTestScriptSetupActionAssertList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptSetupActionAssert;
end;
function TFhirTestScriptSetupActionAssertList.IndexOf(value: TFhirTestScriptSetupActionAssert): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptSetupActionAssertList.Insert(index: Integer): TFhirTestScriptSetupActionAssert;
begin
  result := TFhirTestScriptSetupActionAssert.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptSetupActionAssertList.InsertItem(index: Integer; value: TFhirTestScriptSetupActionAssert);
begin
  assert(value is TFhirTestScriptSetupActionAssert);
  Inherited Insert(index, value);
end;

function TFhirTestScriptSetupActionAssertList.Item(index: Integer): TFhirTestScriptSetupActionAssert;
begin
  result := TFhirTestScriptSetupActionAssert(ObjectByIndex[index]);
end;

function TFhirTestScriptSetupActionAssertList.Link: TFhirTestScriptSetupActionAssertList;
begin
  result := TFhirTestScriptSetupActionAssertList(inherited Link);
end;

procedure TFhirTestScriptSetupActionAssertList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptSetupActionAssertList.SetItemByIndex(index: Integer; value: TFhirTestScriptSetupActionAssert);
begin
  assert(value is TFhirTestScriptSetupActionAssert);
  FhirTestScriptSetupActionAsserts[index] := value;
end;

procedure TFhirTestScriptSetupActionAssertList.SetItemN(index: Integer; value: TFhirTestScriptSetupActionAssert);
begin
  assert(value is TFhirTestScriptSetupActionAssert);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptSetupActionAssertRule }

constructor TFhirTestScriptSetupActionAssertRule.Create;
begin
  inherited;
end;

destructor TFhirTestScriptSetupActionAssertRule.Destroy;
begin
  FRuleId.free;
  FParamList.Free;
  inherited;
end;

procedure TFhirTestScriptSetupActionAssertRule.Assign(oSource : TFslObject);
begin
  inherited;
  ruleIdElement := TFhirTestScriptSetupActionAssertRule(oSource).ruleIdElement.Clone;
  if (TFhirTestScriptSetupActionAssertRule(oSource).FParamList = nil) then
  begin
    FParamList.free;
    FParamList := nil;
  end
  else
  begin
    if FParamList = nil then
      FParamList := TFhirTestScriptSetupActionAssertRuleParamList.Create;
    FParamList.Assign(TFhirTestScriptSetupActionAssertRule(oSource).FParamList);
  end;
end;

procedure TFhirTestScriptSetupActionAssertRule.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'ruleId') Then
     list.add(self.link, 'ruleId', FRuleId.Link);
  if (child_name = 'param') Then
    list.addAll(self, 'param', FParamList);
end;

procedure TFhirTestScriptSetupActionAssertRule.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'ruleId', 'id', false, TFhirId, FRuleId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'param', '', true, TFhirTestScriptSetupActionAssertRuleParam, FParamList.Link)){3};
end;

function TFhirTestScriptSetupActionAssertRule.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'ruleId') then
  begin
    RuleIdElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'param') then
  begin
    ParamList.add(propValue as TFhirTestScriptSetupActionAssertRuleParam){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptSetupActionAssertRule.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'param') then ParamList.insertItem(index, propValue as TFhirTestScriptSetupActionAssertRuleParam){2a}
  else inherited;
end;

function TFhirTestScriptSetupActionAssertRule.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'ruleId') then result := TFhirId.create() {5b}
  else if (propName = 'param') then result := ParamList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptSetupActionAssertRule.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'ruleId') then result := 'id'
  else if (propName = 'param') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptSetupActionAssertRule.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'ruleId') then RuleIdElement := nil
  else if (propName = 'param') then deletePropertyValue('param', ParamList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptSetupActionAssertRule.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'ruleId') then RuleIdElement := asId(new){5b}
  else if (propName = 'param') then replacePropertyValue('param', ParamList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptSetupActionAssertRule.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'param') then ParamList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptSetupActionAssertRule.fhirType : string;
begin
  result := 'rule';
end;

function TFhirTestScriptSetupActionAssertRule.Link : TFhirTestScriptSetupActionAssertRule;
begin
  result := TFhirTestScriptSetupActionAssertRule(inherited Link);
end;

function TFhirTestScriptSetupActionAssertRule.Clone : TFhirTestScriptSetupActionAssertRule;
begin
  result := TFhirTestScriptSetupActionAssertRule(inherited Clone);
end;

function TFhirTestScriptSetupActionAssertRule.equals(other : TObject) : boolean;
var
  o : TFhirTestScriptSetupActionAssertRule;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptSetupActionAssertRule)) then
    result := false
  else
  begin
    o := TFhirTestScriptSetupActionAssertRule(other);
    result := compareDeep(ruleIdElement, o.ruleIdElement, true) and compareDeep(paramList, o.paramList, true);
  end;
end;

function TFhirTestScriptSetupActionAssertRule.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRuleId) and isEmptyProp(FparamList);
end;

procedure TFhirTestScriptSetupActionAssertRule.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('ruleId');
  fields.add('param');
end;

{ TFhirTestScriptSetupActionAssertRule }

Procedure TFhirTestScriptSetupActionAssertRule.SetRuleId(value : TFhirId);
begin
  FRuleId.free;
  FRuleId := value;
end;

Function TFhirTestScriptSetupActionAssertRule.GetRuleIdST : String;
begin
  if FRuleId = nil then
    result := ''
  else
    result := FRuleId.value;
end;

Procedure TFhirTestScriptSetupActionAssertRule.SetRuleIdST(value : String);
begin
  if value <> '' then
  begin
    if FRuleId = nil then
      FRuleId := TFhirId.create;
    FRuleId.value := value
  end
  else if FRuleId <> nil then
    FRuleId.value := '';
end;

Function TFhirTestScriptSetupActionAssertRule.GetParamList : TFhirTestScriptSetupActionAssertRuleParamList;
begin
  if FParamList = nil then
    FParamList := TFhirTestScriptSetupActionAssertRuleParamList.Create;
  result := FParamList;
end;

Function TFhirTestScriptSetupActionAssertRule.GetHasParamList : boolean;
begin
  result := (FParamList <> nil) and (FParamList.count > 0);
end;

function TFhirTestScriptSetupActionAssertRule.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FRuleId.sizeInBytes);
  inc(result, FparamList.sizeInBytes);
end;

{ TFhirTestScriptSetupActionAssertRuleListEnumerator }

Constructor TFhirTestScriptSetupActionAssertRuleListEnumerator.Create(list : TFhirTestScriptSetupActionAssertRuleList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptSetupActionAssertRuleListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptSetupActionAssertRuleListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptSetupActionAssertRuleListEnumerator.GetCurrent : TFhirTestScriptSetupActionAssertRule;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptSetupActionAssertRuleListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptSetupActionAssertRuleList }
procedure TFhirTestScriptSetupActionAssertRuleList.AddItem(value: TFhirTestScriptSetupActionAssertRule);
begin
  assert(value.ClassName = 'TFhirTestScriptSetupActionAssertRule', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptSetupActionAssertRule');
  add(value);
end;

function TFhirTestScriptSetupActionAssertRuleList.Append: TFhirTestScriptSetupActionAssertRule;
begin
  result := TFhirTestScriptSetupActionAssertRule.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptSetupActionAssertRuleList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptSetupActionAssertRuleList.GetEnumerator : TFhirTestScriptSetupActionAssertRuleListEnumerator;
begin
  result := TFhirTestScriptSetupActionAssertRuleListEnumerator.Create(self.link);
end;

function TFhirTestScriptSetupActionAssertRuleList.Clone: TFhirTestScriptSetupActionAssertRuleList;
begin
  result := TFhirTestScriptSetupActionAssertRuleList(inherited Clone);
end;

function TFhirTestScriptSetupActionAssertRuleList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptSetupActionAssertRuleList.GetItemN(index: Integer): TFhirTestScriptSetupActionAssertRule;
begin
  result := TFhirTestScriptSetupActionAssertRule(ObjectByIndex[index]);
end;

function TFhirTestScriptSetupActionAssertRuleList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptSetupActionAssertRule;
end;
function TFhirTestScriptSetupActionAssertRuleList.IndexOf(value: TFhirTestScriptSetupActionAssertRule): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptSetupActionAssertRuleList.Insert(index: Integer): TFhirTestScriptSetupActionAssertRule;
begin
  result := TFhirTestScriptSetupActionAssertRule.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptSetupActionAssertRuleList.InsertItem(index: Integer; value: TFhirTestScriptSetupActionAssertRule);
begin
  assert(value is TFhirTestScriptSetupActionAssertRule);
  Inherited Insert(index, value);
end;

function TFhirTestScriptSetupActionAssertRuleList.Item(index: Integer): TFhirTestScriptSetupActionAssertRule;
begin
  result := TFhirTestScriptSetupActionAssertRule(ObjectByIndex[index]);
end;

function TFhirTestScriptSetupActionAssertRuleList.Link: TFhirTestScriptSetupActionAssertRuleList;
begin
  result := TFhirTestScriptSetupActionAssertRuleList(inherited Link);
end;

procedure TFhirTestScriptSetupActionAssertRuleList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptSetupActionAssertRuleList.SetItemByIndex(index: Integer; value: TFhirTestScriptSetupActionAssertRule);
begin
  assert(value is TFhirTestScriptSetupActionAssertRule);
  FhirTestScriptSetupActionAssertRules[index] := value;
end;

procedure TFhirTestScriptSetupActionAssertRuleList.SetItemN(index: Integer; value: TFhirTestScriptSetupActionAssertRule);
begin
  assert(value is TFhirTestScriptSetupActionAssertRule);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptSetupActionAssertRuleParam }

constructor TFhirTestScriptSetupActionAssertRuleParam.Create;
begin
  inherited;
end;

destructor TFhirTestScriptSetupActionAssertRuleParam.Destroy;
begin
  FName.free;
  FValue.free;
  inherited;
end;

procedure TFhirTestScriptSetupActionAssertRuleParam.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirTestScriptSetupActionAssertRuleParam(oSource).nameElement.Clone;
  valueElement := TFhirTestScriptSetupActionAssertRuleParam(oSource).valueElement.Clone;
end;

procedure TFhirTestScriptSetupActionAssertRuleParam.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirTestScriptSetupActionAssertRuleParam.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value', 'string', false, TFhirString, FValue.Link));{2}
end;

function TFhirTestScriptSetupActionAssertRuleParam.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptSetupActionAssertRuleParam.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestScriptSetupActionAssertRuleParam.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'value') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptSetupActionAssertRuleParam.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'value') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptSetupActionAssertRuleParam.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptSetupActionAssertRuleParam.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'value') then ValueElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptSetupActionAssertRuleParam.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptSetupActionAssertRuleParam.fhirType : string;
begin
  result := 'param';
end;

function TFhirTestScriptSetupActionAssertRuleParam.Link : TFhirTestScriptSetupActionAssertRuleParam;
begin
  result := TFhirTestScriptSetupActionAssertRuleParam(inherited Link);
end;

function TFhirTestScriptSetupActionAssertRuleParam.Clone : TFhirTestScriptSetupActionAssertRuleParam;
begin
  result := TFhirTestScriptSetupActionAssertRuleParam(inherited Clone);
end;

function TFhirTestScriptSetupActionAssertRuleParam.equals(other : TObject) : boolean;
var
  o : TFhirTestScriptSetupActionAssertRuleParam;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptSetupActionAssertRuleParam)) then
    result := false
  else
  begin
    o := TFhirTestScriptSetupActionAssertRuleParam(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirTestScriptSetupActionAssertRuleParam.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FValue);
end;

procedure TFhirTestScriptSetupActionAssertRuleParam.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('value');
end;

{ TFhirTestScriptSetupActionAssertRuleParam }

Procedure TFhirTestScriptSetupActionAssertRuleParam.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirTestScriptSetupActionAssertRuleParam.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirTestScriptSetupActionAssertRuleParam.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirTestScriptSetupActionAssertRuleParam.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirTestScriptSetupActionAssertRuleParam.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

Procedure TFhirTestScriptSetupActionAssertRuleParam.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

function TFhirTestScriptSetupActionAssertRuleParam.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirTestScriptSetupActionAssertRuleParamListEnumerator }

Constructor TFhirTestScriptSetupActionAssertRuleParamListEnumerator.Create(list : TFhirTestScriptSetupActionAssertRuleParamList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptSetupActionAssertRuleParamListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptSetupActionAssertRuleParamListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptSetupActionAssertRuleParamListEnumerator.GetCurrent : TFhirTestScriptSetupActionAssertRuleParam;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptSetupActionAssertRuleParamListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptSetupActionAssertRuleParamList }
procedure TFhirTestScriptSetupActionAssertRuleParamList.AddItem(value: TFhirTestScriptSetupActionAssertRuleParam);
begin
  assert(value.ClassName = 'TFhirTestScriptSetupActionAssertRuleParam', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptSetupActionAssertRuleParam');
  add(value);
end;

function TFhirTestScriptSetupActionAssertRuleParamList.Append: TFhirTestScriptSetupActionAssertRuleParam;
begin
  result := TFhirTestScriptSetupActionAssertRuleParam.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptSetupActionAssertRuleParamList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptSetupActionAssertRuleParamList.GetEnumerator : TFhirTestScriptSetupActionAssertRuleParamListEnumerator;
begin
  result := TFhirTestScriptSetupActionAssertRuleParamListEnumerator.Create(self.link);
end;

function TFhirTestScriptSetupActionAssertRuleParamList.Clone: TFhirTestScriptSetupActionAssertRuleParamList;
begin
  result := TFhirTestScriptSetupActionAssertRuleParamList(inherited Clone);
end;

function TFhirTestScriptSetupActionAssertRuleParamList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptSetupActionAssertRuleParamList.GetItemN(index: Integer): TFhirTestScriptSetupActionAssertRuleParam;
begin
  result := TFhirTestScriptSetupActionAssertRuleParam(ObjectByIndex[index]);
end;

function TFhirTestScriptSetupActionAssertRuleParamList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptSetupActionAssertRuleParam;
end;
function TFhirTestScriptSetupActionAssertRuleParamList.IndexOf(value: TFhirTestScriptSetupActionAssertRuleParam): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptSetupActionAssertRuleParamList.Insert(index: Integer): TFhirTestScriptSetupActionAssertRuleParam;
begin
  result := TFhirTestScriptSetupActionAssertRuleParam.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptSetupActionAssertRuleParamList.InsertItem(index: Integer; value: TFhirTestScriptSetupActionAssertRuleParam);
begin
  assert(value is TFhirTestScriptSetupActionAssertRuleParam);
  Inherited Insert(index, value);
end;

function TFhirTestScriptSetupActionAssertRuleParamList.Item(index: Integer): TFhirTestScriptSetupActionAssertRuleParam;
begin
  result := TFhirTestScriptSetupActionAssertRuleParam(ObjectByIndex[index]);
end;

function TFhirTestScriptSetupActionAssertRuleParamList.Link: TFhirTestScriptSetupActionAssertRuleParamList;
begin
  result := TFhirTestScriptSetupActionAssertRuleParamList(inherited Link);
end;

procedure TFhirTestScriptSetupActionAssertRuleParamList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptSetupActionAssertRuleParamList.SetItemByIndex(index: Integer; value: TFhirTestScriptSetupActionAssertRuleParam);
begin
  assert(value is TFhirTestScriptSetupActionAssertRuleParam);
  FhirTestScriptSetupActionAssertRuleParams[index] := value;
end;

procedure TFhirTestScriptSetupActionAssertRuleParamList.SetItemN(index: Integer; value: TFhirTestScriptSetupActionAssertRuleParam);
begin
  assert(value is TFhirTestScriptSetupActionAssertRuleParam);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptSetupActionAssertRuleset }

constructor TFhirTestScriptSetupActionAssertRuleset.Create;
begin
  inherited;
end;

destructor TFhirTestScriptSetupActionAssertRuleset.Destroy;
begin
  FRulesetId.free;
  FRuleList.Free;
  inherited;
end;

procedure TFhirTestScriptSetupActionAssertRuleset.Assign(oSource : TFslObject);
begin
  inherited;
  rulesetIdElement := TFhirTestScriptSetupActionAssertRuleset(oSource).rulesetIdElement.Clone;
  if (TFhirTestScriptSetupActionAssertRuleset(oSource).FRuleList = nil) then
  begin
    FRuleList.free;
    FRuleList := nil;
  end
  else
  begin
    if FRuleList = nil then
      FRuleList := TFhirTestScriptSetupActionAssertRulesetRuleList.Create;
    FRuleList.Assign(TFhirTestScriptSetupActionAssertRuleset(oSource).FRuleList);
  end;
end;

procedure TFhirTestScriptSetupActionAssertRuleset.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'rulesetId') Then
     list.add(self.link, 'rulesetId', FRulesetId.Link);
  if (child_name = 'rule') Then
    list.addAll(self, 'rule', FRuleList);
end;

procedure TFhirTestScriptSetupActionAssertRuleset.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'rulesetId', 'id', false, TFhirId, FRulesetId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'rule', '', true, TFhirTestScriptSetupActionAssertRulesetRule, FRuleList.Link)){3};
end;

function TFhirTestScriptSetupActionAssertRuleset.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'rulesetId') then
  begin
    RulesetIdElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'rule') then
  begin
    RuleList.add(propValue as TFhirTestScriptSetupActionAssertRulesetRule){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptSetupActionAssertRuleset.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'rule') then RuleList.insertItem(index, propValue as TFhirTestScriptSetupActionAssertRulesetRule){2a}
  else inherited;
end;

function TFhirTestScriptSetupActionAssertRuleset.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'rulesetId') then result := TFhirId.create() {5b}
  else if (propName = 'rule') then result := RuleList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptSetupActionAssertRuleset.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'rulesetId') then result := 'id'
  else if (propName = 'rule') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptSetupActionAssertRuleset.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'rulesetId') then RulesetIdElement := nil
  else if (propName = 'rule') then deletePropertyValue('rule', RuleList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptSetupActionAssertRuleset.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'rulesetId') then RulesetIdElement := asId(new){5b}
  else if (propName = 'rule') then replacePropertyValue('rule', RuleList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptSetupActionAssertRuleset.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'rule') then RuleList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptSetupActionAssertRuleset.fhirType : string;
begin
  result := 'ruleset';
end;

function TFhirTestScriptSetupActionAssertRuleset.Link : TFhirTestScriptSetupActionAssertRuleset;
begin
  result := TFhirTestScriptSetupActionAssertRuleset(inherited Link);
end;

function TFhirTestScriptSetupActionAssertRuleset.Clone : TFhirTestScriptSetupActionAssertRuleset;
begin
  result := TFhirTestScriptSetupActionAssertRuleset(inherited Clone);
end;

function TFhirTestScriptSetupActionAssertRuleset.equals(other : TObject) : boolean;
var
  o : TFhirTestScriptSetupActionAssertRuleset;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptSetupActionAssertRuleset)) then
    result := false
  else
  begin
    o := TFhirTestScriptSetupActionAssertRuleset(other);
    result := compareDeep(rulesetIdElement, o.rulesetIdElement, true) and compareDeep(ruleList, o.ruleList, true);
  end;
end;

function TFhirTestScriptSetupActionAssertRuleset.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRulesetId) and isEmptyProp(FruleList);
end;

procedure TFhirTestScriptSetupActionAssertRuleset.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('rulesetId');
  fields.add('rule');
end;

{ TFhirTestScriptSetupActionAssertRuleset }

Procedure TFhirTestScriptSetupActionAssertRuleset.SetRulesetId(value : TFhirId);
begin
  FRulesetId.free;
  FRulesetId := value;
end;

Function TFhirTestScriptSetupActionAssertRuleset.GetRulesetIdST : String;
begin
  if FRulesetId = nil then
    result := ''
  else
    result := FRulesetId.value;
end;

Procedure TFhirTestScriptSetupActionAssertRuleset.SetRulesetIdST(value : String);
begin
  if value <> '' then
  begin
    if FRulesetId = nil then
      FRulesetId := TFhirId.create;
    FRulesetId.value := value
  end
  else if FRulesetId <> nil then
    FRulesetId.value := '';
end;

Function TFhirTestScriptSetupActionAssertRuleset.GetRuleList : TFhirTestScriptSetupActionAssertRulesetRuleList;
begin
  if FRuleList = nil then
    FRuleList := TFhirTestScriptSetupActionAssertRulesetRuleList.Create;
  result := FRuleList;
end;

Function TFhirTestScriptSetupActionAssertRuleset.GetHasRuleList : boolean;
begin
  result := (FRuleList <> nil) and (FRuleList.count > 0);
end;

function TFhirTestScriptSetupActionAssertRuleset.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FRulesetId.sizeInBytes);
  inc(result, FruleList.sizeInBytes);
end;

{ TFhirTestScriptSetupActionAssertRulesetListEnumerator }

Constructor TFhirTestScriptSetupActionAssertRulesetListEnumerator.Create(list : TFhirTestScriptSetupActionAssertRulesetList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptSetupActionAssertRulesetListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptSetupActionAssertRulesetListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptSetupActionAssertRulesetListEnumerator.GetCurrent : TFhirTestScriptSetupActionAssertRuleset;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptSetupActionAssertRulesetListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptSetupActionAssertRulesetList }
procedure TFhirTestScriptSetupActionAssertRulesetList.AddItem(value: TFhirTestScriptSetupActionAssertRuleset);
begin
  assert(value.ClassName = 'TFhirTestScriptSetupActionAssertRuleset', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptSetupActionAssertRuleset');
  add(value);
end;

function TFhirTestScriptSetupActionAssertRulesetList.Append: TFhirTestScriptSetupActionAssertRuleset;
begin
  result := TFhirTestScriptSetupActionAssertRuleset.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptSetupActionAssertRulesetList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptSetupActionAssertRulesetList.GetEnumerator : TFhirTestScriptSetupActionAssertRulesetListEnumerator;
begin
  result := TFhirTestScriptSetupActionAssertRulesetListEnumerator.Create(self.link);
end;

function TFhirTestScriptSetupActionAssertRulesetList.Clone: TFhirTestScriptSetupActionAssertRulesetList;
begin
  result := TFhirTestScriptSetupActionAssertRulesetList(inherited Clone);
end;

function TFhirTestScriptSetupActionAssertRulesetList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptSetupActionAssertRulesetList.GetItemN(index: Integer): TFhirTestScriptSetupActionAssertRuleset;
begin
  result := TFhirTestScriptSetupActionAssertRuleset(ObjectByIndex[index]);
end;

function TFhirTestScriptSetupActionAssertRulesetList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptSetupActionAssertRuleset;
end;
function TFhirTestScriptSetupActionAssertRulesetList.IndexOf(value: TFhirTestScriptSetupActionAssertRuleset): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptSetupActionAssertRulesetList.Insert(index: Integer): TFhirTestScriptSetupActionAssertRuleset;
begin
  result := TFhirTestScriptSetupActionAssertRuleset.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptSetupActionAssertRulesetList.InsertItem(index: Integer; value: TFhirTestScriptSetupActionAssertRuleset);
begin
  assert(value is TFhirTestScriptSetupActionAssertRuleset);
  Inherited Insert(index, value);
end;

function TFhirTestScriptSetupActionAssertRulesetList.Item(index: Integer): TFhirTestScriptSetupActionAssertRuleset;
begin
  result := TFhirTestScriptSetupActionAssertRuleset(ObjectByIndex[index]);
end;

function TFhirTestScriptSetupActionAssertRulesetList.Link: TFhirTestScriptSetupActionAssertRulesetList;
begin
  result := TFhirTestScriptSetupActionAssertRulesetList(inherited Link);
end;

procedure TFhirTestScriptSetupActionAssertRulesetList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptSetupActionAssertRulesetList.SetItemByIndex(index: Integer; value: TFhirTestScriptSetupActionAssertRuleset);
begin
  assert(value is TFhirTestScriptSetupActionAssertRuleset);
  FhirTestScriptSetupActionAssertRulesets[index] := value;
end;

procedure TFhirTestScriptSetupActionAssertRulesetList.SetItemN(index: Integer; value: TFhirTestScriptSetupActionAssertRuleset);
begin
  assert(value is TFhirTestScriptSetupActionAssertRuleset);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptSetupActionAssertRulesetRule }

constructor TFhirTestScriptSetupActionAssertRulesetRule.Create;
begin
  inherited;
end;

destructor TFhirTestScriptSetupActionAssertRulesetRule.Destroy;
begin
  FRuleId.free;
  FParamList.Free;
  inherited;
end;

procedure TFhirTestScriptSetupActionAssertRulesetRule.Assign(oSource : TFslObject);
begin
  inherited;
  ruleIdElement := TFhirTestScriptSetupActionAssertRulesetRule(oSource).ruleIdElement.Clone;
  if (TFhirTestScriptSetupActionAssertRulesetRule(oSource).FParamList = nil) then
  begin
    FParamList.free;
    FParamList := nil;
  end
  else
  begin
    if FParamList = nil then
      FParamList := TFhirTestScriptSetupActionAssertRulesetRuleParamList.Create;
    FParamList.Assign(TFhirTestScriptSetupActionAssertRulesetRule(oSource).FParamList);
  end;
end;

procedure TFhirTestScriptSetupActionAssertRulesetRule.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'ruleId') Then
     list.add(self.link, 'ruleId', FRuleId.Link);
  if (child_name = 'param') Then
    list.addAll(self, 'param', FParamList);
end;

procedure TFhirTestScriptSetupActionAssertRulesetRule.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'ruleId', 'id', false, TFhirId, FRuleId.Link));{2}
  oList.add(TFHIRProperty.create(self, 'param', '', true, TFhirTestScriptSetupActionAssertRulesetRuleParam, FParamList.Link)){3};
end;

function TFhirTestScriptSetupActionAssertRulesetRule.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'ruleId') then
  begin
    RuleIdElement := asId(propValue){5a};
    result := propValue;
  end
  else if (propName = 'param') then
  begin
    ParamList.add(propValue as TFhirTestScriptSetupActionAssertRulesetRuleParam){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptSetupActionAssertRulesetRule.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'param') then ParamList.insertItem(index, propValue as TFhirTestScriptSetupActionAssertRulesetRuleParam){2a}
  else inherited;
end;

function TFhirTestScriptSetupActionAssertRulesetRule.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'ruleId') then result := TFhirId.create() {5b}
  else if (propName = 'param') then result := ParamList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptSetupActionAssertRulesetRule.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'ruleId') then result := 'id'
  else if (propName = 'param') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptSetupActionAssertRulesetRule.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'ruleId') then RuleIdElement := nil
  else if (propName = 'param') then deletePropertyValue('param', ParamList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptSetupActionAssertRulesetRule.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'ruleId') then RuleIdElement := asId(new){5b}
  else if (propName = 'param') then replacePropertyValue('param', ParamList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptSetupActionAssertRulesetRule.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'param') then ParamList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptSetupActionAssertRulesetRule.fhirType : string;
begin
  result := 'rule';
end;

function TFhirTestScriptSetupActionAssertRulesetRule.Link : TFhirTestScriptSetupActionAssertRulesetRule;
begin
  result := TFhirTestScriptSetupActionAssertRulesetRule(inherited Link);
end;

function TFhirTestScriptSetupActionAssertRulesetRule.Clone : TFhirTestScriptSetupActionAssertRulesetRule;
begin
  result := TFhirTestScriptSetupActionAssertRulesetRule(inherited Clone);
end;

function TFhirTestScriptSetupActionAssertRulesetRule.equals(other : TObject) : boolean;
var
  o : TFhirTestScriptSetupActionAssertRulesetRule;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptSetupActionAssertRulesetRule)) then
    result := false
  else
  begin
    o := TFhirTestScriptSetupActionAssertRulesetRule(other);
    result := compareDeep(ruleIdElement, o.ruleIdElement, true) and compareDeep(paramList, o.paramList, true);
  end;
end;

function TFhirTestScriptSetupActionAssertRulesetRule.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRuleId) and isEmptyProp(FparamList);
end;

procedure TFhirTestScriptSetupActionAssertRulesetRule.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('ruleId');
  fields.add('param');
end;

{ TFhirTestScriptSetupActionAssertRulesetRule }

Procedure TFhirTestScriptSetupActionAssertRulesetRule.SetRuleId(value : TFhirId);
begin
  FRuleId.free;
  FRuleId := value;
end;

Function TFhirTestScriptSetupActionAssertRulesetRule.GetRuleIdST : String;
begin
  if FRuleId = nil then
    result := ''
  else
    result := FRuleId.value;
end;

Procedure TFhirTestScriptSetupActionAssertRulesetRule.SetRuleIdST(value : String);
begin
  if value <> '' then
  begin
    if FRuleId = nil then
      FRuleId := TFhirId.create;
    FRuleId.value := value
  end
  else if FRuleId <> nil then
    FRuleId.value := '';
end;

Function TFhirTestScriptSetupActionAssertRulesetRule.GetParamList : TFhirTestScriptSetupActionAssertRulesetRuleParamList;
begin
  if FParamList = nil then
    FParamList := TFhirTestScriptSetupActionAssertRulesetRuleParamList.Create;
  result := FParamList;
end;

Function TFhirTestScriptSetupActionAssertRulesetRule.GetHasParamList : boolean;
begin
  result := (FParamList <> nil) and (FParamList.count > 0);
end;

function TFhirTestScriptSetupActionAssertRulesetRule.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FRuleId.sizeInBytes);
  inc(result, FparamList.sizeInBytes);
end;

{ TFhirTestScriptSetupActionAssertRulesetRuleListEnumerator }

Constructor TFhirTestScriptSetupActionAssertRulesetRuleListEnumerator.Create(list : TFhirTestScriptSetupActionAssertRulesetRuleList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptSetupActionAssertRulesetRuleListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptSetupActionAssertRulesetRuleListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptSetupActionAssertRulesetRuleListEnumerator.GetCurrent : TFhirTestScriptSetupActionAssertRulesetRule;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptSetupActionAssertRulesetRuleListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptSetupActionAssertRulesetRuleList }
procedure TFhirTestScriptSetupActionAssertRulesetRuleList.AddItem(value: TFhirTestScriptSetupActionAssertRulesetRule);
begin
  assert(value.ClassName = 'TFhirTestScriptSetupActionAssertRulesetRule', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptSetupActionAssertRulesetRule');
  add(value);
end;

function TFhirTestScriptSetupActionAssertRulesetRuleList.Append: TFhirTestScriptSetupActionAssertRulesetRule;
begin
  result := TFhirTestScriptSetupActionAssertRulesetRule.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptSetupActionAssertRulesetRuleList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptSetupActionAssertRulesetRuleList.GetEnumerator : TFhirTestScriptSetupActionAssertRulesetRuleListEnumerator;
begin
  result := TFhirTestScriptSetupActionAssertRulesetRuleListEnumerator.Create(self.link);
end;

function TFhirTestScriptSetupActionAssertRulesetRuleList.Clone: TFhirTestScriptSetupActionAssertRulesetRuleList;
begin
  result := TFhirTestScriptSetupActionAssertRulesetRuleList(inherited Clone);
end;

function TFhirTestScriptSetupActionAssertRulesetRuleList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptSetupActionAssertRulesetRuleList.GetItemN(index: Integer): TFhirTestScriptSetupActionAssertRulesetRule;
begin
  result := TFhirTestScriptSetupActionAssertRulesetRule(ObjectByIndex[index]);
end;

function TFhirTestScriptSetupActionAssertRulesetRuleList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptSetupActionAssertRulesetRule;
end;
function TFhirTestScriptSetupActionAssertRulesetRuleList.IndexOf(value: TFhirTestScriptSetupActionAssertRulesetRule): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptSetupActionAssertRulesetRuleList.Insert(index: Integer): TFhirTestScriptSetupActionAssertRulesetRule;
begin
  result := TFhirTestScriptSetupActionAssertRulesetRule.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptSetupActionAssertRulesetRuleList.InsertItem(index: Integer; value: TFhirTestScriptSetupActionAssertRulesetRule);
begin
  assert(value is TFhirTestScriptSetupActionAssertRulesetRule);
  Inherited Insert(index, value);
end;

function TFhirTestScriptSetupActionAssertRulesetRuleList.Item(index: Integer): TFhirTestScriptSetupActionAssertRulesetRule;
begin
  result := TFhirTestScriptSetupActionAssertRulesetRule(ObjectByIndex[index]);
end;

function TFhirTestScriptSetupActionAssertRulesetRuleList.Link: TFhirTestScriptSetupActionAssertRulesetRuleList;
begin
  result := TFhirTestScriptSetupActionAssertRulesetRuleList(inherited Link);
end;

procedure TFhirTestScriptSetupActionAssertRulesetRuleList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptSetupActionAssertRulesetRuleList.SetItemByIndex(index: Integer; value: TFhirTestScriptSetupActionAssertRulesetRule);
begin
  assert(value is TFhirTestScriptSetupActionAssertRulesetRule);
  FhirTestScriptSetupActionAssertRulesetRules[index] := value;
end;

procedure TFhirTestScriptSetupActionAssertRulesetRuleList.SetItemN(index: Integer; value: TFhirTestScriptSetupActionAssertRulesetRule);
begin
  assert(value is TFhirTestScriptSetupActionAssertRulesetRule);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptSetupActionAssertRulesetRuleParam }

constructor TFhirTestScriptSetupActionAssertRulesetRuleParam.Create;
begin
  inherited;
end;

destructor TFhirTestScriptSetupActionAssertRulesetRuleParam.Destroy;
begin
  FName.free;
  FValue.free;
  inherited;
end;

procedure TFhirTestScriptSetupActionAssertRulesetRuleParam.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirTestScriptSetupActionAssertRulesetRuleParam(oSource).nameElement.Clone;
  valueElement := TFhirTestScriptSetupActionAssertRulesetRuleParam(oSource).valueElement.Clone;
end;

procedure TFhirTestScriptSetupActionAssertRulesetRuleParam.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirTestScriptSetupActionAssertRulesetRuleParam.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value', 'string', false, TFhirString, FValue.Link));{2}
end;

function TFhirTestScriptSetupActionAssertRulesetRuleParam.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptSetupActionAssertRulesetRuleParam.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestScriptSetupActionAssertRulesetRuleParam.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'value') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptSetupActionAssertRulesetRuleParam.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'value') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptSetupActionAssertRulesetRuleParam.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptSetupActionAssertRulesetRuleParam.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'value') then ValueElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptSetupActionAssertRulesetRuleParam.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptSetupActionAssertRulesetRuleParam.fhirType : string;
begin
  result := 'param';
end;

function TFhirTestScriptSetupActionAssertRulesetRuleParam.Link : TFhirTestScriptSetupActionAssertRulesetRuleParam;
begin
  result := TFhirTestScriptSetupActionAssertRulesetRuleParam(inherited Link);
end;

function TFhirTestScriptSetupActionAssertRulesetRuleParam.Clone : TFhirTestScriptSetupActionAssertRulesetRuleParam;
begin
  result := TFhirTestScriptSetupActionAssertRulesetRuleParam(inherited Clone);
end;

function TFhirTestScriptSetupActionAssertRulesetRuleParam.equals(other : TObject) : boolean;
var
  o : TFhirTestScriptSetupActionAssertRulesetRuleParam;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptSetupActionAssertRulesetRuleParam)) then
    result := false
  else
  begin
    o := TFhirTestScriptSetupActionAssertRulesetRuleParam(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirTestScriptSetupActionAssertRulesetRuleParam.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FValue);
end;

procedure TFhirTestScriptSetupActionAssertRulesetRuleParam.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('value');
end;

{ TFhirTestScriptSetupActionAssertRulesetRuleParam }

Procedure TFhirTestScriptSetupActionAssertRulesetRuleParam.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirTestScriptSetupActionAssertRulesetRuleParam.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirTestScriptSetupActionAssertRulesetRuleParam.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirTestScriptSetupActionAssertRulesetRuleParam.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirTestScriptSetupActionAssertRulesetRuleParam.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

Procedure TFhirTestScriptSetupActionAssertRulesetRuleParam.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

function TFhirTestScriptSetupActionAssertRulesetRuleParam.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirTestScriptSetupActionAssertRulesetRuleParamListEnumerator }

Constructor TFhirTestScriptSetupActionAssertRulesetRuleParamListEnumerator.Create(list : TFhirTestScriptSetupActionAssertRulesetRuleParamList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptSetupActionAssertRulesetRuleParamListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptSetupActionAssertRulesetRuleParamListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptSetupActionAssertRulesetRuleParamListEnumerator.GetCurrent : TFhirTestScriptSetupActionAssertRulesetRuleParam;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptSetupActionAssertRulesetRuleParamListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptSetupActionAssertRulesetRuleParamList }
procedure TFhirTestScriptSetupActionAssertRulesetRuleParamList.AddItem(value: TFhirTestScriptSetupActionAssertRulesetRuleParam);
begin
  assert(value.ClassName = 'TFhirTestScriptSetupActionAssertRulesetRuleParam', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptSetupActionAssertRulesetRuleParam');
  add(value);
end;

function TFhirTestScriptSetupActionAssertRulesetRuleParamList.Append: TFhirTestScriptSetupActionAssertRulesetRuleParam;
begin
  result := TFhirTestScriptSetupActionAssertRulesetRuleParam.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptSetupActionAssertRulesetRuleParamList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptSetupActionAssertRulesetRuleParamList.GetEnumerator : TFhirTestScriptSetupActionAssertRulesetRuleParamListEnumerator;
begin
  result := TFhirTestScriptSetupActionAssertRulesetRuleParamListEnumerator.Create(self.link);
end;

function TFhirTestScriptSetupActionAssertRulesetRuleParamList.Clone: TFhirTestScriptSetupActionAssertRulesetRuleParamList;
begin
  result := TFhirTestScriptSetupActionAssertRulesetRuleParamList(inherited Clone);
end;

function TFhirTestScriptSetupActionAssertRulesetRuleParamList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptSetupActionAssertRulesetRuleParamList.GetItemN(index: Integer): TFhirTestScriptSetupActionAssertRulesetRuleParam;
begin
  result := TFhirTestScriptSetupActionAssertRulesetRuleParam(ObjectByIndex[index]);
end;

function TFhirTestScriptSetupActionAssertRulesetRuleParamList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptSetupActionAssertRulesetRuleParam;
end;
function TFhirTestScriptSetupActionAssertRulesetRuleParamList.IndexOf(value: TFhirTestScriptSetupActionAssertRulesetRuleParam): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptSetupActionAssertRulesetRuleParamList.Insert(index: Integer): TFhirTestScriptSetupActionAssertRulesetRuleParam;
begin
  result := TFhirTestScriptSetupActionAssertRulesetRuleParam.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptSetupActionAssertRulesetRuleParamList.InsertItem(index: Integer; value: TFhirTestScriptSetupActionAssertRulesetRuleParam);
begin
  assert(value is TFhirTestScriptSetupActionAssertRulesetRuleParam);
  Inherited Insert(index, value);
end;

function TFhirTestScriptSetupActionAssertRulesetRuleParamList.Item(index: Integer): TFhirTestScriptSetupActionAssertRulesetRuleParam;
begin
  result := TFhirTestScriptSetupActionAssertRulesetRuleParam(ObjectByIndex[index]);
end;

function TFhirTestScriptSetupActionAssertRulesetRuleParamList.Link: TFhirTestScriptSetupActionAssertRulesetRuleParamList;
begin
  result := TFhirTestScriptSetupActionAssertRulesetRuleParamList(inherited Link);
end;

procedure TFhirTestScriptSetupActionAssertRulesetRuleParamList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptSetupActionAssertRulesetRuleParamList.SetItemByIndex(index: Integer; value: TFhirTestScriptSetupActionAssertRulesetRuleParam);
begin
  assert(value is TFhirTestScriptSetupActionAssertRulesetRuleParam);
  FhirTestScriptSetupActionAssertRulesetRuleParams[index] := value;
end;

procedure TFhirTestScriptSetupActionAssertRulesetRuleParamList.SetItemN(index: Integer; value: TFhirTestScriptSetupActionAssertRulesetRuleParam);
begin
  assert(value is TFhirTestScriptSetupActionAssertRulesetRuleParam);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptTest }

constructor TFhirTestScriptTest.Create;
begin
  inherited;
end;

destructor TFhirTestScriptTest.Destroy;
begin
  FName.free;
  FDescription.free;
  FActionList.Free;
  inherited;
end;

procedure TFhirTestScriptTest.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirTestScriptTest(oSource).nameElement.Clone;
  descriptionElement := TFhirTestScriptTest(oSource).descriptionElement.Clone;
  if (TFhirTestScriptTest(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirTestScriptTestActionList.Create;
    FActionList.Assign(TFhirTestScriptTest(oSource).FActionList);
  end;
end;

procedure TFhirTestScriptTest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
end;

procedure TFhirTestScriptTest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));{2}
  oList.add(TFHIRProperty.create(self, 'action', '', true, TFhirTestScriptTestAction, FActionList.Link)){3};
end;

function TFhirTestScriptTest.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirTestScriptTestAction){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptTest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirTestScriptTestAction){2a}
  else inherited;
end;

function TFhirTestScriptTest.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (propName = 'description') then result := TFhirString.create() {5b}
  else if (propName = 'action') then result := ActionList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptTest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'action') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptTest.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'action') then deletePropertyValue('action', ActionList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptTest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (propName = 'description') then DescriptionElement := asString(new){5b}
  else if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptTest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'action') then ActionList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptTest.fhirType : string;
begin
  result := 'test';
end;

function TFhirTestScriptTest.Link : TFhirTestScriptTest;
begin
  result := TFhirTestScriptTest(inherited Link);
end;

function TFhirTestScriptTest.Clone : TFhirTestScriptTest;
begin
  result := TFhirTestScriptTest(inherited Clone);
end;

function TFhirTestScriptTest.equals(other : TObject) : boolean;
var
  o : TFhirTestScriptTest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptTest)) then
    result := false
  else
  begin
    o := TFhirTestScriptTest(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and
      compareDeep(actionList, o.actionList, true);
  end;
end;

function TFhirTestScriptTest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FDescription) and isEmptyProp(FactionList);
end;

procedure TFhirTestScriptTest.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('description');
  fields.add('action');
end;

{ TFhirTestScriptTest }

Procedure TFhirTestScriptTest.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirTestScriptTest.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirTestScriptTest.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirTestScriptTest.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

Function TFhirTestScriptTest.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

Procedure TFhirTestScriptTest.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

Function TFhirTestScriptTest.GetActionList : TFhirTestScriptTestActionList;
begin
  if FActionList = nil then
    FActionList := TFhirTestScriptTestActionList.Create;
  result := FActionList;
end;

Function TFhirTestScriptTest.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

function TFhirTestScriptTest.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FDescription.sizeInBytes);
  inc(result, FactionList.sizeInBytes);
end;

{ TFhirTestScriptTestListEnumerator }

Constructor TFhirTestScriptTestListEnumerator.Create(list : TFhirTestScriptTestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptTestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptTestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptTestListEnumerator.GetCurrent : TFhirTestScriptTest;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptTestListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptTestList }
procedure TFhirTestScriptTestList.AddItem(value: TFhirTestScriptTest);
begin
  assert(value.ClassName = 'TFhirTestScriptTest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptTest');
  add(value);
end;

function TFhirTestScriptTestList.Append: TFhirTestScriptTest;
begin
  result := TFhirTestScriptTest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptTestList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptTestList.GetEnumerator : TFhirTestScriptTestListEnumerator;
begin
  result := TFhirTestScriptTestListEnumerator.Create(self.link);
end;

function TFhirTestScriptTestList.Clone: TFhirTestScriptTestList;
begin
  result := TFhirTestScriptTestList(inherited Clone);
end;

function TFhirTestScriptTestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptTestList.GetItemN(index: Integer): TFhirTestScriptTest;
begin
  result := TFhirTestScriptTest(ObjectByIndex[index]);
end;

function TFhirTestScriptTestList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptTest;
end;
function TFhirTestScriptTestList.IndexOf(value: TFhirTestScriptTest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptTestList.Insert(index: Integer): TFhirTestScriptTest;
begin
  result := TFhirTestScriptTest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptTestList.InsertItem(index: Integer; value: TFhirTestScriptTest);
begin
  assert(value is TFhirTestScriptTest);
  Inherited Insert(index, value);
end;

function TFhirTestScriptTestList.Item(index: Integer): TFhirTestScriptTest;
begin
  result := TFhirTestScriptTest(ObjectByIndex[index]);
end;

function TFhirTestScriptTestList.Link: TFhirTestScriptTestList;
begin
  result := TFhirTestScriptTestList(inherited Link);
end;

procedure TFhirTestScriptTestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptTestList.SetItemByIndex(index: Integer; value: TFhirTestScriptTest);
begin
  assert(value is TFhirTestScriptTest);
  FhirTestScriptTests[index] := value;
end;

procedure TFhirTestScriptTestList.SetItemN(index: Integer; value: TFhirTestScriptTest);
begin
  assert(value is TFhirTestScriptTest);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptTestAction }

constructor TFhirTestScriptTestAction.Create;
begin
  inherited;
end;

destructor TFhirTestScriptTestAction.Destroy;
begin
  FOperation.free;
  FAssert.free;
  inherited;
end;

procedure TFhirTestScriptTestAction.Assign(oSource : TFslObject);
begin
  inherited;
  operation := TFhirTestScriptTestAction(oSource).operation.Clone;
  assert := TFhirTestScriptTestAction(oSource).assert.Clone;
end;

procedure TFhirTestScriptTestAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'operation') Then
     list.add(self.link, 'operation', FOperation.Link);
  if (child_name = 'assert') Then
     list.add(self.link, 'assert', FAssert.Link);
end;

procedure TFhirTestScriptTestAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'operation', '@TestScript.setup.action.operation', false, TFhirTestScriptSetupActionOperation, FOperation.Link));{2}
  oList.add(TFHIRProperty.create(self, 'assert', '@TestScript.setup.action.assert', false, TFhirTestScriptSetupActionAssert, FAssert.Link));{2}
end;

function TFhirTestScriptTestAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'operation') then
  begin
    Operation := propValue as TFhirTestScriptSetupActionOperation{4b};
    result := propValue;
  end
  else if (propName = 'assert') then
  begin
    Assert := propValue as TFhirTestScriptSetupActionAssert{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptTestAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestScriptTestAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'operation') then result := TFhirTestScriptSetupActionOperation.create(){4b}
  else if (propName = 'assert') then result := TFhirTestScriptSetupActionAssert.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptTestAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'operation') then result := '@TestScript.setup.action.operation'
  else if (propName = 'assert') then result := '@TestScript.setup.action.assert'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptTestAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'operation') then OperationElement := nil
  else if (propName = 'assert') then AssertElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptTestAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'operation') then OperationElement := new as TFhirTestScriptSetupActionOperation{4}
  else if (propName = 'assert') then AssertElement := new as TFhirTestScriptSetupActionAssert{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptTestAction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptTestAction.fhirType : string;
begin
  result := 'action';
end;

function TFhirTestScriptTestAction.Link : TFhirTestScriptTestAction;
begin
  result := TFhirTestScriptTestAction(inherited Link);
end;

function TFhirTestScriptTestAction.Clone : TFhirTestScriptTestAction;
begin
  result := TFhirTestScriptTestAction(inherited Clone);
end;

function TFhirTestScriptTestAction.equals(other : TObject) : boolean;
var
  o : TFhirTestScriptTestAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptTestAction)) then
    result := false
  else
  begin
    o := TFhirTestScriptTestAction(other);
    result := compareDeep(operationElement, o.operationElement, true) and compareDeep(assertElement, o.assertElement, true);
  end;
end;

function TFhirTestScriptTestAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FOperation) and isEmptyProp(FAssert);
end;

procedure TFhirTestScriptTestAction.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('operation');
  fields.add('assert');
end;

{ TFhirTestScriptTestAction }

Procedure TFhirTestScriptTestAction.SetOperation(value : TFhirTestScriptSetupActionOperation);
begin
  FOperation.free;
  FOperation := value;
end;

Procedure TFhirTestScriptTestAction.SetAssert(value : TFhirTestScriptSetupActionAssert);
begin
  FAssert.free;
  FAssert := value;
end;

function TFhirTestScriptTestAction.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FOperation.sizeInBytes);
  inc(result, FAssert.sizeInBytes);
end;

{ TFhirTestScriptTestActionListEnumerator }

Constructor TFhirTestScriptTestActionListEnumerator.Create(list : TFhirTestScriptTestActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptTestActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptTestActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptTestActionListEnumerator.GetCurrent : TFhirTestScriptTestAction;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptTestActionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptTestActionList }
procedure TFhirTestScriptTestActionList.AddItem(value: TFhirTestScriptTestAction);
begin
  assert(value.ClassName = 'TFhirTestScriptTestAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptTestAction');
  add(value);
end;

function TFhirTestScriptTestActionList.Append: TFhirTestScriptTestAction;
begin
  result := TFhirTestScriptTestAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptTestActionList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptTestActionList.GetEnumerator : TFhirTestScriptTestActionListEnumerator;
begin
  result := TFhirTestScriptTestActionListEnumerator.Create(self.link);
end;

function TFhirTestScriptTestActionList.Clone: TFhirTestScriptTestActionList;
begin
  result := TFhirTestScriptTestActionList(inherited Clone);
end;

function TFhirTestScriptTestActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptTestActionList.GetItemN(index: Integer): TFhirTestScriptTestAction;
begin
  result := TFhirTestScriptTestAction(ObjectByIndex[index]);
end;

function TFhirTestScriptTestActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptTestAction;
end;
function TFhirTestScriptTestActionList.IndexOf(value: TFhirTestScriptTestAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptTestActionList.Insert(index: Integer): TFhirTestScriptTestAction;
begin
  result := TFhirTestScriptTestAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptTestActionList.InsertItem(index: Integer; value: TFhirTestScriptTestAction);
begin
  assert(value is TFhirTestScriptTestAction);
  Inherited Insert(index, value);
end;

function TFhirTestScriptTestActionList.Item(index: Integer): TFhirTestScriptTestAction;
begin
  result := TFhirTestScriptTestAction(ObjectByIndex[index]);
end;

function TFhirTestScriptTestActionList.Link: TFhirTestScriptTestActionList;
begin
  result := TFhirTestScriptTestActionList(inherited Link);
end;

procedure TFhirTestScriptTestActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptTestActionList.SetItemByIndex(index: Integer; value: TFhirTestScriptTestAction);
begin
  assert(value is TFhirTestScriptTestAction);
  FhirTestScriptTestActions[index] := value;
end;

procedure TFhirTestScriptTestActionList.SetItemN(index: Integer; value: TFhirTestScriptTestAction);
begin
  assert(value is TFhirTestScriptTestAction);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptTeardown }

constructor TFhirTestScriptTeardown.Create;
begin
  inherited;
end;

destructor TFhirTestScriptTeardown.Destroy;
begin
  FActionList.Free;
  inherited;
end;

procedure TFhirTestScriptTeardown.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirTestScriptTeardown(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirTestScriptTeardownActionList.Create;
    FActionList.Assign(TFhirTestScriptTeardown(oSource).FActionList);
  end;
end;

procedure TFhirTestScriptTeardown.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
end;

procedure TFhirTestScriptTeardown.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'action', '', true, TFhirTestScriptTeardownAction, FActionList.Link)){3};
end;

function TFhirTestScriptTeardown.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirTestScriptTeardownAction){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptTeardown.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirTestScriptTeardownAction){2a}
  else inherited;
end;

function TFhirTestScriptTeardown.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'action') then result := ActionList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptTeardown.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'action') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptTeardown.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'action') then deletePropertyValue('action', ActionList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptTeardown.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptTeardown.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'action') then ActionList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptTeardown.fhirType : string;
begin
  result := 'teardown';
end;

function TFhirTestScriptTeardown.Link : TFhirTestScriptTeardown;
begin
  result := TFhirTestScriptTeardown(inherited Link);
end;

function TFhirTestScriptTeardown.Clone : TFhirTestScriptTeardown;
begin
  result := TFhirTestScriptTeardown(inherited Clone);
end;

function TFhirTestScriptTeardown.equals(other : TObject) : boolean;
var
  o : TFhirTestScriptTeardown;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptTeardown)) then
    result := false
  else
  begin
    o := TFhirTestScriptTeardown(other);
    result := compareDeep(actionList, o.actionList, true);
  end;
end;

function TFhirTestScriptTeardown.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FactionList);
end;

procedure TFhirTestScriptTeardown.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('action');
end;

{ TFhirTestScriptTeardown }

Function TFhirTestScriptTeardown.GetActionList : TFhirTestScriptTeardownActionList;
begin
  if FActionList = nil then
    FActionList := TFhirTestScriptTeardownActionList.Create;
  result := FActionList;
end;

Function TFhirTestScriptTeardown.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

function TFhirTestScriptTeardown.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FactionList.sizeInBytes);
end;

{ TFhirTestScriptTeardownListEnumerator }

Constructor TFhirTestScriptTeardownListEnumerator.Create(list : TFhirTestScriptTeardownList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptTeardownListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptTeardownListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptTeardownListEnumerator.GetCurrent : TFhirTestScriptTeardown;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptTeardownListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptTeardownList }
procedure TFhirTestScriptTeardownList.AddItem(value: TFhirTestScriptTeardown);
begin
  assert(value.ClassName = 'TFhirTestScriptTeardown', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptTeardown');
  add(value);
end;

function TFhirTestScriptTeardownList.Append: TFhirTestScriptTeardown;
begin
  result := TFhirTestScriptTeardown.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptTeardownList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptTeardownList.GetEnumerator : TFhirTestScriptTeardownListEnumerator;
begin
  result := TFhirTestScriptTeardownListEnumerator.Create(self.link);
end;

function TFhirTestScriptTeardownList.Clone: TFhirTestScriptTeardownList;
begin
  result := TFhirTestScriptTeardownList(inherited Clone);
end;

function TFhirTestScriptTeardownList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptTeardownList.GetItemN(index: Integer): TFhirTestScriptTeardown;
begin
  result := TFhirTestScriptTeardown(ObjectByIndex[index]);
end;

function TFhirTestScriptTeardownList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptTeardown;
end;
function TFhirTestScriptTeardownList.IndexOf(value: TFhirTestScriptTeardown): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptTeardownList.Insert(index: Integer): TFhirTestScriptTeardown;
begin
  result := TFhirTestScriptTeardown.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptTeardownList.InsertItem(index: Integer; value: TFhirTestScriptTeardown);
begin
  assert(value is TFhirTestScriptTeardown);
  Inherited Insert(index, value);
end;

function TFhirTestScriptTeardownList.Item(index: Integer): TFhirTestScriptTeardown;
begin
  result := TFhirTestScriptTeardown(ObjectByIndex[index]);
end;

function TFhirTestScriptTeardownList.Link: TFhirTestScriptTeardownList;
begin
  result := TFhirTestScriptTeardownList(inherited Link);
end;

procedure TFhirTestScriptTeardownList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptTeardownList.SetItemByIndex(index: Integer; value: TFhirTestScriptTeardown);
begin
  assert(value is TFhirTestScriptTeardown);
  FhirTestScriptTeardowns[index] := value;
end;

procedure TFhirTestScriptTeardownList.SetItemN(index: Integer; value: TFhirTestScriptTeardown);
begin
  assert(value is TFhirTestScriptTeardown);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScriptTeardownAction }

constructor TFhirTestScriptTeardownAction.Create;
begin
  inherited;
end;

destructor TFhirTestScriptTeardownAction.Destroy;
begin
  FOperation.free;
  inherited;
end;

procedure TFhirTestScriptTeardownAction.Assign(oSource : TFslObject);
begin
  inherited;
  operation := TFhirTestScriptTeardownAction(oSource).operation.Clone;
end;

procedure TFhirTestScriptTeardownAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'operation') Then
     list.add(self.link, 'operation', FOperation.Link);
end;

procedure TFhirTestScriptTeardownAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'operation', '@TestScript.setup.action.operation', false, TFhirTestScriptSetupActionOperation, FOperation.Link));{2}
end;

function TFhirTestScriptTeardownAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'operation') then
  begin
    Operation := propValue as TFhirTestScriptSetupActionOperation{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestScriptTeardownAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestScriptTeardownAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'operation') then result := TFhirTestScriptSetupActionOperation.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScriptTeardownAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'operation') then result := '@TestScript.setup.action.operation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScriptTeardownAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'operation') then OperationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScriptTeardownAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'operation') then OperationElement := new as TFhirTestScriptSetupActionOperation{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScriptTeardownAction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScriptTeardownAction.fhirType : string;
begin
  result := 'action';
end;

function TFhirTestScriptTeardownAction.Link : TFhirTestScriptTeardownAction;
begin
  result := TFhirTestScriptTeardownAction(inherited Link);
end;

function TFhirTestScriptTeardownAction.Clone : TFhirTestScriptTeardownAction;
begin
  result := TFhirTestScriptTeardownAction(inherited Clone);
end;

function TFhirTestScriptTeardownAction.equals(other : TObject) : boolean;
var
  o : TFhirTestScriptTeardownAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScriptTeardownAction)) then
    result := false
  else
  begin
    o := TFhirTestScriptTeardownAction(other);
    result := compareDeep(operationElement, o.operationElement, true);
  end;
end;

function TFhirTestScriptTeardownAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FOperation);
end;

procedure TFhirTestScriptTeardownAction.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('operation');
end;

{ TFhirTestScriptTeardownAction }

Procedure TFhirTestScriptTeardownAction.SetOperation(value : TFhirTestScriptSetupActionOperation);
begin
  FOperation.free;
  FOperation := value;
end;

function TFhirTestScriptTeardownAction.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FOperation.sizeInBytes);
end;

{ TFhirTestScriptTeardownActionListEnumerator }

Constructor TFhirTestScriptTeardownActionListEnumerator.Create(list : TFhirTestScriptTeardownActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptTeardownActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptTeardownActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptTeardownActionListEnumerator.GetCurrent : TFhirTestScriptTeardownAction;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptTeardownActionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptTeardownActionList }
procedure TFhirTestScriptTeardownActionList.AddItem(value: TFhirTestScriptTeardownAction);
begin
  assert(value.ClassName = 'TFhirTestScriptTeardownAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScriptTeardownAction');
  add(value);
end;

function TFhirTestScriptTeardownActionList.Append: TFhirTestScriptTeardownAction;
begin
  result := TFhirTestScriptTeardownAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptTeardownActionList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptTeardownActionList.GetEnumerator : TFhirTestScriptTeardownActionListEnumerator;
begin
  result := TFhirTestScriptTeardownActionListEnumerator.Create(self.link);
end;

function TFhirTestScriptTeardownActionList.Clone: TFhirTestScriptTeardownActionList;
begin
  result := TFhirTestScriptTeardownActionList(inherited Clone);
end;

function TFhirTestScriptTeardownActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptTeardownActionList.GetItemN(index: Integer): TFhirTestScriptTeardownAction;
begin
  result := TFhirTestScriptTeardownAction(ObjectByIndex[index]);
end;

function TFhirTestScriptTeardownActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScriptTeardownAction;
end;
function TFhirTestScriptTeardownActionList.IndexOf(value: TFhirTestScriptTeardownAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptTeardownActionList.Insert(index: Integer): TFhirTestScriptTeardownAction;
begin
  result := TFhirTestScriptTeardownAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptTeardownActionList.InsertItem(index: Integer; value: TFhirTestScriptTeardownAction);
begin
  assert(value is TFhirTestScriptTeardownAction);
  Inherited Insert(index, value);
end;

function TFhirTestScriptTeardownActionList.Item(index: Integer): TFhirTestScriptTeardownAction;
begin
  result := TFhirTestScriptTeardownAction(ObjectByIndex[index]);
end;

function TFhirTestScriptTeardownActionList.Link: TFhirTestScriptTeardownActionList;
begin
  result := TFhirTestScriptTeardownActionList(inherited Link);
end;

procedure TFhirTestScriptTeardownActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptTeardownActionList.SetItemByIndex(index: Integer; value: TFhirTestScriptTeardownAction);
begin
  assert(value is TFhirTestScriptTeardownAction);
  FhirTestScriptTeardownActions[index] := value;
end;

procedure TFhirTestScriptTeardownActionList.SetItemN(index: Integer; value: TFhirTestScriptTeardownAction);
begin
  assert(value is TFhirTestScriptTeardownAction);
  ObjectByIndex[index] := value;
end;

{ TFhirTestScript }

constructor TFhirTestScript.Create;
begin
  inherited;
end;

destructor TFhirTestScript.Destroy;
begin
  FIdentifier.free;
  FPurpose.free;
  FCopyright.free;
  FOriginList.Free;
  FDestinationList.Free;
  FMetadata.free;
  FFixtureList.Free;
  FProfileList.Free;
  FVariableList.Free;
  FRuleList.Free;
  FRulesetList.Free;
  FSetup.free;
  FTestList.Free;
  FTeardown.free;
  inherited;
end;

function TFhirTestScript.GetResourceType : TFhirResourceType;
begin
  result := frtTestScript;
end;

procedure TFhirTestScript.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirTestScript(oSource).identifier.Clone;
  purposeElement := TFhirTestScript(oSource).purposeElement.Clone;
  copyrightElement := TFhirTestScript(oSource).copyrightElement.Clone;
  if (TFhirTestScript(oSource).FOriginList = nil) then
  begin
    FOriginList.free;
    FOriginList := nil;
  end
  else
  begin
    if FOriginList = nil then
      FOriginList := TFhirTestScriptOriginList.Create;
    FOriginList.Assign(TFhirTestScript(oSource).FOriginList);
  end;
  if (TFhirTestScript(oSource).FDestinationList = nil) then
  begin
    FDestinationList.free;
    FDestinationList := nil;
  end
  else
  begin
    if FDestinationList = nil then
      FDestinationList := TFhirTestScriptDestinationList.Create;
    FDestinationList.Assign(TFhirTestScript(oSource).FDestinationList);
  end;
  metadata := TFhirTestScript(oSource).metadata.Clone;
  if (TFhirTestScript(oSource).FFixtureList = nil) then
  begin
    FFixtureList.free;
    FFixtureList := nil;
  end
  else
  begin
    if FFixtureList = nil then
      FFixtureList := TFhirTestScriptFixtureList.Create;
    FFixtureList.Assign(TFhirTestScript(oSource).FFixtureList);
  end;
  if (TFhirTestScript(oSource).FProfileList = nil) then
  begin
    FProfileList.free;
    FProfileList := nil;
  end
  else
  begin
    if FProfileList = nil then
      FProfileList := TFhirReferenceList{TFhirReference}.Create;
    FProfileList.Assign(TFhirTestScript(oSource).FProfileList);
  end;
  if (TFhirTestScript(oSource).FVariableList = nil) then
  begin
    FVariableList.free;
    FVariableList := nil;
  end
  else
  begin
    if FVariableList = nil then
      FVariableList := TFhirTestScriptVariableList.Create;
    FVariableList.Assign(TFhirTestScript(oSource).FVariableList);
  end;
  if (TFhirTestScript(oSource).FRuleList = nil) then
  begin
    FRuleList.free;
    FRuleList := nil;
  end
  else
  begin
    if FRuleList = nil then
      FRuleList := TFhirTestScriptRuleList.Create;
    FRuleList.Assign(TFhirTestScript(oSource).FRuleList);
  end;
  if (TFhirTestScript(oSource).FRulesetList = nil) then
  begin
    FRulesetList.free;
    FRulesetList := nil;
  end
  else
  begin
    if FRulesetList = nil then
      FRulesetList := TFhirTestScriptRulesetList.Create;
    FRulesetList.Assign(TFhirTestScript(oSource).FRulesetList);
  end;
  setup := TFhirTestScript(oSource).setup.Clone;
  if (TFhirTestScript(oSource).FTestList = nil) then
  begin
    FTestList.free;
    FTestList := nil;
  end
  else
  begin
    if FTestList = nil then
      FTestList := TFhirTestScriptTestList.Create;
    FTestList.Assign(TFhirTestScript(oSource).FTestList);
  end;
  teardown := TFhirTestScript(oSource).teardown.Clone;
end;

procedure TFhirTestScript.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'origin') Then
    list.addAll(self, 'origin', FOriginList);
  if (child_name = 'destination') Then
    list.addAll(self, 'destination', FDestinationList);
  if (child_name = 'metadata') Then
     list.add(self.link, 'metadata', FMetadata.Link);
  if (child_name = 'fixture') Then
    list.addAll(self, 'fixture', FFixtureList);
  if (child_name = 'profile') Then
    list.addAll(self, 'profile', FProfileList);
  if (child_name = 'variable') Then
    list.addAll(self, 'variable', FVariableList);
  if (child_name = 'rule') Then
    list.addAll(self, 'rule', FRuleList);
  if (child_name = 'ruleset') Then
    list.addAll(self, 'ruleset', FRulesetList);
  if (child_name = 'setup') Then
     list.add(self.link, 'setup', FSetup.Link);
  if (child_name = 'test') Then
    list.addAll(self, 'test', FTestList);
  if (child_name = 'teardown') Then
     list.add(self.link, 'teardown', FTeardown.Link);
end;

procedure TFhirTestScript.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));{2}
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));{2}
  oList.add(TFHIRProperty.create(self, 'origin', '', true, TFhirTestScriptOrigin, FOriginList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'destination', '', true, TFhirTestScriptDestination, FDestinationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'metadata', '', false, TFhirTestScriptMetadata, FMetadata.Link));{2}
  oList.add(TFHIRProperty.create(self, 'fixture', '', true, TFhirTestScriptFixture, FFixtureList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'profile', 'Reference(Any)', true, TFhirReference{TFhirReference}, FProfileList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'variable', '', true, TFhirTestScriptVariable, FVariableList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'rule', '', true, TFhirTestScriptRule, FRuleList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'ruleset', '', true, TFhirTestScriptRuleset, FRulesetList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'setup', '', false, TFhirTestScriptSetup, FSetup.Link));{2}
  oList.add(TFHIRProperty.create(self, 'test', '', true, TFhirTestScriptTest, FTestList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'teardown', '', false, TFhirTestScriptTeardown, FTeardown.Link));{2}
end;

function TFhirTestScript.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier{4b};
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'origin') then
  begin
    OriginList.add(propValue as TFhirTestScriptOrigin){2a};
    result := propValue;
  end
  else if (propName = 'destination') then
  begin
    DestinationList.add(propValue as TFhirTestScriptDestination){2a};
    result := propValue;
  end
  else if (propName = 'metadata') then
  begin
    Metadata := propValue as TFhirTestScriptMetadata{4b};
    result := propValue;
  end
  else if (propName = 'fixture') then
  begin
    FixtureList.add(propValue as TFhirTestScriptFixture){2a};
    result := propValue;
  end
  else if (propName = 'profile') then
  begin
    ProfileList.add(propValue as TFhirReference{TFhirReference}){2a};
    result := propValue;
  end
  else if (propName = 'variable') then
  begin
    VariableList.add(propValue as TFhirTestScriptVariable){2a};
    result := propValue;
  end
  else if (propName = 'rule') then
  begin
    RuleList.add(propValue as TFhirTestScriptRule){2a};
    result := propValue;
  end
  else if (propName = 'ruleset') then
  begin
    RulesetList.add(propValue as TFhirTestScriptRuleset){2a};
    result := propValue;
  end
  else if (propName = 'setup') then
  begin
    Setup := propValue as TFhirTestScriptSetup{4b};
    result := propValue;
  end
  else if (propName = 'test') then
  begin
    TestList.add(propValue as TFhirTestScriptTest){2a};
    result := propValue;
  end
  else if (propName = 'teardown') then
  begin
    Teardown := propValue as TFhirTestScriptTeardown{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirTestScript.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'origin') then OriginList.insertItem(index, propValue as TFhirTestScriptOrigin){2a}
  else if (propName = 'destination') then DestinationList.insertItem(index, propValue as TFhirTestScriptDestination){2a}
  else if (propName = 'fixture') then FixtureList.insertItem(index, propValue as TFhirTestScriptFixture){2a}
  else if (propName = 'profile') then ProfileList.insertItem(index, propValue as TFhirReference{TFhirReference}){2a}
  else if (propName = 'variable') then VariableList.insertItem(index, propValue as TFhirTestScriptVariable){2a}
  else if (propName = 'rule') then RuleList.insertItem(index, propValue as TFhirTestScriptRule){2a}
  else if (propName = 'ruleset') then RulesetList.insertItem(index, propValue as TFhirTestScriptRuleset){2a}
  else if (propName = 'test') then TestList.insertItem(index, propValue as TFhirTestScriptTest){2a}
  else inherited;
end;

function TFhirTestScript.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create(){4b}
  else if (propName = 'purpose') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'copyright') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'origin') then result := OriginList.new(){2}
  else if (propName = 'destination') then result := DestinationList.new(){2}
  else if (propName = 'metadata') then result := TFhirTestScriptMetadata.create(){4b}
  else if (propName = 'fixture') then result := FixtureList.new(){2}
  else if (propName = 'profile') then result := ProfileList.new(){2}
  else if (propName = 'variable') then result := VariableList.new(){2}
  else if (propName = 'rule') then result := RuleList.new(){2}
  else if (propName = 'ruleset') then result := RulesetList.new(){2}
  else if (propName = 'setup') then result := TFhirTestScriptSetup.create(){4b}
  else if (propName = 'test') then result := TestList.new(){2}
  else if (propName = 'teardown') then result := TFhirTestScriptTeardown.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestScript.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'origin') then result := ''
  else if (propName = 'destination') then result := ''
  else if (propName = 'metadata') then result := ''
  else if (propName = 'fixture') then result := ''
  else if (propName = 'profile') then result := 'Reference'
  else if (propName = 'variable') then result := ''
  else if (propName = 'rule') then result := ''
  else if (propName = 'ruleset') then result := ''
  else if (propName = 'setup') then result := ''
  else if (propName = 'test') then result := ''
  else if (propName = 'teardown') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestScript.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'origin') then deletePropertyValue('origin', OriginList, value) {2}
  else if (propName = 'destination') then deletePropertyValue('destination', DestinationList, value) {2}
  else if (propName = 'metadata') then MetadataElement := nil
  else if (propName = 'fixture') then deletePropertyValue('fixture', FixtureList, value) {2}
  else if (propName = 'profile') then deletePropertyValue('profile', ProfileList, value) {2}
  else if (propName = 'variable') then deletePropertyValue('variable', VariableList, value) {2}
  else if (propName = 'rule') then deletePropertyValue('rule', RuleList, value) {2}
  else if (propName = 'ruleset') then deletePropertyValue('ruleset', RulesetList, value) {2}
  else if (propName = 'setup') then SetupElement := nil
  else if (propName = 'test') then deletePropertyValue('test', TestList, value) {2}
  else if (propName = 'teardown') then TeardownElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestScript.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier{4}
  else if (propName = 'purpose') then PurposeElement := asMarkdown(new){5b}
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new){5b}
  else if (propName = 'origin') then replacePropertyValue('origin', OriginList, existing, new) {2}
  else if (propName = 'destination') then replacePropertyValue('destination', DestinationList, existing, new) {2}
  else if (propName = 'metadata') then MetadataElement := new as TFhirTestScriptMetadata{4}
  else if (propName = 'fixture') then replacePropertyValue('fixture', FixtureList, existing, new) {2}
  else if (propName = 'profile') then replacePropertyValue('profile', ProfileList, existing, new) {2}
  else if (propName = 'variable') then replacePropertyValue('variable', VariableList, existing, new) {2}
  else if (propName = 'rule') then replacePropertyValue('rule', RuleList, existing, new) {2}
  else if (propName = 'ruleset') then replacePropertyValue('ruleset', RulesetList, existing, new) {2}
  else if (propName = 'setup') then SetupElement := new as TFhirTestScriptSetup{4}
  else if (propName = 'test') then replacePropertyValue('test', TestList, existing, new) {2}
  else if (propName = 'teardown') then TeardownElement := new as TFhirTestScriptTeardown{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestScript.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'origin') then OriginList.move(source, destination){2a}
  else if (propName = 'destination') then DestinationList.move(source, destination){2a}
  else if (propName = 'fixture') then FixtureList.move(source, destination){2a}
  else if (propName = 'profile') then ProfileList.move(source, destination){2a}
  else if (propName = 'variable') then VariableList.move(source, destination){2a}
  else if (propName = 'rule') then RuleList.move(source, destination){2a}
  else if (propName = 'ruleset') then RulesetList.move(source, destination){2a}
  else if (propName = 'test') then TestList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestScript.fhirType : string;
begin
  result := 'TestScript';
end;

function TFhirTestScript.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FPurpose) and isEmptyProp(FCopyright) and isEmptyProp(ForiginList) and isEmptyProp(FdestinationList) and isEmptyProp(FMetadata) and isEmptyProp(FfixtureList) and isEmptyProp(FprofileList) and isEmptyProp(FvariableList) and isEmptyProp(FruleList) and isEmptyProp(FrulesetList) and isEmptyProp(FSetup) and isEmptyProp(FtestList) and isEmptyProp(FTeardown);
end;

function TFhirTestScript.equals(other : TObject) : boolean;
var
  o : TFhirTestScript;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestScript)) then
    result := false
  else
  begin
    o := TFhirTestScript(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(purposeElement, o.purposeElement, true) and
      compareDeep(copyrightElement, o.copyrightElement, true) and compareDeep(originList, o.originList, true) and
      compareDeep(destinationList, o.destinationList, true) and compareDeep(metadataElement, o.metadataElement, true) and
      compareDeep(fixtureList, o.fixtureList, true) and compareDeep(profileList, o.profileList, true) and
      compareDeep(variableList, o.variableList, true) and compareDeep(ruleList, o.ruleList, true) and
      compareDeep(rulesetList, o.rulesetList, true) and compareDeep(setupElement, o.setupElement, true) and
      compareDeep(testList, o.testList, true) and compareDeep(teardownElement, o.teardownElement, true);
  end;
end;

function TFhirTestScript.Link : TFhirTestScript;
begin
  result := TFhirTestScript(inherited Link);
end;

function TFhirTestScript.Clone : TFhirTestScript;
begin
  result := TFhirTestScript(inherited Clone);
end;

procedure TFhirTestScript.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('status');
  fields.add('experimental');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('purpose');
  fields.add('copyright');
  fields.add('origin');
  fields.add('destination');
  fields.add('metadata');
  fields.add('fixture');
  fields.add('profile');
  fields.add('variable');
  fields.add('rule');
  fields.add('ruleset');
  fields.add('setup');
  fields.add('test');
  fields.add('teardown');
end;

{ TFhirTestScript }

Procedure TFhirTestScript.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Procedure TFhirTestScript.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

Function TFhirTestScript.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

Procedure TFhirTestScript.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

Procedure TFhirTestScript.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

Function TFhirTestScript.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

Procedure TFhirTestScript.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

Function TFhirTestScript.GetOriginList : TFhirTestScriptOriginList;
begin
  if FOriginList = nil then
    FOriginList := TFhirTestScriptOriginList.Create;
  result := FOriginList;
end;

Function TFhirTestScript.GetHasOriginList : boolean;
begin
  result := (FOriginList <> nil) and (FOriginList.count > 0);
end;

Function TFhirTestScript.GetDestinationList : TFhirTestScriptDestinationList;
begin
  if FDestinationList = nil then
    FDestinationList := TFhirTestScriptDestinationList.Create;
  result := FDestinationList;
end;

Function TFhirTestScript.GetHasDestinationList : boolean;
begin
  result := (FDestinationList <> nil) and (FDestinationList.count > 0);
end;

Procedure TFhirTestScript.SetMetadata(value : TFhirTestScriptMetadata);
begin
  FMetadata.free;
  FMetadata := value;
end;

Function TFhirTestScript.GetFixtureList : TFhirTestScriptFixtureList;
begin
  if FFixtureList = nil then
    FFixtureList := TFhirTestScriptFixtureList.Create;
  result := FFixtureList;
end;

Function TFhirTestScript.GetHasFixtureList : boolean;
begin
  result := (FFixtureList <> nil) and (FFixtureList.count > 0);
end;

Function TFhirTestScript.GetProfileList : TFhirReferenceList{TFhirReference};
begin
  if FProfileList = nil then
    FProfileList := TFhirReferenceList{TFhirReference}.Create;
  result := FProfileList;
end;

Function TFhirTestScript.GetHasProfileList : boolean;
begin
  result := (FProfileList <> nil) and (FProfileList.count > 0);
end;

Function TFhirTestScript.GetVariableList : TFhirTestScriptVariableList;
begin
  if FVariableList = nil then
    FVariableList := TFhirTestScriptVariableList.Create;
  result := FVariableList;
end;

Function TFhirTestScript.GetHasVariableList : boolean;
begin
  result := (FVariableList <> nil) and (FVariableList.count > 0);
end;

Function TFhirTestScript.GetRuleList : TFhirTestScriptRuleList;
begin
  if FRuleList = nil then
    FRuleList := TFhirTestScriptRuleList.Create;
  result := FRuleList;
end;

Function TFhirTestScript.GetHasRuleList : boolean;
begin
  result := (FRuleList <> nil) and (FRuleList.count > 0);
end;

Function TFhirTestScript.GetRulesetList : TFhirTestScriptRulesetList;
begin
  if FRulesetList = nil then
    FRulesetList := TFhirTestScriptRulesetList.Create;
  result := FRulesetList;
end;

Function TFhirTestScript.GetHasRulesetList : boolean;
begin
  result := (FRulesetList <> nil) and (FRulesetList.count > 0);
end;

Procedure TFhirTestScript.SetSetup(value : TFhirTestScriptSetup);
begin
  FSetup.free;
  FSetup := value;
end;

Function TFhirTestScript.GetTestList : TFhirTestScriptTestList;
begin
  if FTestList = nil then
    FTestList := TFhirTestScriptTestList.Create;
  result := FTestList;
end;

Function TFhirTestScript.GetHasTestList : boolean;
begin
  result := (FTestList <> nil) and (FTestList.count > 0);
end;

Procedure TFhirTestScript.SetTeardown(value : TFhirTestScriptTeardown);
begin
  FTeardown.free;
  FTeardown := value;
end;

function TFhirTestScript.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FPurpose.sizeInBytes);
  inc(result, FCopyright.sizeInBytes);
  inc(result, ForiginList.sizeInBytes);
  inc(result, FdestinationList.sizeInBytes);
  inc(result, FMetadata.sizeInBytes);
  inc(result, FfixtureList.sizeInBytes);
  inc(result, FprofileList.sizeInBytes);
  inc(result, FvariableList.sizeInBytes);
  inc(result, FruleList.sizeInBytes);
  inc(result, FrulesetList.sizeInBytes);
  inc(result, FSetup.sizeInBytes);
  inc(result, FtestList.sizeInBytes);
  inc(result, FTeardown.sizeInBytes);
end;

{ TFhirTestScriptListEnumerator }

Constructor TFhirTestScriptListEnumerator.Create(list : TFhirTestScriptList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestScriptListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestScriptListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestScriptListEnumerator.GetCurrent : TFhirTestScript;
begin
  Result := FList[FIndex];
end;

function TFhirTestScriptListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirTestScriptList }
procedure TFhirTestScriptList.AddItem(value: TFhirTestScript);
begin
  assert(value.ClassName = 'TFhirTestScript', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestScript');
  add(value);
end;

function TFhirTestScriptList.Append: TFhirTestScript;
begin
  result := TFhirTestScript.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptList.ClearItems;
begin
  Clear;
end;

function TFhirTestScriptList.GetEnumerator : TFhirTestScriptListEnumerator;
begin
  result := TFhirTestScriptListEnumerator.Create(self.link);
end;

function TFhirTestScriptList.Clone: TFhirTestScriptList;
begin
  result := TFhirTestScriptList(inherited Clone);
end;

function TFhirTestScriptList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestScriptList.GetItemN(index: Integer): TFhirTestScript;
begin
  result := TFhirTestScript(ObjectByIndex[index]);
end;

function TFhirTestScriptList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestScript;
end;
function TFhirTestScriptList.IndexOf(value: TFhirTestScript): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestScriptList.Insert(index: Integer): TFhirTestScript;
begin
  result := TFhirTestScript.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestScriptList.InsertItem(index: Integer; value: TFhirTestScript);
begin
  assert(value is TFhirTestScript);
  Inherited Insert(index, value);
end;

function TFhirTestScriptList.Item(index: Integer): TFhirTestScript;
begin
  result := TFhirTestScript(ObjectByIndex[index]);
end;

function TFhirTestScriptList.Link: TFhirTestScriptList;
begin
  result := TFhirTestScriptList(inherited Link);
end;

procedure TFhirTestScriptList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestScriptList.SetItemByIndex(index: Integer; value: TFhirTestScript);
begin
  assert(value is TFhirTestScript);
  FhirTestScripts[index] := value;
end;

procedure TFhirTestScriptList.SetItemN(index: Integer; value: TFhirTestScript);
begin
  assert(value is TFhirTestScript);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_TESTSCRIPT}

{$IFDEF FHIR_VALUESET}

{ TFhirValueSetCompose }

constructor TFhirValueSetCompose.Create;
begin
  inherited;
end;

destructor TFhirValueSetCompose.Destroy;
begin
  FLockedDate.free;
  FInactive.free;
  FIncludeList.Free;
  FExcludeList.Free;
  inherited;
end;

procedure TFhirValueSetCompose.Assign(oSource : TFslObject);
begin
  inherited;
  lockedDateElement := TFhirValueSetCompose(oSource).lockedDateElement.Clone;
  inactiveElement := TFhirValueSetCompose(oSource).inactiveElement.Clone;
  if (TFhirValueSetCompose(oSource).FIncludeList = nil) then
  begin
    FIncludeList.free;
    FIncludeList := nil;
  end
  else
  begin
    if FIncludeList = nil then
      FIncludeList := TFhirValueSetComposeIncludeList.Create;
    FIncludeList.Assign(TFhirValueSetCompose(oSource).FIncludeList);
  end;
  if (TFhirValueSetCompose(oSource).FExcludeList = nil) then
  begin
    FExcludeList.free;
    FExcludeList := nil;
  end
  else
  begin
    if FExcludeList = nil then
      FExcludeList := TFhirValueSetComposeIncludeList.Create;
    FExcludeList.Assign(TFhirValueSetCompose(oSource).FExcludeList);
  end;
end;

procedure TFhirValueSetCompose.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'lockedDate') Then
     list.add(self.link, 'lockedDate', FLockedDate.Link);
  if (child_name = 'inactive') Then
     list.add(self.link, 'inactive', FInactive.Link);
  if (child_name = 'include') Then
    list.addAll(self, 'include', FIncludeList);
  if (child_name = 'exclude') Then
    list.addAll(self, 'exclude', FExcludeList);
end;

procedure TFhirValueSetCompose.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'lockedDate', 'date', false, TFhirDate, FLockedDate.Link));{2}
  oList.add(TFHIRProperty.create(self, 'inactive', 'boolean', false, TFhirBoolean, FInactive.Link));{2}
  oList.add(TFHIRProperty.create(self, 'include', '', true, TFhirValueSetComposeInclude, FIncludeList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'exclude', '@ValueSet.compose.include', true, TFhirValueSetComposeInclude, FExcludeList.Link)){3};
end;

function TFhirValueSetCompose.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'lockedDate') then
  begin
    LockedDateElement := asDate(propValue){5a};
    result := propValue;
  end
  else if (propName = 'inactive') then
  begin
    InactiveElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'include') then
  begin
    IncludeList.add(propValue as TFhirValueSetComposeInclude){2a};
    result := propValue;
  end
  else if (propName = 'exclude') then
  begin
    ExcludeList.add(propValue as TFhirValueSetComposeInclude){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirValueSetCompose.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'include') then IncludeList.insertItem(index, propValue as TFhirValueSetComposeInclude){2a}
  else if (propName = 'exclude') then ExcludeList.insertItem(index, propValue as TFhirValueSetComposeInclude){2a}
  else inherited;
end;

function TFhirValueSetCompose.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'lockedDate') then result := TFhirDate.create() {5b}
  else if (propName = 'inactive') then result := TFhirBoolean.create() {5b}
  else if (propName = 'include') then result := IncludeList.new(){2}
  else if (propName = 'exclude') then result := ExcludeList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirValueSetCompose.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'lockedDate') then result := 'date'
  else if (propName = 'inactive') then result := 'boolean'
  else if (propName = 'include') then result := ''
  else if (propName = 'exclude') then result := '@ValueSet.compose.include'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirValueSetCompose.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'lockedDate') then LockedDateElement := nil
  else if (propName = 'inactive') then InactiveElement := nil
  else if (propName = 'include') then deletePropertyValue('include', IncludeList, value) {2}
  else if (propName = 'exclude') then deletePropertyValue('exclude', ExcludeList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirValueSetCompose.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'lockedDate') then LockedDateElement := asDate(new){5b}
  else if (propName = 'inactive') then InactiveElement := asBoolean(new){5b}
  else if (propName = 'include') then replacePropertyValue('include', IncludeList, existing, new) {2}
  else if (propName = 'exclude') then replacePropertyValue('exclude', ExcludeList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirValueSetCompose.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'include') then IncludeList.move(source, destination){2a}
  else if (propName = 'exclude') then ExcludeList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirValueSetCompose.fhirType : string;
begin
  result := 'compose';
end;

function TFhirValueSetCompose.Link : TFhirValueSetCompose;
begin
  result := TFhirValueSetCompose(inherited Link);
end;

function TFhirValueSetCompose.Clone : TFhirValueSetCompose;
begin
  result := TFhirValueSetCompose(inherited Clone);
end;

function TFhirValueSetCompose.equals(other : TObject) : boolean;
var
  o : TFhirValueSetCompose;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirValueSetCompose)) then
    result := false
  else
  begin
    o := TFhirValueSetCompose(other);
    result := compareDeep(lockedDateElement, o.lockedDateElement, true) and compareDeep(inactiveElement, o.inactiveElement, true) and
      compareDeep(includeList, o.includeList, true) and compareDeep(excludeList, o.excludeList, true);
  end;
end;

function TFhirValueSetCompose.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLockedDate) and isEmptyProp(FInactive) and isEmptyProp(FincludeList) and isEmptyProp(FexcludeList);
end;

procedure TFhirValueSetCompose.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('lockedDate');
  fields.add('inactive');
  fields.add('include');
  fields.add('exclude');
end;

{ TFhirValueSetCompose }

Procedure TFhirValueSetCompose.SetLockedDate(value : TFhirDate);
begin
  FLockedDate.free;
  FLockedDate := value;
end;

Function TFhirValueSetCompose.GetLockedDateST : TFslDateTime;
begin
  if FLockedDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FLockedDate.value;
end;

Procedure TFhirValueSetCompose.SetLockedDateST(value : TFslDateTime);
begin
  if FLockedDate = nil then
    FLockedDate := TFhirDate.create;
  FLockedDate.value := value
end;

Procedure TFhirValueSetCompose.SetInactive(value : TFhirBoolean);
begin
  FInactive.free;
  FInactive := value;
end;

Function TFhirValueSetCompose.GetInactiveST : Boolean;
begin
  if FInactive = nil then
    result := false
  else
    result := FInactive.value;
end;

Procedure TFhirValueSetCompose.SetInactiveST(value : Boolean);
begin
  if FInactive = nil then
    FInactive := TFhirBoolean.create;
  FInactive.value := value
end;

Function TFhirValueSetCompose.GetIncludeList : TFhirValueSetComposeIncludeList;
begin
  if FIncludeList = nil then
    FIncludeList := TFhirValueSetComposeIncludeList.Create;
  result := FIncludeList;
end;

Function TFhirValueSetCompose.GetHasIncludeList : boolean;
begin
  result := (FIncludeList <> nil) and (FIncludeList.count > 0);
end;

Function TFhirValueSetCompose.GetExcludeList : TFhirValueSetComposeIncludeList;
begin
  if FExcludeList = nil then
    FExcludeList := TFhirValueSetComposeIncludeList.Create;
  result := FExcludeList;
end;

Function TFhirValueSetCompose.GetHasExcludeList : boolean;
begin
  result := (FExcludeList <> nil) and (FExcludeList.count > 0);
end;

function TFhirValueSetCompose.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FLockedDate.sizeInBytes);
  inc(result, FInactive.sizeInBytes);
  inc(result, FincludeList.sizeInBytes);
  inc(result, FexcludeList.sizeInBytes);
end;

{ TFhirValueSetComposeListEnumerator }

Constructor TFhirValueSetComposeListEnumerator.Create(list : TFhirValueSetComposeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirValueSetComposeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirValueSetComposeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirValueSetComposeListEnumerator.GetCurrent : TFhirValueSetCompose;
begin
  Result := FList[FIndex];
end;

function TFhirValueSetComposeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirValueSetComposeList }
procedure TFhirValueSetComposeList.AddItem(value: TFhirValueSetCompose);
begin
  assert(value.ClassName = 'TFhirValueSetCompose', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetCompose');
  add(value);
end;

function TFhirValueSetComposeList.Append: TFhirValueSetCompose;
begin
  result := TFhirValueSetCompose.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetComposeList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetComposeList.GetEnumerator : TFhirValueSetComposeListEnumerator;
begin
  result := TFhirValueSetComposeListEnumerator.Create(self.link);
end;

function TFhirValueSetComposeList.Clone: TFhirValueSetComposeList;
begin
  result := TFhirValueSetComposeList(inherited Clone);
end;

function TFhirValueSetComposeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetComposeList.GetItemN(index: Integer): TFhirValueSetCompose;
begin
  result := TFhirValueSetCompose(ObjectByIndex[index]);
end;

function TFhirValueSetComposeList.ItemClass: TFslObjectClass;
begin
  result := TFhirValueSetCompose;
end;
function TFhirValueSetComposeList.IndexOf(value: TFhirValueSetCompose): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirValueSetComposeList.Insert(index: Integer): TFhirValueSetCompose;
begin
  result := TFhirValueSetCompose.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetComposeList.InsertItem(index: Integer; value: TFhirValueSetCompose);
begin
  assert(value is TFhirValueSetCompose);
  Inherited Insert(index, value);
end;

function TFhirValueSetComposeList.Item(index: Integer): TFhirValueSetCompose;
begin
  result := TFhirValueSetCompose(ObjectByIndex[index]);
end;

function TFhirValueSetComposeList.Link: TFhirValueSetComposeList;
begin
  result := TFhirValueSetComposeList(inherited Link);
end;

procedure TFhirValueSetComposeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetComposeList.SetItemByIndex(index: Integer; value: TFhirValueSetCompose);
begin
  assert(value is TFhirValueSetCompose);
  FhirValueSetComposes[index] := value;
end;

procedure TFhirValueSetComposeList.SetItemN(index: Integer; value: TFhirValueSetCompose);
begin
  assert(value is TFhirValueSetCompose);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetComposeInclude }

constructor TFhirValueSetComposeInclude.Create;
begin
  inherited;
end;

destructor TFhirValueSetComposeInclude.Destroy;
begin
  FSystem.free;
  FVersion.free;
  FConceptList.Free;
  FFilterList.Free;
  FValueSetList.Free;
  inherited;
end;

procedure TFhirValueSetComposeInclude.Assign(oSource : TFslObject);
begin
  inherited;
  systemElement := TFhirValueSetComposeInclude(oSource).systemElement.Clone;
  versionElement := TFhirValueSetComposeInclude(oSource).versionElement.Clone;
  if (TFhirValueSetComposeInclude(oSource).FConceptList = nil) then
  begin
    FConceptList.free;
    FConceptList := nil;
  end
  else
  begin
    if FConceptList = nil then
      FConceptList := TFhirValueSetComposeIncludeConceptList.Create;
    FConceptList.Assign(TFhirValueSetComposeInclude(oSource).FConceptList);
  end;
  if (TFhirValueSetComposeInclude(oSource).FFilterList = nil) then
  begin
    FFilterList.free;
    FFilterList := nil;
  end
  else
  begin
    if FFilterList = nil then
      FFilterList := TFhirValueSetComposeIncludeFilterList.Create;
    FFilterList.Assign(TFhirValueSetComposeInclude(oSource).FFilterList);
  end;
  if (TFhirValueSetComposeInclude(oSource).FValueSetList = nil) then
  begin
    FValueSetList.free;
    FValueSetList := nil;
  end
  else
  begin
    if FValueSetList = nil then
      FValueSetList := TFhirUriList.Create;
    FValueSetList.Assign(TFhirValueSetComposeInclude(oSource).FValueSetList);
  end;
end;

procedure TFhirValueSetComposeInclude.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'system') Then
     list.add(self.link, 'system', FSystem.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'concept') Then
    list.addAll(self, 'concept', FConceptList);
  if (child_name = 'filter') Then
    list.addAll(self, 'filter', FFilterList);
  if (child_name = 'valueSet') Then
    list.addAll(self, 'valueSet', FValueSetList);
end;

procedure TFhirValueSetComposeInclude.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'system', 'uri', false, TFhirUri, FSystem.Link));{2}
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));{2}
  oList.add(TFHIRProperty.create(self, 'concept', '', true, TFhirValueSetComposeIncludeConcept, FConceptList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'filter', '', true, TFhirValueSetComposeIncludeFilter, FFilterList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'valueSet', 'uri', true, TFhirUri, FValueSetList.Link)){3};
end;

function TFhirValueSetComposeInclude.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'system') then
  begin
    SystemElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'concept') then
  begin
    ConceptList.add(propValue as TFhirValueSetComposeIncludeConcept){2a};
    result := propValue;
  end
  else if (propName = 'filter') then
  begin
    FilterList.add(propValue as TFhirValueSetComposeIncludeFilter){2a};
    result := propValue;
  end
  else if (propName = 'valueSet') then
  begin
    ValueSetList.add(asUri(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirValueSetComposeInclude.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'concept') then ConceptList.insertItem(index, propValue as TFhirValueSetComposeIncludeConcept){2a}
  else if (propName = 'filter') then FilterList.insertItem(index, propValue as TFhirValueSetComposeIncludeFilter){2a}
  else if (propName = 'valueSet') then ValueSetList.insertItem(index, asUri(propValue)){2}
  else inherited;
end;

function TFhirValueSetComposeInclude.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'system') then result := TFhirUri.create() {5b}
  else if (propName = 'version') then result := TFhirString.create() {5b}
  else if (propName = 'concept') then result := ConceptList.new(){2}
  else if (propName = 'filter') then result := FilterList.new(){2}
  else if (propName = 'valueSet') then result := ValueSetList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirValueSetComposeInclude.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'system') then result := 'uri'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'concept') then result := ''
  else if (propName = 'filter') then result := ''
  else if (propName = 'valueSet') then result := 'uri'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirValueSetComposeInclude.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'system') then SystemElement := nil
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'concept') then deletePropertyValue('concept', ConceptList, value) {2}
  else if (propName = 'filter') then deletePropertyValue('filter', FilterList, value) {2}
  else if (propName = 'valueSet') then deletePropertyValue('valueSet', ValueSetList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirValueSetComposeInclude.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'system') then SystemElement := asUri(new){5b}
  else if (propName = 'version') then VersionElement := asString(new){5b}
  else if (propName = 'concept') then replacePropertyValue('concept', ConceptList, existing, new) {2}
  else if (propName = 'filter') then replacePropertyValue('filter', FilterList, existing, new) {2}
  else if (propName = 'valueSet') then replacePropertyValue('valueSet', ValueSetList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirValueSetComposeInclude.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'concept') then ConceptList.move(source, destination){2a}
  else if (propName = 'filter') then FilterList.move(source, destination){2a}
  else if (propName = 'valueSet') then ValueSetList.move(source, destination){2}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirValueSetComposeInclude.fhirType : string;
begin
  result := 'include';
end;

function TFhirValueSetComposeInclude.Link : TFhirValueSetComposeInclude;
begin
  result := TFhirValueSetComposeInclude(inherited Link);
end;

function TFhirValueSetComposeInclude.Clone : TFhirValueSetComposeInclude;
begin
  result := TFhirValueSetComposeInclude(inherited Clone);
end;

function TFhirValueSetComposeInclude.equals(other : TObject) : boolean;
var
  o : TFhirValueSetComposeInclude;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirValueSetComposeInclude)) then
    result := false
  else
  begin
    o := TFhirValueSetComposeInclude(other);
    result := compareDeep(systemElement, o.systemElement, true) and compareDeep(versionElement, o.versionElement, true) and
      compareDeep(conceptList, o.conceptList, true) and compareDeep(filterList, o.filterList, true) and
      compareDeep(valueSetList, o.valueSetList, true);
  end;
end;

function TFhirValueSetComposeInclude.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSystem) and isEmptyProp(FVersion) and isEmptyProp(FconceptList) and isEmptyProp(FfilterList) and isEmptyProp(FvalueSetList);
end;

procedure TFhirValueSetComposeInclude.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('system');
  fields.add('version');
  fields.add('concept');
  fields.add('filter');
  fields.add('valueSet');
end;

{ TFhirValueSetComposeInclude }

Procedure TFhirValueSetComposeInclude.SetSystem(value : TFhirUri);
begin
  FSystem.free;
  FSystem := value;
end;

Function TFhirValueSetComposeInclude.GetSystemST : String;
begin
  if FSystem = nil then
    result := ''
  else
    result := FSystem.value;
end;

Procedure TFhirValueSetComposeInclude.SetSystemST(value : String);
begin
  if value <> '' then
  begin
    if FSystem = nil then
      FSystem := TFhirUri.create;
    FSystem.value := value
  end
  else if FSystem <> nil then
    FSystem.value := '';
end;

Procedure TFhirValueSetComposeInclude.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

Function TFhirValueSetComposeInclude.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

Procedure TFhirValueSetComposeInclude.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

Function TFhirValueSetComposeInclude.GetConceptList : TFhirValueSetComposeIncludeConceptList;
begin
  if FConceptList = nil then
    FConceptList := TFhirValueSetComposeIncludeConceptList.Create;
  result := FConceptList;
end;

Function TFhirValueSetComposeInclude.GetHasConceptList : boolean;
begin
  result := (FConceptList <> nil) and (FConceptList.count > 0);
end;

Function TFhirValueSetComposeInclude.GetFilterList : TFhirValueSetComposeIncludeFilterList;
begin
  if FFilterList = nil then
    FFilterList := TFhirValueSetComposeIncludeFilterList.Create;
  result := FFilterList;
end;

Function TFhirValueSetComposeInclude.GetHasFilterList : boolean;
begin
  result := (FFilterList <> nil) and (FFilterList.count > 0);
end;

Function TFhirValueSetComposeInclude.GetValueSetList : TFhirUriList;
begin
  if FValueSetList = nil then
    FValueSetList := TFhirUriList.Create;
  result := FValueSetList;
end;

Function TFhirValueSetComposeInclude.GetHasValueSetList : boolean;
begin
  result := (FValueSetList <> nil) and (FValueSetList.count > 0);
end;

function TFhirValueSetComposeInclude.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSystem.sizeInBytes);
  inc(result, FVersion.sizeInBytes);
  inc(result, FconceptList.sizeInBytes);
  inc(result, FfilterList.sizeInBytes);
  inc(result, FvalueSetList.sizeInBytes);
end;

{ TFhirValueSetComposeIncludeListEnumerator }

Constructor TFhirValueSetComposeIncludeListEnumerator.Create(list : TFhirValueSetComposeIncludeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirValueSetComposeIncludeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirValueSetComposeIncludeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirValueSetComposeIncludeListEnumerator.GetCurrent : TFhirValueSetComposeInclude;
begin
  Result := FList[FIndex];
end;

function TFhirValueSetComposeIncludeListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirValueSetComposeIncludeList }
procedure TFhirValueSetComposeIncludeList.AddItem(value: TFhirValueSetComposeInclude);
begin
  assert(value.ClassName = 'TFhirValueSetComposeInclude', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetComposeInclude');
  add(value);
end;

function TFhirValueSetComposeIncludeList.Append: TFhirValueSetComposeInclude;
begin
  result := TFhirValueSetComposeInclude.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetComposeIncludeList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetComposeIncludeList.GetEnumerator : TFhirValueSetComposeIncludeListEnumerator;
begin
  result := TFhirValueSetComposeIncludeListEnumerator.Create(self.link);
end;

function TFhirValueSetComposeIncludeList.Clone: TFhirValueSetComposeIncludeList;
begin
  result := TFhirValueSetComposeIncludeList(inherited Clone);
end;

function TFhirValueSetComposeIncludeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetComposeIncludeList.GetItemN(index: Integer): TFhirValueSetComposeInclude;
begin
  result := TFhirValueSetComposeInclude(ObjectByIndex[index]);
end;

function TFhirValueSetComposeIncludeList.ItemClass: TFslObjectClass;
begin
  result := TFhirValueSetComposeInclude;
end;
function TFhirValueSetComposeIncludeList.IndexOf(value: TFhirValueSetComposeInclude): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirValueSetComposeIncludeList.Insert(index: Integer): TFhirValueSetComposeInclude;
begin
  result := TFhirValueSetComposeInclude.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetComposeIncludeList.InsertItem(index: Integer; value: TFhirValueSetComposeInclude);
begin
  assert(value is TFhirValueSetComposeInclude);
  Inherited Insert(index, value);
end;

function TFhirValueSetComposeIncludeList.Item(index: Integer): TFhirValueSetComposeInclude;
begin
  result := TFhirValueSetComposeInclude(ObjectByIndex[index]);
end;

function TFhirValueSetComposeIncludeList.Link: TFhirValueSetComposeIncludeList;
begin
  result := TFhirValueSetComposeIncludeList(inherited Link);
end;

procedure TFhirValueSetComposeIncludeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetComposeIncludeList.SetItemByIndex(index: Integer; value: TFhirValueSetComposeInclude);
begin
  assert(value is TFhirValueSetComposeInclude);
  FhirValueSetComposeIncludes[index] := value;
end;

procedure TFhirValueSetComposeIncludeList.SetItemN(index: Integer; value: TFhirValueSetComposeInclude);
begin
  assert(value is TFhirValueSetComposeInclude);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetComposeIncludeConcept }

constructor TFhirValueSetComposeIncludeConcept.Create;
begin
  inherited;
end;

destructor TFhirValueSetComposeIncludeConcept.Destroy;
begin
  FCode.free;
  FDisplay.free;
  FDesignationList.Free;
  inherited;
end;

procedure TFhirValueSetComposeIncludeConcept.Assign(oSource : TFslObject);
begin
  inherited;
  codeElement := TFhirValueSetComposeIncludeConcept(oSource).codeElement.Clone;
  displayElement := TFhirValueSetComposeIncludeConcept(oSource).displayElement.Clone;
  if (TFhirValueSetComposeIncludeConcept(oSource).FDesignationList = nil) then
  begin
    FDesignationList.free;
    FDesignationList := nil;
  end
  else
  begin
    if FDesignationList = nil then
      FDesignationList := TFhirValueSetComposeIncludeConceptDesignationList.Create;
    FDesignationList.Assign(TFhirValueSetComposeIncludeConcept(oSource).FDesignationList);
  end;
end;

procedure TFhirValueSetComposeIncludeConcept.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'display') Then
     list.add(self.link, 'display', FDisplay.Link);
  if (child_name = 'designation') Then
    list.addAll(self, 'designation', FDesignationList);
end;

procedure TFhirValueSetComposeIncludeConcept.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirCode, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'display', 'string', false, TFhirString, FDisplay.Link));{2}
  oList.add(TFHIRProperty.create(self, 'designation', '', true, TFhirValueSetComposeIncludeConceptDesignation, FDesignationList.Link)){3};
end;

function TFhirValueSetComposeIncludeConcept.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'display') then
  begin
    DisplayElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'designation') then
  begin
    DesignationList.add(propValue as TFhirValueSetComposeIncludeConceptDesignation){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirValueSetComposeIncludeConcept.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'designation') then DesignationList.insertItem(index, propValue as TFhirValueSetComposeIncludeConceptDesignation){2a}
  else inherited;
end;

function TFhirValueSetComposeIncludeConcept.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCode.create() {5b}
  else if (propName = 'display') then result := TFhirString.create() {5b}
  else if (propName = 'designation') then result := DesignationList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirValueSetComposeIncludeConcept.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'code'
  else if (propName = 'display') then result := 'string'
  else if (propName = 'designation') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirValueSetComposeIncludeConcept.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'display') then DisplayElement := nil
  else if (propName = 'designation') then deletePropertyValue('designation', DesignationList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirValueSetComposeIncludeConcept.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asCode(new){5b}
  else if (propName = 'display') then DisplayElement := asString(new){5b}
  else if (propName = 'designation') then replacePropertyValue('designation', DesignationList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirValueSetComposeIncludeConcept.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'designation') then DesignationList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirValueSetComposeIncludeConcept.fhirType : string;
begin
  result := 'concept';
end;

function TFhirValueSetComposeIncludeConcept.Link : TFhirValueSetComposeIncludeConcept;
begin
  result := TFhirValueSetComposeIncludeConcept(inherited Link);
end;

function TFhirValueSetComposeIncludeConcept.Clone : TFhirValueSetComposeIncludeConcept;
begin
  result := TFhirValueSetComposeIncludeConcept(inherited Clone);
end;

function TFhirValueSetComposeIncludeConcept.equals(other : TObject) : boolean;
var
  o : TFhirValueSetComposeIncludeConcept;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirValueSetComposeIncludeConcept)) then
    result := false
  else
  begin
    o := TFhirValueSetComposeIncludeConcept(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(displayElement, o.displayElement, true) and
      compareDeep(designationList, o.designationList, true);
  end;
end;

function TFhirValueSetComposeIncludeConcept.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FDisplay) and isEmptyProp(FdesignationList);
end;

procedure TFhirValueSetComposeIncludeConcept.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('code');
  fields.add('display');
  fields.add('designation');
end;

{ TFhirValueSetComposeIncludeConcept }

Procedure TFhirValueSetComposeIncludeConcept.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirValueSetComposeIncludeConcept.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

Procedure TFhirValueSetComposeIncludeConcept.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

Procedure TFhirValueSetComposeIncludeConcept.SetDisplay(value : TFhirString);
begin
  FDisplay.free;
  FDisplay := value;
end;

Function TFhirValueSetComposeIncludeConcept.GetDisplayST : String;
begin
  if FDisplay = nil then
    result := ''
  else
    result := FDisplay.value;
end;

Procedure TFhirValueSetComposeIncludeConcept.SetDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FDisplay = nil then
      FDisplay := TFhirString.create;
    FDisplay.value := value
  end
  else if FDisplay <> nil then
    FDisplay.value := '';
end;

Function TFhirValueSetComposeIncludeConcept.GetDesignationList : TFhirValueSetComposeIncludeConceptDesignationList;
begin
  if FDesignationList = nil then
    FDesignationList := TFhirValueSetComposeIncludeConceptDesignationList.Create;
  result := FDesignationList;
end;

Function TFhirValueSetComposeIncludeConcept.GetHasDesignationList : boolean;
begin
  result := (FDesignationList <> nil) and (FDesignationList.count > 0);
end;

function TFhirValueSetComposeIncludeConcept.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FCode.sizeInBytes);
  inc(result, FDisplay.sizeInBytes);
  inc(result, FdesignationList.sizeInBytes);
end;

{ TFhirValueSetComposeIncludeConceptListEnumerator }

Constructor TFhirValueSetComposeIncludeConceptListEnumerator.Create(list : TFhirValueSetComposeIncludeConceptList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirValueSetComposeIncludeConceptListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirValueSetComposeIncludeConceptListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirValueSetComposeIncludeConceptListEnumerator.GetCurrent : TFhirValueSetComposeIncludeConcept;
begin
  Result := FList[FIndex];
end;

function TFhirValueSetComposeIncludeConceptListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirValueSetComposeIncludeConceptList }
procedure TFhirValueSetComposeIncludeConceptList.AddItem(value: TFhirValueSetComposeIncludeConcept);
begin
  assert(value.ClassName = 'TFhirValueSetComposeIncludeConcept', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetComposeIncludeConcept');
  add(value);
end;

function TFhirValueSetComposeIncludeConceptList.Append: TFhirValueSetComposeIncludeConcept;
begin
  result := TFhirValueSetComposeIncludeConcept.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetComposeIncludeConceptList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetComposeIncludeConceptList.GetEnumerator : TFhirValueSetComposeIncludeConceptListEnumerator;
begin
  result := TFhirValueSetComposeIncludeConceptListEnumerator.Create(self.link);
end;

function TFhirValueSetComposeIncludeConceptList.Clone: TFhirValueSetComposeIncludeConceptList;
begin
  result := TFhirValueSetComposeIncludeConceptList(inherited Clone);
end;

function TFhirValueSetComposeIncludeConceptList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetComposeIncludeConceptList.GetItemN(index: Integer): TFhirValueSetComposeIncludeConcept;
begin
  result := TFhirValueSetComposeIncludeConcept(ObjectByIndex[index]);
end;

function TFhirValueSetComposeIncludeConceptList.ItemClass: TFslObjectClass;
begin
  result := TFhirValueSetComposeIncludeConcept;
end;
function TFhirValueSetComposeIncludeConceptList.IndexOf(value: TFhirValueSetComposeIncludeConcept): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirValueSetComposeIncludeConceptList.Insert(index: Integer): TFhirValueSetComposeIncludeConcept;
begin
  result := TFhirValueSetComposeIncludeConcept.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetComposeIncludeConceptList.InsertItem(index: Integer; value: TFhirValueSetComposeIncludeConcept);
begin
  assert(value is TFhirValueSetComposeIncludeConcept);
  Inherited Insert(index, value);
end;

function TFhirValueSetComposeIncludeConceptList.Item(index: Integer): TFhirValueSetComposeIncludeConcept;
begin
  result := TFhirValueSetComposeIncludeConcept(ObjectByIndex[index]);
end;

function TFhirValueSetComposeIncludeConceptList.Link: TFhirValueSetComposeIncludeConceptList;
begin
  result := TFhirValueSetComposeIncludeConceptList(inherited Link);
end;

procedure TFhirValueSetComposeIncludeConceptList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetComposeIncludeConceptList.SetItemByIndex(index: Integer; value: TFhirValueSetComposeIncludeConcept);
begin
  assert(value is TFhirValueSetComposeIncludeConcept);
  FhirValueSetComposeIncludeConcepts[index] := value;
end;

procedure TFhirValueSetComposeIncludeConceptList.SetItemN(index: Integer; value: TFhirValueSetComposeIncludeConcept);
begin
  assert(value is TFhirValueSetComposeIncludeConcept);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetComposeIncludeConceptDesignation }

constructor TFhirValueSetComposeIncludeConceptDesignation.Create;
begin
  inherited;
end;

destructor TFhirValueSetComposeIncludeConceptDesignation.Destroy;
begin
  FLanguage.free;
  FUse.free;
  FValue.free;
  inherited;
end;

procedure TFhirValueSetComposeIncludeConceptDesignation.Assign(oSource : TFslObject);
begin
  inherited;
  languageElement := TFhirValueSetComposeIncludeConceptDesignation(oSource).languageElement.Clone;
  use := TFhirValueSetComposeIncludeConceptDesignation(oSource).use.Clone;
  valueElement := TFhirValueSetComposeIncludeConceptDesignation(oSource).valueElement.Clone;
end;

procedure TFhirValueSetComposeIncludeConceptDesignation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'language') Then
     list.add(self.link, 'language', FLanguage.Link);
  if (child_name = 'use') Then
     list.add(self.link, 'use', FUse.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirValueSetComposeIncludeConceptDesignation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'language', 'code', false, TFhirCode, FLanguage.Link));{2}
  oList.add(TFHIRProperty.create(self, 'use', 'Coding', false, TFhirCoding, FUse.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value', 'string', false, TFhirString, FValue.Link));{2}
end;

function TFhirValueSetComposeIncludeConceptDesignation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'language') then
  begin
    LanguageElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'use') then
  begin
    Use := propValue as TFhirCoding{4b};
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asString(propValue){5a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirValueSetComposeIncludeConceptDesignation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirValueSetComposeIncludeConceptDesignation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'language') then result := TFhirCode.create() {5b}
  else if (propName = 'use') then result := TFhirCoding.create(){4b}
  else if (propName = 'value') then result := TFhirString.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirValueSetComposeIncludeConceptDesignation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'language') then result := 'code'
  else if (propName = 'use') then result := 'Coding'
  else if (propName = 'value') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirValueSetComposeIncludeConceptDesignation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'language') then LanguageElement := nil
  else if (propName = 'use') then UseElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirValueSetComposeIncludeConceptDesignation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'language') then LanguageElement := asCode(new){5b}
  else if (propName = 'use') then UseElement := new as TFhirCoding{4}
  else if (propName = 'value') then ValueElement := asString(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirValueSetComposeIncludeConceptDesignation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirValueSetComposeIncludeConceptDesignation.fhirType : string;
begin
  result := 'designation';
end;

function TFhirValueSetComposeIncludeConceptDesignation.Link : TFhirValueSetComposeIncludeConceptDesignation;
begin
  result := TFhirValueSetComposeIncludeConceptDesignation(inherited Link);
end;

function TFhirValueSetComposeIncludeConceptDesignation.Clone : TFhirValueSetComposeIncludeConceptDesignation;
begin
  result := TFhirValueSetComposeIncludeConceptDesignation(inherited Clone);
end;

function TFhirValueSetComposeIncludeConceptDesignation.equals(other : TObject) : boolean;
var
  o : TFhirValueSetComposeIncludeConceptDesignation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirValueSetComposeIncludeConceptDesignation)) then
    result := false
  else
  begin
    o := TFhirValueSetComposeIncludeConceptDesignation(other);
    result := compareDeep(languageElement, o.languageElement, true) and compareDeep(useElement, o.useElement, true) and
      compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirValueSetComposeIncludeConceptDesignation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLanguage) and isEmptyProp(FUse) and isEmptyProp(FValue);
end;

procedure TFhirValueSetComposeIncludeConceptDesignation.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('language');
  fields.add('use');
  fields.add('value');
end;

{ TFhirValueSetComposeIncludeConceptDesignation }

Procedure TFhirValueSetComposeIncludeConceptDesignation.SetLanguage(value : TFhirCode);
begin
  FLanguage.free;
  FLanguage := value;
end;

Function TFhirValueSetComposeIncludeConceptDesignation.GetLanguageST : String;
begin
  if FLanguage = nil then
    result := ''
  else
    result := FLanguage.value;
end;

Procedure TFhirValueSetComposeIncludeConceptDesignation.SetLanguageST(value : String);
begin
  if value <> '' then
  begin
    if FLanguage = nil then
      FLanguage := TFhirCode.create;
    FLanguage.value := value
  end
  else if FLanguage <> nil then
    FLanguage.value := '';
end;

Procedure TFhirValueSetComposeIncludeConceptDesignation.SetUse(value : TFhirCoding);
begin
  FUse.free;
  FUse := value;
end;

Procedure TFhirValueSetComposeIncludeConceptDesignation.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirValueSetComposeIncludeConceptDesignation.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

Procedure TFhirValueSetComposeIncludeConceptDesignation.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

function TFhirValueSetComposeIncludeConceptDesignation.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FLanguage.sizeInBytes);
  inc(result, FUse.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirValueSetComposeIncludeConceptDesignationListEnumerator }

Constructor TFhirValueSetComposeIncludeConceptDesignationListEnumerator.Create(list : TFhirValueSetComposeIncludeConceptDesignationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirValueSetComposeIncludeConceptDesignationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirValueSetComposeIncludeConceptDesignationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirValueSetComposeIncludeConceptDesignationListEnumerator.GetCurrent : TFhirValueSetComposeIncludeConceptDesignation;
begin
  Result := FList[FIndex];
end;

function TFhirValueSetComposeIncludeConceptDesignationListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirValueSetComposeIncludeConceptDesignationList }
procedure TFhirValueSetComposeIncludeConceptDesignationList.AddItem(value: TFhirValueSetComposeIncludeConceptDesignation);
begin
  assert(value.ClassName = 'TFhirValueSetComposeIncludeConceptDesignation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetComposeIncludeConceptDesignation');
  add(value);
end;

function TFhirValueSetComposeIncludeConceptDesignationList.Append: TFhirValueSetComposeIncludeConceptDesignation;
begin
  result := TFhirValueSetComposeIncludeConceptDesignation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetComposeIncludeConceptDesignationList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetComposeIncludeConceptDesignationList.GetEnumerator : TFhirValueSetComposeIncludeConceptDesignationListEnumerator;
begin
  result := TFhirValueSetComposeIncludeConceptDesignationListEnumerator.Create(self.link);
end;

function TFhirValueSetComposeIncludeConceptDesignationList.Clone: TFhirValueSetComposeIncludeConceptDesignationList;
begin
  result := TFhirValueSetComposeIncludeConceptDesignationList(inherited Clone);
end;

function TFhirValueSetComposeIncludeConceptDesignationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetComposeIncludeConceptDesignationList.GetItemN(index: Integer): TFhirValueSetComposeIncludeConceptDesignation;
begin
  result := TFhirValueSetComposeIncludeConceptDesignation(ObjectByIndex[index]);
end;

function TFhirValueSetComposeIncludeConceptDesignationList.ItemClass: TFslObjectClass;
begin
  result := TFhirValueSetComposeIncludeConceptDesignation;
end;
function TFhirValueSetComposeIncludeConceptDesignationList.IndexOf(value: TFhirValueSetComposeIncludeConceptDesignation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirValueSetComposeIncludeConceptDesignationList.Insert(index: Integer): TFhirValueSetComposeIncludeConceptDesignation;
begin
  result := TFhirValueSetComposeIncludeConceptDesignation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetComposeIncludeConceptDesignationList.InsertItem(index: Integer; value: TFhirValueSetComposeIncludeConceptDesignation);
begin
  assert(value is TFhirValueSetComposeIncludeConceptDesignation);
  Inherited Insert(index, value);
end;

function TFhirValueSetComposeIncludeConceptDesignationList.Item(index: Integer): TFhirValueSetComposeIncludeConceptDesignation;
begin
  result := TFhirValueSetComposeIncludeConceptDesignation(ObjectByIndex[index]);
end;

function TFhirValueSetComposeIncludeConceptDesignationList.Link: TFhirValueSetComposeIncludeConceptDesignationList;
begin
  result := TFhirValueSetComposeIncludeConceptDesignationList(inherited Link);
end;

procedure TFhirValueSetComposeIncludeConceptDesignationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetComposeIncludeConceptDesignationList.SetItemByIndex(index: Integer; value: TFhirValueSetComposeIncludeConceptDesignation);
begin
  assert(value is TFhirValueSetComposeIncludeConceptDesignation);
  FhirValueSetComposeIncludeConceptDesignations[index] := value;
end;

procedure TFhirValueSetComposeIncludeConceptDesignationList.SetItemN(index: Integer; value: TFhirValueSetComposeIncludeConceptDesignation);
begin
  assert(value is TFhirValueSetComposeIncludeConceptDesignation);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetComposeIncludeFilter }

constructor TFhirValueSetComposeIncludeFilter.Create;
begin
  inherited;
end;

destructor TFhirValueSetComposeIncludeFilter.Destroy;
begin
  FProperty_.free;
  FOp.free;
  FValue.free;
  inherited;
end;

procedure TFhirValueSetComposeIncludeFilter.Assign(oSource : TFslObject);
begin
  inherited;
  property_Element := TFhirValueSetComposeIncludeFilter(oSource).property_Element.Clone;
  FOp := TFhirValueSetComposeIncludeFilter(oSource).FOp.Link;
  valueElement := TFhirValueSetComposeIncludeFilter(oSource).valueElement.Clone;
end;

procedure TFhirValueSetComposeIncludeFilter.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'property') Then
     list.add(self.link, 'property', FProperty_.Link);
  if (child_name = 'op') Then
     list.add(self.link, 'op', FOp.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirValueSetComposeIncludeFilter.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'property', 'code', false, TFhirCode, FProperty_.Link));{2}
  oList.add(TFHIRProperty.create(self, 'op', 'code', false, TFHIREnum, FOp.Link));{1}
  oList.add(TFHIRProperty.create(self, 'value', 'code', false, TFhirCode, FValue.Link));{2}
end;

function TFhirValueSetComposeIncludeFilter.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'property') then
  begin
    Property_Element := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'op') then
  begin
    OpElement := asEnum(SYSTEMS_TFhirFilterOperatorEnum, CODES_TFhirFilterOperatorEnum, propValue);
    result := propValue
  end
  else if (propName = 'value') then
  begin
    ValueElement := asCode(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirValueSetComposeIncludeFilter.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirValueSetComposeIncludeFilter.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'property') then result := TFhirCode.create() {5b}
  else if (propName = 'value') then result := TFhirCode.create() {5b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirValueSetComposeIncludeFilter.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'property') then result := 'code'
  else if (propName = 'op') then result := 'code'
  else if (propName = 'value') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirValueSetComposeIncludeFilter.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'property') then Property_Element := nil
  else if (propName = 'op') then OpElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirValueSetComposeIncludeFilter.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'property') then Property_Element := asCode(new){5b}
  else if (propName = 'op') then OpElement := asEnum(SYSTEMS_TFhirFilterOperatorEnum, CODES_TFhirFilterOperatorEnum, new){4}
  else if (propName = 'value') then ValueElement := asCode(new){5b}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirValueSetComposeIncludeFilter.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirValueSetComposeIncludeFilter.fhirType : string;
begin
  result := 'filter';
end;

function TFhirValueSetComposeIncludeFilter.Link : TFhirValueSetComposeIncludeFilter;
begin
  result := TFhirValueSetComposeIncludeFilter(inherited Link);
end;

function TFhirValueSetComposeIncludeFilter.Clone : TFhirValueSetComposeIncludeFilter;
begin
  result := TFhirValueSetComposeIncludeFilter(inherited Clone);
end;

function TFhirValueSetComposeIncludeFilter.equals(other : TObject) : boolean;
var
  o : TFhirValueSetComposeIncludeFilter;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirValueSetComposeIncludeFilter)) then
    result := false
  else
  begin
    o := TFhirValueSetComposeIncludeFilter(other);
    result := compareDeep(property_Element, o.property_Element, true) and compareDeep(opElement, o.opElement, true) and
      compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirValueSetComposeIncludeFilter.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FProperty_) and isEmptyProp(FOp) and isEmptyProp(FValue);
end;

procedure TFhirValueSetComposeIncludeFilter.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('property');
  fields.add('op');
  fields.add('value');
end;

{ TFhirValueSetComposeIncludeFilter }

Procedure TFhirValueSetComposeIncludeFilter.SetProperty_(value : TFhirCode);
begin
  FProperty_.free;
  FProperty_ := value;
end;

Function TFhirValueSetComposeIncludeFilter.GetProperty_ST : String;
begin
  if FProperty_ = nil then
    result := ''
  else
    result := FProperty_.value;
end;

Procedure TFhirValueSetComposeIncludeFilter.SetProperty_ST(value : String);
begin
  if value <> '' then
  begin
    if FProperty_ = nil then
      FProperty_ := TFhirCode.create;
    FProperty_.value := value
  end
  else if FProperty_ <> nil then
    FProperty_.value := '';
end;

Procedure TFhirValueSetComposeIncludeFilter.SetOp(value : TFhirEnum);
begin
  FOp.free;
  FOp := value;
end;

Function TFhirValueSetComposeIncludeFilter.GetOpST : TFhirFilterOperatorEnum;
begin
  if FOp = nil then
    result := TFhirFilterOperatorEnum(0)
  else
    result := TFhirFilterOperatorEnum(StringArrayIndexOfSensitive(CODES_TFhirFilterOperatorEnum, FOp.value));
end;

Procedure TFhirValueSetComposeIncludeFilter.SetOpST(value : TFhirFilterOperatorEnum);
begin
  if ord(value) = 0 then
    OpElement := nil
  else
    OpElement := TFhirEnum.create(SYSTEMS_TFhirFilterOperatorEnum[value], CODES_TFhirFilterOperatorEnum[value]);
end;

Procedure TFhirValueSetComposeIncludeFilter.SetValue(value : TFhirCode);
begin
  FValue.free;
  FValue := value;
end;

Function TFhirValueSetComposeIncludeFilter.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

Procedure TFhirValueSetComposeIncludeFilter.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirCode.create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

function TFhirValueSetComposeIncludeFilter.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FProperty_.sizeInBytes);
  inc(result, FOp.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirValueSetComposeIncludeFilterListEnumerator }

Constructor TFhirValueSetComposeIncludeFilterListEnumerator.Create(list : TFhirValueSetComposeIncludeFilterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirValueSetComposeIncludeFilterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirValueSetComposeIncludeFilterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirValueSetComposeIncludeFilterListEnumerator.GetCurrent : TFhirValueSetComposeIncludeFilter;
begin
  Result := FList[FIndex];
end;

function TFhirValueSetComposeIncludeFilterListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirValueSetComposeIncludeFilterList }
procedure TFhirValueSetComposeIncludeFilterList.AddItem(value: TFhirValueSetComposeIncludeFilter);
begin
  assert(value.ClassName = 'TFhirValueSetComposeIncludeFilter', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetComposeIncludeFilter');
  add(value);
end;

function TFhirValueSetComposeIncludeFilterList.Append: TFhirValueSetComposeIncludeFilter;
begin
  result := TFhirValueSetComposeIncludeFilter.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetComposeIncludeFilterList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetComposeIncludeFilterList.GetEnumerator : TFhirValueSetComposeIncludeFilterListEnumerator;
begin
  result := TFhirValueSetComposeIncludeFilterListEnumerator.Create(self.link);
end;

function TFhirValueSetComposeIncludeFilterList.Clone: TFhirValueSetComposeIncludeFilterList;
begin
  result := TFhirValueSetComposeIncludeFilterList(inherited Clone);
end;

function TFhirValueSetComposeIncludeFilterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetComposeIncludeFilterList.GetItemN(index: Integer): TFhirValueSetComposeIncludeFilter;
begin
  result := TFhirValueSetComposeIncludeFilter(ObjectByIndex[index]);
end;

function TFhirValueSetComposeIncludeFilterList.ItemClass: TFslObjectClass;
begin
  result := TFhirValueSetComposeIncludeFilter;
end;
function TFhirValueSetComposeIncludeFilterList.IndexOf(value: TFhirValueSetComposeIncludeFilter): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirValueSetComposeIncludeFilterList.Insert(index: Integer): TFhirValueSetComposeIncludeFilter;
begin
  result := TFhirValueSetComposeIncludeFilter.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetComposeIncludeFilterList.InsertItem(index: Integer; value: TFhirValueSetComposeIncludeFilter);
begin
  assert(value is TFhirValueSetComposeIncludeFilter);
  Inherited Insert(index, value);
end;

function TFhirValueSetComposeIncludeFilterList.Item(index: Integer): TFhirValueSetComposeIncludeFilter;
begin
  result := TFhirValueSetComposeIncludeFilter(ObjectByIndex[index]);
end;

function TFhirValueSetComposeIncludeFilterList.Link: TFhirValueSetComposeIncludeFilterList;
begin
  result := TFhirValueSetComposeIncludeFilterList(inherited Link);
end;

procedure TFhirValueSetComposeIncludeFilterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetComposeIncludeFilterList.SetItemByIndex(index: Integer; value: TFhirValueSetComposeIncludeFilter);
begin
  assert(value is TFhirValueSetComposeIncludeFilter);
  FhirValueSetComposeIncludeFilters[index] := value;
end;

procedure TFhirValueSetComposeIncludeFilterList.SetItemN(index: Integer; value: TFhirValueSetComposeIncludeFilter);
begin
  assert(value is TFhirValueSetComposeIncludeFilter);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetExpansion }

constructor TFhirValueSetExpansion.Create;
begin
  inherited;
end;

destructor TFhirValueSetExpansion.Destroy;
begin
  FIdentifier.free;
  FTimestamp.free;
  FTotal.free;
  FOffset.free;
  FParameterList.Free;
  FContainsList.Free;
  inherited;
end;

procedure TFhirValueSetExpansion.Assign(oSource : TFslObject);
begin
  inherited;
  identifierElement := TFhirValueSetExpansion(oSource).identifierElement.Clone;
  timestampElement := TFhirValueSetExpansion(oSource).timestampElement.Clone;
  totalElement := TFhirValueSetExpansion(oSource).totalElement.Clone;
  offsetElement := TFhirValueSetExpansion(oSource).offsetElement.Clone;
  if (TFhirValueSetExpansion(oSource).FParameterList = nil) then
  begin
    FParameterList.free;
    FParameterList := nil;
  end
  else
  begin
    if FParameterList = nil then
      FParameterList := TFhirValueSetExpansionParameterList.Create;
    FParameterList.Assign(TFhirValueSetExpansion(oSource).FParameterList);
  end;
  if (TFhirValueSetExpansion(oSource).FContainsList = nil) then
  begin
    FContainsList.free;
    FContainsList := nil;
  end
  else
  begin
    if FContainsList = nil then
      FContainsList := TFhirValueSetExpansionContainsList.Create;
    FContainsList.Assign(TFhirValueSetExpansion(oSource).FContainsList);
  end;
end;

procedure TFhirValueSetExpansion.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'timestamp') Then
     list.add(self.link, 'timestamp', FTimestamp.Link);
  if (child_name = 'total') Then
     list.add(self.link, 'total', FTotal.Link);
  if (child_name = 'offset') Then
     list.add(self.link, 'offset', FOffset.Link);
  if (child_name = 'parameter') Then
    list.addAll(self, 'parameter', FParameterList);
  if (child_name = 'contains') Then
    list.addAll(self, 'contains', FContainsList);
end;

procedure TFhirValueSetExpansion.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'uri', false, TFhirUri, FIdentifier.Link));{2}
  oList.add(TFHIRProperty.create(self, 'timestamp', 'dateTime', false, TFhirDateTime, FTimestamp.Link));{2}
  oList.add(TFHIRProperty.create(self, 'total', 'integer', false, TFhirInteger, FTotal.Link));{2}
  oList.add(TFHIRProperty.create(self, 'offset', 'integer', false, TFhirInteger, FOffset.Link));{2}
  oList.add(TFHIRProperty.create(self, 'parameter', '', true, TFhirValueSetExpansionParameter, FParameterList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'contains', '', true, TFhirValueSetExpansionContains, FContainsList.Link)){3};
end;

function TFhirValueSetExpansion.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'timestamp') then
  begin
    TimestampElement := asDateTime(propValue){5a};
    result := propValue;
  end
  else if (propName = 'total') then
  begin
    TotalElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'offset') then
  begin
    OffsetElement := asInteger(propValue){5a};
    result := propValue;
  end
  else if (propName = 'parameter') then
  begin
    ParameterList.add(propValue as TFhirValueSetExpansionParameter){2a};
    result := propValue;
  end
  else if (propName = 'contains') then
  begin
    ContainsList.add(propValue as TFhirValueSetExpansionContains){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirValueSetExpansion.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'parameter') then ParameterList.insertItem(index, propValue as TFhirValueSetExpansionParameter){2a}
  else if (propName = 'contains') then ContainsList.insertItem(index, propValue as TFhirValueSetExpansionContains){2a}
  else inherited;
end;

function TFhirValueSetExpansion.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirUri.create() {5b}
  else if (propName = 'timestamp') then result := TFhirDateTime.create() {5b}
  else if (propName = 'total') then result := TFhirInteger.create() {5b}
  else if (propName = 'offset') then result := TFhirInteger.create() {5b}
  else if (propName = 'parameter') then result := ParameterList.new(){2}
  else if (propName = 'contains') then result := ContainsList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirValueSetExpansion.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'uri'
  else if (propName = 'timestamp') then result := 'dateTime'
  else if (propName = 'total') then result := 'integer'
  else if (propName = 'offset') then result := 'integer'
  else if (propName = 'parameter') then result := ''
  else if (propName = 'contains') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirValueSetExpansion.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'timestamp') then TimestampElement := nil
  else if (propName = 'total') then TotalElement := nil
  else if (propName = 'offset') then OffsetElement := nil
  else if (propName = 'parameter') then deletePropertyValue('parameter', ParameterList, value) {2}
  else if (propName = 'contains') then deletePropertyValue('contains', ContainsList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirValueSetExpansion.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := asUri(new){5b}
  else if (propName = 'timestamp') then TimestampElement := asDateTime(new){5b}
  else if (propName = 'total') then TotalElement := asInteger(new){5b}
  else if (propName = 'offset') then OffsetElement := asInteger(new){5b}
  else if (propName = 'parameter') then replacePropertyValue('parameter', ParameterList, existing, new) {2}
  else if (propName = 'contains') then replacePropertyValue('contains', ContainsList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirValueSetExpansion.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'parameter') then ParameterList.move(source, destination){2a}
  else if (propName = 'contains') then ContainsList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirValueSetExpansion.fhirType : string;
begin
  result := 'expansion';
end;

function TFhirValueSetExpansion.Link : TFhirValueSetExpansion;
begin
  result := TFhirValueSetExpansion(inherited Link);
end;

function TFhirValueSetExpansion.Clone : TFhirValueSetExpansion;
begin
  result := TFhirValueSetExpansion(inherited Clone);
end;

function TFhirValueSetExpansion.equals(other : TObject) : boolean;
var
  o : TFhirValueSetExpansion;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirValueSetExpansion)) then
    result := false
  else
  begin
    o := TFhirValueSetExpansion(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(timestampElement, o.timestampElement, true) and
      compareDeep(totalElement, o.totalElement, true) and compareDeep(offsetElement, o.offsetElement, true) and
      compareDeep(parameterList, o.parameterList, true) and compareDeep(containsList, o.containsList, true);
  end;
end;

function TFhirValueSetExpansion.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FTimestamp) and isEmptyProp(FTotal) and isEmptyProp(FOffset) and isEmptyProp(FparameterList) and isEmptyProp(FcontainsList);
end;

procedure TFhirValueSetExpansion.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('timestamp');
  fields.add('total');
  fields.add('offset');
  fields.add('parameter');
  fields.add('contains');
end;

{ TFhirValueSetExpansion }

Procedure TFhirValueSetExpansion.SetIdentifier(value : TFhirUri);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

Function TFhirValueSetExpansion.GetIdentifierST : String;
begin
  if FIdentifier = nil then
    result := ''
  else
    result := FIdentifier.value;
end;

Procedure TFhirValueSetExpansion.SetIdentifierST(value : String);
begin
  if value <> '' then
  begin
    if FIdentifier = nil then
      FIdentifier := TFhirUri.create;
    FIdentifier.value := value
  end
  else if FIdentifier <> nil then
    FIdentifier.value := '';
end;

Procedure TFhirValueSetExpansion.SetTimestamp(value : TFhirDateTime);
begin
  FTimestamp.free;
  FTimestamp := value;
end;

Function TFhirValueSetExpansion.GetTimestampST : TFslDateTime;
begin
  if FTimestamp = nil then
    result := TFslDateTime.makeNull
  else
    result := FTimestamp.value;
end;

Procedure TFhirValueSetExpansion.SetTimestampST(value : TFslDateTime);
begin
  if FTimestamp = nil then
    FTimestamp := TFhirDateTime.create;
  FTimestamp.value := value
end;

Procedure TFhirValueSetExpansion.SetTotal(value : TFhirInteger);
begin
  FTotal.free;
  FTotal := value;
end;

Function TFhirValueSetExpansion.GetTotalST : String;
begin
  if FTotal = nil then
    result := ''
  else
    result := FTotal.value;
end;

Procedure TFhirValueSetExpansion.SetTotalST(value : String);
begin
  if value <> '' then
  begin
    if FTotal = nil then
      FTotal := TFhirInteger.create;
    FTotal.value := value
  end
  else if FTotal <> nil then
    FTotal.value := '';
end;

Procedure TFhirValueSetExpansion.SetOffset(value : TFhirInteger);
begin
  FOffset.free;
  FOffset := value;
end;

Function TFhirValueSetExpansion.GetOffsetST : String;
begin
  if FOffset = nil then
    result := ''
  else
    result := FOffset.value;
end;

Procedure TFhirValueSetExpansion.SetOffsetST(value : String);
begin
  if value <> '' then
  begin
    if FOffset = nil then
      FOffset := TFhirInteger.create;
    FOffset.value := value
  end
  else if FOffset <> nil then
    FOffset.value := '';
end;

Function TFhirValueSetExpansion.GetParameterList : TFhirValueSetExpansionParameterList;
begin
  if FParameterList = nil then
    FParameterList := TFhirValueSetExpansionParameterList.Create;
  result := FParameterList;
end;

Function TFhirValueSetExpansion.GetHasParameterList : boolean;
begin
  result := (FParameterList <> nil) and (FParameterList.count > 0);
end;

Function TFhirValueSetExpansion.GetContainsList : TFhirValueSetExpansionContainsList;
begin
  if FContainsList = nil then
    FContainsList := TFhirValueSetExpansionContainsList.Create;
  result := FContainsList;
end;

Function TFhirValueSetExpansion.GetHasContainsList : boolean;
begin
  result := (FContainsList <> nil) and (FContainsList.count > 0);
end;

function TFhirValueSetExpansion.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FIdentifier.sizeInBytes);
  inc(result, FTimestamp.sizeInBytes);
  inc(result, FTotal.sizeInBytes);
  inc(result, FOffset.sizeInBytes);
  inc(result, FparameterList.sizeInBytes);
  inc(result, FcontainsList.sizeInBytes);
end;

{ TFhirValueSetExpansionListEnumerator }

Constructor TFhirValueSetExpansionListEnumerator.Create(list : TFhirValueSetExpansionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirValueSetExpansionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirValueSetExpansionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirValueSetExpansionListEnumerator.GetCurrent : TFhirValueSetExpansion;
begin
  Result := FList[FIndex];
end;

function TFhirValueSetExpansionListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirValueSetExpansionList }
procedure TFhirValueSetExpansionList.AddItem(value: TFhirValueSetExpansion);
begin
  assert(value.ClassName = 'TFhirValueSetExpansion', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetExpansion');
  add(value);
end;

function TFhirValueSetExpansionList.Append: TFhirValueSetExpansion;
begin
  result := TFhirValueSetExpansion.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetExpansionList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetExpansionList.GetEnumerator : TFhirValueSetExpansionListEnumerator;
begin
  result := TFhirValueSetExpansionListEnumerator.Create(self.link);
end;

function TFhirValueSetExpansionList.Clone: TFhirValueSetExpansionList;
begin
  result := TFhirValueSetExpansionList(inherited Clone);
end;

function TFhirValueSetExpansionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetExpansionList.GetItemN(index: Integer): TFhirValueSetExpansion;
begin
  result := TFhirValueSetExpansion(ObjectByIndex[index]);
end;

function TFhirValueSetExpansionList.ItemClass: TFslObjectClass;
begin
  result := TFhirValueSetExpansion;
end;
function TFhirValueSetExpansionList.IndexOf(value: TFhirValueSetExpansion): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirValueSetExpansionList.Insert(index: Integer): TFhirValueSetExpansion;
begin
  result := TFhirValueSetExpansion.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetExpansionList.InsertItem(index: Integer; value: TFhirValueSetExpansion);
begin
  assert(value is TFhirValueSetExpansion);
  Inherited Insert(index, value);
end;

function TFhirValueSetExpansionList.Item(index: Integer): TFhirValueSetExpansion;
begin
  result := TFhirValueSetExpansion(ObjectByIndex[index]);
end;

function TFhirValueSetExpansionList.Link: TFhirValueSetExpansionList;
begin
  result := TFhirValueSetExpansionList(inherited Link);
end;

procedure TFhirValueSetExpansionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetExpansionList.SetItemByIndex(index: Integer; value: TFhirValueSetExpansion);
begin
  assert(value is TFhirValueSetExpansion);
  FhirValueSetExpansions[index] := value;
end;

procedure TFhirValueSetExpansionList.SetItemN(index: Integer; value: TFhirValueSetExpansion);
begin
  assert(value is TFhirValueSetExpansion);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetExpansionParameter }

constructor TFhirValueSetExpansionParameter.Create;
begin
  inherited;
end;

destructor TFhirValueSetExpansionParameter.Destroy;
begin
  FName.free;
  FValue.free;
  inherited;
end;

procedure TFhirValueSetExpansionParameter.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirValueSetExpansionParameter(oSource).nameElement.Clone;
  value := TFhirValueSetExpansionParameter(oSource).value.Clone;
end;

procedure TFhirValueSetExpansionParameter.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirValueSetExpansionParameter.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));{2}
  oList.add(TFHIRProperty.create(self, 'value[x]', 'string|boolean|integer|decimal|uri|code', false, TFhirType, FValue.Link));{2}
end;

function TFhirValueSetExpansionParameter.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue){5a};
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['String', 'Boolean', 'Integer', 'Decimal', 'Uri', 'Code'])) then
  begin
    Value := propValue as TFhirType{4};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirValueSetExpansionParameter.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirValueSetExpansionParameter.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create() {5b}
  else if (isMatchingName(propName, 'value', ['String', 'Boolean', 'Integer', 'Decimal', 'Uri', 'Code'])) then raise EFHIRException.create('Cannot make property Value'){4x}
  else result := inherited createPropertyValue(propName);
end;

function TFhirValueSetExpansionParameter.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'value[x]') then result := 'string|boolean|integer|decimal|uri|code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirValueSetExpansionParameter.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (isMatchingName(propName, 'value', ['String', 'Boolean', 'Integer', 'Decimal', 'Uri', 'Code'])) then ValueElement := nil{4x}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirValueSetExpansionParameter.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new){5b}
  else if (isMatchingName(propName, 'value', ['String', 'Boolean', 'Integer', 'Decimal', 'Uri', 'Code'])) then ValueElement := new as TFhirType{4x}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirValueSetExpansionParameter.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirValueSetExpansionParameter.fhirType : string;
begin
  result := 'parameter';
end;

function TFhirValueSetExpansionParameter.Link : TFhirValueSetExpansionParameter;
begin
  result := TFhirValueSetExpansionParameter(inherited Link);
end;

function TFhirValueSetExpansionParameter.Clone : TFhirValueSetExpansionParameter;
begin
  result := TFhirValueSetExpansionParameter(inherited Clone);
end;

function TFhirValueSetExpansionParameter.equals(other : TObject) : boolean;
var
  o : TFhirValueSetExpansionParameter;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirValueSetExpansionParameter)) then
    result := false
  else
  begin
    o := TFhirValueSetExpansionParameter(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirValueSetExpansionParameter.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FValue);
end;

procedure TFhirValueSetExpansionParameter.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('name');
  fields.add('value[x]');
end;

{ TFhirValueSetExpansionParameter }

Procedure TFhirValueSetExpansionParameter.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

Function TFhirValueSetExpansionParameter.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

Procedure TFhirValueSetExpansionParameter.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

Procedure TFhirValueSetExpansionParameter.SetValue(value : TFhirType);
begin
  FValue.free;
  FValue := value;
end;

function TFhirValueSetExpansionParameter.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FName.sizeInBytes);
  inc(result, FValue.sizeInBytes);
end;

{ TFhirValueSetExpansionParameterListEnumerator }

Constructor TFhirValueSetExpansionParameterListEnumerator.Create(list : TFhirValueSetExpansionParameterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirValueSetExpansionParameterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirValueSetExpansionParameterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirValueSetExpansionParameterListEnumerator.GetCurrent : TFhirValueSetExpansionParameter;
begin
  Result := FList[FIndex];
end;

function TFhirValueSetExpansionParameterListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirValueSetExpansionParameterList }
procedure TFhirValueSetExpansionParameterList.AddItem(value: TFhirValueSetExpansionParameter);
begin
  assert(value.ClassName = 'TFhirValueSetExpansionParameter', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetExpansionParameter');
  add(value);
end;

function TFhirValueSetExpansionParameterList.Append: TFhirValueSetExpansionParameter;
begin
  result := TFhirValueSetExpansionParameter.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetExpansionParameterList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetExpansionParameterList.GetEnumerator : TFhirValueSetExpansionParameterListEnumerator;
begin
  result := TFhirValueSetExpansionParameterListEnumerator.Create(self.link);
end;

function TFhirValueSetExpansionParameterList.Clone: TFhirValueSetExpansionParameterList;
begin
  result := TFhirValueSetExpansionParameterList(inherited Clone);
end;

function TFhirValueSetExpansionParameterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetExpansionParameterList.GetItemN(index: Integer): TFhirValueSetExpansionParameter;
begin
  result := TFhirValueSetExpansionParameter(ObjectByIndex[index]);
end;

function TFhirValueSetExpansionParameterList.ItemClass: TFslObjectClass;
begin
  result := TFhirValueSetExpansionParameter;
end;
function TFhirValueSetExpansionParameterList.IndexOf(value: TFhirValueSetExpansionParameter): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirValueSetExpansionParameterList.Insert(index: Integer): TFhirValueSetExpansionParameter;
begin
  result := TFhirValueSetExpansionParameter.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetExpansionParameterList.InsertItem(index: Integer; value: TFhirValueSetExpansionParameter);
begin
  assert(value is TFhirValueSetExpansionParameter);
  Inherited Insert(index, value);
end;

function TFhirValueSetExpansionParameterList.Item(index: Integer): TFhirValueSetExpansionParameter;
begin
  result := TFhirValueSetExpansionParameter(ObjectByIndex[index]);
end;

function TFhirValueSetExpansionParameterList.Link: TFhirValueSetExpansionParameterList;
begin
  result := TFhirValueSetExpansionParameterList(inherited Link);
end;

procedure TFhirValueSetExpansionParameterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetExpansionParameterList.SetItemByIndex(index: Integer; value: TFhirValueSetExpansionParameter);
begin
  assert(value is TFhirValueSetExpansionParameter);
  FhirValueSetExpansionParameters[index] := value;
end;

procedure TFhirValueSetExpansionParameterList.SetItemN(index: Integer; value: TFhirValueSetExpansionParameter);
begin
  assert(value is TFhirValueSetExpansionParameter);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSetExpansionContains }

constructor TFhirValueSetExpansionContains.Create;
begin
  inherited;
end;

destructor TFhirValueSetExpansionContains.Destroy;
begin
  FSystem.free;
  FAbstract.free;
  FInactive.free;
  FVersion.free;
  FCode.free;
  FDisplay.free;
  FDesignationList.Free;
  FContainsList.Free;
  inherited;
end;

procedure TFhirValueSetExpansionContains.Assign(oSource : TFslObject);
begin
  inherited;
  systemElement := TFhirValueSetExpansionContains(oSource).systemElement.Clone;
  abstractElement := TFhirValueSetExpansionContains(oSource).abstractElement.Clone;
  inactiveElement := TFhirValueSetExpansionContains(oSource).inactiveElement.Clone;
  versionElement := TFhirValueSetExpansionContains(oSource).versionElement.Clone;
  codeElement := TFhirValueSetExpansionContains(oSource).codeElement.Clone;
  displayElement := TFhirValueSetExpansionContains(oSource).displayElement.Clone;
  if (TFhirValueSetExpansionContains(oSource).FDesignationList = nil) then
  begin
    FDesignationList.free;
    FDesignationList := nil;
  end
  else
  begin
    if FDesignationList = nil then
      FDesignationList := TFhirValueSetComposeIncludeConceptDesignationList.Create;
    FDesignationList.Assign(TFhirValueSetExpansionContains(oSource).FDesignationList);
  end;
  if (TFhirValueSetExpansionContains(oSource).FContainsList = nil) then
  begin
    FContainsList.free;
    FContainsList := nil;
  end
  else
  begin
    if FContainsList = nil then
      FContainsList := TFhirValueSetExpansionContainsList.Create;
    FContainsList.Assign(TFhirValueSetExpansionContains(oSource).FContainsList);
  end;
end;

procedure TFhirValueSetExpansionContains.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'system') Then
     list.add(self.link, 'system', FSystem.Link);
  if (child_name = 'abstract') Then
     list.add(self.link, 'abstract', FAbstract.Link);
  if (child_name = 'inactive') Then
     list.add(self.link, 'inactive', FInactive.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'display') Then
     list.add(self.link, 'display', FDisplay.Link);
  if (child_name = 'designation') Then
    list.addAll(self, 'designation', FDesignationList);
  if (child_name = 'contains') Then
    list.addAll(self, 'contains', FContainsList);
end;

procedure TFhirValueSetExpansionContains.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'system', 'uri', false, TFhirUri, FSystem.Link));{2}
  oList.add(TFHIRProperty.create(self, 'abstract', 'boolean', false, TFhirBoolean, FAbstract.Link));{2}
  oList.add(TFHIRProperty.create(self, 'inactive', 'boolean', false, TFhirBoolean, FInactive.Link));{2}
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));{2}
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirCode, FCode.Link));{2}
  oList.add(TFHIRProperty.create(self, 'display', 'string', false, TFhirString, FDisplay.Link));{2}
  oList.add(TFHIRProperty.create(self, 'designation', '@ValueSet.compose.include.concept.designation', true, TFhirValueSetComposeIncludeConceptDesignation, FDesignationList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'contains', '@ValueSet.expansion.contains', true, TFhirValueSetExpansionContains, FContainsList.Link)){3};
end;

function TFhirValueSetExpansionContains.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'system') then
  begin
    SystemElement := asUri(propValue){5a};
    result := propValue;
  end
  else if (propName = 'abstract') then
  begin
    AbstractElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'inactive') then
  begin
    InactiveElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'display') then
  begin
    DisplayElement := asString(propValue){5a};
    result := propValue;
  end
  else if (propName = 'designation') then
  begin
    DesignationList.add(propValue as TFhirValueSetComposeIncludeConceptDesignation){2a};
    result := propValue;
  end
  else if (propName = 'contains') then
  begin
    ContainsList.add(propValue as TFhirValueSetExpansionContains){2a};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirValueSetExpansionContains.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'designation') then DesignationList.insertItem(index, propValue as TFhirValueSetComposeIncludeConceptDesignation){2a}
  else if (propName = 'contains') then ContainsList.insertItem(index, propValue as TFhirValueSetExpansionContains){2a}
  else inherited;
end;

function TFhirValueSetExpansionContains.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'system') then result := TFhirUri.create() {5b}
  else if (propName = 'abstract') then result := TFhirBoolean.create() {5b}
  else if (propName = 'inactive') then result := TFhirBoolean.create() {5b}
  else if (propName = 'version') then result := TFhirString.create() {5b}
  else if (propName = 'code') then result := TFhirCode.create() {5b}
  else if (propName = 'display') then result := TFhirString.create() {5b}
  else if (propName = 'designation') then result := DesignationList.new(){2}
  else if (propName = 'contains') then result := ContainsList.new(){2}
  else result := inherited createPropertyValue(propName);
end;

function TFhirValueSetExpansionContains.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'system') then result := 'uri'
  else if (propName = 'abstract') then result := 'boolean'
  else if (propName = 'inactive') then result := 'boolean'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'code') then result := 'code'
  else if (propName = 'display') then result := 'string'
  else if (propName = 'designation') then result := '@ValueSet.compose.include.concept.designation'
  else if (propName = 'contains') then result := '@ValueSet.expansion.contains'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirValueSetExpansionContains.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'system') then SystemElement := nil
  else if (propName = 'abstract') then AbstractElement := nil
  else if (propName = 'inactive') then InactiveElement := nil
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'display') then DisplayElement := nil
  else if (propName = 'designation') then deletePropertyValue('designation', DesignationList, value) {2}
  else if (propName = 'contains') then deletePropertyValue('contains', ContainsList, value) {2}
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirValueSetExpansionContains.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'system') then SystemElement := asUri(new){5b}
  else if (propName = 'abstract') then AbstractElement := asBoolean(new){5b}
  else if (propName = 'inactive') then InactiveElement := asBoolean(new){5b}
  else if (propName = 'version') then VersionElement := asString(new){5b}
  else if (propName = 'code') then CodeElement := asCode(new){5b}
  else if (propName = 'display') then DisplayElement := asString(new){5b}
  else if (propName = 'designation') then replacePropertyValue('designation', DesignationList, existing, new) {2}
  else if (propName = 'contains') then replacePropertyValue('contains', ContainsList, existing, new) {2}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirValueSetExpansionContains.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'designation') then DesignationList.move(source, destination){2a}
  else if (propName = 'contains') then ContainsList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirValueSetExpansionContains.fhirType : string;
begin
  result := 'contains';
end;

function TFhirValueSetExpansionContains.Link : TFhirValueSetExpansionContains;
begin
  result := TFhirValueSetExpansionContains(inherited Link);
end;

function TFhirValueSetExpansionContains.Clone : TFhirValueSetExpansionContains;
begin
  result := TFhirValueSetExpansionContains(inherited Clone);
end;

function TFhirValueSetExpansionContains.equals(other : TObject) : boolean;
var
  o : TFhirValueSetExpansionContains;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirValueSetExpansionContains)) then
    result := false
  else
  begin
    o := TFhirValueSetExpansionContains(other);
    result := compareDeep(systemElement, o.systemElement, true) and compareDeep(abstractElement, o.abstractElement, true) and
      compareDeep(inactiveElement, o.inactiveElement, true) and compareDeep(versionElement, o.versionElement, true) and
      compareDeep(codeElement, o.codeElement, true) and compareDeep(displayElement, o.displayElement, true) and
      compareDeep(designationList, o.designationList, true) and compareDeep(containsList, o.containsList, true);
  end;
end;

function TFhirValueSetExpansionContains.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSystem) and isEmptyProp(FAbstract) and isEmptyProp(FInactive) and isEmptyProp(FVersion) and isEmptyProp(FCode) and isEmptyProp(FDisplay) and isEmptyProp(FdesignationList) and isEmptyProp(FcontainsList);
end;

procedure TFhirValueSetExpansionContains.listFieldsInOrder(fields : TStringList);
begin
  listBackboneElementFieldsInOrder(fields);
  fields.add('system');
  fields.add('abstract');
  fields.add('inactive');
  fields.add('version');
  fields.add('code');
  fields.add('display');
  fields.add('designation');
  fields.add('contains');
end;

{ TFhirValueSetExpansionContains }

Procedure TFhirValueSetExpansionContains.SetSystem(value : TFhirUri);
begin
  FSystem.free;
  FSystem := value;
end;

Function TFhirValueSetExpansionContains.GetSystemST : String;
begin
  if FSystem = nil then
    result := ''
  else
    result := FSystem.value;
end;

Procedure TFhirValueSetExpansionContains.SetSystemST(value : String);
begin
  if value <> '' then
  begin
    if FSystem = nil then
      FSystem := TFhirUri.create;
    FSystem.value := value
  end
  else if FSystem <> nil then
    FSystem.value := '';
end;

Procedure TFhirValueSetExpansionContains.SetAbstract(value : TFhirBoolean);
begin
  FAbstract.free;
  FAbstract := value;
end;

Function TFhirValueSetExpansionContains.GetAbstractST : Boolean;
begin
  if FAbstract = nil then
    result := false
  else
    result := FAbstract.value;
end;

Procedure TFhirValueSetExpansionContains.SetAbstractST(value : Boolean);
begin
  if FAbstract = nil then
    FAbstract := TFhirBoolean.create;
  FAbstract.value := value
end;

Procedure TFhirValueSetExpansionContains.SetInactive(value : TFhirBoolean);
begin
  FInactive.free;
  FInactive := value;
end;

Function TFhirValueSetExpansionContains.GetInactiveST : Boolean;
begin
  if FInactive = nil then
    result := false
  else
    result := FInactive.value;
end;

Procedure TFhirValueSetExpansionContains.SetInactiveST(value : Boolean);
begin
  if FInactive = nil then
    FInactive := TFhirBoolean.create;
  FInactive.value := value
end;

Procedure TFhirValueSetExpansionContains.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

Function TFhirValueSetExpansionContains.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

Procedure TFhirValueSetExpansionContains.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

Procedure TFhirValueSetExpansionContains.SetCode(value : TFhirCode);
begin
  FCode.free;
  FCode := value;
end;

Function TFhirValueSetExpansionContains.GetCodeST : String;
begin
  if FCode = nil then
    result := ''
  else
    result := FCode.value;
end;

Procedure TFhirValueSetExpansionContains.SetCodeST(value : String);
begin
  if value <> '' then
  begin
    if FCode = nil then
      FCode := TFhirCode.create;
    FCode.value := value
  end
  else if FCode <> nil then
    FCode.value := '';
end;

Procedure TFhirValueSetExpansionContains.SetDisplay(value : TFhirString);
begin
  FDisplay.free;
  FDisplay := value;
end;

Function TFhirValueSetExpansionContains.GetDisplayST : String;
begin
  if FDisplay = nil then
    result := ''
  else
    result := FDisplay.value;
end;

Procedure TFhirValueSetExpansionContains.SetDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FDisplay = nil then
      FDisplay := TFhirString.create;
    FDisplay.value := value
  end
  else if FDisplay <> nil then
    FDisplay.value := '';
end;

Function TFhirValueSetExpansionContains.GetDesignationList : TFhirValueSetComposeIncludeConceptDesignationList;
begin
  if FDesignationList = nil then
    FDesignationList := TFhirValueSetComposeIncludeConceptDesignationList.Create;
  result := FDesignationList;
end;

Function TFhirValueSetExpansionContains.GetHasDesignationList : boolean;
begin
  result := (FDesignationList <> nil) and (FDesignationList.count > 0);
end;

Function TFhirValueSetExpansionContains.GetContainsList : TFhirValueSetExpansionContainsList;
begin
  if FContainsList = nil then
    FContainsList := TFhirValueSetExpansionContainsList.Create;
  result := FContainsList;
end;

Function TFhirValueSetExpansionContains.GetHasContainsList : boolean;
begin
  result := (FContainsList <> nil) and (FContainsList.count > 0);
end;

function TFhirValueSetExpansionContains.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FSystem.sizeInBytes);
  inc(result, FAbstract.sizeInBytes);
  inc(result, FInactive.sizeInBytes);
  inc(result, FVersion.sizeInBytes);
  inc(result, FCode.sizeInBytes);
  inc(result, FDisplay.sizeInBytes);
  inc(result, FdesignationList.sizeInBytes);
  inc(result, FcontainsList.sizeInBytes);
end;

{ TFhirValueSetExpansionContainsListEnumerator }

Constructor TFhirValueSetExpansionContainsListEnumerator.Create(list : TFhirValueSetExpansionContainsList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirValueSetExpansionContainsListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirValueSetExpansionContainsListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirValueSetExpansionContainsListEnumerator.GetCurrent : TFhirValueSetExpansionContains;
begin
  Result := FList[FIndex];
end;

function TFhirValueSetExpansionContainsListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirValueSetExpansionContainsList }
procedure TFhirValueSetExpansionContainsList.AddItem(value: TFhirValueSetExpansionContains);
begin
  assert(value.ClassName = 'TFhirValueSetExpansionContains', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSetExpansionContains');
  add(value);
end;

function TFhirValueSetExpansionContainsList.Append: TFhirValueSetExpansionContains;
begin
  result := TFhirValueSetExpansionContains.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetExpansionContainsList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetExpansionContainsList.GetEnumerator : TFhirValueSetExpansionContainsListEnumerator;
begin
  result := TFhirValueSetExpansionContainsListEnumerator.Create(self.link);
end;

function TFhirValueSetExpansionContainsList.Clone: TFhirValueSetExpansionContainsList;
begin
  result := TFhirValueSetExpansionContainsList(inherited Clone);
end;

function TFhirValueSetExpansionContainsList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetExpansionContainsList.GetItemN(index: Integer): TFhirValueSetExpansionContains;
begin
  result := TFhirValueSetExpansionContains(ObjectByIndex[index]);
end;

function TFhirValueSetExpansionContainsList.ItemClass: TFslObjectClass;
begin
  result := TFhirValueSetExpansionContains;
end;
function TFhirValueSetExpansionContainsList.IndexOf(value: TFhirValueSetExpansionContains): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirValueSetExpansionContainsList.Insert(index: Integer): TFhirValueSetExpansionContains;
begin
  result := TFhirValueSetExpansionContains.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetExpansionContainsList.InsertItem(index: Integer; value: TFhirValueSetExpansionContains);
begin
  assert(value is TFhirValueSetExpansionContains);
  Inherited Insert(index, value);
end;

function TFhirValueSetExpansionContainsList.Item(index: Integer): TFhirValueSetExpansionContains;
begin
  result := TFhirValueSetExpansionContains(ObjectByIndex[index]);
end;

function TFhirValueSetExpansionContainsList.Link: TFhirValueSetExpansionContainsList;
begin
  result := TFhirValueSetExpansionContainsList(inherited Link);
end;

procedure TFhirValueSetExpansionContainsList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetExpansionContainsList.SetItemByIndex(index: Integer; value: TFhirValueSetExpansionContains);
begin
  assert(value is TFhirValueSetExpansionContains);
  FhirValueSetExpansionContains[index] := value;
end;

procedure TFhirValueSetExpansionContainsList.SetItemN(index: Integer; value: TFhirValueSetExpansionContains);
begin
  assert(value is TFhirValueSetExpansionContains);
  ObjectByIndex[index] := value;
end;

{ TFhirValueSet }

constructor TFhirValueSet.Create;
begin
  inherited;
end;

destructor TFhirValueSet.Destroy;
begin
  FIdentifierList.Free;
  FImmutable.free;
  FPurpose.free;
  FCopyright.free;
  FExtensible.free;
  FCompose.free;
  FExpansion.free;
  inherited;
end;

function TFhirValueSet.GetResourceType : TFhirResourceType;
begin
  result := frtValueSet;
end;

procedure TFhirValueSet.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirValueSet(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirValueSet(oSource).FIdentifierList);
  end;
  immutableElement := TFhirValueSet(oSource).immutableElement.Clone;
  purposeElement := TFhirValueSet(oSource).purposeElement.Clone;
  copyrightElement := TFhirValueSet(oSource).copyrightElement.Clone;
  extensibleElement := TFhirValueSet(oSource).extensibleElement.Clone;
  compose := TFhirValueSet(oSource).compose.Clone;
  expansion := TFhirValueSet(oSource).expansion.Clone;
end;

procedure TFhirValueSet.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'immutable') Then
     list.add(self.link, 'immutable', FImmutable.Link);
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'extensible') Then
     list.add(self.link, 'extensible', FExtensible.Link);
  if (child_name = 'compose') Then
     list.add(self.link, 'compose', FCompose.Link);
  if (child_name = 'expansion') Then
     list.add(self.link, 'expansion', FExpansion.Link);
end;

procedure TFhirValueSet.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link)){3};
  oList.add(TFHIRProperty.create(self, 'immutable', 'boolean', false, TFhirBoolean, FImmutable.Link));{2}
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));{2}
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));{2}
  oList.add(TFHIRProperty.create(self, 'extensible', 'boolean', false, TFhirBoolean, FExtensible.Link));{2}
  oList.add(TFHIRProperty.create(self, 'compose', '', false, TFhirValueSetCompose, FCompose.Link));{2}
  oList.add(TFHIRProperty.create(self, 'expansion', '', false, TFhirValueSetExpansion, FExpansion.Link));{2}
end;

function TFhirValueSet.setProperty(propName: string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier){2a};
    result := propValue;
  end
  else if (propName = 'immutable') then
  begin
    ImmutableElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue){5a};
    result := propValue;
  end
  else if (propName = 'extensible') then
  begin
    ExtensibleElement := asBoolean(propValue){5a};
    result := propValue;
  end
  else if (propName = 'compose') then
  begin
    Compose := propValue as TFhirValueSetCompose{4b};
    result := propValue;
  end
  else if (propName = 'expansion') then
  begin
    Expansion := propValue as TFhirValueSetExpansion{4b};
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);;
end;

procedure TFhirValueSet.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier){2a}
  else inherited;
end;

function TFhirValueSet.createPropertyValue(propName: string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new(){2}
  else if (propName = 'immutable') then result := TFhirBoolean.create() {5b}
  else if (propName = 'purpose') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'copyright') then result := TFhirMarkdown.create() {5b}
  else if (propName = 'extensible') then result := TFhirBoolean.create() {5b}
  else if (propName = 'compose') then result := TFhirValueSetCompose.create(){4b}
  else if (propName = 'expansion') then result := TFhirValueSetExpansion.create(){4b}
  else result := inherited createPropertyValue(propName);
end;

function TFhirValueSet.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'immutable') then result := 'boolean'
  else if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'extensible') then result := 'boolean'
  else if (propName = 'compose') then result := ''
  else if (propName = 'expansion') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirValueSet.deleteProperty(propName : string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value) {2}
  else if (propName = 'immutable') then ImmutableElement := nil
  else if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'extensible') then ExtensibleElement := nil
  else if (propName = 'compose') then ComposeElement := nil
  else if (propName = 'expansion') then ExpansionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirValueSet.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new) {2}
  else if (propName = 'immutable') then ImmutableElement := asBoolean(new){5b}
  else if (propName = 'purpose') then PurposeElement := asMarkdown(new){5b}
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new){5b}
  else if (propName = 'extensible') then ExtensibleElement := asBoolean(new){5b}
  else if (propName = 'compose') then ComposeElement := new as TFhirValueSetCompose{4}
  else if (propName = 'expansion') then ExpansionElement := new as TFhirValueSetExpansion{4}
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirValueSet.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination){2a}
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirValueSet.fhirType : string;
begin
  result := 'ValueSet';
end;

function TFhirValueSet.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FImmutable) and isEmptyProp(FPurpose) and isEmptyProp(FCopyright) and isEmptyProp(FExtensible) and isEmptyProp(FCompose) and isEmptyProp(FExpansion);
end;

function TFhirValueSet.equals(other : TObject) : boolean;
var
  o : TFhirValueSet;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirValueSet)) then
    result := false
  else
  begin
    o := TFhirValueSet(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(immutableElement, o.immutableElement, true) and
      compareDeep(purposeElement, o.purposeElement, true) and compareDeep(copyrightElement, o.copyrightElement, true) and
      compareDeep(extensibleElement, o.extensibleElement, true) and compareDeep(composeElement, o.composeElement, true) and
      compareDeep(expansionElement, o.expansionElement, true);
  end;
end;

function TFhirValueSet.Link : TFhirValueSet;
begin
  result := TFhirValueSet(inherited Link);
end;

function TFhirValueSet.Clone : TFhirValueSet;
begin
  result := TFhirValueSet(inherited Clone);
end;

procedure TFhirValueSet.listFieldsInOrder(fields : TStringList);
begin
  listDomainResourceFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('status');
  fields.add('experimental');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('immutable');
  fields.add('purpose');
  fields.add('copyright');
  fields.add('extensible');
  fields.add('compose');
  fields.add('expansion');
end;

{ TFhirValueSet }

Function TFhirValueSet.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

Function TFhirValueSet.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

Procedure TFhirValueSet.SetImmutable(value : TFhirBoolean);
begin
  FImmutable.free;
  FImmutable := value;
end;

Function TFhirValueSet.GetImmutableST : Boolean;
begin
  if FImmutable = nil then
    result := false
  else
    result := FImmutable.value;
end;

Procedure TFhirValueSet.SetImmutableST(value : Boolean);
begin
  if FImmutable = nil then
    FImmutable := TFhirBoolean.create;
  FImmutable.value := value
end;

Procedure TFhirValueSet.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

Function TFhirValueSet.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

Procedure TFhirValueSet.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

Procedure TFhirValueSet.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

Function TFhirValueSet.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

Procedure TFhirValueSet.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

Procedure TFhirValueSet.SetExtensible(value : TFhirBoolean);
begin
  FExtensible.free;
  FExtensible := value;
end;

Function TFhirValueSet.GetExtensibleST : Boolean;
begin
  if FExtensible = nil then
    result := false
  else
    result := FExtensible.value;
end;

Procedure TFhirValueSet.SetExtensibleST(value : Boolean);
begin
  if FExtensible = nil then
    FExtensible := TFhirBoolean.create;
  FExtensible.value := value
end;

Procedure TFhirValueSet.SetCompose(value : TFhirValueSetCompose);
begin
  FCompose.free;
  FCompose := value;
end;

Procedure TFhirValueSet.SetExpansion(value : TFhirValueSetExpansion);
begin
  FExpansion.free;
  FExpansion := value;
end;

function TFhirValueSet.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FidentifierList.sizeInBytes);
  inc(result, FImmutable.sizeInBytes);
  inc(result, FPurpose.sizeInBytes);
  inc(result, FCopyright.sizeInBytes);
  inc(result, FExtensible.sizeInBytes);
  inc(result, FCompose.sizeInBytes);
  inc(result, FExpansion.sizeInBytes);
end;

{ TFhirValueSetListEnumerator }

Constructor TFhirValueSetListEnumerator.Create(list : TFhirValueSetList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirValueSetListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirValueSetListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirValueSetListEnumerator.GetCurrent : TFhirValueSet;
begin
  Result := FList[FIndex];
end;

function TFhirValueSetListEnumerator.sizeInBytesV : cardinal;
begin
  result := inherited sizeInBytesV;
  inc(result, FList.sizeInBytes);
end;

{ TFhirValueSetList }
procedure TFhirValueSetList.AddItem(value: TFhirValueSet);
begin
  assert(value.ClassName = 'TFhirValueSet', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirValueSet');
  add(value);
end;

function TFhirValueSetList.Append: TFhirValueSet;
begin
  result := TFhirValueSet.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetList.ClearItems;
begin
  Clear;
end;

function TFhirValueSetList.GetEnumerator : TFhirValueSetListEnumerator;
begin
  result := TFhirValueSetListEnumerator.Create(self.link);
end;

function TFhirValueSetList.Clone: TFhirValueSetList;
begin
  result := TFhirValueSetList(inherited Clone);
end;

function TFhirValueSetList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirValueSetList.GetItemN(index: Integer): TFhirValueSet;
begin
  result := TFhirValueSet(ObjectByIndex[index]);
end;

function TFhirValueSetList.ItemClass: TFslObjectClass;
begin
  result := TFhirValueSet;
end;
function TFhirValueSetList.IndexOf(value: TFhirValueSet): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirValueSetList.Insert(index: Integer): TFhirValueSet;
begin
  result := TFhirValueSet.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirValueSetList.InsertItem(index: Integer; value: TFhirValueSet);
begin
  assert(value is TFhirValueSet);
  Inherited Insert(index, value);
end;

function TFhirValueSetList.Item(index: Integer): TFhirValueSet;
begin
  result := TFhirValueSet(ObjectByIndex[index]);
end;

function TFhirValueSetList.Link: TFhirValueSetList;
begin
  result := TFhirValueSetList(inherited Link);
end;

procedure TFhirValueSetList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirValueSetList.SetItemByIndex(index: Integer; value: TFhirValueSet);
begin
  assert(value is TFhirValueSet);
  FhirValueSets[index] := value;
end;

procedure TFhirValueSetList.SetItemN(index: Integer; value: TFhirValueSet);
begin
  assert(value is TFhirValueSet);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_VALUESET}

end.

